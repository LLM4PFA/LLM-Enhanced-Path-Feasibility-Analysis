[
    {
        "var_name": "buf.bn",
        "function_name": "BN_nist_mod_224",
        "location": {
            "file_path": "crypto/bn/bn_nist.c",
            "region": {
                "startLine": 599,
                "startColumn": 27,
                "endColumn": 56
            },
            "context": {
                "startLine": 597,
                "endLine": 601,
                "snippet": {
                    "text": "        nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);"
                }
            }
        },
        "function_code": "int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\n                    BN_CTX *ctx)\n{\n    int top = a->top, i;\n    int carry;\n    BN_ULONG *r_d, *a_d = a->d;\n    union {\n        BN_ULONG bn[BN_NIST_224_TOP];\n        unsigned int ui[BN_NIST_224_TOP * sizeof(BN_ULONG) /\n                        sizeof(unsigned int)];\n    } buf;\n    BN_ULONG c_d[BN_NIST_224_TOP], *res;\n    bn_addsub_f adjust;\n    static const BIGNUM ossl_bignum_nist_p_224_sqr = {\n        (BN_ULONG *)_nist_p_224_sqr,\n        OSSL_NELEM(_nist_p_224_sqr),\n        OSSL_NELEM(_nist_p_224_sqr),\n        0, BN_FLG_STATIC_DATA\n    };\n\n    field = &ossl_bignum_nist_p_224; /* just to make sure */\n\n    if (BN_is_negative(a) || BN_ucmp(a, &ossl_bignum_nist_p_224_sqr) >= 0)\n        return BN_nnmod(r, a, field, ctx);\n\n    i = BN_ucmp(field, a);\n    if (i == 0) {\n        BN_zero(r);\n        return 1;\n    } else if (i > 0)\n        return (r == a) ? 1 : (BN_copy(r, a) != NULL);\n\n    if (r != a) {\n        if (!bn_wexpand(r, BN_NIST_224_TOP))\n            return 0;\n        r_d = r->d;\n        nist_cp_bn(r_d, a_d, BN_NIST_224_TOP);\n    } else\n        r_d = a_d;\n\n#if BN_BITS2==64\n    /* copy upper 256 bits of 448 bit number ... */\n    nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP - 1),\n                 top - (BN_NIST_224_TOP - 1), BN_NIST_224_TOP);\n    /* ... and right shift by 32 to obtain upper 224 bits */\n    nist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);\n    /* truncate lower part to 224 bits too */\n    r_d[BN_NIST_224_TOP - 1] &= BN_MASK2l;\n#else\n    nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP,\n                 BN_NIST_224_TOP);\n#endif\n\n#if defined(NIST_INT64) && BN_BITS2!=64\n    {\n        NIST_INT64 acc;         /* accumulator */\n        unsigned int *rp = (unsigned int *)r_d;\n        const unsigned int *bp = (const unsigned int *)buf.ui;\n\n        acc = rp[0];\n        acc -= bp[7 - 7];\n        acc -= bp[11 - 7];\n        rp[0] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[1];\n        acc -= bp[8 - 7];\n        acc -= bp[12 - 7];\n        rp[1] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[2];\n        acc -= bp[9 - 7];\n        acc -= bp[13 - 7];\n        rp[2] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[3];\n        acc += bp[7 - 7];\n        acc += bp[11 - 7];\n        acc -= bp[10 - 7];\n        rp[3] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[4];\n        acc += bp[8 - 7];\n        acc += bp[12 - 7];\n        acc -= bp[11 - 7];\n        rp[4] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[5];\n        acc += bp[9 - 7];\n        acc += bp[13 - 7];\n        acc -= bp[12 - 7];\n        rp[5] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[6];\n        acc += bp[10 - 7];\n        acc -= bp[13 - 7];\n        rp[6] = (unsigned int)acc;\n\n        carry = (int)(acc >> 32);\n# if BN_BITS2==64\n        rp[7] = carry;\n# endif\n    }\n#else\n    {\n        BN_ULONG t_d[BN_NIST_224_TOP];\n\n        nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);\n        carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);\n        carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);\n        carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);\n        carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n\n# if BN_BITS2==64\n        carry = (int)(r_d[BN_NIST_224_TOP - 1] >> 32);\n# endif\n    }\n#endif\n    adjust = bn_sub_words;\n    if (carry > 0) {\n        carry =\n            (int)bn_sub_words(r_d, r_d, _nist_p_224[carry - 1],\n                              BN_NIST_224_TOP);\n#if BN_BITS2==64\n        carry = (int)(~(r_d[BN_NIST_224_TOP - 1] >> 32)) & 1;\n#endif\n    } else if (carry < 0) {\n        /*\n         * it's a bit more complicated logic in this case. if bn_add_words\n         * yields no carry, then result has to be adjusted by unconditionally\n         * *adding* the modulus. but if it does, then result has to be\n         * compared to the modulus and conditionally adjusted by\n         * *subtracting* the latter.\n         */\n        carry =\n            (int)bn_add_words(r_d, r_d, _nist_p_224[-carry - 1],\n                              BN_NIST_224_TOP);\n        adjust = carry ? bn_sub_words : bn_add_words;\n    } else\n        carry = 1;\n\n    /* otherwise it's effectively same as in BN_nist_mod_192... */\n    res = ((*adjust) (c_d, r_d, _nist_p_224[0], BN_NIST_224_TOP) && carry)\n        ? r_d\n        : c_d;\n    nist_cp_bn(r_d, res, BN_NIST_224_TOP);\n    r->top = BN_NIST_224_TOP;\n    bn_correct_top(r);\n\n    return 1;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses a negative index -3 on the [array](1)."
    },
    {
        "var_name": "buf.bn",
        "function_name": "BN_nist_mod_224",
        "location": {
            "file_path": "crypto/bn/bn_nist.c",
            "region": {
                "startLine": 601,
                "startColumn": 27,
                "endColumn": 58
            },
            "context": {
                "startLine": 599,
                "endLine": 603,
                "snippet": {
                    "text": "        nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);"
                }
            }
        },
        "function_code": "int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\n                    BN_CTX *ctx)\n{\n    int top = a->top, i;\n    int carry;\n    BN_ULONG *r_d, *a_d = a->d;\n    union {\n        BN_ULONG bn[BN_NIST_224_TOP];\n        unsigned int ui[BN_NIST_224_TOP * sizeof(BN_ULONG) /\n                        sizeof(unsigned int)];\n    } buf;\n    BN_ULONG c_d[BN_NIST_224_TOP], *res;\n    bn_addsub_f adjust;\n    static const BIGNUM ossl_bignum_nist_p_224_sqr = {\n        (BN_ULONG *)_nist_p_224_sqr,\n        OSSL_NELEM(_nist_p_224_sqr),\n        OSSL_NELEM(_nist_p_224_sqr),\n        0, BN_FLG_STATIC_DATA\n    };\n\n    field = &ossl_bignum_nist_p_224; /* just to make sure */\n\n    if (BN_is_negative(a) || BN_ucmp(a, &ossl_bignum_nist_p_224_sqr) >= 0)\n        return BN_nnmod(r, a, field, ctx);\n\n    i = BN_ucmp(field, a);\n    if (i == 0) {\n        BN_zero(r);\n        return 1;\n    } else if (i > 0)\n        return (r == a) ? 1 : (BN_copy(r, a) != NULL);\n\n    if (r != a) {\n        if (!bn_wexpand(r, BN_NIST_224_TOP))\n            return 0;\n        r_d = r->d;\n        nist_cp_bn(r_d, a_d, BN_NIST_224_TOP);\n    } else\n        r_d = a_d;\n\n#if BN_BITS2==64\n    /* copy upper 256 bits of 448 bit number ... */\n    nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP - 1),\n                 top - (BN_NIST_224_TOP - 1), BN_NIST_224_TOP);\n    /* ... and right shift by 32 to obtain upper 224 bits */\n    nist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);\n    /* truncate lower part to 224 bits too */\n    r_d[BN_NIST_224_TOP - 1] &= BN_MASK2l;\n#else\n    nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP,\n                 BN_NIST_224_TOP);\n#endif\n\n#if defined(NIST_INT64) && BN_BITS2!=64\n    {\n        NIST_INT64 acc;         /* accumulator */\n        unsigned int *rp = (unsigned int *)r_d;\n        const unsigned int *bp = (const unsigned int *)buf.ui;\n\n        acc = rp[0];\n        acc -= bp[7 - 7];\n        acc -= bp[11 - 7];\n        rp[0] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[1];\n        acc -= bp[8 - 7];\n        acc -= bp[12 - 7];\n        rp[1] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[2];\n        acc -= bp[9 - 7];\n        acc -= bp[13 - 7];\n        rp[2] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[3];\n        acc += bp[7 - 7];\n        acc += bp[11 - 7];\n        acc -= bp[10 - 7];\n        rp[3] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[4];\n        acc += bp[8 - 7];\n        acc += bp[12 - 7];\n        acc -= bp[11 - 7];\n        rp[4] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[5];\n        acc += bp[9 - 7];\n        acc += bp[13 - 7];\n        acc -= bp[12 - 7];\n        rp[5] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[6];\n        acc += bp[10 - 7];\n        acc -= bp[13 - 7];\n        rp[6] = (unsigned int)acc;\n\n        carry = (int)(acc >> 32);\n# if BN_BITS2==64\n        rp[7] = carry;\n# endif\n    }\n#else\n    {\n        BN_ULONG t_d[BN_NIST_224_TOP];\n\n        nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);\n        carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);\n        carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);\n        carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);\n        carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n\n# if BN_BITS2==64\n        carry = (int)(r_d[BN_NIST_224_TOP - 1] >> 32);\n# endif\n    }\n#endif\n    adjust = bn_sub_words;\n    if (carry > 0) {\n        carry =\n            (int)bn_sub_words(r_d, r_d, _nist_p_224[carry - 1],\n                              BN_NIST_224_TOP);\n#if BN_BITS2==64\n        carry = (int)(~(r_d[BN_NIST_224_TOP - 1] >> 32)) & 1;\n#endif\n    } else if (carry < 0) {\n        /*\n         * it's a bit more complicated logic in this case. if bn_add_words\n         * yields no carry, then result has to be adjusted by unconditionally\n         * *adding* the modulus. but if it does, then result has to be\n         * compared to the modulus and conditionally adjusted by\n         * *subtracting* the latter.\n         */\n        carry =\n            (int)bn_add_words(r_d, r_d, _nist_p_224[-carry - 1],\n                              BN_NIST_224_TOP);\n        adjust = carry ? bn_sub_words : bn_add_words;\n    } else\n        carry = 1;\n\n    /* otherwise it's effectively same as in BN_nist_mod_192... */\n    res = ((*adjust) (c_d, r_d, _nist_p_224[0], BN_NIST_224_TOP) && carry)\n        ? r_d\n        : c_d;\n    nist_cp_bn(r_d, res, BN_NIST_224_TOP);\n    r->top = BN_NIST_224_TOP;\n    bn_correct_top(r);\n\n    return 1;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses a negative index -3 on the [array](1)."
    },
    {
        "var_name": "buf.bn",
        "function_name": "BN_nist_mod_224",
        "location": {
            "file_path": "crypto/bn/bn_nist.c",
            "region": {
                "startLine": 605,
                "startColumn": 27,
                "endColumn": 58
            },
            "context": {
                "startLine": 603,
                "endLine": 607,
                "snippet": {
                    "text": "        nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);"
                }
            }
        },
        "function_code": "int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\n                    BN_CTX *ctx)\n{\n    int top = a->top, i;\n    int carry;\n    BN_ULONG *r_d, *a_d = a->d;\n    union {\n        BN_ULONG bn[BN_NIST_224_TOP];\n        unsigned int ui[BN_NIST_224_TOP * sizeof(BN_ULONG) /\n                        sizeof(unsigned int)];\n    } buf;\n    BN_ULONG c_d[BN_NIST_224_TOP], *res;\n    bn_addsub_f adjust;\n    static const BIGNUM ossl_bignum_nist_p_224_sqr = {\n        (BN_ULONG *)_nist_p_224_sqr,\n        OSSL_NELEM(_nist_p_224_sqr),\n        OSSL_NELEM(_nist_p_224_sqr),\n        0, BN_FLG_STATIC_DATA\n    };\n\n    field = &ossl_bignum_nist_p_224; /* just to make sure */\n\n    if (BN_is_negative(a) || BN_ucmp(a, &ossl_bignum_nist_p_224_sqr) >= 0)\n        return BN_nnmod(r, a, field, ctx);\n\n    i = BN_ucmp(field, a);\n    if (i == 0) {\n        BN_zero(r);\n        return 1;\n    } else if (i > 0)\n        return (r == a) ? 1 : (BN_copy(r, a) != NULL);\n\n    if (r != a) {\n        if (!bn_wexpand(r, BN_NIST_224_TOP))\n            return 0;\n        r_d = r->d;\n        nist_cp_bn(r_d, a_d, BN_NIST_224_TOP);\n    } else\n        r_d = a_d;\n\n#if BN_BITS2==64\n    /* copy upper 256 bits of 448 bit number ... */\n    nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP - 1),\n                 top - (BN_NIST_224_TOP - 1), BN_NIST_224_TOP);\n    /* ... and right shift by 32 to obtain upper 224 bits */\n    nist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);\n    /* truncate lower part to 224 bits too */\n    r_d[BN_NIST_224_TOP - 1] &= BN_MASK2l;\n#else\n    nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP,\n                 BN_NIST_224_TOP);\n#endif\n\n#if defined(NIST_INT64) && BN_BITS2!=64\n    {\n        NIST_INT64 acc;         /* accumulator */\n        unsigned int *rp = (unsigned int *)r_d;\n        const unsigned int *bp = (const unsigned int *)buf.ui;\n\n        acc = rp[0];\n        acc -= bp[7 - 7];\n        acc -= bp[11 - 7];\n        rp[0] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[1];\n        acc -= bp[8 - 7];\n        acc -= bp[12 - 7];\n        rp[1] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[2];\n        acc -= bp[9 - 7];\n        acc -= bp[13 - 7];\n        rp[2] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[3];\n        acc += bp[7 - 7];\n        acc += bp[11 - 7];\n        acc -= bp[10 - 7];\n        rp[3] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[4];\n        acc += bp[8 - 7];\n        acc += bp[12 - 7];\n        acc -= bp[11 - 7];\n        rp[4] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[5];\n        acc += bp[9 - 7];\n        acc += bp[13 - 7];\n        acc -= bp[12 - 7];\n        rp[5] = (unsigned int)acc;\n        acc >>= 32;\n\n        acc += rp[6];\n        acc += bp[10 - 7];\n        acc -= bp[13 - 7];\n        rp[6] = (unsigned int)acc;\n\n        carry = (int)(acc >> 32);\n# if BN_BITS2==64\n        rp[7] = carry;\n# endif\n    }\n#else\n    {\n        BN_ULONG t_d[BN_NIST_224_TOP];\n\n        nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);\n        carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);\n        carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);\n        carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n        nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);\n        carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n\n# if BN_BITS2==64\n        carry = (int)(r_d[BN_NIST_224_TOP - 1] >> 32);\n# endif\n    }\n#endif\n    adjust = bn_sub_words;\n    if (carry > 0) {\n        carry =\n            (int)bn_sub_words(r_d, r_d, _nist_p_224[carry - 1],\n                              BN_NIST_224_TOP);\n#if BN_BITS2==64\n        carry = (int)(~(r_d[BN_NIST_224_TOP - 1] >> 32)) & 1;\n#endif\n    } else if (carry < 0) {\n        /*\n         * it's a bit more complicated logic in this case. if bn_add_words\n         * yields no carry, then result has to be adjusted by unconditionally\n         * *adding* the modulus. but if it does, then result has to be\n         * compared to the modulus and conditionally adjusted by\n         * *subtracting* the latter.\n         */\n        carry =\n            (int)bn_add_words(r_d, r_d, _nist_p_224[-carry - 1],\n                              BN_NIST_224_TOP);\n        adjust = carry ? bn_sub_words : bn_add_words;\n    } else\n        carry = 1;\n\n    /* otherwise it's effectively same as in BN_nist_mod_192... */\n    res = ((*adjust) (c_d, r_d, _nist_p_224[0], BN_NIST_224_TOP) && carry)\n        ? r_d\n        : c_d;\n    nist_cp_bn(r_d, res, BN_NIST_224_TOP);\n    r->top = BN_NIST_224_TOP;\n    bn_correct_top(r);\n\n    return 1;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses a negative index -3 on the [array](1)."
    },
    {
        "var_name": "p.p.X",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1067,
                "startColumn": 27,
                "endColumn": 35
            },
            "context": {
                "startLine": 1065,
                "endLine": 1069,
                "snippet": {
                    "text": "\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.X",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1067,
                "startColumn": 38,
                "endColumn": 46
            },
            "context": {
                "startLine": 1065,
                "endLine": 1069,
                "snippet": {
                    "text": "\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.X",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1067,
                "startColumn": 49,
                "endColumn": 57
            },
            "context": {
                "startLine": 1065,
                "endLine": 1069,
                "snippet": {
                    "text": "\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.X",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1067,
                "startColumn": 60,
                "endColumn": 68
            },
            "context": {
                "startLine": 1065,
                "endLine": 1069,
                "snippet": {
                    "text": "\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.Y",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1068,
                "startColumn": 27,
                "endColumn": 35
            },
            "context": {
                "startLine": 1066,
                "endLine": 1070,
                "snippet": {
                    "text": "\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.Y",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1068,
                "startColumn": 38,
                "endColumn": 46
            },
            "context": {
                "startLine": 1066,
                "endLine": 1070,
                "snippet": {
                    "text": "\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.Y",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1068,
                "startColumn": 49,
                "endColumn": 57
            },
            "context": {
                "startLine": 1066,
                "endLine": 1070,
                "snippet": {
                    "text": "\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.Y",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1068,
                "startColumn": 60,
                "endColumn": 68
            },
            "context": {
                "startLine": 1066,
                "endLine": 1070,
                "snippet": {
                    "text": "\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.Z",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1078,
                "startColumn": 17,
                "endColumn": 25
            },
            "context": {
                "startLine": 1076,
                "endLine": 1080,
                "snippet": {
                    "text": "\t\t\t\tp.p.Z[4] = ONE[4] & infty;"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "ONE",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1078,
                "startColumn": 28,
                "endColumn": 34
            },
            "context": {
                "startLine": 1076,
                "endLine": 1080,
                "snippet": {
                    "text": "\t\t\t\tp.p.Z[4] = ONE[4] & infty;"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.Z",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1079,
                "startColumn": 17,
                "endColumn": 25
            },
            "context": {
                "startLine": 1077,
                "endLine": 1081,
                "snippet": {
                    "text": "\t\t\t\tp.Z[5] = ONE[5] & infty;"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "ONE",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1079,
                "startColumn": 28,
                "endColumn": 34
            },
            "context": {
                "startLine": 1077,
                "endLine": 1081,
                "snippet": {
                    "text": "\t\t\t\tp.p.Z[5] = ONE[5] & infty;"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.Z",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1080,
                "startColumn": 17,
                "endColumn": 25
            },
            "context": {
                "startLine": 1078,
                "endLine": 1082,
                "snippet": {
                    "text": "\t\t\t\tp.Z[6] = ONE[6] & infty;"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "ONE",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1080,
                "startColumn": 28,
                "endColumn": 34
            },
            "context": {
                "startLine": 1078,
                "endLine": 1082,
                "snippet": {
                    "text": "\t\t\t\tp.p.Z[6] = ONE[6] & infty;"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "p.p.Z",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1081,
                "startColumn": 17,
                "endColumn": 25
            },
            "context": {
                "startLine": 1079,
                "endLine": 1083,
                "snippet": {
                    "text": "\t\t\t\tp.Z[7] = ONE[7] & infty;"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "ONE",
        "function_name": "ecp_nistz256_points_mul",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 1081,
                "startColumn": 28,
                "endColumn": 34
            },
            "context": {
                "startLine": 1079,
                "endLine": 1083,
                "snippet": {
                    "text": "\t\t\t\tp.p.Z[7] = ONE[7] & infty;"
                }
            }
        },
        "function_code": "__owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n\t\t\t\t\t\t\t\t\t\t  EC_POINT *r,\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalar,\n\t\t\t\t\t\t\t\t\t\t  size_t num,\n\t\t\t\t\t\t\t\t\t\t  const EC_POINT *points[],\n\t\t\t\t\t\t\t\t\t\t  const BIGNUM *scalars[], BN_CTX *ctx)\n{\n\tint i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n\tunsigned char p_str[33] = { 0 };\n\tconst PRECOMP256_ROW *preComputedTable = NULL;\n\tconst NISTZ256_PRE_COMP *pre_comp = NULL;\n\tconst EC_POINT *generator = NULL;\n\tconst BIGNUM **new_scalars = NULL;\n\tconst EC_POINT **new_points = NULL;\n\tunsigned int idx = 0;\n\tconst unsigned int window_size = 7;\n\tconst unsigned int mask = (1 << (window_size + 1)) - 1;\n\tunsigned int wvalue;\n\tALIGN32 union {\n\t\tP256_POINT p;\n\t\tP256_POINT_AFFINE a;\n\t} t, p;\n\tBIGNUM *tmp_scalar;\n\n\tif ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n\t\tERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n\t\treturn 0;\n\t}\n\n\tmemset(&p, 0, sizeof(p));\n\tBN_CTX_start(ctx);\n\n\tif (scalar) {\n\t\tgenerator = EC_GROUP_get0_generator(group);\n\t\tif (generator == NULL) {\n\t\t\tERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n\t\t\tgoto err;\n\t\t}\n\n\t\t/* look if we can use precomputed multiples of generator */\n\t\tpre_comp = group->pre_comp.nistz256;\n\n\t\tif (pre_comp) {\n\t\t\t/*\n\t\t\t * If there is a precomputed table for the generator, check that\n\t\t\t * it was generated with the same generator.\n\t\t\t */\n\t\t\tEC_POINT *pre_comp_generator = EC_POINT_new(group);\n\t\t\tif (pre_comp_generator == NULL)\n\t\t\t\tgoto err;\n\n\t\t\tecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n\t\t\tif (!ecp_nistz256_set_from_affine(pre_comp_generator,\n\t\t\t\t\t\t\t\t\t\t\t  group, &p.a, ctx)) {\n\t\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n\t\t\t\tpreComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n\n\t\t\tEC_POINT_free(pre_comp_generator);\n\t\t}\n\n\t\tif (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n\t\t\t/*\n\t\t\t * If there is no precomputed data, but the generator is the\n\t\t\t * default, a hardcoded table of precomputed data is used. This\n\t\t\t * is because applications, such as Apache, do not use\n\t\t\t * EC_KEY_precompute_mult.\n\t\t\t */\n\t\t\tpreComputedTable = ecp_nistz256_precomputed;\n\t\t}\n\n\t\tif (preComputedTable) {\n\t\t\tBN_ULONG infty;\n\n\t\t\tif ((BN_num_bits(scalar) > 256)\n\t\t\t\t|| BN_is_negative(scalar)) {\n\t\t\t\tif ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tif (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n\t\t\t\t\tERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tscalar = tmp_scalar;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n\t\t\t\tBN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n\n\t\t\t\tp_str[i + 0] = (unsigned char)d;\n\t\t\t\tp_str[i + 1] = (unsigned char)(d >> 8);\n\t\t\t\tp_str[i + 2] = (unsigned char)(d >> 16);\n\t\t\t\tp_str[i + 3] = (unsigned char)(d >>= 24);\n\t\t\t\tif (BN_BYTES == 8) {\n\t\t\t\t\td >>= 8;\n\t\t\t\t\tp_str[i + 4] = (unsigned char)d;\n\t\t\t\t\tp_str[i + 5] = (unsigned char)(d >> 8);\n\t\t\t\t\tp_str[i + 6] = (unsigned char)(d >> 16);\n\t\t\t\t\tp_str[i + 7] = (unsigned char)(d >> 24);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (; i < 33; i++)\n\t\t\t\tp_str[i] = 0;\n\n\t\t\t/* First window */\n\t\t\twvalue = (p_str[0] << 1) & mask;\n\t\t\tidx += window_size;\n\n\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\tecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n\t\t\t\t\t\t\t\t   wvalue >> 1);\n\n\t\t\tecp_nistz256_neg(p.p.Z, p.p.Y);\n\t\t\tcopy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n\n\t\t\t/*\n\t\t\t * Since affine infinity is encoded as (0,0) and\n\t\t\t * Jacobian is (,,0), we need to harmonize them\n\t\t\t * by assigning \"one\" or zero to Z.\n\t\t\t */\n\t\t\tinfty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n\t\t\t\t\t p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n\t\t\tif (P256_LIMBS == 8)\n\t\t\t\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n\n\t\t\tinfty = 0 - is_zero(infty);\n\t\t\tinfty = ~infty;\n\n\t\t\tp.p.Z[0] = ONE[0] & infty;\n\t\t\tp.p.Z[1] = ONE[1] & infty;\n\t\t\tp.p.Z[2] = ONE[2] & infty;\n\t\t\tp.p.Z[3] = ONE[3] & infty;\n\t\t\tif (P256_LIMBS == 8) {\n\t\t\t\tp.p.Z[4] = ONE[4] & infty;\n\t\t\t\tp.p.Z[5] = ONE[5] & infty;\n\t\t\t\tp.p.Z[6] = ONE[6] & infty;\n\t\t\t\tp.p.Z[7] = ONE[7] & infty;\n\t\t\t}\n\n\t\t\tfor (i = 1; i < 37; i++) {\n\t\t\t\tunsigned int off = (idx - 1) / 8;\n\t\t\t\twvalue = p_str[off] | p_str[off + 1] << 8;\n\t\t\t\twvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n\t\t\t\tidx += window_size;\n\n\t\t\t\twvalue = _booth_recode_w7(wvalue);\n\n\t\t\t\tecp_nistz256_gather_w7(&t.a,\n\t\t\t\t\t\t\t\t\t   preComputedTable[i], wvalue >> 1);\n\n\t\t\t\tecp_nistz256_neg(t.p.Z, t.a.Y);\n\t\t\t\tcopy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n\n\t\t\t\tecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n\t\t\t}\n\t\t} else {\n\t\t\tp_is_infinity = 1;\n\t\t\tno_precomp_for_generator = 1;\n\t\t}\n\t} else\n\t\tp_is_infinity = 1;\n\n\tif (no_precomp_for_generator) {\n\t\t/*\n\t\t * Without a precomputed table for the generator, it has to be\n\t\t * handled like a normal point.\n\t\t */\n\t\tnew_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n\t\tif (new_scalars == NULL)\n\t\t\tgoto err;\n\n\t\tnew_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n\t\tif (new_points == NULL)\n\t\t\tgoto err;\n\n\t\tmemcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n\t\tnew_scalars[num] = scalar;\n\t\tmemcpy(new_points, points, num * sizeof(EC_POINT *));\n\t\tnew_points[num] = generator;\n\n\t\tscalars = new_scalars;\n\t\tpoints = new_points;\n\t\tnum++;\n\t}\n\n\tif (num) {\n\t\tP256_POINT *out = &t.p;\n\t\tif (p_is_infinity)\n\t\t\tout = &p.p;\n\n\t\tif (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n\t\t\tgoto err;\n\n\t\tif (!p_is_infinity)\n\t\t\tecp_nistz256_point_add(&p.p, &p.p, out);\n\t}\n\n\t/* Not constant-time, but we're only operating on the public output. */\n\tif (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n\t\t!bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n\t\t!bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n\t\tgoto err;\n\t}\n\tr->Z_is_one = is_one(r->Z) & 1;\n\n\tret = 1;\n\nerr:\n\tBN_CTX_end(ctx);\n\tOPENSSL_free(new_points);\n\tOPENSSL_free(new_scalars);\n\treturn ret;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "ONE",
        "function_name": "is_one",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 224,
                "startColumn": 27,
                "endColumn": 33
            },
            "context": {
                "startLine": 222,
                "endLine": 226,
                "snippet": {
                    "text": "\t\t\tres |= a[4] ^ ONE[4];"
                }
            }
        },
        "function_code": "static BN_ULONG is_one(const BIGNUM *z)\n{\n    BN_ULONG res = 0;\n    BN_ULONG *a = bn_get_words(z);\n\n\tif (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n\t\tres = a[0] ^ ONE[0];\n\t\tres |= a[1] ^ ONE[1];\n\t\tres |= a[2] ^ ONE[2];\n\t\tres |= a[3] ^ ONE[3];\n\t\tif (P256_LIMBS == 8) {\n\t\t\tres |= a[4] ^ ONE[4];\n\t\t\tres |= a[5] ^ ONE[5];\n\t\t\tres |= a[6] ^ ONE[6];\n            /*\n             * no check for a[7] (being zero) on 32-bit platforms,\n             * because value of \"one\" takes only 7 limbs.\n             */\n        }\n        res = is_zero(res);\n    }\n\n    return res;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "ONE",
        "function_name": "is_one",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 225,
                "startColumn": 27,
                "endColumn": 33
            },
            "context": {
                "startLine": 223,
                "endLine": 227,
                "snippet": {
                    "text": "    \t\tres |= a[5] ^ ONE[5];"
                }
            }
        },
        "function_code": "static BN_ULONG is_one(const BIGNUM *z)\n{\n    BN_ULONG res = 0;\n    BN_ULONG *a = bn_get_words(z);\n\n\tif (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n\t\tres = a[0] ^ ONE[0];\n\t\tres |= a[1] ^ ONE[1];\n\t\tres |= a[2] ^ ONE[2];\n\t\tres |= a[3] ^ ONE[3];\n\n\t\tif (P256_LIMBS == 8) {\n\t\t\tres |= a[4] ^ ONE[4];\n\t\t\tres |= a[5] ^ ONE[5];\n\t\t\tres |= a[6] ^ ONE[6];            /*\n             * no check for a[7] (being zero) on 32-bit platforms,\n             * because value of \"one\" takes only 7 limbs.\n             */\n        }\n        res = is_zero(res);\n    }\n\n    return res;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "ONE",
        "function_name": "is_one",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 226,
                "startColumn": 27,
                "endColumn": 33
            },
            "context": {
                "startLine": 224,
                "endLine": 228,
                "snippet": {
                    "text": "\t\t\tres |= a[6] ^ ONE[6];"
                }
            }
        },
        "function_code": "static BN_ULONG is_one(const BIGNUM *z)\n{\n    BN_ULONG res = 0;\n    BN_ULONG *a = bn_get_words(z);\n\n\tif (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n\t\tres = a[0] ^ ONE[0];\n\t\tres |= a[1] ^ ONE[1];\n\t\tres |= a[2] ^ ONE[2];\n\t\tres |= a[3] ^ ONE[3];\n\t\tif (P256_LIMBS == 8) {\n\t\t\tres |= a[4] ^ ONE[4];\n\t\t\tres |= a[5] ^ ONE[5];\n\t\t\tres |= a[6] ^ ONE[6];\n            /*\n             * no check for a[7] (being zero) on 32-bit platforms,\n             * because value of \"one\" takes only 7 limbs.\n             */\n        }\n        res = is_zero(res);\n    }\n\n    return res;\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "a",
        "function_name": "is_equal",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 204,
                "startColumn": 16,
                "endColumn": 20
            },
            "context": {
                "startLine": 202,
                "endLine": 206,
                "snippet": {
                    "text": "\t\tres |= a[4] ^ b[4];"
                }
            }
        },
        "function_code": "static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n\tif (P256_LIMBS == 8) {\n\t\tres |= a[4] ^ b[4];\n\t\tres |= a[5] ^ b[5];\n\t\tres |= a[6] ^ b[6];\n\t\tres |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "b",
        "function_name": "is_equal",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 204,
                "startColumn": 23,
                "endColumn": 27
            },
            "context": {
                "startLine": 202,
                "endLine": 206,
                "snippet": {
                    "text": "\t\tres |= a[4] ^ b[4];"
                }
            }
        },
        "function_code": "static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n\tif (P256_LIMBS == 8) {\n\t\tres |= a[4] ^ b[4];\n\t\tres |= a[5] ^ b[5];\n\t\tres |= a[6] ^ b[6];\n\t\tres |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "a",
        "function_name": "is_equal",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 205,
                "startColumn": 16,
                "endColumn": 20
            },
            "context": {
                "startLine": 203,
                "endLine": 207,
                "snippet": {
                    "text": "\t\tres |= a[5] ^ b[5];"
                }
            }
        },
        "function_code": "static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n\tif (P256_LIMBS == 8) {\n\t\tres |= a[4] ^ b[4];\n\t\tres |= a[5] ^ b[5];\n\t\tres |= a[6] ^ b[6];\n\t\tres |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "b",
        "function_name": "is_equal",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 205,
                "startColumn": 23,
                "endColumn": 27
            },
            "context": {
                "startLine": 203,
                "endLine": 207,
                "snippet": {
                    "text": "\t\tres |= a[5] ^ b[5];"
                }
            }
        },
        "function_code": "static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n\tif (P256_LIMBS == 8) {\n\t\tres |= a[4] ^ b[4];\n\t\tres |= a[5] ^ b[5];\n\t\tres |= a[6] ^ b[6];\n\t\tres |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "a",
        "function_name": "is_equal",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 206,
                "startColumn": 16,
                "endColumn": 20
            },
            "context": {
                "startLine": 204,
                "endLine": 208,
                "snippet": {
                    "text": "\t\tres |= a[6] ^ b[6];"
                }
            }
        },
        "function_code": "static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n\tif (P256_LIMBS == 8) {\n\t\tres |= a[4] ^ b[4];\n\t\tres |= a[5] ^ b[5];\n\t\tres |= a[6] ^ b[6];\n\t\tres |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "b",
        "function_name": "is_equal",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 206,
                "startColumn": 23,
                "endColumn": 27
            },
            "context": {
                "startLine": 204,
                "endLine": 208,
                "snippet": {
                    "text": "\t\tres |= a[6] ^ b[6];"
                }
            }
        },
        "function_code": "static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n\tif (P256_LIMBS == 8) {\n\t\tres |= a[4] ^ b[4];\n\t\tres |= a[5] ^ b[5];\n\t\tres |= a[6] ^ b[6];\n\t\tres |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "a",
        "function_name": "is_equal",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 207,
                "startColumn": 16,
                "endColumn": 20
            },
            "context": {
                "startLine": 205,
                "endLine": 209,
                "snippet": {
                    "text": "\t\tres |= a[7] ^ b[7];"
                }
            }
        },
        "function_code": "static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n\tif (P256_LIMBS == 8) {\n\t\tres |= a[4] ^ b[4];\n\t\tres |= a[5] ^ b[5];\n\t\tres |= a[6] ^ b[6];\n\t\tres |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "b",
        "function_name": "is_equal",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 207,
                "startColumn": 23,
                "endColumn": 27
            },
            "context": {
                "startLine": 205,
                "endLine": 209,
                "snippet": {
                    "text": "\t\tres |= a[7] ^ b[7];"
                }
            }
        },
        "function_code": "static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n                         const BN_ULONG b[P256_LIMBS])\n{\n    BN_ULONG res;\n\n    res = a[0] ^ b[0];\n    res |= a[1] ^ b[1];\n    res |= a[2] ^ b[2];\n    res |= a[3] ^ b[3];\n\tif (P256_LIMBS == 8) {\n\t\tres |= a[4] ^ b[4];\n\t\tres |= a[5] ^ b[5];\n\t\tres |= a[6] ^ b[6];\n\t\tres |= a[7] ^ b[7];\n    }\n\n    return is_zero(res);\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "dst",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 179,
                "startColumn": 9,
                "endColumn": 15
            },
            "context": {
                "startLine": 177,
                "endLine": 181,
                "snippet": {
                    "text": "\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "src",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 179,
                "startColumn": 19,
                "endColumn": 25
            },
            "context": {
                "startLine": 177,
                "endLine": 181,
                "snippet": {
                    "text": "\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "dst",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 179,
                "startColumn": 38,
                "endColumn": 44
            },
            "context": {
                "startLine": 177,
                "endLine": 181,
                "snippet": {
                    "text": "\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 39 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "dst",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 180,
                "startColumn": 9,
                "endColumn": 15
            },
            "context": {
                "startLine": 178,
                "endLine": 182,
                "snippet": {
                    "text": "\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "src",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 180,
                "startColumn": 19,
                "endColumn": 25
            },
            "context": {
                "startLine": 178,
                "endLine": 182,
                "snippet": {
                    "text": "\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "dst",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 180,
                "startColumn": 38,
                "endColumn": 44
            },
            "context": {
                "startLine": 178,
                "endLine": 182,
                "snippet": {
                    "text": "\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 47 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "dst",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 181,
                "startColumn": 9,
                "endColumn": 15
            },
            "context": {
                "startLine": 179,
                "endLine": 183,
                "snippet": {
                    "text": "\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "src",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 181,
                "startColumn": 19,
                "endColumn": 25
            },
            "context": {
                "startLine": 179,
                "endLine": 183,
                "snippet": {
                    "text": "\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "dst",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 181,
                "startColumn": 38,
                "endColumn": 44
            },
            "context": {
                "startLine": 179,
                "endLine": 183,
                "snippet": {
                    "text": "\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 55 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "dst",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 182,
                "startColumn": 9,
                "endColumn": 15
            },
            "context": {
                "startLine": 180,
                "endLine": 184,
                "snippet": {
                    "text": "\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "src",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 182,
                "startColumn": 19,
                "endColumn": 25
            },
            "context": {
                "startLine": 180,
                "endLine": 184,
                "snippet": {
                    "text": "\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    },
    {
        "var_name": "dst",
        "function_name": "copy_conditional",
        "location": {
            "file_path": "crypto/ec/ecp_nistz256.c",
            "region": {
                "startLine": 182,
                "startColumn": 38,
                "endColumn": 44
            },
            "context": {
                "startLine": 180,
                "endLine": 184,
                "snippet": {
                    "text": "\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);"
                }
            }
        },
        "function_code": "static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n                             const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n{\n    BN_ULONG mask1 = 0-move;\n    BN_ULONG mask2 = ~mask1;\n\n    dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n    dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n    dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n    dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n\tif (P256_LIMBS == 8) {\n\t\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n\t\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n\t\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n\t\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n    }\n}",
        "result": 0,
        "bug_report": "This array indexing operation accesses byte offset 63 but the [array](1) is only 32 bytes."
    }
]