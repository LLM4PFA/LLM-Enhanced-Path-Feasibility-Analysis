[
    {
        "var_name": "key_param",
        "function_name": "cms_main",
        "location": {
            "file_path": "apps/cms.c",
            "region": {
                "startLine": 671,
                "startColumn": 21,
                "endColumn": 30
            },
            "context": {
                "startLine": 669,
                "endLine": 673,
                "snippet": {
                    "text": "key_param->next = nparam;"
                }
            }
        },
        "function_code": "int cms_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ASN1_OBJECT *econtent_type = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\n    CMS_ContentInfo *cms = NULL, *rcms = NULL;\n    CMS_ReceiptRequest *rr = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *key = NULL;\n    EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = sk_X509_new_null(), *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL, *originator = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = X509_VERIFY_PARAM_new();\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *certsoutfile = NULL, *digestname = NULL, *wrapname = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    char *digesthex = NULL;\n    unsigned char *digestbin = NULL;\n    long digestlen = 0;\n    char *infile = NULL, *outfile = NULL, *rctfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *signerfile = NULL;\n    char *originatorfile = NULL, *recipfile = NULL, *ciphername = NULL;\n    char *to = NULL, *from = NULL, *subject = NULL, *prog;\n    cms_key_param *key_first = NULL, *key_param = NULL;\n    int flags = CMS_DETACHED, binary_files = 0;\n    int noout = 0, print = 0, keyidx = -1, vpmtouched = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\n    int operation = 0, ret = 1, rr_print = 0, rr_allorfirst = -1;\n    int verify_retcode = 0, rctformat = FORMAT_SMIME, keyform = FORMAT_UNDEF;\n    size_t secret_keylen = 0, secret_keyidlen = 0;\n    unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\n    unsigned char *secret_key = NULL, *secret_keyid = NULL;\n    long ltmp;\n    const char *mime_eol = \"\\n\";\n    OPTION_CHOICE o;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if (encerts == NULL || vpm == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, cms_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(cms_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n\n        case OPT_ENCRYPT:\n            operation = SMIME_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            operation = SMIME_DECRYPT;\n            break;\n        case OPT_SIGN:\n            operation = SMIME_SIGN;\n            break;\n        case OPT_VERIFY:\n            operation = SMIME_VERIFY;\n            break;\n        case OPT_RESIGN:\n            operation = SMIME_RESIGN;\n            break;\n        case OPT_SIGN_RECEIPT:\n            operation = SMIME_SIGN_RECEIPT;\n            break;\n        case OPT_VERIFY_RECEIPT:\n            operation = SMIME_VERIFY_RECEIPT;\n            rctfile = opt_arg();\n            break;\n        case OPT_VERIFY_RETCODE:\n            verify_retcode = 1;\n            break;\n        case OPT_DIGEST_CREATE:\n            operation = SMIME_DIGEST_CREATE;\n            break;\n        case OPT_DIGEST:\n            digesthex = opt_arg();\n            break;\n        case OPT_DIGEST_VERIFY:\n            operation = SMIME_DIGEST_VERIFY;\n            break;\n        case OPT_COMPRESS:\n            operation = SMIME_COMPRESS;\n            break;\n        case OPT_UNCOMPRESS:\n            operation = SMIME_UNCOMPRESS;\n            break;\n        case OPT_ED_ENCRYPT:\n            operation = SMIME_ENCRYPTED_ENCRYPT;\n            break;\n        case OPT_ED_DECRYPT:\n            operation = SMIME_ENCRYPTED_DECRYPT;\n            break;\n        case OPT_DATA_CREATE:\n            operation = SMIME_DATA_CREATE;\n            break;\n        case OPT_DATA_OUT:\n            operation = SMIME_DATA_OUT;\n            break;\n        case OPT_CMSOUT:\n            operation = SMIME_CMSOUT;\n            break;\n\n        case OPT_DEBUG_DECRYPT:\n            flags |= CMS_DEBUG_DECRYPT;\n            break;\n        case OPT_TEXT:\n            flags |= CMS_TEXT;\n            break;\n        case OPT_ASCIICRLF:\n            flags |= CMS_ASCIICRLF;\n            break;\n        case OPT_NOINTERN:\n            flags |= CMS_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= CMS_NO_SIGNER_CERT_VERIFY;\n            break;\n        case OPT_NOCERTS:\n            flags |= CMS_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= CMS_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~CMS_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= CMS_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= CMS_BINARY;\n            break;\n        case OPT_CADES:\n            flags |= CMS_CADES;\n            break;\n        case OPT_KEYID:\n            flags |= CMS_USE_KEYID;\n            break;\n        case OPT_NOSIGS:\n            flags |= CMS_NOSIGS;\n            break;\n        case OPT_NO_CONTENT_VERIFY:\n            flags |= CMS_NO_CONTENT_VERIFY;\n            break;\n        case OPT_NO_ATTR_VERIFY:\n            flags |= CMS_NO_ATTR_VERIFY;\n            break;\n        case OPT_INDEF:\n            flags |= CMS_STREAM;\n            break;\n        case OPT_NOINDEF:\n            flags &= ~CMS_STREAM;\n            break;\n        case OPT_CRLFEOL:\n            mime_eol = \"\\r\\n\";\n            flags |= CMS_CRLFEOL;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_RR_PRINT:\n            rr_print = 1;\n            break;\n        case OPT_RR_ALL:\n            rr_allorfirst = 0;\n            break;\n        case OPT_RR_FIRST:\n            rr_allorfirst = 1;\n            break;\n        case OPT_RCTFORM:\n            if (!opt_format(opt_arg(),\n                            OPT_FMT_PEMDER | OPT_FMT_SMIME, &rctformat))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_RR_FROM:\n            if (rr_from == NULL\n                && (rr_from = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_from, opt_arg());\n            break;\n        case OPT_RR_TO:\n            if (rr_to == NULL\n                && (rr_to = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_to, opt_arg());\n            break;\n        case OPT_PRINT:\n            noout = print = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SECRETKEY:\n            if (secret_key != NULL) {\n                BIO_printf(bio_err, \"Invalid key (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_key = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_key == NULL) {\n                BIO_printf(bio_err, \"Invalid key %s\\n\", opt_arg());\n                goto end;\n            }\n            secret_keylen = (size_t)ltmp;\n            break;\n        case OPT_SECRETKEYID:\n            if (secret_keyid != NULL) {\n                BIO_printf(bio_err, \"Invalid id (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_keyid = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_keyid == NULL) {\n                BIO_printf(bio_err, \"Invalid id %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            secret_keyidlen = (size_t)ltmp;\n            break;\n        case OPT_PWRI_PASSWORD:\n            pwri_pass = (unsigned char *)opt_arg();\n            break;\n        case OPT_ECONTENT_TYPE:\n            if (econtent_type != NULL) {\n                BIO_printf(bio_err, \"Invalid OID (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            econtent_type = OBJ_txt2obj(opt_arg(), 0);\n            if (econtent_type == NULL) {\n                BIO_printf(bio_err, \"Invalid OID %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_CERTSOUT:\n            certsoutfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_ORIGINATOR:\n            originatorfile = opt_arg();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n                    goto end;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_RECIP:\n            if (operation == SMIME_ENCRYPT) {\n                cert = load_cert(opt_arg(), FORMAT_UNDEF,\n                                 \"recipient certificate file\");\n                if (cert == NULL)\n                    goto end;\n                if (!sk_X509_push(encerts, cert))\n                    goto end;\n                cert = NULL;\n            } else {\n                recipfile = opt_arg();\n            }\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_KEYOPT:\n            keyidx = -1;\n            if (operation == SMIME_ENCRYPT) {\n                if (sk_X509_num(encerts) > 0)\n                    keyidx += sk_X509_num(encerts);\n            } else {\n                if (keyfile != NULL || signerfile != NULL)\n                    keyidx++;\n                if (skkeys != NULL)\n                    keyidx += sk_OPENSSL_STRING_num(skkeys);\n            }\n            if (keyidx < 0) {\n                BIO_printf(bio_err, \"No key specified\\n\");\n                goto opthelp;\n            }\n            if (key_param == NULL || key_param->idx != keyidx) {\n                cms_key_param *nparam;\n                nparam = app_malloc(sizeof(*nparam), \"key param buffer\");\n                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {\n                    OPENSSL_free(nparam);\n                    goto end;\n                }\n                nparam->idx = keyidx;\n                nparam->next = NULL;\n                if (key_first == NULL)\n                    key_first = nparam;\n                else\n                    key_param->next = nparam;\n                key_param = nparam;\n            }\n            sk_OPENSSL_STRING_push(key_param->param, opt_arg());\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_WRAP:\n            wrapname = opt_arg();\n            break;\n        case OPT_AES128_WRAP:\n        case OPT_AES192_WRAP:\n        case OPT_AES256_WRAP:\n        case OPT_3DES_WRAP:\n            wrapname = opt_flag() + 1;\n            break;\n        }\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto end;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n        goto end;\n    if (wrapname != NULL) {\n        if (!opt_cipher_any(wrapname, &wrap_cipher))\n            goto end;\n    }\n\n    /* Remaining args are files to process. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((rr_allorfirst != -1 || rr_from != NULL) && rr_to == NULL) {\n        BIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\n        goto opthelp;\n    }\n\n    if (!(operation & SMIME_SIGNERS) && (rr_to != NULL || rr_from != NULL)) {\n        BIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\n        goto opthelp;\n    }\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n\n    if ((flags & CMS_CADES) != 0) {\n        if ((flags & CMS_NOATTR) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: \"\n                     \"CAdES requires signed attributes\\n\");\n            goto opthelp;\n        }\n        if (operation == SMIME_VERIFY\n                && (flags & (CMS_NO_SIGNER_CERT_VERIFY | CMS_NO_ATTR_VERIFY)) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: CAdES validation requires\"\n                     \" certs and signed attributes validations\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        if (keyfile != NULL && signerfile == NULL) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        /* Check to see if any final signer needs to be appended */\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (skkeys == NULL && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (keyfile == NULL)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL\n            && secret_key == NULL && pwri_pass == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (*argv == NULL && secret_key == NULL\n            && pwri_pass == NULL && sk_X509_num(encerts) <= 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    } else if (!operation) {\n        BIO_printf(bio_err, \"No operation option (-encrypt|-decrypt|-sign|-verify|...) specified.\\n\");\n        goto opthelp;\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if ((operation & SMIME_SIGNERS) == 0) {\n        if ((flags & CMS_DETACHED) == 0)\n            BIO_printf(bio_err,\n                       \"Warning: -nodetach option is ignored for non-signing operation\\n\");\n\n        flags &= ~CMS_DETACHED;\n    }\n    if ((operation & SMIME_IP) == 0 && contfile != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: -contfile option is ignored for the given operation\\n\");\n    if (operation != SMIME_ENCRYPT && *argv != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: recipient certificate file parameters ignored for operation other than -encrypt\\n\");\n\n    if ((flags & CMS_BINARY) != 0) {\n        if (!(operation & SMIME_OP))\n            outformat = FORMAT_BINARY;\n        if (!(operation & SMIME_IP))\n            informat = FORMAT_BINARY;\n        if ((operation & SMIME_SIGNERS) != 0 && (flags & CMS_DETACHED) != 0)\n            binary_files = 1;\n        if ((operation & SMIME_IP) != 0 && contfile == NULL)\n            binary_files = 1;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (!cipher)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        if (secret_key && !secret_keyid) {\n            BIO_printf(bio_err, \"No secret key id\\n\");\n            goto end;\n        }\n\n        for (; *argv != NULL; argv++) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificate file\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (originatorfile != NULL) {\n        if ((originator = load_cert(originatorfile, FORMAT_UNDEF,\n                                    \"originator certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_SIGN_RECEIPT) {\n        if ((signer = load_cert(signerfile, FORMAT_UNDEF,\n                                \"receipt signer certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((operation == SMIME_DECRYPT) || (operation == SMIME_ENCRYPT)) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (digesthex != NULL) {\n        if (operation != SMIME_SIGN) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest for non-signing operation\\n\");\n            goto end;\n        }\n        if (infile != NULL\n            || (flags & CMS_DETACHED) == 0\n            || (flags & CMS_STREAM) != 0) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest when -in, -nodetach or streaming is used\\n\");\n            goto end;\n        }\n        digestbin = OPENSSL_hexstr2buf(digesthex, &digestlen);\n        if (digestbin == NULL) {\n            BIO_printf(bio_err,\n                       \"Invalid hex value after -digest\\n\");\n            goto end;\n        }\n    } else {\n        in = bio_open_default(infile, 'r',\n                              binary_files ? FORMAT_BINARY : informat);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (operation & SMIME_IP) {\n        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");\n        if (cms == NULL)\n            goto end;\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n        if (certsoutfile != NULL) {\n            STACK_OF(X509) *allcerts;\n            allcerts = CMS_get1_certs(cms);\n            if (!save_certs(certsoutfile, allcerts)) {\n                BIO_printf(bio_err,\n                           \"Error writing certs to %s\\n\", certsoutfile);\n                ret = 5;\n                goto end;\n            }\n            OSSL_STACK_OF_X509_free(allcerts);\n        }\n    }\n\n    if (rctfile != NULL) {\n        char *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\n\n        if ((rctin = BIO_new_file(rctfile, rctmode)) == NULL) {\n            BIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\n            goto end;\n        }\n\n        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");\n        if (rcms == NULL)\n            goto end;\n    }\n\n    out = bio_open_default(outfile, 'w',\n                           binary_files ? FORMAT_BINARY : outformat);\n    if (out == NULL)\n        goto end;\n\n    if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, cms_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_DATA_CREATE) {\n        cms = CMS_data_create_ex(in, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_DIGEST_CREATE) {\n        cms = CMS_digest_create_ex(in, sign_md, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_COMPRESS) {\n        cms = CMS_compress(in, -1, flags);\n    } else if (operation == SMIME_ENCRYPT) {\n        int i;\n        flags |= CMS_PARTIAL;\n        cms = CMS_encrypt_ex(NULL, in, cipher, flags, libctx, app_get0_propq());\n        if (cms == NULL)\n            goto end;\n        for (i = 0; i < sk_X509_num(encerts); i++) {\n            CMS_RecipientInfo *ri;\n            cms_key_param *kparam;\n            int tflags = flags | CMS_KEY_PARAM;\n            /* This flag enforces allocating the EVP_PKEY_CTX for the recipient here */\n            EVP_PKEY_CTX *pctx;\n            X509 *x = sk_X509_value(encerts, i);\n            int res;\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    break;\n                }\n            }\n            ri = CMS_add1_recipient(cms, x, key, originator, tflags);\n            if (ri == NULL)\n                goto end;\n\n            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n            if (kparam != NULL) {\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n\n            res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,\n                                    EVP_PKEY_CTRL_CIPHER,\n                                    EVP_CIPHER_get_nid(cipher), NULL);\n            if (res <= 0 && res != -2)\n                goto end;\n\n            if (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\n                    && wrap_cipher != NULL) {\n                EVP_CIPHER_CTX *wctx;\n                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n                if (EVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL) != 1)\n                    goto end;\n            }\n        }\n\n        if (secret_key != NULL) {\n            if (!CMS_add0_recipient_key(cms, NID_undef,\n                                        secret_key, secret_keylen,\n                                        secret_keyid, secret_keyidlen,\n                                        NULL, NULL, NULL))\n                goto end;\n            /* NULL these because call absorbs them */\n            secret_key = NULL;\n            secret_keyid = NULL;\n        }\n        if (pwri_pass != NULL) {\n            pwri_tmp = (unsigned char *)OPENSSL_strdup((char *)pwri_pass);\n            if (pwri_tmp == NULL)\n                goto end;\n            if (CMS_add0_recipient_password(cms,\n                                            -1, NID_undef, NID_undef,\n                                            pwri_tmp, -1, NULL) == NULL)\n                goto end;\n            pwri_tmp = NULL;\n        }\n        if (!(flags & CMS_STREAM)) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\n        cms = CMS_EncryptedData_encrypt_ex(in, cipher, secret_key,\n                                           secret_keylen, flags, libctx, app_get0_propq());\n\n    } else if (operation == SMIME_SIGN_RECEIPT) {\n        CMS_ContentInfo *srcms = NULL;\n        STACK_OF(CMS_SignerInfo) *sis;\n        CMS_SignerInfo *si;\n        sis = CMS_get0_SignerInfos(cms);\n        if (sis == NULL)\n            goto end;\n        si = sk_CMS_SignerInfo_value(sis, 0);\n        srcms = CMS_sign_receipt(si, signer, key, other, flags);\n        if (srcms == NULL)\n            goto end;\n        CMS_ContentInfo_free(cms);\n        cms = srcms;\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content and not signing pre-computed digest, we\n         * enable streaming if S/MIME output format.\n         */\n        if (operation == SMIME_SIGN) {\n\n            if ((flags & CMS_DETACHED) != 0 && digestbin == NULL) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= CMS_STREAM;\n            }\n            flags |= CMS_PARTIAL;\n            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (cms == NULL)\n                goto end;\n            if (econtent_type != NULL)\n                CMS_set1_eContentType(cms, econtent_type);\n\n            if (rr_to != NULL\n                && ((rr = make_receipt_request(rr_to, rr_allorfirst, rr_from))\n                    == NULL)) {\n                BIO_puts(bio_err, \"Signed Receipt Request Creation Error\\n\");\n                goto end;\n            }\n        } else {\n            flags |= CMS_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            CMS_SignerInfo *si;\n            cms_key_param *kparam;\n            int tflags = flags;\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL) {\n                ret = 2;\n                goto end;\n            }\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL) {\n                ret = 2;\n                goto end;\n            }\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    tflags |= CMS_KEY_PARAM;\n                    break;\n                }\n            }\n            si = CMS_add1_signer(cms, signer, key, sign_md, tflags);\n            if (si == NULL)\n                goto end;\n            if (kparam != NULL) {\n                EVP_PKEY_CTX *pctx;\n                pctx = CMS_SignerInfo_get0_pkey_ctx(si);\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n            if (rr != NULL && !CMS_add1_ReceiptRequest(si, rr))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if (operation == SMIME_SIGN && digestbin != NULL\n            && (flags & CMS_STREAM) == 0) {\n            /* Use pre-computed digest instead of content */\n            if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))\n                goto end;\n        } else if (operation == SMIME_SIGN && (flags & CMS_STREAM) == 0) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    }\n\n    if (cms == NULL) {\n        BIO_printf(bio_err, \"Error creating CMS structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (flags & CMS_DEBUG_DECRYPT)\n            CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\n\n        if (secret_key != NULL) {\n            if (!CMS_decrypt_set1_key(cms,\n                                      secret_key, secret_keylen,\n                                      secret_keyid, secret_keyidlen)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\n                goto end;\n            }\n        }\n\n        if (key != NULL) {\n            if (!CMS_decrypt_set1_pkey_and_peer(cms, key, recip, originator)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\n                goto end;\n            }\n        }\n\n        if (pwri_pass != NULL) {\n            if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\n                goto end;\n            }\n        }\n\n        if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_DATA_OUT) {\n        if (!CMS_data(cms, out, flags))\n            goto end;\n    } else if (operation == SMIME_UNCOMPRESS) {\n        if (!CMS_uncompress(cms, indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_DIGEST_VERIFY) {\n        if (CMS_digest_verify(cms, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_DECRYPT) {\n        if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\n                                       indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_VERIFY) {\n        if (CMS_verify(cms, other, store, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"%s Verification successful\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n        } else {\n            BIO_printf(bio_err, \"%s Verification failure\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n            if (verify_retcode)\n                ret = verify_err + 32;\n            goto end;\n        }\n        if (signerfile != NULL) {\n            STACK_OF(X509) *signers = CMS_get0_signers(cms);\n\n            if (!save_certs(signerfile, signers)) {\n                BIO_printf(bio_err,\n                           \"Error writing signers to %s\\n\", signerfile);\n                ret = 5;\n                goto end;\n            }\n            sk_X509_free(signers);\n        }\n        if (rr_print)\n            receipt_request_print(cms);\n\n    } else if (operation == SMIME_VERIFY_RECEIPT) {\n        if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else {\n        if (noout) {\n            if (print) {\n                ASN1_PCTX *pctx = NULL;\n                if (get_nameopt() != XN_FLAG_ONELINE) {\n                    pctx = ASN1_PCTX_new();\n                    if (pctx != NULL) { /* Print anyway if malloc failed */\n                        ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT);\n                        ASN1_PCTX_set_str_flags(pctx, get_nameopt());\n                        ASN1_PCTX_set_nm_flags(pctx, get_nameopt());\n                    }\n                }\n                CMS_ContentInfo_print_ctx(out, cms, 0, pctx);\n                ASN1_PCTX_free(pctx);\n            }\n        } else if (outformat == FORMAT_SMIME) {\n            if (to)\n                BIO_printf(out, \"To: %s%s\", to, mime_eol);\n            if (from)\n                BIO_printf(out, \"From: %s%s\", from, mime_eol);\n            if (subject)\n                BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n            if (operation == SMIME_RESIGN)\n                ret = SMIME_write_CMS(out, cms, indata, flags);\n            else\n                ret = SMIME_write_CMS(out, cms, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            ret = PEM_write_bio_CMS_stream(out, cms, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            ret = i2d_CMS_bio_stream(out, cms, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for CMS file\\n\");\n            goto end;\n        }\n        if (ret <= 0) {\n            ret = 6;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    OPENSSL_free(secret_key);\n    OPENSSL_free(secret_keyid);\n    OPENSSL_free(pwri_tmp);\n    ASN1_OBJECT_free(econtent_type);\n    CMS_ReceiptRequest_free(rr);\n    sk_OPENSSL_STRING_free(rr_to);\n    sk_OPENSSL_STRING_free(rr_from);\n    for (key_param = key_first; key_param;) {\n        cms_key_param *tparam;\n        sk_OPENSSL_STRING_free(key_param->param);\n        tparam = key_param->next;\n        OPENSSL_free(key_param);\n        key_param = tparam;\n    }\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_CIPHER_free(cipher);\n    EVP_CIPHER_free(wrap_cipher);\n    EVP_MD_free(sign_md);\n    CMS_ContentInfo_free(cms);\n    CMS_ContentInfo_free(rcms);\n    release_engine(e);\n    BIO_free(rctin);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(digestbin);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}",
        "result": 0
    },
    {
        "var_name": "evp_mac_mdname",
        "function_name": "speed_main",
        "location": {
            "file_path": "apps/speed.c",
            "region": {
                "startLine": 2730,
                "startColumn": 58,
                "endColumn": 72
            },
            "context": {
                "startLine": 2728,
                "endLine": 2732,
                "snippet": {
                    "text": "size_t hmac_name_len = sizeof(\"hmac()\") + strlen(evp_mac_mdname);"
                }
            }
        },
        "function_code": "int speed_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ENGINE *e = NULL;\n    loopargs_t *loopargs = NULL;\n    const char *prog;\n    const char *engine_id = NULL;\n    EVP_CIPHER *evp_cipher = NULL;\n    EVP_MAC *mac = NULL;\n    double d = 0.0;\n    OPTION_CHOICE o;\n    int async_init = 0, multiblock = 0, pr_header = 0;\n    uint8_t doit[ALGOR_NUM] = { 0 };\n    int ret = 1, misalign = 0, lengths_single = 0;\n    STACK_OF(EVP_KEM) *kem_stack = NULL;\n    STACK_OF(EVP_SIGNATURE) *sig_stack = NULL;\n    long count = 0;\n    unsigned int size_num = SIZE_NUM;\n    unsigned int i, k, loopargs_len = 0, async_jobs = 0;\n    unsigned int idx;\n    int keylen = 0;\n    int buflen;\n    size_t declen;\n    BIGNUM *bn = NULL;\n    EVP_PKEY_CTX *genctx = NULL;\n#ifndef NO_FORK\n    int multi = 0;\n#endif\n    long op_count = 1;\n    openssl_speed_sec_t seconds = { SECONDS, RSA_SECONDS, DSA_SECONDS,\n                                    ECDSA_SECONDS, ECDH_SECONDS,\n                                    EdDSA_SECONDS, SM2_SECONDS,\n                                    FFDH_SECONDS, KEM_SECONDS,\n                                    SIG_SECONDS };\n\n    static const unsigned char key32[32] = {\n        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,\n        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,\n        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,\n        0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56\n    };\n    static const unsigned char deskey[] = {\n        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, /* key1 */\n        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, /* key2 */\n        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34  /* key3 */\n    };\n    static const struct {\n        const unsigned char *data;\n        unsigned int length;\n        unsigned int bits;\n    } rsa_keys[] = {\n        {   test512,   sizeof(test512),   512 },\n        {  test1024,  sizeof(test1024),  1024 },\n        {  test2048,  sizeof(test2048),  2048 },\n        {  test3072,  sizeof(test3072),  3072 },\n        {  test4096,  sizeof(test4096),  4096 },\n        {  test7680,  sizeof(test7680),  7680 },\n        { test15360, sizeof(test15360), 15360 }\n    };\n    uint8_t rsa_doit[RSA_NUM] = { 0 };\n    int primes = RSA_DEFAULT_PRIME_NUM;\n#ifndef OPENSSL_NO_DH\n    typedef struct ffdh_params_st {\n        const char *name;\n        unsigned int nid;\n        unsigned int bits;\n    } FFDH_PARAMS;\n\n    static const FFDH_PARAMS ffdh_params[FFDH_NUM] = {\n        {\"ffdh2048\", NID_ffdhe2048, 2048},\n        {\"ffdh3072\", NID_ffdhe3072, 3072},\n        {\"ffdh4096\", NID_ffdhe4096, 4096},\n        {\"ffdh6144\", NID_ffdhe6144, 6144},\n        {\"ffdh8192\", NID_ffdhe8192, 8192}\n    };\n    uint8_t ffdh_doit[FFDH_NUM] = { 0 };\n\n#endif /* OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_DSA\n    static const unsigned int dsa_bits[DSA_NUM] = { 1024, 2048 };\n    uint8_t dsa_doit[DSA_NUM] = { 0 };\n#endif /* OPENSSL_NO_DSA */\n    /*\n     * We only test over the following curves as they are representative, To\n     * add tests over more curves, simply add the curve NID and curve name to\n     * the following arrays and increase the |ecdh_choices| and |ecdsa_choices|\n     * lists accordingly.\n     */\n    static const EC_CURVE ec_curves[EC_NUM] = {\n        /* Prime Curves */\n        {\"secp160r1\", NID_secp160r1, 160},\n        {\"nistp192\", NID_X9_62_prime192v1, 192},\n        {\"nistp224\", NID_secp224r1, 224},\n        {\"nistp256\", NID_X9_62_prime256v1, 256},\n        {\"nistp384\", NID_secp384r1, 384},\n        {\"nistp521\", NID_secp521r1, 521},\n#ifndef OPENSSL_NO_EC2M\n        /* Binary Curves */\n        {\"nistk163\", NID_sect163k1, 163},\n        {\"nistk233\", NID_sect233k1, 233},\n        {\"nistk283\", NID_sect283k1, 283},\n        {\"nistk409\", NID_sect409k1, 409},\n        {\"nistk571\", NID_sect571k1, 571},\n        {\"nistb163\", NID_sect163r2, 163},\n        {\"nistb233\", NID_sect233r1, 233},\n        {\"nistb283\", NID_sect283r1, 283},\n        {\"nistb409\", NID_sect409r1, 409},\n        {\"nistb571\", NID_sect571r1, 571},\n#endif\n        {\"brainpoolP256r1\", NID_brainpoolP256r1, 256},\n        {\"brainpoolP256t1\", NID_brainpoolP256t1, 256},\n        {\"brainpoolP384r1\", NID_brainpoolP384r1, 384},\n        {\"brainpoolP384t1\", NID_brainpoolP384t1, 384},\n        {\"brainpoolP512r1\", NID_brainpoolP512r1, 512},\n        {\"brainpoolP512t1\", NID_brainpoolP512t1, 512},\n#ifndef OPENSSL_NO_ECX\n        /* Other and ECDH only ones */\n        {\"X25519\", NID_X25519, 253},\n        {\"X448\", NID_X448, 448}\n#endif\n    };\n#ifndef OPENSSL_NO_ECX\n    static const EC_CURVE ed_curves[EdDSA_NUM] = {\n        /* EdDSA */\n        {\"Ed25519\", NID_ED25519, 253, 64},\n        {\"Ed448\", NID_ED448, 456, 114}\n    };\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n    static const EC_CURVE sm2_curves[SM2_NUM] = {\n        /* SM2 */\n        {\"CurveSM2\", NID_sm2, 256}\n    };\n    uint8_t sm2_doit[SM2_NUM] = { 0 };\n#endif\n    uint8_t ecdsa_doit[ECDSA_NUM] = { 0 };\n    uint8_t ecdh_doit[EC_NUM] = { 0 };\n#ifndef OPENSSL_NO_ECX\n    uint8_t eddsa_doit[EdDSA_NUM] = { 0 };\n#endif /* OPENSSL_NO_ECX */\n\n    uint8_t kems_doit[MAX_KEM_NUM] = { 0 };\n    uint8_t sigs_doit[MAX_SIG_NUM] = { 0 };\n\n    uint8_t do_kems = 0;\n    uint8_t do_sigs = 0;\n\n    /* checks declared curves against choices list. */\n#ifndef OPENSSL_NO_ECX\n    OPENSSL_assert(ed_curves[EdDSA_NUM - 1].nid == NID_ED448);\n    OPENSSL_assert(strcmp(eddsa_choices[EdDSA_NUM - 1].name, \"ed448\") == 0);\n\n    OPENSSL_assert(ec_curves[EC_NUM - 1].nid == NID_X448);\n    OPENSSL_assert(strcmp(ecdh_choices[EC_NUM - 1].name, \"ecdhx448\") == 0);\n\n    OPENSSL_assert(ec_curves[ECDSA_NUM - 1].nid == NID_brainpoolP512t1);\n    OPENSSL_assert(strcmp(ecdsa_choices[ECDSA_NUM - 1].name, \"ecdsabrp512t1\") == 0);\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    OPENSSL_assert(sm2_curves[SM2_NUM - 1].nid == NID_sm2);\n    OPENSSL_assert(strcmp(sm2_choices[SM2_NUM - 1].name, \"curveSM2\") == 0);\n#endif\n\n    prog = opt_init(argc, argv, speed_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opterr:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(speed_options);\n            ret = 0;\n            goto end;\n        case OPT_ELAPSED:\n            usertime = 0;\n            break;\n        case OPT_EVP:\n            if (doit[D_EVP]) {\n                BIO_printf(bio_err, \"%s: -evp option cannot be used more than once\\n\", prog);\n                goto opterr;\n            }\n            ERR_set_mark();\n            if (!opt_cipher_silent(opt_arg(), &evp_cipher)) {\n                if (have_md(opt_arg()))\n                    evp_md_name = opt_arg();\n            }\n            if (evp_cipher == NULL && evp_md_name == NULL) {\n                ERR_clear_last_mark();\n                BIO_printf(bio_err,\n                           \"%s: %s is an unknown cipher or digest\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            ERR_pop_to_mark();\n            doit[D_EVP] = 1;\n            break;\n        case OPT_HMAC:\n            if (!have_md(opt_arg())) {\n                BIO_printf(bio_err, \"%s: %s is an unknown digest\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            evp_mac_mdname = opt_arg();\n            doit[D_HMAC] = 1;\n            break;\n        case OPT_CMAC:\n            if (!have_cipher(opt_arg())) {\n                BIO_printf(bio_err, \"%s: %s is an unknown cipher\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            evp_mac_ciphername = opt_arg();\n            doit[D_EVP_CMAC] = 1;\n            break;\n        case OPT_DECRYPT:\n            decrypt = 1;\n            break;\n        case OPT_ENGINE:\n            /*\n             * In a forked execution, an engine might need to be\n             * initialised by each child process, not by the parent.\n             * So store the name here and run setup_engine() later on.\n             */\n            engine_id = opt_arg();\n            break;\n        case OPT_MULTI:\n#ifndef NO_FORK\n            multi = opt_int_arg();\n            if ((size_t)multi >= SIZE_MAX / sizeof(int)) {\n                BIO_printf(bio_err, \"%s: multi argument too large\\n\", prog);\n                return 0;\n            }\n#endif\n            break;\n        case OPT_ASYNCJOBS:\n#ifndef OPENSSL_NO_ASYNC\n            async_jobs = opt_int_arg();\n            if (async_jobs > 99999) {\n                BIO_printf(bio_err, \"%s: too many async_jobs\\n\", prog);\n                goto opterr;\n            }\n            if (!ASYNC_is_capable()) {\n                BIO_printf(bio_err,\n                           \"%s: async_jobs specified but async not supported\\n\",\n                           prog);\n                if (testmode)\n                    /* Return success in the testmode. */\n                    return 0;\n                goto opterr;\n            }\n#endif\n            break;\n        case OPT_MISALIGN:\n            misalign = opt_int_arg();\n            if (misalign > MISALIGN) {\n                BIO_printf(bio_err,\n                           \"%s: Maximum offset is %d\\n\", prog, MISALIGN);\n                goto opterr;\n            }\n            break;\n        case OPT_MR:\n            mr = 1;\n            break;\n        case OPT_MB:\n            multiblock = 1;\n#ifdef OPENSSL_NO_MULTIBLOCK\n            BIO_printf(bio_err,\n                       \"%s: -mb specified but multi-block support is disabled\\n\",\n                       prog);\n            goto end;\n#endif\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_PRIMES:\n            primes = opt_int_arg();\n            break;\n        case OPT_SECONDS:\n            seconds.sym = seconds.rsa = seconds.dsa = seconds.ecdsa\n                        = seconds.ecdh = seconds.eddsa\n                        = seconds.sm2 = seconds.ffdh\n                        = seconds.kem = seconds.sig = opt_int_arg();\n            break;\n        case OPT_BYTES:\n            lengths_single = opt_int_arg();\n            lengths = &lengths_single;\n            size_num = 1;\n            break;\n        case OPT_AEAD:\n            aead = 1;\n            break;\n        case OPT_KEM:\n            do_kems = 1;\n            break;\n        case OPT_SIG:\n            do_sigs = 1;\n            break;\n        case OPT_MLOCK:\n            domlock = 1;\n#if !defined(_WIN32) && !defined(OPENSSL_SYS_LINUX)\n            BIO_printf(bio_err,\n                       \"%s: -mlock not supported on this platform\\n\",\n                       prog);\n            goto end;\n#endif\n            break;\n        case OPT_TESTMODE:\n            testmode = 1;\n            break;\n        }\n    }\n\n    /* find all KEMs currently available */\n    kem_stack = sk_EVP_KEM_new(kems_cmp);\n    EVP_KEM_do_all_provided(app_get0_libctx(), collect_kem, kem_stack);\n\n    kems_algs_len = 0;\n\n    for (idx = 0; idx < (unsigned int)sk_EVP_KEM_num(kem_stack); idx++) {\n        EVP_KEM *kem = sk_EVP_KEM_value(kem_stack, idx);\n\n        if (strcmp(EVP_KEM_get0_name(kem), \"RSA\") == 0) {\n            if (kems_algs_len + OSSL_NELEM(rsa_choices) >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < OSSL_NELEM(rsa_choices); i++) {\n                kems_doit[kems_algs_len] = 1;\n                kems_algname[kems_algs_len++] = OPENSSL_strdup(rsa_choices[i].name);\n            }\n        } else if (strcmp(EVP_KEM_get0_name(kem), \"EC\") == 0) {\n            if (kems_algs_len + 3 >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-256\");\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-384\");\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-521\");\n        } else {\n            if (kems_algs_len + 1 >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(EVP_KEM_get0_name(kem));\n        }\n    }\n    sk_EVP_KEM_pop_free(kem_stack, EVP_KEM_free);\n    kem_stack = NULL;\n\n    /* find all SIGNATUREs currently available */\n    sig_stack = sk_EVP_SIGNATURE_new(signatures_cmp);\n    EVP_SIGNATURE_do_all_provided(app_get0_libctx(), collect_signatures, sig_stack);\n\n    sigs_algs_len = 0;\n\n    for (idx = 0; idx < (unsigned int)sk_EVP_SIGNATURE_num(sig_stack); idx++) {\n        EVP_SIGNATURE *s = sk_EVP_SIGNATURE_value(sig_stack, idx);\n        const char *sig_name = EVP_SIGNATURE_get0_name(s);\n\n        if (strcmp(sig_name, \"RSA\") == 0) {\n            if (sigs_algs_len + OSSL_NELEM(rsa_choices) >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < OSSL_NELEM(rsa_choices); i++) {\n                sigs_doit[sigs_algs_len] = 1;\n                sigs_algname[sigs_algs_len++] = OPENSSL_strdup(rsa_choices[i].name);\n            }\n        }\n#ifndef OPENSSL_NO_DSA\n        else if (strcmp(sig_name, \"DSA\") == 0) {\n            if (sigs_algs_len + DSA_NUM >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < DSA_NUM; i++) {\n                sigs_doit[sigs_algs_len] = 1;\n                sigs_algname[sigs_algs_len++] = OPENSSL_strdup(dsa_choices[i].name);\n            }\n        }\n#endif /* OPENSSL_NO_DSA */\n        /* skipping these algs as tested elsewhere - and b/o setup is a pain */\n        else if (strcmp(sig_name, \"ED25519\") &&\n                 strcmp(sig_name, \"ED448\") &&\n                 strcmp(sig_name, \"ECDSA\") &&\n                 strcmp(sig_name, \"HMAC\") &&\n                 strcmp(sig_name, \"SIPHASH\") &&\n                 strcmp(sig_name, \"POLY1305\") &&\n                 strcmp(sig_name, \"CMAC\") &&\n                 strcmp(sig_name, \"SM2\")) { /* skip alg */\n            if (sigs_algs_len + 1 >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            /* activate this provider algorithm */\n            sigs_doit[sigs_algs_len] = 1;\n            sigs_algname[sigs_algs_len++] = OPENSSL_strdup(sig_name);\n        }\n    }\n    sk_EVP_SIGNATURE_pop_free(sig_stack, EVP_SIGNATURE_free);\n    sig_stack = NULL;\n\n    /* Remaining arguments are algorithms. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_RAND_load())\n        goto end;\n\n    for (; *argv; argv++) {\n        const char *algo = *argv;\n        int algo_found = 0;\n\n        if (opt_found(algo, doit_choices, &i)) {\n            doit[i] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"des\") == 0) {\n            doit[D_CBC_DES] = doit[D_EDE3_DES] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"sha\") == 0) {\n            doit[D_SHA1] = doit[D_SHA256] = doit[D_SHA512] = 1;\n            algo_found = 1;\n        }\n#ifndef OPENSSL_NO_DEPRECATED_3_0\n        if (strcmp(algo, \"openssl\") == 0) /* just for compatibility */\n            algo_found = 1;\n#endif\n        if (HAS_PREFIX(algo, \"rsa\")) {\n            if (algo[sizeof(\"rsa\") - 1] == '\\0') {\n                memset(rsa_doit, 1, sizeof(rsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, rsa_choices, &i)) {\n                rsa_doit[i] = 1;\n                algo_found = 1;\n            }\n        }\n#ifndef OPENSSL_NO_DH\n        if (HAS_PREFIX(algo, \"ffdh\")) {\n            if (algo[sizeof(\"ffdh\") - 1] == '\\0') {\n                memset(ffdh_doit, 1, sizeof(ffdh_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ffdh_choices, &i)) {\n                ffdh_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_DSA\n        if (HAS_PREFIX(algo, \"dsa\")) {\n            if (algo[sizeof(\"dsa\") - 1] == '\\0') {\n                memset(dsa_doit, 1, sizeof(dsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, dsa_choices, &i)) {\n                dsa_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#endif\n        if (strcmp(algo, \"aes\") == 0) {\n            doit[D_CBC_128_AES] = doit[D_CBC_192_AES] = doit[D_CBC_256_AES] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"camellia\") == 0) {\n            doit[D_CBC_128_CML] = doit[D_CBC_192_CML] = doit[D_CBC_256_CML] = 1;\n            algo_found = 1;\n        }\n        if (HAS_PREFIX(algo, \"ecdsa\")) {\n            if (algo[sizeof(\"ecdsa\") - 1] == '\\0') {\n                memset(ecdsa_doit, 1, sizeof(ecdsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ecdsa_choices, &i)) {\n                ecdsa_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n        if (HAS_PREFIX(algo, \"ecdh\")) {\n            if (algo[sizeof(\"ecdh\") - 1] == '\\0') {\n                memset(ecdh_doit, 1, sizeof(ecdh_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ecdh_choices, &i)) {\n                ecdh_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#ifndef OPENSSL_NO_ECX\n        if (strcmp(algo, \"eddsa\") == 0) {\n            memset(eddsa_doit, 1, sizeof(eddsa_doit));\n            algo_found = 1;\n        }\n        if (opt_found(algo, eddsa_choices, &i)) {\n            eddsa_doit[i] = 2;\n            algo_found = 1;\n        }\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        if (strcmp(algo, \"sm2\") == 0) {\n            memset(sm2_doit, 1, sizeof(sm2_doit));\n            algo_found = 1;\n        }\n        if (opt_found(algo, sm2_choices, &i)) {\n            sm2_doit[i] = 2;\n            algo_found = 1;\n        }\n#endif\n        if (kem_locate(algo, &idx)) {\n            kems_doit[idx]++;\n            do_kems = 1;\n            algo_found = 1;\n        }\n        if (sig_locate(algo, &idx)) {\n            sigs_doit[idx]++;\n            do_sigs = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"kmac\") == 0) {\n            doit[D_KMAC128] = doit[D_KMAC256] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"cmac\") == 0) {\n            doit[D_EVP_CMAC] = 1;\n            algo_found = 1;\n        }\n\n        if (!algo_found) {\n            BIO_printf(bio_err, \"%s: Unknown algorithm %s\\n\", prog, algo);\n            goto end;\n        }\n    }\n\n    /* Sanity checks */\n    if (aead) {\n        if (evp_cipher == NULL) {\n            BIO_printf(bio_err, \"-aead can be used only with an AEAD cipher\\n\");\n            goto end;\n        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &\n                     EVP_CIPH_FLAG_AEAD_CIPHER)) {\n            BIO_printf(bio_err, \"%s is not an AEAD cipher\\n\",\n                       EVP_CIPHER_get0_name(evp_cipher));\n            goto end;\n        }\n    }\n    if (kems_algs_len > 0) {\n        int maxcnt = get_max(kems_doit, kems_algs_len);\n\n        if (maxcnt > 1) {\n            /* some algs explicitly selected */\n            for (i = 0; i < kems_algs_len; i++) {\n                /* disable the rest */\n                kems_doit[i]--;\n            }\n        }\n    }\n    if (sigs_algs_len > 0) {\n        int maxcnt = get_max(sigs_doit, sigs_algs_len);\n\n        if (maxcnt > 1) {\n            /* some algs explicitly selected */\n            for (i = 0; i < sigs_algs_len; i++) {\n                /* disable the rest */\n                sigs_doit[i]--;\n            }\n        }\n    }\n    if (multiblock) {\n        if (evp_cipher == NULL) {\n            BIO_printf(bio_err, \"-mb can be used only with a multi-block\"\n                                \" capable cipher\\n\");\n            goto end;\n        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &\n                     EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {\n            BIO_printf(bio_err, \"%s is not a multi-block capable\\n\",\n                       EVP_CIPHER_get0_name(evp_cipher));\n            goto end;\n        } else if (async_jobs > 0) {\n            BIO_printf(bio_err, \"Async mode is not supported with -mb\");\n            goto end;\n        }\n    }\n\n    /* Initialize the job pool if async mode is enabled */\n    if (async_jobs > 0) {\n        async_init = ASYNC_init_thread(async_jobs, async_jobs);\n        if (!async_init) {\n            BIO_printf(bio_err, \"Error creating the ASYNC job pool\\n\");\n            goto end;\n        }\n    }\n\n    loopargs_len = (async_jobs == 0 ? 1 : async_jobs);\n    loopargs =\n        app_malloc(loopargs_len * sizeof(loopargs_t), \"array of loopargs\");\n    memset(loopargs, 0, loopargs_len * sizeof(loopargs_t));\n\n    buflen = lengths[size_num - 1];\n    if (buflen < 36)    /* size of random vector in RSA benchmark */\n        buflen = 36;\n    if (INT_MAX - (MAX_MISALIGNMENT + 1) < buflen) {\n        BIO_printf(bio_err, \"Error: buffer size too large\\n\");\n        goto end;\n    }\n    buflen += MAX_MISALIGNMENT + 1;\n    for (i = 0; i < loopargs_len; i++) {\n        if (async_jobs > 0) {\n            loopargs[i].wait_ctx = ASYNC_WAIT_CTX_new();\n            if (loopargs[i].wait_ctx == NULL) {\n                BIO_printf(bio_err, \"Error creating the ASYNC_WAIT_CTX\\n\");\n                goto end;\n            }\n        }\n\n        loopargs[i].buf_malloc = app_malloc(buflen, \"input buffer\");\n        loopargs[i].buf2_malloc = app_malloc(buflen, \"input buffer\");\n\n        /* Align the start of buffers on a 64 byte boundary */\n        loopargs[i].buf = loopargs[i].buf_malloc + misalign;\n        loopargs[i].buf2 = loopargs[i].buf2_malloc + misalign;\n        loopargs[i].buflen = buflen - misalign;\n        loopargs[i].sigsize = buflen - misalign;\n        loopargs[i].secret_a = app_malloc(MAX_ECDH_SIZE, \"ECDH secret a\");\n        loopargs[i].secret_b = app_malloc(MAX_ECDH_SIZE, \"ECDH secret b\");\n#ifndef OPENSSL_NO_DH\n        loopargs[i].secret_ff_a = app_malloc(MAX_FFDH_SIZE, \"FFDH secret a\");\n        loopargs[i].secret_ff_b = app_malloc(MAX_FFDH_SIZE, \"FFDH secret b\");\n#endif\n    }\n\n#ifndef NO_FORK\n    if (multi && do_multi(multi, size_num))\n        goto show_res;\n#endif\n\n    for (i = 0; i < loopargs_len; ++i) {\n        if (domlock) {\n#if defined(_WIN32)\n            (void)VirtualLock(loopargs[i].buf_malloc, buflen);\n            (void)VirtualLock(loopargs[i].buf2_malloc, buflen);\n#elif defined(OPENSSL_SYS_LINUX)\n            (void)mlock(loopargs[i].buf_malloc, buflen);\n            (void)mlock(loopargs[i].buf_malloc, buflen);\n#endif\n        }\n        memset(loopargs[i].buf_malloc, 0, buflen);\n        memset(loopargs[i].buf2_malloc, 0, buflen);\n    }\n\n    /* Initialize the engine after the fork */\n    e = setup_engine(engine_id, 0);\n\n    /* No parameters; turn on everything. */\n    if (argc == 0 && !doit[D_EVP] && !doit[D_HMAC]\n        && !doit[D_EVP_CMAC] && !do_kems && !do_sigs) {\n        memset(doit, 1, sizeof(doit));\n        doit[D_EVP] = doit[D_EVP_CMAC] = 0;\n        ERR_set_mark();\n        for (i = D_MD2; i <= D_WHIRLPOOL; i++) {\n            if (!have_md(names[i]))\n                doit[i] = 0;\n        }\n        for (i = D_CBC_DES; i <= D_CBC_256_CML; i++) {\n            if (!have_cipher(names[i]))\n                doit[i] = 0;\n        }\n        if ((mac = EVP_MAC_fetch(app_get0_libctx(), \"GMAC\",\n                                 app_get0_propq())) != NULL) {\n            EVP_MAC_free(mac);\n            mac = NULL;\n        } else {\n            doit[D_GHASH] = 0;\n        }\n        if ((mac = EVP_MAC_fetch(app_get0_libctx(), \"HMAC\",\n                                 app_get0_propq())) != NULL) {\n            EVP_MAC_free(mac);\n            mac = NULL;\n        } else {\n            doit[D_HMAC] = 0;\n        }\n        ERR_pop_to_mark();\n        memset(rsa_doit, 1, sizeof(rsa_doit));\n#ifndef OPENSSL_NO_DH\n        memset(ffdh_doit, 1, sizeof(ffdh_doit));\n#endif\n#ifndef OPENSSL_NO_DSA\n        memset(dsa_doit, 1, sizeof(dsa_doit));\n#endif\n#ifndef OPENSSL_NO_ECX\n        memset(ecdsa_doit, 1, sizeof(ecdsa_doit));\n        memset(ecdh_doit, 1, sizeof(ecdh_doit));\n        memset(eddsa_doit, 1, sizeof(eddsa_doit));\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        memset(sm2_doit, 1, sizeof(sm2_doit));\n#endif\n        memset(kems_doit, 1, sizeof(kems_doit));\n        do_kems = 1;\n        memset(sigs_doit, 1, sizeof(sigs_doit));\n        do_sigs = 1;\n    }\n    for (i = 0; i < ALGOR_NUM; i++)\n        if (doit[i])\n            pr_header++;\n\n    if (usertime == 0 && !mr)\n        BIO_printf(bio_err,\n                   \"You have chosen to measure elapsed time \"\n                   \"instead of user CPU time.\\n\");\n\n#if SIGALRM > 0\n    signal(SIGALRM, alarmed);\n#endif\n\n    if (doit[D_MD2]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD2], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MD2_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD2, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MDC2]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MDC2], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MDC2_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MDC2, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MD4]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD4], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MD4_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD4, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MD5]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD5], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, MD5_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD5, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA1]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA1], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA1_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA1, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA256]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA256], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA256_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA256, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA512]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA512], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA512_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA512, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_WHIRLPOOL]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_WHIRLPOOL], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, WHIRLPOOL_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_WHIRLPOOL, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_RMD160]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_RMD160], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_RMD160_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_RMD160, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_HMAC]) {\n        static const char hmac_key[] = \"This is a key...\";\n        int len = strlen(hmac_key);\n        size_t hmac_name_len = sizeof(\"hmac()\") + strlen(evp_mac_mdname);\n        OSSL_PARAM params[3];\n\n        if (evp_mac_mdname == NULL)\n            goto end;\n        evp_hmac_name = app_malloc(hmac_name_len, \"HMAC name\");\n        BIO_snprintf(evp_hmac_name, hmac_name_len, \"hmac(%s)\", evp_mac_mdname);\n        names[D_HMAC] = evp_hmac_name;\n\n        params[0] =\n            OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                             evp_mac_mdname, 0);\n        params[1] =\n            OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                              (char *)hmac_key, len);\n        params[2] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"HMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_HMAC], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, HMAC_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_HMAC, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_CBC_DES]) {\n        int st = 1;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ctx = init_evp_cipher_ctx(\"des-cbc\", deskey,\n                                                  sizeof(deskey) / 3);\n            st = loopargs[i].ctx != NULL;\n        }\n        algindex = D_CBC_DES;\n        for (testnum = 0; st && testnum < size_num; testnum++) {\n            if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                break;\n            print_message(names[D_CBC_DES], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_CBC_DES, testnum, count, d);\n        }\n        for (i = 0; i < loopargs_len; i++)\n            EVP_CIPHER_CTX_free(loopargs[i].ctx);\n    }\n\n    if (doit[D_EDE3_DES]) {\n        int st = 1;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ctx = init_evp_cipher_ctx(\"des-ede3-cbc\", deskey,\n                                                  sizeof(deskey));\n            st = loopargs[i].ctx != NULL;\n        }\n        algindex = D_EDE3_DES;\n        for (testnum = 0; st && testnum < size_num; testnum++) {\n            if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                break;\n            print_message(names[D_EDE3_DES], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_EDE3_DES, testnum, count, d);\n        }\n        for (i = 0; i < loopargs_len; i++)\n            EVP_CIPHER_CTX_free(loopargs[i].ctx);\n    }\n\n    for (k = 0; k < 3; k++) {\n        algindex = D_CBC_128_AES + k;\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16 + k * 8;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n\n    for (k = 0; k < 3; k++) {\n        algindex = D_CBC_128_CML + k;\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16 + k * 8;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n\n    for (algindex = D_RC4; algindex <= D_CBC_CAST; algindex++) {\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n    if (doit[D_GHASH]) {\n        static const char gmac_iv[] = \"0123456789ab\";\n        OSSL_PARAM params[4];\n\n        params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_CIPHER,\n                                                     \"aes-128-gcm\", 0);\n        params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_IV,\n                                                      (char *)gmac_iv,\n                                                      sizeof(gmac_iv) - 1);\n        params[2] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 16);\n        params[3] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"GMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        /* b/c of the definition of GHASH_loop(), init() calls are needed here */\n        for (i = 0; i < loopargs_len; i++) {\n            if (!EVP_MAC_init(loopargs[i].mctx, NULL, 0, NULL))\n                goto end;\n        }\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_GHASH], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, GHASH_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_GHASH, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_RAND]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_RAND], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, RAND_bytes_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_RAND, testnum, count, d);\n        }\n    }\n\n    /*-\n     * There are three scenarios for D_EVP:\n     * 1- Using authenticated encryption (AE) e.g. CCM, GCM, OCB etc.\n     * 2- Using AE + associated data (AD) i.e. AEAD using CCM, GCM, OCB etc.\n     * 3- Not using AE or AD e.g. ECB, CBC, CFB etc.\n     */\n    if (doit[D_EVP]) {\n        if (evp_cipher != NULL) {\n            int (*loopfunc) (void *);\n            int outlen = 0;\n            unsigned int ae_mode = 0;\n\n            if (multiblock && (EVP_CIPHER_get_flags(evp_cipher)\n                               & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {\n                multiblock_speed(evp_cipher, lengths_single, &seconds);\n                ret = 0;\n                goto end;\n            }\n\n            names[D_EVP] = EVP_CIPHER_get0_name(evp_cipher);\n\n            mode_op = EVP_CIPHER_get_mode(evp_cipher);\n\n            if (aead) {\n                if (lengths == lengths_list) {\n                    lengths = aead_lengths_list;\n                    size_num = OSSL_NELEM(aead_lengths_list);\n                }\n            }\n            if (mode_op == EVP_CIPH_GCM_MODE\n                || mode_op == EVP_CIPH_CCM_MODE\n                || mode_op == EVP_CIPH_OCB_MODE\n                || mode_op == EVP_CIPH_SIV_MODE\n                || mode_op == EVP_CIPH_GCM_SIV_MODE) {\n                ae_mode = 1;\n                if (decrypt)\n                    loopfunc = EVP_Update_loop_aead_dec;\n                else\n                    loopfunc = EVP_Update_loop_aead_enc;\n            } else {\n                loopfunc = EVP_Update_loop;\n            }\n\n            for (testnum = 0; testnum < size_num; testnum++) {\n                print_message(names[D_EVP], lengths[testnum], seconds.sym);\n\n                for (k = 0; k < loopargs_len; k++) {\n                    loopargs[k].ctx = EVP_CIPHER_CTX_new();\n                    if (loopargs[k].ctx == NULL) {\n                        BIO_printf(bio_err, \"\\nEVP_CIPHER_CTX_new failure\\n\");\n                        exit(1);\n                    }\n\n                    /*\n                     * For AE modes, we must first encrypt the data to get\n                     * a valid tag that enables us to decrypt. If we don't\n                     * encrypt first, we won't have a valid tag that enables\n                     * authenticity and hence decryption will fail.\n                     */\n                    if (!EVP_CipherInit_ex(loopargs[k].ctx, evp_cipher, NULL,\n                                           NULL, NULL, ae_mode ? 1 : !decrypt)) {\n                        BIO_printf(bio_err, \"\\nCouldn't init the context\\n\");\n                        dofail();\n                        exit(1);\n                    }\n\n                    /* Padding isn't needed */\n                    EVP_CIPHER_CTX_set_padding(loopargs[k].ctx, 0);\n\n                    keylen = EVP_CIPHER_CTX_get_key_length(loopargs[k].ctx);\n                    loopargs[k].key = app_malloc(keylen, \"evp_cipher key\");\n                    EVP_CIPHER_CTX_rand_key(loopargs[k].ctx, loopargs[k].key);\n\n                    if (!ae_mode) {\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, NULL, NULL,\n                                               loopargs[k].key, NULL, -1)) {\n                            BIO_printf(bio_err, \"\\nFailed to set the key\\n\");\n                            dofail();\n                            exit(1);\n                        }\n                    } else if (mode_op == EVP_CIPH_SIV_MODE\n                               || mode_op == EVP_CIPH_GCM_SIV_MODE) {\n                        EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                            EVP_CTRL_SET_SPEED, 1, NULL);\n                    }\n                    if (ae_mode && decrypt) {\n                        /* Set length of iv (Doesn't apply to SIV mode) */\n                        if (mode_op != EVP_CIPH_SIV_MODE) {\n                            if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                     EVP_CTRL_AEAD_SET_IVLEN,\n                                                     aead_ivlen, NULL)) {\n                                BIO_printf(bio_err, \"\\nFailed to set iv length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        /* Set tag_len (Not for GCM/SIV at encryption stage) */\n                        if (mode_op != EVP_CIPH_GCM_MODE\n                            && mode_op != EVP_CIPH_SIV_MODE\n                            && mode_op != EVP_CIPH_GCM_SIV_MODE) {\n                            if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                     EVP_CTRL_AEAD_SET_TAG,\n                                                     TAG_LEN, NULL)) {\n                                BIO_printf(bio_err,\n                                           \"\\nFailed to set tag length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, NULL, NULL,\n                                               loopargs[k].key, aead_iv, -1)) {\n                            BIO_printf(bio_err, \"\\nFailed to set the key\\n\");\n                            dofail();\n                            exit(1);\n                        }\n                        /* Set total length of input. Only required for CCM */\n                        if (mode_op == EVP_CIPH_CCM_MODE) {\n                            if (!EVP_EncryptUpdate(loopargs[k].ctx, NULL,\n                                                   &outlen, NULL,\n                                                   lengths[testnum])) {\n                                BIO_printf(bio_err,\n                                           \"\\nCouldn't set input text length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (aead) {\n                            if (!EVP_EncryptUpdate(loopargs[k].ctx, NULL,\n                                                   &outlen, aad, sizeof(aad))) {\n                                BIO_printf(bio_err,\n                                           \"\\nCouldn't insert AAD when encrypting\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (!EVP_EncryptUpdate(loopargs[k].ctx, loopargs[k].buf,\n                                               &outlen, loopargs[k].buf,\n                                               lengths[testnum])) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed to to encrypt the data\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        if (!EVP_EncryptFinal_ex(loopargs[k].ctx,\n                                                 loopargs[k].buf, &outlen)) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed finalize the encryption\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx, EVP_CTRL_AEAD_GET_TAG,\n                                                 TAG_LEN, &loopargs[k].tag)) {\n                            BIO_printf(bio_err, \"\\nFailed to get the tag\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        EVP_CIPHER_CTX_free(loopargs[k].ctx);\n                        loopargs[k].ctx = EVP_CIPHER_CTX_new();\n                        if (loopargs[k].ctx == NULL) {\n                            BIO_printf(bio_err,\n                                       \"\\nEVP_CIPHER_CTX_new failure\\n\");\n                            exit(1);\n                        }\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, evp_cipher,\n                                               NULL, NULL, NULL, 0)) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed initializing the context\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        EVP_CIPHER_CTX_set_padding(loopargs[k].ctx, 0);\n\n                        /* GCM-SIV/SIV only allows for a single Update operation */\n                        if (mode_op == EVP_CIPH_SIV_MODE\n                            || mode_op == EVP_CIPH_GCM_SIV_MODE)\n                            EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                EVP_CTRL_SET_SPEED, 1, NULL);\n                    }\n                }\n\n                Time_F(START);\n                count = run_benchmark(async_jobs, loopfunc, loopargs);\n                d = Time_F(STOP);\n                for (k = 0; k < loopargs_len; k++) {\n                    OPENSSL_clear_free(loopargs[k].key, keylen);\n                    EVP_CIPHER_CTX_free(loopargs[k].ctx);\n                }\n                print_result(D_EVP, testnum, count, d);\n            }\n        } else if (evp_md_name != NULL) {\n            names[D_EVP] = evp_md_name;\n\n            for (testnum = 0; testnum < size_num; testnum++) {\n                print_message(names[D_EVP], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EVP_Digest_md_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(D_EVP, testnum, count, d);\n                if (count < 0)\n                    break;\n            }\n        }\n    }\n\n    if (doit[D_EVP_CMAC]) {\n        size_t len = sizeof(\"cmac()\") + strlen(evp_mac_ciphername);\n        OSSL_PARAM params[3];\n        EVP_CIPHER *cipher = NULL;\n\n        if (!opt_cipher(evp_mac_ciphername, &cipher))\n            goto end;\n\n        keylen = EVP_CIPHER_get_key_length(cipher);\n        EVP_CIPHER_free(cipher);\n        if (keylen <= 0 || keylen > (int)sizeof(key32)) {\n            BIO_printf(bio_err, \"\\nRequested CMAC cipher with unsupported key length.\\n\");\n            goto end;\n        }\n        evp_cmac_name = app_malloc(len, \"CMAC name\");\n        BIO_snprintf(evp_cmac_name, len, \"cmac(%s)\", evp_mac_ciphername);\n        names[D_EVP_CMAC] = evp_cmac_name;\n\n        params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_CIPHER,\n                                                     evp_mac_ciphername, 0);\n        params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (char *)key32, keylen);\n        params[2] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"CMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_EVP_CMAC], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, CMAC_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_EVP_CMAC, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_KMAC128]) {\n        OSSL_PARAM params[2];\n\n        params[0] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 16);\n        params[1] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"KMAC-128\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_KMAC128], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, KMAC128_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_KMAC128, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_KMAC256]) {\n        OSSL_PARAM params[2];\n\n        params[0] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 32);\n        params[1] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"KMAC-256\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_KMAC256], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, KMAC256_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_KMAC256, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    for (i = 0; i < loopargs_len; i++)\n        if (RAND_bytes(loopargs[i].buf, 36) <= 0)\n            goto end;\n\n    for (testnum = 0; testnum < RSA_NUM; testnum++) {\n        EVP_PKEY *rsa_key = NULL;\n        int st = 0;\n\n        if (!rsa_doit[testnum])\n            continue;\n\n        if (primes > RSA_DEFAULT_PRIME_NUM) {\n            /* we haven't set keys yet,  generate multi-prime RSA keys */\n            bn = BN_new();\n            st = bn != NULL\n                && BN_set_word(bn, RSA_F4)\n                && init_gen_str(&genctx, \"RSA\", NULL, 0, NULL, NULL)\n                && EVP_PKEY_CTX_set_rsa_keygen_bits(genctx, rsa_keys[testnum].bits) > 0\n                && EVP_PKEY_CTX_set1_rsa_keygen_pubexp(genctx, bn) > 0\n                && EVP_PKEY_CTX_set_rsa_keygen_primes(genctx, primes) > 0\n                && EVP_PKEY_keygen(genctx, &rsa_key);\n            BN_free(bn);\n            bn = NULL;\n            EVP_PKEY_CTX_free(genctx);\n            genctx = NULL;\n        } else {\n            const unsigned char *p = rsa_keys[testnum].data;\n\n            st = (rsa_key = d2i_PrivateKey(EVP_PKEY_RSA, NULL, &p,\n                                           rsa_keys[testnum].length)) != NULL;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].rsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].rsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].rsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA sign setup failure.  No RSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"private\", \"rsa sign\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R1:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits private RSA sign ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key,\n                                                                   NULL);\n            if (loopargs[i].rsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].rsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].rsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA verify setup failure.  No RSA verify will be done.\\n\");\n            dofail();\n            rsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"public\", \"rsa verify\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R2:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits public RSA verify ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][1] = (double)count / d;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_encrypt_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            loopargs[i].encsize = loopargs[i].buflen;\n            if (loopargs[i].rsa_encrypt_ctx[testnum] == NULL\n                || EVP_PKEY_encrypt_init(loopargs[i].rsa_encrypt_ctx[testnum]) <= 0\n                || EVP_PKEY_encrypt(loopargs[i].rsa_encrypt_ctx[testnum],\n                                    loopargs[i].buf2,\n                                    &loopargs[i].encsize,\n                                    loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA encrypt setup failure.  No RSA encrypt will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"public\", \"rsa encrypt\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_encrypt_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R3:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits public RSA encrypt ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_decrypt_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            declen = loopargs[i].buflen;\n            if (loopargs[i].rsa_decrypt_ctx[testnum] == NULL\n                || EVP_PKEY_decrypt_init(loopargs[i].rsa_decrypt_ctx[testnum]) <= 0\n                || EVP_PKEY_decrypt(loopargs[i].rsa_decrypt_ctx[testnum],\n                                    loopargs[i].buf,\n                                    &declen,\n                                    loopargs[i].buf2,\n                                    loopargs[i].encsize) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA decrypt setup failure.  No RSA decrypt will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"private\", \"rsa decrypt\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_decrypt_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R4:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits private RSA decrypt ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][3] = (double)count / d;\n            op_count = count;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(rsa_doit, testnum);\n        }\n        EVP_PKEY_free(rsa_key);\n    }\n\n#ifndef OPENSSL_NO_DSA\n    for (testnum = 0; testnum < DSA_NUM; testnum++) {\n        EVP_PKEY *dsa_key = NULL;\n        int st;\n\n        if (!dsa_doit[testnum])\n            continue;\n\n        st = (dsa_key = get_dsa(dsa_bits[testnum])) != NULL;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].dsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(dsa_key,\n                                                                 NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].dsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].dsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].dsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"DSA sign setup failure.  No DSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"sign\", \"dsa\",\n                               dsa_bits[testnum], seconds.dsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, DSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R5:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits DSA sign ops in %.2fs\\n\",\n                       count, dsa_bits[testnum], d);\n            dsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].dsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(dsa_key,\n                                                                   NULL);\n            if (loopargs[i].dsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].dsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].dsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"DSA verify setup failure.  No DSA verify will be done.\\n\");\n            dofail();\n            dsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"verify\", \"dsa\",\n                               dsa_bits[testnum], seconds.dsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, DSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R6:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits DSA verify ops in %.2fs\\n\",\n                       count, dsa_bits[testnum], d);\n            dsa_results[testnum][1] = (double)count / d;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(dsa_doit, testnum);\n        }\n        EVP_PKEY_free(dsa_key);\n    }\n#endif /* OPENSSL_NO_DSA */\n\n    for (testnum = 0; testnum < ECDSA_NUM; testnum++) {\n        EVP_PKEY *ecdsa_key = NULL;\n        int st;\n\n        if (!ecdsa_doit[testnum])\n            continue;\n\n        st = (ecdsa_key = get_ecdsa(&ec_curves[testnum])) != NULL;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ecdsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(ecdsa_key,\n                                                                   NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].ecdsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].ecdsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].ecdsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"ECDSA sign setup failure.  No ECDSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"sign\", \"ecdsa\",\n                               ec_curves[testnum].bits, seconds.ecdsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, ECDSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R7:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits ECDSA sign ops in %.2fs\\n\",\n                       count, ec_curves[testnum].bits, d);\n            ecdsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ecdsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(ecdsa_key,\n                                                                     NULL);\n            if (loopargs[i].ecdsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].ecdsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].ecdsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"ECDSA verify setup failure.  No ECDSA verify will be done.\\n\");\n            dofail();\n            ecdsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"verify\", \"ecdsa\",\n                               ec_curves[testnum].bits, seconds.ecdsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, ECDSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R8:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits ECDSA verify ops in %.2fs\\n\",\n                       count, ec_curves[testnum].bits, d);\n            ecdsa_results[testnum][1] = (double)count / d;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ecdsa_doit, testnum);\n        }\n        EVP_PKEY_free(ecdsa_key);\n    }\n\n    for (testnum = 0; testnum < EC_NUM; testnum++) {\n        int ecdh_checks = 1;\n\n        if (!ecdh_doit[testnum])\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY_CTX *test_ctx = NULL;\n            EVP_PKEY_CTX *ctx = NULL;\n            EVP_PKEY *key_A = NULL;\n            EVP_PKEY *key_B = NULL;\n            size_t outlen;\n            size_t test_outlen;\n\n            if ((key_A = get_ecdsa(&ec_curves[testnum])) == NULL /* generate secret key A */\n                || (key_B = get_ecdsa(&ec_curves[testnum])) == NULL /* generate secret key B */\n                || (ctx = EVP_PKEY_CTX_new(key_A, NULL)) == NULL /* derivation ctx from skeyA */\n                || EVP_PKEY_derive_init(ctx) <= 0 /* init derivation ctx */\n                || EVP_PKEY_derive_set_peer(ctx, key_B) <= 0 /* set peer pubkey in ctx */\n                || EVP_PKEY_derive(ctx, NULL, &outlen) <= 0 /* determine max length */\n                || outlen == 0 /* ensure outlen is a valid size */\n                || outlen > MAX_ECDH_SIZE /* avoid buffer overflow */) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH key generation failure.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            /*\n             * Here we perform a test run, comparing the output of a*B and b*A;\n             * we try this here and assume that further EVP_PKEY_derive calls\n             * never fail, so we can skip checks in the actually benchmarked\n             * code, for maximum performance.\n             */\n            if ((test_ctx = EVP_PKEY_CTX_new(key_B, NULL)) == NULL /* test ctx from skeyB */\n                || EVP_PKEY_derive_init(test_ctx) <= 0 /* init derivation test_ctx */\n                || EVP_PKEY_derive_set_peer(test_ctx, key_A) <= 0 /* set peer pubkey in test_ctx */\n                || EVP_PKEY_derive(test_ctx, NULL, &test_outlen) <= 0 /* determine max length */\n                || EVP_PKEY_derive(ctx, loopargs[i].secret_a, &outlen) <= 0 /* compute a*B */\n                || EVP_PKEY_derive(test_ctx, loopargs[i].secret_b, &test_outlen) <= 0 /* compute b*A */\n                || test_outlen != outlen /* compare output length */) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH computation failure.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            /* Compare the computation results: CRYPTO_memcmp() returns 0 if equal */\n            if (CRYPTO_memcmp(loopargs[i].secret_a,\n                              loopargs[i].secret_b, outlen)) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH computations don't match.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            loopargs[i].ecdh_ctx[testnum] = ctx;\n            loopargs[i].outlen[testnum] = outlen;\n\n            EVP_PKEY_free(key_A);\n            EVP_PKEY_free(key_B);\n            EVP_PKEY_CTX_free(test_ctx);\n            test_ctx = NULL;\n        }\n        if (ecdh_checks != 0) {\n            pkey_print_message(\"\", \"ecdh\",\n                               ec_curves[testnum].bits, seconds.ecdh);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, ECDH_EVP_derive_key_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R9:%ld:%d:%.2f\\n\" :\n                       \"%ld %u-bits ECDH ops in %.2fs\\n\", count,\n                       ec_curves[testnum].bits, d);\n            ecdh_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ecdh_doit, testnum);\n        }\n    }\n\n#ifndef OPENSSL_NO_ECX\n    for (testnum = 0; testnum < EdDSA_NUM; testnum++) {\n        int st = 1;\n        EVP_PKEY *ed_pkey = NULL;\n        EVP_PKEY_CTX *ed_pctx = NULL;\n\n        if (!eddsa_doit[testnum])\n            continue;           /* Ignore Curve */\n        for (i = 0; i < loopargs_len; i++) {\n            loopargs[i].eddsa_ctx[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].eddsa_ctx[testnum] == NULL) {\n                st = 0;\n                break;\n            }\n            loopargs[i].eddsa_ctx2[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].eddsa_ctx2[testnum] == NULL) {\n                st = 0;\n                break;\n            }\n\n            if ((ed_pctx = EVP_PKEY_CTX_new_id(ed_curves[testnum].nid,\n                                               NULL)) == NULL\n                || EVP_PKEY_keygen_init(ed_pctx) <= 0\n                || EVP_PKEY_keygen(ed_pctx, &ed_pkey) <= 0) {\n                st = 0;\n                EVP_PKEY_CTX_free(ed_pctx);\n                break;\n            }\n            EVP_PKEY_CTX_free(ed_pctx);\n\n            if (!EVP_DigestSignInit(loopargs[i].eddsa_ctx[testnum], NULL, NULL,\n                                    NULL, ed_pkey)) {\n                st = 0;\n                EVP_PKEY_free(ed_pkey);\n                break;\n            }\n            if (!EVP_DigestVerifyInit(loopargs[i].eddsa_ctx2[testnum], NULL,\n                                      NULL, NULL, ed_pkey)) {\n                st = 0;\n                EVP_PKEY_free(ed_pkey);\n                break;\n            }\n\n            EVP_PKEY_free(ed_pkey);\n            ed_pkey = NULL;\n        }\n        if (st == 0) {\n            BIO_printf(bio_err, \"EdDSA failure.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            for (i = 0; i < loopargs_len; i++) {\n                /* Perform EdDSA signature test */\n                loopargs[i].sigsize = ed_curves[testnum].sigsize;\n                st = EVP_DigestSign(loopargs[i].eddsa_ctx[testnum],\n                                    loopargs[i].buf2, &loopargs[i].sigsize,\n                                    loopargs[i].buf, 20);\n                if (st == 0)\n                    break;\n            }\n            if (st == 0) {\n                BIO_printf(bio_err,\n                           \"EdDSA sign failure.  No EdDSA sign will be done.\\n\");\n                dofail();\n                op_count = 1;\n            } else {\n                pkey_print_message(\"sign\", ed_curves[testnum].name,\n                                   ed_curves[testnum].bits, seconds.eddsa);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EdDSA_sign_loop, loopargs);\n                d = Time_F(STOP);\n\n                BIO_printf(bio_err,\n                           mr ? \"+R10:%ld:%u:%s:%.2f\\n\" :\n                           \"%ld %u bits %s sign ops in %.2fs \\n\",\n                           count, ed_curves[testnum].bits,\n                           ed_curves[testnum].name, d);\n                eddsa_results[testnum][0] = (double)count / d;\n                op_count = count;\n            }\n            /* Perform EdDSA verification test */\n            for (i = 0; i < loopargs_len; i++) {\n                st = EVP_DigestVerify(loopargs[i].eddsa_ctx2[testnum],\n                                      loopargs[i].buf2, loopargs[i].sigsize,\n                                      loopargs[i].buf, 20);\n                if (st != 1)\n                    break;\n            }\n            if (st != 1) {\n                BIO_printf(bio_err,\n                           \"EdDSA verify failure.  No EdDSA verify will be done.\\n\");\n                dofail();\n                eddsa_doit[testnum] = 0;\n            } else {\n                pkey_print_message(\"verify\", ed_curves[testnum].name,\n                                   ed_curves[testnum].bits, seconds.eddsa);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EdDSA_verify_loop, loopargs);\n                d = Time_F(STOP);\n                BIO_printf(bio_err,\n                           mr ? \"+R11:%ld:%u:%s:%.2f\\n\"\n                           : \"%ld %u bits %s verify ops in %.2fs\\n\",\n                           count, ed_curves[testnum].bits,\n                           ed_curves[testnum].name, d);\n                eddsa_results[testnum][1] = (double)count / d;\n            }\n\n            if (op_count <= 1) {\n                /* if longer than 10s, don't do any more */\n                stop_it(eddsa_doit, testnum);\n            }\n        }\n    }\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    for (testnum = 0; testnum < SM2_NUM; testnum++) {\n        int st = 1;\n        EVP_PKEY *sm2_pkey = NULL;\n\n        if (!sm2_doit[testnum])\n            continue;           /* Ignore Curve */\n        /* Init signing and verification */\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY_CTX *sm2_pctx = NULL;\n            EVP_PKEY_CTX *sm2_vfy_pctx = NULL;\n            EVP_PKEY_CTX *pctx = NULL;\n            st = 0;\n\n            loopargs[i].sm2_ctx[testnum] = EVP_MD_CTX_new();\n            loopargs[i].sm2_vfy_ctx[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].sm2_ctx[testnum] == NULL\n                    || loopargs[i].sm2_vfy_ctx[testnum] == NULL)\n                break;\n\n            sm2_pkey = NULL;\n\n            st = !((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_SM2, NULL)) == NULL\n                || EVP_PKEY_keygen_init(pctx) <= 0\n                || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,\n                    sm2_curves[testnum].nid) <= 0\n                || EVP_PKEY_keygen(pctx, &sm2_pkey) <= 0);\n            EVP_PKEY_CTX_free(pctx);\n            if (st == 0)\n                break;\n\n            st = 0; /* set back to zero */\n            /* attach it sooner to rely on main final cleanup */\n            loopargs[i].sm2_pkey[testnum] = sm2_pkey;\n            loopargs[i].sigsize = EVP_PKEY_get_size(sm2_pkey);\n\n            sm2_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);\n            sm2_vfy_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);\n            if (sm2_pctx == NULL || sm2_vfy_pctx == NULL) {\n                EVP_PKEY_CTX_free(sm2_vfy_pctx);\n                break;\n            }\n\n            /* attach them directly to respective ctx */\n            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_ctx[testnum], sm2_pctx);\n            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_vfy_ctx[testnum], sm2_vfy_pctx);\n\n            /*\n             * No need to allow user to set an explicit ID here, just use\n             * the one defined in the 'draft-yang-tls-tl13-sm-suites' I-D.\n             */\n            if (EVP_PKEY_CTX_set1_id(sm2_pctx, SM2_ID, SM2_ID_LEN) != 1\n                || EVP_PKEY_CTX_set1_id(sm2_vfy_pctx, SM2_ID, SM2_ID_LEN) != 1)\n                break;\n\n            if (!EVP_DigestSignInit(loopargs[i].sm2_ctx[testnum], NULL,\n                                    EVP_sm3(), NULL, sm2_pkey))\n                break;\n            if (!EVP_DigestVerifyInit(loopargs[i].sm2_vfy_ctx[testnum], NULL,\n                                      EVP_sm3(), NULL, sm2_pkey))\n                break;\n            st = 1;         /* mark loop as succeeded */\n        }\n        if (st == 0) {\n            BIO_printf(bio_err, \"SM2 init failure.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            for (i = 0; i < loopargs_len; i++) {\n                /* Perform SM2 signature test */\n                st = EVP_DigestSign(loopargs[i].sm2_ctx[testnum],\n                                    loopargs[i].buf2, &loopargs[i].sigsize,\n                                    loopargs[i].buf, 20);\n                if (st == 0)\n                    break;\n            }\n            if (st == 0) {\n                BIO_printf(bio_err,\n                           \"SM2 sign failure.  No SM2 sign will be done.\\n\");\n                dofail();\n                op_count = 1;\n            } else {\n                pkey_print_message(\"sign\", sm2_curves[testnum].name,\n                                   sm2_curves[testnum].bits, seconds.sm2);\n                Time_F(START);\n                count = run_benchmark(async_jobs, SM2_sign_loop, loopargs);\n                d = Time_F(STOP);\n\n                BIO_printf(bio_err,\n                           mr ? \"+R12:%ld:%u:%s:%.2f\\n\" :\n                           \"%ld %u bits %s sign ops in %.2fs \\n\",\n                           count, sm2_curves[testnum].bits,\n                           sm2_curves[testnum].name, d);\n                sm2_results[testnum][0] = (double)count / d;\n                op_count = count;\n            }\n\n            /* Perform SM2 verification test */\n            for (i = 0; i < loopargs_len; i++) {\n                st = EVP_DigestVerify(loopargs[i].sm2_vfy_ctx[testnum],\n                                      loopargs[i].buf2, loopargs[i].sigsize,\n                                      loopargs[i].buf, 20);\n                if (st != 1)\n                    break;\n            }\n            if (st != 1) {\n                BIO_printf(bio_err,\n                           \"SM2 verify failure.  No SM2 verify will be done.\\n\");\n                dofail();\n                sm2_doit[testnum] = 0;\n            } else {\n                pkey_print_message(\"verify\", sm2_curves[testnum].name,\n                                   sm2_curves[testnum].bits, seconds.sm2);\n                Time_F(START);\n                count = run_benchmark(async_jobs, SM2_verify_loop, loopargs);\n                d = Time_F(STOP);\n                BIO_printf(bio_err,\n                           mr ? \"+R13:%ld:%u:%s:%.2f\\n\"\n                           : \"%ld %u bits %s verify ops in %.2fs\\n\",\n                           count, sm2_curves[testnum].bits,\n                           sm2_curves[testnum].name, d);\n                sm2_results[testnum][1] = (double)count / d;\n            }\n\n            if (op_count <= 1) {\n                /* if longer than 10s, don't do any more */\n                for (testnum++; testnum < SM2_NUM; testnum++)\n                    sm2_doit[testnum] = 0;\n            }\n        }\n    }\n#endif                         /* OPENSSL_NO_SM2 */\n\n#ifndef OPENSSL_NO_DH\n    for (testnum = 0; testnum < FFDH_NUM; testnum++) {\n        int ffdh_checks = 1;\n\n        if (!ffdh_doit[testnum])\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey_A = NULL;\n            EVP_PKEY *pkey_B = NULL;\n            EVP_PKEY_CTX *ffdh_ctx = NULL;\n            EVP_PKEY_CTX *test_ctx = NULL;\n            size_t secret_size;\n            size_t test_out;\n\n            /* Ensure that the error queue is empty */\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            pkey_A = EVP_PKEY_new();\n            if (!pkey_A) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY (out of memory?).\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            pkey_B = EVP_PKEY_new();\n            if (!pkey_B) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY (out of memory?).\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            ffdh_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DH, NULL);\n            if (!ffdh_ctx) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            if (EVP_PKEY_keygen_init(ffdh_ctx) <= 0) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_CTX_set_dh_nid(ffdh_ctx, ffdh_params[testnum].nid) <= 0) {\n                BIO_printf(bio_err, \"Error setting DH key size for keygen.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            if (EVP_PKEY_keygen(ffdh_ctx, &pkey_A) <= 0 ||\n                EVP_PKEY_keygen(ffdh_ctx, &pkey_B) <= 0) {\n                BIO_printf(bio_err, \"FFDH key generation failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            EVP_PKEY_CTX_free(ffdh_ctx);\n\n            /*\n             * check if the derivation works correctly both ways so that\n             * we know if future derive calls will fail, and we can skip\n             * error checking in benchmarked code\n             */\n            ffdh_ctx = EVP_PKEY_CTX_new(pkey_A, NULL);\n            if (ffdh_ctx == NULL) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_init(ffdh_ctx) <= 0) {\n                BIO_printf(bio_err, \"FFDH derivation context init failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_set_peer(ffdh_ctx, pkey_B) <= 0) {\n                BIO_printf(bio_err, \"Assigning peer key for derivation failed.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive(ffdh_ctx, NULL, &secret_size) <= 0) {\n                BIO_printf(bio_err, \"Checking size of shared secret failed.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (secret_size > MAX_FFDH_SIZE) {\n                BIO_printf(bio_err, \"Assertion failure: shared secret too large.\\n\");\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive(ffdh_ctx,\n                                loopargs[i].secret_ff_a,\n                                &secret_size) <= 0) {\n                BIO_printf(bio_err, \"Shared secret derive failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            /* Now check from side B */\n            test_ctx = EVP_PKEY_CTX_new(pkey_B, NULL);\n            if (!test_ctx) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_init(test_ctx) <= 0 ||\n                EVP_PKEY_derive_set_peer(test_ctx, pkey_A) <= 0 ||\n                EVP_PKEY_derive(test_ctx, NULL, &test_out) <= 0 ||\n                EVP_PKEY_derive(test_ctx, loopargs[i].secret_ff_b, &test_out) <= 0 ||\n                test_out != secret_size) {\n                BIO_printf(bio_err, \"FFDH computation failure.\\n\");\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            /* compare the computed secrets */\n            if (CRYPTO_memcmp(loopargs[i].secret_ff_a,\n                              loopargs[i].secret_ff_b, secret_size)) {\n                BIO_printf(bio_err, \"FFDH computations don't match.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            loopargs[i].ffdh_ctx[testnum] = ffdh_ctx;\n\n            EVP_PKEY_free(pkey_A);\n            pkey_A = NULL;\n            EVP_PKEY_free(pkey_B);\n            pkey_B = NULL;\n            EVP_PKEY_CTX_free(test_ctx);\n            test_ctx = NULL;\n        }\n        if (ffdh_checks != 0) {\n            pkey_print_message(\"\", \"ffdh\",\n                               ffdh_params[testnum].bits, seconds.ffdh);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, FFDH_derive_key_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R14:%ld:%d:%.2f\\n\" :\n                       \"%ld %u-bits FFDH ops in %.2fs\\n\", count,\n                       ffdh_params[testnum].bits, d);\n            ffdh_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ffdh_doit, testnum);\n        }\n    }\n#endif  /* OPENSSL_NO_DH */\n\n    for (testnum = 0; testnum < kems_algs_len; testnum++) {\n        int kem_checks = 1;\n        const char *kem_name = kems_algname[testnum];\n\n        if (!kems_doit[testnum] || !do_kems)\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey = NULL;\n            EVP_PKEY_CTX *kem_gen_ctx = NULL;\n            EVP_PKEY_CTX *kem_encaps_ctx = NULL;\n            EVP_PKEY_CTX *kem_decaps_ctx = NULL;\n            size_t send_secret_len, out_len;\n            size_t rcv_secret_len;\n            unsigned char *out = NULL, *send_secret = NULL, *rcv_secret;\n            unsigned int bits;\n            char *name;\n            char sfx[MAX_ALGNAME_SUFFIX];\n            OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n            int use_params = 0;\n            enum kem_type_t { KEM_RSA = 1, KEM_EC, KEM_X25519, KEM_X448 } kem_type;\n\n            /* no string after rsa<bitcnt> permitted: */\n            if (strlen(kem_name) < MAX_ALGNAME_SUFFIX + 4 /* rsa+digit */\n                && sscanf(kem_name, \"rsa%u%s\", &bits, sfx) == 1)\n                kem_type = KEM_RSA;\n            else if (strncmp(kem_name, \"EC\", 2) == 0)\n                kem_type = KEM_EC;\n            else if (strcmp(kem_name, \"X25519\") == 0)\n                kem_type = KEM_X25519;\n            else if (strcmp(kem_name, \"X448\") == 0)\n                kem_type = KEM_X448;\n            else kem_type = 0;\n\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            if (kem_type == KEM_RSA) {\n                params[0] = OSSL_PARAM_construct_uint(OSSL_PKEY_PARAM_RSA_BITS,\n                                                      &bits);\n                use_params = 1;\n            } else if (kem_type == KEM_EC) {\n                name = (char *)(kem_name + 2);\n                params[0] = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_GROUP_NAME,\n                                                  name, 0);\n                use_params = 1;\n            }\n\n            kem_gen_ctx = EVP_PKEY_CTX_new_from_name(app_get0_libctx(),\n                                               (kem_type == KEM_RSA) ? \"RSA\":\n                                                (kem_type == KEM_EC) ? \"EC\":\n                                                 kem_name,\n                                               app_get0_propq());\n\n            if ((!kem_gen_ctx || EVP_PKEY_keygen_init(kem_gen_ctx) <= 0)\n                || (use_params\n                    && EVP_PKEY_CTX_set_params(kem_gen_ctx, params) <= 0)) {\n                BIO_printf(bio_err, \"Error initializing keygen ctx for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_keygen(kem_gen_ctx, &pkey) <= 0) {\n                BIO_printf(bio_err, \"Error while generating KEM EVP_PKEY.\\n\");\n                goto kem_err_break;\n            }\n            /* Now prepare encaps data structs */\n            kem_encaps_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (kem_encaps_ctx == NULL\n                || EVP_PKEY_encapsulate_init(kem_encaps_ctx, NULL) <= 0\n                || (kem_type == KEM_RSA\n                    && EVP_PKEY_CTX_set_kem_op(kem_encaps_ctx, \"RSASVE\") <= 0)\n                || ((kem_type == KEM_EC\n                    || kem_type == KEM_X25519\n                    || kem_type == KEM_X448)\n                   && EVP_PKEY_CTX_set_kem_op(kem_encaps_ctx, \"DHKEM\") <= 0)\n                || EVP_PKEY_encapsulate(kem_encaps_ctx, NULL, &out_len,\n                                      NULL, &send_secret_len) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while initializing encaps data structs for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            out = app_malloc(out_len, \"encaps result\");\n            send_secret = app_malloc(send_secret_len, \"encaps secret\");\n            if (out == NULL || send_secret == NULL) {\n                BIO_printf(bio_err, \"MemAlloc error in encaps for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_encapsulate(kem_encaps_ctx, out, &out_len,\n                                     send_secret, &send_secret_len) <= 0) {\n                BIO_printf(bio_err, \"Encaps error for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            /* Now prepare decaps data structs */\n            kem_decaps_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (kem_decaps_ctx == NULL\n                || EVP_PKEY_decapsulate_init(kem_decaps_ctx, NULL) <= 0\n                || (kem_type == KEM_RSA\n                  && EVP_PKEY_CTX_set_kem_op(kem_decaps_ctx, \"RSASVE\") <= 0)\n                || ((kem_type == KEM_EC\n                     || kem_type == KEM_X25519\n                     || kem_type == KEM_X448)\n                  && EVP_PKEY_CTX_set_kem_op(kem_decaps_ctx, \"DHKEM\") <= 0)\n                || EVP_PKEY_decapsulate(kem_decaps_ctx, NULL, &rcv_secret_len,\n                                        out, out_len) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while initializing decaps data structs for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            rcv_secret = app_malloc(rcv_secret_len, \"KEM decaps secret\");\n            if (rcv_secret == NULL) {\n                BIO_printf(bio_err, \"MemAlloc failure in decaps for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_decapsulate(kem_decaps_ctx, rcv_secret,\n                                     &rcv_secret_len, out, out_len) <= 0\n                || rcv_secret_len != send_secret_len\n                || memcmp(send_secret, rcv_secret, send_secret_len)) {\n                BIO_printf(bio_err, \"Decaps error for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            loopargs[i].kem_gen_ctx[testnum] = kem_gen_ctx;\n            loopargs[i].kem_encaps_ctx[testnum] = kem_encaps_ctx;\n            loopargs[i].kem_decaps_ctx[testnum] = kem_decaps_ctx;\n            loopargs[i].kem_out_len[testnum] = out_len;\n            loopargs[i].kem_secret_len[testnum] = send_secret_len;\n            loopargs[i].kem_out[testnum] = out;\n            loopargs[i].kem_send_secret[testnum] = send_secret;\n            loopargs[i].kem_rcv_secret[testnum] = rcv_secret;\n            EVP_PKEY_free(pkey);\n            pkey = NULL;\n            continue;\n\n        kem_err_break:\n            dofail();\n            EVP_PKEY_free(pkey);\n            op_count = 1;\n            kem_checks = 0;\n            break;\n        }\n        if (kem_checks != 0) {\n            kskey_print_message(kem_name, \"keygen\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_keygen_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R15:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM keygen ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][0] = (double)count / d;\n            op_count = count;\n            kskey_print_message(kem_name, \"encaps\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_encaps_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R16:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM encaps ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][1] = (double)count / d;\n            op_count = count;\n            kskey_print_message(kem_name, \"decaps\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_decaps_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R17:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM decaps ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(kems_doit, testnum);\n        }\n    }\n\n    for (testnum = 0; testnum < sigs_algs_len; testnum++) {\n        int sig_checks = 1;\n        const char *sig_name = sigs_algname[testnum];\n\n        if (!sigs_doit[testnum] || !do_sigs)\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey = NULL;\n            EVP_PKEY_CTX *ctx_params = NULL;\n            EVP_PKEY* pkey_params = NULL;\n            EVP_PKEY_CTX *sig_gen_ctx = NULL;\n            EVP_PKEY_CTX *sig_sign_ctx = NULL;\n            EVP_PKEY_CTX *sig_verify_ctx = NULL;\n            unsigned char md[SHA256_DIGEST_LENGTH];\n            unsigned char *sig;\n            char sfx[MAX_ALGNAME_SUFFIX];\n            size_t md_len = SHA256_DIGEST_LENGTH;\n            size_t max_sig_len, sig_len;\n            unsigned int bits;\n            OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n            int use_params = 0;\n\n            /* only sign little data to avoid measuring digest performance */\n            memset(md, 0, SHA256_DIGEST_LENGTH);\n\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            /* no string after rsa<bitcnt> permitted: */\n            if (strlen(sig_name) < MAX_ALGNAME_SUFFIX + 4 /* rsa+digit */\n                && sscanf(sig_name, \"rsa%u%s\", &bits, sfx) == 1) {\n                params[0] = OSSL_PARAM_construct_uint(OSSL_PKEY_PARAM_RSA_BITS,\n                                                      &bits);\n                use_params = 1;\n            }\n\n            if (strncmp(sig_name, \"dsa\", 3) == 0) {\n                ctx_params = EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, NULL);\n                if (ctx_params == NULL\n                    || EVP_PKEY_paramgen_init(ctx_params) <= 0\n                    || EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx_params,\n                                                        atoi(sig_name + 3)) <= 0\n                    || EVP_PKEY_paramgen(ctx_params, &pkey_params) <= 0\n                    || (sig_gen_ctx = EVP_PKEY_CTX_new(pkey_params, NULL)) == NULL\n                    || EVP_PKEY_keygen_init(sig_gen_ctx) <= 0) {\n                    BIO_printf(bio_err,\n                               \"Error initializing classic keygen ctx for %s.\\n\",\n                               sig_name);\n                    goto sig_err_break;\n                }\n            }\n\n            if (sig_gen_ctx == NULL)\n                sig_gen_ctx = EVP_PKEY_CTX_new_from_name(app_get0_libctx(),\n                                      use_params == 1 ? \"RSA\" : sig_name,\n                                      app_get0_propq());\n\n            if (!sig_gen_ctx || EVP_PKEY_keygen_init(sig_gen_ctx) <= 0\n                || (use_params &&\n                    EVP_PKEY_CTX_set_params(sig_gen_ctx, params) <= 0)) {\n                BIO_printf(bio_err, \"Error initializing keygen ctx for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_keygen(sig_gen_ctx, &pkey) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while generating signature EVP_PKEY for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            /* Now prepare signature data structs */\n            sig_sign_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                      pkey,\n                                                      app_get0_propq());\n            if (sig_sign_ctx == NULL\n                || EVP_PKEY_sign_init(sig_sign_ctx) <= 0\n                || (use_params == 1\n                    && (EVP_PKEY_CTX_set_rsa_padding(sig_sign_ctx,\n                                                     RSA_PKCS1_PADDING) <= 0))\n                || EVP_PKEY_sign(sig_sign_ctx, NULL, &max_sig_len,\n                                 md, md_len) <= 0) {\n                    BIO_printf(bio_err,\n                               \"Error while initializing signing data structs for %s.\\n\",\n                               sig_name);\n                    goto sig_err_break;\n            }\n            sig = app_malloc(sig_len = max_sig_len, \"signature buffer\");\n            if (sig == NULL) {\n                BIO_printf(bio_err, \"MemAlloc error in sign for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_sign(sig_sign_ctx, sig, &sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Signing error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            /* Now prepare verify data structs */\n            memset(md, 0, SHA256_DIGEST_LENGTH);\n            sig_verify_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (sig_verify_ctx == NULL\n                || EVP_PKEY_verify_init(sig_verify_ctx) <= 0\n                || (use_params == 1\n                  && (EVP_PKEY_CTX_set_rsa_padding(sig_verify_ctx,\n                                                   RSA_PKCS1_PADDING) <= 0))) {\n                BIO_printf(bio_err,\n                           \"Error while initializing verify data structs for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_verify(sig_verify_ctx, sig, sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Verify error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_verify(sig_verify_ctx, sig, sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Verify 2 error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            loopargs[i].sig_gen_ctx[testnum] = sig_gen_ctx;\n            loopargs[i].sig_sign_ctx[testnum] = sig_sign_ctx;\n            loopargs[i].sig_verify_ctx[testnum] = sig_verify_ctx;\n            loopargs[i].sig_max_sig_len[testnum] = max_sig_len;\n            loopargs[i].sig_act_sig_len[testnum] = sig_len;\n            loopargs[i].sig_sig[testnum] = sig;\n            EVP_PKEY_free(pkey);\n            pkey = NULL;\n            continue;\n\n        sig_err_break:\n            dofail();\n            EVP_PKEY_free(pkey);\n            op_count = 1;\n            sig_checks = 0;\n            break;\n        }\n\n        if (sig_checks != 0) {\n            kskey_print_message(sig_name, \"keygen\", seconds.sig);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SIG_keygen_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R18:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature keygen ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][0] = (double)count / d;\n            op_count = count;\n            kskey_print_message(sig_name, \"signs\", seconds.sig);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, SIG_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R19:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature sign ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][1] = (double)count / d;\n            op_count = count;\n\n            kskey_print_message(sig_name, \"verify\", seconds.sig);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, SIG_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R20:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature verify ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1)\n            stop_it(sigs_doit, testnum);\n    }\n\n#ifndef NO_FORK\n show_res:\n#endif\n    if (!mr) {\n        printf(\"version: %s\\n\", OpenSSL_version(OPENSSL_FULL_VERSION_STRING));\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_BUILT_ON));\n        printf(\"options: %s\\n\", BN_options());\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_CFLAGS));\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_CPU_INFO));\n    }\n\n    if (pr_header) {\n        if (mr) {\n            printf(\"+H\");\n        } else {\n            printf(\"The 'numbers' are in 1000s of bytes per second processed.\\n\");\n            printf(\"type        \");\n        }\n        for (testnum = 0; testnum < size_num; testnum++)\n            printf(mr ? \":%d\" : \"%7d bytes\", lengths[testnum]);\n        printf(\"\\n\");\n    }\n\n    for (k = 0; k < ALGOR_NUM; k++) {\n        const char *alg_name = names[k];\n\n        if (!doit[k])\n            continue;\n\n        if (k == D_EVP) {\n            if (evp_cipher == NULL)\n                alg_name = evp_md_name;\n            else if ((alg_name = EVP_CIPHER_get0_name(evp_cipher)) == NULL)\n                app_bail_out(\"failed to get name of cipher '%s'\\n\", evp_cipher);\n        }\n\n        if (mr)\n            printf(\"+F:%u:%s\", k, alg_name);\n        else\n            printf(\"%-13s\", alg_name);\n        for (testnum = 0; testnum < size_num; testnum++) {\n            if (results[k][testnum] > 10000 && !mr)\n                printf(\" %11.2fk\", results[k][testnum] / 1e3);\n            else\n                printf(mr ? \":%.2f\" : \" %11.2f \", results[k][testnum]);\n        }\n        printf(\"\\n\");\n    }\n    testnum = 1;\n    for (k = 0; k < RSA_NUM; k++) {\n        if (!rsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%19ssign    verify    encrypt   decrypt   sign/s verify/s  encr./s  decr./s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F2:%u:%u:%f:%f:%f:%f\\n\",\n                   k, rsa_keys[k].bits, rsa_results[k][0], rsa_results[k][1],\n                   rsa_results[k][2], rsa_results[k][3]);\n        else\n            printf(\"rsa %5u bits %8.6fs %8.6fs %8.6fs %8.6fs %8.1f %8.1f %8.1f %8.1f\\n\",\n                   rsa_keys[k].bits, 1.0 / rsa_results[k][0],\n                   1.0 / rsa_results[k][1], 1.0 / rsa_results[k][2],\n                   1.0 / rsa_results[k][3],\n                   rsa_results[k][0], rsa_results[k][1],\n                   rsa_results[k][2], rsa_results[k][3]);\n    }\n    testnum = 1;\n#ifndef OPENSSL_NO_DSA\n    for (k = 0; k < DSA_NUM; k++) {\n        if (!dsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%18ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F3:%u:%u:%f:%f\\n\",\n                   k, dsa_bits[k], dsa_results[k][0], dsa_results[k][1]);\n        else\n            printf(\"dsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\\n\",\n                   dsa_bits[k], 1.0 / dsa_results[k][0], 1.0 / dsa_results[k][1],\n                   dsa_results[k][0], dsa_results[k][1]);\n    }\n#endif /* OPENSSL_NO_DSA */\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(ecdsa_doit); k++) {\n        if (!ecdsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F4:%u:%u:%f:%f\\n\",\n                   k, ec_curves[k].bits,\n                   ecdsa_results[k][0], ecdsa_results[k][1]);\n        else\n            printf(\"%4u bits ecdsa (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   ec_curves[k].bits, ec_curves[k].name,\n                   1.0 / ecdsa_results[k][0], 1.0 / ecdsa_results[k][1],\n                   ecdsa_results[k][0], ecdsa_results[k][1]);\n    }\n\n    testnum = 1;\n    for (k = 0; k < EC_NUM; k++) {\n        if (!ecdh_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30sop      op/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F5:%u:%u:%f:%f\\n\",\n                   k, ec_curves[k].bits,\n                   ecdh_results[k][0], 1.0 / ecdh_results[k][0]);\n\n        else\n            printf(\"%4u bits ecdh (%s) %8.4fs %8.1f\\n\",\n                   ec_curves[k].bits, ec_curves[k].name,\n                   1.0 / ecdh_results[k][0], ecdh_results[k][0]);\n    }\n\n#ifndef OPENSSL_NO_ECX\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(eddsa_doit); k++) {\n        if (!eddsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F6:%u:%u:%s:%f:%f\\n\",\n                   k, ed_curves[k].bits, ed_curves[k].name,\n                   eddsa_results[k][0], eddsa_results[k][1]);\n        else\n            printf(\"%4u bits EdDSA (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   ed_curves[k].bits, ed_curves[k].name,\n                   1.0 / eddsa_results[k][0], 1.0 / eddsa_results[k][1],\n                   eddsa_results[k][0], eddsa_results[k][1]);\n    }\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(sm2_doit); k++) {\n        if (!sm2_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F7:%u:%u:%s:%f:%f\\n\",\n                   k, sm2_curves[k].bits, sm2_curves[k].name,\n                   sm2_results[k][0], sm2_results[k][1]);\n        else\n            printf(\"%4u bits SM2 (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   sm2_curves[k].bits, sm2_curves[k].name,\n                   1.0 / sm2_results[k][0], 1.0 / sm2_results[k][1],\n                   sm2_results[k][0], sm2_results[k][1]);\n    }\n#endif\n#ifndef OPENSSL_NO_DH\n    testnum = 1;\n    for (k = 0; k < FFDH_NUM; k++) {\n        if (!ffdh_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%23sop     op/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F8:%u:%u:%f:%f\\n\",\n                   k, ffdh_params[k].bits,\n                   ffdh_results[k][0], 1.0 / ffdh_results[k][0]);\n\n        else\n            printf(\"%4u bits ffdh %8.4fs %8.1f\\n\",\n                   ffdh_params[k].bits,\n                   1.0 / ffdh_results[k][0], ffdh_results[k][0]);\n    }\n#endif /* OPENSSL_NO_DH */\n\n    testnum = 1;\n    for (k = 0; k < kems_algs_len; k++) {\n        const char *kem_name = kems_algname[k];\n\n        if (!kems_doit[k] || !do_kems)\n            continue;\n        if (testnum && !mr) {\n            printf(\"%31skeygen    encaps    decaps keygens/s  encaps/s  decaps/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F9:%u:%f:%f:%f\\n\",\n                   k, kems_results[k][0], kems_results[k][1],\n                   kems_results[k][2]);\n        else\n            printf(\"%27s %8.6fs %8.6fs %8.6fs %9.1f %9.1f %9.1f\\n\", kem_name,\n                   1.0 / kems_results[k][0],\n                   1.0 / kems_results[k][1], 1.0 / kems_results[k][2],\n                   kems_results[k][0], kems_results[k][1], kems_results[k][2]);\n    }\n    ret = 0;\n\n    testnum = 1;\n    for (k = 0; k < sigs_algs_len; k++) {\n        const char *sig_name = sigs_algname[k];\n\n        if (!sigs_doit[k] || !do_sigs)\n            continue;\n        if (testnum && !mr) {\n            printf(\"%31skeygen     signs    verify keygens/s    sign/s  verify/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F10:%u:%f:%f:%f\\n\",\n                   k, sigs_results[k][0], sigs_results[k][1],\n                   sigs_results[k][2]);\n        else\n            printf(\"%27s %8.6fs %8.6fs %8.6fs %9.1f %9.1f %9.1f\\n\", sig_name,\n                   1.0 / sigs_results[k][0], 1.0 / sigs_results[k][1],\n                   1.0 / sigs_results[k][2], sigs_results[k][0],\n                   sigs_results[k][1], sigs_results[k][2]);\n    }\n    ret = 0;\n\n end:\n    if (ret == 0 && testmode)\n        ret = testmoderesult;\n    ERR_print_errors(bio_err);\n    for (i = 0; i < loopargs_len; i++) {\n        OPENSSL_free(loopargs[i].buf_malloc);\n        OPENSSL_free(loopargs[i].buf2_malloc);\n\n        BN_free(bn);\n        EVP_PKEY_CTX_free(genctx);\n        for (k = 0; k < RSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].rsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_verify_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_encrypt_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_decrypt_ctx[k]);\n        }\n#ifndef OPENSSL_NO_DH\n        OPENSSL_free(loopargs[i].secret_ff_a);\n        OPENSSL_free(loopargs[i].secret_ff_b);\n        for (k = 0; k < FFDH_NUM; k++)\n            EVP_PKEY_CTX_free(loopargs[i].ffdh_ctx[k]);\n#endif\n#ifndef OPENSSL_NO_DSA\n        for (k = 0; k < DSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].dsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].dsa_verify_ctx[k]);\n        }\n#endif\n        for (k = 0; k < ECDSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].ecdsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].ecdsa_verify_ctx[k]);\n        }\n        for (k = 0; k < EC_NUM; k++)\n            EVP_PKEY_CTX_free(loopargs[i].ecdh_ctx[k]);\n#ifndef OPENSSL_NO_ECX\n        for (k = 0; k < EdDSA_NUM; k++) {\n            EVP_MD_CTX_free(loopargs[i].eddsa_ctx[k]);\n            EVP_MD_CTX_free(loopargs[i].eddsa_ctx2[k]);\n        }\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        for (k = 0; k < SM2_NUM; k++) {\n            EVP_PKEY_CTX *pctx = NULL;\n\n            /* free signing ctx */\n            if (loopargs[i].sm2_ctx[k] != NULL\n                && (pctx = EVP_MD_CTX_get_pkey_ctx(loopargs[i].sm2_ctx[k])) != NULL)\n                EVP_PKEY_CTX_free(pctx);\n            EVP_MD_CTX_free(loopargs[i].sm2_ctx[k]);\n            /* free verification ctx */\n            if (loopargs[i].sm2_vfy_ctx[k] != NULL\n                && (pctx = EVP_MD_CTX_get_pkey_ctx(loopargs[i].sm2_vfy_ctx[k])) != NULL)\n                EVP_PKEY_CTX_free(pctx);\n            EVP_MD_CTX_free(loopargs[i].sm2_vfy_ctx[k]);\n            /* free pkey */\n            EVP_PKEY_free(loopargs[i].sm2_pkey[k]);\n        }\n#endif\n        for (k = 0; k < kems_algs_len; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].kem_gen_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].kem_encaps_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].kem_decaps_ctx[k]);\n            OPENSSL_free(loopargs[i].kem_out[k]);\n            OPENSSL_free(loopargs[i].kem_send_secret[k]);\n            OPENSSL_free(loopargs[i].kem_rcv_secret[k]);\n        }\n        for (k = 0; k < sigs_algs_len; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].sig_gen_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].sig_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].sig_verify_ctx[k]);\n            OPENSSL_free(loopargs[i].sig_sig[k]);\n        }\n        OPENSSL_free(loopargs[i].secret_a);\n        OPENSSL_free(loopargs[i].secret_b);\n    }\n    OPENSSL_free(evp_hmac_name);\n    OPENSSL_free(evp_cmac_name);\n    for (k = 0; k < kems_algs_len; k++)\n        OPENSSL_free(kems_algname[k]);\n    if (kem_stack != NULL)\n        sk_EVP_KEM_pop_free(kem_stack, EVP_KEM_free);\n    for (k = 0; k < sigs_algs_len; k++)\n        OPENSSL_free(sigs_algname[k]);\n    if (sig_stack != NULL)\n        sk_EVP_SIGNATURE_pop_free(sig_stack, EVP_SIGNATURE_free);\n\n    if (async_jobs > 0) {\n        for (i = 0; i < loopargs_len; i++)\n            ASYNC_WAIT_CTX_free(loopargs[i].wait_ctx);\n    }\n\n    if (async_init) {\n        ASYNC_cleanup_thread();\n    }\n    OPENSSL_free(loopargs);\n    release_engine(e);\n    EVP_CIPHER_free(evp_cipher);\n    EVP_MAC_free(mac);\n    NCONF_free(conf);\n    return ret;\n}",
        "result": 0
    },
    {
        "var_name": "p",
        "function_name": "list_insert_sorted",
        "location": {
            "file_path": "ssl/quic/quic_cfq.c",
            "region": {
                "startLine": 159,
                "startColumn": 55,
                "endColumn": 60
            },
            "context": {
                "startLine": 157,
                "endLine": 161,
                "snippet": {
                    "text": "for (; p != NULL && cmp(p, n) < 0; pprev = p, p = p->next);"
                }
            }
        },
        "function_code": "static void list_insert_sorted(QUIC_CFQ_ITEM_LIST *l, QUIC_CFQ_ITEM_EX *n,\n                               int (*cmp)(const QUIC_CFQ_ITEM_EX *a,\n                                          const QUIC_CFQ_ITEM_EX *b))\n{\n    QUIC_CFQ_ITEM_EX *p = l->head, *pprev = NULL;\n\n    if (p == NULL) {\n        l->head = l->tail = n;\n        n->prev = n->next = NULL;\n        return;\n    }\n\n    for (; p != NULL && cmp(p, n) < 0; pprev = p, p = p->next);\n\n    if (p == NULL)\n        list_insert_tail(l, n);\n    else if (pprev == NULL)\n        list_insert_head(l, n);\n    else\n        list_insert_after(l, pprev, n);\n}",
        "result": 0
    },
    {
        "var_name": "s2",
        "function_name": "test_str_ne",
        "location": {
            "file_path": "test/testutil/tests.c",
            "region": {
                "startLine": 296,
                "startColumn": 34,
                "endColumn": 36
            },
            "context": {
                "startLine": 294,
                "endLine": 298,
                "snippet": {
                    "text": "if (s1 == NULL || strcmp(s1, s2) == 0) {"
                }
            }
        },
        "function_code": "int test_str_ne(const char *file, int line, const char *st1, const char *st2,\n                const char *s1, const char *s2)\n{\n    if ((s1 == NULL) ^ (s2 == NULL))\n      return 1;\n    if (s1 == NULL || strcmp(s1, s2) == 0) {\n        test_fail_string_message(NULL, file, line, \"string\", st1, st2, \"!=\",\n                                 s1, s1 == NULL ? 0 : strlen(s1),\n                                 s2, s2 == NULL ? 0 : strlen(s2));\n        return 0;\n    }\n    return 1;\n}",
        "result": 0
    },
    {
        "var_name": "s2",
        "function_name": "test_strn_ne",
        "location": {
            "file_path": "test/testutil/tests.c",
            "region": {
                "startLine": 324,
                "startColumn": 47,
                "endColumn": 49
            },
            "context": {
                "startLine": 322,
                "endLine": 326,
                "snippet": {
                    "text": "if (n1 != n2 || s1 == NULL || strncmp(s1, s2, n1) == 0) {"
                }
            }
        },
        "function_code": "int test_strn_ne(const char *file, int line, const char *st1, const char *st2,\n                 const char *s1, size_t n1, const char *s2, size_t n2)\n{\n    if ((s1 == NULL) ^ (s2 == NULL))\n      return 1;\n    if (n1 != n2 || s1 == NULL || strncmp(s1, s2, n1) == 0) {\n        test_fail_string_message(NULL, file, line, \"string\", st1, st2, \"!=\",\n                                 s1, s1 == NULL ? 0 : OPENSSL_strnlen(s1, n1),\n                                 s2, s2 == NULL ? 0 : OPENSSL_strnlen(s2, n2));\n        return 0;\n    }\n    return 1;\n}",
        "result": 0
    }
]