[
    {
        "var_name": "res",
        "function_name": "pcibios_reserve_legacy_regions",
        "location": {
            "file_path": "arch/powerpc/kernel/pci-common.c",
            "region": {
                "startLine": 1373,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 1371,
                "endLine": 1375,
                "snippet": {
                    "text": "res->name = \"Legacy IO\";"
                }
            }
        },
        "function_code": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
        "result": 0
    },
    {
        "var_name": "res",
        "function_name": "pcibios_reserve_legacy_regions",
        "location": {
            "file_path": "arch/powerpc/kernel/pci-common.c",
            "region": {
                "startLine": 1374,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 1372,
                "endLine": 1376,
                "snippet": {
                    "text": "res->flags = IORESOURCE_IO;"
                }
            }
        },
        "function_code": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
        "result": 0
    },
    {
        "var_name": "res",
        "function_name": "pcibios_reserve_legacy_regions",
        "location": {
            "file_path": "arch/powerpc/kernel/pci-common.c",
            "region": {
                "startLine": 1375,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 1373,
                "endLine": 1377,
                "snippet": {
                    "text": "res->start = offset;"
                }
            }
        },
        "function_code": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
        "result": 0
    },
    {
        "var_name": "res",
        "function_name": "pcibios_reserve_legacy_regions",
        "location": {
            "file_path": "arch/powerpc/kernel/pci-common.c",
            "region": {
                "startLine": 1376,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 1374,
                "endLine": 1378,
                "snippet": {
                    "text": "res->end = (offset + 0xfff) & 0xfffffffful;"
                }
            }
        },
        "function_code": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
        "result": 0
    },
    {
        "var_name": "res",
        "function_name": "pcibios_reserve_legacy_regions",
        "location": {
            "file_path": "arch/powerpc/kernel/pci-common.c",
            "region": {
                "startLine": 1401,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 1399,
                "endLine": 1403,
                "snippet": {
                    "text": "res->name = \"Legacy VGA memory\";"
                }
            }
        },
        "function_code": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
        "result": 0
    },
    {
        "var_name": "res",
        "function_name": "pcibios_reserve_legacy_regions",
        "location": {
            "file_path": "arch/powerpc/kernel/pci-common.c",
            "region": {
                "startLine": 1402,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 1400,
                "endLine": 1404,
                "snippet": {
                    "text": "res->flags = IORESOURCE_MEM;"
                }
            }
        },
        "function_code": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
        "result": 0
    },
    {
        "var_name": "res",
        "function_name": "pcibios_reserve_legacy_regions",
        "location": {
            "file_path": "arch/powerpc/kernel/pci-common.c",
            "region": {
                "startLine": 1403,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 1401,
                "endLine": 1405,
                "snippet": {
                    "text": "res->start = 0xa0000 + offset;"
                }
            }
        },
        "function_code": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
        "result": 0
    },
    {
        "var_name": "res",
        "function_name": "pcibios_reserve_legacy_regions",
        "location": {
            "file_path": "arch/powerpc/kernel/pci-common.c",
            "region": {
                "startLine": 1404,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 1402,
                "endLine": 1406,
                "snippet": {
                    "text": "res->end = 0xbffff + offset;"
                }
            }
        },
        "function_code": "static void __init pcibios_reserve_legacy_regions(struct pci_bus *bus)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tresource_size_t\toffset;\n\tstruct resource *res, *pres;\n\tint i;\n\n\tpr_debug(\"Reserving legacy ranges for domain %04x\\n\", pci_domain_nr(bus));\n\n\t/* Check for IO */\n\tif (!(hose->io_resource.flags & IORESOURCE_IO))\n\t\tgoto no_io;\n\toffset = (unsigned long)hose->io_base_virt - _IO_BASE;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy IO\";\n\tres->flags = IORESOURCE_IO;\n\tres->start = offset;\n\tres->end = (offset + 0xfff) & 0xfffffffful;\n\tpr_debug(\"Candidate legacy IO: %pR\\n\", res);\n\tif (request_resource(&hose->io_resource, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve Legacy IO %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n\n no_io:\n\t/* Check for memory */\n\tfor (i = 0; i < 3; i++) {\n\t\tpres = &hose->mem_resources[i];\n\t\toffset = hose->mem_offset[i];\n\t\tif (!(pres->flags & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tpr_debug(\"hose mem res: %pR\\n\", pres);\n\t\tif ((pres->start - offset) <= 0xa0000 &&\n\t\t    (pres->end - offset) >= 0xbffff)\n\t\t\tbreak;\n\t}\n\tif (i >= 3)\n\t\treturn;\n\tres = kzalloc(sizeof(struct resource), GFP_KERNEL);\n\tBUG_ON(res == NULL);\n\tres->name = \"Legacy VGA memory\";\n\tres->flags = IORESOURCE_MEM;\n\tres->start = 0xa0000 + offset;\n\tres->end = 0xbffff + offset;\n\tpr_debug(\"Candidate VGA memory: %pR\\n\", res);\n\tif (request_resource(pres, res)) {\n\t\tprintk(KERN_DEBUG\n\t\t       \"PCI %04x:%02x Cannot reserve VGA memory %pR\\n\",\n\t\t       pci_domain_nr(bus), bus->number, res);\n\t\tkfree(res);\n\t}\n}",
        "result": 0
    },
    {
        "var_name": "dev",
        "function_name": "pci_device_from_OF_node",
        "location": {
            "file_path": "arch/powerpc/kernel/pci_32.c",
            "region": {
                "startLine": 193,
                "startColumn": 25,
                "endColumn": 28
            },
            "context": {
                "startLine": 191,
                "endLine": 195,
                "snippet": {
                    "text": "if (pci_to_OF_bus_map[dev->bus->number] == *bus &&"
                }
            }
        },
        "function_code": "int pci_device_from_OF_node(struct device_node *node, u8 *bus, u8 *devfn)\n{\n#ifdef CONFIG_PPC_PCI_OF_BUS_MAP\n\tstruct pci_dev *dev = NULL;\n#endif\n\tconst __be32 *reg;\n\tint size;\n\n\t/* Check if it might have a chance to be a PCI device */\n\tif (!pci_find_hose_for_OF_device(node))\n\t\treturn -ENODEV;\n\n\treg = of_get_property(node, \"reg\", &size);\n\tif (!reg || size < 5 * sizeof(u32))\n\t\treturn -ENODEV;\n\n\t*bus = (be32_to_cpup(&reg[0]) >> 16) & 0xff;\n\t*devfn = (be32_to_cpup(&reg[0]) >> 8) & 0xff;\n\n#ifndef CONFIG_PPC_PCI_OF_BUS_MAP\n\treturn 0;\n#else\n\t/* Ok, here we need some tweak. If we have already renumbered\n\t * all busses, we can't rely on the OF bus number any more.\n\t * the pci_to_OF_bus_map is not enough as several PCI busses\n\t * may match the same OF bus number.\n\t */\n\tif (!pci_to_OF_bus_map)\n\t\treturn 0;\n\n\tfor_each_pci_dev(dev)\n\t\tif (pci_to_OF_bus_map[dev->bus->number] == *bus &&\n\t\t\t\tdev->devfn == *devfn) {\n\t\t\t*bus = dev->bus->number;\n\t\t\tpci_dev_put(dev);\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENODEV;\n#endif // CONFIG_PPC_PCI_OF_BUS_MAP\n}",
        "result": 0
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xics_find_server",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xics.h",
            "region": {
                "startLine": 122,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 120,
                "endLine": 124,
                "snippet": {
                    "text": "if (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)"
                }
            }
        },
        "function_code": "static inline struct kvmppc_icp *kvmppc_xics_find_server(struct kvm *kvm,\n\t\t\t\t\t\t\t u32 nr)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)\n\t\t\treturn vcpu->arch.icp;\n\t}\n\treturn NULL;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xive_find_server",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xive.h",
            "region": {
                "startLine": 205,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 203,
                "endLine": 207,
                "snippet": {
                    "text": "if (vcpu->arch.xive_vcpu && nr == vcpu->arch.xive_vcpu->server_num)"
                }
            }
        },
        "function_code": "static inline struct kvm_vcpu *kvmppc_xive_find_server(struct kvm *kvm, u32 nr)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.xive_vcpu && nr == vcpu->arch.xive_vcpu->server_num)\n\t\t\treturn vcpu;\n\t}\n\treturn NULL;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xive_vp_in_use",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xive.h",
            "region": {
                "startLine": 246,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 244,
                "endLine": 248,
                "snippet": {
                    "text": "if (vcpu->arch.xive_vcpu && vp_id == vcpu->arch.xive_vcpu->vp_id)"
                }
            }
        },
        "function_code": "static inline bool kvmppc_xive_vp_in_use(struct kvm *kvm, u32 vp_id)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.xive_vcpu && vp_id == vcpu->arch.xive_vcpu->vp_id)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xics_find_server",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xics.h",
            "region": {
                "startLine": 122,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 120,
                "endLine": 124,
                "snippet": {
                    "text": "if (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)"
                }
            }
        },
        "function_code": "static inline struct kvmppc_icp *kvmppc_xics_find_server(struct kvm *kvm,\n\t\t\t\t\t\t\t u32 nr)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)\n\t\t\treturn vcpu->arch.icp;\n\t}\n\treturn NULL;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xics_find_server",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xics.h",
            "region": {
                "startLine": 122,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 120,
                "endLine": 124,
                "snippet": {
                    "text": "if (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)"
                }
            }
        },
        "function_code": "static inline struct kvmppc_icp *kvmppc_xics_find_server(struct kvm *kvm,\n\t\t\t\t\t\t\t u32 nr)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)\n\t\t\treturn vcpu->arch.icp;\n\t}\n\treturn NULL;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "xive_pre_save_scan",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xive.c",
            "region": {
                "startLine": 2144,
                "startColumn": 33,
                "endColumn": 37
            },
            "context": {
                "startLine": 2142,
                "endLine": 2146,
                "snippet": {
                    "text": "struct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;"
                }
            }
        },
        "function_code": "static void xive_pre_save_scan(struct kvmppc_xive *xive)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\tint j;\n\n\t/*\n\t * See comment in xive_get_source() about how this\n\t * work. Collect a stable state for all interrupts\n\t */\n\tfor (i = 0; i <= xive->max_sbid; i++) {\n\t\tstruct kvmppc_xive_src_block *sb = xive->src_blocks[i];\n\t\tif (!sb)\n\t\t\tcontinue;\n\t\tfor (j = 0;  j < KVMPPC_XICS_IRQ_PER_ICS; j++)\n\t\t\txive_pre_save_mask_irq(xive, sb, j);\n\t}\n\n\t/* Then scan the queues and update the \"in_queue\" flag */\n\tkvm_for_each_vcpu(i, vcpu, xive->kvm) {\n\t\tstruct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;\n\t\tif (!xc)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < KVMPPC_XIVE_Q_COUNT; j++) {\n\t\t\tif (xc->queues[j].qpage)\n\t\t\t\txive_pre_save_queue(xive, &xc->queues[j]);\n\t\t}\n\t}\n\n\t/* Finally restore interrupt states */\n\tfor (i = 0; i <= xive->max_sbid; i++) {\n\t\tstruct kvmppc_xive_src_block *sb = xive->src_blocks[i];\n\t\tif (!sb)\n\t\t\tcontinue;\n\t\tfor (j = 0;  j < KVMPPC_XICS_IRQ_PER_ICS; j++)\n\t\t\txive_pre_save_unmask_irq(xive, sb, j);\n\t}\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "xive_check_delayed_irq",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xive.c",
            "region": {
                "startLine": 2312,
                "startColumn": 33,
                "endColumn": 37
            },
            "context": {
                "startLine": 2310,
                "endLine": 2314,
                "snippet": {
                    "text": "struct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;"
                }
            }
        },
        "function_code": "static bool xive_check_delayed_irq(struct kvmppc_xive *xive, u32 irq)\n{\n\tstruct kvm *kvm = xive->kvm;\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvmppc_xive_vcpu *xc = vcpu->arch.xive_vcpu;\n\n\t\tif (!xc)\n\t\t\tcontinue;\n\n\t\tif (xc->delayed_irq == irq) {\n\t\t\txc->delayed_irq = 0;\n\t\t\txive->delayed_irqs--;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xics_find_server",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xics.h",
            "region": {
                "startLine": 122,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 120,
                "endLine": 124,
                "snippet": {
                    "text": "if (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)"
                }
            }
        },
        "function_code": "static inline struct kvmppc_icp *kvmppc_xics_find_server(struct kvm *kvm,\n\t\t\t\t\t\t\t u32 nr)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)\n\t\t\treturn vcpu->arch.icp;\n\t}\n\treturn NULL;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xive_find_server",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xive.h",
            "region": {
                "startLine": 205,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 203,
                "endLine": 207,
                "snippet": {
                    "text": "if (vcpu->arch.xive_vcpu && nr == vcpu->arch.xive_vcpu->server_num)"
                }
            }
        },
        "function_code": "static inline struct kvm_vcpu *kvmppc_xive_find_server(struct kvm *kvm, u32 nr)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.xive_vcpu && nr == vcpu->arch.xive_vcpu->server_num)\n\t\t\treturn vcpu;\n\t}\n\treturn NULL;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xive_vp_in_use",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xive.h",
            "region": {
                "startLine": 246,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 244,
                "endLine": 248,
                "snippet": {
                    "text": "if (vcpu->arch.xive_vcpu && vp_id == vcpu->arch.xive_vcpu->vp_id)"
                }
            }
        },
        "function_code": "static inline bool kvmppc_xive_vp_in_use(struct kvm *kvm, u32 vp_id)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.xive_vcpu && vp_id == vcpu->arch.xive_vcpu->vp_id)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xics_find_server",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xics.h",
            "region": {
                "startLine": 122,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 120,
                "endLine": 124,
                "snippet": {
                    "text": "if (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)"
                }
            }
        },
        "function_code": "static inline struct kvmppc_icp *kvmppc_xics_find_server(struct kvm *kvm,\n\t\t\t\t\t\t\t u32 nr)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)\n\t\t\treturn vcpu->arch.icp;\n\t}\n\treturn NULL;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xive_find_server",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xive.h",
            "region": {
                "startLine": 205,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 203,
                "endLine": 207,
                "snippet": {
                    "text": "if (vcpu->arch.xive_vcpu && nr == vcpu->arch.xive_vcpu->server_num)"
                }
            }
        },
        "function_code": "static inline struct kvm_vcpu *kvmppc_xive_find_server(struct kvm *kvm, u32 nr)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.xive_vcpu && nr == vcpu->arch.xive_vcpu->server_num)\n\t\t\treturn vcpu;\n\t}\n\treturn NULL;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "vcpu",
        "function_name": "kvmppc_xive_vp_in_use",
        "location": {
            "file_path": "arch/powerpc/kvm/book3s_xive.h",
            "region": {
                "startLine": 246,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 244,
                "endLine": 248,
                "snippet": {
                    "text": "if (vcpu->arch.xive_vcpu && vp_id == vcpu->arch.xive_vcpu->vp_id)"
                }
            }
        },
        "function_code": "static inline bool kvmppc_xive_vp_in_use(struct kvm *kvm, u32 vp_id)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tunsigned long i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu->arch.xive_vcpu && vp_id == vcpu->arch.xive_vcpu->vp_id)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 477,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 475,
                "endLine": 479,
                "snippet": {
                    "text": "window->offset = offset;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 478,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 476,
                "endLine": 480,
                "snippet": {
                    "text": "window->size = size;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 479,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 477,
                "endLine": 481,
                "snippet": {
                    "text": "window->ioid = ioid;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 480,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 478,
                "endLine": 482,
                "snippet": {
                    "text": "window->iommu = iommu;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 482,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 480,
                "endLine": 484,
                "snippet": {
                    "text": "window->table.it_blocksize = 16;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 483,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 481,
                "endLine": 485,
                "snippet": {
                    "text": "window->table.it_base = (unsigned long)iommu->ptab;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 484,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 482,
                "endLine": 486,
                "snippet": {
                    "text": "window->table.it_index = iommu->nid;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 485,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 483,
                "endLine": 487,
                "snippet": {
                    "text": "window->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 486,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 484,
                "endLine": 488,
                "snippet": {
                    "text": "window->table.it_offset ="
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 487,
                "startColumn": 14,
                "endColumn": 20
            },
            "context": {
                "startLine": 485,
                "endLine": 489,
                "snippet": {
                    "text": "(offset >> window->table.it_page_shift) + pte_offset;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 488,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 486,
                "endLine": 490,
                "snippet": {
                    "text": "window->table.it_size = size >> window->table.it_page_shift;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "window",
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 489,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 487,
                "endLine": 491,
                "snippet": {
                    "text": "window->table.it_ops = &cell_iommu_ops;"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}",
        "result": 0
    },
    {
        "var_name": "np",
        "function_name": "cell_iommu_init_disabled",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 742,
                "startColumn": 8,
                "endColumn": 10
            },
            "context": {
                "startLine": 740,
                "endLine": 744,
                "snippet": {
                    "text": "if (np->parent == NULL || np->parent->parent != NULL)"
                }
            }
        },
        "function_code": "static int __init cell_iommu_init_disabled(void)\n{\n\tstruct device_node *np = NULL;\n\tunsigned long base = 0, size;\n\n\t/* When no iommu is present, we use direct DMA ops */\n\n\t/* First make sure all IOC translation is turned off */\n\tcell_disable_iommus();\n\n\t/* If we have no Axon, we set up the spider DMA magic offset */\n\tnp = of_find_node_by_name(NULL, \"axon\");\n\tif (!np)\n\t\tcell_dma_nommu_offset = SPIDER_DMA_OFFSET;\n\tof_node_put(np);\n\n\t/* Now we need to check to see where the memory is mapped\n\t * in PCI space. We assume that all busses use the same dma\n\t * window which is always the case so far on Cell, thus we\n\t * pick up the first pci-internal node we can find and check\n\t * the DMA window from there.\n\t */\n\tfor_each_node_by_name(np, \"axon\") {\n\t\tif (np->parent == NULL || np->parent->parent != NULL)\n\t\t\tcontinue;\n\t\tif (cell_iommu_get_window(np, &base, &size) == 0)\n\t\t\tbreak;\n\t}\n\tif (np == NULL) {\n\t\tfor_each_node_by_name(np, \"pci-internal\") {\n\t\t\tif (np->parent == NULL || np->parent->parent != NULL)\n\t\t\t\tcontinue;\n\t\t\tif (cell_iommu_get_window(np, &base, &size) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tof_node_put(np);\n\n\t/* If we found a DMA window, we check if it's big enough to enclose\n\t * all of physical memory. If not, we force enable IOMMU\n\t */\n\tif (np && size < memblock_end_of_DRAM()) {\n\t\tprintk(KERN_WARNING \"iommu: force-enabled, dma window\"\n\t\t       \" (%ldMB) smaller than total memory (%lldMB)\\n\",\n\t\t       size >> 20, memblock_end_of_DRAM() >> 20);\n\t\treturn -ENODEV;\n\t}\n\n\tcell_dma_nommu_offset += base;\n\n\tif (cell_dma_nommu_offset != 0)\n\t\tcell_pci_controller_ops.dma_dev_setup = cell_pci_dma_dev_setup;\n\n\tprintk(\"iommu: disabled, direct DMA offset is 0x%lx\\n\",\n\t       cell_dma_nommu_offset);\n\n\treturn 0;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "iommu",
        "function_name": "cell_iommu_fixed_mapping_init",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 1005,
                "startColumn": 34,
                "endColumn": 39
            },
            "context": {
                "startLine": 1003,
                "endLine": 1007,
                "snippet": {
                    "text": "\"fixed window 0x%lx-0x%lx\\n\", iommu->nid, dbase,"
                }
            }
        },
        "function_code": "static int __init cell_iommu_fixed_mapping_init(void)\n{\n\tunsigned long dbase, dsize, fbase, fsize, hbase, hend;\n\tstruct cbe_iommu *iommu;\n\tstruct device_node *np;\n\n\t/* The fixed mapping is only supported on axon machines */\n\tnp = of_find_node_by_name(NULL, \"axon\");\n\tof_node_put(np);\n\n\tif (!np) {\n\t\tpr_debug(\"iommu: fixed mapping disabled, no axons found\\n\");\n\t\treturn -1;\n\t}\n\n\t/* We must have dma-ranges properties for fixed mapping to work */\n\tnp = of_find_node_with_property(NULL, \"dma-ranges\");\n\tof_node_put(np);\n\n\tif (!np) {\n\t\tpr_debug(\"iommu: no dma-ranges found, no fixed mapping\\n\");\n\t\treturn -1;\n\t}\n\n\t/* The default setup is to have the fixed mapping sit after the\n\t * dynamic region, so find the top of the largest IOMMU window\n\t * on any axon, then add the size of RAM and that's our max value.\n\t * If that is > 32GB we have to do other shennanigans.\n\t */\n\tfbase = 0;\n\tfor_each_node_by_name(np, \"axon\") {\n\t\tcell_iommu_get_window(np, &dbase, &dsize);\n\t\tfbase = max(fbase, dbase + dsize);\n\t}\n\n\tfbase = ALIGN(fbase, 1 << IO_SEGMENT_SHIFT);\n\tfsize = memblock_phys_mem_size();\n\n\tif ((fbase + fsize) <= 0x800000000ul)\n\t\thbase = 0; /* use the device tree window */\n\telse {\n\t\t/* If we're over 32 GB we need to cheat. We can't map all of\n\t\t * RAM with the fixed mapping, and also fit the dynamic\n\t\t * region. So try to place the dynamic region where the hash\n\t\t * table sits, drivers never need to DMA to it, we don't\n\t\t * need a fixed mapping for that area.\n\t\t */\n\t\tif (!htab_address) {\n\t\t\tpr_debug(\"iommu: htab is NULL, on LPAR? Huh?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\thbase = __pa(htab_address);\n\t\thend  = hbase + htab_size_bytes;\n\n\t\t/* The window must start and end on a segment boundary */\n\t\tif ((hbase != ALIGN(hbase, 1 << IO_SEGMENT_SHIFT)) ||\n\t\t    (hend != ALIGN(hend, 1 << IO_SEGMENT_SHIFT))) {\n\t\t\tpr_debug(\"iommu: hash window not segment aligned\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Check the hash window fits inside the real DMA window */\n\t\tfor_each_node_by_name(np, \"axon\") {\n\t\t\tcell_iommu_get_window(np, &dbase, &dsize);\n\n\t\t\tif (hbase < dbase || (hend > (dbase + dsize))) {\n\t\t\t\tpr_debug(\"iommu: hash window doesn't fit in\"\n\t\t\t\t\t \"real DMA window\\n\");\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfbase = 0;\n\t}\n\n\t/* Setup the dynamic regions */\n\tfor_each_node_by_name(np, \"axon\") {\n\t\tiommu = cell_iommu_alloc(np);\n\t\tBUG_ON(!iommu);\n\n\t\tif (hbase == 0)\n\t\t\tcell_iommu_get_window(np, &dbase, &dsize);\n\t\telse {\n\t\t\tdbase = hbase;\n\t\t\tdsize = htab_size_bytes;\n\t\t}\n\n\t\tprintk(KERN_DEBUG \"iommu: node %d, dynamic window 0x%lx-0x%lx \"\n\t\t\t\"fixed window 0x%lx-0x%lx\\n\", iommu->nid, dbase,\n\t\t\t dbase + dsize, fbase, fbase + fsize);\n\n\t\tcell_iommu_setup_stab(iommu, dbase, dsize, fbase, fsize);\n\t\tiommu->ptab = cell_iommu_alloc_ptab(iommu, dbase, dsize, 0, 0,\n\t\t\t\t\t\t    IOMMU_PAGE_SHIFT_4K);\n\t\tcell_iommu_setup_fixed_ptab(iommu, np, dbase, dsize,\n\t\t\t\t\t     fbase, fsize);\n\t\tcell_iommu_enable_hardware(iommu);\n\t\tcell_iommu_setup_window(iommu, np, dbase, dsize, 0);\n\t}\n\n\tcell_pci_controller_ops.iommu_bypass_supported =\n\t\tcell_pci_iommu_bypass_supported;\n\treturn 0;\n}",
        "result": 0
    },
    {
        "var_name": "iommu",
        "function_name": "cell_iommu_fixed_mapping_init",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 1009,
                "startColumn": 3,
                "endColumn": 8
            },
            "context": {
                "startLine": 1007,
                "endLine": 1011,
                "snippet": {
                    "text": "iommu->ptab = cell_iommu_alloc_ptab(iommu, dbase, dsize, 0, 0,"
                }
            }
        },
        "function_code": "static int __init cell_iommu_fixed_mapping_init(void)\n{\n\tunsigned long dbase, dsize, fbase, fsize, hbase, hend;\n\tstruct cbe_iommu *iommu;\n\tstruct device_node *np;\n\n\t/* The fixed mapping is only supported on axon machines */\n\tnp = of_find_node_by_name(NULL, \"axon\");\n\tof_node_put(np);\n\n\tif (!np) {\n\t\tpr_debug(\"iommu: fixed mapping disabled, no axons found\\n\");\n\t\treturn -1;\n\t}\n\n\t/* We must have dma-ranges properties for fixed mapping to work */\n\tnp = of_find_node_with_property(NULL, \"dma-ranges\");\n\tof_node_put(np);\n\n\tif (!np) {\n\t\tpr_debug(\"iommu: no dma-ranges found, no fixed mapping\\n\");\n\t\treturn -1;\n\t}\n\n\t/* The default setup is to have the fixed mapping sit after the\n\t * dynamic region, so find the top of the largest IOMMU window\n\t * on any axon, then add the size of RAM and that's our max value.\n\t * If that is > 32GB we have to do other shennanigans.\n\t */\n\tfbase = 0;\n\tfor_each_node_by_name(np, \"axon\") {\n\t\tcell_iommu_get_window(np, &dbase, &dsize);\n\t\tfbase = max(fbase, dbase + dsize);\n\t}\n\n\tfbase = ALIGN(fbase, 1 << IO_SEGMENT_SHIFT);\n\tfsize = memblock_phys_mem_size();\n\n\tif ((fbase + fsize) <= 0x800000000ul)\n\t\thbase = 0; /* use the device tree window */\n\telse {\n\t\t/* If we're over 32 GB we need to cheat. We can't map all of\n\t\t * RAM with the fixed mapping, and also fit the dynamic\n\t\t * region. So try to place the dynamic region where the hash\n\t\t * table sits, drivers never need to DMA to it, we don't\n\t\t * need a fixed mapping for that area.\n\t\t */\n\t\tif (!htab_address) {\n\t\t\tpr_debug(\"iommu: htab is NULL, on LPAR? Huh?\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\thbase = __pa(htab_address);\n\t\thend  = hbase + htab_size_bytes;\n\n\t\t/* The window must start and end on a segment boundary */\n\t\tif ((hbase != ALIGN(hbase, 1 << IO_SEGMENT_SHIFT)) ||\n\t\t    (hend != ALIGN(hend, 1 << IO_SEGMENT_SHIFT))) {\n\t\t\tpr_debug(\"iommu: hash window not segment aligned\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* Check the hash window fits inside the real DMA window */\n\t\tfor_each_node_by_name(np, \"axon\") {\n\t\t\tcell_iommu_get_window(np, &dbase, &dsize);\n\n\t\t\tif (hbase < dbase || (hend > (dbase + dsize))) {\n\t\t\t\tpr_debug(\"iommu: hash window doesn't fit in\"\n\t\t\t\t\t \"real DMA window\\n\");\n\t\t\t\tof_node_put(np);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfbase = 0;\n\t}\n\n\t/* Setup the dynamic regions */\n\tfor_each_node_by_name(np, \"axon\") {\n\t\tiommu = cell_iommu_alloc(np);\n\t\tBUG_ON(!iommu);\n\n\t\tif (hbase == 0)\n\t\t\tcell_iommu_get_window(np, &dbase, &dsize);\n\t\telse {\n\t\t\tdbase = hbase;\n\t\t\tdsize = htab_size_bytes;\n\t\t}\n\n\t\tprintk(KERN_DEBUG \"iommu: node %d, dynamic window 0x%lx-0x%lx \"\n\t\t\t\"fixed window 0x%lx-0x%lx\\n\", iommu->nid, dbase,\n\t\t\t dbase + dsize, fbase, fbase + fsize);\n\n\t\tcell_iommu_setup_stab(iommu, dbase, dsize, fbase, fsize);\n\t\tiommu->ptab = cell_iommu_alloc_ptab(iommu, dbase, dsize, 0, 0,\n\t\t\t\t\t\t    IOMMU_PAGE_SHIFT_4K);\n\t\tcell_iommu_setup_fixed_ptab(iommu, np, dbase, dsize,\n\t\t\t\t\t     fbase, fsize);\n\t\tcell_iommu_enable_hardware(iommu);\n\t\tcell_iommu_setup_window(iommu, np, dbase, dsize, 0);\n\t}\n\n\tcell_pci_controller_ops.iommu_bypass_supported =\n\t\tcell_pci_iommu_bypass_supported;\n\treturn 0;\n}",
        "result": 0
    },
    {
        "var_name": "spu",
        "function_name": "ctx_location",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/spufs/sched.c",
            "region": {
                "startLine": 370,
                "startColumn": 11,
                "endColumn": 14
            },
            "context": {
                "startLine": 368,
                "endLine": 372,
                "snippet": {
                    "text": "BUG_ON(spu->node != node);"
                }
            }
        },
        "function_code": "static struct spu *ctx_location(struct spu *ref, int offset, int node)\n{\n\tstruct spu *spu;\n\n\tspu = NULL;\n\tif (offset >= 0) {\n\t\tlist_for_each_entry(spu, ref->aff_list.prev, aff_list) {\n\t\t\tBUG_ON(spu->node != node);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t\tif (sched_spu(spu))\n\t\t\t\toffset--;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry_reverse(spu, ref->aff_list.next, aff_list) {\n\t\t\tBUG_ON(spu->node != node);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t\tif (sched_spu(spu))\n\t\t\t\toffset++;\n\t\t}\n\t}\n\n\treturn spu;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "spu",
        "function_name": "ctx_location",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/spufs/sched.c",
            "region": {
                "startLine": 378,
                "startColumn": 11,
                "endColumn": 14
            },
            "context": {
                "startLine": 376,
                "endLine": 380,
                "snippet": {
                    "text": "BUG_ON(spu->node != node);"
                }
            }
        },
        "function_code": "static struct spu *ctx_location(struct spu *ref, int offset, int node)\n{\n\tstruct spu *spu;\n\n\tspu = NULL;\n\tif (offset >= 0) {\n\t\tlist_for_each_entry(spu, ref->aff_list.prev, aff_list) {\n\t\t\tBUG_ON(spu->node != node);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t\tif (sched_spu(spu))\n\t\t\t\toffset--;\n\t\t}\n\t} else {\n\t\tlist_for_each_entry_reverse(spu, ref->aff_list.next, aff_list) {\n\t\t\tBUG_ON(spu->node != node);\n\t\t\tif (offset == 0)\n\t\t\t\tbreak;\n\t\t\tif (sched_spu(spu))\n\t\t\t\toffset++;\n\t\t}\n\t}\n\n\treturn spu;\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "kbd",
        "function_name": "chrp_init_IRQ",
        "location": {
            "file_path": "arch/powerpc/platforms/chrp/setup.c",
            "region": {
                "startLine": 524,
                "startColumn": 23,
                "endColumn": 26
            },
            "context": {
                "startLine": 522,
                "endLine": 526,
                "snippet": {
                    "text": "if (of_node_is_type(kbd->parent, \"adb\"))"
                }
            }
        },
        "function_code": "static void __init chrp_init_IRQ(void)\n{\n#if defined(CONFIG_VT) && defined(CONFIG_INPUT_ADBHID) && defined(CONFIG_XMON)\n\tstruct device_node *kbd;\n#endif\n\tchrp_find_openpic();\n\tchrp_find_8259();\n\n#ifdef CONFIG_SMP\n\t/* Pegasos has no MPIC, those ops would make it crash. It might be an\n\t * option to move setting them to after we probe the PIC though\n\t */\n\tif (chrp_mpic != NULL)\n\t\tsmp_ops = &chrp_smp_ops;\n#endif /* CONFIG_SMP */\n\n\tif (_chrp_type == _CHRP_Pegasos)\n\t\tppc_md.get_irq        = i8259_irq;\n\n#if defined(CONFIG_VT) && defined(CONFIG_INPUT_ADBHID) && defined(CONFIG_XMON)\n\t/* see if there is a keyboard in the device tree\n\t   with a parent of type \"adb\" */\n\tfor_each_node_by_name(kbd, \"keyboard\")\n\t\tif (of_node_is_type(kbd->parent, \"adb\"))\n\t\t\tbreak;\n\tof_node_put(kbd);\n\tif (kbd) {\n\t\tif (request_irq(HYDRA_INT_ADB_NMI, xmon_irq, 0, \"XMON break\",\n\t\t\t\tNULL))\n\t\t\tpr_err(\"Failed to register XMON break interrupt\\n\");\n\t}\n#endif\n}",
        "result": 0,
        "loop_assign": 1
    },
    {
        "var_name": "mpic",
        "function_name": "holly_init_IRQ",
        "location": {
            "file_path": "arch/powerpc/platforms/embedded6xx/holly.c",
            "region": {
                "startLine": 167,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 165,
                "endLine": 169,
                "snippet": {
                    "text": "mpic_assign_isu(mpic, 0, mpic->paddr + 0x100);"
                }
            }
        },
        "function_code": "static void __init holly_init_IRQ(void)\n{\n\tstruct mpic *mpic;\n#ifdef CONFIG_PCI\n\tunsigned int cascade_pci_irq;\n\tstruct device_node *tsi_pci;\n\tstruct device_node *cascade_node = NULL;\n#endif\n\n\tmpic = mpic_alloc(NULL, 0, MPIC_BIG_ENDIAN |\n\t\t\tMPIC_SPV_EOI | MPIC_NO_PTHROU_DIS | MPIC_REGSET_TSI108,\n\t\t\t24, 0,\n\t\t\t\"Tsi108_PIC\");\n\n\tBUG_ON(mpic == NULL);\n\n\tmpic_assign_isu(mpic, 0, mpic->paddr + 0x100);\n\n\tmpic_init(mpic);\n\n#ifdef CONFIG_PCI\n\ttsi_pci = of_find_node_by_type(NULL, \"pci\");\n\tif (tsi_pci == NULL) {\n\t\tprintk(KERN_ERR \"%s: No tsi108 pci node found !\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcascade_node = of_find_node_by_type(NULL, \"pic-router\");\n\tif (cascade_node == NULL) {\n\t\tprintk(KERN_ERR \"%s: No tsi108 pci cascade node found !\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcascade_pci_irq = irq_of_parse_and_map(tsi_pci, 0);\n\tpr_debug(\"%s: tsi108 cascade_pci_irq = 0x%x\\n\", __func__, (u32) cascade_pci_irq);\n\ttsi108_pci_int_init(cascade_node);\n\tirq_set_handler_data(cascade_pci_irq, mpic);\n\tirq_set_chained_handler(cascade_pci_irq, tsi108_irq_cascade);\n\n\tof_node_put(tsi_pci);\n\tof_node_put(cascade_node);\n#endif\n\t/* Configure MPIC outputs to CPU0 */\n\ttsi108_write_reg(TSI108_MPIC_OFFSET + 0x30c, 0);\n}",
        "result": 0
    },
    {
        "var_name": "mpic",
        "function_name": "linkstation_init_IRQ",
        "location": {
            "file_path": "arch/powerpc/platforms/embedded6xx/linkstation.c",
            "region": {
                "startLine": 91,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 89,
                "endLine": 93,
                "snippet": {
                    "text": "mpic_assign_isu(mpic, 0, mpic->paddr + 0x10200);"
                }
            }
        },
        "function_code": "static void __init linkstation_init_IRQ(void)\n{\n\tstruct mpic *mpic;\n\n\tmpic = mpic_alloc(NULL, 0, 0, 4, 0, \" EPIC     \");\n\tBUG_ON(mpic == NULL);\n\n\t/* PCI IRQs */\n\tmpic_assign_isu(mpic, 0, mpic->paddr + 0x10200);\n\n\t/* I2C */\n\tmpic_assign_isu(mpic, 1, mpic->paddr + 0x11000);\n\n\t/* ttyS0, ttyS1 */\n\tmpic_assign_isu(mpic, 2, mpic->paddr + 0x11100);\n\n\tmpic_init(mpic);\n}",
        "result": 0
    },
    {
        "var_name": "mpic",
        "function_name": "linkstation_init_IRQ",
        "location": {
            "file_path": "arch/powerpc/platforms/embedded6xx/linkstation.c",
            "region": {
                "startLine": 94,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 92,
                "endLine": 96,
                "snippet": {
                    "text": "mpic_assign_isu(mpic, 1, mpic->paddr + 0x11000);"
                }
            }
        },
        "function_code": "static void __init linkstation_init_IRQ(void)\n{\n\tstruct mpic *mpic;\n\n\tmpic = mpic_alloc(NULL, 0, 0, 4, 0, \" EPIC     \");\n\tBUG_ON(mpic == NULL);\n\n\t/* PCI IRQs */\n\tmpic_assign_isu(mpic, 0, mpic->paddr + 0x10200);\n\n\t/* I2C */\n\tmpic_assign_isu(mpic, 1, mpic->paddr + 0x11000);\n\n\t/* ttyS0, ttyS1 */\n\tmpic_assign_isu(mpic, 2, mpic->paddr + 0x11100);\n\n\tmpic_init(mpic);\n}",
        "result": 0
    },
    {
        "var_name": "mpic",
        "function_name": "linkstation_init_IRQ",
        "location": {
            "file_path": "arch/powerpc/platforms/embedded6xx/linkstation.c",
            "region": {
                "startLine": 97,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 95,
                "endLine": 99,
                "snippet": {
                    "text": "mpic_assign_isu(mpic, 2, mpic->paddr + 0x11100);"
                }
            }
        },
        "function_code": "static void __init linkstation_init_IRQ(void)\n{\n\tstruct mpic *mpic;\n\n\tmpic = mpic_alloc(NULL, 0, 0, 4, 0, \" EPIC     \");\n\tBUG_ON(mpic == NULL);\n\n\t/* PCI IRQs */\n\tmpic_assign_isu(mpic, 0, mpic->paddr + 0x10200);\n\n\t/* I2C */\n\tmpic_assign_isu(mpic, 1, mpic->paddr + 0x11000);\n\n\t/* ttyS0, ttyS1 */\n\tmpic_assign_isu(mpic, 2, mpic->paddr + 0x11100);\n\n\tmpic_init(mpic);\n}",
        "result": 0
    },
    {
        "var_name": "mpic",
        "function_name": "storcenter_init_IRQ",
        "location": {
            "file_path": "arch/powerpc/platforms/embedded6xx/storcenter.c",
            "region": {
                "startLine": 95,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 93,
                "endLine": 97,
                "snippet": {
                    "text": "mpic_assign_isu(mpic, 0, mpic->paddr + 0x10200);"
                }
            }
        },
        "function_code": "static void __init storcenter_init_IRQ(void)\n{\n\tstruct mpic *mpic;\n\n\tmpic = mpic_alloc(NULL, 0, 0, 16, 0, \" OpenPIC  \");\n\tBUG_ON(mpic == NULL);\n\n\t/*\n\t * 16 Serial Interrupts followed by 16 Internal Interrupts.\n\t * I2C is the second internal, so it is at 17, 0x11020.\n\t */\n\tmpic_assign_isu(mpic, 0, mpic->paddr + 0x10200);\n\tmpic_assign_isu(mpic, 1, mpic->paddr + 0x11000);\n\n\tmpic_init(mpic);\n}",
        "result": 0
    },
    {
        "var_name": "mpic",
        "function_name": "storcenter_init_IRQ",
        "location": {
            "file_path": "arch/powerpc/platforms/embedded6xx/storcenter.c",
            "region": {
                "startLine": 96,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 94,
                "endLine": 98,
                "snippet": {
                    "text": "mpic_assign_isu(mpic, 1, mpic->paddr + 0x11000);"
                }
            }
        },
        "function_code": "static void __init storcenter_init_IRQ(void)\n{\n\tstruct mpic *mpic;\n\n\tmpic = mpic_alloc(NULL, 0, 0, 16, 0, \" OpenPIC  \");\n\tBUG_ON(mpic == NULL);\n\n\t/*\n\t * 16 Serial Interrupts followed by 16 Internal Interrupts.\n\t * I2C is the second internal, so it is at 17, 0x11020.\n\t */\n\tmpic_assign_isu(mpic, 0, mpic->paddr + 0x10200);\n\tmpic_assign_isu(mpic, 1, mpic->paddr + 0x11000);\n\n\tmpic_init(mpic);\n}",
        "result": 0
    },
    {
        "var_name": "hose",
        "function_name": "hpcd_final_uli5288",
        "location": {
            "file_path": "arch/powerpc/platforms/fsl_uli1575.c",
            "region": {
                "startLine": 336,
                "startColumn": 14,
                "endColumn": 18
            },
            "context": {
                "startLine": 334,
                "endLine": 338,
                "snippet": {
                    "text": "laddr[0] = (hose->first_busno << 16) | (PCI_DEVFN(31, 0) << 8);"
                }
            }
        },
        "function_code": "static void hpcd_final_uli5288(struct pci_dev *dev)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(dev->bus);\n\tstruct device_node *hosenode = hose ? hose->dn : NULL;\n\tstruct of_phandle_args oirq;\n\tu32 laddr[3];\n\n\tif (!machine_is(mpc86xx_hpcd))\n\t\treturn;\n\n\tif (!hosenode)\n\t\treturn;\n\n\toirq.np = hosenode;\n\toirq.args[0] = 2;\n\toirq.args_count = 1;\n\tladdr[0] = (hose->first_busno << 16) | (PCI_DEVFN(31, 0) << 8);\n\tladdr[1] = laddr[2] = 0;\n\tof_irq_parse_raw(laddr, &oirq);\n\tdev->irq = irq_create_of_mapping(&oirq);\n}",
        "result": 0
    },
    {
        "var_name": "mpic",
        "function_name": "pas_init_IRQ",
        "location": {
            "file_path": "arch/powerpc/platforms/pasemi/setup.c",
            "region": {
                "startLine": 291,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 289,
                "endLine": 293,
                "snippet": {
                    "text": "mpic_assign_isu(mpic, 0, mpic->paddr + 0x10000);"
                }
            }
        },
        "function_code": "static __init void pas_init_IRQ(void)\n{\n\tstruct device_node *np;\n\tstruct device_node *root, *mpic_node;\n\tunsigned long openpic_addr;\n\tconst unsigned int *opprop;\n\tint naddr, opplen;\n\tint mpic_flags;\n\tconst unsigned int *nmiprop;\n\tstruct mpic *mpic;\n\n\tmpic_node = NULL;\n\n\tfor_each_node_by_type(np, \"interrupt-controller\")\n\t\tif (of_device_is_compatible(np, \"open-pic\")) {\n\t\t\tmpic_node = np;\n\t\t\tbreak;\n\t\t}\n\tif (!mpic_node)\n\t\tfor_each_node_by_type(np, \"open-pic\") {\n\t\t\tmpic_node = np;\n\t\t\tbreak;\n\t\t}\n\tif (!mpic_node) {\n\t\tpr_err(\"Failed to locate the MPIC interrupt controller\\n\");\n\t\treturn;\n\t}\n\n\t/* Find address list in /platform-open-pic */\n\troot = of_find_node_by_path(\"/\");\n\tnaddr = of_n_addr_cells(root);\n\topprop = of_get_property(root, \"platform-open-pic\", &opplen);\n\tif (!opprop) {\n\t\tpr_err(\"No platform-open-pic property.\\n\");\n\t\tof_node_put(root);\n\t\treturn;\n\t}\n\topenpic_addr = of_read_number(opprop, naddr);\n\tpr_debug(\"OpenPIC addr: %lx\\n\", openpic_addr);\n\n\tmpic_flags = MPIC_LARGE_VECTORS | MPIC_NO_BIAS | MPIC_NO_RESET;\n\n\tnmiprop = of_get_property(mpic_node, \"nmi-source\", NULL);\n\tif (nmiprop)\n\t\tmpic_flags |= MPIC_ENABLE_MCK;\n\n\tmpic = mpic_alloc(mpic_node, openpic_addr,\n\t\t\t  mpic_flags, 0, 0, \"PASEMI-OPIC\");\n\tBUG_ON(!mpic);\n\n\tmpic_assign_isu(mpic, 0, mpic->paddr + 0x10000);\n\tmpic_init(mpic);\n\t/* The NMI/MCK source needs to be prio 15 */\n\tif (nmiprop) {\n\t\tnmi_virq = irq_create_mapping(NULL, *nmiprop);\n\t\tmpic_irq_set_priority(nmi_virq, 15);\n\t\tirq_set_irq_type(nmi_virq, IRQ_TYPE_EDGE_RISING);\n\t\tmpic_unmask_irq(irq_get_irq_data(nmi_virq));\n\t}\n\n\tnemo_init_IRQ(mpic);\n\n\tof_node_put(mpic_node);\n\tof_node_put(root);\n}",
        "result": 0
    },
    {
        "var_name": "w",
        "function_name": "pnv_pci_fixup_bridge_resources",
        "location": {
            "file_path": "arch/powerpc/platforms/powernv/pci-ioda.c",
            "region": {
                "startLine": 2273,
                "startColumn": 14,
                "endColumn": 15
            },
            "context": {
                "startLine": 2271,
                "endLine": 2275,
                "snippet": {
                    "text": "r->start = w->start;"
                }
            }
        },
        "function_code": "static void pnv_pci_fixup_bridge_resources(struct pci_bus *bus,\n\t\t\t\t\t   unsigned long type)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pnv_phb *phb = hose->private_data;\n\tstruct pci_dev *bridge = bus->self;\n\tstruct resource *r, *w;\n\tbool msi_region = false;\n\tint i;\n\n\t/* Check if we need apply fixup to the bridge's windows */\n\tif (!pci_is_root_bus(bridge->bus) &&\n\t    !pci_is_root_bus(bridge->bus->self->bus))\n\t\treturn;\n\n\t/* Fixup the resources */\n\tfor (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {\n\t\tr = &bridge->resource[PCI_BRIDGE_RESOURCES + i];\n\t\tif (!r->flags || !r->parent)\n\t\t\tcontinue;\n\n\t\tw = NULL;\n\t\tif (r->flags & type & IORESOURCE_IO)\n\t\t\tw = &hose->io_resource;\n\t\telse if (pnv_pci_is_m64(phb, r) &&\n\t\t\t (type & IORESOURCE_PREFETCH) &&\n\t\t\t phb->ioda.m64_segsize)\n\t\t\tw = &hose->mem_resources[1];\n\t\telse if (r->flags & type & IORESOURCE_MEM) {\n\t\t\tw = &hose->mem_resources[0];\n\t\t\tmsi_region = true;\n\t\t}\n\n\t\tr->start = w->start;\n\t\tr->end = w->end;\n\n\t\t/* The 64KB 32-bits MSI region shouldn't be included in\n\t\t * the 32-bits bridge window. Otherwise, we can see strange\n\t\t * issues. One of them is EEH error observed on Garrison.\n\t\t *\n\t\t * Exclude top 1MB region which is the minimal alignment of\n\t\t * 32-bits bridge window.\n\t\t */\n\t\tif (msi_region) {\n\t\t\tr->end += 0x10000;\n\t\t\tr->end -= 0x100000;\n\t\t}\n\t}\n}",
        "result": -1
    },
    {
        "var_name": "w",
        "function_name": "pnv_pci_fixup_bridge_resources",
        "location": {
            "file_path": "arch/powerpc/platforms/powernv/pci-ioda.c",
            "region": {
                "startLine": 2274,
                "startColumn": 12,
                "endColumn": 13
            },
            "context": {
                "startLine": 2272,
                "endLine": 2276,
                "snippet": {
                    "text": "r->end = w->end;"
                }
            }
        },
        "function_code": "static void pnv_pci_fixup_bridge_resources(struct pci_bus *bus,\n\t\t\t\t\t   unsigned long type)\n{\n\tstruct pci_controller *hose = pci_bus_to_host(bus);\n\tstruct pnv_phb *phb = hose->private_data;\n\tstruct pci_dev *bridge = bus->self;\n\tstruct resource *r, *w;\n\tbool msi_region = false;\n\tint i;\n\n\t/* Check if we need apply fixup to the bridge's windows */\n\tif (!pci_is_root_bus(bridge->bus) &&\n\t    !pci_is_root_bus(bridge->bus->self->bus))\n\t\treturn;\n\n\t/* Fixup the resources */\n\tfor (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {\n\t\tr = &bridge->resource[PCI_BRIDGE_RESOURCES + i];\n\t\tif (!r->flags || !r->parent)\n\t\t\tcontinue;\n\n\t\tw = NULL;\n\t\tif (r->flags & type & IORESOURCE_IO)\n\t\t\tw = &hose->io_resource;\n\t\telse if (pnv_pci_is_m64(phb, r) &&\n\t\t\t (type & IORESOURCE_PREFETCH) &&\n\t\t\t phb->ioda.m64_segsize)\n\t\t\tw = &hose->mem_resources[1];\n\t\telse if (r->flags & type & IORESOURCE_MEM) {\n\t\t\tw = &hose->mem_resources[0];\n\t\t\tmsi_region = true;\n\t\t}\n\n\t\tr->start = w->start;\n\t\tr->end = w->end;\n\n\t\t/* The 64KB 32-bits MSI region shouldn't be included in\n\t\t * the 32-bits bridge window. Otherwise, we can see strange\n\t\t * issues. One of them is EEH error observed on Garrison.\n\t\t *\n\t\t * Exclude top 1MB region which is the minimal alignment of\n\t\t * 32-bits bridge window.\n\t\t */\n\t\tif (msi_region) {\n\t\t\tr->end += 0x10000;\n\t\t\tr->end -= 0x100000;\n\t\t}\n\t}\n}",
        "result": -1
    },
    {
        "var_name": "drv",
        "function_name": "ps3_system_bus_probe",
        "location": {
            "file_path": "arch/powerpc/platforms/ps3/system-bus.c",
            "region": {
                "startLine": 374,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 372,
                "endLine": 376,
                "snippet": {
                    "text": "if (drv->probe)"
                }
            }
        },
        "function_code": "static int ps3_system_bus_probe(struct device *_dev)\n{\n\tint result = 0;\n\tstruct ps3_system_bus_device *dev = ps3_dev_to_system_bus_dev(_dev);\n\tstruct ps3_system_bus_driver *drv;\n\n\tBUG_ON(!dev);\n\tdev_dbg(_dev, \"%s:%d\\n\", __func__, __LINE__);\n\n\tdrv = ps3_system_bus_dev_to_system_bus_drv(dev);\n\tBUG_ON(!drv);\n\n\tif (drv->probe)\n\t\tresult = drv->probe(dev);\n\telse\n\t\tpr_debug(\"%s:%d: %s no probe method\\n\", __func__, __LINE__,\n\t\t\tdev_name(&dev->core));\n\n\tpr_debug(\" <- %s:%d: %s\\n\", __func__, __LINE__, dev_name(&dev->core));\n\treturn result;\n}",
        "result": 0
    },
    {
        "var_name": "drv",
        "function_name": "ps3_system_bus_remove",
        "location": {
            "file_path": "arch/powerpc/platforms/ps3/system-bus.c",
            "region": {
                "startLine": 395,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 393,
                "endLine": 397,
                "snippet": {
                    "text": "if (drv->remove)"
                }
            }
        },
        "function_code": "static void ps3_system_bus_remove(struct device *_dev)\n{\n\tstruct ps3_system_bus_device *dev = ps3_dev_to_system_bus_dev(_dev);\n\tstruct ps3_system_bus_driver *drv;\n\n\tBUG_ON(!dev);\n\tdev_dbg(_dev, \"%s:%d\\n\", __func__, __LINE__);\n\n\tdrv = ps3_system_bus_dev_to_system_bus_drv(dev);\n\tBUG_ON(!drv);\n\n\tif (drv->remove)\n\t\tdrv->remove(dev);\n\telse\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no remove method\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\n\tpr_debug(\" <- %s:%d: %s\\n\", __func__, __LINE__, dev_name(&dev->core));\n}",
        "result": 0
    },
    {
        "var_name": "dev",
        "function_name": "ps3_system_bus_shutdown",
        "location": {
            "file_path": "arch/powerpc/platforms/ps3/system-bus.c",
            "region": {
                "startLine": 412,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 410,
                "endLine": 414,
                "snippet": {
                    "text": "dev->match_id);"
                }
            }
        },
        "function_code": "static void ps3_system_bus_shutdown(struct device *_dev)\n{\n\tstruct ps3_system_bus_device *dev = ps3_dev_to_system_bus_dev(_dev);\n\tstruct ps3_system_bus_driver *drv;\n\n\tBUG_ON(!dev);\n\n\tdev_dbg(&dev->core, \" -> %s:%d: match_id %d\\n\", __func__, __LINE__,\n\t\tdev->match_id);\n\n\tif (!dev->core.driver) {\n\t\tdev_dbg(&dev->core, \"%s:%d: no driver bound\\n\", __func__,\n\t\t\t__LINE__);\n\t\treturn;\n\t}\n\n\tdrv = ps3_system_bus_dev_to_system_bus_drv(dev);\n\n\tBUG_ON(!drv);\n\n\tdev_dbg(&dev->core, \"%s:%d: %s -> %s\\n\", __func__, __LINE__,\n\t\tdev_name(&dev->core), drv->core.name);\n\n\tif (drv->shutdown)\n\t\tdrv->shutdown(dev);\n\telse if (drv->remove) {\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no shutdown, calling remove\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\t\tdrv->remove(dev);\n\t} else {\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no shutdown method\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\t\tBUG();\n\t}\n\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n}",
        "result": 0
    },
    {
        "var_name": "dev",
        "function_name": "ps3_system_bus_shutdown",
        "location": {
            "file_path": "arch/powerpc/platforms/ps3/system-bus.c",
            "region": {
                "startLine": 414,
                "startColumn": 7,
                "endColumn": 10
            },
            "context": {
                "startLine": 412,
                "endLine": 416,
                "snippet": {
                    "text": "if (!dev->core.driver) {"
                }
            }
        },
        "function_code": "static void ps3_system_bus_shutdown(struct device *_dev)\n{\n\tstruct ps3_system_bus_device *dev = ps3_dev_to_system_bus_dev(_dev);\n\tstruct ps3_system_bus_driver *drv;\n\n\tBUG_ON(!dev);\n\n\tdev_dbg(&dev->core, \" -> %s:%d: match_id %d\\n\", __func__, __LINE__,\n\t\tdev->match_id);\n\n\tif (!dev->core.driver) {\n\t\tdev_dbg(&dev->core, \"%s:%d: no driver bound\\n\", __func__,\n\t\t\t__LINE__);\n\t\treturn;\n\t}\n\n\tdrv = ps3_system_bus_dev_to_system_bus_drv(dev);\n\n\tBUG_ON(!drv);\n\n\tdev_dbg(&dev->core, \"%s:%d: %s -> %s\\n\", __func__, __LINE__,\n\t\tdev_name(&dev->core), drv->core.name);\n\n\tif (drv->shutdown)\n\t\tdrv->shutdown(dev);\n\telse if (drv->remove) {\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no shutdown, calling remove\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\t\tdrv->remove(dev);\n\t} else {\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no shutdown method\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\t\tBUG();\n\t}\n\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n}",
        "result": 0
    },
    {
        "var_name": "drv",
        "function_name": "ps3_system_bus_shutdown",
        "location": {
            "file_path": "arch/powerpc/platforms/ps3/system-bus.c",
            "region": {
                "startLine": 425,
                "startColumn": 25,
                "endColumn": 28
            },
            "context": {
                "startLine": 423,
                "endLine": 427,
                "snippet": {
                    "text": "dev_name(&dev->core), drv->core.name);"
                }
            }
        },
        "function_code": "static void ps3_system_bus_shutdown(struct device *_dev)\n{\n\tstruct ps3_system_bus_device *dev = ps3_dev_to_system_bus_dev(_dev);\n\tstruct ps3_system_bus_driver *drv;\n\n\tBUG_ON(!dev);\n\n\tdev_dbg(&dev->core, \" -> %s:%d: match_id %d\\n\", __func__, __LINE__,\n\t\tdev->match_id);\n\n\tif (!dev->core.driver) {\n\t\tdev_dbg(&dev->core, \"%s:%d: no driver bound\\n\", __func__,\n\t\t\t__LINE__);\n\t\treturn;\n\t}\n\n\tdrv = ps3_system_bus_dev_to_system_bus_drv(dev);\n\n\tBUG_ON(!drv);\n\n\tdev_dbg(&dev->core, \"%s:%d: %s -> %s\\n\", __func__, __LINE__,\n\t\tdev_name(&dev->core), drv->core.name);\n\n\tif (drv->shutdown)\n\t\tdrv->shutdown(dev);\n\telse if (drv->remove) {\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no shutdown, calling remove\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\t\tdrv->remove(dev);\n\t} else {\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no shutdown method\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\t\tBUG();\n\t}\n\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n}",
        "result": 0
    },
    {
        "var_name": "drv",
        "function_name": "ps3_system_bus_shutdown",
        "location": {
            "file_path": "arch/powerpc/platforms/ps3/system-bus.c",
            "region": {
                "startLine": 427,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 425,
                "endLine": 429,
                "snippet": {
                    "text": "if (drv->shutdown)"
                }
            }
        },
        "function_code": "static void ps3_system_bus_shutdown(struct device *_dev)\n{\n\tstruct ps3_system_bus_device *dev = ps3_dev_to_system_bus_dev(_dev);\n\tstruct ps3_system_bus_driver *drv;\n\n\tBUG_ON(!dev);\n\n\tdev_dbg(&dev->core, \" -> %s:%d: match_id %d\\n\", __func__, __LINE__,\n\t\tdev->match_id);\n\n\tif (!dev->core.driver) {\n\t\tdev_dbg(&dev->core, \"%s:%d: no driver bound\\n\", __func__,\n\t\t\t__LINE__);\n\t\treturn;\n\t}\n\n\tdrv = ps3_system_bus_dev_to_system_bus_drv(dev);\n\n\tBUG_ON(!drv);\n\n\tdev_dbg(&dev->core, \"%s:%d: %s -> %s\\n\", __func__, __LINE__,\n\t\tdev_name(&dev->core), drv->core.name);\n\n\tif (drv->shutdown)\n\t\tdrv->shutdown(dev);\n\telse if (drv->remove) {\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no shutdown, calling remove\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\t\tdrv->remove(dev);\n\t} else {\n\t\tdev_dbg(&dev->core, \"%s:%d %s: no shutdown method\\n\",\n\t\t\t__func__, __LINE__, drv->core.name);\n\t\tBUG();\n\t}\n\n\tdev_dbg(&dev->core, \" <- %s:%d\\n\", __func__, __LINE__);\n}",
        "result": 0
    },
    {
        "var_name": "buff_stats",
        "function_name": "drc_pmem_query_stats",
        "location": {
            "file_path": "arch/powerpc/platforms/pseries/papr_scm.c",
            "region": {
                "startLine": 343,
                "startColumn": 15,
                "endColumn": 25
            },
            "context": {
                "startLine": 341,
                "endLine": 345,
                "snippet": {
                    "text": "be32_to_cpu(buff_stats->num_statistics));"
                }
            }
        },
        "function_code": "static ssize_t drc_pmem_query_stats(struct papr_scm_priv *p,\n\t\t\t\t    struct papr_scm_perf_stats *buff_stats,\n\t\t\t\t    unsigned int num_stats)\n{\n\tunsigned long ret[PLPAR_HCALL_BUFSIZE];\n\tsize_t size;\n\ts64 rc;\n\n\t/* Setup the out buffer */\n\tif (buff_stats) {\n\t\tmemcpy(buff_stats->eye_catcher,\n\t\t       PAPR_SCM_PERF_STATS_EYECATCHER, 8);\n\t\tbuff_stats->stats_version =\n\t\t\tcpu_to_be32(PAPR_SCM_PERF_STATS_VERSION);\n\t\tbuff_stats->num_statistics =\n\t\t\tcpu_to_be32(num_stats);\n\n\t\t/*\n\t\t * Calculate the buffer size based on num-stats provided\n\t\t * or use the prefetched max buffer length\n\t\t */\n\t\tif (num_stats)\n\t\t\t/* Calculate size from the num_stats */\n\t\t\tsize = sizeof(struct papr_scm_perf_stats) +\n\t\t\t\tnum_stats * sizeof(struct papr_scm_perf_stat);\n\t\telse\n\t\t\tsize = p->stat_buffer_len;\n\t} else {\n\t\t/* In case of no out buffer ignore the size */\n\t\tsize = 0;\n\t}\n\n\t/* Do the HCALL asking PHYP for info */\n\trc = plpar_hcall(H_SCM_PERFORMANCE_STATS, ret, p->drc_index,\n\t\t\t buff_stats ? virt_to_phys(buff_stats) : 0,\n\t\t\t size);\n\n\t/* Check if the error was due to an unknown stat-id */\n\tif (rc == H_PARTIAL) {\n\t\tdev_err(&p->pdev->dev,\n\t\t\t\"Unknown performance stats, Err:0x%016lX\\n\", ret[0]);\n\t\treturn -ENOENT;\n\t} else if (rc == H_AUTHORITY) {\n\t\tdev_info(&p->pdev->dev,\n\t\t\t \"Permission denied while accessing performance stats\");\n\t\treturn -EPERM;\n\t} else if (rc == H_UNSUPPORTED) {\n\t\tdev_dbg(&p->pdev->dev, \"Performance stats unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t} else if (rc != H_SUCCESS) {\n\t\tdev_err(&p->pdev->dev,\n\t\t\t\"Failed to query performance stats, Err:%lld\\n\", rc);\n\t\treturn -EIO;\n\n\t} else if (!size) {\n\t\t/* Handle case where stat buffer size was requested */\n\t\tdev_dbg(&p->pdev->dev,\n\t\t\t\"Performance stats size %ld\\n\", ret[0]);\n\t\treturn ret[0];\n\t}\n\n\t/* Successfully fetched the requested stats from phyp */\n\tdev_dbg(&p->pdev->dev,\n\t\t\"Performance stats returned %d stats\\n\",\n\t\tbe32_to_cpu(buff_stats->num_statistics));\n\treturn 0;\n}",
        "result": 0
    },
    {
        "var_name": "mpic",
        "function_name": "_mpic_cpu_read",
        "location": {
            "file_path": "arch/powerpc/sysdev/mpic.c",
            "region": {
                "startLine": 257,
                "startColumn": 20,
                "endColumn": 24
            },
            "context": {
                "startLine": 255,
                "endLine": 259,
                "snippet": {
                    "text": "return _mpic_read(mpic->reg_type, &mpic->cpuregs[cpu], reg);"
                }
            }
        },
        "function_code": "static inline u32 _mpic_cpu_read(struct mpic *mpic, unsigned int reg)\n{\n\tunsigned int cpu = mpic_processor_id(mpic);\n\n\treturn _mpic_read(mpic->reg_type, &mpic->cpuregs[cpu], reg);\n}",
        "result": -1
    },
    {
        "var_name": "mpic",
        "function_name": "mpic_get_coreint_irq",
        "location": {
            "file_path": "arch/powerpc/sysdev/mpic.c",
            "region": {
                "startLine": 1815,
                "startColumn": 22,
                "endColumn": 26
            },
            "context": {
                "startLine": 1813,
                "endLine": 1817,
                "snippet": {
                    "text": "if (unlikely(src == mpic->spurious_vec)) {"
                }
            }
        },
        "function_code": "unsigned int mpic_get_coreint_irq(void)\n{\n#ifdef CONFIG_BOOKE\n\tstruct mpic *mpic = mpic_primary;\n\tu32 src;\n\n\tBUG_ON(mpic == NULL);\n\n\tsrc = mfspr(SPRN_EPR);\n\n\tif (unlikely(src == mpic->spurious_vec)) {\n\t\tif (mpic->flags & MPIC_SPV_EOI)\n\t\t\tmpic_eoi(mpic);\n\t\treturn 0;\n\t}\n\tif (unlikely(mpic->protected && test_bit(src, mpic->protected))) {\n\t\tprintk_ratelimited(KERN_WARNING \"%s: Got protected source %d !\\n\",\n\t\t\t\t   mpic->name, (int)src);\n\t\treturn 0;\n\t}\n\n\treturn irq_linear_revmap(mpic->irqhost, src);\n#else\n\treturn 0;\n#endif\n}",
        "result": 0
    },
    {
        "var_name": "mpic",
        "function_name": "mpic_get_mcirq",
        "location": {
            "file_path": "arch/powerpc/sysdev/mpic.c",
            "region": {
                "startLine": 1838,
                "startColumn": 33,
                "endColumn": 37
            },
            "context": {
                "startLine": 1836,
                "endLine": 1840,
                "snippet": {
                    "text": "return _mpic_get_one_irq(mpic, MPIC_INFO(CPU_MCACK));"
                }
            }
        },
        "function_code": "unsigned int mpic_get_mcirq(void)\n{\n\tstruct mpic *mpic = mpic_primary;\n\n\tBUG_ON(mpic == NULL);\n\n\treturn _mpic_get_one_irq(mpic, MPIC_INFO(CPU_MCACK));\n}",
        "result": 0
    },
    {
        "var_name": "tsk",
        "function_name": "show_task",
        "location": {
            "file_path": "arch/powerpc/xmon/xmon.c",
            "region": {
                "startLine": 3279,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 3277,
                "endLine": 3281,
                "snippet": {
                    "text": "tsk->thread.ksp, tsk->thread.regs,"
                }
            }
        },
        "function_code": "static void show_task(struct task_struct *volatile tsk)\n{\n\tunsigned int p_state = READ_ONCE(tsk->__state);\n\tchar state;\n\n\t/*\n\t * Cloned from kdb_task_state_char(), which is not entirely\n\t * appropriate for calling from xmon. This could be moved\n\t * to a common, generic, routine used by both.\n\t */\n\tstate = (p_state == TASK_RUNNING) ? 'R' :\n\t\t(p_state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p_state & TASK_STOPPED) ? 'T' :\n\t\t(p_state & TASK_TRACED) ? 'C' :\n\t\t(tsk->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(tsk->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p_state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\n\tprintf(\"%16px %16lx %16px %6d %6d %c %2d %s\\n\", tsk,\n\t\ttsk->thread.ksp, tsk->thread.regs,\n\t\ttsk->pid, rcu_dereference(tsk->parent)->pid,\n\t\tstate, task_cpu(tsk),\n\t\ttsk->comm);\n}",
        "result": 0
    },
    {
        "var_name": "tsk",
        "function_name": "show_task",
        "location": {
            "file_path": "arch/powerpc/xmon/xmon.c",
            "region": {
                "startLine": 3280,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 3278,
                "endLine": 3282,
                "snippet": {
                    "text": "tsk->pid, rcu_dereference(tsk->parent)->pid,"
                }
            }
        },
        "function_code": "static void show_task(struct task_struct *volatile tsk)\n{\n\tunsigned int p_state = READ_ONCE(tsk->__state);\n\tchar state;\n\n\t/*\n\t * Cloned from kdb_task_state_char(), which is not entirely\n\t * appropriate for calling from xmon. This could be moved\n\t * to a common, generic, routine used by both.\n\t */\n\tstate = (p_state == TASK_RUNNING) ? 'R' :\n\t\t(p_state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p_state & TASK_STOPPED) ? 'T' :\n\t\t(p_state & TASK_TRACED) ? 'C' :\n\t\t(tsk->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(tsk->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p_state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\n\tprintf(\"%16px %16lx %16px %6d %6d %c %2d %s\\n\", tsk,\n\t\ttsk->thread.ksp, tsk->thread.regs,\n\t\ttsk->pid, rcu_dereference(tsk->parent)->pid,\n\t\tstate, task_cpu(tsk),\n\t\ttsk->comm);\n}",
        "result": 0
    },
    {
        "var_name": "tsk",
        "function_name": "show_task",
        "location": {
            "file_path": "arch/powerpc/xmon/xmon.c",
            "region": {
                "startLine": 3282,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 3280,
                "endLine": 3284,
                "snippet": {
                    "text": "tsk->comm);"
                }
            }
        },
        "function_code": "static void show_task(struct task_struct *volatile tsk)\n{\n\tunsigned int p_state = READ_ONCE(tsk->__state);\n\tchar state;\n\n\t/*\n\t * Cloned from kdb_task_state_char(), which is not entirely\n\t * appropriate for calling from xmon. This could be moved\n\t * to a common, generic, routine used by both.\n\t */\n\tstate = (p_state == TASK_RUNNING) ? 'R' :\n\t\t(p_state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p_state & TASK_STOPPED) ? 'T' :\n\t\t(p_state & TASK_TRACED) ? 'C' :\n\t\t(tsk->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(tsk->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p_state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\n\tprintf(\"%16px %16lx %16px %6d %6d %c %2d %s\\n\", tsk,\n\t\ttsk->thread.ksp, tsk->thread.regs,\n\t\ttsk->pid, rcu_dereference(tsk->parent)->pid,\n\t\tstate, task_cpu(tsk),\n\t\ttsk->comm);\n}",
        "result": 0
    },
    {
        "var_name": "cie_tmp",
        "function_name": "dwarf_lookup_cie",
        "location": {
            "file_path": "arch/sh/kernel/dwarf.c",
            "region": {
                "startLine": 326,
                "startColumn": 18,
                "endColumn": 25
            },
            "context": {
                "startLine": 324,
                "endLine": 328,
                "snippet": {
                    "text": "if (cie_ptr == cie_tmp->cie_pointer) {"
                }
            }
        },
        "function_code": "static struct dwarf_cie *dwarf_lookup_cie(unsigned long cie_ptr)\n{\n\tstruct rb_node **rb_node = &cie_root.rb_node;\n\tstruct dwarf_cie *cie = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dwarf_cie_lock, flags);\n\n\t/*\n\t * We've cached the last CIE we looked up because chances are\n\t * that the FDE wants this CIE.\n\t */\n\tif (cached_cie && cached_cie->cie_pointer == cie_ptr) {\n\t\tcie = cached_cie;\n\t\tgoto out;\n\t}\n\n\twhile (*rb_node) {\n\t\tstruct dwarf_cie *cie_tmp;\n\n\t\tcie_tmp = rb_entry(*rb_node, struct dwarf_cie, node);\n\t\tBUG_ON(!cie_tmp);\n\n\t\tif (cie_ptr == cie_tmp->cie_pointer) {\n\t\t\tcie = cie_tmp;\n\t\t\tcached_cie = cie_tmp;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (cie_ptr < cie_tmp->cie_pointer)\n\t\t\t\trb_node = &(*rb_node)->rb_left;\n\t\t\telse\n\t\t\t\trb_node = &(*rb_node)->rb_right;\n\t\t}\n\t}\n\nout:\n\tspin_unlock_irqrestore(&dwarf_cie_lock, flags);\n\treturn cie;\n}",
        "result": 0
    },
    {
        "var_name": "fde_tmp",
        "function_name": "dwarf_lookup_fde",
        "location": {
            "file_path": "arch/sh/kernel/dwarf.c",
            "region": {
                "startLine": 362,
                "startColumn": 15,
                "endColumn": 22
            },
            "context": {
                "startLine": 360,
                "endLine": 364,
                "snippet": {
                    "text": "tmp_start = fde_tmp->initial_location;"
                }
            }
        },
        "function_code": "struct dwarf_fde *dwarf_lookup_fde(unsigned long pc)\n{\n\tstruct rb_node **rb_node = &fde_root.rb_node;\n\tstruct dwarf_fde *fde = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dwarf_fde_lock, flags);\n\n\twhile (*rb_node) {\n\t\tstruct dwarf_fde *fde_tmp;\n\t\tunsigned long tmp_start, tmp_end;\n\n\t\tfde_tmp = rb_entry(*rb_node, struct dwarf_fde, node);\n\t\tBUG_ON(!fde_tmp);\n\n\t\ttmp_start = fde_tmp->initial_location;\n\t\ttmp_end = fde_tmp->initial_location + fde_tmp->address_range;\n\n\t\tif (pc < tmp_start) {\n\t\t\trb_node = &(*rb_node)->rb_left;\n\t\t} else {\n\t\t\tif (pc < tmp_end) {\n\t\t\t\tfde = fde_tmp;\n\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\trb_node = &(*rb_node)->rb_right;\n\t\t}\n\t}\n\nout:\n\tspin_unlock_irqrestore(&dwarf_fde_lock, flags);\n\n\treturn fde;\n}",
        "result": 0
    },
    {
        "var_name": "fde_tmp",
        "function_name": "dwarf_lookup_fde",
        "location": {
            "file_path": "arch/sh/kernel/dwarf.c",
            "region": {
                "startLine": 363,
                "startColumn": 13,
                "endColumn": 20
            },
            "context": {
                "startLine": 361,
                "endLine": 365,
                "snippet": {
                    "text": "tmp_end = fde_tmp->initial_location + fde_tmp->address_range;"
                }
            }
        },
        "function_code": "struct dwarf_fde *dwarf_lookup_fde(unsigned long pc)\n{\n\tstruct rb_node **rb_node = &fde_root.rb_node;\n\tstruct dwarf_fde *fde = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dwarf_fde_lock, flags);\n\n\twhile (*rb_node) {\n\t\tstruct dwarf_fde *fde_tmp;\n\t\tunsigned long tmp_start, tmp_end;\n\n\t\tfde_tmp = rb_entry(*rb_node, struct dwarf_fde, node);\n\t\tBUG_ON(!fde_tmp);\n\n\t\ttmp_start = fde_tmp->initial_location;\n\t\ttmp_end = fde_tmp->initial_location + fde_tmp->address_range;\n\n\t\tif (pc < tmp_start) {\n\t\t\trb_node = &(*rb_node)->rb_left;\n\t\t} else {\n\t\t\tif (pc < tmp_end) {\n\t\t\t\tfde = fde_tmp;\n\t\t\t\tgoto out;\n\t\t\t} else\n\t\t\t\trb_node = &(*rb_node)->rb_right;\n\t\t}\n\t}\n\nout:\n\tspin_unlock_irqrestore(&dwarf_fde_lock, flags);\n\n\treturn fde;\n}",
        "result": 0
    },
    {
        "var_name": "reg",
        "function_name": "dwarf_unwind_stack",
        "location": {
            "file_path": "arch/sh/kernel/dwarf.c",
            "region": {
                "startLine": 673,
                "startColumn": 20,
                "endColumn": 23
            },
            "context": {
                "startLine": 671,
                "endLine": 675,
                "snippet": {
                    "text": "UNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);"
                }
            }
        },
        "function_code": "struct dwarf_frame *dwarf_unwind_stack(unsigned long pc,\n\t\t\t\t       struct dwarf_frame *prev)\n{\n\tstruct dwarf_frame *frame;\n\tstruct dwarf_cie *cie;\n\tstruct dwarf_fde *fde;\n\tstruct dwarf_reg *reg;\n\tunsigned long addr;\n\n\t/*\n\t * If we've been called in to before initialization has\n\t * completed, bail out immediately.\n\t */\n\tif (!dwarf_unwinder_ready)\n\t\treturn NULL;\n\n\t/*\n\t * If we're starting at the top of the stack we need get the\n\t * contents of a physical register to get the CFA in order to\n\t * begin the virtual unwinding of the stack.\n\t *\n\t * NOTE: the return address is guaranteed to be setup by the\n\t * time this function makes its first function call.\n\t */\n\tif (!pc || !prev)\n\t\tpc = _THIS_IP_;\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\t/*\n\t * If our stack has been patched by the function graph tracer\n\t * then we might see the address of return_to_handler() where we\n\t * expected to find the real return address.\n\t */\n\tif (pc == (unsigned long)&return_to_handler) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = ftrace_graph_get_ret_stack(current, 0);\n\t\tif (ret_stack)\n\t\t\tpc = ret_stack->ret;\n\t\t/*\n\t\t * We currently have no way of tracking how many\n\t\t * return_to_handler()'s we've seen. If there is more\n\t\t * than one patched return address on our stack,\n\t\t * complain loudly.\n\t\t */\n\t\tWARN_ON(ftrace_graph_get_ret_stack(current, 1));\n\t}\n#endif\n\n\tframe = mempool_alloc(dwarf_frame_pool, GFP_ATOMIC);\n\tif (!frame) {\n\t\tprintk(KERN_ERR \"Unable to allocate a dwarf frame\\n\");\n\t\tUNWINDER_BUG();\n\t}\n\n\tINIT_LIST_HEAD(&frame->reg_list);\n\tframe->flags = 0;\n\tframe->prev = prev;\n\tframe->return_addr = 0;\n\n\tfde = dwarf_lookup_fde(pc);\n\tif (!fde) {\n\t\t/*\n\t\t * This is our normal exit path. There are two reasons\n\t\t * why we might exit here,\n\t\t *\n\t\t *\ta) pc has no asscociated DWARF frame info and so\n\t\t *\twe don't know how to unwind this frame. This is\n\t\t *\tusually the case when we're trying to unwind a\n\t\t *\tframe that was called from some assembly code\n\t\t *\tthat has no DWARF info, e.g. syscalls.\n\t\t *\n\t\t *\tb) the DEBUG info for pc is bogus. There's\n\t\t *\treally no way to distinguish this case from the\n\t\t *\tcase above, which sucks because we could print a\n\t\t *\twarning here.\n\t\t */\n\t\tgoto bail;\n\t}\n\n\tcie = dwarf_lookup_cie(fde->cie_pointer);\n\n\tframe->pc = fde->initial_location;\n\n\t/* CIE initial instructions */\n\tdwarf_cfa_execute_insns(cie->initial_instructions,\n\t\t\t\tcie->instructions_end, cie, fde,\n\t\t\t\tframe, pc);\n\n\t/* FDE instructions */\n\tdwarf_cfa_execute_insns(fde->instructions, fde->end, cie,\n\t\t\t\tfde, frame, pc);\n\n\t/* Calculate the CFA */\n\tswitch (frame->flags) {\n\tcase DWARF_FRAME_CFA_REG_OFFSET:\n\t\tif (prev) {\n\t\t\treg = dwarf_frame_reg(prev, frame->cfa_register);\n\t\t\tUNWINDER_BUG_ON(!reg);\n\t\t\tUNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);\n\n\t\t\taddr = prev->cfa + reg->addr;\n\t\t\tframe->cfa = __raw_readl(addr);\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * Again, we're starting from the top of the\n\t\t\t * stack. We need to physically read\n\t\t\t * the contents of a register in order to get\n\t\t\t * the Canonical Frame Address for this\n\t\t\t * function.\n\t\t\t */\n\t\t\tframe->cfa = dwarf_read_arch_reg(frame->cfa_register);\n\t\t}\n\n\t\tframe->cfa += frame->cfa_offset;\n\t\tbreak;\n\tdefault:\n\t\tUNWINDER_BUG();\n\t}\n\n\treg = dwarf_frame_reg(frame, DWARF_ARCH_RA_REG);\n\n\t/*\n\t * If we haven't seen the return address register or the return\n\t * address column is undefined then we must assume that this is\n\t * the end of the callstack.\n\t */\n\tif (!reg || reg->flags == DWARF_UNDEFINED)\n\t\tgoto bail;\n\n\tUNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);\n\n\taddr = frame->cfa + reg->addr;\n\tframe->return_addr = __raw_readl(addr);\n\n\t/*\n\t * Ah, the joys of unwinding through interrupts.\n\t *\n\t * Interrupts are tricky - the DWARF info needs to be _really_\n\t * accurate and unfortunately I'm seeing a lot of bogus DWARF\n\t * info. For example, I've seen interrupts occur in epilogues\n\t * just after the frame pointer (r14) had been restored. The\n\t * problem was that the DWARF info claimed that the CFA could be\n\t * reached by using the value of the frame pointer before it was\n\t * restored.\n\t *\n\t * So until the compiler can be trusted to produce reliable\n\t * DWARF info when it really matters, let's stop unwinding once\n\t * we've calculated the function that was interrupted.\n\t */\n\tif (prev && prev->pc == (unsigned long)ret_from_irq)\n\t\tframe->return_addr = 0;\n\n\treturn frame;\n\nbail:\n\tdwarf_free_frame(frame);\n\treturn NULL;\n}",
        "result": 0
    },
    {
        "var_name": "reg",
        "function_name": "dwarf_unwind_stack",
        "location": {
            "file_path": "arch/sh/kernel/dwarf.c",
            "region": {
                "startLine": 675,
                "startColumn": 23,
                "endColumn": 26
            },
            "context": {
                "startLine": 673,
                "endLine": 677,
                "snippet": {
                    "text": "addr = prev->cfa + reg->addr;"
                }
            }
        },
        "function_code": "struct dwarf_frame *dwarf_unwind_stack(unsigned long pc,\n\t\t\t\t       struct dwarf_frame *prev)\n{\n\tstruct dwarf_frame *frame;\n\tstruct dwarf_cie *cie;\n\tstruct dwarf_fde *fde;\n\tstruct dwarf_reg *reg;\n\tunsigned long addr;\n\n\t/*\n\t * If we've been called in to before initialization has\n\t * completed, bail out immediately.\n\t */\n\tif (!dwarf_unwinder_ready)\n\t\treturn NULL;\n\n\t/*\n\t * If we're starting at the top of the stack we need get the\n\t * contents of a physical register to get the CFA in order to\n\t * begin the virtual unwinding of the stack.\n\t *\n\t * NOTE: the return address is guaranteed to be setup by the\n\t * time this function makes its first function call.\n\t */\n\tif (!pc || !prev)\n\t\tpc = _THIS_IP_;\n\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\t/*\n\t * If our stack has been patched by the function graph tracer\n\t * then we might see the address of return_to_handler() where we\n\t * expected to find the real return address.\n\t */\n\tif (pc == (unsigned long)&return_to_handler) {\n\t\tstruct ftrace_ret_stack *ret_stack;\n\n\t\tret_stack = ftrace_graph_get_ret_stack(current, 0);\n\t\tif (ret_stack)\n\t\t\tpc = ret_stack->ret;\n\t\t/*\n\t\t * We currently have no way of tracking how many\n\t\t * return_to_handler()'s we've seen. If there is more\n\t\t * than one patched return address on our stack,\n\t\t * complain loudly.\n\t\t */\n\t\tWARN_ON(ftrace_graph_get_ret_stack(current, 1));\n\t}\n#endif\n\n\tframe = mempool_alloc(dwarf_frame_pool, GFP_ATOMIC);\n\tif (!frame) {\n\t\tprintk(KERN_ERR \"Unable to allocate a dwarf frame\\n\");\n\t\tUNWINDER_BUG();\n\t}\n\n\tINIT_LIST_HEAD(&frame->reg_list);\n\tframe->flags = 0;\n\tframe->prev = prev;\n\tframe->return_addr = 0;\n\n\tfde = dwarf_lookup_fde(pc);\n\tif (!fde) {\n\t\t/*\n\t\t * This is our normal exit path. There are two reasons\n\t\t * why we might exit here,\n\t\t *\n\t\t *\ta) pc has no asscociated DWARF frame info and so\n\t\t *\twe don't know how to unwind this frame. This is\n\t\t *\tusually the case when we're trying to unwind a\n\t\t *\tframe that was called from some assembly code\n\t\t *\tthat has no DWARF info, e.g. syscalls.\n\t\t *\n\t\t *\tb) the DEBUG info for pc is bogus. There's\n\t\t *\treally no way to distinguish this case from the\n\t\t *\tcase above, which sucks because we could print a\n\t\t *\twarning here.\n\t\t */\n\t\tgoto bail;\n\t}\n\n\tcie = dwarf_lookup_cie(fde->cie_pointer);\n\n\tframe->pc = fde->initial_location;\n\n\t/* CIE initial instructions */\n\tdwarf_cfa_execute_insns(cie->initial_instructions,\n\t\t\t\tcie->instructions_end, cie, fde,\n\t\t\t\tframe, pc);\n\n\t/* FDE instructions */\n\tdwarf_cfa_execute_insns(fde->instructions, fde->end, cie,\n\t\t\t\tfde, frame, pc);\n\n\t/* Calculate the CFA */\n\tswitch (frame->flags) {\n\tcase DWARF_FRAME_CFA_REG_OFFSET:\n\t\tif (prev) {\n\t\t\treg = dwarf_frame_reg(prev, frame->cfa_register);\n\t\t\tUNWINDER_BUG_ON(!reg);\n\t\t\tUNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);\n\n\t\t\taddr = prev->cfa + reg->addr;\n\t\t\tframe->cfa = __raw_readl(addr);\n\n\t\t} else {\n\t\t\t/*\n\t\t\t * Again, we're starting from the top of the\n\t\t\t * stack. We need to physically read\n\t\t\t * the contents of a register in order to get\n\t\t\t * the Canonical Frame Address for this\n\t\t\t * function.\n\t\t\t */\n\t\t\tframe->cfa = dwarf_read_arch_reg(frame->cfa_register);\n\t\t}\n\n\t\tframe->cfa += frame->cfa_offset;\n\t\tbreak;\n\tdefault:\n\t\tUNWINDER_BUG();\n\t}\n\n\treg = dwarf_frame_reg(frame, DWARF_ARCH_RA_REG);\n\n\t/*\n\t * If we haven't seen the return address register or the return\n\t * address column is undefined then we must assume that this is\n\t * the end of the callstack.\n\t */\n\tif (!reg || reg->flags == DWARF_UNDEFINED)\n\t\tgoto bail;\n\n\tUNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);\n\n\taddr = frame->cfa + reg->addr;\n\tframe->return_addr = __raw_readl(addr);\n\n\t/*\n\t * Ah, the joys of unwinding through interrupts.\n\t *\n\t * Interrupts are tricky - the DWARF info needs to be _really_\n\t * accurate and unfortunately I'm seeing a lot of bogus DWARF\n\t * info. For example, I've seen interrupts occur in epilogues\n\t * just after the frame pointer (r14) had been restored. The\n\t * problem was that the DWARF info claimed that the CFA could be\n\t * reached by using the value of the frame pointer before it was\n\t * restored.\n\t *\n\t * So until the compiler can be trusted to produce reliable\n\t * DWARF info when it really matters, let's stop unwinding once\n\t * we've calculated the function that was interrupted.\n\t */\n\tif (prev && prev->pc == (unsigned long)ret_from_irq)\n\t\tframe->return_addr = 0;\n\n\treturn frame;\n\nbail:\n\tdwarf_free_frame(frame);\n\treturn NULL;\n}",
        "result": 0
    },
    {
        "var_name": "tiop",
        "function_name": "lookup_address",
        "location": {
            "file_path": "arch/sh/kernel/io_trapped.c",
            "region": {
                "startLine": 169,
                "startColumn": 39,
                "endColumn": 43
            },
            "context": {
                "startLine": 167,
                "endLine": 171,
                "snippet": {
                    "text": "unsigned long vaddr = (unsigned long)tiop->virt_base;"
                }
            }
        },
        "function_code": "static unsigned long lookup_address(struct trapped_io *tiop,\n\t\t\t\t    unsigned long address)\n{\n\tstruct resource *res;\n\tunsigned long vaddr = (unsigned long)tiop->virt_base;\n\tunsigned long len;\n\tint k;\n\n\tfor (k = 0; k < tiop->num_resources; k++) {\n\t\tres = tiop->resource + k;\n\t\tlen = roundup(resource_size(res), PAGE_SIZE);\n\t\tif (address < (vaddr + len))\n\t\t\treturn res->start + (address - vaddr);\n\t\tvaddr += len;\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "tiop",
        "function_name": "from_device",
        "location": {
            "file_path": "arch/sh/kernel/io_trapped.c",
            "region": {
                "startLine": 237,
                "startColumn": 11,
                "endColumn": 15
            },
            "context": {
                "startLine": 235,
                "endLine": 239,
                "snippet": {
                    "text": "(tiop->minimum_bus_width / 8)),"
                }
            }
        },
        "function_code": "static unsigned long from_device(void *dst, const void *src, unsigned long cnt)\n{\n\tstruct trapped_io *tiop;\n\tunsigned long src_addr = (unsigned long)src;\n\tunsigned long long tmp;\n\n\tpr_debug(\"trapped io read 0x%08lx (%ld)\\n\", src_addr, cnt);\n\ttiop = lookup_tiop(src_addr);\n\tWARN_ON(!tiop || (tiop->magic != IO_TRAPPED_MAGIC));\n\n\tsrc_addr = lookup_address(tiop, src_addr);\n\tif (!src_addr)\n\t\treturn cnt;\n\n\ttmp = copy_word(src_addr,\n\t\t\tmax_t(unsigned long, cnt,\n\t\t\t      (tiop->minimum_bus_width / 8)),\n\t\t\t(unsigned long)dst, cnt);\n\n\tpr_debug(\"trapped io read 0x%08lx -> 0x%08llx\\n\", src_addr, tmp);\n\treturn 0;\n}"
    },
    {
        "var_name": "tiop",
        "function_name": "to_device",
        "location": {
            "file_path": "arch/sh/kernel/io_trapped.c",
            "region": {
                "startLine": 260,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 258,
                "endLine": 262,
                "snippet": {
                    "text": "(tiop->minimum_bus_width / 8)));"
                }
            }
        },
        "function_code": "static unsigned long to_device(void *dst, const void *src, unsigned long cnt)\n{\n\tstruct trapped_io *tiop;\n\tunsigned long dst_addr = (unsigned long)dst;\n\tunsigned long long tmp;\n\n\tpr_debug(\"trapped io write 0x%08lx (%ld)\\n\", dst_addr, cnt);\n\ttiop = lookup_tiop(dst_addr);\n\tWARN_ON(!tiop || (tiop->magic != IO_TRAPPED_MAGIC));\n\n\tdst_addr = lookup_address(tiop, dst_addr);\n\tif (!dst_addr)\n\t\treturn cnt;\n\n\ttmp = copy_word((unsigned long)src, cnt,\n\t\t\tdst_addr, max_t(unsigned long, cnt,\n\t\t\t\t\t(tiop->minimum_bus_width / 8)));\n\n\tpr_debug(\"trapped io write 0x%08lx -> 0x%08llx\\n\", dst_addr, tmp);\n\treturn 0;\n}"
    },
    {
        "var_name": "p4d",
        "function_name": "__get_pte_phys",
        "location": {
            "file_path": "arch/sh/mm/init.c",
            "region": {
                "startLine": 62,
                "startColumn": 14,
                "endColumn": 17
            },
            "context": {
                "startLine": 60,
                "endLine": 64,
                "snippet": {
                    "text": "p4d_ERROR(*p4d);"
                }
            }
        },
        "function_code": "static pte_t *__get_pte_phys(unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset_k(addr);\n\tif (pgd_none(*pgd)) {\n\t\tpgd_ERROR(*pgd);\n\t\treturn NULL;\n\t}\n\n\tp4d = p4d_alloc(NULL, pgd, addr);\n\tif (unlikely(!p4d)) {\n\t\tp4d_ERROR(*p4d);\n\t\treturn NULL;\n\t}\n\n\tpud = pud_alloc(NULL, p4d, addr);\n\tif (unlikely(!pud)) {\n\t\tpud_ERROR(*pud);\n\t\treturn NULL;\n\t}\n\n\tpmd = pmd_alloc(NULL, pud, addr);\n\tif (unlikely(!pmd)) {\n\t\tpmd_ERROR(*pmd);\n\t\treturn NULL;\n\t}\n\n\treturn pte_offset_kernel(pmd, addr);\n}"
    },
    {
        "var_name": "pud",
        "function_name": "__get_pte_phys",
        "location": {
            "file_path": "arch/sh/mm/init.c",
            "region": {
                "startLine": 68,
                "startColumn": 14,
                "endColumn": 17
            },
            "context": {
                "startLine": 66,
                "endLine": 70,
                "snippet": {
                    "text": "pud_ERROR(*pud);"
                }
            }
        },
        "function_code": "static pte_t *__get_pte_phys(unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset_k(addr);\n\tif (pgd_none(*pgd)) {\n\t\tpgd_ERROR(*pgd);\n\t\treturn NULL;\n\t}\n\n\tp4d = p4d_alloc(NULL, pgd, addr);\n\tif (unlikely(!p4d)) {\n\t\tp4d_ERROR(*p4d);\n\t\treturn NULL;\n\t}\n\n\tpud = pud_alloc(NULL, p4d, addr);\n\tif (unlikely(!pud)) {\n\t\tpud_ERROR(*pud);\n\t\treturn NULL;\n\t}\n\n\tpmd = pmd_alloc(NULL, pud, addr);\n\tif (unlikely(!pmd)) {\n\t\tpmd_ERROR(*pmd);\n\t\treturn NULL;\n\t}\n\n\treturn pte_offset_kernel(pmd, addr);\n}"
    },
    {
        "var_name": "pmd",
        "function_name": "__get_pte_phys",
        "location": {
            "file_path": "arch/sh/mm/init.c",
            "region": {
                "startLine": 74,
                "startColumn": 14,
                "endColumn": 17
            },
            "context": {
                "startLine": 72,
                "endLine": 76,
                "snippet": {
                    "text": "pmd_ERROR(*pmd);"
                }
            }
        },
        "function_code": "static pte_t *__get_pte_phys(unsigned long addr)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\n\tpgd = pgd_offset_k(addr);\n\tif (pgd_none(*pgd)) {\n\t\tpgd_ERROR(*pgd);\n\t\treturn NULL;\n\t}\n\n\tp4d = p4d_alloc(NULL, pgd, addr);\n\tif (unlikely(!p4d)) {\n\t\tp4d_ERROR(*p4d);\n\t\treturn NULL;\n\t}\n\n\tpud = pud_alloc(NULL, p4d, addr);\n\tif (unlikely(!pud)) {\n\t\tpud_ERROR(*pud);\n\t\treturn NULL;\n\t}\n\n\tpmd = pmd_alloc(NULL, pud, addr);\n\tif (unlikely(!pmd)) {\n\t\tpmd_ERROR(*pmd);\n\t\treturn NULL;\n\t}\n\n\treturn pte_offset_kernel(pmd, addr);\n}"
    },
    {
        "var_name": "handler_data",
        "function_name": "build_irq",
        "location": {
            "file_path": "arch/sparc/kernel/irq_64.c",
            "region": {
                "startLine": 643,
                "startColumn": 2,
                "endColumn": 14
            },
            "context": {
                "startLine": 641,
                "endLine": 645,
                "snippet": {
                    "text": "handler_data->imap  = imap;"
                }
            }
        },
        "function_code": "unsigned int build_irq(int inofixup, unsigned long iclr, unsigned long imap)\n{\n\tstruct irq_handler_data *handler_data;\n\tstruct ino_bucket *bucket;\n\tunsigned int irq;\n\tint ino;\n\n\tBUG_ON(tlb_type == hypervisor);\n\n\tino = (upa_readq(imap) & (IMAP_IGN | IMAP_INO)) + inofixup;\n\tbucket = &ivector_table[ino];\n\tirq = bucket_get_irq(__pa(bucket));\n\tif (!irq) {\n\t\tirq = irq_alloc(0, ino);\n\t\tbucket_set_irq(__pa(bucket), irq);\n\t\tirq_set_chip_and_handler_name(irq, &sun4u_irq,\n\t\t\t\t\t      handle_fasteoi_irq, \"IVEC\");\n\t}\n\n\thandler_data = irq_get_handler_data(irq);\n\tif (unlikely(handler_data))\n\t\tgoto out;\n\n\thandler_data = kzalloc(sizeof(struct irq_handler_data), GFP_ATOMIC);\n\tif (unlikely(!handler_data)) {\n\t\tprom_printf(\"IRQ: kzalloc(irq_handler_data) failed.\\n\");\n\t\tprom_halt();\n\t}\n\tirq_set_handler_data(irq, handler_data);\n\n\thandler_data->imap  = imap;\n\thandler_data->iclr  = iclr;\n\nout:\n\treturn irq;\n}"
    },
    {
        "var_name": "handler_data",
        "function_name": "build_irq",
        "location": {
            "file_path": "arch/sparc/kernel/irq_64.c",
            "region": {
                "startLine": 644,
                "startColumn": 2,
                "endColumn": 14
            },
            "context": {
                "startLine": 642,
                "endLine": 646,
                "snippet": {
                    "text": "handler_data->iclr  = iclr;"
                }
            }
        },
        "function_code": "unsigned int build_irq(int inofixup, unsigned long iclr, unsigned long imap)\n{\n\tstruct irq_handler_data *handler_data;\n\tstruct ino_bucket *bucket;\n\tunsigned int irq;\n\tint ino;\n\n\tBUG_ON(tlb_type == hypervisor);\n\n\tino = (upa_readq(imap) & (IMAP_IGN | IMAP_INO)) + inofixup;\n\tbucket = &ivector_table[ino];\n\tirq = bucket_get_irq(__pa(bucket));\n\tif (!irq) {\n\t\tirq = irq_alloc(0, ino);\n\t\tbucket_set_irq(__pa(bucket), irq);\n\t\tirq_set_chip_and_handler_name(irq, &sun4u_irq,\n\t\t\t\t\t      handle_fasteoi_irq, \"IVEC\");\n\t}\n\n\thandler_data = irq_get_handler_data(irq);\n\tif (unlikely(handler_data))\n\t\tgoto out;\n\n\thandler_data = kzalloc(sizeof(struct irq_handler_data), GFP_ATOMIC);\n\tif (unlikely(!handler_data)) {\n\t\tprom_printf(\"IRQ: kzalloc(irq_handler_data) failed.\\n\");\n\t\tprom_halt();\n\t}\n\tirq_set_handler_data(irq, handler_data);\n\n\thandler_data->imap  = imap;\n\thandler_data->iclr  = iclr;\n\nout:\n\treturn irq;\n}"
    },
    {
        "var_name": "handler_data",
        "function_name": "_sun4d_build_device_irq",
        "location": {
            "file_path": "arch/sparc/kernel/sun4d_irq.c",
            "region": {
                "startLine": 312,
                "startColumn": 2,
                "endColumn": 14
            },
            "context": {
                "startLine": 310,
                "endLine": 314,
                "snippet": {
                    "text": "handler_data->cpuid    = board_to_cpu[board];"
                }
            }
        },
        "function_code": "static unsigned int _sun4d_build_device_irq(unsigned int real_irq,\n                                            unsigned int pil,\n                                            unsigned int board)\n{\n\tstruct sun4d_handler_data *handler_data;\n\tunsigned int irq;\n\n\tirq = irq_alloc(real_irq, pil);\n\tif (irq == 0) {\n\t\tprom_printf(\"IRQ: allocate for %d %d %d failed\\n\",\n\t\t\treal_irq, pil, board);\n\t\tgoto err_out;\n\t}\n\n\thandler_data = irq_get_handler_data(irq);\n\tif (unlikely(handler_data))\n\t\tgoto err_out;\n\n\thandler_data = kzalloc(sizeof(struct sun4d_handler_data), GFP_ATOMIC);\n\tif (unlikely(!handler_data)) {\n\t\tprom_printf(\"IRQ: kzalloc(sun4d_handler_data) failed.\\n\");\n\t\tprom_halt();\n\t}\n\thandler_data->cpuid    = board_to_cpu[board];\n\thandler_data->real_irq = real_irq;\n\tirq_set_chip_and_handler_name(irq, &sun4d_irq,\n\t                              handle_level_irq, \"level\");\n\tirq_set_handler_data(irq, handler_data);\n\nerr_out:\n\treturn irq;\n}"
    },
    {
        "var_name": "handler_data",
        "function_name": "_sun4d_build_device_irq",
        "location": {
            "file_path": "arch/sparc/kernel/sun4d_irq.c",
            "region": {
                "startLine": 313,
                "startColumn": 2,
                "endColumn": 14
            },
            "context": {
                "startLine": 311,
                "endLine": 315,
                "snippet": {
                    "text": "handler_data->real_irq = real_irq;"
                }
            }
        },
        "function_code": "static unsigned int _sun4d_build_device_irq(unsigned int real_irq,\n                                            unsigned int pil,\n                                            unsigned int board)\n{\n\tstruct sun4d_handler_data *handler_data;\n\tunsigned int irq;\n\n\tirq = irq_alloc(real_irq, pil);\n\tif (irq == 0) {\n\t\tprom_printf(\"IRQ: allocate for %d %d %d failed\\n\",\n\t\t\treal_irq, pil, board);\n\t\tgoto err_out;\n\t}\n\n\thandler_data = irq_get_handler_data(irq);\n\tif (unlikely(handler_data))\n\t\tgoto err_out;\n\n\thandler_data = kzalloc(sizeof(struct sun4d_handler_data), GFP_ATOMIC);\n\tif (unlikely(!handler_data)) {\n\t\tprom_printf(\"IRQ: kzalloc(sun4d_handler_data) failed.\\n\");\n\t\tprom_halt();\n\t}\n\thandler_data->cpuid    = board_to_cpu[board];\n\thandler_data->real_irq = real_irq;\n\tirq_set_chip_and_handler_name(irq, &sun4d_irq,\n\t                              handle_level_irq, \"level\");\n\tirq_set_handler_data(irq, handler_data);\n\nerr_out:\n\treturn irq;\n}"
    },
    {
        "var_name": "handler_data",
        "function_name": "sun4m_build_device_irq",
        "location": {
            "file_path": "arch/sparc/kernel/sun4m_irq.c",
            "region": {
                "startLine": 277,
                "startColumn": 2,
                "endColumn": 14
            },
            "context": {
                "startLine": 275,
                "endLine": 279,
                "snippet": {
                    "text": "handler_data->mask = sun4m_imask[real_irq];"
                }
            }
        },
        "function_code": "static unsigned int sun4m_build_device_irq(struct platform_device *op,\n\t\t\t\t\t   unsigned int real_irq)\n{\n\tstruct sun4m_handler_data *handler_data;\n\tunsigned int irq;\n\tunsigned int pil;\n\n\tif (real_irq >= OBP_INT_LEVEL_VME) {\n\t\tprom_printf(\"Bogus sun4m IRQ %u\\n\", real_irq);\n\t\tprom_halt();\n\t}\n\tpil = (real_irq & 0xf);\n\tirq = irq_alloc(real_irq, pil);\n\n\tif (irq == 0)\n\t\tgoto out;\n\n\thandler_data = irq_get_handler_data(irq);\n\tif (unlikely(handler_data))\n\t\tgoto out;\n\n\thandler_data = kzalloc(sizeof(struct sun4m_handler_data), GFP_ATOMIC);\n\tif (unlikely(!handler_data)) {\n\t\tprom_printf(\"IRQ: kzalloc(sun4m_handler_data) failed.\\n\");\n\t\tprom_halt();\n\t}\n\n\thandler_data->mask = sun4m_imask[real_irq];\n\thandler_data->percpu = real_irq < OBP_INT_LEVEL_ONBOARD;\n\tirq_set_chip_and_handler_name(irq, &sun4m_irq,\n\t                              handle_level_irq, \"level\");\n\tirq_set_handler_data(irq, handler_data);\n\nout:\n\treturn irq;\n}"
    },
    {
        "var_name": "handler_data",
        "function_name": "sun4m_build_device_irq",
        "location": {
            "file_path": "arch/sparc/kernel/sun4m_irq.c",
            "region": {
                "startLine": 278,
                "startColumn": 2,
                "endColumn": 14
            },
            "context": {
                "startLine": 276,
                "endLine": 280,
                "snippet": {
                    "text": "handler_data->percpu = real_irq < OBP_INT_LEVEL_ONBOARD;"
                }
            }
        },
        "function_code": "static unsigned int sun4m_build_device_irq(struct platform_device *op,\n\t\t\t\t\t   unsigned int real_irq)\n{\n\tstruct sun4m_handler_data *handler_data;\n\tunsigned int irq;\n\tunsigned int pil;\n\n\tif (real_irq >= OBP_INT_LEVEL_VME) {\n\t\tprom_printf(\"Bogus sun4m IRQ %u\\n\", real_irq);\n\t\tprom_halt();\n\t}\n\tpil = (real_irq & 0xf);\n\tirq = irq_alloc(real_irq, pil);\n\n\tif (irq == 0)\n\t\tgoto out;\n\n\thandler_data = irq_get_handler_data(irq);\n\tif (unlikely(handler_data))\n\t\tgoto out;\n\n\thandler_data = kzalloc(sizeof(struct sun4m_handler_data), GFP_ATOMIC);\n\tif (unlikely(!handler_data)) {\n\t\tprom_printf(\"IRQ: kzalloc(sun4m_handler_data) failed.\\n\");\n\t\tprom_halt();\n\t}\n\n\thandler_data->mask = sun4m_imask[real_irq];\n\thandler_data->percpu = real_irq < OBP_INT_LEVEL_ONBOARD;\n\tirq_set_chip_and_handler_name(irq, &sun4m_irq,\n\t                              handle_level_irq, \"level\");\n\tirq_set_handler_data(irq, handler_data);\n\nout:\n\treturn irq;\n}"
    },
    {
        "var_name": "qi",
        "function_name": "destroy_queue",
        "location": {
            "file_path": "arch/um/drivers/vector_kern.c",
            "region": {
                "startLine": 484,
                "startColumn": 42,
                "endColumn": 44
            },
            "context": {
                "startLine": 482,
                "endLine": 486,
                "snippet": {
                    "text": "struct vector_private *vp = netdev_priv(qi->dev);"
                }
            }
        },
        "function_code": "static void destroy_queue(struct vector_queue *qi)\n{\n\tint i;\n\tstruct iovec *iov;\n\tstruct vector_private *vp = netdev_priv(qi->dev);\n\tstruct mmsghdr *mmsg_vector;\n\n\tif (qi == NULL)\n\t\treturn;\n\t/* deallocate any skbuffs - we rely on any unused to be\n\t * set to NULL.\n\t */\n\tif (qi->skbuff_vector != NULL) {\n\t\tfor (i = 0; i < qi->max_depth; i++) {\n\t\t\tif (*(qi->skbuff_vector + i) != NULL)\n\t\t\t\tdev_kfree_skb_any(*(qi->skbuff_vector + i));\n\t\t}\n\t\tkfree(qi->skbuff_vector);\n\t}\n\t/* deallocate matching IOV structures including header buffs */\n\tif (qi->mmsg_vector != NULL) {\n\t\tmmsg_vector = qi->mmsg_vector;\n\t\tfor (i = 0; i < qi->max_depth; i++) {\n\t\t\tiov = mmsg_vector->msg_hdr.msg_iov;\n\t\t\tif (iov != NULL) {\n\t\t\t\tif ((vp->header_size > 0) &&\n\t\t\t\t\t(iov->iov_base != NULL))\n\t\t\t\t\tkfree(iov->iov_base);\n\t\t\t\tkfree(iov);\n\t\t\t}\n\t\t\tmmsg_vector++;\n\t\t}\n\t\tkfree(qi->mmsg_vector);\n\t}\n\tkfree(qi);\n}"
    },
    {
        "var_name": "gairesult",
        "function_name": "user_init_socket_fds",
        "location": {
            "file_path": "arch/um/drivers/vector_user.c",
            "region": {
                "startLine": 596,
                "startColumn": 23,
                "endColumn": 32
            },
            "context": {
                "startLine": 594,
                "endLine": 598,
                "snippet": {
                    "text": "(struct sockaddr *) gairesult->ai_addr,"
                }
            }
        },
        "function_code": "static struct vector_fds *user_init_socket_fds(struct arglist *ifspec, int id)\n{\n\tint err = -ENOMEM;\n\tint fd = -1, gairet;\n\tstruct addrinfo srchints;\n\tstruct addrinfo dsthints;\n\tbool v6, udp;\n\tchar *value;\n\tchar *src, *dst, *srcport, *dstport;\n\tstruct addrinfo *gairesult = NULL;\n\tstruct vector_fds *result = NULL;\n\n\n\tvalue = uml_vector_fetch_arg(ifspec, \"v6\");\n\tv6 = false;\n\tudp = false;\n\tif (value != NULL) {\n\t\tif (strtol((const char *) value, NULL, 10) > 0)\n\t\t\tv6 = true;\n\t}\n\n\tvalue = uml_vector_fetch_arg(ifspec, \"udp\");\n\tif (value != NULL) {\n\t\tif (strtol((const char *) value, NULL, 10) > 0)\n\t\t\tudp = true;\n\t}\n\tsrc = uml_vector_fetch_arg(ifspec, \"src\");\n\tdst = uml_vector_fetch_arg(ifspec, \"dst\");\n\tsrcport = uml_vector_fetch_arg(ifspec, \"srcport\");\n\tdstport = uml_vector_fetch_arg(ifspec, \"dstport\");\n\n\tmemset(&dsthints, 0, sizeof(dsthints));\n\n\tif (v6)\n\t\tdsthints.ai_family = AF_INET6;\n\telse\n\t\tdsthints.ai_family = AF_INET;\n\n\tswitch (id) {\n\tcase ID_GRE:\n\t\tdsthints.ai_socktype = SOCK_RAW;\n\t\tdsthints.ai_protocol = IPPROTO_GRE;\n\t\tbreak;\n\tcase ID_L2TPV3:\n\t\tif (udp) {\n\t\t\tdsthints.ai_socktype = SOCK_DGRAM;\n\t\t\tdsthints.ai_protocol = 0;\n\t\t} else {\n\t\t\tdsthints.ai_socktype = SOCK_RAW;\n\t\t\tdsthints.ai_protocol = IPPROTO_L2TP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Unsupported socket type\\n\");\n\t\treturn NULL;\n\t}\n\tmemcpy(&srchints, &dsthints, sizeof(struct addrinfo));\n\n\tgairet = getaddrinfo(src, srcport, &dsthints, &gairesult);\n\tif ((gairet != 0) || (gairesult == NULL)) {\n\t\tprintk(UM_KERN_ERR\n\t\t\t\"socket_open : could not resolve src, error = %s\",\n\t\t\tgai_strerror(gairet)\n\t\t);\n\t\treturn NULL;\n\t}\n\tfd = socket(gairesult->ai_family,\n\t\tgairesult->ai_socktype, gairesult->ai_protocol);\n\tif (fd == -1) {\n\t\tprintk(UM_KERN_ERR\n\t\t\t\"socket_open : could not open socket, error = %d\",\n\t\t\t-errno\n\t\t);\n\t\tgoto cleanup;\n\t}\n\tif (bind(fd,\n\t\t(struct sockaddr *) gairesult->ai_addr,\n\t\tgairesult->ai_addrlen)) {\n\t\tprintk(UM_KERN_ERR L2TPV3_BIND_FAIL, errno);\n\t\tgoto cleanup;\n\t}\n\n\tif (gairesult != NULL)\n\t\tfreeaddrinfo(gairesult);\n\n\tgairesult = NULL;\n\n\tgairet = getaddrinfo(dst, dstport, &dsthints, &gairesult);\n\tif ((gairet != 0) || (gairesult == NULL)) {\n\t\tprintk(UM_KERN_ERR\n\t\t\t\"socket_open : could not resolve dst, error = %s\",\n\t\t\tgai_strerror(gairet)\n\t\t);\n\t\treturn NULL;\n\t}\n\n\tresult = uml_kmalloc(sizeof(struct vector_fds), UM_GFP_KERNEL);\n\tif (result != NULL) {\n\t\tresult->rx_fd = fd;\n\t\tresult->tx_fd = fd;\n\t\tresult->remote_addr = uml_kmalloc(\n\t\t\tgairesult->ai_addrlen, UM_GFP_KERNEL);\n\t\tif (result->remote_addr == NULL)\n\t\t\tgoto cleanup;\n\t\tresult->remote_addr_size = gairesult->ai_addrlen;\n\t\tmemcpy(\n\t\t\tresult->remote_addr,\n\t\t\tgairesult->ai_addr,\n\t\t\tgairesult->ai_addrlen\n\t\t);\n\t}\n\tfreeaddrinfo(gairesult);\n\treturn result;\ncleanup:\n\tif (gairesult != NULL)\n\t\tfreeaddrinfo(gairesult);\n\tprintk(UM_KERN_ERR \"user_init_socket: init failed, error %d\", err);\n\tif (fd >= 0)\n\t\tos_close_file(fd);\n\tif (result != NULL) {\n\t\tkfree(result->remote_addr);\n\t\tkfree(result);\n\t}\n\treturn NULL;\n}"
    },
    {
        "var_name": "gairesult",
        "function_name": "user_init_socket_fds",
        "location": {
            "file_path": "arch/um/drivers/vector_user.c",
            "region": {
                "startLine": 597,
                "startColumn": 3,
                "endColumn": 12
            },
            "context": {
                "startLine": 595,
                "endLine": 599,
                "snippet": {
                    "text": "gairesult->ai_addrlen)) {"
                }
            }
        },
        "function_code": "static struct vector_fds *user_init_socket_fds(struct arglist *ifspec, int id)\n{\n\tint err = -ENOMEM;\n\tint fd = -1, gairet;\n\tstruct addrinfo srchints;\n\tstruct addrinfo dsthints;\n\tbool v6, udp;\n\tchar *value;\n\tchar *src, *dst, *srcport, *dstport;\n\tstruct addrinfo *gairesult = NULL;\n\tstruct vector_fds *result = NULL;\n\n\n\tvalue = uml_vector_fetch_arg(ifspec, \"v6\");\n\tv6 = false;\n\tudp = false;\n\tif (value != NULL) {\n\t\tif (strtol((const char *) value, NULL, 10) > 0)\n\t\t\tv6 = true;\n\t}\n\n\tvalue = uml_vector_fetch_arg(ifspec, \"udp\");\n\tif (value != NULL) {\n\t\tif (strtol((const char *) value, NULL, 10) > 0)\n\t\t\tudp = true;\n\t}\n\tsrc = uml_vector_fetch_arg(ifspec, \"src\");\n\tdst = uml_vector_fetch_arg(ifspec, \"dst\");\n\tsrcport = uml_vector_fetch_arg(ifspec, \"srcport\");\n\tdstport = uml_vector_fetch_arg(ifspec, \"dstport\");\n\n\tmemset(&dsthints, 0, sizeof(dsthints));\n\n\tif (v6)\n\t\tdsthints.ai_family = AF_INET6;\n\telse\n\t\tdsthints.ai_family = AF_INET;\n\n\tswitch (id) {\n\tcase ID_GRE:\n\t\tdsthints.ai_socktype = SOCK_RAW;\n\t\tdsthints.ai_protocol = IPPROTO_GRE;\n\t\tbreak;\n\tcase ID_L2TPV3:\n\t\tif (udp) {\n\t\t\tdsthints.ai_socktype = SOCK_DGRAM;\n\t\t\tdsthints.ai_protocol = 0;\n\t\t} else {\n\t\t\tdsthints.ai_socktype = SOCK_RAW;\n\t\t\tdsthints.ai_protocol = IPPROTO_L2TP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Unsupported socket type\\n\");\n\t\treturn NULL;\n\t}\n\tmemcpy(&srchints, &dsthints, sizeof(struct addrinfo));\n\n\tgairet = getaddrinfo(src, srcport, &dsthints, &gairesult);\n\tif ((gairet != 0) || (gairesult == NULL)) {\n\t\tprintk(UM_KERN_ERR\n\t\t\t\"socket_open : could not resolve src, error = %s\",\n\t\t\tgai_strerror(gairet)\n\t\t);\n\t\treturn NULL;\n\t}\n\tfd = socket(gairesult->ai_family,\n\t\tgairesult->ai_socktype, gairesult->ai_protocol);\n\tif (fd == -1) {\n\t\tprintk(UM_KERN_ERR\n\t\t\t\"socket_open : could not open socket, error = %d\",\n\t\t\t-errno\n\t\t);\n\t\tgoto cleanup;\n\t}\n\tif (bind(fd,\n\t\t(struct sockaddr *) gairesult->ai_addr,\n\t\tgairesult->ai_addrlen)) {\n\t\tprintk(UM_KERN_ERR L2TPV3_BIND_FAIL, errno);\n\t\tgoto cleanup;\n\t}\n\n\tif (gairesult != NULL)\n\t\tfreeaddrinfo(gairesult);\n\n\tgairesult = NULL;\n\n\tgairet = getaddrinfo(dst, dstport, &dsthints, &gairesult);\n\tif ((gairet != 0) || (gairesult == NULL)) {\n\t\tprintk(UM_KERN_ERR\n\t\t\t\"socket_open : could not resolve dst, error = %s\",\n\t\t\tgai_strerror(gairet)\n\t\t);\n\t\treturn NULL;\n\t}\n\n\tresult = uml_kmalloc(sizeof(struct vector_fds), UM_GFP_KERNEL);\n\tif (result != NULL) {\n\t\tresult->rx_fd = fd;\n\t\tresult->tx_fd = fd;\n\t\tresult->remote_addr = uml_kmalloc(\n\t\t\tgairesult->ai_addrlen, UM_GFP_KERNEL);\n\t\tif (result->remote_addr == NULL)\n\t\t\tgoto cleanup;\n\t\tresult->remote_addr_size = gairesult->ai_addrlen;\n\t\tmemcpy(\n\t\t\tresult->remote_addr,\n\t\t\tgairesult->ai_addr,\n\t\t\tgairesult->ai_addrlen\n\t\t);\n\t}\n\tfreeaddrinfo(gairesult);\n\treturn result;\ncleanup:\n\tif (gairesult != NULL)\n\t\tfreeaddrinfo(gairesult);\n\tprintk(UM_KERN_ERR \"user_init_socket: init failed, error %d\", err);\n\tif (fd >= 0)\n\t\tos_close_file(fd);\n\tif (result != NULL) {\n\t\tkfree(result->remote_addr);\n\t\tkfree(result);\n\t}\n\treturn NULL;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "um_pci_cfgspace_read",
        "location": {
            "file_path": "arch/um/drivers/virt-pci.c",
            "region": {
                "startLine": 200,
                "startColumn": 9,
                "endColumn": 12
            },
            "context": {
                "startLine": 198,
                "endLine": 202,
                "snippet": {
                    "text": "data = buf->data;"
                }
            }
        },
        "function_code": "static unsigned long um_pci_cfgspace_read(void *priv, unsigned int offset,\n\t\t\t\t\t  int size)\n{\n\tstruct um_pci_device_reg *reg = priv;\n\tstruct um_pci_device *dev = reg->dev;\n\tstruct virtio_pcidev_msg hdr = {\n\t\t.op = VIRTIO_PCIDEV_OP_CFG_READ,\n\t\t.size = size,\n\t\t.addr = offset,\n\t};\n\t/* buf->data is maximum size - we may only use parts of it */\n\tstruct um_pci_message_buffer *buf;\n\tu8 *data;\n\tunsigned long ret = ULONG_MAX;\n\tsize_t bytes = sizeof(buf->data);\n\n\tif (!dev)\n\t\treturn ULONG_MAX;\n\n\tbuf = get_cpu_var(um_pci_msg_bufs);\n\tdata = buf->data;\n\n\tif (buf)\n\t\tmemset(data, 0xff, bytes);\n\n\tswitch (size) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n#ifdef CONFIG_64BIT\n\tcase 8:\n#endif\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid config space read size %d\\n\", size);\n\t\tgoto out;\n\t}\n\n\tif (um_pci_send_cmd(dev, &hdr, sizeof(hdr), NULL, 0, data, bytes))\n\t\tgoto out;\n\n\tswitch (size) {\n\tcase 1:\n\t\tret = data[0];\n\t\tbreak;\n\tcase 2:\n\t\tret = le16_to_cpup((void *)data);\n\t\tbreak;\n\tcase 4:\n\t\tret = le32_to_cpup((void *)data);\n\t\tbreak;\n#ifdef CONFIG_64BIT\n\tcase 8:\n\t\tret = le64_to_cpup((void *)data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tput_cpu_var(um_pci_msg_bufs);\n\treturn ret;\n}"
    },
    {
        "var_name": "e",
        "function_name": "time_travel_update_time",
        "location": {
            "file_path": "arch/um/kernel/time.c",
            "region": {
                "startLine": 410,
                "startColumn": 29,
                "endColumn": 30
            },
            "context": {
                "startLine": 408,
                "endLine": 412,
                "snippet": {
                    "text": "__time_travel_update_time(e->time, idle);"
                }
            }
        },
        "function_code": "static void time_travel_update_time(unsigned long long next, bool idle)\n{\n\tstruct time_travel_event ne = {\n\t\t.onstack = true,\n\t};\n\tstruct time_travel_event *e;\n\tbool finished = idle;\n\n\t/* add it without a handler - we deal with that specifically below */\n\t__time_travel_add_event(&ne, next);\n\n\tdo {\n\t\te = time_travel_first_event();\n\n\t\tBUG_ON(!e);\n\t\t__time_travel_update_time(e->time, idle);\n\n\t\t/* new events may have been inserted while we were waiting */\n\t\tif (e == time_travel_first_event()) {\n\t\t\tBUG_ON(!time_travel_del_event(e));\n\t\t\tBUG_ON(time_travel_time != e->time);\n\n\t\t\tif (e == &ne) {\n\t\t\t\tfinished = true;\n\t\t\t} else {\n\t\t\t\tif (e->onstack)\n\t\t\t\t\tpanic(\"On-stack event dequeued outside of the stack! time=%lld, event time=%lld, event=%pS\\n\",\n\t\t\t\t\t      time_travel_time, e->time, e);\n\t\t\t\ttime_travel_deliver_event(e);\n\t\t\t}\n\t\t}\n\n\t\te = time_travel_first_event();\n\t\tif (e)\n\t\t\ttime_travel_ext_update_request(e->time);\n\t} while (ne.pending && !finished);\n\n\ttime_travel_del_event(&ne);\n}"
    },
    {
        "var_name": "event",
        "function_name": "intel_pmu_drain_pebs_core",
        "location": {
            "file_path": "arch/x86/events/intel/ds.c",
            "region": {
                "startLine": 2119,
                "startColumn": 7,
                "endColumn": 12
            },
            "context": {
                "startLine": 2117,
                "endLine": 2121,
                "snippet": {
                    "text": "if (!event->attr.precise_ip)"
                }
            }
        },
        "function_code": "static void intel_pmu_drain_pebs_core(struct pt_regs *iregs, struct perf_sample_data *data)\n{\n\tstruct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);\n\tstruct debug_store *ds = cpuc->ds;\n\tstruct perf_event *event = cpuc->events[0]; /* PMC0 only */\n\tstruct pebs_record_core *at, *top;\n\tint n;\n\n\tif (!x86_pmu.pebs_active)\n\t\treturn;\n\n\tat  = (struct pebs_record_core *)(unsigned long)ds->pebs_buffer_base;\n\ttop = (struct pebs_record_core *)(unsigned long)ds->pebs_index;\n\n\t/*\n\t * Whatever else happens, drain the thing\n\t */\n\tds->pebs_index = ds->pebs_buffer_base;\n\n\tif (!test_bit(0, cpuc->active_mask))\n\t\treturn;\n\n\tWARN_ON_ONCE(!event);\n\n\tif (!event->attr.precise_ip)\n\t\treturn;\n\n\tn = top - at;\n\tif (n <= 0) {\n\t\tif (event->hw.flags & PERF_X86_EVENT_AUTO_RELOAD)\n\t\t\tintel_pmu_save_and_restart_reload(event, 0);\n\t\treturn;\n\t}\n\n\t__intel_pmu_pebs_event(event, iregs, data, at, top, 0, n,\n\t\t\t       setup_pebs_fixed_sample_data);\n}"
    },
    {
        "var_name": "irqd",
        "function_name": "x86_vector_alloc_irqs",
        "location": {
            "file_path": "arch/x86/kernel/apic/vector.c",
            "region": {
                "startLine": 565,
                "startColumn": 16,
                "endColumn": 20
            },
            "context": {
                "startLine": 563,
                "endLine": 567,
                "snippet": {
                    "text": "WARN_ON_ONCE(irqd->chip_data);"
                }
            }
        },
        "function_code": "static int x86_vector_alloc_irqs(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct apic_chip_data *apicd;\n\tstruct irq_data *irqd;\n\tint i, err, node;\n\n\tif (apic_is_disabled)\n\t\treturn -ENXIO;\n\n\t/*\n\t * Catch any attempt to touch the cascade interrupt on a PIC\n\t * equipped system.\n\t */\n\tif (WARN_ON_ONCE(info->flags & X86_IRQ_ALLOC_LEGACY &&\n\t\t\t virq == PIC_CASCADE_IR))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirqd = irq_domain_get_irq_data(domain, virq + i);\n\t\tBUG_ON(!irqd);\n\t\tnode = irq_data_get_node(irqd);\n\t\tWARN_ON_ONCE(irqd->chip_data);\n\t\tapicd = alloc_apic_chip_data(node);\n\t\tif (!apicd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tapicd->irq = virq + i;\n\t\tirqd->chip = &lapic_controller;\n\t\tirqd->chip_data = apicd;\n\t\tirqd->hwirq = virq + i;\n\t\tirqd_set_single_target(irqd);\n\t\t/*\n\t\t * Prevent that any of these interrupts is invoked in\n\t\t * non interrupt context via e.g. generic_handle_irq()\n\t\t * as that can corrupt the affinity move state.\n\t\t */\n\t\tirqd_set_handle_enforce_irqctx(irqd);\n\n\t\t/* Don't invoke affinity setter on deactivated interrupts */\n\t\tirqd_set_affinity_on_activate(irqd);\n\n\t\t/*\n\t\t * Legacy vectors are already assigned when the IOAPIC\n\t\t * takes them over. They stay on the same vector. This is\n\t\t * required for check_timer() to work correctly as it might\n\t\t * switch back to legacy mode. Only update the hardware\n\t\t * config.\n\t\t */\n\t\tif (info->flags & X86_IRQ_ALLOC_LEGACY) {\n\t\t\tif (!vector_configure_legacy(virq + i, irqd, apicd))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = assign_irq_vector_policy(irqd, info);\n\t\ttrace_vector_setup(virq + i, false, err);\n\t\tif (err) {\n\t\t\tirqd->chip_data = NULL;\n\t\t\tfree_apic_chip_data(apicd);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\tx86_vector_free_irqs(domain, virq, i);\n\treturn err;\n}"
    },
    {
        "var_name": "irqd",
        "function_name": "x86_vector_alloc_irqs",
        "location": {
            "file_path": "arch/x86/kernel/apic/vector.c",
            "region": {
                "startLine": 573,
                "startColumn": 3,
                "endColumn": 7
            },
            "context": {
                "startLine": 571,
                "endLine": 575,
                "snippet": {
                    "text": "irqd->chip = &lapic_controller;"
                }
            }
        },
        "function_code": "static int x86_vector_alloc_irqs(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct apic_chip_data *apicd;\n\tstruct irq_data *irqd;\n\tint i, err, node;\n\n\tif (apic_is_disabled)\n\t\treturn -ENXIO;\n\n\t/*\n\t * Catch any attempt to touch the cascade interrupt on a PIC\n\t * equipped system.\n\t */\n\tif (WARN_ON_ONCE(info->flags & X86_IRQ_ALLOC_LEGACY &&\n\t\t\t virq == PIC_CASCADE_IR))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirqd = irq_domain_get_irq_data(domain, virq + i);\n\t\tBUG_ON(!irqd);\n\t\tnode = irq_data_get_node(irqd);\n\t\tWARN_ON_ONCE(irqd->chip_data);\n\t\tapicd = alloc_apic_chip_data(node);\n\t\tif (!apicd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tapicd->irq = virq + i;\n\t\tirqd->chip = &lapic_controller;\n\t\tirqd->chip_data = apicd;\n\t\tirqd->hwirq = virq + i;\n\t\tirqd_set_single_target(irqd);\n\t\t/*\n\t\t * Prevent that any of these interrupts is invoked in\n\t\t * non interrupt context via e.g. generic_handle_irq()\n\t\t * as that can corrupt the affinity move state.\n\t\t */\n\t\tirqd_set_handle_enforce_irqctx(irqd);\n\n\t\t/* Don't invoke affinity setter on deactivated interrupts */\n\t\tirqd_set_affinity_on_activate(irqd);\n\n\t\t/*\n\t\t * Legacy vectors are already assigned when the IOAPIC\n\t\t * takes them over. They stay on the same vector. This is\n\t\t * required for check_timer() to work correctly as it might\n\t\t * switch back to legacy mode. Only update the hardware\n\t\t * config.\n\t\t */\n\t\tif (info->flags & X86_IRQ_ALLOC_LEGACY) {\n\t\t\tif (!vector_configure_legacy(virq + i, irqd, apicd))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = assign_irq_vector_policy(irqd, info);\n\t\ttrace_vector_setup(virq + i, false, err);\n\t\tif (err) {\n\t\t\tirqd->chip_data = NULL;\n\t\t\tfree_apic_chip_data(apicd);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\tx86_vector_free_irqs(domain, virq, i);\n\treturn err;\n}"
    },
    {
        "var_name": "irqd",
        "function_name": "x86_vector_alloc_irqs",
        "location": {
            "file_path": "arch/x86/kernel/apic/vector.c",
            "region": {
                "startLine": 574,
                "startColumn": 3,
                "endColumn": 7
            },
            "context": {
                "startLine": 572,
                "endLine": 576,
                "snippet": {
                    "text": "irqd->chip_data = apicd;"
                }
            }
        },
        "function_code": "static int x86_vector_alloc_irqs(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct apic_chip_data *apicd;\n\tstruct irq_data *irqd;\n\tint i, err, node;\n\n\tif (apic_is_disabled)\n\t\treturn -ENXIO;\n\n\t/*\n\t * Catch any attempt to touch the cascade interrupt on a PIC\n\t * equipped system.\n\t */\n\tif (WARN_ON_ONCE(info->flags & X86_IRQ_ALLOC_LEGACY &&\n\t\t\t virq == PIC_CASCADE_IR))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirqd = irq_domain_get_irq_data(domain, virq + i);\n\t\tBUG_ON(!irqd);\n\t\tnode = irq_data_get_node(irqd);\n\t\tWARN_ON_ONCE(irqd->chip_data);\n\t\tapicd = alloc_apic_chip_data(node);\n\t\tif (!apicd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tapicd->irq = virq + i;\n\t\tirqd->chip = &lapic_controller;\n\t\tirqd->chip_data = apicd;\n\t\tirqd->hwirq = virq + i;\n\t\tirqd_set_single_target(irqd);\n\t\t/*\n\t\t * Prevent that any of these interrupts is invoked in\n\t\t * non interrupt context via e.g. generic_handle_irq()\n\t\t * as that can corrupt the affinity move state.\n\t\t */\n\t\tirqd_set_handle_enforce_irqctx(irqd);\n\n\t\t/* Don't invoke affinity setter on deactivated interrupts */\n\t\tirqd_set_affinity_on_activate(irqd);\n\n\t\t/*\n\t\t * Legacy vectors are already assigned when the IOAPIC\n\t\t * takes them over. They stay on the same vector. This is\n\t\t * required for check_timer() to work correctly as it might\n\t\t * switch back to legacy mode. Only update the hardware\n\t\t * config.\n\t\t */\n\t\tif (info->flags & X86_IRQ_ALLOC_LEGACY) {\n\t\t\tif (!vector_configure_legacy(virq + i, irqd, apicd))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = assign_irq_vector_policy(irqd, info);\n\t\ttrace_vector_setup(virq + i, false, err);\n\t\tif (err) {\n\t\t\tirqd->chip_data = NULL;\n\t\t\tfree_apic_chip_data(apicd);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\tx86_vector_free_irqs(domain, virq, i);\n\treturn err;\n}"
    },
    {
        "var_name": "irqd",
        "function_name": "x86_vector_alloc_irqs",
        "location": {
            "file_path": "arch/x86/kernel/apic/vector.c",
            "region": {
                "startLine": 575,
                "startColumn": 3,
                "endColumn": 7
            },
            "context": {
                "startLine": 573,
                "endLine": 577,
                "snippet": {
                    "text": "irqd->hwirq = virq + i;"
                }
            }
        },
        "function_code": "static int x86_vector_alloc_irqs(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct apic_chip_data *apicd;\n\tstruct irq_data *irqd;\n\tint i, err, node;\n\n\tif (apic_is_disabled)\n\t\treturn -ENXIO;\n\n\t/*\n\t * Catch any attempt to touch the cascade interrupt on a PIC\n\t * equipped system.\n\t */\n\tif (WARN_ON_ONCE(info->flags & X86_IRQ_ALLOC_LEGACY &&\n\t\t\t virq == PIC_CASCADE_IR))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirqd = irq_domain_get_irq_data(domain, virq + i);\n\t\tBUG_ON(!irqd);\n\t\tnode = irq_data_get_node(irqd);\n\t\tWARN_ON_ONCE(irqd->chip_data);\n\t\tapicd = alloc_apic_chip_data(node);\n\t\tif (!apicd) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tapicd->irq = virq + i;\n\t\tirqd->chip = &lapic_controller;\n\t\tirqd->chip_data = apicd;\n\t\tirqd->hwirq = virq + i;\n\t\tirqd_set_single_target(irqd);\n\t\t/*\n\t\t * Prevent that any of these interrupts is invoked in\n\t\t * non interrupt context via e.g. generic_handle_irq()\n\t\t * as that can corrupt the affinity move state.\n\t\t */\n\t\tirqd_set_handle_enforce_irqctx(irqd);\n\n\t\t/* Don't invoke affinity setter on deactivated interrupts */\n\t\tirqd_set_affinity_on_activate(irqd);\n\n\t\t/*\n\t\t * Legacy vectors are already assigned when the IOAPIC\n\t\t * takes them over. They stay on the same vector. This is\n\t\t * required for check_timer() to work correctly as it might\n\t\t * switch back to legacy mode. Only update the hardware\n\t\t * config.\n\t\t */\n\t\tif (info->flags & X86_IRQ_ALLOC_LEGACY) {\n\t\t\tif (!vector_configure_legacy(virq + i, irqd, apicd))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\terr = assign_irq_vector_policy(irqd, info);\n\t\ttrace_vector_setup(virq + i, false, err);\n\t\tif (err) {\n\t\t\tirqd->chip_data = NULL;\n\t\t\tfree_apic_chip_data(apicd);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\tx86_vector_free_irqs(domain, virq, i);\n\treturn err;\n}"
    },
    {
        "var_name": "vm86",
        "function_name": "save_v86_state",
        "location": {
            "file_path": "arch/x86/kernel/vm86_32.c",
            "region": {
                "startLine": 111,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 109,
                "endLine": 113,
                "snippet": {
                    "text": "set_flags(regs->pt.flags, VEFLAGS, X86_EFLAGS_VIF | vm86->veflags_mask);"
                }
            }
        },
        "function_code": "void save_v86_state(struct kernel_vm86_regs *regs, int retval)\n{\n\tstruct task_struct *tsk = current;\n\tstruct vm86plus_struct __user *user;\n\tstruct vm86 *vm86 = current->thread.vm86;\n\n\t/*\n\t * This gets called from entry.S with interrupts disabled, but\n\t * from process context. Enable interrupts here, before trying\n\t * to access user space.\n\t */\n\tlocal_irq_enable();\n\n\tBUG_ON(!vm86);\n\n\tset_flags(regs->pt.flags, VEFLAGS, X86_EFLAGS_VIF | vm86->veflags_mask);\n\tuser = vm86->user_vm86;\n\n\tif (!user_access_begin(user, vm86->vm86plus.is_vm86pus ?\n\t\t       sizeof(struct vm86plus_struct) :\n\t\t       sizeof(struct vm86_struct)))\n\t\tgoto Efault;\n\n\tunsafe_put_user(regs->pt.bx, &user->regs.ebx, Efault_end);\n\tunsafe_put_user(regs->pt.cx, &user->regs.ecx, Efault_end);\n\tunsafe_put_user(regs->pt.dx, &user->regs.edx, Efault_end);\n\tunsafe_put_user(regs->pt.si, &user->regs.esi, Efault_end);\n\tunsafe_put_user(regs->pt.di, &user->regs.edi, Efault_end);\n\tunsafe_put_user(regs->pt.bp, &user->regs.ebp, Efault_end);\n\tunsafe_put_user(regs->pt.ax, &user->regs.eax, Efault_end);\n\tunsafe_put_user(regs->pt.ip, &user->regs.eip, Efault_end);\n\tunsafe_put_user(regs->pt.cs, &user->regs.cs, Efault_end);\n\tunsafe_put_user(regs->pt.flags, &user->regs.eflags, Efault_end);\n\tunsafe_put_user(regs->pt.sp, &user->regs.esp, Efault_end);\n\tunsafe_put_user(regs->pt.ss, &user->regs.ss, Efault_end);\n\tunsafe_put_user(regs->es, &user->regs.es, Efault_end);\n\tunsafe_put_user(regs->ds, &user->regs.ds, Efault_end);\n\tunsafe_put_user(regs->fs, &user->regs.fs, Efault_end);\n\tunsafe_put_user(regs->gs, &user->regs.gs, Efault_end);\n\n\t/*\n\t * Don't write screen_bitmap in case some user had a value there\n\t * and expected it to remain unchanged.\n\t */\n\n\tuser_access_end();\n\nexit_vm86:\n\tpreempt_disable();\n\ttsk->thread.sp0 = vm86->saved_sp0;\n\ttsk->thread.sysenter_cs = __KERNEL_CS;\n\tupdate_task_stack(tsk);\n\trefresh_sysenter_cs(&tsk->thread);\n\tvm86->saved_sp0 = 0;\n\tpreempt_enable();\n\n\tmemcpy(&regs->pt, &vm86->regs32, sizeof(struct pt_regs));\n\n\tloadsegment(gs, vm86->regs32.gs);\n\n\tregs->pt.ax = retval;\n\treturn;\n\nEfault_end:\n\tuser_access_end();\nEfault:\n\tpr_alert(\"could not access userspace vm86 info\\n\");\n\tforce_exit_sig(SIGSEGV);\n\tgoto exit_vm86;\n}"
    },
    {
        "var_name": "vm86",
        "function_name": "save_v86_state",
        "location": {
            "file_path": "arch/x86/kernel/vm86_32.c",
            "region": {
                "startLine": 112,
                "startColumn": 9,
                "endColumn": 13
            },
            "context": {
                "startLine": 110,
                "endLine": 114,
                "snippet": {
                    "text": "user = vm86->user_vm86;"
                }
            }
        },
        "function_code": "void save_v86_state(struct kernel_vm86_regs *regs, int retval)\n{\n\tstruct task_struct *tsk = current;\n\tstruct vm86plus_struct __user *user;\n\tstruct vm86 *vm86 = current->thread.vm86;\n\n\t/*\n\t * This gets called from entry.S with interrupts disabled, but\n\t * from process context. Enable interrupts here, before trying\n\t * to access user space.\n\t */\n\tlocal_irq_enable();\n\n\tBUG_ON(!vm86);\n\n\tset_flags(regs->pt.flags, VEFLAGS, X86_EFLAGS_VIF | vm86->veflags_mask);\n\tuser = vm86->user_vm86;\n\n\tif (!user_access_begin(user, vm86->vm86plus.is_vm86pus ?\n\t\t       sizeof(struct vm86plus_struct) :\n\t\t       sizeof(struct vm86_struct)))\n\t\tgoto Efault;\n\n\tunsafe_put_user(regs->pt.bx, &user->regs.ebx, Efault_end);\n\tunsafe_put_user(regs->pt.cx, &user->regs.ecx, Efault_end);\n\tunsafe_put_user(regs->pt.dx, &user->regs.edx, Efault_end);\n\tunsafe_put_user(regs->pt.si, &user->regs.esi, Efault_end);\n\tunsafe_put_user(regs->pt.di, &user->regs.edi, Efault_end);\n\tunsafe_put_user(regs->pt.bp, &user->regs.ebp, Efault_end);\n\tunsafe_put_user(regs->pt.ax, &user->regs.eax, Efault_end);\n\tunsafe_put_user(regs->pt.ip, &user->regs.eip, Efault_end);\n\tunsafe_put_user(regs->pt.cs, &user->regs.cs, Efault_end);\n\tunsafe_put_user(regs->pt.flags, &user->regs.eflags, Efault_end);\n\tunsafe_put_user(regs->pt.sp, &user->regs.esp, Efault_end);\n\tunsafe_put_user(regs->pt.ss, &user->regs.ss, Efault_end);\n\tunsafe_put_user(regs->es, &user->regs.es, Efault_end);\n\tunsafe_put_user(regs->ds, &user->regs.ds, Efault_end);\n\tunsafe_put_user(regs->fs, &user->regs.fs, Efault_end);\n\tunsafe_put_user(regs->gs, &user->regs.gs, Efault_end);\n\n\t/*\n\t * Don't write screen_bitmap in case some user had a value there\n\t * and expected it to remain unchanged.\n\t */\n\n\tuser_access_end();\n\nexit_vm86:\n\tpreempt_disable();\n\ttsk->thread.sp0 = vm86->saved_sp0;\n\ttsk->thread.sysenter_cs = __KERNEL_CS;\n\tupdate_task_stack(tsk);\n\trefresh_sysenter_cs(&tsk->thread);\n\tvm86->saved_sp0 = 0;\n\tpreempt_enable();\n\n\tmemcpy(&regs->pt, &vm86->regs32, sizeof(struct pt_regs));\n\n\tloadsegment(gs, vm86->regs32.gs);\n\n\tregs->pt.ax = retval;\n\treturn;\n\nEfault_end:\n\tuser_access_end();\nEfault:\n\tpr_alert(\"could not access userspace vm86 info\\n\");\n\tforce_exit_sig(SIGSEGV);\n\tgoto exit_vm86;\n}"
    },
    {
        "var_name": "ptep",
        "function_name": "set_aliased_prot",
        "location": {
            "file_path": "arch/x86/xen/enlighten_pv.c",
            "region": {
                "startLine": 432,
                "startColumn": 17,
                "endColumn": 21
            },
            "context": {
                "startLine": 430,
                "endLine": 434,
                "snippet": {
                    "text": "pfn = pte_pfn(*ptep);"
                }
            }
        },
        "function_code": "static void set_aliased_prot(void *v, pgprot_t prot)\n{\n\tint level;\n\tpte_t *ptep;\n\tpte_t pte;\n\tunsigned long pfn;\n\tunsigned char dummy;\n\tvoid *va;\n\n\tptep = lookup_address((unsigned long)v, &level);\n\tBUG_ON(ptep == NULL);\n\n\tpfn = pte_pfn(*ptep);\n\tpte = pfn_pte(pfn, prot);\n\n\t/*\n\t * Careful: update_va_mapping() will fail if the virtual address\n\t * we're poking isn't populated in the page tables.  We don't\n\t * need to worry about the direct map (that's always in the page\n\t * tables), but we need to be careful about vmap space.  In\n\t * particular, the top level page table can lazily propagate\n\t * entries between processes, so if we've switched mms since we\n\t * vmapped the target in the first place, we might not have the\n\t * top-level page table entry populated.\n\t *\n\t * We disable preemption because we want the same mm active when\n\t * we probe the target and when we issue the hypercall.  We'll\n\t * have the same nominal mm, but if we're a kernel thread, lazy\n\t * mm dropping could change our pgd.\n\t *\n\t * Out of an abundance of caution, this uses __get_user() to fault\n\t * in the target address just in case there's some obscure case\n\t * in which the target address isn't readable.\n\t */\n\n\tpreempt_disable();\n\n\tcopy_from_kernel_nofault(&dummy, v, 1);\n\n\tif (HYPERVISOR_update_va_mapping((unsigned long)v, pte, 0))\n\t\tBUG();\n\n\tva = __va(PFN_PHYS(pfn));\n\n\tif (va != v && HYPERVISOR_update_va_mapping((unsigned long)va, pte, 0))\n\t\tBUG();\n\n\tpreempt_enable();\n}"
    },
    {
        "var_name": "ptep",
        "function_name": "xen_load_gdt",
        "location": {
            "file_path": "arch/x86/xen/enlighten_pv.c",
            "region": {
                "startLine": 539,
                "startColumn": 17,
                "endColumn": 21
            },
            "context": {
                "startLine": 537,
                "endLine": 541,
                "snippet": {
                    "text": "pfn = pte_pfn(*ptep);"
                }
            }
        },
        "function_code": "static void xen_load_gdt(const struct desc_ptr *dtr)\n{\n\tunsigned long va = dtr->address;\n\tunsigned int size = dtr->size + 1;\n\tunsigned long pfn, mfn;\n\tint level;\n\tpte_t *ptep;\n\tvoid *virt;\n\n\t/* @size should be at most GDT_SIZE which is smaller than PAGE_SIZE. */\n\tBUG_ON(size > PAGE_SIZE);\n\tBUG_ON(va & ~PAGE_MASK);\n\n\t/*\n\t * The GDT is per-cpu and is in the percpu data area.\n\t * That can be virtually mapped, so we need to do a\n\t * page-walk to get the underlying MFN for the\n\t * hypercall.  The page can also be in the kernel's\n\t * linear range, so we need to RO that mapping too.\n\t */\n\tptep = lookup_address(va, &level);\n\tBUG_ON(ptep == NULL);\n\n\tpfn = pte_pfn(*ptep);\n\tmfn = pfn_to_mfn(pfn);\n\tvirt = __va(PFN_PHYS(pfn));\n\n\tmake_lowmem_page_readonly((void *)va);\n\tmake_lowmem_page_readonly(virt);\n\n\tif (HYPERVISOR_set_gdt(&mfn, size / sizeof(struct desc_struct)))\n\t\tBUG();\n}"
    },
    {
        "var_name": "pte",
        "function_name": "arbitrary_virt_to_machine",
        "location": {
            "file_path": "arch/x86/xen/mmu.c",
            "region": {
                "startLine": 37,
                "startColumn": 39,
                "endColumn": 42
            },
            "context": {
                "startLine": 35,
                "endLine": 39,
                "snippet": {
                    "text": "return XMADDR(((phys_addr_t)pte_mfn(*pte) << PAGE_SHIFT) + offset);"
                }
            }
        },
        "function_code": "xmaddr_t arbitrary_virt_to_machine(void *vaddr)\n{\n\tunsigned long address = (unsigned long)vaddr;\n\tunsigned int level;\n\tpte_t *pte;\n\tunsigned offset;\n\n\t/*\n\t * if the PFN is in the linear mapped vaddr range, we can just use\n\t * the (quick) virt_to_machine() p2m lookup\n\t */\n\tif (virt_addr_valid(vaddr))\n\t\treturn virt_to_machine(vaddr);\n\n\t/* otherwise we have to do a (slower) full page-table walk */\n\n\tpte = lookup_address(address, &level);\n\tBUG_ON(pte == NULL);\n\toffset = address & ~PAGE_MASK;\n\treturn XMADDR(((phys_addr_t)pte_mfn(*pte) << PAGE_SHIFT) + offset);\n}"
    },
    {
        "var_name": "ptep",
        "function_name": "xen_build_mfn_list_list",
        "location": {
            "file_path": "arch/x86/xen/p2m.c",
            "region": {
                "startLine": 246,
                "startColumn": 18,
                "endColumn": 22
            },
            "context": {
                "startLine": 244,
                "endLine": 248,
                "snippet": {
                    "text": "mfn = pte_mfn(*ptep);"
                }
            }
        },
        "function_code": "void __ref xen_build_mfn_list_list(void)\n{\n\tunsigned long pfn, mfn;\n\tpte_t *ptep;\n\tunsigned int level, topidx, mididx;\n\tunsigned long *mid_mfn_p;\n\n\tif (xen_start_info->flags & SIF_VIRT_P2M_4TOOLS)\n\t\treturn;\n\n\t/* Pre-initialize p2m_top_mfn to be completely missing */\n\tif (p2m_top_mfn == NULL) {\n\t\tp2m_mid_missing_mfn = alloc_p2m_page();\n\t\tp2m_mid_mfn_init(p2m_mid_missing_mfn, p2m_missing);\n\n\t\tp2m_top_mfn_p = alloc_p2m_page();\n\t\tp2m_top_mfn_p_init(p2m_top_mfn_p);\n\n\t\tp2m_top_mfn = alloc_p2m_page();\n\t\tp2m_top_mfn_init(p2m_top_mfn);\n\t} else {\n\t\t/* Reinitialise, mfn's all change after migration */\n\t\tp2m_mid_mfn_init(p2m_mid_missing_mfn, p2m_missing);\n\t}\n\n\tfor (pfn = 0; pfn < xen_max_p2m_pfn && pfn < MAX_P2M_PFN;\n\t     pfn += P2M_PER_PAGE) {\n\t\ttopidx = p2m_top_index(pfn);\n\t\tmididx = p2m_mid_index(pfn);\n\n\t\tmid_mfn_p = p2m_top_mfn_p[topidx];\n\t\tptep = lookup_address((unsigned long)(xen_p2m_addr + pfn),\n\t\t\t\t      &level);\n\t\tBUG_ON(!ptep || level != PG_LEVEL_4K);\n\t\tmfn = pte_mfn(*ptep);\n\t\tptep = (pte_t *)((unsigned long)ptep & ~(PAGE_SIZE - 1));\n\n\t\t/* Don't bother allocating any mfn mid levels if\n\t\t * they're just missing, just update the stored mfn,\n\t\t * since all could have changed over a migrate.\n\t\t */\n\t\tif (ptep == p2m_missing_pte || ptep == p2m_identity_pte) {\n\t\t\tBUG_ON(mididx);\n\t\t\tBUG_ON(mid_mfn_p != p2m_mid_missing_mfn);\n\t\t\tp2m_top_mfn[topidx] = virt_to_mfn(p2m_mid_missing_mfn);\n\t\t\tpfn += (P2M_MID_PER_PAGE - 1) * P2M_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mid_mfn_p == p2m_mid_missing_mfn) {\n\t\t\tmid_mfn_p = alloc_p2m_page();\n\t\t\tp2m_mid_mfn_init(mid_mfn_p, p2m_missing);\n\n\t\t\tp2m_top_mfn_p[topidx] = mid_mfn_p;\n\t\t}\n\n\t\tp2m_top_mfn[topidx] = virt_to_mfn(mid_mfn_p);\n\t\tmid_mfn_p[mididx] = mfn;\n\t}\n}"
    },
    {
        "var_name": "bfqd",
        "function_name": "bfq_bio_bfqg",
        "location": {
            "file_path": "block/bfq-cgroup.c",
            "region": {
                "startLine": 617,
                "startColumn": 19,
                "endColumn": 23
            },
            "context": {
                "startLine": 615,
                "endLine": 619,
                "snippet": {
                    "text": "&bfqg_to_blkg(bfqd->root_group)->blkcg->css);"
                }
            }
        },
        "function_code": "\nstruct bfq_group *bfq_bio_bfqg(struct bfq_data *bfqd, struct bio *bio)\n{\n\tstruct blkcg_gq *blkg = bio->bi_blkg;\n\tstruct bfq_group *bfqg;\n\n\twhile (blkg) {\n\t\tif (!blkg->online) {\n\t\t\tblkg = blkg->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tbfqg = blkg_to_bfqg(blkg);\n\t\tif (bfqg->pd.online) {\n\t\t\tbio_associate_blkg_from_css(bio, &blkg->blkcg->css);\n\t\t\treturn bfqg;\n\t\t}\n\t\tblkg = blkg->parent;\n\t}\n\tbio_associate_blkg_from_css(bio,\n\t\t\t\t&bfqg_to_blkg(bfqd->root_group)->blkcg->css);\n\treturn bfqd->root_group;"
    },
    {
        "var_name": "bfqd",
        "function_name": "bfq_bio_bfqg",
        "location": {
            "file_path": "block/bfq-cgroup.c",
            "region": {
                "startLine": 618,
                "startColumn": 9,
                "endColumn": 13
            },
            "context": {
                "startLine": 616,
                "endLine": 620,
                "snippet": {
                    "text": "return bfqd->root_group;"
                }
            }
        },
        "function_code": "\nstruct bfq_group *bfq_bio_bfqg(struct bfq_data *bfqd, struct bio *bio)\n{\n\tstruct blkcg_gq *blkg = bio->bi_blkg;\n\tstruct bfq_group *bfqg;\n\n\twhile (blkg) {\n\t\tif (!blkg->online) {\n\t\t\tblkg = blkg->parent;\n\t\t\tcontinue;\n\t\t}\n\t\tbfqg = blkg_to_bfqg(blkg);\n\t\tif (bfqg->pd.online) {\n\t\t\tbio_associate_blkg_from_css(bio, &blkg->blkcg->css);\n\t\t\treturn bfqg;\n\t\t}\n\t\tblkg = blkg->parent;\n\t}\n\tbio_associate_blkg_from_css(bio,\n\t\t\t\t&bfqg_to_blkg(bfqd->root_group)->blkcg->css);\n\treturn bfqd->root_group;"
    },
    {
        "var_name": "bip_src",
        "function_name": "bio_integrity_clone",
        "location": {
            "file_path": "block/bio-integrity.c",
            "region": {
                "startLine": 623,
                "startColumn": 43,
                "endColumn": 50
            },
            "context": {
                "startLine": 621,
                "endLine": 625,
                "snippet": {
                    "text": "bip = bio_integrity_alloc(bio, gfp_mask, bip_src->bip_vcnt);"
                }
            }
        },
        "function_code": "int bio_integrity_clone(struct bio *bio, struct bio *bio_src,\n\t\t\tgfp_t gfp_mask)\n{\n\tstruct bio_integrity_payload *bip_src = bio_integrity(bio_src);\n\tstruct bio_integrity_payload *bip;\n\n\tBUG_ON(bip_src == NULL);\n\n\tbip = bio_integrity_alloc(bio, gfp_mask, bip_src->bip_vcnt);\n\tif (IS_ERR(bip))\n\t\treturn PTR_ERR(bip);\n\n\tmemcpy(bip->bip_vec, bip_src->bip_vec,\n\t       bip_src->bip_vcnt * sizeof(struct bio_vec));\n\n\tbip->bip_vcnt = bip_src->bip_vcnt;\n\tbip->bip_iter = bip_src->bip_iter;\n\tbip->bip_flags = bip_src->bip_flags & ~BIP_BLOCK_INTEGRITY;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "bip_src",
        "function_name": "bio_integrity_clone",
        "location": {
            "file_path": "block/bio-integrity.c",
            "region": {
                "startLine": 627,
                "startColumn": 23,
                "endColumn": 30
            },
            "context": {
                "startLine": 625,
                "endLine": 629,
                "snippet": {
                    "text": "memcpy(bip->bip_vec, bip_src->bip_vec,"
                }
            }
        },
        "function_code": "int bio_integrity_clone(struct bio *bio, struct bio *bio_src,\n\t\t\tgfp_t gfp_mask)\n{\n\tstruct bio_integrity_payload *bip_src = bio_integrity(bio_src);\n\tstruct bio_integrity_payload *bip;\n\n\tBUG_ON(bip_src == NULL);\n\n\tbip = bio_integrity_alloc(bio, gfp_mask, bip_src->bip_vcnt);\n\tif (IS_ERR(bip))\n\t\treturn PTR_ERR(bip);\n\n\tmemcpy(bip->bip_vec, bip_src->bip_vec,\n\t       bip_src->bip_vcnt * sizeof(struct bio_vec));\n\n\tbip->bip_vcnt = bip_src->bip_vcnt;\n\tbip->bip_iter = bip_src->bip_iter;\n\tbip->bip_flags = bip_src->bip_flags & ~BIP_BLOCK_INTEGRITY;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "bip_src",
        "function_name": "bio_integrity_clone",
        "location": {
            "file_path": "block/bio-integrity.c",
            "region": {
                "startLine": 628,
                "startColumn": 9,
                "endColumn": 16
            },
            "context": {
                "startLine": 626,
                "endLine": 630,
                "snippet": {
                    "text": "bip_src->bip_vcnt * sizeof(struct bio_vec));"
                }
            }
        },
        "function_code": "int bio_integrity_clone(struct bio *bio, struct bio *bio_src,\n\t\t\tgfp_t gfp_mask)\n{\n\tstruct bio_integrity_payload *bip_src = bio_integrity(bio_src);\n\tstruct bio_integrity_payload *bip;\n\n\tBUG_ON(bip_src == NULL);\n\n\tbip = bio_integrity_alloc(bio, gfp_mask, bip_src->bip_vcnt);\n\tif (IS_ERR(bip))\n\t\treturn PTR_ERR(bip);\n\n\tmemcpy(bip->bip_vec, bip_src->bip_vec,\n\t       bip_src->bip_vcnt * sizeof(struct bio_vec));\n\n\tbip->bip_vcnt = bip_src->bip_vcnt;\n\tbip->bip_iter = bip_src->bip_iter;\n\tbip->bip_flags = bip_src->bip_flags & ~BIP_BLOCK_INTEGRITY;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "bip_src",
        "function_name": "bio_integrity_clone",
        "location": {
            "file_path": "block/bio-integrity.c",
            "region": {
                "startLine": 630,
                "startColumn": 18,
                "endColumn": 25
            },
            "context": {
                "startLine": 628,
                "endLine": 632,
                "snippet": {
                    "text": "bip->bip_vcnt = bip_src->bip_vcnt;"
                }
            }
        },
        "function_code": "int bio_integrity_clone(struct bio *bio, struct bio *bio_src,\n\t\t\tgfp_t gfp_mask)\n{\n\tstruct bio_integrity_payload *bip_src = bio_integrity(bio_src);\n\tstruct bio_integrity_payload *bip;\n\n\tBUG_ON(bip_src == NULL);\n\n\tbip = bio_integrity_alloc(bio, gfp_mask, bip_src->bip_vcnt);\n\tif (IS_ERR(bip))\n\t\treturn PTR_ERR(bip);\n\n\tmemcpy(bip->bip_vec, bip_src->bip_vec,\n\t       bip_src->bip_vcnt * sizeof(struct bio_vec));\n\n\tbip->bip_vcnt = bip_src->bip_vcnt;\n\tbip->bip_iter = bip_src->bip_iter;\n\tbip->bip_flags = bip_src->bip_flags & ~BIP_BLOCK_INTEGRITY;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "bip_src",
        "function_name": "bio_integrity_clone",
        "location": {
            "file_path": "block/bio-integrity.c",
            "region": {
                "startLine": 631,
                "startColumn": 18,
                "endColumn": 25
            },
            "context": {
                "startLine": 629,
                "endLine": 633,
                "snippet": {
                    "text": "bip->bip_iter = bip_src->bip_iter;"
                }
            }
        },
        "function_code": "int bio_integrity_clone(struct bio *bio, struct bio *bio_src,\n\t\t\tgfp_t gfp_mask)\n{\n\tstruct bio_integrity_payload *bip_src = bio_integrity(bio_src);\n\tstruct bio_integrity_payload *bip;\n\n\tBUG_ON(bip_src == NULL);\n\n\tbip = bio_integrity_alloc(bio, gfp_mask, bip_src->bip_vcnt);\n\tif (IS_ERR(bip))\n\t\treturn PTR_ERR(bip);\n\n\tmemcpy(bip->bip_vec, bip_src->bip_vec,\n\t       bip_src->bip_vcnt * sizeof(struct bio_vec));\n\n\tbip->bip_vcnt = bip_src->bip_vcnt;\n\tbip->bip_iter = bip_src->bip_iter;\n\tbip->bip_flags = bip_src->bip_flags & ~BIP_BLOCK_INTEGRITY;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "bs",
        "function_name": "bio_free",
        "location": {
            "file_path": "block/bio.c",
            "region": {
                "startLine": 237,
                "startColumn": 19,
                "endColumn": 21
            },
            "context": {
                "startLine": 235,
                "endLine": 239,
                "snippet": {
                    "text": "mempool_free(p - bs->front_pad, &bs->bio_pool);"
                }
            }
        },
        "function_code": "static void bio_free(struct bio *bio)\n{\n\tstruct bio_set *bs = bio->bi_pool;\n\tvoid *p = bio;\n\n\tWARN_ON_ONCE(!bs);\n\n\tbio_uninit(bio);\n\tbvec_free(&bs->bvec_pool, bio->bi_io_vec, bio->bi_max_vecs);\n\tmempool_free(p - bs->front_pad, &bs->bio_pool);\n}"
    },
    {
        "var_name": "hctx",
        "function_name": "blk_mq_hw_queue_mapped",
        "location": {
            "file_path": "block/blk-mq.h",
            "region": {
                "startLine": 236,
                "startColumn": 9,
                "endColumn": 13
            },
            "context": {
                "startLine": 234,
                "endLine": 238,
                "snippet": {
                    "text": "return hctx->nr_ctx && hctx->tags;"
                }
            }
        },
        "function_code": "static inline bool blk_mq_hw_queue_mapped(struct blk_mq_hw_ctx *hctx)\n{\n\treturn hctx->nr_ctx && hctx->tags;\n}"
    },
    {
        "var_name": "hctx",
        "function_name": "blk_mq_exit_hctx",
        "location": {
            "file_path": "block/blk-mq.c",
            "region": {
                "startLine": 3623,
                "startColumn": 29,
                "endColumn": 33
            },
            "context": {
                "startLine": 3621,
                "endLine": 3625,
                "snippet": {
                    "text": "struct request *flush_rq = hctx->fq->flush_rq;"
                }
            }
        },
        "function_code": "static void blk_mq_exit_hctx(struct request_queue *q,\n\t\tstruct blk_mq_tag_set *set,\n\t\tstruct blk_mq_hw_ctx *hctx, unsigned int hctx_idx)\n{\n\tstruct request *flush_rq = hctx->fq->flush_rq;\n\n\tif (blk_mq_hw_queue_mapped(hctx))\n\t\tblk_mq_tag_idle(hctx);\n\n\tif (blk_queue_init_done(q))\n\t\tblk_mq_clear_flush_rq_mapping(set->tags[hctx_idx],\n\t\t\t\tset->queue_depth, flush_rq);\n\tif (set->ops->exit_request)\n\t\tset->ops->exit_request(set, flush_rq, hctx_idx);\n\n\tif (set->ops->exit_hctx)\n\t\tset->ops->exit_hctx(hctx, hctx_idx);\n\n\tblk_mq_remove_cpuhp(hctx);\n\n\txa_erase(&q->hctx_table, hctx_idx);\n\n\tspin_lock(&q->unused_hctx_lock);\n\tlist_add(&hctx->hctx_list, &q->unused_hctx_list);\n\tspin_unlock(&q->unused_hctx_lock);\n}"
    },
    {
        "var_name": "curr",
        "function_name": "drbg_ctr_bcc",
        "location": {
            "file_path": "crypto/drbg.c",
            "region": {
                "startLine": 322,
                "startColumn": 30,
                "endColumn": 34
            },
            "context": {
                "startLine": 320,
                "endLine": 324,
                "snippet": {
                    "text": "const unsigned char *pos = curr->buf;"
                }
            }
        },
        "function_code": "static int drbg_ctr_bcc(struct drbg_state *drbg,\n\t\t\tunsigned char *out, const unsigned char *key,\n\t\t\tstruct list_head *in)\n{\n\tint ret = 0;\n\tstruct drbg_string *curr = NULL;\n\tstruct drbg_string data;\n\tshort cnt = 0;\n\n\tdrbg_string_fill(&data, out, drbg_blocklen(drbg));\n\n\t/* 10.4.3 step 2 / 4 */\n\tdrbg_kcapi_symsetkey(drbg, key);\n\tlist_for_each_entry(curr, in, list) {\n\t\tconst unsigned char *pos = curr->buf;\n\t\tsize_t len = curr->len;\n\t\t/* 10.4.3 step 4.1 */\n\t\twhile (len) {\n\t\t\t/* 10.4.3 step 4.2 */\n\t\t\tif (drbg_blocklen(drbg) == cnt) {\n\t\t\t\tcnt = 0;\n\t\t\t\tret = drbg_kcapi_sym(drbg, out, &data);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tout[cnt] ^= *pos;\n\t\t\tpos++;\n\t\t\tcnt++;\n\t\t\tlen--;\n\t\t}\n\t}\n\t/* 10.4.3 step 4.2 for last block */\n\tif (cnt)\n\t\tret = drbg_kcapi_sym(drbg, out, &data);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "curr",
        "function_name": "drbg_ctr_bcc",
        "location": {
            "file_path": "crypto/drbg.c",
            "region": {
                "startLine": 323,
                "startColumn": 16,
                "endColumn": 20
            },
            "context": {
                "startLine": 321,
                "endLine": 325,
                "snippet": {
                    "text": "size_t len = curr->len;"
                }
            }
        },
        "function_code": "static int drbg_ctr_bcc(struct drbg_state *drbg,\n\t\t\tunsigned char *out, const unsigned char *key,\n\t\t\tstruct list_head *in)\n{\n\tint ret = 0;\n\tstruct drbg_string *curr = NULL;\n\tstruct drbg_string data;\n\tshort cnt = 0;\n\n\tdrbg_string_fill(&data, out, drbg_blocklen(drbg));\n\n\t/* 10.4.3 step 2 / 4 */\n\tdrbg_kcapi_symsetkey(drbg, key);\n\tlist_for_each_entry(curr, in, list) {\n\t\tconst unsigned char *pos = curr->buf;\n\t\tsize_t len = curr->len;\n\t\t/* 10.4.3 step 4.1 */\n\t\twhile (len) {\n\t\t\t/* 10.4.3 step 4.2 */\n\t\t\tif (drbg_blocklen(drbg) == cnt) {\n\t\t\t\tcnt = 0;\n\t\t\t\tret = drbg_kcapi_sym(drbg, out, &data);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tout[cnt] ^= *pos;\n\t\t\tpos++;\n\t\t\tcnt++;\n\t\t\tlen--;\n\t\t}\n\t}\n\t/* 10.4.3 step 4.2 for last block */\n\tif (cnt)\n\t\tret = drbg_kcapi_sym(drbg, out, &data);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "seed",
        "function_name": "drbg_ctr_df",
        "location": {
            "file_path": "crypto/drbg.c",
            "region": {
                "startLine": 424,
                "startColumn": 15,
                "endColumn": 19
            },
            "context": {
                "startLine": 422,
                "endLine": 426,
                "snippet": {
                    "text": "inputlen += seed->len;"
                }
            }
        },
        "function_code": "static int drbg_ctr_df(struct drbg_state *drbg,\n\t\t       unsigned char *df_data, size_t bytes_to_return,\n\t\t       struct list_head *seedlist)\n{\n\tint ret = -EFAULT;\n\tunsigned char L_N[8];\n\t/* S3 is input */\n\tstruct drbg_string S1, S2, S4, cipherin;\n\tLIST_HEAD(bcc_list);\n\tunsigned char *pad = df_data + drbg_statelen(drbg);\n\tunsigned char *iv = pad + drbg_blocklen(drbg);\n\tunsigned char *temp = iv + drbg_blocklen(drbg);\n\tsize_t padlen = 0;\n\tunsigned int templen = 0;\n\t/* 10.4.2 step 7 */\n\tunsigned int i = 0;\n\t/* 10.4.2 step 8 */\n\tconst unsigned char *K = (unsigned char *)\n\t\t\t   \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n\t\t\t   \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\"\n\t\t\t   \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\"\n\t\t\t   \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\";\n\tunsigned char *X;\n\tsize_t generated_len = 0;\n\tsize_t inputlen = 0;\n\tstruct drbg_string *seed = NULL;\n\n\tmemset(pad, 0, drbg_blocklen(drbg));\n\tmemset(iv, 0, drbg_blocklen(drbg));\n\n\t/* 10.4.2 step 1 is implicit as we work byte-wise */\n\n\t/* 10.4.2 step 2 */\n\tif ((512/8) < bytes_to_return)\n\t\treturn -EINVAL;\n\n\t/* 10.4.2 step 2 -- calculate the entire length of all input data */\n\tlist_for_each_entry(seed, seedlist, list)\n\t\tinputlen += seed->len;\n\tdrbg_cpu_to_be32(inputlen, &L_N[0]);\n\n\t/* 10.4.2 step 3 */\n\tdrbg_cpu_to_be32(bytes_to_return, &L_N[4]);\n\n\t/* 10.4.2 step 5: length is L_N, input_string, one byte, padding */\n\tpadlen = (inputlen + sizeof(L_N) + 1) % (drbg_blocklen(drbg));\n\t/* wrap the padlen appropriately */\n\tif (padlen)\n\t\tpadlen = drbg_blocklen(drbg) - padlen;\n\t/*\n\t * pad / padlen contains the 0x80 byte and the following zero bytes.\n\t * As the calculated padlen value only covers the number of zero\n\t * bytes, this value has to be incremented by one for the 0x80 byte.\n\t */\n\tpadlen++;\n\tpad[0] = 0x80;\n\n\t/* 10.4.2 step 4 -- first fill the linked list and then order it */\n\tdrbg_string_fill(&S1, iv, drbg_blocklen(drbg));\n\tlist_add_tail(&S1.list, &bcc_list);\n\tdrbg_string_fill(&S2, L_N, sizeof(L_N));\n\tlist_add_tail(&S2.list, &bcc_list);\n\tlist_splice_tail(seedlist, &bcc_list);\n\tdrbg_string_fill(&S4, pad, padlen);\n\tlist_add_tail(&S4.list, &bcc_list);\n\n\t/* 10.4.2 step 9 */\n\twhile (templen < (drbg_keylen(drbg) + (drbg_blocklen(drbg)))) {\n\t\t/*\n\t\t * 10.4.2 step 9.1 - the padding is implicit as the buffer\n\t\t * holds zeros after allocation -- even the increment of i\n\t\t * is irrelevant as the increment remains within length of i\n\t\t */\n\t\tdrbg_cpu_to_be32(i, iv);\n\t\t/* 10.4.2 step 9.2 -- BCC and concatenation with temp */\n\t\tret = drbg_ctr_bcc(drbg, temp + templen, K, &bcc_list);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\t/* 10.4.2 step 9.3 */\n\t\ti++;\n\t\ttemplen += drbg_blocklen(drbg);\n\t}\n\n\t/* 10.4.2 step 11 */\n\tX = temp + (drbg_keylen(drbg));\n\tdrbg_string_fill(&cipherin, X, drbg_blocklen(drbg));\n\n\t/* 10.4.2 step 12: overwriting of outval is implemented in next step */\n\n\t/* 10.4.2 step 13 */\n\tdrbg_kcapi_symsetkey(drbg, temp);\n\twhile (generated_len < bytes_to_return) {\n\t\tshort blocklen = 0;\n\t\t/*\n\t\t * 10.4.2 step 13.1: the truncation of the key length is\n\t\t * implicit as the key is only drbg_blocklen in size based on\n\t\t * the implementation of the cipher function callback\n\t\t */\n\t\tret = drbg_kcapi_sym(drbg, X, &cipherin);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tblocklen = (drbg_blocklen(drbg) <\n\t\t\t\t(bytes_to_return - generated_len)) ?\n\t\t\t    drbg_blocklen(drbg) :\n\t\t\t\t(bytes_to_return - generated_len);\n\t\t/* 10.4.2 step 13.2 and 14 */\n\t\tmemcpy(df_data + generated_len, X, blocklen);\n\t\tgenerated_len += blocklen;\n\t}\n\n\tret = 0;\n\nout:\n\tmemset(iv, 0, drbg_blocklen(drbg));\n\tmemset(temp, 0, drbg_statelen(drbg) + drbg_blocklen(drbg));\n\tmemset(pad, 0, drbg_blocklen(drbg));\n\treturn ret;\n}"
    },
    {
        "var_name": "input",
        "function_name": "drbg_kcapi_hash",
        "location": {
            "file_path": "crypto/drbg.c",
            "region": {
                "startLine": 1715,
                "startColumn": 38,
                "endColumn": 43
            },
            "context": {
                "startLine": 1713,
                "endLine": 1717,
                "snippet": {
                    "text": "crypto_shash_update(&sdesc->shash, input->buf, input->len);"
                }
            }
        },
        "function_code": "static int drbg_kcapi_hash(struct drbg_state *drbg, unsigned char *outval,\n\t\t\t   const struct list_head *in)\n{\n\tstruct sdesc *sdesc = drbg->priv_data;\n\tstruct drbg_string *input = NULL;\n\n\tcrypto_shash_init(&sdesc->shash);\n\tlist_for_each_entry(input, in, list)\n\t\tcrypto_shash_update(&sdesc->shash, input->buf, input->len);\n\treturn crypto_shash_final(&sdesc->shash, outval);\n}"
    },
    {
        "var_name": "pgt_info",
        "function_name": "hl_mmu_dr_get_pgt_info",
        "location": {
            "file_path": "drivers/accel/habanalabs/common/mmu/mmu.c",
            "region": {
                "startLine": 1221,
                "startColumn": 19,
                "endColumn": 27
            },
            "context": {
                "startLine": 1219,
                "endLine": 1223,
                "snippet": {
                    "text": "if (hop_addr == pgt_info->shadow_addr)"
                }
            }
        },
        "function_code": "struct pgt_info *hl_mmu_dr_get_pgt_info(struct hl_ctx *ctx, u64 hop_addr)\n{\n\tstruct pgt_info *pgt_info = NULL;\n\n\thash_for_each_possible(ctx->mmu_shadow_hash, pgt_info, node,\n\t\t\t(unsigned long) hop_addr)\n\t\tif (hop_addr == pgt_info->shadow_addr)\n\t\t\tbreak;\n\n\treturn pgt_info;\n}"
    },
    {
        "var_name": "pgt_info",
        "function_name": "hl_mmu_v2_hr_get_pgt_info",
        "location": {
            "file_path": "drivers/accel/habanalabs/common/mmu/mmu_v2_hr.c",
            "region": {
                "startLine": 19,
                "startColumn": 24,
                "endColumn": 32
            },
            "context": {
                "startLine": 17,
                "endLine": 21,
                "snippet": {
                    "text": "if (phys_hop_addr == pgt_info->phys_addr)"
                }
            }
        },
        "function_code": "static struct pgt_info *hl_mmu_v2_hr_get_pgt_info(struct hl_ctx *ctx, u64 phys_hop_addr)\n{\n\tstruct pgt_info *pgt_info = NULL;\n\n\thash_for_each_possible(ctx->hr_mmu_phys_hash, pgt_info, node,\n\t\t\t\t(unsigned long) phys_hop_addr)\n\t\tif (phys_hop_addr == pgt_info->phys_addr)\n\t\t\tbreak;\n\n\treturn pgt_info;\n}"
    },
    {
        "var_name": "file_priv",
        "function_name": "ivpu_file_priv_put",
        "location": {
            "file_path": "drivers/accel/ivpu/ivpu_drv.c",
            "region": {
                "startLine": 107,
                "startColumn": 29,
                "endColumn": 38
            },
            "context": {
                "startLine": 105,
                "endLine": 109,
                "snippet": {
                    "text": "struct ivpu_device *vdev = file_priv->vdev;"
                }
            }
        },
        "function_code": "void ivpu_file_priv_put(struct ivpu_file_priv **link)\n{\n\tstruct ivpu_file_priv *file_priv = *link;\n\tstruct ivpu_device *vdev = file_priv->vdev;\n\n\tdrm_WARN_ON(&vdev->drm, !file_priv);\n\n\tivpu_dbg(vdev, KREF, \"file_priv put: ctx %u refcount %u\\n\",\n\t\t file_priv->ctx.id, kref_read(&file_priv->ref));\n\n\t*link = NULL;\n\tkref_put(&file_priv->ref, file_priv_release);\n}"
    },
    {
        "var_name": "thread",
        "function_name": "acpi_ds_dump_method_stack",
        "location": {
            "file_path": "drivers/acpi/acpica/dsdebug.c",
            "region": {
                "startLine": 137,
                "startColumn": 20,
                "endColumn": 26
            },
            "context": {
                "startLine": 135,
                "endLine": 139,
                "snippet": {
                    "text": "next_walk_state = thread->walk_state_list;"
                }
            }
        },
        "function_code": "void\nacpi_ds_dump_method_stack(acpi_status status,\n\t\t\t  struct acpi_walk_state *walk_state,\n\t\t\t  union acpi_parse_object *op)\n{\n\tunion acpi_parse_object *next;\n\tstruct acpi_thread_state *thread;\n\tstruct acpi_walk_state *next_walk_state;\n\tstruct acpi_namespace_node *previous_method = NULL;\n\tunion acpi_operand_object *method_desc;\n\n\tACPI_FUNCTION_TRACE(ds_dump_method_stack);\n\n\t/* Ignore control codes, they are not errors */\n\n\tif (ACPI_CNTL_EXCEPTION(status)) {\n\t\treturn_VOID;\n\t}\n\n\t/* We may be executing a deferred opcode */\n\n\tif (walk_state->deferred_node) {\n\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t\t  \"Executing subtree for Buffer/Package/Region\\n\"));\n\t\treturn_VOID;\n\t}\n\n\t/*\n\t * If there is no Thread, we are not actually executing a method.\n\t * This can happen when the iASL compiler calls the interpreter\n\t * to perform constant folding.\n\t */\n\tthread = walk_state->thread;\n\tif (!thread) {\n\t\treturn_VOID;\n\t}\n\n\t/* Display exception and method name */\n\n\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t  \"\\n**** Exception %s during execution of method \",\n\t\t\t  acpi_format_exception(status)));\n\n\tacpi_ds_print_node_pathname(walk_state->method_node, NULL);\n\n\t/* Display stack of executing methods */\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_DISPATCH,\n\t\t\t      \"\\n\\nMethod Execution Stack:\\n\"));\n\tnext_walk_state = thread->walk_state_list;\n\n\t/* Walk list of linked walk states */\n\n\twhile (next_walk_state) {\n\t\tmethod_desc = next_walk_state->method_desc;\n\t\tif (method_desc) {\n\t\t\tacpi_ex_stop_trace_method((struct acpi_namespace_node *)\n\t\t\t\t\t\t  method_desc->method.node,\n\t\t\t\t\t\t  method_desc, walk_state);\n\t\t}\n\n\t\tACPI_DEBUG_PRINT((ACPI_DB_DISPATCH,\n\t\t\t\t  \"    Method [%4.4s] executing: \",\n\t\t\t\t  acpi_ut_get_node_name(next_walk_state->\n\t\t\t\t\t\t\tmethod_node)));\n\n\t\t/* First method is the currently executing method */\n\n\t\tif (next_walk_state == walk_state) {\n\t\t\tif (op) {\n\n\t\t\t\t/* Display currently executing ASL statement */\n\n\t\t\t\tnext = op->common.next;\n\t\t\t\top->common.next = NULL;\n\n#ifdef ACPI_DISASSEMBLER\n\t\t\t\tif (walk_state->method_node !=\n\t\t\t\t    acpi_gbl_root_node) {\n\n\t\t\t\t\t/* More verbose if not module-level code */\n\n\t\t\t\t\tacpi_os_printf(\"Failed at \");\n\t\t\t\t\tacpi_dm_disassemble(next_walk_state, op,\n\t\t\t\t\t\t\t    ACPI_UINT32_MAX);\n\t\t\t\t}\n#endif\n\t\t\t\top->common.next = next;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * This method has called another method\n\t\t\t * NOTE: the method call parse subtree is already deleted at\n\t\t\t * this point, so we cannot disassemble the method invocation.\n\t\t\t */\n\t\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_DISPATCH,\n\t\t\t\t\t      \"Call to method \"));\n\t\t\tacpi_ds_print_node_pathname(previous_method, NULL);\n\t\t}\n\n\t\tprevious_method = next_walk_state->method_node;\n\t\tnext_walk_state = next_walk_state->next;\n\t\tACPI_DEBUG_PRINT_RAW((ACPI_DB_DISPATCH, \"\\n\"));\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "walk_state",
        "function_name": "acpi_ds_delete_walk_state",
        "location": {
            "file_path": "drivers/acpi/acpica/dswstate.c",
            "region": {
                "startLine": 685,
                "startColumn": 6,
                "endColumn": 16
            },
            "context": {
                "startLine": 683,
                "endLine": 687,
                "snippet": {
                    "text": "if (walk_state->descriptor_type != ACPI_DESC_TYPE_WALK) {"
                }
            }
        },
        "function_code": "void acpi_ds_delete_walk_state(struct acpi_walk_state *walk_state)\n{\n\tunion acpi_generic_state *state;\n\n\tACPI_FUNCTION_TRACE_PTR(ds_delete_walk_state, walk_state);\n\n\tif (!walk_state) {\n\t\treturn_VOID;\n\t}\n\n\tif (walk_state->descriptor_type != ACPI_DESC_TYPE_WALK) {\n\t\tACPI_ERROR((AE_INFO, \"%p is not a valid walk state\",\n\t\t\t    walk_state));\n\t\treturn_VOID;\n\t}\n\n\t/* There should not be any open scopes */\n\n\tif (walk_state->parser_state.scope) {\n\t\tACPI_ERROR((AE_INFO, \"%p walk still has a scope list\",\n\t\t\t    walk_state));\n\t\tacpi_ps_cleanup_scope(&walk_state->parser_state);\n\t}\n\n\t/* Always must free any linked control states */\n\n\twhile (walk_state->control_state) {\n\t\tstate = walk_state->control_state;\n\t\twalk_state->control_state = state->common.next;\n\n\t\tacpi_ut_delete_generic_state(state);\n\t}\n\n\t/* Always must free any linked parse states */\n\n\twhile (walk_state->scope_info) {\n\t\tstate = walk_state->scope_info;\n\t\twalk_state->scope_info = state->common.next;\n\n\t\tacpi_ut_delete_generic_state(state);\n\t}\n\n\t/* Always must free any stacked result states */\n\n\twhile (walk_state->results) {\n\t\tstate = walk_state->results;\n\t\twalk_state->results = state->common.next;\n\n\t\tacpi_ut_delete_generic_state(state);\n\t}\n\n\tACPI_FREE(walk_state);\n\treturn_VOID;\n}"
    },
    {
        "var_name": "(union acpi_descriptor*)(void*)(source_desc)",
        "function_name": "acpi_ex_do_debug_object",
        "location": {
            "file_path": "drivers/acpi/acpica/exdebug.c",
            "region": {
                "startLine": 103,
                "startColumn": 6,
                "endColumn": 50
            },
            "context": {
                "startLine": 101,
                "endLine": 105,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_do_debug_object(union acpi_operand_object *source_desc,\n\t\t\tu32 level, u32 index)\n{\n\tu32 i;\n\tu32 timer;\n\tunion acpi_operand_object *object_desc;\n\tu32 value;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_do_debug_object, source_desc);\n\n\t/* Output must be enabled via the debug_object global or the dbg_level */\n\n\tif (!acpi_gbl_enable_aml_debug_object &&\n\t    !(acpi_dbg_level & ACPI_LV_DEBUG_OBJECT)) {\n\t\treturn_VOID;\n\t}\n\n\t/* Newline -- don't emit the line header */\n\n\tif (source_desc &&\n\t    (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) &&\n\t    (source_desc->common.type == ACPI_TYPE_STRING)) {\n\t\tif ((source_desc->string.length == 1) &&\n\t\t    (*source_desc->string.pointer == '\\n')) {\n\t\t\tacpi_os_printf(\"\\n\");\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\t/*\n\t * Print line header as long as we are not in the middle of an\n\t * object display\n\t */\n\tif (!((level > 0) && index == 0)) {\n\t\tif (acpi_gbl_display_debug_timer) {\n\t\t\t/*\n\t\t\t * We will emit the current timer value (in microseconds) with each\n\t\t\t * debug output. Only need the lower 26 bits. This allows for 67\n\t\t\t * million microseconds or 67 seconds before rollover.\n\t\t\t *\n\t\t\t * Convert 100 nanosecond units to microseconds\n\t\t\t */\n\t\t\ttimer = ((u32)acpi_os_get_timer() / 10);\n\t\t\ttimer &= 0x03FFFFFF;\n\n\t\t\tacpi_os_printf(\"ACPI Debug: T=0x%8.8X %*s\", timer,\n\t\t\t\t       level, \" \");\n\t\t} else {\n\t\t\tacpi_os_printf(\"ACPI Debug: %*s\", level, \" \");\n\t\t}\n\t}\n\n\t/* Display the index for package output only */\n\n\tif (index > 0) {\n\t\tacpi_os_printf(\"(%.2u) \", index - 1);\n\t}\n\n\tif (!source_desc) {\n\t\tacpi_os_printf(\"[Null Object]\\n\");\n\t\treturn_VOID;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) {\n\n\t\t/* No object type prefix needed for integers and strings */\n\n\t\tif ((source_desc->common.type != ACPI_TYPE_INTEGER) &&\n\t\t    (source_desc->common.type != ACPI_TYPE_STRING)) {\n\t\t\tacpi_os_printf(\"%s \",\n\t\t\t\t       acpi_ut_get_object_type_name\n\t\t\t\t       (source_desc));\n\t\t}\n\n\t\tif (!acpi_ut_valid_internal_object(source_desc)) {\n\t\t\tacpi_os_printf(\"%p, Invalid Internal Object!\\n\",\n\t\t\t\t       source_desc);\n\t\t\treturn_VOID;\n\t\t}\n\t} else if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) ==\n\t\t   ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_os_printf(\"%s (Node %p)\\n\",\n\t\t\t       acpi_ut_get_type_name(((struct\n\t\t\t\t\t\t       acpi_namespace_node *)\n\t\t\t\t\t\t      source_desc)->type),\n\t\t\t       source_desc);\n\t\treturn_VOID;\n\t} else {\n\t\treturn_VOID;\n\t}\n\n\t/* source_desc is of type ACPI_DESC_TYPE_OPERAND */\n\n\tswitch (source_desc->common.type) {\n\tcase ACPI_TYPE_INTEGER:\n\n\t\t/* Output correct integer width */\n\n\t\tif (acpi_gbl_integer_byte_width == 4) {\n\t\t\tacpi_os_printf(\"0x%8.8X\\n\",\n\t\t\t\t       (u32)source_desc->integer.value);\n\t\t} else {\n\t\t\tacpi_os_printf(\"0x%8.8X%8.8X\\n\",\n\t\t\t\t       ACPI_FORMAT_UINT64(source_desc->integer.\n\t\t\t\t\t\t\t  value));\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tacpi_os_printf(\"[0x%.2X]\\n\", (u32)source_desc->buffer.length);\n\t\tacpi_ut_dump_buffer(source_desc->buffer.pointer,\n\t\t\t\t    (source_desc->buffer.length < 256) ?\n\t\t\t\t    source_desc->buffer.length : 256,\n\t\t\t\t    DB_BYTE_DISPLAY, 0);\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\tacpi_os_printf(\"\\\"%s\\\"\\n\", source_desc->string.pointer);\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\tacpi_os_printf(\"(Contains 0x%.2X Elements):\\n\",\n\t\t\t       source_desc->package.count);\n\n\t\t/* Output the entire contents of the package */\n\n\t\tfor (i = 0; i < source_desc->package.count; i++) {\n\t\t\tacpi_ex_do_debug_object(source_desc->package.\n\t\t\t\t\t\telements[i], level + 4, i + 1);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\n\t\tacpi_os_printf(\"[%s] \",\n\t\t\t       acpi_ut_get_reference_name(source_desc));\n\n\t\t/* Decode the reference */\n\n\t\tswitch (source_desc->reference.class) {\n\t\tcase ACPI_REFCLASS_INDEX:\n\n\t\t\tacpi_os_printf(\"0x%X\\n\", source_desc->reference.value);\n\t\t\tbreak;\n\n\t\tcase ACPI_REFCLASS_TABLE:\n\n\t\t\t/* Case for ddb_handle */\n\n\t\t\tacpi_os_printf(\"Table Index 0x%X\\n\",\n\t\t\t\t       source_desc->reference.value);\n\t\t\treturn_VOID;\n\n\t\tdefault:\n\n\t\t\tbreak;\n\t\t}\n\n\t\tacpi_os_printf(\" \");\n\n\t\t/* Check for valid node first, then valid object */\n\n\t\tif (source_desc->reference.node) {\n\t\t\tif (ACPI_GET_DESCRIPTOR_TYPE\n\t\t\t    (source_desc->reference.node) !=\n\t\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\" %p - Not a valid namespace node\\n\",\n\t\t\t\t     source_desc->reference.node);\n\t\t\t} else {\n\t\t\t\tacpi_os_printf(\"Node %p [%4.4s] \",\n\t\t\t\t\t       source_desc->reference.node,\n\t\t\t\t\t       (source_desc->reference.node)->\n\t\t\t\t\t       name.ascii);\n\n\t\t\t\tswitch ((source_desc->reference.node)->type) {\n\n\t\t\t\t\t/* These types have no attached object */\n\n\t\t\t\tcase ACPI_TYPE_DEVICE:\n\t\t\t\t\tacpi_os_printf(\"Device\\n\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_THERMAL:\n\t\t\t\t\tacpi_os_printf(\"Thermal Zone\\n\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tacpi_ex_do_debug_object((source_desc->\n\t\t\t\t\t\t\t\t reference.\n\t\t\t\t\t\t\t\t node)->object,\n\t\t\t\t\t\t\t\tlevel + 4, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (source_desc->reference.object) {\n\t\t\tif (ACPI_GET_DESCRIPTOR_TYPE\n\t\t\t    (source_desc->reference.object) ==\n\t\t\t    ACPI_DESC_TYPE_NAMED) {\n\n\t\t\t\t/* Reference object is a namespace node */\n\n\t\t\t\tacpi_ex_do_debug_object(ACPI_CAST_PTR\n\t\t\t\t\t\t\t(union\n\t\t\t\t\t\t\t acpi_operand_object,\n\t\t\t\t\t\t\t source_desc->reference.\n\t\t\t\t\t\t\t object), level + 4, 0);\n\t\t\t} else {\n\t\t\t\tobject_desc = source_desc->reference.object;\n\t\t\t\tvalue = source_desc->reference.value;\n\n\t\t\t\tswitch (object_desc->common.type) {\n\t\t\t\tcase ACPI_TYPE_BUFFER:\n\n\t\t\t\t\tacpi_os_printf(\"Buffer[%u] = 0x%2.2X\\n\",\n\t\t\t\t\t\t       value,\n\t\t\t\t\t\t       *source_desc->reference.\n\t\t\t\t\t\t       index_pointer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_STRING:\n\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"String[%u] = \\\"%c\\\" (0x%2.2X)\\n\",\n\t\t\t\t\t     value,\n\t\t\t\t\t     *source_desc->reference.\n\t\t\t\t\t     index_pointer,\n\t\t\t\t\t     *source_desc->reference.\n\t\t\t\t\t     index_pointer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_PACKAGE:\n\n\t\t\t\t\tacpi_os_printf(\"Package[%u] = \", value);\n\t\t\t\t\tif (!(*source_desc->reference.where)) {\n\t\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t\t    (\"[Uninitialized Package Element]\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tacpi_ex_do_debug_object\n\t\t\t\t\t\t    (*source_desc->reference.\n\t\t\t\t\t\t     where, level + 4, 0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"Unknown Reference object type %X\\n\",\n\t\t\t\t\t     object_desc->common.type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tacpi_os_printf(\"(Descriptor %p)\\n\", source_desc);\n\t\tbreak;\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC, \"\\n\"));\n\treturn_VOID;\n}"
    },
    {
        "var_name": "(void*)(source_desc)",
        "function_name": "acpi_ex_do_debug_object",
        "location": {
            "file_path": "drivers/acpi/acpica/exdebug.c",
            "region": {
                "startLine": 103,
                "startColumn": 6,
                "endColumn": 26
            },
            "context": {
                "startLine": 101,
                "endLine": 105,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_do_debug_object(union acpi_operand_object *source_desc,\n\t\t\tu32 level, u32 index)\n{\n\tu32 i;\n\tu32 timer;\n\tunion acpi_operand_object *object_desc;\n\tu32 value;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_do_debug_object, source_desc);\n\n\t/* Output must be enabled via the debug_object global or the dbg_level */\n\n\tif (!acpi_gbl_enable_aml_debug_object &&\n\t    !(acpi_dbg_level & ACPI_LV_DEBUG_OBJECT)) {\n\t\treturn_VOID;\n\t}\n\n\t/* Newline -- don't emit the line header */\n\n\tif (source_desc &&\n\t    (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) &&\n\t    (source_desc->common.type == ACPI_TYPE_STRING)) {\n\t\tif ((source_desc->string.length == 1) &&\n\t\t    (*source_desc->string.pointer == '\\n')) {\n\t\t\tacpi_os_printf(\"\\n\");\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\t/*\n\t * Print line header as long as we are not in the middle of an\n\t * object display\n\t */\n\tif (!((level > 0) && index == 0)) {\n\t\tif (acpi_gbl_display_debug_timer) {\n\t\t\t/*\n\t\t\t * We will emit the current timer value (in microseconds) with each\n\t\t\t * debug output. Only need the lower 26 bits. This allows for 67\n\t\t\t * million microseconds or 67 seconds before rollover.\n\t\t\t *\n\t\t\t * Convert 100 nanosecond units to microseconds\n\t\t\t */\n\t\t\ttimer = ((u32)acpi_os_get_timer() / 10);\n\t\t\ttimer &= 0x03FFFFFF;\n\n\t\t\tacpi_os_printf(\"ACPI Debug: T=0x%8.8X %*s\", timer,\n\t\t\t\t       level, \" \");\n\t\t} else {\n\t\t\tacpi_os_printf(\"ACPI Debug: %*s\", level, \" \");\n\t\t}\n\t}\n\n\t/* Display the index for package output only */\n\n\tif (index > 0) {\n\t\tacpi_os_printf(\"(%.2u) \", index - 1);\n\t}\n\n\tif (!source_desc) {\n\t\tacpi_os_printf(\"[Null Object]\\n\");\n\t\treturn_VOID;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) {\n\n\t\t/* No object type prefix needed for integers and strings */\n\n\t\tif ((source_desc->common.type != ACPI_TYPE_INTEGER) &&\n\t\t    (source_desc->common.type != ACPI_TYPE_STRING)) {\n\t\t\tacpi_os_printf(\"%s \",\n\t\t\t\t       acpi_ut_get_object_type_name\n\t\t\t\t       (source_desc));\n\t\t}\n\n\t\tif (!acpi_ut_valid_internal_object(source_desc)) {\n\t\t\tacpi_os_printf(\"%p, Invalid Internal Object!\\n\",\n\t\t\t\t       source_desc);\n\t\t\treturn_VOID;\n\t\t}\n\t} else if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) ==\n\t\t   ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_os_printf(\"%s (Node %p)\\n\",\n\t\t\t       acpi_ut_get_type_name(((struct\n\t\t\t\t\t\t       acpi_namespace_node *)\n\t\t\t\t\t\t      source_desc)->type),\n\t\t\t       source_desc);\n\t\treturn_VOID;\n\t} else {\n\t\treturn_VOID;\n\t}\n\n\t/* source_desc is of type ACPI_DESC_TYPE_OPERAND */\n\n\tswitch (source_desc->common.type) {\n\tcase ACPI_TYPE_INTEGER:\n\n\t\t/* Output correct integer width */\n\n\t\tif (acpi_gbl_integer_byte_width == 4) {\n\t\t\tacpi_os_printf(\"0x%8.8X\\n\",\n\t\t\t\t       (u32)source_desc->integer.value);\n\t\t} else {\n\t\t\tacpi_os_printf(\"0x%8.8X%8.8X\\n\",\n\t\t\t\t       ACPI_FORMAT_UINT64(source_desc->integer.\n\t\t\t\t\t\t\t  value));\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tacpi_os_printf(\"[0x%.2X]\\n\", (u32)source_desc->buffer.length);\n\t\tacpi_ut_dump_buffer(source_desc->buffer.pointer,\n\t\t\t\t    (source_desc->buffer.length < 256) ?\n\t\t\t\t    source_desc->buffer.length : 256,\n\t\t\t\t    DB_BYTE_DISPLAY, 0);\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\tacpi_os_printf(\"\\\"%s\\\"\\n\", source_desc->string.pointer);\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\tacpi_os_printf(\"(Contains 0x%.2X Elements):\\n\",\n\t\t\t       source_desc->package.count);\n\n\t\t/* Output the entire contents of the package */\n\n\t\tfor (i = 0; i < source_desc->package.count; i++) {\n\t\t\tacpi_ex_do_debug_object(source_desc->package.\n\t\t\t\t\t\telements[i], level + 4, i + 1);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\n\t\tacpi_os_printf(\"[%s] \",\n\t\t\t       acpi_ut_get_reference_name(source_desc));\n\n\t\t/* Decode the reference */\n\n\t\tswitch (source_desc->reference.class) {\n\t\tcase ACPI_REFCLASS_INDEX:\n\n\t\t\tacpi_os_printf(\"0x%X\\n\", source_desc->reference.value);\n\t\t\tbreak;\n\n\t\tcase ACPI_REFCLASS_TABLE:\n\n\t\t\t/* Case for ddb_handle */\n\n\t\t\tacpi_os_printf(\"Table Index 0x%X\\n\",\n\t\t\t\t       source_desc->reference.value);\n\t\t\treturn_VOID;\n\n\t\tdefault:\n\n\t\t\tbreak;\n\t\t}\n\n\t\tacpi_os_printf(\" \");\n\n\t\t/* Check for valid node first, then valid object */\n\n\t\tif (source_desc->reference.node) {\n\t\t\tif (ACPI_GET_DESCRIPTOR_TYPE\n\t\t\t    (source_desc->reference.node) !=\n\t\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\" %p - Not a valid namespace node\\n\",\n\t\t\t\t     source_desc->reference.node);\n\t\t\t} else {\n\t\t\t\tacpi_os_printf(\"Node %p [%4.4s] \",\n\t\t\t\t\t       source_desc->reference.node,\n\t\t\t\t\t       (source_desc->reference.node)->\n\t\t\t\t\t       name.ascii);\n\n\t\t\t\tswitch ((source_desc->reference.node)->type) {\n\n\t\t\t\t\t/* These types have no attached object */\n\n\t\t\t\tcase ACPI_TYPE_DEVICE:\n\t\t\t\t\tacpi_os_printf(\"Device\\n\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_THERMAL:\n\t\t\t\t\tacpi_os_printf(\"Thermal Zone\\n\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tacpi_ex_do_debug_object((source_desc->\n\t\t\t\t\t\t\t\t reference.\n\t\t\t\t\t\t\t\t node)->object,\n\t\t\t\t\t\t\t\tlevel + 4, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (source_desc->reference.object) {\n\t\t\tif (ACPI_GET_DESCRIPTOR_TYPE\n\t\t\t    (source_desc->reference.object) ==\n\t\t\t    ACPI_DESC_TYPE_NAMED) {\n\n\t\t\t\t/* Reference object is a namespace node */\n\n\t\t\t\tacpi_ex_do_debug_object(ACPI_CAST_PTR\n\t\t\t\t\t\t\t(union\n\t\t\t\t\t\t\t acpi_operand_object,\n\t\t\t\t\t\t\t source_desc->reference.\n\t\t\t\t\t\t\t object), level + 4, 0);\n\t\t\t} else {\n\t\t\t\tobject_desc = source_desc->reference.object;\n\t\t\t\tvalue = source_desc->reference.value;\n\n\t\t\t\tswitch (object_desc->common.type) {\n\t\t\t\tcase ACPI_TYPE_BUFFER:\n\n\t\t\t\t\tacpi_os_printf(\"Buffer[%u] = 0x%2.2X\\n\",\n\t\t\t\t\t\t       value,\n\t\t\t\t\t\t       *source_desc->reference.\n\t\t\t\t\t\t       index_pointer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_STRING:\n\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"String[%u] = \\\"%c\\\" (0x%2.2X)\\n\",\n\t\t\t\t\t     value,\n\t\t\t\t\t     *source_desc->reference.\n\t\t\t\t\t     index_pointer,\n\t\t\t\t\t     *source_desc->reference.\n\t\t\t\t\t     index_pointer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_PACKAGE:\n\n\t\t\t\t\tacpi_os_printf(\"Package[%u] = \", value);\n\t\t\t\t\tif (!(*source_desc->reference.where)) {\n\t\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t\t    (\"[Uninitialized Package Element]\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tacpi_ex_do_debug_object\n\t\t\t\t\t\t    (*source_desc->reference.\n\t\t\t\t\t\t     where, level + 4, 0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"Unknown Reference object type %X\\n\",\n\t\t\t\t\t     object_desc->common.type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tacpi_os_printf(\"(Descriptor %p)\\n\", source_desc);\n\t\tbreak;\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC, \"\\n\"));\n\treturn_VOID;\n}"
    },
    {
        "var_name": "source_desc",
        "function_name": "acpi_ex_do_debug_object",
        "location": {
            "file_path": "drivers/acpi/acpica/exdebug.c",
            "region": {
                "startLine": 103,
                "startColumn": 6,
                "endColumn": 17
            },
            "context": {
                "startLine": 101,
                "endLine": 105,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_do_debug_object(union acpi_operand_object *source_desc,\n\t\t\tu32 level, u32 index)\n{\n\tu32 i;\n\tu32 timer;\n\tunion acpi_operand_object *object_desc;\n\tu32 value;\n\n\tACPI_FUNCTION_TRACE_PTR(ex_do_debug_object, source_desc);\n\n\t/* Output must be enabled via the debug_object global or the dbg_level */\n\n\tif (!acpi_gbl_enable_aml_debug_object &&\n\t    !(acpi_dbg_level & ACPI_LV_DEBUG_OBJECT)) {\n\t\treturn_VOID;\n\t}\n\n\t/* Newline -- don't emit the line header */\n\n\tif (source_desc &&\n\t    (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) &&\n\t    (source_desc->common.type == ACPI_TYPE_STRING)) {\n\t\tif ((source_desc->string.length == 1) &&\n\t\t    (*source_desc->string.pointer == '\\n')) {\n\t\t\tacpi_os_printf(\"\\n\");\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\t/*\n\t * Print line header as long as we are not in the middle of an\n\t * object display\n\t */\n\tif (!((level > 0) && index == 0)) {\n\t\tif (acpi_gbl_display_debug_timer) {\n\t\t\t/*\n\t\t\t * We will emit the current timer value (in microseconds) with each\n\t\t\t * debug output. Only need the lower 26 bits. This allows for 67\n\t\t\t * million microseconds or 67 seconds before rollover.\n\t\t\t *\n\t\t\t * Convert 100 nanosecond units to microseconds\n\t\t\t */\n\t\t\ttimer = ((u32)acpi_os_get_timer() / 10);\n\t\t\ttimer &= 0x03FFFFFF;\n\n\t\t\tacpi_os_printf(\"ACPI Debug: T=0x%8.8X %*s\", timer,\n\t\t\t\t       level, \" \");\n\t\t} else {\n\t\t\tacpi_os_printf(\"ACPI Debug: %*s\", level, \" \");\n\t\t}\n\t}\n\n\t/* Display the index for package output only */\n\n\tif (index > 0) {\n\t\tacpi_os_printf(\"(%.2u) \", index - 1);\n\t}\n\n\tif (!source_desc) {\n\t\tacpi_os_printf(\"[Null Object]\\n\");\n\t\treturn_VOID;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(source_desc) == ACPI_DESC_TYPE_OPERAND) {\n\n\t\t/* No object type prefix needed for integers and strings */\n\n\t\tif ((source_desc->common.type != ACPI_TYPE_INTEGER) &&\n\t\t    (source_desc->common.type != ACPI_TYPE_STRING)) {\n\t\t\tacpi_os_printf(\"%s \",\n\t\t\t\t       acpi_ut_get_object_type_name\n\t\t\t\t       (source_desc));\n\t\t}\n\n\t\tif (!acpi_ut_valid_internal_object(source_desc)) {\n\t\t\tacpi_os_printf(\"%p, Invalid Internal Object!\\n\",\n\t\t\t\t       source_desc);\n\t\t\treturn_VOID;\n\t\t}\n\t} else if (ACPI_GET_DESCRIPTOR_TYPE(source_desc) ==\n\t\t   ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_os_printf(\"%s (Node %p)\\n\",\n\t\t\t       acpi_ut_get_type_name(((struct\n\t\t\t\t\t\t       acpi_namespace_node *)\n\t\t\t\t\t\t      source_desc)->type),\n\t\t\t       source_desc);\n\t\treturn_VOID;\n\t} else {\n\t\treturn_VOID;\n\t}\n\n\t/* source_desc is of type ACPI_DESC_TYPE_OPERAND */\n\n\tswitch (source_desc->common.type) {\n\tcase ACPI_TYPE_INTEGER:\n\n\t\t/* Output correct integer width */\n\n\t\tif (acpi_gbl_integer_byte_width == 4) {\n\t\t\tacpi_os_printf(\"0x%8.8X\\n\",\n\t\t\t\t       (u32)source_desc->integer.value);\n\t\t} else {\n\t\t\tacpi_os_printf(\"0x%8.8X%8.8X\\n\",\n\t\t\t\t       ACPI_FORMAT_UINT64(source_desc->integer.\n\t\t\t\t\t\t\t  value));\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_BUFFER:\n\n\t\tacpi_os_printf(\"[0x%.2X]\\n\", (u32)source_desc->buffer.length);\n\t\tacpi_ut_dump_buffer(source_desc->buffer.pointer,\n\t\t\t\t    (source_desc->buffer.length < 256) ?\n\t\t\t\t    source_desc->buffer.length : 256,\n\t\t\t\t    DB_BYTE_DISPLAY, 0);\n\t\tbreak;\n\n\tcase ACPI_TYPE_STRING:\n\n\t\tacpi_os_printf(\"\\\"%s\\\"\\n\", source_desc->string.pointer);\n\t\tbreak;\n\n\tcase ACPI_TYPE_PACKAGE:\n\n\t\tacpi_os_printf(\"(Contains 0x%.2X Elements):\\n\",\n\t\t\t       source_desc->package.count);\n\n\t\t/* Output the entire contents of the package */\n\n\t\tfor (i = 0; i < source_desc->package.count; i++) {\n\t\t\tacpi_ex_do_debug_object(source_desc->package.\n\t\t\t\t\t\telements[i], level + 4, i + 1);\n\t\t}\n\t\tbreak;\n\n\tcase ACPI_TYPE_LOCAL_REFERENCE:\n\n\t\tacpi_os_printf(\"[%s] \",\n\t\t\t       acpi_ut_get_reference_name(source_desc));\n\n\t\t/* Decode the reference */\n\n\t\tswitch (source_desc->reference.class) {\n\t\tcase ACPI_REFCLASS_INDEX:\n\n\t\t\tacpi_os_printf(\"0x%X\\n\", source_desc->reference.value);\n\t\t\tbreak;\n\n\t\tcase ACPI_REFCLASS_TABLE:\n\n\t\t\t/* Case for ddb_handle */\n\n\t\t\tacpi_os_printf(\"Table Index 0x%X\\n\",\n\t\t\t\t       source_desc->reference.value);\n\t\t\treturn_VOID;\n\n\t\tdefault:\n\n\t\t\tbreak;\n\t\t}\n\n\t\tacpi_os_printf(\" \");\n\n\t\t/* Check for valid node first, then valid object */\n\n\t\tif (source_desc->reference.node) {\n\t\t\tif (ACPI_GET_DESCRIPTOR_TYPE\n\t\t\t    (source_desc->reference.node) !=\n\t\t\t    ACPI_DESC_TYPE_NAMED) {\n\t\t\t\tacpi_os_printf\n\t\t\t\t    (\" %p - Not a valid namespace node\\n\",\n\t\t\t\t     source_desc->reference.node);\n\t\t\t} else {\n\t\t\t\tacpi_os_printf(\"Node %p [%4.4s] \",\n\t\t\t\t\t       source_desc->reference.node,\n\t\t\t\t\t       (source_desc->reference.node)->\n\t\t\t\t\t       name.ascii);\n\n\t\t\t\tswitch ((source_desc->reference.node)->type) {\n\n\t\t\t\t\t/* These types have no attached object */\n\n\t\t\t\tcase ACPI_TYPE_DEVICE:\n\t\t\t\t\tacpi_os_printf(\"Device\\n\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_THERMAL:\n\t\t\t\t\tacpi_os_printf(\"Thermal Zone\\n\");\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tacpi_ex_do_debug_object((source_desc->\n\t\t\t\t\t\t\t\t reference.\n\t\t\t\t\t\t\t\t node)->object,\n\t\t\t\t\t\t\t\tlevel + 4, 0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (source_desc->reference.object) {\n\t\t\tif (ACPI_GET_DESCRIPTOR_TYPE\n\t\t\t    (source_desc->reference.object) ==\n\t\t\t    ACPI_DESC_TYPE_NAMED) {\n\n\t\t\t\t/* Reference object is a namespace node */\n\n\t\t\t\tacpi_ex_do_debug_object(ACPI_CAST_PTR\n\t\t\t\t\t\t\t(union\n\t\t\t\t\t\t\t acpi_operand_object,\n\t\t\t\t\t\t\t source_desc->reference.\n\t\t\t\t\t\t\t object), level + 4, 0);\n\t\t\t} else {\n\t\t\t\tobject_desc = source_desc->reference.object;\n\t\t\t\tvalue = source_desc->reference.value;\n\n\t\t\t\tswitch (object_desc->common.type) {\n\t\t\t\tcase ACPI_TYPE_BUFFER:\n\n\t\t\t\t\tacpi_os_printf(\"Buffer[%u] = 0x%2.2X\\n\",\n\t\t\t\t\t\t       value,\n\t\t\t\t\t\t       *source_desc->reference.\n\t\t\t\t\t\t       index_pointer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_STRING:\n\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"String[%u] = \\\"%c\\\" (0x%2.2X)\\n\",\n\t\t\t\t\t     value,\n\t\t\t\t\t     *source_desc->reference.\n\t\t\t\t\t     index_pointer,\n\t\t\t\t\t     *source_desc->reference.\n\t\t\t\t\t     index_pointer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ACPI_TYPE_PACKAGE:\n\n\t\t\t\t\tacpi_os_printf(\"Package[%u] = \", value);\n\t\t\t\t\tif (!(*source_desc->reference.where)) {\n\t\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t\t    (\"[Uninitialized Package Element]\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tacpi_ex_do_debug_object\n\t\t\t\t\t\t    (*source_desc->reference.\n\t\t\t\t\t\t     where, level + 4, 0);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tacpi_os_printf\n\t\t\t\t\t    (\"Unknown Reference object type %X\\n\",\n\t\t\t\t\t     object_desc->common.type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\n\t\tacpi_os_printf(\"(Descriptor %p)\\n\", source_desc);\n\t\tbreak;\n\t}\n\n\tACPI_DEBUG_PRINT_RAW((ACPI_DB_EXEC, \"\\n\"));\n\treturn_VOID;\n}"
    },
    {
        "var_name": "(union acpi_descriptor*)(void*)(obj_desc)",
        "function_name": "acpi_ex_dump_object_descriptor",
        "location": {
            "file_path": "drivers/acpi/acpica/exdump.c",
            "region": {
                "startLine": 1141,
                "startColumn": 6,
                "endColumn": 47
            },
            "context": {
                "startLine": 1139,
                "endLine": 1143,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)\n{\n\tACPI_FUNCTION_TRACE(ex_dump_object_descriptor);\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (!flags) {\n\n\t\t/* Check if debug output enabled */\n\n\t\tif (!ACPI_IS_DEBUG_ENABLED(ACPI_LV_OBJECTS, _COMPONENT)) {\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_ex_dump_namespace_node((struct acpi_namespace_node *)\n\t\t\t\t\t    obj_desc, flags);\n\n\t\tobj_desc = ((struct acpi_namespace_node *)obj_desc)->object;\n\t\tif (!obj_desc) {\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nAttached Object %p\", obj_desc);\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" - Namespace Node\");\n\t\t}\n\n\t\tacpi_os_printf(\":\\n\");\n\t\tgoto dump_object;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {\n\t\tacpi_os_printf(\"%p is not an ACPI operand object: [%s]\\n\",\n\t\t\t       obj_desc, acpi_ut_get_descriptor_name(obj_desc));\n\t\treturn_VOID;\n\t}\n\n\t/* Validate the object type */\n\n\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Not a known object type: %2.2X\\n\",\n\t\t\t       obj_desc->common.type);\n\t\treturn_VOID;\n\t}\n\ndump_object:\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\t/* Common Fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_common);\n\n\t/* Object-specific fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);\n\n\tif (obj_desc->common.type == ACPI_TYPE_REGION) {\n\t\tobj_desc = obj_desc->common.next_object;\n\t\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Secondary object is not a known object type: %2.2X\\n\",\n\t\t\t     obj_desc->common.type);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nExtra attached Object (%p):\\n\", obj_desc);\n\t\tacpi_ex_dump_object(obj_desc,\n\t\t\t\t    acpi_ex_dump_info[obj_desc->common.type]);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "(void*)(obj_desc)",
        "function_name": "acpi_ex_dump_object_descriptor",
        "location": {
            "file_path": "drivers/acpi/acpica/exdump.c",
            "region": {
                "startLine": 1141,
                "startColumn": 6,
                "endColumn": 23
            },
            "context": {
                "startLine": 1139,
                "endLine": 1143,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)\n{\n\tACPI_FUNCTION_TRACE(ex_dump_object_descriptor);\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (!flags) {\n\n\t\t/* Check if debug output enabled */\n\n\t\tif (!ACPI_IS_DEBUG_ENABLED(ACPI_LV_OBJECTS, _COMPONENT)) {\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_ex_dump_namespace_node((struct acpi_namespace_node *)\n\t\t\t\t\t    obj_desc, flags);\n\n\t\tobj_desc = ((struct acpi_namespace_node *)obj_desc)->object;\n\t\tif (!obj_desc) {\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nAttached Object %p\", obj_desc);\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" - Namespace Node\");\n\t\t}\n\n\t\tacpi_os_printf(\":\\n\");\n\t\tgoto dump_object;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {\n\t\tacpi_os_printf(\"%p is not an ACPI operand object: [%s]\\n\",\n\t\t\t       obj_desc, acpi_ut_get_descriptor_name(obj_desc));\n\t\treturn_VOID;\n\t}\n\n\t/* Validate the object type */\n\n\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Not a known object type: %2.2X\\n\",\n\t\t\t       obj_desc->common.type);\n\t\treturn_VOID;\n\t}\n\ndump_object:\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\t/* Common Fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_common);\n\n\t/* Object-specific fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);\n\n\tif (obj_desc->common.type == ACPI_TYPE_REGION) {\n\t\tobj_desc = obj_desc->common.next_object;\n\t\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Secondary object is not a known object type: %2.2X\\n\",\n\t\t\t     obj_desc->common.type);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nExtra attached Object (%p):\\n\", obj_desc);\n\t\tacpi_ex_dump_object(obj_desc,\n\t\t\t\t    acpi_ex_dump_info[obj_desc->common.type]);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "obj_desc",
        "function_name": "acpi_ex_dump_object_descriptor",
        "location": {
            "file_path": "drivers/acpi/acpica/exdump.c",
            "region": {
                "startLine": 1141,
                "startColumn": 6,
                "endColumn": 14
            },
            "context": {
                "startLine": 1139,
                "endLine": 1143,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)\n{\n\tACPI_FUNCTION_TRACE(ex_dump_object_descriptor);\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (!flags) {\n\n\t\t/* Check if debug output enabled */\n\n\t\tif (!ACPI_IS_DEBUG_ENABLED(ACPI_LV_OBJECTS, _COMPONENT)) {\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_ex_dump_namespace_node((struct acpi_namespace_node *)\n\t\t\t\t\t    obj_desc, flags);\n\n\t\tobj_desc = ((struct acpi_namespace_node *)obj_desc)->object;\n\t\tif (!obj_desc) {\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nAttached Object %p\", obj_desc);\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" - Namespace Node\");\n\t\t}\n\n\t\tacpi_os_printf(\":\\n\");\n\t\tgoto dump_object;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {\n\t\tacpi_os_printf(\"%p is not an ACPI operand object: [%s]\\n\",\n\t\t\t       obj_desc, acpi_ut_get_descriptor_name(obj_desc));\n\t\treturn_VOID;\n\t}\n\n\t/* Validate the object type */\n\n\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Not a known object type: %2.2X\\n\",\n\t\t\t       obj_desc->common.type);\n\t\treturn_VOID;\n\t}\n\ndump_object:\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\t/* Common Fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_common);\n\n\t/* Object-specific fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);\n\n\tif (obj_desc->common.type == ACPI_TYPE_REGION) {\n\t\tobj_desc = obj_desc->common.next_object;\n\t\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Secondary object is not a known object type: %2.2X\\n\",\n\t\t\t     obj_desc->common.type);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nExtra attached Object (%p):\\n\", obj_desc);\n\t\tacpi_ex_dump_object(obj_desc,\n\t\t\t\t    acpi_ex_dump_info[obj_desc->common.type]);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "(union acpi_descriptor*)(void*)(obj_desc)",
        "function_name": "acpi_ex_dump_object_descriptor",
        "location": {
            "file_path": "drivers/acpi/acpica/exdump.c",
            "region": {
                "startLine": 1151,
                "startColumn": 7,
                "endColumn": 48
            },
            "context": {
                "startLine": 1149,
                "endLine": 1153,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)\n{\n\tACPI_FUNCTION_TRACE(ex_dump_object_descriptor);\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (!flags) {\n\n\t\t/* Check if debug output enabled */\n\n\t\tif (!ACPI_IS_DEBUG_ENABLED(ACPI_LV_OBJECTS, _COMPONENT)) {\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_ex_dump_namespace_node((struct acpi_namespace_node *)\n\t\t\t\t\t    obj_desc, flags);\n\n\t\tobj_desc = ((struct acpi_namespace_node *)obj_desc)->object;\n\t\tif (!obj_desc) {\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nAttached Object %p\", obj_desc);\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" - Namespace Node\");\n\t\t}\n\n\t\tacpi_os_printf(\":\\n\");\n\t\tgoto dump_object;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {\n\t\tacpi_os_printf(\"%p is not an ACPI operand object: [%s]\\n\",\n\t\t\t       obj_desc, acpi_ut_get_descriptor_name(obj_desc));\n\t\treturn_VOID;\n\t}\n\n\t/* Validate the object type */\n\n\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Not a known object type: %2.2X\\n\",\n\t\t\t       obj_desc->common.type);\n\t\treturn_VOID;\n\t}\n\ndump_object:\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\t/* Common Fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_common);\n\n\t/* Object-specific fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);\n\n\tif (obj_desc->common.type == ACPI_TYPE_REGION) {\n\t\tobj_desc = obj_desc->common.next_object;\n\t\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Secondary object is not a known object type: %2.2X\\n\",\n\t\t\t     obj_desc->common.type);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nExtra attached Object (%p):\\n\", obj_desc);\n\t\tacpi_ex_dump_object(obj_desc,\n\t\t\t\t    acpi_ex_dump_info[obj_desc->common.type]);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "(void*)(obj_desc)",
        "function_name": "acpi_ex_dump_object_descriptor",
        "location": {
            "file_path": "drivers/acpi/acpica/exdump.c",
            "region": {
                "startLine": 1151,
                "startColumn": 7,
                "endColumn": 24
            },
            "context": {
                "startLine": 1149,
                "endLine": 1153,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)\n{\n\tACPI_FUNCTION_TRACE(ex_dump_object_descriptor);\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (!flags) {\n\n\t\t/* Check if debug output enabled */\n\n\t\tif (!ACPI_IS_DEBUG_ENABLED(ACPI_LV_OBJECTS, _COMPONENT)) {\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_ex_dump_namespace_node((struct acpi_namespace_node *)\n\t\t\t\t\t    obj_desc, flags);\n\n\t\tobj_desc = ((struct acpi_namespace_node *)obj_desc)->object;\n\t\tif (!obj_desc) {\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nAttached Object %p\", obj_desc);\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" - Namespace Node\");\n\t\t}\n\n\t\tacpi_os_printf(\":\\n\");\n\t\tgoto dump_object;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {\n\t\tacpi_os_printf(\"%p is not an ACPI operand object: [%s]\\n\",\n\t\t\t       obj_desc, acpi_ut_get_descriptor_name(obj_desc));\n\t\treturn_VOID;\n\t}\n\n\t/* Validate the object type */\n\n\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Not a known object type: %2.2X\\n\",\n\t\t\t       obj_desc->common.type);\n\t\treturn_VOID;\n\t}\n\ndump_object:\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\t/* Common Fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_common);\n\n\t/* Object-specific fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);\n\n\tif (obj_desc->common.type == ACPI_TYPE_REGION) {\n\t\tobj_desc = obj_desc->common.next_object;\n\t\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Secondary object is not a known object type: %2.2X\\n\",\n\t\t\t     obj_desc->common.type);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nExtra attached Object (%p):\\n\", obj_desc);\n\t\tacpi_ex_dump_object(obj_desc,\n\t\t\t\t    acpi_ex_dump_info[obj_desc->common.type]);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "obj_desc",
        "function_name": "acpi_ex_dump_object_descriptor",
        "location": {
            "file_path": "drivers/acpi/acpica/exdump.c",
            "region": {
                "startLine": 1151,
                "startColumn": 7,
                "endColumn": 15
            },
            "context": {
                "startLine": 1149,
                "endLine": 1153,
                "snippet": {
                    "text": "if (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)\n{\n\tACPI_FUNCTION_TRACE(ex_dump_object_descriptor);\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (!flags) {\n\n\t\t/* Check if debug output enabled */\n\n\t\tif (!ACPI_IS_DEBUG_ENABLED(ACPI_LV_OBJECTS, _COMPONENT)) {\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_ex_dump_namespace_node((struct acpi_namespace_node *)\n\t\t\t\t\t    obj_desc, flags);\n\n\t\tobj_desc = ((struct acpi_namespace_node *)obj_desc)->object;\n\t\tif (!obj_desc) {\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nAttached Object %p\", obj_desc);\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" - Namespace Node\");\n\t\t}\n\n\t\tacpi_os_printf(\":\\n\");\n\t\tgoto dump_object;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {\n\t\tacpi_os_printf(\"%p is not an ACPI operand object: [%s]\\n\",\n\t\t\t       obj_desc, acpi_ut_get_descriptor_name(obj_desc));\n\t\treturn_VOID;\n\t}\n\n\t/* Validate the object type */\n\n\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Not a known object type: %2.2X\\n\",\n\t\t\t       obj_desc->common.type);\n\t\treturn_VOID;\n\t}\n\ndump_object:\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\t/* Common Fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_common);\n\n\t/* Object-specific fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);\n\n\tif (obj_desc->common.type == ACPI_TYPE_REGION) {\n\t\tobj_desc = obj_desc->common.next_object;\n\t\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Secondary object is not a known object type: %2.2X\\n\",\n\t\t\t     obj_desc->common.type);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nExtra attached Object (%p):\\n\", obj_desc);\n\t\tacpi_ex_dump_object(obj_desc,\n\t\t\t\t    acpi_ex_dump_info[obj_desc->common.type]);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "obj_desc",
        "function_name": "acpi_ex_dump_object_descriptor",
        "location": {
            "file_path": "drivers/acpi/acpica/exdump.c",
            "region": {
                "startLine": 1185,
                "startColumn": 50,
                "endColumn": 58
            },
            "context": {
                "startLine": 1183,
                "endLine": 1187,
                "snippet": {
                    "text": "acpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);"
                }
            }
        },
        "function_code": "void\nacpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)\n{\n\tACPI_FUNCTION_TRACE(ex_dump_object_descriptor);\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (!flags) {\n\n\t\t/* Check if debug output enabled */\n\n\t\tif (!ACPI_IS_DEBUG_ENABLED(ACPI_LV_OBJECTS, _COMPONENT)) {\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_ex_dump_namespace_node((struct acpi_namespace_node *)\n\t\t\t\t\t    obj_desc, flags);\n\n\t\tobj_desc = ((struct acpi_namespace_node *)obj_desc)->object;\n\t\tif (!obj_desc) {\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nAttached Object %p\", obj_desc);\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" - Namespace Node\");\n\t\t}\n\n\t\tacpi_os_printf(\":\\n\");\n\t\tgoto dump_object;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {\n\t\tacpi_os_printf(\"%p is not an ACPI operand object: [%s]\\n\",\n\t\t\t       obj_desc, acpi_ut_get_descriptor_name(obj_desc));\n\t\treturn_VOID;\n\t}\n\n\t/* Validate the object type */\n\n\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Not a known object type: %2.2X\\n\",\n\t\t\t       obj_desc->common.type);\n\t\treturn_VOID;\n\t}\n\ndump_object:\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\t/* Common Fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_common);\n\n\t/* Object-specific fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);\n\n\tif (obj_desc->common.type == ACPI_TYPE_REGION) {\n\t\tobj_desc = obj_desc->common.next_object;\n\t\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Secondary object is not a known object type: %2.2X\\n\",\n\t\t\t     obj_desc->common.type);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nExtra attached Object (%p):\\n\", obj_desc);\n\t\tacpi_ex_dump_object(obj_desc,\n\t\t\t\t    acpi_ex_dump_info[obj_desc->common.type]);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "obj_desc",
        "function_name": "acpi_ex_dump_object_descriptor",
        "location": {
            "file_path": "drivers/acpi/acpica/exdump.c",
            "region": {
                "startLine": 1187,
                "startColumn": 6,
                "endColumn": 14
            },
            "context": {
                "startLine": 1185,
                "endLine": 1189,
                "snippet": {
                    "text": "if (obj_desc->common.type == ACPI_TYPE_REGION) {"
                }
            }
        },
        "function_code": "void\nacpi_ex_dump_object_descriptor(union acpi_operand_object *obj_desc, u32 flags)\n{\n\tACPI_FUNCTION_TRACE(ex_dump_object_descriptor);\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\tif (!flags) {\n\n\t\t/* Check if debug output enabled */\n\n\t\tif (!ACPI_IS_DEBUG_ENABLED(ACPI_LV_OBJECTS, _COMPONENT)) {\n\t\t\treturn_VOID;\n\t\t}\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\tacpi_ex_dump_namespace_node((struct acpi_namespace_node *)\n\t\t\t\t\t    obj_desc, flags);\n\n\t\tobj_desc = ((struct acpi_namespace_node *)obj_desc)->object;\n\t\tif (!obj_desc) {\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nAttached Object %p\", obj_desc);\n\t\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) == ACPI_DESC_TYPE_NAMED) {\n\t\t\tacpi_os_printf(\" - Namespace Node\");\n\t\t}\n\n\t\tacpi_os_printf(\":\\n\");\n\t\tgoto dump_object;\n\t}\n\n\tif (ACPI_GET_DESCRIPTOR_TYPE(obj_desc) != ACPI_DESC_TYPE_OPERAND) {\n\t\tacpi_os_printf(\"%p is not an ACPI operand object: [%s]\\n\",\n\t\t\t       obj_desc, acpi_ut_get_descriptor_name(obj_desc));\n\t\treturn_VOID;\n\t}\n\n\t/* Validate the object type */\n\n\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\tacpi_os_printf(\"Not a known object type: %2.2X\\n\",\n\t\t\t       obj_desc->common.type);\n\t\treturn_VOID;\n\t}\n\ndump_object:\n\n\tif (!obj_desc) {\n\t\treturn_VOID;\n\t}\n\n\t/* Common Fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_common);\n\n\t/* Object-specific fields */\n\n\tacpi_ex_dump_object(obj_desc, acpi_ex_dump_info[obj_desc->common.type]);\n\n\tif (obj_desc->common.type == ACPI_TYPE_REGION) {\n\t\tobj_desc = obj_desc->common.next_object;\n\t\tif (obj_desc->common.type > ACPI_TYPE_LOCAL_MAX) {\n\t\t\tacpi_os_printf\n\t\t\t    (\"Secondary object is not a known object type: %2.2X\\n\",\n\t\t\t     obj_desc->common.type);\n\n\t\t\treturn_VOID;\n\t\t}\n\n\t\tacpi_os_printf(\"\\nExtra attached Object (%p):\\n\", obj_desc);\n\t\tacpi_ex_dump_object(obj_desc,\n\t\t\t\t    acpi_ex_dump_info[obj_desc->common.type]);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "node",
        "function_name": "acpi_ns_delete_node",
        "location": {
            "file_path": "drivers/acpi/acpica/nsalloc.c",
            "region": {
                "startLine": 91,
                "startColumn": 13,
                "endColumn": 17
            },
            "context": {
                "startLine": 89,
                "endLine": 93,
                "snippet": {
                    "text": "obj_desc = node->object;"
                }
            }
        },
        "function_code": "void acpi_ns_delete_node(struct acpi_namespace_node *node)\n{\n\tunion acpi_operand_object *obj_desc;\n\tunion acpi_operand_object *next_desc;\n\n\tACPI_FUNCTION_NAME(ns_delete_node);\n\n\tif (!node) {\n\t\treturn_VOID;\n\t}\n\n\t/* Detach an object if there is one */\n\n\tacpi_ns_detach_object(node);\n\n\t/*\n\t * Delete an attached data object list if present (objects that were\n\t * attached via acpi_attach_data). Note: After any normal object is\n\t * detached above, the only possible remaining object(s) are data\n\t * objects, in a linked list.\n\t */\n\tobj_desc = node->object;\n\twhile (obj_desc && (obj_desc->common.type == ACPI_TYPE_LOCAL_DATA)) {\n\n\t\t/* Invoke the attached data deletion handler if present */\n\n\t\tif (obj_desc->data.handler) {\n\t\t\tobj_desc->data.handler(node, obj_desc->data.pointer);\n\t\t}\n\n\t\tnext_desc = obj_desc->common.next_object;\n\t\tacpi_ut_remove_reference(obj_desc);\n\t\tobj_desc = next_desc;\n\t}\n\n\t/* Special case for the statically allocated root node */\n\n\tif (node == acpi_gbl_root_node) {\n\t\treturn;\n\t}\n\n\t/* Now we can delete the node */\n\n\t(void)acpi_os_release_object(acpi_gbl_namespace_cache, node);\n\n\tACPI_MEM_TRACKING(acpi_gbl_ns_node_list->total_freed++);\n\tACPI_DEBUG_PRINT((ACPI_DB_ALLOCATIONS, \"Node %p, Remaining %X\\n\",\n\t\t\t  node, acpi_gbl_current_node_count));\n}"
    },
    {
        "var_name": "parent_node",
        "function_name": "acpi_ns_delete_children",
        "location": {
            "file_path": "drivers/acpi/acpica/nsalloc.c",
            "region": {
                "startLine": 280,
                "startColumn": 14,
                "endColumn": 25
            },
            "context": {
                "startLine": 278,
                "endLine": 282,
                "snippet": {
                    "text": "next_node = parent_node->child;"
                }
            }
        },
        "function_code": "void acpi_ns_delete_children(struct acpi_namespace_node *parent_node)\n{\n\tstruct acpi_namespace_node *next_node;\n\tstruct acpi_namespace_node *node_to_delete;\n\n\tACPI_FUNCTION_TRACE_PTR(ns_delete_children, parent_node);\n\n\tif (!parent_node) {\n\t\treturn_VOID;\n\t}\n\n\t/* Deallocate all children at this level */\n\n\tnext_node = parent_node->child;\n\twhile (next_node) {\n\n\t\t/* Grandchildren should have all been deleted already */\n\n\t\tif (next_node->child) {\n\t\t\tACPI_ERROR((AE_INFO, \"Found a grandchild! P=%p C=%p\",\n\t\t\t\t    parent_node, next_node));\n\t\t}\n\n\t\t/*\n\t\t * Delete this child node and move on to the next child in the list.\n\t\t * No need to unlink the node since we are deleting the entire branch.\n\t\t */\n\t\tnode_to_delete = next_node;\n\t\tnext_node = next_node->peer;\n\t\tacpi_ns_delete_node(node_to_delete);\n\t}\n\n\t/* Clear the parent's child pointer */\n\n\tparent_node->child = NULL;\n\treturn_VOID;\n}"
    },
    {
        "var_name": "parser_state",
        "function_name": "acpi_ps_cleanup_scope",
        "location": {
            "file_path": "drivers/acpi/acpica/psscope.c",
            "region": {
                "startLine": 225,
                "startColumn": 9,
                "endColumn": 21
            },
            "context": {
                "startLine": 223,
                "endLine": 227,
                "snippet": {
                    "text": "while (parser_state->scope) {"
                }
            }
        },
        "function_code": "void acpi_ps_cleanup_scope(struct acpi_parse_state *parser_state)\n{\n\tunion acpi_generic_state *scope;\n\n\tACPI_FUNCTION_TRACE_PTR(ps_cleanup_scope, parser_state);\n\n\tif (!parser_state) {\n\t\treturn_VOID;\n\t}\n\n\t/* Delete anything on the scope stack */\n\n\twhile (parser_state->scope) {\n\t\tscope = acpi_ut_pop_generic_state(&parser_state->scope);\n\t\tacpi_ut_delete_generic_state(scope);\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "op",
        "function_name": "acpi_ps_append_arg",
        "location": {
            "file_path": "drivers/acpi/acpica/pstree.c",
            "region": {
                "startLine": 107,
                "startColumn": 36,
                "endColumn": 38
            },
            "context": {
                "startLine": 105,
                "endLine": 109,
                "snippet": {
                    "text": "op_info = acpi_ps_get_opcode_info(op->common.aml_opcode);"
                }
            }
        },
        "function_code": "void\nacpi_ps_append_arg(union acpi_parse_object *op, union acpi_parse_object *arg)\n{\n\tunion acpi_parse_object *prev_arg;\n\tconst struct acpi_opcode_info *op_info;\n\n\tACPI_FUNCTION_TRACE(ps_append_arg);\n\n\tif (!op) {\n\t\treturn_VOID;\n\t}\n\n\t/* Get the info structure for this opcode */\n\n\top_info = acpi_ps_get_opcode_info(op->common.aml_opcode);\n\tif (op_info->class == AML_CLASS_UNKNOWN) {\n\n\t\t/* Invalid opcode */\n\n\t\tACPI_ERROR((AE_INFO, \"Invalid AML Opcode: 0x%2.2X\",\n\t\t\t    op->common.aml_opcode));\n\t\treturn_VOID;\n\t}\n\n\t/* Check if this opcode requires argument sub-objects */\n\n\tif (!(op_info->flags & AML_HAS_ARGS)) {\n\n\t\t/* Has no linked argument objects */\n\n\t\treturn_VOID;\n\t}\n\n\t/* Append the argument to the linked argument list */\n\n\tif (op->common.value.arg) {\n\n\t\t/* Append to existing argument list */\n\n\t\tprev_arg = op->common.value.arg;\n\t\twhile (prev_arg->common.next) {\n\t\t\tprev_arg = prev_arg->common.next;\n\t\t}\n\t\tprev_arg->common.next = arg;\n\t} else {\n\t\t/* No argument list, this will be the first argument */\n\n\t\top->common.value.arg = arg;\n\t}\n\n\t/* Set the parent in this arg and any args linked after it */\n\n\twhile (arg) {\n\t\targ->common.parent = op;\n\t\targ = arg->common.next;\n\n\t\top->common.arg_list_length++;\n\t}\n\n\treturn_VOID;\n}"
    },
    {
        "var_name": "card",
        "function_name": "ns_init_card_error",
        "location": {
            "file_path": "drivers/atm/nicstar.c",
            "region": {
                "startLine": 819,
                "startColumn": 22,
                "endColumn": 26
            },
            "context": {
                "startLine": 817,
                "endLine": 821,
                "snippet": {
                    "text": "writel(0x00000000, card->membase + CFG);"
                }
            }
        },
        "function_code": "static void ns_init_card_error(ns_dev *card, int error)\n{\n\tif (error >= 17) {\n\t\twritel(0x00000000, card->membase + CFG);\n\t}\n\tif (error >= 16) {\n\t\tstruct sk_buff *iovb;\n\t\twhile ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)\n\t\t\tdev_kfree_skb_any(iovb);\n\t}\n\tif (error >= 15) {\n\t\tstruct sk_buff *sb;\n\t\twhile ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)\n\t\t\tdev_kfree_skb_any(sb);\n\t\tfree_scq(card, card->scq0, NULL);\n\t}\n\tif (error >= 14) {\n\t\tstruct sk_buff *lb;\n\t\twhile ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)\n\t\t\tdev_kfree_skb_any(lb);\n\t}\n\tif (error >= 13) {\n\t\tstruct sk_buff *hb;\n\t\twhile ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)\n\t\t\tdev_kfree_skb_any(hb);\n\t}\n\tif (error >= 12) {\n\t\tdma_free_coherent(&card->pcidev->dev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,\n\t\t\t\tcard->rsq.org, card->rsq.dma);\n\t}\n\tif (error >= 11) {\n\t\tdma_free_coherent(&card->pcidev->dev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,\n\t\t\t\tcard->tsq.org, card->tsq.dma);\n\t}\n\tif (error >= 10) {\n\t\tfree_irq(card->pcidev->irq, card);\n\t}\n\tif (error >= 4) {\n\t\tiounmap(card->membase);\n\t}\n\tif (error >= 3) {\n\t\tpci_disable_device(card->pcidev);\n\t\tkfree(card);\n\t}\n}"
    },
    {
        "var_name": "*walk",
        "function_name": "suni_stop",
        "location": {
            "file_path": "drivers/atm/suni.c",
            "region": {
                "startLine": 348,
                "startColumn": 14,
                "endColumn": 19
            },
            "context": {
                "startLine": 346,
                "endLine": 350,
                "snippet": {
                    "text": "walk = &PRIV((*walk)->dev)->next);"
                }
            }
        },
        "function_code": "static int suni_stop(struct atm_dev *dev)\n{\n\tstruct suni_priv **walk;\n\tunsigned long flags;\n\n\t/* let SAR driver worry about stopping interrupts */\n\tspin_lock_irqsave(&sunis_lock,flags);\n\tfor (walk = &sunis; *walk != PRIV(dev);\n\t    walk = &PRIV((*walk)->dev)->next);\n\t*walk = PRIV((*walk)->dev)->next;\n\tif (!sunis) del_timer_sync(&poll_timer);\n\tspin_unlock_irqrestore(&sunis_lock,flags);\n\tkfree(PRIV(dev));\n\n\treturn 0;\n}"
    },
    {
        "var_name": "grp",
        "function_name": "remove_nodes",
        "location": {
            "file_path": "drivers/base/devres.c",
            "region": {
                "startLine": 479,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 477,
                "endLine": 481,
                "snippet": {
                    "text": "grp->color++;"
                }
            }
        },
        "function_code": "static int remove_nodes(struct device *dev,\n\t\t\tstruct list_head *first, struct list_head *end,\n\t\t\tstruct list_head *todo)\n{\n\tstruct devres_node *node, *n;\n\tint cnt = 0, nr_groups = 0;\n\n\t/* First pass - move normal devres entries to @todo and clear\n\t * devres_group colors.\n\t */\n\tnode = list_entry(first, struct devres_node, entry);\n\tlist_for_each_entry_safe_from(node, n, end, entry) {\n\t\tstruct devres_group *grp;\n\n\t\tgrp = node_to_group(node);\n\t\tif (grp) {\n\t\t\t/* clear color of group markers in the first pass */\n\t\t\tgrp->color = 0;\n\t\t\tnr_groups++;\n\t\t} else {\n\t\t\t/* regular devres entry */\n\t\t\tif (&node->entry == first)\n\t\t\t\tfirst = first->next;\n\t\t\tlist_move_tail(&node->entry, todo);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\tif (!nr_groups)\n\t\treturn cnt;\n\n\t/* Second pass - Scan groups and color them.  A group gets\n\t * color value of two iff the group is wholly contained in\n\t * [current node, end). That is, for a closed group, both opening\n\t * and closing markers should be in the range, while just the\n\t * opening marker is enough for an open group.\n\t */\n\tnode = list_entry(first, struct devres_node, entry);\n\tlist_for_each_entry_safe_from(node, n, end, entry) {\n\t\tstruct devres_group *grp;\n\n\t\tgrp = node_to_group(node);\n\t\tBUG_ON(!grp || list_empty(&grp->node[0].entry));\n\n\t\tgrp->color++;\n\t\tif (list_empty(&grp->node[1].entry))\n\t\t\tgrp->color++;\n\n\t\tBUG_ON(grp->color <= 0 || grp->color > 2);\n\t\tif (grp->color == 2) {\n\t\t\t/* No need to update current node or end. The removed\n\t\t\t * nodes are always before both.\n\t\t\t */\n\t\t\tlist_move_tail(&grp->node[0].entry, todo);\n\t\t\tlist_del_init(&grp->node[1].entry);\n\t\t}\n\t}\n\n\treturn cnt;\n}"
    },
    {
        "var_name": "ops",
        "function_name": "platform_msi_update_dom_ops",
        "location": {
            "file_path": "drivers/base/platform-msi.c",
            "region": {
                "startLine": 79,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 77,
                "endLine": 81,
                "snippet": {
                    "text": "if (ops->msi_init == NULL)"
                }
            }
        },
        "function_code": "static void platform_msi_update_dom_ops(struct msi_domain_info *info)\n{\n\tstruct msi_domain_ops *ops = info->ops;\n\n\tBUG_ON(!ops);\n\n\tif (ops->msi_init == NULL)\n\t\tops->msi_init = platform_msi_init;\n\tif (ops->set_desc == NULL)\n\t\tops->set_desc = platform_msi_set_desc;\n}"
    },
    {
        "var_name": "chip",
        "function_name": "platform_msi_update_chip_ops",
        "location": {
            "file_path": "drivers/base/platform-msi.c",
            "region": {
                "startLine": 97,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 95,
                "endLine": 99,
                "snippet": {
                    "text": "if (!chip->irq_mask)"
                }
            }
        },
        "function_code": "static void platform_msi_update_chip_ops(struct msi_domain_info *info)\n{\n\tstruct irq_chip *chip = info->chip;\n\n\tBUG_ON(!chip);\n\tif (!chip->irq_mask)\n\t\tchip->irq_mask = irq_chip_mask_parent;\n\tif (!chip->irq_unmask)\n\t\tchip->irq_unmask = irq_chip_unmask_parent;\n\tif (!chip->irq_eoi)\n\t\tchip->irq_eoi = irq_chip_eoi_parent;\n\tif (!chip->irq_set_affinity)\n\t\tchip->irq_set_affinity = msi_domain_set_affinity;\n\tif (!chip->irq_write_msi_msg)\n\t\tchip->irq_write_msi_msg = platform_msi_write_msg;\n\tif (WARN_ON((info->flags & MSI_FLAG_LEVEL_CAPABLE) &&\n\t\t    !(chip->flags & IRQCHIP_SUPPORTS_LEVEL_MSI)))\n\t\tinfo->flags &= ~MSI_FLAG_LEVEL_CAPABLE;\n}"
    },
    {
        "var_name": "config",
        "function_name": "regmap_get_reg_endian",
        "location": {
            "file_path": "drivers/base/regmap/regmap.c",
            "region": {
                "startLine": 607,
                "startColumn": 11,
                "endColumn": 17
            },
            "context": {
                "startLine": 605,
                "endLine": 609,
                "snippet": {
                    "text": "endian = config->reg_format_endian;"
                }
            }
        },
        "function_code": "static enum regmap_endian regmap_get_reg_endian(const struct regmap_bus *bus,\n\t\t\t\t\tconst struct regmap_config *config)\n{\n\tenum regmap_endian endian;\n\n\t/* Retrieve the endianness specification from the regmap config */\n\tendian = config->reg_format_endian;\n\n\t/* If the regmap config specified a non-default value, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* Retrieve the endianness specification from the bus config */\n\tif (bus && bus->reg_format_endian_default)\n\t\tendian = bus->reg_format_endian_default;\n\n\t/* If the bus specified a non-default value, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* Use this if no other value was found */\n\treturn REGMAP_ENDIAN_BIG;\n}"
    },
    {
        "var_name": "config",
        "function_name": "regmap_get_val_endian",
        "location": {
            "file_path": "drivers/base/regmap/regmap.c",
            "region": {
                "startLine": 633,
                "startColumn": 11,
                "endColumn": 17
            },
            "context": {
                "startLine": 631,
                "endLine": 635,
                "snippet": {
                    "text": "endian = config->val_format_endian;"
                }
            }
        },
        "function_code": "enum regmap_endian regmap_get_val_endian(struct device *dev,\n\t\t\t\t\t const struct regmap_bus *bus,\n\t\t\t\t\t const struct regmap_config *config)\n{\n\tstruct fwnode_handle *fwnode = dev ? dev_fwnode(dev) : NULL;\n\tenum regmap_endian endian;\n\n\t/* Retrieve the endianness specification from the regmap config */\n\tendian = config->val_format_endian;\n\n\t/* If the regmap config specified a non-default value, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* If the firmware node exist try to get endianness from it */\n\tif (fwnode_property_read_bool(fwnode, \"big-endian\"))\n\t\tendian = REGMAP_ENDIAN_BIG;\n\telse if (fwnode_property_read_bool(fwnode, \"little-endian\"))\n\t\tendian = REGMAP_ENDIAN_LITTLE;\n\telse if (fwnode_property_read_bool(fwnode, \"native-endian\"))\n\t\tendian = REGMAP_ENDIAN_NATIVE;\n\n\t/* If the endianness was specified in fwnode, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* Retrieve the endianness specification from the bus config */\n\tif (bus && bus->val_format_endian_default)\n\t\tendian = bus->val_format_endian_default;\n\n\t/* If the bus specified a non-default value, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* Use this if no other value was found */\n\treturn REGMAP_ENDIAN_BIG;\n}"
    },
    {
        "var_name": "config",
        "function_name": "__regmap_init",
        "location": {
            "file_path": "drivers/base/regmap/regmap.c",
            "region": {
                "startLine": 831,
                "startColumn": 20,
                "endColumn": 26
            },
            "context": {
                "startLine": 829,
                "endLine": 833,
                "snippet": {
                    "text": "map->reg_read  = config->reg_read;"
                }
            }
        },
        "function_code": "struct regmap *__regmap_init(struct device *dev,\n\t\t\t     const struct regmap_bus *bus,\n\t\t\t     void *bus_context,\n\t\t\t     const struct regmap_config *config,\n\t\t\t     struct lock_class_key *lock_key,\n\t\t\t     const char *lock_name)\n{\n\tstruct regmap *map;\n\tint ret = -EINVAL;\n\tenum regmap_endian reg_endian, val_endian;\n\tint i, j;\n\n\tif (!config)\n\t\tgoto err;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (map == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = regmap_set_name(map, config);\n\tif (ret)\n\t\tgoto err_map;\n\n\tret = -EINVAL; /* Later error paths rely on this */\n\n\tif (config->disable_locking) {\n\t\tmap->lock = map->unlock = regmap_lock_unlock_none;\n\t\tmap->can_sleep = config->can_sleep;\n\t\tregmap_debugfs_disable(map);\n\t} else if (config->lock && config->unlock) {\n\t\tmap->lock = config->lock;\n\t\tmap->unlock = config->unlock;\n\t\tmap->lock_arg = config->lock_arg;\n\t\tmap->can_sleep = config->can_sleep;\n\t} else if (config->use_hwlock) {\n\t\tmap->hwlock = hwspin_lock_request_specific(config->hwlock_id);\n\t\tif (!map->hwlock) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_name;\n\t\t}\n\n\t\tswitch (config->hwlock_mode) {\n\t\tcase HWLOCK_IRQSTATE:\n\t\t\tmap->lock = regmap_lock_hwlock_irqsave;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irqrestore;\n\t\t\tbreak;\n\t\tcase HWLOCK_IRQ:\n\t\t\tmap->lock = regmap_lock_hwlock_irq;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmap->lock = regmap_lock_hwlock;\n\t\t\tmap->unlock = regmap_unlock_hwlock;\n\t\t\tbreak;\n\t\t}\n\n\t\tmap->lock_arg = map;\n\t} else {\n\t\tif ((bus && bus->fast_io) ||\n\t\t    config->fast_io) {\n\t\t\tif (config->use_raw_spinlock) {\n\t\t\t\traw_spin_lock_init(&map->raw_spinlock);\n\t\t\t\tmap->lock = regmap_lock_raw_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_raw_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->raw_spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t} else {\n\t\t\t\tspin_lock_init(&map->spinlock);\n\t\t\t\tmap->lock = regmap_lock_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t}\n\t\t} else {\n\t\t\tmutex_init(&map->mutex);\n\t\t\tmap->lock = regmap_lock_mutex;\n\t\t\tmap->unlock = regmap_unlock_mutex;\n\t\t\tmap->can_sleep = true;\n\t\t\tlockdep_set_class_and_name(&map->mutex,\n\t\t\t\t\t\t   lock_key, lock_name);\n\t\t}\n\t\tmap->lock_arg = map;\n\t}\n\n\t/*\n\t * When we write in fast-paths with regmap_bulk_write() don't allocate\n\t * scratch buffers with sleeping allocations.\n\t */\n\tif ((bus && bus->fast_io) || config->fast_io)\n\t\tmap->alloc_flags = GFP_ATOMIC;\n\telse\n\t\tmap->alloc_flags = GFP_KERNEL;\n\n\tmap->reg_base = config->reg_base;\n\n\tmap->format.reg_bytes = DIV_ROUND_UP(config->reg_bits, 8);\n\tmap->format.pad_bytes = config->pad_bits / 8;\n\tmap->format.reg_shift = config->reg_shift;\n\tmap->format.val_bytes = DIV_ROUND_UP(config->val_bits, 8);\n\tmap->format.buf_size = DIV_ROUND_UP(config->reg_bits +\n\t\t\tconfig->val_bits + config->pad_bits, 8);\n\tmap->reg_shift = config->pad_bits % 8;\n\tif (config->reg_stride)\n\t\tmap->reg_stride = config->reg_stride;\n\telse\n\t\tmap->reg_stride = 1;\n\tif (is_power_of_2(map->reg_stride))\n\t\tmap->reg_stride_order = ilog2(map->reg_stride);\n\telse\n\t\tmap->reg_stride_order = -1;\n\tmap->use_single_read = config->use_single_read || !(config->read || (bus && bus->read));\n\tmap->use_single_write = config->use_single_write || !(config->write || (bus && bus->write));\n\tmap->can_multi_write = config->can_multi_write && (config->write || (bus && bus->write));\n\tif (bus) {\n\t\tmap->max_raw_read = bus->max_raw_read;\n\t\tmap->max_raw_write = bus->max_raw_write;\n\t} else if (config->max_raw_read && config->max_raw_write) {\n\t\tmap->max_raw_read = config->max_raw_read;\n\t\tmap->max_raw_write = config->max_raw_write;\n\t}\n\tmap->dev = dev;\n\tmap->bus = bus;\n\tmap->bus_context = bus_context;\n\tmap->max_register = config->max_register;\n\tmap->max_register_is_set = map->max_register ?: config->max_register_is_0;\n\tmap->wr_table = config->wr_table;\n\tmap->rd_table = config->rd_table;\n\tmap->volatile_table = config->volatile_table;\n\tmap->precious_table = config->precious_table;\n\tmap->wr_noinc_table = config->wr_noinc_table;\n\tmap->rd_noinc_table = config->rd_noinc_table;\n\tmap->writeable_reg = config->writeable_reg;\n\tmap->readable_reg = config->readable_reg;\n\tmap->volatile_reg = config->volatile_reg;\n\tmap->precious_reg = config->precious_reg;\n\tmap->writeable_noinc_reg = config->writeable_noinc_reg;\n\tmap->readable_noinc_reg = config->readable_noinc_reg;\n\tmap->cache_type = config->cache_type;\n\n\tspin_lock_init(&map->async_lock);\n\tINIT_LIST_HEAD(&map->async_list);\n\tINIT_LIST_HEAD(&map->async_free);\n\tinit_waitqueue_head(&map->async_waitq);\n\n\tif (config->read_flag_mask ||\n\t    config->write_flag_mask ||\n\t    config->zero_flag_mask) {\n\t\tmap->read_flag_mask = config->read_flag_mask;\n\t\tmap->write_flag_mask = config->write_flag_mask;\n\t} else if (bus) {\n\t\tmap->read_flag_mask = bus->read_flag_mask;\n\t}\n\n\tif (config && config->read && config->write) {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tif (config->reg_update_bits)\n\t\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\t/* Bulk read/write */\n\t\tmap->read = config->read;\n\t\tmap->write = config->write;\n\n\t\treg_endian = REGMAP_ENDIAN_NATIVE;\n\t\tval_endian = REGMAP_ENDIAN_NATIVE;\n\t} else if (!bus) {\n\t\tmap->reg_read  = config->reg_read;\n\t\tmap->reg_write = config->reg_write;\n\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else if (!bus->read || !bus->write) {\n\t\tmap->reg_read = _regmap_bus_reg_read;\n\t\tmap->reg_write = _regmap_bus_reg_write;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\t\t/* Bulk read/write */\n\t\tmap->read = bus->read;\n\t\tmap->write = bus->write;\n\n\t\treg_endian = regmap_get_reg_endian(bus, config);\n\t\tval_endian = regmap_get_val_endian(dev, bus, config);\n\t}\n\n\tswitch (config->reg_bits + map->reg_shift) {\n\tcase 2:\n\t\tswitch (config->val_bits) {\n\t\tcase 6:\n\t\t\tmap->format.format_write = regmap_format_2_6_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tswitch (config->val_bits) {\n\t\tcase 12:\n\t\t\tmap->format.format_write = regmap_format_4_12_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 7:\n\t\tswitch (config->val_bits) {\n\t\tcase 9:\n\t\t\tmap->format.format_write = regmap_format_7_9_write;\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\tmap->format.format_write = regmap_format_7_17_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 10:\n\t\tswitch (config->val_bits) {\n\t\tcase 14:\n\t\t\tmap->format.format_write = regmap_format_10_14_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 12:\n\t\tswitch (config->val_bits) {\n\t\tcase 20:\n\t\t\tmap->format.format_write = regmap_format_12_20_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 8:\n\t\tmap->format.format_reg = regmap_format_8;\n\t\tbreak;\n\n\tcase 16:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_16_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_16_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 24:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 32:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_32_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_32_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tgoto err_hwlock;\n\t}\n\n\tif (val_endian == REGMAP_ENDIAN_NATIVE)\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\n\tswitch (config->val_bits) {\n\tcase 8:\n\t\tmap->format.format_val = regmap_format_8;\n\t\tmap->format.parse_val = regmap_parse_8;\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_16_be;\n\t\t\tmap->format.parse_val = regmap_parse_16_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_16_le;\n\t\t\tmap->format.parse_val = regmap_parse_16_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_16_native;\n\t\t\tmap->format.parse_val = regmap_parse_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_24_be;\n\t\t\tmap->format.parse_val = regmap_parse_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_32_be;\n\t\t\tmap->format.parse_val = regmap_parse_32_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_32_le;\n\t\t\tmap->format.parse_val = regmap_parse_32_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_32_native;\n\t\t\tmap->format.parse_val = regmap_parse_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (map->format.format_write) {\n\t\tif ((reg_endian != REGMAP_ENDIAN_BIG) ||\n\t\t    (val_endian != REGMAP_ENDIAN_BIG))\n\t\t\tgoto err_hwlock;\n\t\tmap->use_single_write = true;\n\t}\n\n\tif (!map->format.format_write &&\n\t    !(map->format.format_reg && map->format.format_val))\n\t\tgoto err_hwlock;\n\n\tmap->work_buf = kzalloc(map->format.buf_size, GFP_KERNEL);\n\tif (map->work_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hwlock;\n\t}\n\n\tif (map->format.format_write) {\n\t\tmap->defer_caching = false;\n\t\tmap->reg_write = _regmap_bus_formatted_write;\n\t} else if (map->format.format_val) {\n\t\tmap->defer_caching = true;\n\t\tmap->reg_write = _regmap_bus_raw_write;\n\t}\n\nskip_format_initialization:\n\n\tmap->range_tree = RB_ROOT;\n\tfor (i = 0; i < config->num_ranges; i++) {\n\t\tconst struct regmap_range_cfg *range_cfg = &config->ranges[i];\n\t\tstruct regmap_range_node *new;\n\n\t\t/* Sanity check */\n\t\tif (range_cfg->range_max < range_cfg->range_min) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d < %d\\n\", i,\n\t\t\t\trange_cfg->range_max, range_cfg->range_min);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->range_max > map->max_register) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d > %d\\n\", i,\n\t\t\t\trange_cfg->range_max, map->max_register);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->selector_reg > map->max_register) {\n\t\t\tdev_err(map->dev,\n\t\t\t\t\"Invalid range %d: selector out of map\\n\", i);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->window_len == 0) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: window_len 0\\n\",\n\t\t\t\ti);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\t/* Make sure, that this register range has no selector\n\t\t   or data window within its boundary */\n\t\tfor (j = 0; j < config->num_ranges; j++) {\n\t\t\tunsigned int sel_reg = config->ranges[j].selector_reg;\n\t\t\tunsigned int win_min = config->ranges[j].window_start;\n\t\t\tunsigned int win_max = win_min +\n\t\t\t\t\t       config->ranges[j].window_len - 1;\n\n\t\t\t/* Allow data window inside its own virtual range */\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (range_cfg->range_min <= sel_reg &&\n\t\t\t    sel_reg <= range_cfg->range_max) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: selector for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\n\t\t\tif (!(win_max < range_cfg->range_min ||\n\t\t\t      win_min > range_cfg->range_max)) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: window for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tnew->map = map;\n\t\tnew->name = range_cfg->name;\n\t\tnew->range_min = range_cfg->range_min;\n\t\tnew->range_max = range_cfg->range_max;\n\t\tnew->selector_reg = range_cfg->selector_reg;\n\t\tnew->selector_mask = range_cfg->selector_mask;\n\t\tnew->selector_shift = range_cfg->selector_shift;\n\t\tnew->window_start = range_cfg->window_start;\n\t\tnew->window_len = range_cfg->window_len;\n\n\t\tif (!_regmap_range_add(map, new)) {\n\t\t\tdev_err(map->dev, \"Failed to add range %d\\n\", i);\n\t\t\tkfree(new);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (map->selector_work_buf == NULL) {\n\t\t\tmap->selector_work_buf =\n\t\t\t\tkzalloc(map->format.buf_size, GFP_KERNEL);\n\t\t\tif (map->selector_work_buf == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = regcache_init(map, config);\n\tif (ret != 0)\n\t\tgoto err_range;\n\n\tif (dev) {\n\t\tret = regmap_attach_dev(dev, map, config);\n\t\tif (ret != 0)\n\t\t\tgoto err_regcache;\n\t} else {\n\t\tregmap_debugfs_init(map);\n\t}\n\n\treturn map;\n\nerr_regcache:\n\tregcache_exit(map);\nerr_range:\n\tregmap_range_exit(map);\n\tkfree(map->work_buf);\nerr_hwlock:\n\tif (map->hwlock)\n\t\thwspin_lock_free(map->hwlock);\nerr_name:\n\tkfree_const(map->name);\nerr_map:\n\tkfree(map);\nerr:\n\treturn ERR_PTR(ret);\n}"
    },
    {
        "var_name": "config",
        "function_name": "__regmap_init",
        "location": {
            "file_path": "drivers/base/regmap/regmap.c",
            "region": {
                "startLine": 832,
                "startColumn": 20,
                "endColumn": 26
            },
            "context": {
                "startLine": 830,
                "endLine": 834,
                "snippet": {
                    "text": "map->reg_write = config->reg_write;"
                }
            }
        },
        "function_code": "struct regmap *__regmap_init(struct device *dev,\n\t\t\t     const struct regmap_bus *bus,\n\t\t\t     void *bus_context,\n\t\t\t     const struct regmap_config *config,\n\t\t\t     struct lock_class_key *lock_key,\n\t\t\t     const char *lock_name)\n{\n\tstruct regmap *map;\n\tint ret = -EINVAL;\n\tenum regmap_endian reg_endian, val_endian;\n\tint i, j;\n\n\tif (!config)\n\t\tgoto err;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (map == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = regmap_set_name(map, config);\n\tif (ret)\n\t\tgoto err_map;\n\n\tret = -EINVAL; /* Later error paths rely on this */\n\n\tif (config->disable_locking) {\n\t\tmap->lock = map->unlock = regmap_lock_unlock_none;\n\t\tmap->can_sleep = config->can_sleep;\n\t\tregmap_debugfs_disable(map);\n\t} else if (config->lock && config->unlock) {\n\t\tmap->lock = config->lock;\n\t\tmap->unlock = config->unlock;\n\t\tmap->lock_arg = config->lock_arg;\n\t\tmap->can_sleep = config->can_sleep;\n\t} else if (config->use_hwlock) {\n\t\tmap->hwlock = hwspin_lock_request_specific(config->hwlock_id);\n\t\tif (!map->hwlock) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_name;\n\t\t}\n\n\t\tswitch (config->hwlock_mode) {\n\t\tcase HWLOCK_IRQSTATE:\n\t\t\tmap->lock = regmap_lock_hwlock_irqsave;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irqrestore;\n\t\t\tbreak;\n\t\tcase HWLOCK_IRQ:\n\t\t\tmap->lock = regmap_lock_hwlock_irq;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmap->lock = regmap_lock_hwlock;\n\t\t\tmap->unlock = regmap_unlock_hwlock;\n\t\t\tbreak;\n\t\t}\n\n\t\tmap->lock_arg = map;\n\t} else {\n\t\tif ((bus && bus->fast_io) ||\n\t\t    config->fast_io) {\n\t\t\tif (config->use_raw_spinlock) {\n\t\t\t\traw_spin_lock_init(&map->raw_spinlock);\n\t\t\t\tmap->lock = regmap_lock_raw_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_raw_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->raw_spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t} else {\n\t\t\t\tspin_lock_init(&map->spinlock);\n\t\t\t\tmap->lock = regmap_lock_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t}\n\t\t} else {\n\t\t\tmutex_init(&map->mutex);\n\t\t\tmap->lock = regmap_lock_mutex;\n\t\t\tmap->unlock = regmap_unlock_mutex;\n\t\t\tmap->can_sleep = true;\n\t\t\tlockdep_set_class_and_name(&map->mutex,\n\t\t\t\t\t\t   lock_key, lock_name);\n\t\t}\n\t\tmap->lock_arg = map;\n\t}\n\n\t/*\n\t * When we write in fast-paths with regmap_bulk_write() don't allocate\n\t * scratch buffers with sleeping allocations.\n\t */\n\tif ((bus && bus->fast_io) || config->fast_io)\n\t\tmap->alloc_flags = GFP_ATOMIC;\n\telse\n\t\tmap->alloc_flags = GFP_KERNEL;\n\n\tmap->reg_base = config->reg_base;\n\n\tmap->format.reg_bytes = DIV_ROUND_UP(config->reg_bits, 8);\n\tmap->format.pad_bytes = config->pad_bits / 8;\n\tmap->format.reg_shift = config->reg_shift;\n\tmap->format.val_bytes = DIV_ROUND_UP(config->val_bits, 8);\n\tmap->format.buf_size = DIV_ROUND_UP(config->reg_bits +\n\t\t\tconfig->val_bits + config->pad_bits, 8);\n\tmap->reg_shift = config->pad_bits % 8;\n\tif (config->reg_stride)\n\t\tmap->reg_stride = config->reg_stride;\n\telse\n\t\tmap->reg_stride = 1;\n\tif (is_power_of_2(map->reg_stride))\n\t\tmap->reg_stride_order = ilog2(map->reg_stride);\n\telse\n\t\tmap->reg_stride_order = -1;\n\tmap->use_single_read = config->use_single_read || !(config->read || (bus && bus->read));\n\tmap->use_single_write = config->use_single_write || !(config->write || (bus && bus->write));\n\tmap->can_multi_write = config->can_multi_write && (config->write || (bus && bus->write));\n\tif (bus) {\n\t\tmap->max_raw_read = bus->max_raw_read;\n\t\tmap->max_raw_write = bus->max_raw_write;\n\t} else if (config->max_raw_read && config->max_raw_write) {\n\t\tmap->max_raw_read = config->max_raw_read;\n\t\tmap->max_raw_write = config->max_raw_write;\n\t}\n\tmap->dev = dev;\n\tmap->bus = bus;\n\tmap->bus_context = bus_context;\n\tmap->max_register = config->max_register;\n\tmap->max_register_is_set = map->max_register ?: config->max_register_is_0;\n\tmap->wr_table = config->wr_table;\n\tmap->rd_table = config->rd_table;\n\tmap->volatile_table = config->volatile_table;\n\tmap->precious_table = config->precious_table;\n\tmap->wr_noinc_table = config->wr_noinc_table;\n\tmap->rd_noinc_table = config->rd_noinc_table;\n\tmap->writeable_reg = config->writeable_reg;\n\tmap->readable_reg = config->readable_reg;\n\tmap->volatile_reg = config->volatile_reg;\n\tmap->precious_reg = config->precious_reg;\n\tmap->writeable_noinc_reg = config->writeable_noinc_reg;\n\tmap->readable_noinc_reg = config->readable_noinc_reg;\n\tmap->cache_type = config->cache_type;\n\n\tspin_lock_init(&map->async_lock);\n\tINIT_LIST_HEAD(&map->async_list);\n\tINIT_LIST_HEAD(&map->async_free);\n\tinit_waitqueue_head(&map->async_waitq);\n\n\tif (config->read_flag_mask ||\n\t    config->write_flag_mask ||\n\t    config->zero_flag_mask) {\n\t\tmap->read_flag_mask = config->read_flag_mask;\n\t\tmap->write_flag_mask = config->write_flag_mask;\n\t} else if (bus) {\n\t\tmap->read_flag_mask = bus->read_flag_mask;\n\t}\n\n\tif (config && config->read && config->write) {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tif (config->reg_update_bits)\n\t\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\t/* Bulk read/write */\n\t\tmap->read = config->read;\n\t\tmap->write = config->write;\n\n\t\treg_endian = REGMAP_ENDIAN_NATIVE;\n\t\tval_endian = REGMAP_ENDIAN_NATIVE;\n\t} else if (!bus) {\n\t\tmap->reg_read  = config->reg_read;\n\t\tmap->reg_write = config->reg_write;\n\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else if (!bus->read || !bus->write) {\n\t\tmap->reg_read = _regmap_bus_reg_read;\n\t\tmap->reg_write = _regmap_bus_reg_write;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\t\t/* Bulk read/write */\n\t\tmap->read = bus->read;\n\t\tmap->write = bus->write;\n\n\t\treg_endian = regmap_get_reg_endian(bus, config);\n\t\tval_endian = regmap_get_val_endian(dev, bus, config);\n\t}\n\n\tswitch (config->reg_bits + map->reg_shift) {\n\tcase 2:\n\t\tswitch (config->val_bits) {\n\t\tcase 6:\n\t\t\tmap->format.format_write = regmap_format_2_6_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tswitch (config->val_bits) {\n\t\tcase 12:\n\t\t\tmap->format.format_write = regmap_format_4_12_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 7:\n\t\tswitch (config->val_bits) {\n\t\tcase 9:\n\t\t\tmap->format.format_write = regmap_format_7_9_write;\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\tmap->format.format_write = regmap_format_7_17_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 10:\n\t\tswitch (config->val_bits) {\n\t\tcase 14:\n\t\t\tmap->format.format_write = regmap_format_10_14_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 12:\n\t\tswitch (config->val_bits) {\n\t\tcase 20:\n\t\t\tmap->format.format_write = regmap_format_12_20_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 8:\n\t\tmap->format.format_reg = regmap_format_8;\n\t\tbreak;\n\n\tcase 16:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_16_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_16_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 24:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 32:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_32_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_32_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tgoto err_hwlock;\n\t}\n\n\tif (val_endian == REGMAP_ENDIAN_NATIVE)\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\n\tswitch (config->val_bits) {\n\tcase 8:\n\t\tmap->format.format_val = regmap_format_8;\n\t\tmap->format.parse_val = regmap_parse_8;\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_16_be;\n\t\t\tmap->format.parse_val = regmap_parse_16_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_16_le;\n\t\t\tmap->format.parse_val = regmap_parse_16_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_16_native;\n\t\t\tmap->format.parse_val = regmap_parse_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_24_be;\n\t\t\tmap->format.parse_val = regmap_parse_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_32_be;\n\t\t\tmap->format.parse_val = regmap_parse_32_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_32_le;\n\t\t\tmap->format.parse_val = regmap_parse_32_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_32_native;\n\t\t\tmap->format.parse_val = regmap_parse_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (map->format.format_write) {\n\t\tif ((reg_endian != REGMAP_ENDIAN_BIG) ||\n\t\t    (val_endian != REGMAP_ENDIAN_BIG))\n\t\t\tgoto err_hwlock;\n\t\tmap->use_single_write = true;\n\t}\n\n\tif (!map->format.format_write &&\n\t    !(map->format.format_reg && map->format.format_val))\n\t\tgoto err_hwlock;\n\n\tmap->work_buf = kzalloc(map->format.buf_size, GFP_KERNEL);\n\tif (map->work_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hwlock;\n\t}\n\n\tif (map->format.format_write) {\n\t\tmap->defer_caching = false;\n\t\tmap->reg_write = _regmap_bus_formatted_write;\n\t} else if (map->format.format_val) {\n\t\tmap->defer_caching = true;\n\t\tmap->reg_write = _regmap_bus_raw_write;\n\t}\n\nskip_format_initialization:\n\n\tmap->range_tree = RB_ROOT;\n\tfor (i = 0; i < config->num_ranges; i++) {\n\t\tconst struct regmap_range_cfg *range_cfg = &config->ranges[i];\n\t\tstruct regmap_range_node *new;\n\n\t\t/* Sanity check */\n\t\tif (range_cfg->range_max < range_cfg->range_min) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d < %d\\n\", i,\n\t\t\t\trange_cfg->range_max, range_cfg->range_min);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->range_max > map->max_register) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d > %d\\n\", i,\n\t\t\t\trange_cfg->range_max, map->max_register);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->selector_reg > map->max_register) {\n\t\t\tdev_err(map->dev,\n\t\t\t\t\"Invalid range %d: selector out of map\\n\", i);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->window_len == 0) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: window_len 0\\n\",\n\t\t\t\ti);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\t/* Make sure, that this register range has no selector\n\t\t   or data window within its boundary */\n\t\tfor (j = 0; j < config->num_ranges; j++) {\n\t\t\tunsigned int sel_reg = config->ranges[j].selector_reg;\n\t\t\tunsigned int win_min = config->ranges[j].window_start;\n\t\t\tunsigned int win_max = win_min +\n\t\t\t\t\t       config->ranges[j].window_len - 1;\n\n\t\t\t/* Allow data window inside its own virtual range */\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (range_cfg->range_min <= sel_reg &&\n\t\t\t    sel_reg <= range_cfg->range_max) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: selector for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\n\t\t\tif (!(win_max < range_cfg->range_min ||\n\t\t\t      win_min > range_cfg->range_max)) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: window for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tnew->map = map;\n\t\tnew->name = range_cfg->name;\n\t\tnew->range_min = range_cfg->range_min;\n\t\tnew->range_max = range_cfg->range_max;\n\t\tnew->selector_reg = range_cfg->selector_reg;\n\t\tnew->selector_mask = range_cfg->selector_mask;\n\t\tnew->selector_shift = range_cfg->selector_shift;\n\t\tnew->window_start = range_cfg->window_start;\n\t\tnew->window_len = range_cfg->window_len;\n\n\t\tif (!_regmap_range_add(map, new)) {\n\t\t\tdev_err(map->dev, \"Failed to add range %d\\n\", i);\n\t\t\tkfree(new);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (map->selector_work_buf == NULL) {\n\t\t\tmap->selector_work_buf =\n\t\t\t\tkzalloc(map->format.buf_size, GFP_KERNEL);\n\t\t\tif (map->selector_work_buf == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = regcache_init(map, config);\n\tif (ret != 0)\n\t\tgoto err_range;\n\n\tif (dev) {\n\t\tret = regmap_attach_dev(dev, map, config);\n\t\tif (ret != 0)\n\t\t\tgoto err_regcache;\n\t} else {\n\t\tregmap_debugfs_init(map);\n\t}\n\n\treturn map;\n\nerr_regcache:\n\tregcache_exit(map);\nerr_range:\n\tregmap_range_exit(map);\n\tkfree(map->work_buf);\nerr_hwlock:\n\tif (map->hwlock)\n\t\thwspin_lock_free(map->hwlock);\nerr_name:\n\tkfree_const(map->name);\nerr_map:\n\tkfree(map);\nerr:\n\treturn ERR_PTR(ret);\n}"
    },
    {
        "var_name": "config",
        "function_name": "__regmap_init",
        "location": {
            "file_path": "drivers/base/regmap/regmap.c",
            "region": {
                "startLine": 833,
                "startColumn": 26,
                "endColumn": 32
            },
            "context": {
                "startLine": 831,
                "endLine": 835,
                "snippet": {
                    "text": "map->reg_update_bits = config->reg_update_bits;"
                }
            }
        },
        "function_code": "struct regmap *__regmap_init(struct device *dev,\n\t\t\t     const struct regmap_bus *bus,\n\t\t\t     void *bus_context,\n\t\t\t     const struct regmap_config *config,\n\t\t\t     struct lock_class_key *lock_key,\n\t\t\t     const char *lock_name)\n{\n\tstruct regmap *map;\n\tint ret = -EINVAL;\n\tenum regmap_endian reg_endian, val_endian;\n\tint i, j;\n\n\tif (!config)\n\t\tgoto err;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (map == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = regmap_set_name(map, config);\n\tif (ret)\n\t\tgoto err_map;\n\n\tret = -EINVAL; /* Later error paths rely on this */\n\n\tif (config->disable_locking) {\n\t\tmap->lock = map->unlock = regmap_lock_unlock_none;\n\t\tmap->can_sleep = config->can_sleep;\n\t\tregmap_debugfs_disable(map);\n\t} else if (config->lock && config->unlock) {\n\t\tmap->lock = config->lock;\n\t\tmap->unlock = config->unlock;\n\t\tmap->lock_arg = config->lock_arg;\n\t\tmap->can_sleep = config->can_sleep;\n\t} else if (config->use_hwlock) {\n\t\tmap->hwlock = hwspin_lock_request_specific(config->hwlock_id);\n\t\tif (!map->hwlock) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_name;\n\t\t}\n\n\t\tswitch (config->hwlock_mode) {\n\t\tcase HWLOCK_IRQSTATE:\n\t\t\tmap->lock = regmap_lock_hwlock_irqsave;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irqrestore;\n\t\t\tbreak;\n\t\tcase HWLOCK_IRQ:\n\t\t\tmap->lock = regmap_lock_hwlock_irq;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmap->lock = regmap_lock_hwlock;\n\t\t\tmap->unlock = regmap_unlock_hwlock;\n\t\t\tbreak;\n\t\t}\n\n\t\tmap->lock_arg = map;\n\t} else {\n\t\tif ((bus && bus->fast_io) ||\n\t\t    config->fast_io) {\n\t\t\tif (config->use_raw_spinlock) {\n\t\t\t\traw_spin_lock_init(&map->raw_spinlock);\n\t\t\t\tmap->lock = regmap_lock_raw_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_raw_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->raw_spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t} else {\n\t\t\t\tspin_lock_init(&map->spinlock);\n\t\t\t\tmap->lock = regmap_lock_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t}\n\t\t} else {\n\t\t\tmutex_init(&map->mutex);\n\t\t\tmap->lock = regmap_lock_mutex;\n\t\t\tmap->unlock = regmap_unlock_mutex;\n\t\t\tmap->can_sleep = true;\n\t\t\tlockdep_set_class_and_name(&map->mutex,\n\t\t\t\t\t\t   lock_key, lock_name);\n\t\t}\n\t\tmap->lock_arg = map;\n\t}\n\n\t/*\n\t * When we write in fast-paths with regmap_bulk_write() don't allocate\n\t * scratch buffers with sleeping allocations.\n\t */\n\tif ((bus && bus->fast_io) || config->fast_io)\n\t\tmap->alloc_flags = GFP_ATOMIC;\n\telse\n\t\tmap->alloc_flags = GFP_KERNEL;\n\n\tmap->reg_base = config->reg_base;\n\n\tmap->format.reg_bytes = DIV_ROUND_UP(config->reg_bits, 8);\n\tmap->format.pad_bytes = config->pad_bits / 8;\n\tmap->format.reg_shift = config->reg_shift;\n\tmap->format.val_bytes = DIV_ROUND_UP(config->val_bits, 8);\n\tmap->format.buf_size = DIV_ROUND_UP(config->reg_bits +\n\t\t\tconfig->val_bits + config->pad_bits, 8);\n\tmap->reg_shift = config->pad_bits % 8;\n\tif (config->reg_stride)\n\t\tmap->reg_stride = config->reg_stride;\n\telse\n\t\tmap->reg_stride = 1;\n\tif (is_power_of_2(map->reg_stride))\n\t\tmap->reg_stride_order = ilog2(map->reg_stride);\n\telse\n\t\tmap->reg_stride_order = -1;\n\tmap->use_single_read = config->use_single_read || !(config->read || (bus && bus->read));\n\tmap->use_single_write = config->use_single_write || !(config->write || (bus && bus->write));\n\tmap->can_multi_write = config->can_multi_write && (config->write || (bus && bus->write));\n\tif (bus) {\n\t\tmap->max_raw_read = bus->max_raw_read;\n\t\tmap->max_raw_write = bus->max_raw_write;\n\t} else if (config->max_raw_read && config->max_raw_write) {\n\t\tmap->max_raw_read = config->max_raw_read;\n\t\tmap->max_raw_write = config->max_raw_write;\n\t}\n\tmap->dev = dev;\n\tmap->bus = bus;\n\tmap->bus_context = bus_context;\n\tmap->max_register = config->max_register;\n\tmap->max_register_is_set = map->max_register ?: config->max_register_is_0;\n\tmap->wr_table = config->wr_table;\n\tmap->rd_table = config->rd_table;\n\tmap->volatile_table = config->volatile_table;\n\tmap->precious_table = config->precious_table;\n\tmap->wr_noinc_table = config->wr_noinc_table;\n\tmap->rd_noinc_table = config->rd_noinc_table;\n\tmap->writeable_reg = config->writeable_reg;\n\tmap->readable_reg = config->readable_reg;\n\tmap->volatile_reg = config->volatile_reg;\n\tmap->precious_reg = config->precious_reg;\n\tmap->writeable_noinc_reg = config->writeable_noinc_reg;\n\tmap->readable_noinc_reg = config->readable_noinc_reg;\n\tmap->cache_type = config->cache_type;\n\n\tspin_lock_init(&map->async_lock);\n\tINIT_LIST_HEAD(&map->async_list);\n\tINIT_LIST_HEAD(&map->async_free);\n\tinit_waitqueue_head(&map->async_waitq);\n\n\tif (config->read_flag_mask ||\n\t    config->write_flag_mask ||\n\t    config->zero_flag_mask) {\n\t\tmap->read_flag_mask = config->read_flag_mask;\n\t\tmap->write_flag_mask = config->write_flag_mask;\n\t} else if (bus) {\n\t\tmap->read_flag_mask = bus->read_flag_mask;\n\t}\n\n\tif (config && config->read && config->write) {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tif (config->reg_update_bits)\n\t\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\t/* Bulk read/write */\n\t\tmap->read = config->read;\n\t\tmap->write = config->write;\n\n\t\treg_endian = REGMAP_ENDIAN_NATIVE;\n\t\tval_endian = REGMAP_ENDIAN_NATIVE;\n\t} else if (!bus) {\n\t\tmap->reg_read  = config->reg_read;\n\t\tmap->reg_write = config->reg_write;\n\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else if (!bus->read || !bus->write) {\n\t\tmap->reg_read = _regmap_bus_reg_read;\n\t\tmap->reg_write = _regmap_bus_reg_write;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\t\t/* Bulk read/write */\n\t\tmap->read = bus->read;\n\t\tmap->write = bus->write;\n\n\t\treg_endian = regmap_get_reg_endian(bus, config);\n\t\tval_endian = regmap_get_val_endian(dev, bus, config);\n\t}\n\n\tswitch (config->reg_bits + map->reg_shift) {\n\tcase 2:\n\t\tswitch (config->val_bits) {\n\t\tcase 6:\n\t\t\tmap->format.format_write = regmap_format_2_6_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tswitch (config->val_bits) {\n\t\tcase 12:\n\t\t\tmap->format.format_write = regmap_format_4_12_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 7:\n\t\tswitch (config->val_bits) {\n\t\tcase 9:\n\t\t\tmap->format.format_write = regmap_format_7_9_write;\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\tmap->format.format_write = regmap_format_7_17_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 10:\n\t\tswitch (config->val_bits) {\n\t\tcase 14:\n\t\t\tmap->format.format_write = regmap_format_10_14_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 12:\n\t\tswitch (config->val_bits) {\n\t\tcase 20:\n\t\t\tmap->format.format_write = regmap_format_12_20_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 8:\n\t\tmap->format.format_reg = regmap_format_8;\n\t\tbreak;\n\n\tcase 16:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_16_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_16_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 24:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 32:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_32_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_32_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tgoto err_hwlock;\n\t}\n\n\tif (val_endian == REGMAP_ENDIAN_NATIVE)\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\n\tswitch (config->val_bits) {\n\tcase 8:\n\t\tmap->format.format_val = regmap_format_8;\n\t\tmap->format.parse_val = regmap_parse_8;\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_16_be;\n\t\t\tmap->format.parse_val = regmap_parse_16_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_16_le;\n\t\t\tmap->format.parse_val = regmap_parse_16_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_16_native;\n\t\t\tmap->format.parse_val = regmap_parse_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_24_be;\n\t\t\tmap->format.parse_val = regmap_parse_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_32_be;\n\t\t\tmap->format.parse_val = regmap_parse_32_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_32_le;\n\t\t\tmap->format.parse_val = regmap_parse_32_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_32_native;\n\t\t\tmap->format.parse_val = regmap_parse_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (map->format.format_write) {\n\t\tif ((reg_endian != REGMAP_ENDIAN_BIG) ||\n\t\t    (val_endian != REGMAP_ENDIAN_BIG))\n\t\t\tgoto err_hwlock;\n\t\tmap->use_single_write = true;\n\t}\n\n\tif (!map->format.format_write &&\n\t    !(map->format.format_reg && map->format.format_val))\n\t\tgoto err_hwlock;\n\n\tmap->work_buf = kzalloc(map->format.buf_size, GFP_KERNEL);\n\tif (map->work_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hwlock;\n\t}\n\n\tif (map->format.format_write) {\n\t\tmap->defer_caching = false;\n\t\tmap->reg_write = _regmap_bus_formatted_write;\n\t} else if (map->format.format_val) {\n\t\tmap->defer_caching = true;\n\t\tmap->reg_write = _regmap_bus_raw_write;\n\t}\n\nskip_format_initialization:\n\n\tmap->range_tree = RB_ROOT;\n\tfor (i = 0; i < config->num_ranges; i++) {\n\t\tconst struct regmap_range_cfg *range_cfg = &config->ranges[i];\n\t\tstruct regmap_range_node *new;\n\n\t\t/* Sanity check */\n\t\tif (range_cfg->range_max < range_cfg->range_min) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d < %d\\n\", i,\n\t\t\t\trange_cfg->range_max, range_cfg->range_min);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->range_max > map->max_register) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d > %d\\n\", i,\n\t\t\t\trange_cfg->range_max, map->max_register);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->selector_reg > map->max_register) {\n\t\t\tdev_err(map->dev,\n\t\t\t\t\"Invalid range %d: selector out of map\\n\", i);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->window_len == 0) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: window_len 0\\n\",\n\t\t\t\ti);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\t/* Make sure, that this register range has no selector\n\t\t   or data window within its boundary */\n\t\tfor (j = 0; j < config->num_ranges; j++) {\n\t\t\tunsigned int sel_reg = config->ranges[j].selector_reg;\n\t\t\tunsigned int win_min = config->ranges[j].window_start;\n\t\t\tunsigned int win_max = win_min +\n\t\t\t\t\t       config->ranges[j].window_len - 1;\n\n\t\t\t/* Allow data window inside its own virtual range */\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (range_cfg->range_min <= sel_reg &&\n\t\t\t    sel_reg <= range_cfg->range_max) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: selector for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\n\t\t\tif (!(win_max < range_cfg->range_min ||\n\t\t\t      win_min > range_cfg->range_max)) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: window for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tnew->map = map;\n\t\tnew->name = range_cfg->name;\n\t\tnew->range_min = range_cfg->range_min;\n\t\tnew->range_max = range_cfg->range_max;\n\t\tnew->selector_reg = range_cfg->selector_reg;\n\t\tnew->selector_mask = range_cfg->selector_mask;\n\t\tnew->selector_shift = range_cfg->selector_shift;\n\t\tnew->window_start = range_cfg->window_start;\n\t\tnew->window_len = range_cfg->window_len;\n\n\t\tif (!_regmap_range_add(map, new)) {\n\t\t\tdev_err(map->dev, \"Failed to add range %d\\n\", i);\n\t\t\tkfree(new);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (map->selector_work_buf == NULL) {\n\t\t\tmap->selector_work_buf =\n\t\t\t\tkzalloc(map->format.buf_size, GFP_KERNEL);\n\t\t\tif (map->selector_work_buf == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = regcache_init(map, config);\n\tif (ret != 0)\n\t\tgoto err_range;\n\n\tif (dev) {\n\t\tret = regmap_attach_dev(dev, map, config);\n\t\tif (ret != 0)\n\t\t\tgoto err_regcache;\n\t} else {\n\t\tregmap_debugfs_init(map);\n\t}\n\n\treturn map;\n\nerr_regcache:\n\tregcache_exit(map);\nerr_range:\n\tregmap_range_exit(map);\n\tkfree(map->work_buf);\nerr_hwlock:\n\tif (map->hwlock)\n\t\thwspin_lock_free(map->hwlock);\nerr_name:\n\tkfree_const(map->name);\nerr_map:\n\tkfree(map);\nerr:\n\treturn ERR_PTR(ret);\n}"
    },
    {
        "var_name": "config",
        "function_name": "__regmap_init",
        "location": {
            "file_path": "drivers/base/regmap/regmap.c",
            "region": {
                "startLine": 855,
                "startColumn": 10,
                "endColumn": 16
            },
            "context": {
                "startLine": 853,
                "endLine": 857,
                "snippet": {
                    "text": "switch (config->reg_bits + map->reg_shift) {"
                }
            }
        },
        "function_code": "struct regmap *__regmap_init(struct device *dev,\n\t\t\t     const struct regmap_bus *bus,\n\t\t\t     void *bus_context,\n\t\t\t     const struct regmap_config *config,\n\t\t\t     struct lock_class_key *lock_key,\n\t\t\t     const char *lock_name)\n{\n\tstruct regmap *map;\n\tint ret = -EINVAL;\n\tenum regmap_endian reg_endian, val_endian;\n\tint i, j;\n\n\tif (!config)\n\t\tgoto err;\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (map == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = regmap_set_name(map, config);\n\tif (ret)\n\t\tgoto err_map;\n\n\tret = -EINVAL; /* Later error paths rely on this */\n\n\tif (config->disable_locking) {\n\t\tmap->lock = map->unlock = regmap_lock_unlock_none;\n\t\tmap->can_sleep = config->can_sleep;\n\t\tregmap_debugfs_disable(map);\n\t} else if (config->lock && config->unlock) {\n\t\tmap->lock = config->lock;\n\t\tmap->unlock = config->unlock;\n\t\tmap->lock_arg = config->lock_arg;\n\t\tmap->can_sleep = config->can_sleep;\n\t} else if (config->use_hwlock) {\n\t\tmap->hwlock = hwspin_lock_request_specific(config->hwlock_id);\n\t\tif (!map->hwlock) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto err_name;\n\t\t}\n\n\t\tswitch (config->hwlock_mode) {\n\t\tcase HWLOCK_IRQSTATE:\n\t\t\tmap->lock = regmap_lock_hwlock_irqsave;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irqrestore;\n\t\t\tbreak;\n\t\tcase HWLOCK_IRQ:\n\t\t\tmap->lock = regmap_lock_hwlock_irq;\n\t\t\tmap->unlock = regmap_unlock_hwlock_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmap->lock = regmap_lock_hwlock;\n\t\t\tmap->unlock = regmap_unlock_hwlock;\n\t\t\tbreak;\n\t\t}\n\n\t\tmap->lock_arg = map;\n\t} else {\n\t\tif ((bus && bus->fast_io) ||\n\t\t    config->fast_io) {\n\t\t\tif (config->use_raw_spinlock) {\n\t\t\t\traw_spin_lock_init(&map->raw_spinlock);\n\t\t\t\tmap->lock = regmap_lock_raw_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_raw_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->raw_spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t} else {\n\t\t\t\tspin_lock_init(&map->spinlock);\n\t\t\t\tmap->lock = regmap_lock_spinlock;\n\t\t\t\tmap->unlock = regmap_unlock_spinlock;\n\t\t\t\tlockdep_set_class_and_name(&map->spinlock,\n\t\t\t\t\t\t\t   lock_key, lock_name);\n\t\t\t}\n\t\t} else {\n\t\t\tmutex_init(&map->mutex);\n\t\t\tmap->lock = regmap_lock_mutex;\n\t\t\tmap->unlock = regmap_unlock_mutex;\n\t\t\tmap->can_sleep = true;\n\t\t\tlockdep_set_class_and_name(&map->mutex,\n\t\t\t\t\t\t   lock_key, lock_name);\n\t\t}\n\t\tmap->lock_arg = map;\n\t}\n\n\t/*\n\t * When we write in fast-paths with regmap_bulk_write() don't allocate\n\t * scratch buffers with sleeping allocations.\n\t */\n\tif ((bus && bus->fast_io) || config->fast_io)\n\t\tmap->alloc_flags = GFP_ATOMIC;\n\telse\n\t\tmap->alloc_flags = GFP_KERNEL;\n\n\tmap->reg_base = config->reg_base;\n\n\tmap->format.reg_bytes = DIV_ROUND_UP(config->reg_bits, 8);\n\tmap->format.pad_bytes = config->pad_bits / 8;\n\tmap->format.reg_shift = config->reg_shift;\n\tmap->format.val_bytes = DIV_ROUND_UP(config->val_bits, 8);\n\tmap->format.buf_size = DIV_ROUND_UP(config->reg_bits +\n\t\t\tconfig->val_bits + config->pad_bits, 8);\n\tmap->reg_shift = config->pad_bits % 8;\n\tif (config->reg_stride)\n\t\tmap->reg_stride = config->reg_stride;\n\telse\n\t\tmap->reg_stride = 1;\n\tif (is_power_of_2(map->reg_stride))\n\t\tmap->reg_stride_order = ilog2(map->reg_stride);\n\telse\n\t\tmap->reg_stride_order = -1;\n\tmap->use_single_read = config->use_single_read || !(config->read || (bus && bus->read));\n\tmap->use_single_write = config->use_single_write || !(config->write || (bus && bus->write));\n\tmap->can_multi_write = config->can_multi_write && (config->write || (bus && bus->write));\n\tif (bus) {\n\t\tmap->max_raw_read = bus->max_raw_read;\n\t\tmap->max_raw_write = bus->max_raw_write;\n\t} else if (config->max_raw_read && config->max_raw_write) {\n\t\tmap->max_raw_read = config->max_raw_read;\n\t\tmap->max_raw_write = config->max_raw_write;\n\t}\n\tmap->dev = dev;\n\tmap->bus = bus;\n\tmap->bus_context = bus_context;\n\tmap->max_register = config->max_register;\n\tmap->max_register_is_set = map->max_register ?: config->max_register_is_0;\n\tmap->wr_table = config->wr_table;\n\tmap->rd_table = config->rd_table;\n\tmap->volatile_table = config->volatile_table;\n\tmap->precious_table = config->precious_table;\n\tmap->wr_noinc_table = config->wr_noinc_table;\n\tmap->rd_noinc_table = config->rd_noinc_table;\n\tmap->writeable_reg = config->writeable_reg;\n\tmap->readable_reg = config->readable_reg;\n\tmap->volatile_reg = config->volatile_reg;\n\tmap->precious_reg = config->precious_reg;\n\tmap->writeable_noinc_reg = config->writeable_noinc_reg;\n\tmap->readable_noinc_reg = config->readable_noinc_reg;\n\tmap->cache_type = config->cache_type;\n\n\tspin_lock_init(&map->async_lock);\n\tINIT_LIST_HEAD(&map->async_list);\n\tINIT_LIST_HEAD(&map->async_free);\n\tinit_waitqueue_head(&map->async_waitq);\n\n\tif (config->read_flag_mask ||\n\t    config->write_flag_mask ||\n\t    config->zero_flag_mask) {\n\t\tmap->read_flag_mask = config->read_flag_mask;\n\t\tmap->write_flag_mask = config->write_flag_mask;\n\t} else if (bus) {\n\t\tmap->read_flag_mask = bus->read_flag_mask;\n\t}\n\n\tif (config && config->read && config->write) {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tif (config->reg_update_bits)\n\t\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\t/* Bulk read/write */\n\t\tmap->read = config->read;\n\t\tmap->write = config->write;\n\n\t\treg_endian = REGMAP_ENDIAN_NATIVE;\n\t\tval_endian = REGMAP_ENDIAN_NATIVE;\n\t} else if (!bus) {\n\t\tmap->reg_read  = config->reg_read;\n\t\tmap->reg_write = config->reg_write;\n\t\tmap->reg_update_bits = config->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else if (!bus->read || !bus->write) {\n\t\tmap->reg_read = _regmap_bus_reg_read;\n\t\tmap->reg_write = _regmap_bus_reg_write;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\n\t\tmap->defer_caching = false;\n\t\tgoto skip_format_initialization;\n\t} else {\n\t\tmap->reg_read  = _regmap_bus_read;\n\t\tmap->reg_update_bits = bus->reg_update_bits;\n\t\t/* Bulk read/write */\n\t\tmap->read = bus->read;\n\t\tmap->write = bus->write;\n\n\t\treg_endian = regmap_get_reg_endian(bus, config);\n\t\tval_endian = regmap_get_val_endian(dev, bus, config);\n\t}\n\n\tswitch (config->reg_bits + map->reg_shift) {\n\tcase 2:\n\t\tswitch (config->val_bits) {\n\t\tcase 6:\n\t\t\tmap->format.format_write = regmap_format_2_6_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 4:\n\t\tswitch (config->val_bits) {\n\t\tcase 12:\n\t\t\tmap->format.format_write = regmap_format_4_12_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 7:\n\t\tswitch (config->val_bits) {\n\t\tcase 9:\n\t\t\tmap->format.format_write = regmap_format_7_9_write;\n\t\t\tbreak;\n\t\tcase 17:\n\t\t\tmap->format.format_write = regmap_format_7_17_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 10:\n\t\tswitch (config->val_bits) {\n\t\tcase 14:\n\t\t\tmap->format.format_write = regmap_format_10_14_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 12:\n\t\tswitch (config->val_bits) {\n\t\tcase 20:\n\t\t\tmap->format.format_write = regmap_format_12_20_write;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 8:\n\t\tmap->format.format_reg = regmap_format_8;\n\t\tbreak;\n\n\tcase 16:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_16_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_16_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 24:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tcase 32:\n\t\tswitch (reg_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_reg = regmap_format_32_be;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_reg = regmap_format_32_le;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_reg = regmap_format_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tgoto err_hwlock;\n\t}\n\n\tif (val_endian == REGMAP_ENDIAN_NATIVE)\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\n\tswitch (config->val_bits) {\n\tcase 8:\n\t\tmap->format.format_val = regmap_format_8;\n\t\tmap->format.parse_val = regmap_parse_8;\n\t\tmap->format.parse_inplace = regmap_parse_inplace_noop;\n\t\tbreak;\n\tcase 16:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_16_be;\n\t\t\tmap->format.parse_val = regmap_parse_16_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_16_le;\n\t\t\tmap->format.parse_val = regmap_parse_16_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_16_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_16_native;\n\t\t\tmap->format.parse_val = regmap_parse_16_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 24:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_24_be;\n\t\t\tmap->format.parse_val = regmap_parse_24_be;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\tcase 32:\n\t\tswitch (val_endian) {\n\t\tcase REGMAP_ENDIAN_BIG:\n\t\t\tmap->format.format_val = regmap_format_32_be;\n\t\t\tmap->format.parse_val = regmap_parse_32_be;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_be_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_LITTLE:\n\t\t\tmap->format.format_val = regmap_format_32_le;\n\t\t\tmap->format.parse_val = regmap_parse_32_le;\n\t\t\tmap->format.parse_inplace = regmap_parse_32_le_inplace;\n\t\t\tbreak;\n\t\tcase REGMAP_ENDIAN_NATIVE:\n\t\t\tmap->format.format_val = regmap_format_32_native;\n\t\t\tmap->format.parse_val = regmap_parse_32_native;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err_hwlock;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (map->format.format_write) {\n\t\tif ((reg_endian != REGMAP_ENDIAN_BIG) ||\n\t\t    (val_endian != REGMAP_ENDIAN_BIG))\n\t\t\tgoto err_hwlock;\n\t\tmap->use_single_write = true;\n\t}\n\n\tif (!map->format.format_write &&\n\t    !(map->format.format_reg && map->format.format_val))\n\t\tgoto err_hwlock;\n\n\tmap->work_buf = kzalloc(map->format.buf_size, GFP_KERNEL);\n\tif (map->work_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hwlock;\n\t}\n\n\tif (map->format.format_write) {\n\t\tmap->defer_caching = false;\n\t\tmap->reg_write = _regmap_bus_formatted_write;\n\t} else if (map->format.format_val) {\n\t\tmap->defer_caching = true;\n\t\tmap->reg_write = _regmap_bus_raw_write;\n\t}\n\nskip_format_initialization:\n\n\tmap->range_tree = RB_ROOT;\n\tfor (i = 0; i < config->num_ranges; i++) {\n\t\tconst struct regmap_range_cfg *range_cfg = &config->ranges[i];\n\t\tstruct regmap_range_node *new;\n\n\t\t/* Sanity check */\n\t\tif (range_cfg->range_max < range_cfg->range_min) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d < %d\\n\", i,\n\t\t\t\trange_cfg->range_max, range_cfg->range_min);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->range_max > map->max_register) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: %d > %d\\n\", i,\n\t\t\t\trange_cfg->range_max, map->max_register);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->selector_reg > map->max_register) {\n\t\t\tdev_err(map->dev,\n\t\t\t\t\"Invalid range %d: selector out of map\\n\", i);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (range_cfg->window_len == 0) {\n\t\t\tdev_err(map->dev, \"Invalid range %d: window_len 0\\n\",\n\t\t\t\ti);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\t/* Make sure, that this register range has no selector\n\t\t   or data window within its boundary */\n\t\tfor (j = 0; j < config->num_ranges; j++) {\n\t\t\tunsigned int sel_reg = config->ranges[j].selector_reg;\n\t\t\tunsigned int win_min = config->ranges[j].window_start;\n\t\t\tunsigned int win_max = win_min +\n\t\t\t\t\t       config->ranges[j].window_len - 1;\n\n\t\t\t/* Allow data window inside its own virtual range */\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (range_cfg->range_min <= sel_reg &&\n\t\t\t    sel_reg <= range_cfg->range_max) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: selector for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\n\t\t\tif (!(win_max < range_cfg->range_min ||\n\t\t\t      win_min > range_cfg->range_max)) {\n\t\t\t\tdev_err(map->dev,\n\t\t\t\t\t\"Range %d: window for %d in window\\n\",\n\t\t\t\t\ti, j);\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (new == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tnew->map = map;\n\t\tnew->name = range_cfg->name;\n\t\tnew->range_min = range_cfg->range_min;\n\t\tnew->range_max = range_cfg->range_max;\n\t\tnew->selector_reg = range_cfg->selector_reg;\n\t\tnew->selector_mask = range_cfg->selector_mask;\n\t\tnew->selector_shift = range_cfg->selector_shift;\n\t\tnew->window_start = range_cfg->window_start;\n\t\tnew->window_len = range_cfg->window_len;\n\n\t\tif (!_regmap_range_add(map, new)) {\n\t\t\tdev_err(map->dev, \"Failed to add range %d\\n\", i);\n\t\t\tkfree(new);\n\t\t\tgoto err_range;\n\t\t}\n\n\t\tif (map->selector_work_buf == NULL) {\n\t\t\tmap->selector_work_buf =\n\t\t\t\tkzalloc(map->format.buf_size, GFP_KERNEL);\n\t\t\tif (map->selector_work_buf == NULL) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err_range;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = regcache_init(map, config);\n\tif (ret != 0)\n\t\tgoto err_range;\n\n\tif (dev) {\n\t\tret = regmap_attach_dev(dev, map, config);\n\t\tif (ret != 0)\n\t\t\tgoto err_regcache;\n\t} else {\n\t\tregmap_debugfs_init(map);\n\t}\n\n\treturn map;\n\nerr_regcache:\n\tregcache_exit(map);\nerr_range:\n\tregmap_range_exit(map);\n\tkfree(map->work_buf);\nerr_hwlock:\n\tif (map->hwlock)\n\t\thwspin_lock_free(map->hwlock);\nerr_name:\n\tkfree_const(map->name);\nerr_map:\n\tkfree(map);\nerr:\n\treturn ERR_PTR(ret);\n}"
    },
    {
        "var_name": "pd",
        "function_name": "pkt_bio_finished",
        "location": {
            "file_path": "drivers/block/pktcdvd.c",
            "region": {
                "startLine": 534,
                "startColumn": 36,
                "endColumn": 38
            },
            "context": {
                "startLine": 532,
                "endLine": 536,
                "snippet": {
                    "text": "struct device *ddev = disk_to_dev(pd->disk);"
                }
            }
        },
        "function_code": "static void pkt_bio_finished(struct pktcdvd_device *pd)\n{\n\tstruct device *ddev = disk_to_dev(pd->disk);\n\n\tBUG_ON(atomic_read(&pd->cdrw.pending_bios) <= 0);\n\tif (atomic_dec_and_test(&pd->cdrw.pending_bios)) {\n\t\tdev_dbg(ddev, \"queue empty\\n\");\n\t\tatomic_set(&pd->iosched.attention, 1);\n\t\twake_up(&pd->wqueue);\n\t}\n}"
    },
    {
        "var_name": "pd",
        "function_name": "pkt_end_io_read",
        "location": {
            "file_path": "drivers/block/pktcdvd.c",
            "region": {
                "startLine": 979,
                "startColumn": 22,
                "endColumn": 24
            },
            "context": {
                "startLine": 977,
                "endLine": 981,
                "snippet": {
                    "text": "dev_dbg(disk_to_dev(pd->disk), \"bio=%p sec0=%llx sec=%llx err=%d\\n\","
                }
            }
        },
        "function_code": "static void pkt_end_io_read(struct bio *bio)\n{\n\tstruct packet_data *pkt = bio->bi_private;\n\tstruct pktcdvd_device *pd = pkt->pd;\n\tBUG_ON(!pd);\n\n\tdev_dbg(disk_to_dev(pd->disk), \"bio=%p sec0=%llx sec=%llx err=%d\\n\",\n\t\tbio, pkt->sector, bio->bi_iter.bi_sector, bio->bi_status);\n\n\tif (bio->bi_status)\n\t\tatomic_inc(&pkt->io_errors);\n\tbio_uninit(bio);\n\tif (atomic_dec_and_test(&pkt->io_wait)) {\n\t\tatomic_inc(&pkt->run_sm);\n\t\twake_up(&pd->wqueue);\n\t}\n\tpkt_bio_finished(pd);\n}"
    },
    {
        "var_name": "pd",
        "function_name": "pkt_end_io_packet_write",
        "location": {
            "file_path": "drivers/block/pktcdvd.c",
            "region": {
                "startLine": 998,
                "startColumn": 22,
                "endColumn": 24
            },
            "context": {
                "startLine": 996,
                "endLine": 1000,
                "snippet": {
                    "text": "dev_dbg(disk_to_dev(pd->disk), \"id=%d, err=%d\\n\", pkt->id, bio->bi_status);"
                }
            }
        },
        "function_code": "static void pkt_end_io_packet_write(struct bio *bio)\n{\n\tstruct packet_data *pkt = bio->bi_private;\n\tstruct pktcdvd_device *pd = pkt->pd;\n\tBUG_ON(!pd);\n\n\tdev_dbg(disk_to_dev(pd->disk), \"id=%d, err=%d\\n\", pkt->id, bio->bi_status);\n\n\tpd->stats.pkt_ended++;\n\n\tbio_uninit(bio);\n\tpkt_bio_finished(pd);\n\tatomic_dec(&pkt->io_wait);\n\tatomic_inc(&pkt->run_sm);\n\twake_up(&pd->wqueue);\n}"
    },
    {
        "var_name": "pd",
        "function_name": "pkt_end_io_packet_write",
        "location": {
            "file_path": "drivers/block/pktcdvd.c",
            "region": {
                "startLine": 1000,
                "startColumn": 2,
                "endColumn": 4
            },
            "context": {
                "startLine": 998,
                "endLine": 1002,
                "snippet": {
                    "text": "pd->stats.pkt_ended++;"
                }
            }
        },
        "function_code": "static void pkt_end_io_packet_write(struct bio *bio)\n{\n\tstruct packet_data *pkt = bio->bi_private;\n\tstruct pktcdvd_device *pd = pkt->pd;\n\tBUG_ON(!pd);\n\n\tdev_dbg(disk_to_dev(pd->disk), \"id=%d, err=%d\\n\", pkt->id, bio->bi_status);\n\n\tpd->stats.pkt_ended++;\n\n\tbio_uninit(bio);\n\tpkt_bio_finished(pd);\n\tatomic_dec(&pkt->io_wait);\n\tatomic_inc(&pkt->run_sm);\n\twake_up(&pd->wqueue);\n}"
    },
    {
        "var_name": "data",
        "function_name": "rz_cpg_clocks_init",
        "location": {
            "file_path": "drivers/clk/renesas/clk-rz.c",
            "region": {
                "startLine": 98,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 96,
                "endLine": 100,
                "snippet": {
                    "text": "data->clks = clks;"
                }
            }
        },
        "function_code": "static void __init rz_cpg_clocks_init(struct device_node *np)\n{\n\tstruct clk_onecell_data *data;\n\tstruct clk **clks;\n\tvoid __iomem *base;\n\tunsigned i;\n\tint num_clks;\n\n\tnum_clks = of_property_count_strings(np, \"clock-output-names\");\n\tif (WARN(num_clks <= 0, \"can't count CPG clocks\\n\"))\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tclks = kcalloc(num_clks, sizeof(*clks), GFP_KERNEL);\n\tBUG_ON(!data || !clks);\n\n\tdata->clks = clks;\n\tdata->clk_num = num_clks;\n\n\tbase = of_iomap(np, 0);\n\n\tfor (i = 0; i < num_clks; ++i) {\n\t\tconst char *name;\n\t\tstruct clk *clk;\n\n\t\tof_property_read_string_index(np, \"clock-output-names\", i, &name);\n\n\t\tclk = rz_cpg_register_clock(np, base, name);\n\t\tif (IS_ERR(clk))\n\t\t\tpr_err(\"%s: failed to register %pOFn %s clock (%ld)\\n\",\n\t\t\t       __func__, np, name, PTR_ERR(clk));\n\t\telse\n\t\t\tdata->clks[i] = clk;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, data);\n\n\tcpg_mstp_add_clk_domain(np);\n}"
    },
    {
        "var_name": "data",
        "function_name": "rz_cpg_clocks_init",
        "location": {
            "file_path": "drivers/clk/renesas/clk-rz.c",
            "region": {
                "startLine": 99,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 97,
                "endLine": 101,
                "snippet": {
                    "text": "data->clk_num = num_clks;"
                }
            }
        },
        "function_code": "static void __init rz_cpg_clocks_init(struct device_node *np)\n{\n\tstruct clk_onecell_data *data;\n\tstruct clk **clks;\n\tvoid __iomem *base;\n\tunsigned i;\n\tint num_clks;\n\n\tnum_clks = of_property_count_strings(np, \"clock-output-names\");\n\tif (WARN(num_clks <= 0, \"can't count CPG clocks\\n\"))\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tclks = kcalloc(num_clks, sizeof(*clks), GFP_KERNEL);\n\tBUG_ON(!data || !clks);\n\n\tdata->clks = clks;\n\tdata->clk_num = num_clks;\n\n\tbase = of_iomap(np, 0);\n\n\tfor (i = 0; i < num_clks; ++i) {\n\t\tconst char *name;\n\t\tstruct clk *clk;\n\n\t\tof_property_read_string_index(np, \"clock-output-names\", i, &name);\n\n\t\tclk = rz_cpg_register_clock(np, base, name);\n\t\tif (IS_ERR(clk))\n\t\t\tpr_err(\"%s: failed to register %pOFn %s clock (%ld)\\n\",\n\t\t\t       __func__, np, name, PTR_ERR(clk));\n\t\telse\n\t\t\tdata->clks[i] = clk;\n\t}\n\n\tof_clk_add_provider(np, of_clk_src_onecell_get, data);\n\n\tcpg_mstp_add_clk_domain(np);\n}"
    },
    {
        "var_name": "protected",
        "function_name": "sunxi_simple_gates_setup",
        "location": {
            "file_path": "drivers/clk/sunxi/clk-simple-gates.c",
            "region": {
                "startLine": 70,
                "startColumn": 8,
                "endColumn": 17
            },
            "context": {
                "startLine": 68,
                "endLine": 72,
                "snippet": {
                    "text": "if (protected[j] == index)"
                }
            }
        },
        "function_code": "static void __init sunxi_simple_gates_setup(struct device_node *node,\n\t\t\t\t\t    const int protected[],\n\t\t\t\t\t    int nprotected)\n{\n\tstruct clk_onecell_data *clk_data;\n\tconst char *clk_parent, *clk_name;\n\tstruct property *prop;\n\tstruct resource res;\n\tvoid __iomem *clk_reg;\n\tvoid __iomem *reg;\n\tconst __be32 *p;\n\tint number, i = 0, j;\n\tu8 clk_bit;\n\tu32 index;\n\n\treg = of_io_request_and_map(node, 0, of_node_full_name(node));\n\tif (IS_ERR(reg))\n\t\treturn;\n\n\tclk_parent = of_clk_get_parent_name(node, 0);\n\n\tclk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);\n\tif (!clk_data)\n\t\tgoto err_unmap;\n\n\tnumber = of_property_count_u32_elems(node, \"clock-indices\");\n\tof_property_read_u32_index(node, \"clock-indices\", number - 1, &number);\n\n\tclk_data->clks = kcalloc(number + 1, sizeof(struct clk *), GFP_KERNEL);\n\tif (!clk_data->clks)\n\t\tgoto err_free_data;\n\n\tof_property_for_each_u32(node, \"clock-indices\", prop, p, index) {\n\t\tof_property_read_string_index(node, \"clock-output-names\",\n\t\t\t\t\t      i, &clk_name);\n\n\t\tclk_reg = reg + 4 * (index / 32);\n\t\tclk_bit = index % 32;\n\n\t\tclk_data->clks[index] = clk_register_gate(NULL, clk_name,\n\t\t\t\t\t\t\t  clk_parent, 0,\n\t\t\t\t\t\t\t  clk_reg,\n\t\t\t\t\t\t\t  clk_bit,\n\t\t\t\t\t\t\t  0, &gates_lock);\n\t\ti++;\n\n\t\tif (IS_ERR(clk_data->clks[index])) {\n\t\t\tWARN_ON(true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < nprotected; j++)\n\t\t\tif (protected[j] == index)\n\t\t\t\tclk_prepare_enable(clk_data->clks[index]);\n\n\t}\n\n\tclk_data->clk_num = number + 1;\n\tof_clk_add_provider(node, of_clk_src_onecell_get, clk_data);\n\n\treturn;\n\nerr_free_data:\n\tkfree(clk_data);\nerr_unmap:\n\tiounmap(reg);\n\tof_address_to_resource(node, 0, &res);\n\trelease_mem_region(res.start, resource_size(&res));\n}"
    },
    {
        "var_name": "adtx",
        "function_name": "admac_tx_status",
        "location": {
            "file_path": "drivers/dma/apple-admac.c",
            "region": {
                "startLine": 397,
                "startColumn": 8,
                "endColumn": 12
            },
            "context": {
                "startLine": 395,
                "endLine": 399,
                "snippet": {
                    "text": "if (adtx->tx.cookie == cookie) {"
                }
            }
        },
        "function_code": "static enum dma_status admac_tx_status(struct dma_chan *chan, dma_cookie_t cookie,\n\t\t\t\t       struct dma_tx_state *txstate)\n{\n\tstruct admac_chan *adchan = to_admac_chan(chan);\n\tstruct admac_data *ad = adchan->host;\n\tstruct admac_tx *adtx;\n\n\tenum dma_status ret;\n\tsize_t residue;\n\tunsigned long flags;\n\n\tret = dma_cookie_status(chan, cookie, txstate);\n\tif (ret == DMA_COMPLETE || !txstate)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&adchan->lock, flags);\n\tadtx = adchan->current_tx;\n\n\tif (adtx && adtx->tx.cookie == cookie) {\n\t\tret = DMA_IN_PROGRESS;\n\t\tresidue = admac_cyclic_read_residue(ad, adchan->no, adtx);\n\t} else {\n\t\tret = DMA_IN_PROGRESS;\n\t\tresidue = 0;\n\t\tlist_for_each_entry(adtx, &adchan->issued, node) {\n\t\t\tif (adtx->tx.cookie == cookie) {\n\t\t\t\tresidue = adtx->buf_len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&adchan->lock, flags);\n\n\tdma_set_residue(txstate, residue);\n\treturn ret;\n}"
    },
    {
        "var_name": "desc",
        "function_name": "pl330_get_desc",
        "location": {
            "file_path": "drivers/dma/pl330.c",
            "region": {
                "startLine": 2618,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2616,
                "endLine": 2620,
                "snippet": {
                    "text": "desc->pchan = pch;"
                }
            }
        },
        "function_code": "static struct dma_pl330_desc *pl330_get_desc(struct dma_pl330_chan *pch)\n{\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tu8 *peri_id = pch->chan.private;\n\tstruct dma_pl330_desc *desc;\n\n\t/* Pluck one desc from the pool of DMAC */\n\tdesc = pluck_desc(&pl330->desc_pool, &pl330->pool_lock);\n\n\t/* If the DMAC pool is empty, alloc new */\n\tif (!desc) {\n\t\tstatic DEFINE_SPINLOCK(lock);\n\t\tLIST_HEAD(pool);\n\n\t\tif (!add_desc(&pool, &lock, GFP_ATOMIC, 1))\n\t\t\treturn NULL;\n\n\t\tdesc = pluck_desc(&pool, &lock);\n\t\tWARN_ON(!desc || !list_empty(&pool));\n\t}\n\n\t/* Initialize the descriptor */\n\tdesc->pchan = pch;\n\tdesc->txd.cookie = 0;\n\tasync_tx_ack(&desc->txd);\n\n\tdesc->peri = peri_id ? pch->chan.chan_id : 0;\n\tdesc->rqcfg.pcfg = &pch->dmac->pcfg;\n\n\tdma_async_tx_descriptor_init(&desc->txd, &pch->chan);\n\n\treturn desc;\n}"
    },
    {
        "var_name": "desc",
        "function_name": "pl330_get_desc",
        "location": {
            "file_path": "drivers/dma/pl330.c",
            "region": {
                "startLine": 2619,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2617,
                "endLine": 2621,
                "snippet": {
                    "text": "desc->txd.cookie = 0;"
                }
            }
        },
        "function_code": "static struct dma_pl330_desc *pl330_get_desc(struct dma_pl330_chan *pch)\n{\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tu8 *peri_id = pch->chan.private;\n\tstruct dma_pl330_desc *desc;\n\n\t/* Pluck one desc from the pool of DMAC */\n\tdesc = pluck_desc(&pl330->desc_pool, &pl330->pool_lock);\n\n\t/* If the DMAC pool is empty, alloc new */\n\tif (!desc) {\n\t\tstatic DEFINE_SPINLOCK(lock);\n\t\tLIST_HEAD(pool);\n\n\t\tif (!add_desc(&pool, &lock, GFP_ATOMIC, 1))\n\t\t\treturn NULL;\n\n\t\tdesc = pluck_desc(&pool, &lock);\n\t\tWARN_ON(!desc || !list_empty(&pool));\n\t}\n\n\t/* Initialize the descriptor */\n\tdesc->pchan = pch;\n\tdesc->txd.cookie = 0;\n\tasync_tx_ack(&desc->txd);\n\n\tdesc->peri = peri_id ? pch->chan.chan_id : 0;\n\tdesc->rqcfg.pcfg = &pch->dmac->pcfg;\n\n\tdma_async_tx_descriptor_init(&desc->txd, &pch->chan);\n\n\treturn desc;\n}"
    },
    {
        "var_name": "desc",
        "function_name": "pl330_get_desc",
        "location": {
            "file_path": "drivers/dma/pl330.c",
            "region": {
                "startLine": 2622,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2620,
                "endLine": 2624,
                "snippet": {
                    "text": "desc->peri = peri_id ? pch->chan.chan_id : 0;"
                }
            }
        },
        "function_code": "static struct dma_pl330_desc *pl330_get_desc(struct dma_pl330_chan *pch)\n{\n\tstruct pl330_dmac *pl330 = pch->dmac;\n\tu8 *peri_id = pch->chan.private;\n\tstruct dma_pl330_desc *desc;\n\n\t/* Pluck one desc from the pool of DMAC */\n\tdesc = pluck_desc(&pl330->desc_pool, &pl330->pool_lock);\n\n\t/* If the DMAC pool is empty, alloc new */\n\tif (!desc) {\n\t\tstatic DEFINE_SPINLOCK(lock);\n\t\tLIST_HEAD(pool);\n\n\t\tif (!add_desc(&pool, &lock, GFP_ATOMIC, 1))\n\t\t\treturn NULL;\n\n\t\tdesc = pluck_desc(&pool, &lock);\n\t\tWARN_ON(!desc || !list_empty(&pool));\n\t}\n\n\t/* Initialize the descriptor */\n\tdesc->pchan = pch;\n\tdesc->txd.cookie = 0;\n\tasync_tx_ack(&desc->txd);\n\n\tdesc->peri = peri_id ? pch->chan.chan_id : 0;\n\tdesc->rqcfg.pcfg = &pch->dmac->pcfg;\n\n\tdma_async_tx_descriptor_init(&desc->txd, &pch->chan);\n\n\treturn desc;\n}"
    },
    {
        "var_name": "desc",
        "function_name": "ppc440spe_dma_put_desc",
        "location": {
            "file_path": "drivers/dma/ppc4xx/adma.c",
            "region": {
                "startLine": 1080,
                "startColumn": 9,
                "endColumn": 13
            },
            "context": {
                "startLine": 1078,
                "endLine": 1082,
                "snippet": {
                    "text": "pcdb = desc->phys;"
                }
            }
        },
        "function_code": "static void ppc440spe_dma_put_desc(struct ppc440spe_adma_chan *chan,\n\t\tstruct ppc440spe_adma_desc_slot *desc)\n{\n\tu32 pcdb;\n\tstruct dma_regs *dma_reg = chan->device->dma_reg;\n\n\tpcdb = desc->phys;\n\tif (!test_bit(PPC440SPE_DESC_INT, &desc->flags))\n\t\tpcdb |= DMA_CDB_NO_INT;\n\n\tchan_last_sub[chan->device->id] = desc;\n\n\tADMA_LL_DBG(print_cb(chan, desc->hw_desc));\n\n\tiowrite32(pcdb, &dma_reg->cpfpl);\n}"
    },
    {
        "var_name": "iter",
        "function_name": "ppc440spe_chan_append",
        "location": {
            "file_path": "drivers/dma/ppc4xx/adma.c",
            "region": {
                "startLine": 1121,
                "startColumn": 8,
                "endColumn": 12
            },
            "context": {
                "startLine": 1119,
                "endLine": 1123,
                "snippet": {
                    "text": "if (!iter->hw_next)"
                }
            }
        },
        "function_code": "static void ppc440spe_chan_append(struct ppc440spe_adma_chan *chan)\n{\n\tstruct xor_regs *xor_reg;\n\tstruct ppc440spe_adma_desc_slot *iter;\n\tstruct xor_cb *xcb;\n\tu32 cur_desc;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tswitch (chan->device->id) {\n\tcase PPC440SPE_DMA0_ID:\n\tcase PPC440SPE_DMA1_ID:\n\t\tcur_desc = ppc440spe_chan_get_current_descriptor(chan);\n\n\t\tif (likely(cur_desc)) {\n\t\t\titer = chan_last_sub[chan->device->id];\n\t\t\tBUG_ON(!iter);\n\t\t} else {\n\t\t\t/* first peer */\n\t\t\titer = chan_first_cdb[chan->device->id];\n\t\t\tBUG_ON(!iter);\n\t\t\tppc440spe_dma_put_desc(chan, iter);\n\t\t\tchan->hw_chain_inited = 1;\n\t\t}\n\n\t\t/* is there something new to append */\n\t\tif (!iter->hw_next)\n\t\t\tbreak;\n\n\t\t/* flush descriptors from the s/w queue to fifo */\n\t\tlist_for_each_entry_continue(iter, &chan->chain, chain_node) {\n\t\t\tppc440spe_dma_put_desc(chan, iter);\n\t\t\tif (!iter->hw_next)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PPC440SPE_XOR_ID:\n\t\t/* update h/w links and refetch */\n\t\tif (!xor_last_submit->hw_next)\n\t\t\tbreak;\n\n\t\txor_reg = chan->device->xor_reg;\n\t\t/* the last linked CDB has to generate an interrupt\n\t\t * that we'd be able to append the next lists to h/w\n\t\t * regardless of the XOR engine state at the moment of\n\t\t * appending of these next lists\n\t\t */\n\t\txcb = xor_last_linked->hw_desc;\n\t\txcb->cbc |= XOR_CBCR_CBCE_BIT;\n\n\t\tif (!(ioread32be(&xor_reg->sr) & XOR_SR_XCP_BIT)) {\n\t\t\t/* XORcore is idle. Refetch now */\n\t\t\tdo_xor_refetch = 0;\n\t\t\tppc440spe_xor_set_link(xor_last_submit,\n\t\t\t\txor_last_submit->hw_next);\n\n\t\t\tADMA_LL_DBG(print_cb_list(chan,\n\t\t\t\txor_last_submit->hw_next));\n\n\t\t\txor_last_submit = xor_last_linked;\n\t\t\tiowrite32be(ioread32be(&xor_reg->crsr) |\n\t\t\t\t    XOR_CRSR_RCBE_BIT | XOR_CRSR_64BA_BIT,\n\t\t\t\t    &xor_reg->crsr);\n\t\t} else {\n\t\t\t/* XORcore is running. Refetch later in the handler */\n\t\t\tdo_xor_refetch = 1;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tlocal_irq_restore(flags);\n}"
    },
    {
        "var_name": "scf",
        "function_name": "ppc440spe_adma_prep_dma_pqzero_sum",
        "location": {
            "file_path": "drivers/dma/ppc4xx/adma.c",
            "region": {
                "startLine": 2748,
                "startColumn": 12,
                "endColumn": 15
            },
            "context": {
                "startLine": 2746,
                "endLine": 2750,
                "snippet": {
                    "text": "scf[src_cnt - 1]);"
                }
            }
        },
        "function_code": "static struct dma_async_tx_descriptor *ppc440spe_adma_prep_dma_pqzero_sum(\n\t\tstruct dma_chan *chan, dma_addr_t *pq, dma_addr_t *src,\n\t\tunsigned int src_cnt, const unsigned char *scf, size_t len,\n\t\tenum sum_check_flags *pqres, unsigned long flags)\n{\n\tstruct ppc440spe_adma_chan *ppc440spe_chan;\n\tstruct ppc440spe_adma_desc_slot *sw_desc, *iter;\n\tdma_addr_t pdest, qdest;\n\tint slot_cnt, slots_per_op, idst, dst_cnt;\n\n\tppc440spe_chan = to_ppc440spe_adma_chan(chan);\n\n\tif (flags & DMA_PREP_PQ_DISABLE_P)\n\t\tpdest = 0;\n\telse\n\t\tpdest = pq[0];\n\n\tif (flags & DMA_PREP_PQ_DISABLE_Q)\n\t\tqdest = 0;\n\telse\n\t\tqdest = pq[1];\n\n\tADMA_LL_DBG(prep_dma_pqzero_sum_dbg(ppc440spe_chan->device->id,\n\t\t\t\t\t    src, src_cnt, scf));\n\n\t/* Always use WXOR for P/Q calculations (two destinations).\n\t * Need 1 or 2 extra slots to verify results are zero.\n\t */\n\tidst = dst_cnt = (pdest && qdest) ? 2 : 1;\n\n\t/* One additional slot per destination to clone P/Q\n\t * before calculation (we have to preserve destinations).\n\t */\n\tslot_cnt = src_cnt + dst_cnt * 2;\n\tslots_per_op = 1;\n\n\tspin_lock_bh(&ppc440spe_chan->lock);\n\tsw_desc = ppc440spe_adma_alloc_slots(ppc440spe_chan, slot_cnt,\n\t\t\t\t\t     slots_per_op);\n\tif (sw_desc) {\n\t\tppc440spe_desc_init_dma01pqzero_sum(sw_desc, dst_cnt, src_cnt);\n\n\t\t/* Setup byte count for each slot just allocated */\n\t\tsw_desc->async_tx.flags = flags;\n\t\tlist_for_each_entry(iter, &sw_desc->group_list, chain_node) {\n\t\t\tppc440spe_desc_set_byte_count(iter, ppc440spe_chan,\n\t\t\t\t\t\t      len);\n\t\t\titer->unmap_len = len;\n\t\t}\n\n\t\tif (pdest) {\n\t\t\tstruct dma_cdb *hw_desc;\n\t\t\tstruct ppc440spe_adma_chan *chan;\n\n\t\t\titer = sw_desc->group_head;\n\t\t\tchan = to_ppc440spe_adma_chan(iter->async_tx.chan);\n\t\t\tmemset(iter->hw_desc, 0, sizeof(struct dma_cdb));\n\t\t\titer->hw_next = list_entry(iter->chain_node.next,\n\t\t\t\t\t\tstruct ppc440spe_adma_desc_slot,\n\t\t\t\t\t\tchain_node);\n\t\t\thw_desc = iter->hw_desc;\n\t\t\thw_desc->opc = DMA_CDB_OPC_MV_SG1_SG2;\n\t\t\titer->src_cnt = 0;\n\t\t\titer->dst_cnt = 0;\n\t\t\tppc440spe_desc_set_dest_addr(iter, chan, 0,\n\t\t\t\t\t\t     ppc440spe_chan->pdest, 0);\n\t\t\tppc440spe_desc_set_src_addr(iter, chan, 0, 0, pdest);\n\t\t\tppc440spe_desc_set_byte_count(iter, ppc440spe_chan,\n\t\t\t\t\t\t      len);\n\t\t\titer->unmap_len = 0;\n\t\t\t/* override pdest to preserve original P */\n\t\t\tpdest = ppc440spe_chan->pdest;\n\t\t}\n\t\tif (qdest) {\n\t\t\tstruct dma_cdb *hw_desc;\n\t\t\tstruct ppc440spe_adma_chan *chan;\n\n\t\t\titer = list_first_entry(&sw_desc->group_list,\n\t\t\t\t\t\tstruct ppc440spe_adma_desc_slot,\n\t\t\t\t\t\tchain_node);\n\t\t\tchan = to_ppc440spe_adma_chan(iter->async_tx.chan);\n\n\t\t\tif (pdest) {\n\t\t\t\titer = list_entry(iter->chain_node.next,\n\t\t\t\t\t\tstruct ppc440spe_adma_desc_slot,\n\t\t\t\t\t\tchain_node);\n\t\t\t}\n\n\t\t\tmemset(iter->hw_desc, 0, sizeof(struct dma_cdb));\n\t\t\titer->hw_next = list_entry(iter->chain_node.next,\n\t\t\t\t\t\tstruct ppc440spe_adma_desc_slot,\n\t\t\t\t\t\tchain_node);\n\t\t\thw_desc = iter->hw_desc;\n\t\t\thw_desc->opc = DMA_CDB_OPC_MV_SG1_SG2;\n\t\t\titer->src_cnt = 0;\n\t\t\titer->dst_cnt = 0;\n\t\t\tppc440spe_desc_set_dest_addr(iter, chan, 0,\n\t\t\t\t\t\t     ppc440spe_chan->qdest, 0);\n\t\t\tppc440spe_desc_set_src_addr(iter, chan, 0, 0, qdest);\n\t\t\tppc440spe_desc_set_byte_count(iter, ppc440spe_chan,\n\t\t\t\t\t\t      len);\n\t\t\titer->unmap_len = 0;\n\t\t\t/* override qdest to preserve original Q */\n\t\t\tqdest = ppc440spe_chan->qdest;\n\t\t}\n\n\t\t/* Setup destinations for P/Q ops */\n\t\tppc440spe_adma_pqzero_sum_set_dest(sw_desc, pdest, qdest);\n\n\t\t/* Setup zero QWORDs into DCHECK CDBs */\n\t\tidst = dst_cnt;\n\t\tlist_for_each_entry_reverse(iter, &sw_desc->group_list,\n\t\t\t\t\t    chain_node) {\n\t\t\t/*\n\t\t\t * The last CDB corresponds to Q-parity check,\n\t\t\t * the one before last CDB corresponds\n\t\t\t * P-parity check\n\t\t\t */\n\t\t\tif (idst == DMA_DEST_MAX_NUM) {\n\t\t\t\tif (idst == dst_cnt) {\n\t\t\t\t\tset_bit(PPC440SPE_DESC_QCHECK,\n\t\t\t\t\t\t&iter->flags);\n\t\t\t\t} else {\n\t\t\t\t\tset_bit(PPC440SPE_DESC_PCHECK,\n\t\t\t\t\t\t&iter->flags);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (qdest) {\n\t\t\t\t\tset_bit(PPC440SPE_DESC_QCHECK,\n\t\t\t\t\t\t&iter->flags);\n\t\t\t\t} else {\n\t\t\t\t\tset_bit(PPC440SPE_DESC_PCHECK,\n\t\t\t\t\t\t&iter->flags);\n\t\t\t\t}\n\t\t\t}\n\t\t\titer->xor_check_result = pqres;\n\n\t\t\t/*\n\t\t\t * set it to zero, if check fail then result will\n\t\t\t * be updated\n\t\t\t */\n\t\t\t*iter->xor_check_result = 0;\n\t\t\tppc440spe_desc_set_dcheck(iter, ppc440spe_chan,\n\t\t\t\tppc440spe_qword);\n\n\t\t\tif (!(--dst_cnt))\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Setup sources and mults for P/Q ops */\n\t\tlist_for_each_entry_continue_reverse(iter, &sw_desc->group_list,\n\t\t\t\t\t\t     chain_node) {\n\t\t\tstruct ppc440spe_adma_chan *chan;\n\t\t\tu32 mult_dst;\n\n\t\t\tchan = to_ppc440spe_adma_chan(iter->async_tx.chan);\n\t\t\tppc440spe_desc_set_src_addr(iter, chan, 0,\n\t\t\t\t\t\t    DMA_CUED_XOR_HB,\n\t\t\t\t\t\t    src[src_cnt - 1]);\n\t\t\tif (qdest) {\n\t\t\t\tmult_dst = (dst_cnt - 1) ? DMA_CDB_SG_DST2 :\n\t\t\t\t\t\t\t   DMA_CDB_SG_DST1;\n\t\t\t\tppc440spe_desc_set_src_mult(iter, chan,\n\t\t\t\t\t\t\t    DMA_CUED_MULT1_OFF,\n\t\t\t\t\t\t\t    mult_dst,\n\t\t\t\t\t\t\t    scf[src_cnt - 1]);\n\t\t\t}\n\t\t\tif (!(--src_cnt))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&ppc440spe_chan->lock);\n\treturn sw_desc ? &sw_desc->async_tx : NULL;\n}"
    },
    {
        "var_name": "gchan",
        "function_name": "gpi_send_cmd",
        "location": {
            "file_path": "drivers/dma/qcom/gpi.c",
            "region": {
                "startLine": 697,
                "startColumn": 10,
                "endColumn": 15
            },
            "context": {
                "startLine": 695,
                "endLine": 699,
                "snippet": {
                    "text": "chid = gchan->chid;"
                }
            }
        },
        "function_code": "static int gpi_send_cmd(struct gpii *gpii, struct gchan *gchan,\n\t\t\tenum gpi_cmd gpi_cmd)\n{\n\tu32 chid = MAX_CHANNELS_PER_GPII;\n\tunsigned long timeout;\n\tvoid __iomem *cmd_reg;\n\tu32 cmd;\n\n\tif (gpi_cmd >= GPI_MAX_CMD)\n\t\treturn -EINVAL;\n\tif (IS_CHAN_CMD(gpi_cmd))\n\t\tchid = gchan->chid;\n\n\tdev_dbg(gpii->gpi_dev->dev,\n\t\t\"sending cmd: %s:%u\\n\", TO_GPI_CMD_STR(gpi_cmd), chid);\n\n\t/* send opcode and wait for completion */\n\treinit_completion(&gpii->cmd_completion);\n\tgpii->gpi_cmd = gpi_cmd;\n\n\tcmd_reg = IS_CHAN_CMD(gpi_cmd) ? gchan->ch_cmd_reg : gpii->ev_cmd_reg;\n\tcmd = IS_CHAN_CMD(gpi_cmd) ? GPII_n_CH_CMD(gpi_cmd_info[gpi_cmd].opcode, chid) :\n\t\t\t\t     GPII_n_EV_CMD(gpi_cmd_info[gpi_cmd].opcode, 0);\n\tgpi_write_reg(gpii, cmd_reg, cmd);\n\ttimeout = wait_for_completion_timeout(&gpii->cmd_completion,\n\t\t\t\t\t      msecs_to_jiffies(CMD_TIMEOUT_MS));\n\tif (!timeout) {\n\t\tdev_err(gpii->gpi_dev->dev, \"cmd: %s completion timeout:%u\\n\",\n\t\t\tTO_GPI_CMD_STR(gpi_cmd), chid);\n\t\treturn -EIO;\n\t}\n\n\t/* confirm new ch state is correct , if the cmd is a state change cmd */\n\tif (gpi_cmd_info[gpi_cmd].state == STATE_IGNORE)\n\t\treturn 0;\n\n\tif (IS_CHAN_CMD(gpi_cmd) && gchan->ch_state == gpi_cmd_info[gpi_cmd].state)\n\t\treturn 0;\n\n\tif (!IS_CHAN_CMD(gpi_cmd) && gpii->ev_state == gpi_cmd_info[gpi_cmd].state)\n\t\treturn 0;\n\n\treturn -EIO;\n}"
    },
    {
        "var_name": "vd",
        "function_name": "sf_pdma_desc_residue",
        "location": {
            "file_path": "drivers/dma/sf-pdma/sf-pdma.c",
            "region": {
                "startLine": 169,
                "startColumn": 7,
                "endColumn": 9
            },
            "context": {
                "startLine": 167,
                "endLine": 171,
                "snippet": {
                    "text": "if (vd->tx.cookie == cookie)"
                }
            }
        },
        "function_code": "static size_t sf_pdma_desc_residue(struct sf_pdma_chan *chan,\n\t\t\t\t   dma_cookie_t cookie)\n{\n\tstruct virt_dma_desc *vd = NULL;\n\tstruct pdma_regs *regs = &chan->regs;\n\tunsigned long flags;\n\tu64 residue = 0;\n\tstruct sf_pdma_desc *desc;\n\tstruct dma_async_tx_descriptor *tx = NULL;\n\n\tspin_lock_irqsave(&chan->vchan.lock, flags);\n\n\tlist_for_each_entry(vd, &chan->vchan.desc_submitted, node)\n\t\tif (vd->tx.cookie == cookie)\n\t\t\ttx = &vd->tx;\n\n\tif (!tx)\n\t\tgoto out;\n\n\tif (cookie == tx->chan->completed_cookie)\n\t\tgoto out;\n\n\tif (cookie == tx->cookie) {\n\t\tresidue = readq(regs->residue);\n\t} else {\n\t\tvd = vchan_find_desc(&chan->vchan, cookie);\n\t\tif (!vd)\n\t\t\tgoto out;\n\n\t\tdesc = to_sf_pdma_desc(vd);\n\t\tresidue = desc->xfer_size;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&chan->vchan.lock, flags);\n\treturn residue;\n}"
    },
    {
        "var_name": "ds",
        "function_name": "txx9dmac_prep_slave_sg",
        "location": {
            "file_path": "drivers/dma/txx9dmac.c",
            "region": {
                "startLine": 818,
                "startColumn": 6,
                "endColumn": 8
            },
            "context": {
                "startLine": 816,
                "endLine": 820,
                "snippet": {
                    "text": "if (ds->tx_reg)"
                }
            }
        },
        "function_code": "static struct dma_async_tx_descriptor *\ntxx9dmac_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,\n\t\tunsigned int sg_len, enum dma_transfer_direction direction,\n\t\tunsigned long flags, void *context)\n{\n\tstruct txx9dmac_chan *dc = to_txx9dmac_chan(chan);\n\tstruct txx9dmac_dev *ddev = dc->ddev;\n\tstruct txx9dmac_slave *ds = chan->private;\n\tstruct txx9dmac_desc *prev;\n\tstruct txx9dmac_desc *first;\n\tunsigned int i;\n\tstruct scatterlist *sg;\n\n\tdev_vdbg(chan2dev(chan), \"prep_dma_slave\\n\");\n\n\tBUG_ON(!ds || !ds->reg_width);\n\tif (ds->tx_reg)\n\t\tBUG_ON(direction != DMA_MEM_TO_DEV);\n\telse\n\t\tBUG_ON(direction != DMA_DEV_TO_MEM);\n\tif (unlikely(!sg_len))\n\t\treturn NULL;\n\n\tprev = first = NULL;\n\n\tfor_each_sg(sgl, sg, sg_len, i) {\n\t\tstruct txx9dmac_desc *desc;\n\t\tdma_addr_t mem;\n\t\tu32 sai, dai;\n\n\t\tdesc = txx9dmac_desc_get(dc);\n\t\tif (!desc) {\n\t\t\ttxx9dmac_desc_put(dc, first);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tmem = sg_dma_address(sg);\n\n\t\tif (__is_dmac64(ddev)) {\n\t\t\tif (direction == DMA_MEM_TO_DEV) {\n\t\t\t\tdesc->hwdesc.SAR = mem;\n\t\t\t\tdesc->hwdesc.DAR = ds->tx_reg;\n\t\t\t} else {\n\t\t\t\tdesc->hwdesc.SAR = ds->rx_reg;\n\t\t\t\tdesc->hwdesc.DAR = mem;\n\t\t\t}\n\t\t\tdesc->hwdesc.CNTR = sg_dma_len(sg);\n\t\t} else {\n\t\t\tif (direction == DMA_MEM_TO_DEV) {\n\t\t\t\tdesc->hwdesc32.SAR = mem;\n\t\t\t\tdesc->hwdesc32.DAR = ds->tx_reg;\n\t\t\t} else {\n\t\t\t\tdesc->hwdesc32.SAR = ds->rx_reg;\n\t\t\t\tdesc->hwdesc32.DAR = mem;\n\t\t\t}\n\t\t\tdesc->hwdesc32.CNTR = sg_dma_len(sg);\n\t\t}\n\t\tif (direction == DMA_MEM_TO_DEV) {\n\t\t\tsai = ds->reg_width;\n\t\t\tdai = 0;\n\t\t} else {\n\t\t\tsai = 0;\n\t\t\tdai = ds->reg_width;\n\t\t}\n\t\ttxx9dmac_desc_set_nosimple(ddev, desc, sai, dai,\n\t\t\t\t\tdc->ccr | TXX9_DMA_CCR_XFACT);\n\n\t\tif (!first) {\n\t\t\tfirst = desc;\n\t\t} else {\n\t\t\tdesc_write_CHAR(dc, prev, desc->txd.phys);\n\t\t\tdma_sync_single_for_device(chan2parent(&dc->chan),\n\t\t\t\t\tprev->txd.phys,\n\t\t\t\t\tddev->descsize,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tlist_add_tail(&desc->desc_node, &first->tx_list);\n\t\t}\n\t\tprev = desc;\n\t}\n\n\t/* Trigger interrupt after last block */\n\tif (flags & DMA_PREP_INTERRUPT)\n\t\ttxx9dmac_desc_set_INTENT(ddev, prev);\n\n\tdesc_write_CHAR(dc, prev, 0);\n\tdma_sync_single_for_device(chan2parent(&dc->chan),\n\t\t\tprev->txd.phys, ddev->descsize,\n\t\t\tDMA_TO_DEVICE);\n\n\tfirst->txd.flags = flags;\n\tfirst->len = 0;\n\n\treturn &first->txd;\n}"
    },
    {
        "var_name": "pdata",
        "function_name": "txx9dmac_probe",
        "location": {
            "file_path": "drivers/dma/txx9dmac.c",
            "region": {
                "startLine": 1190,
                "startColumn": 26,
                "endColumn": 31
            },
            "context": {
                "startLine": 1188,
                "endLine": 1192,
                "snippet": {
                    "text": "ddev->have_64bit_regs = pdata->have_64bit_regs;"
                }
            }
        },
        "function_code": "static int __init txx9dmac_probe(struct platform_device *pdev)\n{\n\tstruct txx9dmac_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct resource *io;\n\tstruct txx9dmac_dev *ddev;\n\tu32 mcr;\n\tint err;\n\n\tio = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!io)\n\t\treturn -EINVAL;\n\n\tddev = devm_kzalloc(&pdev->dev, sizeof(*ddev), GFP_KERNEL);\n\tif (!ddev)\n\t\treturn -ENOMEM;\n\n\tif (!devm_request_mem_region(&pdev->dev, io->start, resource_size(io),\n\t\t\t\t     dev_name(&pdev->dev)))\n\t\treturn -EBUSY;\n\n\tddev->regs = devm_ioremap(&pdev->dev, io->start, resource_size(io));\n\tif (!ddev->regs)\n\t\treturn -ENOMEM;\n\tddev->have_64bit_regs = pdata->have_64bit_regs;\n\tif (__is_dmac64(ddev))\n\t\tddev->descsize = sizeof(struct txx9dmac_hwdesc);\n\telse\n\t\tddev->descsize = sizeof(struct txx9dmac_hwdesc32);\n\n\t/* force dma off, just in case */\n\ttxx9dmac_off(ddev);\n\n\tddev->irq = platform_get_irq(pdev, 0);\n\tif (ddev->irq >= 0) {\n\t\ttasklet_setup(&ddev->tasklet, txx9dmac_tasklet);\n\t\terr = devm_request_irq(&pdev->dev, ddev->irq,\n\t\t\ttxx9dmac_interrupt, 0, dev_name(&pdev->dev), ddev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmcr = TXX9_DMA_MCR_MSTEN | MCR_LE;\n\tif (pdata && pdata->memcpy_chan >= 0)\n\t\tmcr |= TXX9_DMA_MCR_FIFUM(pdata->memcpy_chan);\n\tdma_writel(ddev, MCR, mcr);\n\n\tplatform_set_drvdata(pdev, ddev);\n\treturn 0;\n}"
    },
    {
        "var_name": "chan",
        "function_name": "xgene_dma_chan_ring_isr",
        "location": {
            "file_path": "drivers/dma/xgene-dma.c",
            "region": {
                "startLine": 1000,
                "startColumn": 21,
                "endColumn": 25
            },
            "context": {
                "startLine": 998,
                "endLine": 1002,
                "snippet": {
                    "text": "disable_irq_nosync(chan->rx_irq);"
                }
            }
        },
        "function_code": "static irqreturn_t xgene_dma_chan_ring_isr(int irq, void *id)\n{\n\tstruct xgene_dma_chan *chan = (struct xgene_dma_chan *)id;\n\n\tBUG_ON(!chan);\n\n\t/*\n\t * Disable DMA channel IRQ until we process completed\n\t * descriptors\n\t */\n\tdisable_irq_nosync(chan->rx_irq);\n\n\t/*\n\t * Schedule the tasklet to handle all cleanup of the current\n\t * transaction. It will start a new transaction if there is\n\t * one pending.\n\t */\n\ttasklet_schedule(&chan->tasklet);\n\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "ref",
        "function_name": "dpll_msg_add_pin_phase_adjust",
        "location": {
            "file_path": "drivers/dpll/dpll_netlink.c",
            "region": {
                "startLine": 242,
                "startColumn": 29,
                "endColumn": 32
            },
            "context": {
                "startLine": 240,
                "endLine": 244,
                "snippet": {
                    "text": "struct dpll_device *dpll = ref->dpll;"
                }
            }
        },
        "function_code": "static int\ndpll_msg_add_pin_phase_adjust(struct sk_buff *msg, struct dpll_pin *pin,\n\t\t\t      struct dpll_pin_ref *ref,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct dpll_pin_ops *ops = dpll_pin_ops(ref);\n\tstruct dpll_device *dpll = ref->dpll;\n\ts32 phase_adjust;\n\tint ret;\n\n\tif (!ops->phase_adjust_get)\n\t\treturn 0;\n\tret = ops->phase_adjust_get(pin, dpll_pin_on_dpll_priv(dpll, pin),\n\t\t\t\t    dpll, dpll_priv(dpll),\n\t\t\t\t    &phase_adjust, extack);\n\tif (ret)\n\t\treturn ret;\n\tif (nla_put_s32(msg, DPLL_A_PIN_PHASE_ADJUST, phase_adjust))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "ref",
        "function_name": "dpll_msg_add_ffo",
        "location": {
            "file_path": "drivers/dpll/dpll_netlink.c",
            "region": {
                "startLine": 288,
                "startColumn": 29,
                "endColumn": 32
            },
            "context": {
                "startLine": 286,
                "endLine": 290,
                "snippet": {
                    "text": "struct dpll_device *dpll = ref->dpll;"
                }
            }
        },
        "function_code": "static int dpll_msg_add_ffo(struct sk_buff *msg, struct dpll_pin *pin,\n\t\t\t    struct dpll_pin_ref *ref,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tconst struct dpll_pin_ops *ops = dpll_pin_ops(ref);\n\tstruct dpll_device *dpll = ref->dpll;\n\ts64 ffo;\n\tint ret;\n\n\tif (!ops->ffo_get)\n\t\treturn 0;\n\tret = ops->ffo_get(pin, dpll_pin_on_dpll_priv(dpll, pin),\n\t\t\t   dpll, dpll_priv(dpll), &ffo, extack);\n\tif (ret) {\n\t\tif (ret == -ENODATA)\n\t\t\treturn 0;\n\t\treturn ret;\n\t}\n\treturn nla_put_sint(msg, DPLL_A_PIN_FRACTIONAL_FREQUENCY_OFFSET, ffo);\n}"
    },
    {
        "var_name": "ref",
        "function_name": "dpll_msg_add_pin_freq",
        "location": {
            "file_path": "drivers/dpll/dpll_netlink.c",
            "region": {
                "startLine": 309,
                "startColumn": 29,
                "endColumn": 32
            },
            "context": {
                "startLine": 307,
                "endLine": 311,
                "snippet": {
                    "text": "struct dpll_device *dpll = ref->dpll;"
                }
            }
        },
        "function_code": "static int\ndpll_msg_add_pin_freq(struct sk_buff *msg, struct dpll_pin *pin,\n\t\t      struct dpll_pin_ref *ref, struct netlink_ext_ack *extack)\n{\n\tconst struct dpll_pin_ops *ops = dpll_pin_ops(ref);\n\tstruct dpll_device *dpll = ref->dpll;\n\tstruct nlattr *nest;\n\tint fs, ret;\n\tu64 freq;\n\n\tif (!ops->frequency_get)\n\t\treturn 0;\n\tret = ops->frequency_get(pin, dpll_pin_on_dpll_priv(dpll, pin), dpll,\n\t\t\t\t dpll_priv(dpll), &freq, extack);\n\tif (ret)\n\t\treturn ret;\n\tif (nla_put_64bit(msg, DPLL_A_PIN_FREQUENCY, sizeof(freq), &freq,\n\t\t\t  DPLL_A_PIN_PAD))\n\t\treturn -EMSGSIZE;\n\tfor (fs = 0; fs < pin->prop.freq_supported_num; fs++) {\n\t\tnest = nla_nest_start(msg, DPLL_A_PIN_FREQUENCY_SUPPORTED);\n\t\tif (!nest)\n\t\t\treturn -EMSGSIZE;\n\t\tfreq = pin->prop.freq_supported[fs].min;\n\t\tif (nla_put_64bit(msg, DPLL_A_PIN_FREQUENCY_MIN, sizeof(freq),\n\t\t\t\t  &freq, DPLL_A_PIN_PAD)) {\n\t\t\tnla_nest_cancel(msg, nest);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\tfreq = pin->prop.freq_supported[fs].max;\n\t\tif (nla_put_64bit(msg, DPLL_A_PIN_FREQUENCY_MAX, sizeof(freq),\n\t\t\t\t  &freq, DPLL_A_PIN_PAD)) {\n\t\t\tnla_nest_cancel(msg, nest);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\tnla_nest_end(msg, nest);\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "dev",
        "function_name": "pci_eisa_init_early",
        "location": {
            "file_path": "drivers/eisa/pci_eisa.c",
            "region": {
                "startLine": 81,
                "startColumn": 8,
                "endColumn": 11
            },
            "context": {
                "startLine": 79,
                "endLine": 83,
                "snippet": {
                    "text": "if ((dev->class >> 8) == PCI_CLASS_BRIDGE_EISA) {"
                }
            }
        },
        "function_code": "static int __init pci_eisa_init_early(void)\n{\n\tstruct pci_dev *dev = NULL;\n\tint ret;\n\n\tfor_each_pci_dev(dev)\n\t\tif ((dev->class >> 8) == PCI_CLASS_BRIDGE_EISA) {\n\t\t\tret = pci_eisa_init(dev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "xfer_",
        "function_name": "scmi_xfer_lookup_unlocked",
        "location": {
            "file_path": "drivers/firmware/arm_scmi/driver.c",
            "region": {
                "startLine": 694,
                "startColumn": 10,
                "endColumn": 15
            },
            "context": {
                "startLine": 692,
                "endLine": 696,
                "snippet": {
                    "text": "xfer = XFER_FIND(minfo->pending_xfers, xfer_id);"
                }
            }
        },
        "function_code": "static struct scmi_xfer *\nscmi_xfer_lookup_unlocked(struct scmi_xfers_info *minfo, u16 xfer_id)\n{\n\tstruct scmi_xfer *xfer = NULL;\n\n\tif (test_bit(xfer_id, minfo->xfer_alloc_table))\n\t\txfer = XFER_FIND(minfo->pending_xfers, xfer_id);\n\n\treturn xfer ?: ERR_PTR(-EINVAL);\n}"
    },
    {
        "var_name": "tag_data",
        "function_name": "rpi_firmware_property",
        "location": {
            "file_path": "drivers/firmware/raspberrypi.c",
            "region": {
                "startLine": 170,
                "startColumn": 33,
                "endColumn": 41
            },
            "context": {
                "startLine": 168,
                "endLine": 172,
                "snippet": {
                    "text": "memcpy(data + sizeof(*header), tag_data, buf_size);"
                }
            }
        },
        "function_code": "int rpi_firmware_property(struct rpi_firmware *fw,\n\t\t\t  u32 tag, void *tag_data, size_t buf_size)\n{\n\tstruct rpi_firmware_property_tag_header *header;\n\tint ret;\n\n\t/* Some mailboxes can use over 1k bytes. Rather than checking\n\t * size and using stack or kmalloc depending on requirements,\n\t * just use kmalloc. Mailboxes don't get called enough to worry\n\t * too much about the time taken in the allocation.\n\t */\n\tvoid *data = kmalloc(sizeof(*header) + buf_size, GFP_KERNEL);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\theader = data;\n\theader->tag = tag;\n\theader->buf_size = buf_size;\n\theader->req_resp_size = 0;\n\tmemcpy(data + sizeof(*header), tag_data, buf_size);\n\n\tret = rpi_firmware_property_list(fw, data, buf_size + sizeof(*header));\n\n\tmemcpy(tag_data, data + sizeof(*header), buf_size);\n\n\tkfree(data);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "tag_data",
        "function_name": "rpi_firmware_property",
        "location": {
            "file_path": "drivers/firmware/raspberrypi.c",
            "region": {
                "startLine": 174,
                "startColumn": 9,
                "endColumn": 17
            },
            "context": {
                "startLine": 172,
                "endLine": 176,
                "snippet": {
                    "text": "memcpy(tag_data, data + sizeof(*header), buf_size);"
                }
            }
        },
        "function_code": "int rpi_firmware_property(struct rpi_firmware *fw,\n\t\t\t  u32 tag, void *tag_data, size_t buf_size)\n{\n\tstruct rpi_firmware_property_tag_header *header;\n\tint ret;\n\n\t/* Some mailboxes can use over 1k bytes. Rather than checking\n\t * size and using stack or kmalloc depending on requirements,\n\t * just use kmalloc. Mailboxes don't get called enough to worry\n\t * too much about the time taken in the allocation.\n\t */\n\tvoid *data = kmalloc(sizeof(*header) + buf_size, GFP_KERNEL);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\theader = data;\n\theader->tag = tag;\n\theader->buf_size = buf_size;\n\theader->req_resp_size = 0;\n\tmemcpy(data + sizeof(*header), tag_data, buf_size);\n\n\tret = rpi_firmware_property_list(fw, data, buf_size + sizeof(*header));\n\n\tmemcpy(tag_data, data + sizeof(*header), buf_size);\n\n\tkfree(data);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "(uint8_t*)data",
        "function_name": "build_ar_command",
        "location": {
            "file_path": "drivers/fsi/fsi-master-ast-cf.c",
            "region": {
                "startLine": 268,
                "startColumn": 23,
                "endColumn": 37
            },
            "context": {
                "startLine": 266,
                "endLine": 270,
                "snippet": {
                    "text": "msg_push_bits(cmd, ((uint8_t *)data)[i], 8);"
                }
            }
        },
        "function_code": "static void build_ar_command(struct fsi_master_acf *master,\n\t\t\t     struct fsi_msg *cmd, uint8_t id,\n\t\t\t     uint32_t addr, size_t size,\n\t\t\t     const void *data)\n{\n\tint i, addr_bits, opcode_bits;\n\tbool write = !!data;\n\tuint8_t ds, opcode;\n\tuint32_t rel_addr;\n\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\t/* we have 21 bits of address max */\n\taddr &= ((1 << 21) - 1);\n\n\t/* cmd opcodes are variable length - SAME_AR is only two bits */\n\topcode_bits = 3;\n\n\tif (check_same_address(master, id, addr)) {\n\t\t/* we still address the byte offset within the word */\n\t\taddr_bits = 2;\n\t\topcode_bits = 2;\n\t\topcode = FSI_CMD_SAME_AR;\n\t\ttrace_fsi_master_acf_cmd_same_addr(master);\n\n\t} else if (check_relative_address(master, id, addr, &rel_addr)) {\n\t\t/* 8 bits plus sign */\n\t\taddr_bits = 9;\n\t\taddr = rel_addr;\n\t\topcode = FSI_CMD_REL_AR;\n\t\ttrace_fsi_master_acf_cmd_rel_addr(master, rel_addr);\n\n\t} else {\n\t\taddr_bits = 21;\n\t\topcode = FSI_CMD_ABS_AR;\n\t\ttrace_fsi_master_acf_cmd_abs_addr(master, addr);\n\t}\n\n\t/*\n\t * The read/write size is encoded in the lower bits of the address\n\t * (as it must be naturally-aligned), and the following ds bit.\n\t *\n\t *\tsize\taddr:1\taddr:0\tds\n\t *\t1\tx\tx\t0\n\t *\t2\tx\t0\t1\n\t *\t4\t0\t1\t1\n\t *\n\t */\n\tds = size > 1 ? 1 : 0;\n\taddr &= ~(size - 1);\n\tif (size == 4)\n\t\taddr |= 1;\n\n\tmsg_push_bits(cmd, id, 2);\n\tmsg_push_bits(cmd, opcode, opcode_bits);\n\tmsg_push_bits(cmd, write ? 0 : 1, 1);\n\tmsg_push_bits(cmd, addr, addr_bits);\n\tmsg_push_bits(cmd, ds, 1);\n\tfor (i = 0; write && i < size; i++)\n\t\tmsg_push_bits(cmd, ((uint8_t *)data)[i], 8);\n\n\tmsg_push_crc(cmd);\n\tmsg_finish_cmd(cmd);\n}"
    },
    {
        "var_name": "data",
        "function_name": "build_ar_command",
        "location": {
            "file_path": "drivers/fsi/fsi-master-ast-cf.c",
            "region": {
                "startLine": 268,
                "startColumn": 34,
                "endColumn": 38
            },
            "context": {
                "startLine": 266,
                "endLine": 270,
                "snippet": {
                    "text": "msg_push_bits(cmd, ((uint8_t *)data)[i], 8);"
                }
            }
        },
        "function_code": "static void build_ar_command(struct fsi_master_acf *master,\n\t\t\t     struct fsi_msg *cmd, uint8_t id,\n\t\t\t     uint32_t addr, size_t size,\n\t\t\t     const void *data)\n{\n\tint i, addr_bits, opcode_bits;\n\tbool write = !!data;\n\tuint8_t ds, opcode;\n\tuint32_t rel_addr;\n\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\t/* we have 21 bits of address max */\n\taddr &= ((1 << 21) - 1);\n\n\t/* cmd opcodes are variable length - SAME_AR is only two bits */\n\topcode_bits = 3;\n\n\tif (check_same_address(master, id, addr)) {\n\t\t/* we still address the byte offset within the word */\n\t\taddr_bits = 2;\n\t\topcode_bits = 2;\n\t\topcode = FSI_CMD_SAME_AR;\n\t\ttrace_fsi_master_acf_cmd_same_addr(master);\n\n\t} else if (check_relative_address(master, id, addr, &rel_addr)) {\n\t\t/* 8 bits plus sign */\n\t\taddr_bits = 9;\n\t\taddr = rel_addr;\n\t\topcode = FSI_CMD_REL_AR;\n\t\ttrace_fsi_master_acf_cmd_rel_addr(master, rel_addr);\n\n\t} else {\n\t\taddr_bits = 21;\n\t\topcode = FSI_CMD_ABS_AR;\n\t\ttrace_fsi_master_acf_cmd_abs_addr(master, addr);\n\t}\n\n\t/*\n\t * The read/write size is encoded in the lower bits of the address\n\t * (as it must be naturally-aligned), and the following ds bit.\n\t *\n\t *\tsize\taddr:1\taddr:0\tds\n\t *\t1\tx\tx\t0\n\t *\t2\tx\t0\t1\n\t *\t4\t0\t1\t1\n\t *\n\t */\n\tds = size > 1 ? 1 : 0;\n\taddr &= ~(size - 1);\n\tif (size == 4)\n\t\taddr |= 1;\n\n\tmsg_push_bits(cmd, id, 2);\n\tmsg_push_bits(cmd, opcode, opcode_bits);\n\tmsg_push_bits(cmd, write ? 0 : 1, 1);\n\tmsg_push_bits(cmd, addr, addr_bits);\n\tmsg_push_bits(cmd, ds, 1);\n\tfor (i = 0; write && i < size; i++)\n\t\tmsg_push_bits(cmd, ((uint8_t *)data)[i], 8);\n\n\tmsg_push_crc(cmd);\n\tmsg_finish_cmd(cmd);\n}"
    },
    {
        "var_name": "(uint8_t*)data",
        "function_name": "build_ar_command",
        "location": {
            "file_path": "drivers/fsi/fsi-master-gpio.c",
            "region": {
                "startLine": 293,
                "startColumn": 23,
                "endColumn": 37
            },
            "context": {
                "startLine": 291,
                "endLine": 295,
                "snippet": {
                    "text": "msg_push_bits(cmd, ((uint8_t *)data)[i], 8);"
                }
            }
        },
        "function_code": "static void build_ar_command(struct fsi_master_gpio *master,\n\t\tstruct fsi_gpio_msg *cmd, uint8_t id,\n\t\tuint32_t addr, size_t size, const void *data)\n{\n\tint i, addr_bits, opcode_bits;\n\tbool write = !!data;\n\tuint8_t ds, opcode;\n\tuint32_t rel_addr;\n\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\t/* we have 21 bits of address max */\n\taddr &= ((1 << 21) - 1);\n\n\t/* cmd opcodes are variable length - SAME_AR is only two bits */\n\topcode_bits = 3;\n\n\tif (check_same_address(master, id, addr)) {\n\t\t/* we still address the byte offset within the word */\n\t\taddr_bits = 2;\n\t\topcode_bits = 2;\n\t\topcode = FSI_CMD_SAME_AR;\n\t\ttrace_fsi_master_gpio_cmd_same_addr(master);\n\n\t} else if (check_relative_address(master, id, addr, &rel_addr)) {\n\t\t/* 8 bits plus sign */\n\t\taddr_bits = 9;\n\t\taddr = rel_addr;\n\t\topcode = FSI_CMD_REL_AR;\n\t\ttrace_fsi_master_gpio_cmd_rel_addr(master, rel_addr);\n\n\t} else {\n\t\taddr_bits = 21;\n\t\topcode = FSI_CMD_ABS_AR;\n\t\ttrace_fsi_master_gpio_cmd_abs_addr(master, addr);\n\t}\n\n\t/*\n\t * The read/write size is encoded in the lower bits of the address\n\t * (as it must be naturally-aligned), and the following ds bit.\n\t *\n\t *\tsize\taddr:1\taddr:0\tds\n\t *\t1\tx\tx\t0\n\t *\t2\tx\t0\t1\n\t *\t4\t0\t1\t1\n\t *\n\t */\n\tds = size > 1 ? 1 : 0;\n\taddr &= ~(size - 1);\n\tif (size == 4)\n\t\taddr |= 1;\n\n\tmsg_push_bits(cmd, id, 2);\n\tmsg_push_bits(cmd, opcode, opcode_bits);\n\tmsg_push_bits(cmd, write ? 0 : 1, 1);\n\tmsg_push_bits(cmd, addr, addr_bits);\n\tmsg_push_bits(cmd, ds, 1);\n\tfor (i = 0; write && i < size; i++)\n\t\tmsg_push_bits(cmd, ((uint8_t *)data)[i], 8);\n\n\tmsg_push_crc(cmd);\n}"
    },
    {
        "var_name": "data",
        "function_name": "build_ar_command",
        "location": {
            "file_path": "drivers/fsi/fsi-master-gpio.c",
            "region": {
                "startLine": 293,
                "startColumn": 34,
                "endColumn": 38
            },
            "context": {
                "startLine": 291,
                "endLine": 295,
                "snippet": {
                    "text": "msg_push_bits(cmd, ((uint8_t *)data)[i], 8);"
                }
            }
        },
        "function_code": "static void build_ar_command(struct fsi_master_gpio *master,\n\t\tstruct fsi_gpio_msg *cmd, uint8_t id,\n\t\tuint32_t addr, size_t size, const void *data)\n{\n\tint i, addr_bits, opcode_bits;\n\tbool write = !!data;\n\tuint8_t ds, opcode;\n\tuint32_t rel_addr;\n\n\tcmd->bits = 0;\n\tcmd->msg = 0;\n\n\t/* we have 21 bits of address max */\n\taddr &= ((1 << 21) - 1);\n\n\t/* cmd opcodes are variable length - SAME_AR is only two bits */\n\topcode_bits = 3;\n\n\tif (check_same_address(master, id, addr)) {\n\t\t/* we still address the byte offset within the word */\n\t\taddr_bits = 2;\n\t\topcode_bits = 2;\n\t\topcode = FSI_CMD_SAME_AR;\n\t\ttrace_fsi_master_gpio_cmd_same_addr(master);\n\n\t} else if (check_relative_address(master, id, addr, &rel_addr)) {\n\t\t/* 8 bits plus sign */\n\t\taddr_bits = 9;\n\t\taddr = rel_addr;\n\t\topcode = FSI_CMD_REL_AR;\n\t\ttrace_fsi_master_gpio_cmd_rel_addr(master, rel_addr);\n\n\t} else {\n\t\taddr_bits = 21;\n\t\topcode = FSI_CMD_ABS_AR;\n\t\ttrace_fsi_master_gpio_cmd_abs_addr(master, addr);\n\t}\n\n\t/*\n\t * The read/write size is encoded in the lower bits of the address\n\t * (as it must be naturally-aligned), and the following ds bit.\n\t *\n\t *\tsize\taddr:1\taddr:0\tds\n\t *\t1\tx\tx\t0\n\t *\t2\tx\t0\t1\n\t *\t4\t0\t1\t1\n\t *\n\t */\n\tds = size > 1 ? 1 : 0;\n\taddr &= ~(size - 1);\n\tif (size == 4)\n\t\taddr |= 1;\n\n\tmsg_push_bits(cmd, id, 2);\n\tmsg_push_bits(cmd, opcode, opcode_bits);\n\tmsg_push_bits(cmd, write ? 0 : 1, 1);\n\tmsg_push_bits(cmd, addr, addr_bits);\n\tmsg_push_bits(cmd, ds, 1);\n\tfor (i = 0; write && i < size; i++)\n\t\tmsg_push_bits(cmd, ((uint8_t *)data)[i], 8);\n\n\tmsg_push_crc(cmd);\n}"
    },
    {
        "var_name": "bo_va",
        "function_name": "amdgpu_cs_vm_handling",
        "location": {
            "file_path": "drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c",
            "region": {
                "startLine": 1115,
                "startColumn": 35,
                "endColumn": 40
            },
            "context": {
                "startLine": 1113,
                "endLine": 1117,
                "snippet": {
                    "text": "r = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);"
                }
            }
        },
        "function_code": "static int amdgpu_cs_vm_handling(struct amdgpu_cs_parser *p)\n{\n\tstruct amdgpu_fpriv *fpriv = p->filp->driver_priv;\n\tstruct amdgpu_job *job = p->gang_leader;\n\tstruct amdgpu_device *adev = p->adev;\n\tstruct amdgpu_vm *vm = &fpriv->vm;\n\tstruct amdgpu_bo_list_entry *e;\n\tstruct amdgpu_bo_va *bo_va;\n\tunsigned int i;\n\tint r;\n\n\tr = amdgpu_vm_clear_freed(adev, vm, NULL);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_vm_bo_update(adev, fpriv->prt_va, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_sync_fence(&p->sync, fpriv->prt_va->last_pt_update);\n\tif (r)\n\t\treturn r;\n\n\tif (fpriv->csa_va) {\n\t\tbo_va = fpriv->csa_va;\n\t\tBUG_ON(!bo_va);\n\t\tr = amdgpu_vm_bo_update(adev, bo_va, false);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t/* FIXME: In theory this loop shouldn't be needed any more when\n\t * amdgpu_vm_handle_moved handles all moved BOs that are reserved\n\t * with p->ticket. But removing it caused test regressions, so I'm\n\t * leaving it here for now.\n\t */\n\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\tbo_va = e->bo_va;\n\t\tif (bo_va == NULL)\n\t\t\tcontinue;\n\n\t\tr = amdgpu_vm_bo_update(adev, bo_va, false);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = amdgpu_sync_fence(&p->sync, bo_va->last_pt_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tr = amdgpu_vm_handle_moved(adev, vm, &p->exec.ticket);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_vm_update_pdes(adev, vm, false);\n\tif (r)\n\t\treturn r;\n\n\tr = amdgpu_sync_fence(&p->sync, vm->last_update);\n\tif (r)\n\t\treturn r;\n\n\tfor (i = 0; i < p->gang_size; ++i) {\n\t\tjob = p->jobs[i];\n\n\t\tif (!job->vm)\n\t\t\tcontinue;\n\n\t\tjob->vm_pd_addr = amdgpu_gmc_pd_addr(vm->root.bo);\n\t}\n\n\tif (adev->debug_vm) {\n\t\t/* Invalidate all BOs to test for userspace bugs */\n\t\tamdgpu_bo_list_for_each_entry(e, p->bo_list) {\n\t\t\tstruct amdgpu_bo *bo = e->bo;\n\n\t\t\t/* ignore duplicates */\n\t\t\tif (!bo)\n\t\t\t\tcontinue;\n\n\t\t\tamdgpu_vm_bo_invalidate(adev, bo, false);\n\t\t}\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "adev",
        "function_name": "amdgpu_ras_log_on_err_counter",
        "location": {
            "file_path": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c",
            "region": {
                "startLine": 2250,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 2248,
                "endLine": 2252,
                "snippet": {
                    "text": "if (!adev->ras_enabled || !con)"
                }
            }
        },
        "function_code": "static void amdgpu_ras_log_on_err_counter(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ras *con = amdgpu_ras_get_context(adev);\n\tstruct ras_manager *obj;\n\n\tif (!adev->ras_enabled || !con)\n\t\treturn;\n\n\tlist_for_each_entry(obj, &con->head, node) {\n\t\tstruct ras_query_if info = {\n\t\t\t.head = obj->head,\n\t\t};\n\n\t\t/*\n\t\t * PCIE_BIF IP has one different isr by ras controller\n\t\t * interrupt, the specific ras counter query will be\n\t\t * done in that isr. So skip such block from common\n\t\t * sync flood interrupt isr calling.\n\t\t */\n\t\tif (info.head.block == AMDGPU_RAS_BLOCK__PCIE_BIF)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * this is a workaround for aldebaran, skip send msg to\n\t\t * smu to get ecc_info table due to smu handle get ecc\n\t\t * info table failed temporarily.\n\t\t * should be removed until smu fix handle ecc_info table.\n\t\t */\n\t\tif ((info.head.block == AMDGPU_RAS_BLOCK__UMC) &&\n\t\t    (amdgpu_ip_version(adev, MP1_HWIP, 0) ==\n\t\t     IP_VERSION(13, 0, 2)))\n\t\t\tcontinue;\n\n\t\tamdgpu_ras_query_error_status(adev, &info);\n\n\t\tif (amdgpu_ip_version(adev, MP0_HWIP, 0) !=\n\t\t\t    IP_VERSION(11, 0, 2) &&\n\t\t    amdgpu_ip_version(adev, MP0_HWIP, 0) !=\n\t\t\t    IP_VERSION(11, 0, 4) &&\n\t\t    amdgpu_ip_version(adev, MP0_HWIP, 0) !=\n\t\t\t    IP_VERSION(13, 0, 0)) {\n\t\t\tif (amdgpu_ras_reset_error_status(adev, info.head.block))\n\t\t\t\tdev_warn(adev->dev, \"Failed to reset error counter and error status\");\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "adev",
        "function_name": "amdgpu_ras_query_err_status",
        "location": {
            "file_path": "drivers/gpu/drm/amd/amdgpu/amdgpu_ras.c",
            "region": {
                "startLine": 2325,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 2323,
                "endLine": 2327,
                "snippet": {
                    "text": "if (!adev->ras_enabled || !con)"
                }
            }
        },
        "function_code": "static void amdgpu_ras_query_err_status(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_ras *con = amdgpu_ras_get_context(adev);\n\tstruct ras_manager *obj;\n\n\tif (!adev->ras_enabled || !con)\n\t\treturn;\n\n\tlist_for_each_entry(obj, &con->head, node) {\n\t\tstruct ras_query_if info = {\n\t\t\t.head = obj->head,\n\t\t};\n\n\t\tamdgpu_ras_error_status_query(adev, &info);\n\t}\n}"
    },
    {
        "var_name": "hive",
        "function_name": "amdgpu_get_xgmi_hive",
        "location": {
            "file_path": "drivers/gpu/drm/amd/amdgpu/amdgpu_xgmi.c",
            "region": {
                "startLine": 607,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 605,
                "endLine": 609,
                "snippet": {
                    "text": "if (hive->hive_id == adev->gmc.xgmi.hive_id)"
                }
            }
        },
        "function_code": "struct amdgpu_hive_info *amdgpu_get_xgmi_hive(struct amdgpu_device *adev)\n{\n\tstruct amdgpu_hive_info *hive = NULL;\n\tint ret;\n\n\tif (!adev->gmc.xgmi.hive_id)\n\t\treturn NULL;\n\n\tif (adev->hive) {\n\t\tkobject_get(&adev->hive->kobj);\n\t\treturn adev->hive;\n\t}\n\n\tmutex_lock(&xgmi_mutex);\n\n\tlist_for_each_entry(hive, &xgmi_hive_list, node)  {\n\t\tif (hive->hive_id == adev->gmc.xgmi.hive_id)\n\t\t\tgoto pro_end;\n\t}\n\n\thive = kzalloc(sizeof(*hive), GFP_KERNEL);\n\tif (!hive) {\n\t\tdev_err(adev->dev, \"XGMI: allocation failed\\n\");\n\t\tret = -ENOMEM;\n\t\thive = NULL;\n\t\tgoto pro_end;\n\t}\n\n\t/* initialize new hive if not exist */\n\tret = kobject_init_and_add(&hive->kobj,\n\t\t\t&amdgpu_xgmi_hive_type,\n\t\t\t&adev->dev->kobj,\n\t\t\t\"%s\", \"xgmi_hive_info\");\n\tif (ret) {\n\t\tdev_err(adev->dev, \"XGMI: failed initializing kobject for xgmi hive\\n\");\n\t\tkobject_put(&hive->kobj);\n\t\thive = NULL;\n\t\tgoto pro_end;\n\t}\n\n\t/**\n\t * Only init hive->reset_domain for none SRIOV configuration. For SRIOV,\n\t * Host driver decide how to reset the GPU either through FLR or chain reset.\n\t * Guest side will get individual notifications from the host for the FLR\n\t * if necessary.\n\t */\n\tif (!amdgpu_sriov_vf(adev)) {\n\t/**\n\t * Avoid recreating reset domain when hive is reconstructed for the case\n\t * of reset the devices in the XGMI hive during probe for passthrough GPU\n\t * See https://www.spinics.net/lists/amd-gfx/msg58836.html\n\t */\n\t\tif (adev->reset_domain->type != XGMI_HIVE) {\n\t\t\thive->reset_domain =\n\t\t\t\tamdgpu_reset_create_reset_domain(XGMI_HIVE, \"amdgpu-reset-hive\");\n\t\t\tif (!hive->reset_domain) {\n\t\t\t\tdev_err(adev->dev, \"XGMI: failed initializing reset domain for xgmi hive\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tkobject_put(&hive->kobj);\n\t\t\t\thive = NULL;\n\t\t\t\tgoto pro_end;\n\t\t\t}\n\t\t} else {\n\t\t\tamdgpu_reset_get_reset_domain(adev->reset_domain);\n\t\t\thive->reset_domain = adev->reset_domain;\n\t\t}\n\t}\n\n\thive->hive_id = adev->gmc.xgmi.hive_id;\n\tINIT_LIST_HEAD(&hive->device_list);\n\tINIT_LIST_HEAD(&hive->node);\n\tmutex_init(&hive->hive_lock);\n\tatomic_set(&hive->number_devices, 0);\n\ttask_barrier_init(&hive->tb);\n\thive->pstate = AMDGPU_XGMI_PSTATE_UNKNOWN;\n\thive->hi_req_gpu = NULL;\n\n\t/*\n\t * hive pstate on boot is high in vega20 so we have to go to low\n\t * pstate on after boot.\n\t */\n\thive->hi_req_count = AMDGPU_MAX_XGMI_DEVICE_PER_HIVE;\n\tlist_add_tail(&hive->node, &xgmi_hive_list);\n\npro_end:\n\tif (hive)\n\t\tkobject_get(&hive->kobj);\n\tmutex_unlock(&xgmi_mutex);\n\treturn hive;\n}"
    },
    {
        "var_name": "top_dev",
        "function_name": "kfd_topology_device_by_id",
        "location": {
            "file_path": "drivers/gpu/drm/amd/amdkfd/kfd_topology.c",
            "region": {
                "startLine": 89,
                "startColumn": 7,
                "endColumn": 14
            },
            "context": {
                "startLine": 87,
                "endLine": 91,
                "snippet": {
                    "text": "if (top_dev->gpu_id == gpu_id) {"
                }
            }
        },
        "function_code": "struct kfd_topology_device *kfd_topology_device_by_id(uint32_t gpu_id)\n{\n\tstruct kfd_topology_device *top_dev = NULL;\n\tstruct kfd_topology_device *ret = NULL;\n\n\tdown_read(&topology_lock);\n\n\tlist_for_each_entry(top_dev, &topology_device_list, list)\n\t\tif (top_dev->gpu_id == gpu_id) {\n\t\t\tret = top_dev;\n\t\t\tbreak;\n\t\t}\n\n\tup_read(&topology_lock);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "aconnector",
        "function_name": "dm_resume",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c",
            "region": {
                "startLine": 2983,
                "startColumn": 8,
                "endColumn": 18
            },
            "context": {
                "startLine": 2981,
                "endLine": 2985,
                "snippet": {
                    "text": "if (!aconnector->dc_link)"
                }
            }
        },
        "function_code": "static int dm_resume(void *handle)\n{\n\tstruct amdgpu_device *adev = handle;\n\tstruct drm_device *ddev = adev_to_drm(adev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct amdgpu_dm_connector *aconnector;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_list_iter iter;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *new_crtc_state;\n\tstruct dm_crtc_state *dm_new_crtc_state;\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *new_plane_state;\n\tstruct dm_plane_state *dm_new_plane_state;\n\tstruct dm_atomic_state *dm_state = to_dm_atomic_state(dm->atomic_obj.state);\n\tenum dc_connection_type new_connection_type = dc_connection_none;\n\tstruct dc_state *dc_state;\n\tint i, r, j, ret;\n\tbool need_hotplug = false;\n\n\tif (dm->dc->caps.ips_support) {\n\t\tdc_dmub_srv_apply_idle_power_optimizations(dm->dc, false);\n\t}\n\n\tif (amdgpu_in_reset(adev)) {\n\t\tdc_state = dm->cached_dc_state;\n\n\t\t/*\n\t\t * The dc->current_state is backed up into dm->cached_dc_state\n\t\t * before we commit 0 streams.\n\t\t *\n\t\t * DC will clear link encoder assignments on the real state\n\t\t * but the changes won't propagate over to the copy we made\n\t\t * before the 0 streams commit.\n\t\t *\n\t\t * DC expects that link encoder assignments are *not* valid\n\t\t * when committing a state, so as a workaround we can copy\n\t\t * off of the current state.\n\t\t *\n\t\t * We lose the previous assignments, but we had already\n\t\t * commit 0 streams anyway.\n\t\t */\n\t\tlink_enc_cfg_copy(adev->dm.dc->current_state, dc_state);\n\n\t\tr = dm_dmub_hw_init(adev);\n\t\tif (r)\n\t\t\tDRM_ERROR(\"DMUB interface failed to initialize: status=%d\\n\", r);\n\n\t\tdc_dmub_srv_set_power_state(dm->dc->ctx->dmub_srv, DC_ACPI_CM_POWER_STATE_D0);\n\t\tdc_set_power_state(dm->dc, DC_ACPI_CM_POWER_STATE_D0);\n\n\t\tdc_resume(dm->dc);\n\n\t\tamdgpu_dm_irq_resume_early(adev);\n\n\t\tfor (i = 0; i < dc_state->stream_count; i++) {\n\t\t\tdc_state->streams[i]->mode_changed = true;\n\t\t\tfor (j = 0; j < dc_state->stream_status[i].plane_count; j++) {\n\t\t\t\tdc_state->stream_status[i].plane_states[j]->update_flags.raw\n\t\t\t\t\t= 0xffffffff;\n\t\t\t}\n\t\t}\n\n\t\tif (dc_is_dmub_outbox_supported(adev->dm.dc)) {\n\t\t\tamdgpu_dm_outbox_init(adev);\n\t\t\tdc_enable_dmub_outbox(adev->dm.dc);\n\t\t}\n\n\t\tWARN_ON(!dc_commit_streams(dm->dc, dc_state->streams, dc_state->stream_count));\n\n\t\tdm_gpureset_commit_state(dm->cached_dc_state, dm);\n\n\t\tdm_gpureset_toggle_interrupts(adev, dm->cached_dc_state, true);\n\n\t\tdc_state_release(dm->cached_dc_state);\n\t\tdm->cached_dc_state = NULL;\n\n\t\tamdgpu_dm_irq_resume_late(adev);\n\n\t\tmutex_unlock(&dm->dc_lock);\n\n\t\treturn 0;\n\t}\n\t/* Recreate dc_state - DC invalidates it when setting power state to S3. */\n\tdc_state_release(dm_state->context);\n\tdm_state->context = dc_state_create(dm->dc);\n\t/* TODO: Remove dc_state->dccg, use dc->dccg directly. */\n\n\t/* Before powering on DC we need to re-initialize DMUB. */\n\tdm_dmub_hw_resume(adev);\n\n\t/* Re-enable outbox interrupts for DPIA. */\n\tif (dc_is_dmub_outbox_supported(adev->dm.dc)) {\n\t\tamdgpu_dm_outbox_init(adev);\n\t\tdc_enable_dmub_outbox(adev->dm.dc);\n\t}\n\n\t/* power on hardware */\n\tdc_dmub_srv_set_power_state(dm->dc->ctx->dmub_srv, DC_ACPI_CM_POWER_STATE_D0);\n\tdc_set_power_state(dm->dc, DC_ACPI_CM_POWER_STATE_D0);\n\n\t/* program HPD filter */\n\tdc_resume(dm->dc);\n\n\t/*\n\t * early enable HPD Rx IRQ, should be done before set mode as short\n\t * pulse interrupts are used for MST\n\t */\n\tamdgpu_dm_irq_resume_early(adev);\n\n\t/* On resume we need to rewrite the MSTM control bits to enable MST*/\n\ts3_handle_mst(ddev, false);\n\n\t/* Do detection*/\n\tdrm_connector_list_iter_begin(ddev, &iter);\n\tdrm_for_each_connector_iter(connector, &iter) {\n\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK)\n\t\t\tcontinue;\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\n\t\tif (!aconnector->dc_link)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * this is the case when traversing through already created end sink\n\t\t * MST connectors, should be skipped\n\t\t */\n\t\tif (aconnector && aconnector->mst_root)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&aconnector->hpd_lock);\n\t\tif (!dc_link_detect_connection_type(aconnector->dc_link, &new_connection_type))\n\t\t\tDRM_ERROR(\"KMS: Failed to detect connector\\n\");\n\n\t\tif (aconnector->base.force && new_connection_type == dc_connection_none) {\n\t\t\temulated_link_detect(aconnector->dc_link);\n\t\t} else {\n\t\t\tmutex_lock(&dm->dc_lock);\n\t\t\tdc_link_detect(aconnector->dc_link, DETECT_REASON_HPD);\n\t\t\tmutex_unlock(&dm->dc_lock);\n\t\t}\n\n\t\tif (aconnector->fake_enable && aconnector->dc_link->local_sink)\n\t\t\taconnector->fake_enable = false;\n\n\t\tif (aconnector->dc_sink)\n\t\t\tdc_sink_release(aconnector->dc_sink);\n\t\taconnector->dc_sink = NULL;\n\t\tamdgpu_dm_update_connector_after_detect(aconnector);\n\t\tmutex_unlock(&aconnector->hpd_lock);\n\t}\n\tdrm_connector_list_iter_end(&iter);\n\n\t/* Force mode set in atomic commit */\n\tfor_each_new_crtc_in_state(dm->cached_state, crtc, new_crtc_state, i)\n\t\tnew_crtc_state->active_changed = true;\n\n\t/*\n\t * atomic_check is expected to create the dc states. We need to release\n\t * them here, since they were duplicated as part of the suspend\n\t * procedure.\n\t */\n\tfor_each_new_crtc_in_state(dm->cached_state, crtc, new_crtc_state, i) {\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tif (dm_new_crtc_state->stream) {\n\t\t\tWARN_ON(kref_read(&dm_new_crtc_state->stream->refcount) > 1);\n\t\t\tdc_stream_release(dm_new_crtc_state->stream);\n\t\t\tdm_new_crtc_state->stream = NULL;\n\t\t}\n\t\tdm_new_crtc_state->base.color_mgmt_changed = true;\n\t}\n\n\tfor_each_new_plane_in_state(dm->cached_state, plane, new_plane_state, i) {\n\t\tdm_new_plane_state = to_dm_plane_state(new_plane_state);\n\t\tif (dm_new_plane_state->dc_state) {\n\t\t\tWARN_ON(kref_read(&dm_new_plane_state->dc_state->refcount) > 1);\n\t\t\tdc_plane_state_release(dm_new_plane_state->dc_state);\n\t\t\tdm_new_plane_state->dc_state = NULL;\n\t\t}\n\t}\n\n\tdrm_atomic_helper_resume(ddev, dm->cached_state);\n\n\tdm->cached_state = NULL;\n\n\t/* Do mst topology probing after resuming cached state*/\n\tdrm_connector_list_iter_begin(ddev, &iter);\n\tdrm_for_each_connector_iter(connector, &iter) {\n\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK)\n\t\t\tcontinue;\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\t\tif (aconnector->dc_link->type != dc_connection_mst_branch ||\n\t\t    aconnector->mst_root)\n\t\t\tcontinue;\n\n\t\tret = drm_dp_mst_topology_mgr_resume(&aconnector->mst_mgr, true);\n\n\t\tif (ret < 0) {\n\t\t\tdm_helpers_dp_mst_stop_top_mgr(aconnector->dc_link->ctx,\n\t\t\t\t\taconnector->dc_link);\n\t\t\tneed_hotplug = true;\n\t\t}\n\t}\n\tdrm_connector_list_iter_end(&iter);\n\n\tif (need_hotplug)\n\t\tdrm_kms_helper_hotplug_event(ddev);\n\n\tamdgpu_dm_irq_resume_late(adev);\n\n\tamdgpu_dm_smu_write_watermarks_table(adev);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "aconnector",
        "function_name": "create_validate_stream_for_sink",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c",
            "region": {
                "startLine": 6877,
                "startColumn": 7,
                "endColumn": 17
            },
            "context": {
                "startLine": 6875,
                "endLine": 6879,
                "snippet": {
                    "text": "if (aconnector->base.connector_type == DRM_MODE_CONNECTOR_WRITEBACK)"
                }
            }
        },
        "function_code": "struct dc_stream_state *\ncreate_validate_stream_for_sink(struct amdgpu_dm_connector *aconnector,\n\t\t\t\tconst struct drm_display_mode *drm_mode,\n\t\t\t\tconst struct dm_connector_state *dm_state,\n\t\t\t\tconst struct dc_stream_state *old_stream)\n{\n\tstruct drm_connector *connector = &aconnector->base;\n\tstruct amdgpu_device *adev = drm_to_adev(connector->dev);\n\tstruct dc_stream_state *stream;\n\tconst struct drm_connector_state *drm_state = dm_state ? &dm_state->base : NULL;\n\tint requested_bpc = drm_state ? drm_state->max_requested_bpc : 8;\n\tenum dc_status dc_result = DC_OK;\n\n\tdo {\n\t\tstream = create_stream_for_sink(connector, drm_mode,\n\t\t\t\t\t\tdm_state, old_stream,\n\t\t\t\t\t\trequested_bpc);\n\t\tif (stream == NULL) {\n\t\t\tDRM_ERROR(\"Failed to create stream for sink!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (aconnector->base.connector_type == DRM_MODE_CONNECTOR_WRITEBACK)\n\t\t\treturn stream;\n\n\t\tdc_result = dc_validate_stream(adev->dm.dc, stream);\n\t\tif (dc_result == DC_OK && stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST)\n\t\t\tdc_result = dm_dp_mst_is_port_support_mode(aconnector, stream);\n\n\t\tif (dc_result == DC_OK)\n\t\t\tdc_result = dm_validate_stream_and_context(adev->dm.dc, stream);\n\n\t\tif (dc_result != DC_OK) {\n\t\t\tDRM_DEBUG_KMS(\"Mode %dx%d (clk %d) failed DC validation with error %d (%s)\\n\",\n\t\t\t\t      drm_mode->hdisplay,\n\t\t\t\t      drm_mode->vdisplay,\n\t\t\t\t      drm_mode->clock,\n\t\t\t\t      dc_result,\n\t\t\t\t      dc_status_to_str(dc_result));\n\n\t\t\tdc_stream_release(stream);\n\t\t\tstream = NULL;\n\t\t\trequested_bpc -= 2; /* lower bpc to retry validation */\n\t\t}\n\n\t} while (stream == NULL && requested_bpc >= 6);\n\n\tif (dc_result == DC_FAIL_ENC_VALIDATE && !aconnector->force_yuv420_output) {\n\t\tDRM_DEBUG_KMS(\"Retry forcing YCbCr420 encoding\\n\");\n\n\t\taconnector->force_yuv420_output = true;\n\t\tstream = create_validate_stream_for_sink(aconnector, drm_mode,\n\t\t\t\t\t\tdm_state, old_stream);\n\t\taconnector->force_yuv420_output = false;\n\t}\n\n\treturn stream;\n}"
    },
    {
        "var_name": "curmode",
        "function_name": "amdgpu_dm_connector_add_common_modes",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c",
            "region": {
                "startLine": 7392,
                "startColumn": 29,
                "endColumn": 36
            },
            "context": {
                "startLine": 7390,
                "endLine": 7394,
                "snippet": {
                    "text": "if (common_modes[i].w == curmode->hdisplay &&"
                }
            }
        },
        "function_code": "static void amdgpu_dm_connector_add_common_modes(struct drm_encoder *encoder,\n\t\t\t\t\t\t struct drm_connector *connector)\n{\n\tstruct amdgpu_encoder *amdgpu_encoder = to_amdgpu_encoder(encoder);\n\tstruct drm_display_mode *mode = NULL;\n\tstruct drm_display_mode *native_mode = &amdgpu_encoder->native_mode;\n\tstruct amdgpu_dm_connector *amdgpu_dm_connector =\n\t\t\t\tto_amdgpu_dm_connector(connector);\n\tint i;\n\tint n;\n\tstruct mode_size {\n\t\tchar name[DRM_DISPLAY_MODE_LEN];\n\t\tint w;\n\t\tint h;\n\t} common_modes[] = {\n\t\t{  \"640x480\",  640,  480},\n\t\t{  \"800x600\",  800,  600},\n\t\t{ \"1024x768\", 1024,  768},\n\t\t{ \"1280x720\", 1280,  720},\n\t\t{ \"1280x800\", 1280,  800},\n\t\t{\"1280x1024\", 1280, 1024},\n\t\t{ \"1440x900\", 1440,  900},\n\t\t{\"1680x1050\", 1680, 1050},\n\t\t{\"1600x1200\", 1600, 1200},\n\t\t{\"1920x1080\", 1920, 1080},\n\t\t{\"1920x1200\", 1920, 1200}\n\t};\n\n\tn = ARRAY_SIZE(common_modes);\n\n\tfor (i = 0; i < n; i++) {\n\t\tstruct drm_display_mode *curmode = NULL;\n\t\tbool mode_existed = false;\n\n\t\tif (common_modes[i].w > native_mode->hdisplay ||\n\t\t    common_modes[i].h > native_mode->vdisplay ||\n\t\t   (common_modes[i].w == native_mode->hdisplay &&\n\t\t    common_modes[i].h == native_mode->vdisplay))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(curmode, &connector->probed_modes, head) {\n\t\t\tif (common_modes[i].w == curmode->hdisplay &&\n\t\t\t    common_modes[i].h == curmode->vdisplay) {\n\t\t\t\tmode_existed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (mode_existed)\n\t\t\tcontinue;\n\n\t\tmode = amdgpu_dm_create_common_mode(encoder,\n\t\t\t\tcommon_modes[i].name, common_modes[i].w,\n\t\t\t\tcommon_modes[i].h);\n\t\tif (!mode)\n\t\t\tcontinue;\n\n\t\tdrm_mode_probed_add(connector, mode);\n\t\tamdgpu_dm_connector->num_modes++;\n\t}\n}"
    },
    {
        "var_name": "acrtc",
        "function_name": "amdgpu_dm_commit_streams",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c",
            "region": {
                "startLine": 8880,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 8878,
                "endLine": 8882,
                "snippet": {
                    "text": "if (!acrtc->wb_enabled)"
                }
            }
        },
        "function_code": "static void amdgpu_dm_commit_streams(struct drm_atomic_state *state,\n\t\t\t\t\tstruct dc_state *dc_state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tstruct dm_crtc_state *dm_old_crtc_state, *dm_new_crtc_state;\n\tstruct drm_connector_state *old_con_state;\n\tstruct drm_connector *connector;\n\tbool mode_set_reset_required = false;\n\tu32 i;\n\n\t/* Disable writeback */\n\tfor_each_old_connector_in_state(state, connector, old_con_state, i) {\n\t\tstruct dm_connector_state *dm_old_con_state;\n\t\tstruct amdgpu_crtc *acrtc;\n\n\t\tif (connector->connector_type != DRM_MODE_CONNECTOR_WRITEBACK)\n\t\t\tcontinue;\n\n\t\told_crtc_state = NULL;\n\n\t\tdm_old_con_state = to_dm_connector_state(old_con_state);\n\t\tif (!dm_old_con_state->base.crtc)\n\t\t\tcontinue;\n\n\t\tacrtc = to_amdgpu_crtc(dm_old_con_state->base.crtc);\n\t\tif (acrtc)\n\t\t\told_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);\n\n\t\tif (!acrtc->wb_enabled)\n\t\t\tcontinue;\n\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tdm_clear_writeback(dm, dm_old_crtc_state);\n\t\tacrtc->wb_enabled = false;\n\t}\n\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state,\n\t\t\t\t      new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tif (old_crtc_state->active &&\n\t\t    (!new_crtc_state->active ||\n\t\t     drm_atomic_crtc_needs_modeset(new_crtc_state))) {\n\t\t\tmanage_dm_interrupts(adev, acrtc, false);\n\t\t\tdc_stream_release(dm_old_crtc_state->stream);\n\t\t}\n\t}\n\n\tdrm_atomic_helper_calc_timestamping_constants(state);\n\n\t/* update changed items */\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tdrm_dbg_state(state->dev,\n\t\t\t\"amdgpu_crtc id:%d crtc_state_flags: enable:%d, active:%d, planes_changed:%d, mode_changed:%d,active_changed:%d,connectors_changed:%d\\n\",\n\t\t\tacrtc->crtc_id,\n\t\t\tnew_crtc_state->enable,\n\t\t\tnew_crtc_state->active,\n\t\t\tnew_crtc_state->planes_changed,\n\t\t\tnew_crtc_state->mode_changed,\n\t\t\tnew_crtc_state->active_changed,\n\t\t\tnew_crtc_state->connectors_changed);\n\n\t\t/* Disable cursor if disabling crtc */\n\t\tif (old_crtc_state->active && !new_crtc_state->active) {\n\t\t\tstruct dc_cursor_position position;\n\n\t\t\tmemset(&position, 0, sizeof(position));\n\t\t\tmutex_lock(&dm->dc_lock);\n\t\t\tdc_stream_set_cursor_position(dm_old_crtc_state->stream, &position);\n\t\t\tmutex_unlock(&dm->dc_lock);\n\t\t}\n\n\t\t/* Copy all transient state flags into dc state */\n\t\tif (dm_new_crtc_state->stream) {\n\t\t\tamdgpu_dm_crtc_copy_transient_flags(&dm_new_crtc_state->base,\n\t\t\t\t\t\t\t    dm_new_crtc_state->stream);\n\t\t}\n\n\t\t/* handles headless hotplug case, updating new_state and\n\t\t * aconnector as needed\n\t\t */\n\n\t\tif (amdgpu_dm_crtc_modeset_required(new_crtc_state, dm_new_crtc_state->stream, dm_old_crtc_state->stream)) {\n\n\t\t\tDRM_DEBUG_ATOMIC(\"Atomic commit: SET crtc id %d: [%p]\\n\", acrtc->crtc_id, acrtc);\n\n\t\t\tif (!dm_new_crtc_state->stream) {\n\t\t\t\t/*\n\t\t\t\t * this could happen because of issues with\n\t\t\t\t * userspace notifications delivery.\n\t\t\t\t * In this case userspace tries to set mode on\n\t\t\t\t * display which is disconnected in fact.\n\t\t\t\t * dc_sink is NULL in this case on aconnector.\n\t\t\t\t * We expect reset mode will come soon.\n\t\t\t\t *\n\t\t\t\t * This can also happen when unplug is done\n\t\t\t\t * during resume sequence ended\n\t\t\t\t *\n\t\t\t\t * In this case, we want to pretend we still\n\t\t\t\t * have a sink to keep the pipe running so that\n\t\t\t\t * hw state is consistent with the sw state\n\t\t\t\t */\n\t\t\t\tDRM_DEBUG_DRIVER(\"%s: Failed to create new stream for crtc %d\\n\",\n\t\t\t\t\t\t__func__, acrtc->base.base.id);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (dm_old_crtc_state->stream)\n\t\t\t\tremove_stream(adev, acrtc, dm_old_crtc_state->stream);\n\n\t\t\tpm_runtime_get_noresume(dev->dev);\n\n\t\t\tacrtc->enabled = true;\n\t\t\tacrtc->hw_mode = new_crtc_state->mode;\n\t\t\tcrtc->hwmode = new_crtc_state->mode;\n\t\t\tmode_set_reset_required = true;\n\t\t} else if (modereset_required(new_crtc_state)) {\n\t\t\tDRM_DEBUG_ATOMIC(\"Atomic commit: RESET. crtc id %d:[%p]\\n\", acrtc->crtc_id, acrtc);\n\t\t\t/* i.e. reset mode */\n\t\t\tif (dm_old_crtc_state->stream)\n\t\t\t\tremove_stream(adev, acrtc, dm_old_crtc_state->stream);\n\n\t\t\tmode_set_reset_required = true;\n\t\t}\n\t} /* for_each_crtc_in_state() */\n\n\t/* if there mode set or reset, disable eDP PSR, Replay */\n\tif (mode_set_reset_required) {\n\t\tif (dm->vblank_control_workqueue)\n\t\t\tflush_workqueue(dm->vblank_control_workqueue);\n\n\t\tamdgpu_dm_replay_disable_all(dm);\n\t\tamdgpu_dm_psr_disable_all(dm);\n\t}\n\n\tdm_enable_per_frame_crtc_master_sync(dc_state);\n\tmutex_lock(&dm->dc_lock);\n\tWARN_ON(!dc_commit_streams(dm->dc, dc_state->streams, dc_state->stream_count));\n\n\t/* Allow idle optimization when vblank count is 0 for display off */\n\tif (dm->active_vblank_irq_count == 0)\n\t\tdc_allow_idle_optimizations(dm->dc, true);\n\tmutex_unlock(&dm->dc_lock);\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (dm_new_crtc_state->stream != NULL) {\n\t\t\tconst struct dc_stream_status *status =\n\t\t\t\t\tdc_stream_get_status(dm_new_crtc_state->stream);\n\n\t\t\tif (!status)\n\t\t\t\tstatus = dc_state_get_stream_status(dc_state,\n\t\t\t\t\t\t\t\t\t dm_new_crtc_state->stream);\n\t\t\tif (!status)\n\t\t\t\tdrm_err(dev,\n\t\t\t\t\t\"got no status for stream %p on acrtc%p\\n\",\n\t\t\t\t\tdm_new_crtc_state->stream, acrtc);\n\t\t\telse\n\t\t\t\tacrtc->otg_inst = status->primary_otg_inst;\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "pipe",
        "function_name": "dm_set_writeback",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c",
            "region": {
                "startLine": 9116,
                "startColumn": 36,
                "endColumn": 40
            },
            "context": {
                "startLine": 9114,
                "endLine": 9118,
                "snippet": {
                    "text": "wb_info->writeback_source_plane = pipe->plane_state;"
                }
            }
        },
        "function_code": "static void dm_set_writeback(struct amdgpu_display_manager *dm,\n\t\t\t      struct dm_crtc_state *crtc_state,\n\t\t\t      struct drm_connector *connector,\n\t\t\t      struct drm_connector_state *new_con_state)\n{\n\tstruct drm_writeback_connector *wb_conn = drm_connector_to_writeback(connector);\n\tstruct amdgpu_device *adev = dm->adev;\n\tstruct amdgpu_crtc *acrtc;\n\tstruct dc_writeback_info *wb_info;\n\tstruct pipe_ctx *pipe = NULL;\n\tstruct amdgpu_framebuffer *afb;\n\tint i = 0;\n\n\twb_info = kzalloc(sizeof(*wb_info), GFP_KERNEL);\n\tif (!wb_info) {\n\t\tDRM_ERROR(\"Failed to allocate wb_info\\n\");\n\t\treturn;\n\t}\n\n\tacrtc = to_amdgpu_crtc(wb_conn->encoder.crtc);\n\tif (!acrtc) {\n\t\tDRM_ERROR(\"no amdgpu_crtc found\\n\");\n\t\tkfree(wb_info);\n\t\treturn;\n\t}\n\n\tafb = to_amdgpu_framebuffer(new_con_state->writeback_job->fb);\n\tif (!afb) {\n\t\tDRM_ERROR(\"No amdgpu_framebuffer found\\n\");\n\t\tkfree(wb_info);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < MAX_PIPES; i++) {\n\t\tif (dm->dc->current_state->res_ctx.pipe_ctx[i].stream == crtc_state->stream) {\n\t\t\tpipe = &dm->dc->current_state->res_ctx.pipe_ctx[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* fill in wb_info */\n\twb_info->wb_enabled = true;\n\n\twb_info->dwb_pipe_inst = 0;\n\twb_info->dwb_params.dwbscl_black_color = 0;\n\twb_info->dwb_params.hdr_mult = 0x1F000;\n\twb_info->dwb_params.csc_params.gamut_adjust_type = CM_GAMUT_ADJUST_TYPE_BYPASS;\n\twb_info->dwb_params.csc_params.gamut_coef_format = CM_GAMUT_REMAP_COEF_FORMAT_S2_13;\n\twb_info->dwb_params.output_depth = DWB_OUTPUT_PIXEL_DEPTH_10BPC;\n\twb_info->dwb_params.cnv_params.cnv_out_bpc = DWB_CNV_OUT_BPC_10BPC;\n\n\t/* width & height from crtc */\n\twb_info->dwb_params.cnv_params.src_width = acrtc->base.mode.crtc_hdisplay;\n\twb_info->dwb_params.cnv_params.src_height = acrtc->base.mode.crtc_vdisplay;\n\twb_info->dwb_params.dest_width = acrtc->base.mode.crtc_hdisplay;\n\twb_info->dwb_params.dest_height = acrtc->base.mode.crtc_vdisplay;\n\n\twb_info->dwb_params.cnv_params.crop_en = false;\n\twb_info->dwb_params.stereo_params.stereo_enabled = false;\n\n\twb_info->dwb_params.cnv_params.out_max_pix_val = 0x3ff;\t// 10 bits\n\twb_info->dwb_params.cnv_params.out_min_pix_val = 0;\n\twb_info->dwb_params.cnv_params.fc_out_format = DWB_OUT_FORMAT_32BPP_ARGB;\n\twb_info->dwb_params.cnv_params.out_denorm_mode = DWB_OUT_DENORM_BYPASS;\n\n\twb_info->dwb_params.out_format = dwb_scaler_mode_bypass444;\n\n\twb_info->dwb_params.capture_rate = dwb_capture_rate_0;\n\n\twb_info->dwb_params.scaler_taps.h_taps = 4;\n\twb_info->dwb_params.scaler_taps.v_taps = 4;\n\twb_info->dwb_params.scaler_taps.h_taps_c = 2;\n\twb_info->dwb_params.scaler_taps.v_taps_c = 2;\n\twb_info->dwb_params.subsample_position = DWB_INTERSTITIAL_SUBSAMPLING;\n\n\twb_info->mcif_buf_params.luma_pitch = afb->base.pitches[0];\n\twb_info->mcif_buf_params.chroma_pitch = afb->base.pitches[1];\n\n\tfor (i = 0; i < DWB_MCIF_BUF_COUNT; i++) {\n\t\twb_info->mcif_buf_params.luma_address[i] = afb->address;\n\t\twb_info->mcif_buf_params.chroma_address[i] = 0;\n\t}\n\n\twb_info->mcif_buf_params.p_vmid = 1;\n\tif (amdgpu_ip_version(adev, DCE_HWIP, 0) >= IP_VERSION(3, 0, 0)) {\n\t\twb_info->mcif_warmup_params.start_address.quad_part = afb->address;\n\t\twb_info->mcif_warmup_params.region_size =\n\t\t\twb_info->mcif_buf_params.luma_pitch * wb_info->dwb_params.dest_height;\n\t}\n\twb_info->mcif_warmup_params.p_vmid = 1;\n\twb_info->writeback_source_plane = pipe->plane_state;\n\n\tdc_stream_add_writeback(dm->dc, crtc_state->stream, wb_info);\n\n\tacrtc->wb_pending = true;\n\tacrtc->wb_conn = wb_conn;\n\tdrm_writeback_queue_job(wb_conn, new_con_state);\n}"
    },
    {
        "var_name": "connector",
        "function_name": "amdgpu_dm_atomic_commit_tail",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c",
            "region": {
                "startLine": 9169,
                "startColumn": 7,
                "endColumn": 16
            },
            "context": {
                "startLine": 9167,
                "endLine": 9171,
                "snippet": {
                    "text": "if (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK)"
                }
            }
        },
        "function_code": "static void amdgpu_dm_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct dm_atomic_state *dm_state;\n\tstruct dc_state *dc_state = NULL;\n\tu32 i, j;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tunsigned long flags;\n\tbool wait_for_vblank = true;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_con_state, *new_con_state;\n\tstruct dm_crtc_state *dm_old_crtc_state, *dm_new_crtc_state;\n\tint crtc_disable_count = 0;\n\n\ttrace_amdgpu_dm_atomic_commit_tail_begin(state);\n\n\tif (dm->dc->caps.ips_support && dm->dc->idle_optimizations_allowed)\n\t\tdc_allow_idle_optimizations(dm->dc, false);\n\n\tdrm_atomic_helper_update_legacy_modeset_state(dev, state);\n\tdrm_dp_mst_atomic_wait_for_dependencies(state);\n\n\tdm_state = dm_atomic_get_new_state(state);\n\tif (dm_state && dm_state->context) {\n\t\tdc_state = dm_state->context;\n\t\tamdgpu_dm_commit_streams(state, dc_state);\n\t}\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\t\tstruct amdgpu_dm_connector *aconnector;\n\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK)\n\t\t\tcontinue;\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\n\t\tif (!adev->dm.hdcp_workqueue)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"[HDCP_DM] -------------- i : %x ----------\\n\", i);\n\n\t\tif (!connector)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"[HDCP_DM] connector->index: %x connect_status: %x dpms: %x\\n\",\n\t\t\tconnector->index, connector->status, connector->dpms);\n\t\tpr_debug(\"[HDCP_DM] state protection old: %x new: %x\\n\",\n\t\t\told_con_state->content_protection, new_con_state->content_protection);\n\n\t\tif (aconnector->dc_sink) {\n\t\t\tif (aconnector->dc_sink->sink_signal != SIGNAL_TYPE_VIRTUAL &&\n\t\t\t\taconnector->dc_sink->sink_signal != SIGNAL_TYPE_NONE) {\n\t\t\t\tpr_debug(\"[HDCP_DM] pipe_ctx dispname=%s\\n\",\n\t\t\t\taconnector->dc_sink->edid_caps.display_name);\n\t\t\t}\n\t\t}\n\n\t\tnew_crtc_state = NULL;\n\t\told_crtc_state = NULL;\n\n\t\tif (acrtc) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\t\t\told_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);\n\t\t}\n\n\t\tif (old_crtc_state)\n\t\t\tpr_debug(\"old crtc en: %x a: %x m: %x a-chg: %x c-chg: %x\\n\",\n\t\t\told_crtc_state->enable,\n\t\t\told_crtc_state->active,\n\t\t\told_crtc_state->mode_changed,\n\t\t\told_crtc_state->active_changed,\n\t\t\told_crtc_state->connectors_changed);\n\n\t\tif (new_crtc_state)\n\t\t\tpr_debug(\"NEW crtc en: %x a: %x m: %x a-chg: %x c-chg: %x\\n\",\n\t\t\tnew_crtc_state->enable,\n\t\t\tnew_crtc_state->active,\n\t\t\tnew_crtc_state->mode_changed,\n\t\t\tnew_crtc_state->active_changed,\n\t\t\tnew_crtc_state->connectors_changed);\n\t}\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\t\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\n\t\tif (!adev->dm.hdcp_workqueue)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = NULL;\n\t\told_crtc_state = NULL;\n\n\t\tif (acrtc) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\t\t\told_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);\n\t\t}\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (dm_new_crtc_state && dm_new_crtc_state->stream == NULL &&\n\t\t    connector->state->content_protection == DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\t\thdcp_reset_display(adev->dm.hdcp_workqueue, aconnector->dc_link->link_index);\n\t\t\tnew_con_state->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\t\tdm_new_con_state->update_hdcp = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_content_protection_different(new_crtc_state, old_crtc_state, new_con_state,\n\t\t\t\t\t\t\t\t\t\t\told_con_state, connector, adev->dm.hdcp_workqueue)) {\n\t\t\t/* when display is unplugged from mst hub, connctor will\n\t\t\t * be destroyed within dm_dp_mst_connector_destroy. connector\n\t\t\t * hdcp perperties, like type, undesired, desired, enabled,\n\t\t\t * will be lost. So, save hdcp properties into hdcp_work within\n\t\t\t * amdgpu_dm_atomic_commit_tail. if the same display is\n\t\t\t * plugged back with same display index, its hdcp properties\n\t\t\t * will be retrieved from hdcp_work within dm_dp_mst_get_modes\n\t\t\t */\n\n\t\t\tbool enable_encryption = false;\n\n\t\t\tif (new_con_state->content_protection == DRM_MODE_CONTENT_PROTECTION_DESIRED)\n\t\t\t\tenable_encryption = true;\n\n\t\t\tif (aconnector->dc_link && aconnector->dc_sink &&\n\t\t\t\taconnector->dc_link->type == dc_connection_mst_branch) {\n\t\t\t\tstruct hdcp_workqueue *hdcp_work = adev->dm.hdcp_workqueue;\n\t\t\t\tstruct hdcp_workqueue *hdcp_w =\n\t\t\t\t\t&hdcp_work[aconnector->dc_link->link_index];\n\n\t\t\t\thdcp_w->hdcp_content_type[connector->index] =\n\t\t\t\t\tnew_con_state->hdcp_content_type;\n\t\t\t\thdcp_w->content_protection[connector->index] =\n\t\t\t\t\tnew_con_state->content_protection;\n\t\t\t}\n\n\t\t\tif (new_crtc_state && new_crtc_state->mode_changed &&\n\t\t\t\tnew_con_state->content_protection >= DRM_MODE_CONTENT_PROTECTION_DESIRED)\n\t\t\t\tenable_encryption = true;\n\n\t\t\tDRM_INFO(\"[HDCP_DM] hdcp_update_display enable_encryption = %x\\n\", enable_encryption);\n\n\t\t\thdcp_update_display(\n\t\t\t\tadev->dm.hdcp_workqueue, aconnector->dc_link->link_index, aconnector,\n\t\t\t\tnew_con_state->hdcp_content_type, enable_encryption);\n\t\t}\n\t}\n\n\t/* Handle connector state changes */\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct dm_connector_state *dm_old_con_state = to_dm_connector_state(old_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\t\tstruct dc_surface_update *dummy_updates;\n\t\tstruct dc_stream_update stream_update;\n\t\tstruct dc_info_packet hdr_packet;\n\t\tstruct dc_stream_status *status = NULL;\n\t\tbool abm_changed, hdr_changed, scaling_changed;\n\n\t\tmemset(&stream_update, 0, sizeof(stream_update));\n\n\t\tif (acrtc) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\t\t\told_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);\n\t\t}\n\n\t\t/* Skip any modesets/resets */\n\t\tif (!acrtc || drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tscaling_changed = is_scaling_state_different(dm_new_con_state,\n\t\t\t\t\t\t\t     dm_old_con_state);\n\n\t\tabm_changed = dm_new_crtc_state->abm_level !=\n\t\t\t      dm_old_crtc_state->abm_level;\n\n\t\thdr_changed =\n\t\t\t!drm_connector_atomic_hdr_metadata_equal(old_con_state, new_con_state);\n\n\t\tif (!scaling_changed && !abm_changed && !hdr_changed)\n\t\t\tcontinue;\n\n\t\tstream_update.stream = dm_new_crtc_state->stream;\n\t\tif (scaling_changed) {\n\t\t\tupdate_stream_scaling_settings(&dm_new_con_state->base.crtc->mode,\n\t\t\t\t\tdm_new_con_state, dm_new_crtc_state->stream);\n\n\t\t\tstream_update.src = dm_new_crtc_state->stream->src;\n\t\t\tstream_update.dst = dm_new_crtc_state->stream->dst;\n\t\t}\n\n\t\tif (abm_changed) {\n\t\t\tdm_new_crtc_state->stream->abm_level = dm_new_crtc_state->abm_level;\n\n\t\t\tstream_update.abm_level = &dm_new_crtc_state->abm_level;\n\t\t}\n\n\t\tif (hdr_changed) {\n\t\t\tfill_hdr_info_packet(new_con_state, &hdr_packet);\n\t\t\tstream_update.hdr_static_metadata = &hdr_packet;\n\t\t}\n\n\t\tstatus = dc_stream_get_status(dm_new_crtc_state->stream);\n\n\t\tif (WARN_ON(!status))\n\t\t\tcontinue;\n\n\t\tWARN_ON(!status->plane_count);\n\n\t\t/*\n\t\t * TODO: DC refuses to perform stream updates without a dc_surface_update.\n\t\t * Here we create an empty update on each plane.\n\t\t * To fix this, DC should permit updating only stream properties.\n\t\t */\n\t\tdummy_updates = kzalloc(sizeof(struct dc_surface_update) * MAX_SURFACES, GFP_ATOMIC);\n\t\tif (!dummy_updates) {\n\t\t\tDRM_ERROR(\"Failed to allocate memory for dummy_updates.\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < status->plane_count; j++)\n\t\t\tdummy_updates[j].surface = status->plane_states[0];\n\n\n\t\tmutex_lock(&dm->dc_lock);\n\t\tdc_update_planes_and_stream(dm->dc,\n\t\t\t\t\t    dummy_updates,\n\t\t\t\t\t    status->plane_count,\n\t\t\t\t\t    dm_new_crtc_state->stream,\n\t\t\t\t\t    &stream_update);\n\t\tmutex_unlock(&dm->dc_lock);\n\t\tkfree(dummy_updates);\n\t}\n\n\t/**\n\t * Enable interrupts for CRTCs that are newly enabled or went through\n\t * a modeset. It was intentionally deferred until after the front end\n\t * state was modified to wait until the OTG was on and so the IRQ\n\t * handlers didn't access stale or invalid state.\n\t */\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n#ifdef CONFIG_DEBUG_FS\n\t\tenum amdgpu_dm_pipe_crc_source cur_crc_src;\n#endif\n\t\t/* Count number of newly disabled CRTCs for dropping PM refs later. */\n\t\tif (old_crtc_state->active && !new_crtc_state->active)\n\t\t\tcrtc_disable_count++;\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\t/* For freesync config update on crtc state and params for irq */\n\t\tupdate_stream_irq_parameters(dm, dm_new_crtc_state);\n\n#ifdef CONFIG_DEBUG_FS\n\t\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\t\tcur_crc_src = acrtc->dm_irq_params.crc_src;\n\t\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n#endif\n\n\t\tif (new_crtc_state->active &&\n\t\t    (!old_crtc_state->active ||\n\t\t     drm_atomic_crtc_needs_modeset(new_crtc_state))) {\n\t\t\tdc_stream_retain(dm_new_crtc_state->stream);\n\t\t\tacrtc->dm_irq_params.stream = dm_new_crtc_state->stream;\n\t\t\tmanage_dm_interrupts(adev, acrtc, true);\n\t\t}\n\t\t/* Handle vrr on->off / off->on transitions */\n\t\tamdgpu_dm_handle_vrr_transition(dm_old_crtc_state, dm_new_crtc_state);\n\n#ifdef CONFIG_DEBUG_FS\n\t\tif (new_crtc_state->active &&\n\t\t    (!old_crtc_state->active ||\n\t\t     drm_atomic_crtc_needs_modeset(new_crtc_state))) {\n\t\t\t/**\n\t\t\t * Frontend may have changed so reapply the CRC capture\n\t\t\t * settings for the stream.\n\t\t\t */\n\t\t\tif (amdgpu_dm_is_valid_crc_source(cur_crc_src)) {\n#if defined(CONFIG_DRM_AMD_SECURE_DISPLAY)\n\t\t\t\tif (amdgpu_dm_crc_window_is_activated(crtc)) {\n\t\t\t\t\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\t\t\t\t\tacrtc->dm_irq_params.window_param.update_win = true;\n\n\t\t\t\t\t/**\n\t\t\t\t\t * It takes 2 frames for HW to stably generate CRC when\n\t\t\t\t\t * resuming from suspend, so we set skip_frame_cnt 2.\n\t\t\t\t\t */\n\t\t\t\t\tacrtc->dm_irq_params.window_param.skip_frame_cnt = 2;\n\t\t\t\t\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n\t\t\t\t}\n#endif\n\t\t\t\tif (amdgpu_dm_crtc_configure_crc_source(\n\t\t\t\t\tcrtc, dm_new_crtc_state, cur_crc_src))\n\t\t\t\t\tDRM_DEBUG_DRIVER(\"Failed to configure crc source\");\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, j)\n\t\tif (new_crtc_state->async_flip)\n\t\t\twait_for_vblank = false;\n\n\t/* update planes when needed per crtc*/\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, j) {\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (dm_new_crtc_state->stream)\n\t\t\tamdgpu_dm_commit_planes(state, dev, dm, crtc, wait_for_vblank);\n\t}\n\n\t/* Enable writeback */\n\tfor_each_new_connector_in_state(state, connector, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\n\t\tif (connector->connector_type != DRM_MODE_CONNECTOR_WRITEBACK)\n\t\t\tcontinue;\n\n\t\tif (!new_con_state->writeback_job)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\n\t\tif (!new_crtc_state)\n\t\t\tcontinue;\n\n\t\tif (acrtc->wb_enabled)\n\t\t\tcontinue;\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tdm_set_writeback(dm, dm_new_crtc_state, connector, new_con_state);\n\t\tacrtc->wb_enabled = true;\n\t}\n\n\t/* Update audio instances for each connector. */\n\tamdgpu_dm_commit_audio(dev, state);\n\n\t/* restore the backlight level */\n\tfor (i = 0; i < dm->num_of_edps; i++) {\n\t\tif (dm->backlight_dev[i] &&\n\t\t    (dm->actual_brightness[i] != dm->brightness[i]))\n\t\t\tamdgpu_dm_backlight_set_level(dm, i, dm->brightness[i]);\n\t}\n\n\t/*\n\t * send vblank event on all events not handled in flip and\n\t * mark consumed event for drm_atomic_helper_commit_hw_done\n\t */\n\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\n\t\tif (new_crtc_state->event)\n\t\t\tdrm_send_event_locked(dev, &new_crtc_state->event->base);\n\n\t\tnew_crtc_state->event = NULL;\n\t}\n\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n\n\t/* Signal HW programming completion */\n\tdrm_atomic_helper_commit_hw_done(state);\n\n\tif (wait_for_vblank)\n\t\tdrm_atomic_helper_wait_for_flip_done(dev, state);\n\n\tdrm_atomic_helper_cleanup_planes(dev, state);\n\n\t/* Don't free the memory if we are hitting this as part of suspend.\n\t * This way we don't free any memory during suspend; see\n\t * amdgpu_bo_free_kernel().  The memory will be freed in the first\n\t * non-suspend modeset or when the driver is torn down.\n\t */\n\tif (!adev->in_suspend) {\n\t\t/* return the stolen vga memory back to VRAM */\n\t\tif (!adev->mman.keep_stolen_vga_memory)\n\t\t\tamdgpu_bo_free_kernel(&adev->mman.stolen_vga_memory, NULL, NULL);\n\t\tamdgpu_bo_free_kernel(&adev->mman.stolen_extended_memory, NULL, NULL);\n\t}\n\n\t/*\n\t * Finally, drop a runtime PM reference for each newly disabled CRTC,\n\t * so we can put the GPU into runtime suspend if we're not driving any\n\t * displays anymore\n\t */\n\tfor (i = 0; i < crtc_disable_count; i++)\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\tpm_runtime_mark_last_busy(dev->dev);\n}"
    },
    {
        "var_name": "aconnector->dc_link",
        "function_name": "amdgpu_dm_atomic_commit_tail",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c",
            "region": {
                "startLine": 9281,
                "startColumn": 40,
                "endColumn": 59
            },
            "context": {
                "startLine": 9279,
                "endLine": 9283,
                "snippet": {
                    "text": "adev->dm.hdcp_workqueue, aconnector->dc_link->link_index, aconnector,"
                }
            }
        },
        "function_code": "static void amdgpu_dm_atomic_commit_tail(struct drm_atomic_state *state)\n{\n\tstruct drm_device *dev = state->dev;\n\tstruct amdgpu_device *adev = drm_to_adev(dev);\n\tstruct amdgpu_display_manager *dm = &adev->dm;\n\tstruct dm_atomic_state *dm_state;\n\tstruct dc_state *dc_state = NULL;\n\tu32 i, j;\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *old_crtc_state, *new_crtc_state;\n\tunsigned long flags;\n\tbool wait_for_vblank = true;\n\tstruct drm_connector *connector;\n\tstruct drm_connector_state *old_con_state, *new_con_state;\n\tstruct dm_crtc_state *dm_old_crtc_state, *dm_new_crtc_state;\n\tint crtc_disable_count = 0;\n\n\ttrace_amdgpu_dm_atomic_commit_tail_begin(state);\n\n\tif (dm->dc->caps.ips_support && dm->dc->idle_optimizations_allowed)\n\t\tdc_allow_idle_optimizations(dm->dc, false);\n\n\tdrm_atomic_helper_update_legacy_modeset_state(dev, state);\n\tdrm_dp_mst_atomic_wait_for_dependencies(state);\n\n\tdm_state = dm_atomic_get_new_state(state);\n\tif (dm_state && dm_state->context) {\n\t\tdc_state = dm_state->context;\n\t\tamdgpu_dm_commit_streams(state, dc_state);\n\t}\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\t\tstruct amdgpu_dm_connector *aconnector;\n\n\t\tif (connector->connector_type == DRM_MODE_CONNECTOR_WRITEBACK)\n\t\t\tcontinue;\n\n\t\taconnector = to_amdgpu_dm_connector(connector);\n\n\t\tif (!adev->dm.hdcp_workqueue)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"[HDCP_DM] -------------- i : %x ----------\\n\", i);\n\n\t\tif (!connector)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"[HDCP_DM] connector->index: %x connect_status: %x dpms: %x\\n\",\n\t\t\tconnector->index, connector->status, connector->dpms);\n\t\tpr_debug(\"[HDCP_DM] state protection old: %x new: %x\\n\",\n\t\t\told_con_state->content_protection, new_con_state->content_protection);\n\n\t\tif (aconnector->dc_sink) {\n\t\t\tif (aconnector->dc_sink->sink_signal != SIGNAL_TYPE_VIRTUAL &&\n\t\t\t\taconnector->dc_sink->sink_signal != SIGNAL_TYPE_NONE) {\n\t\t\t\tpr_debug(\"[HDCP_DM] pipe_ctx dispname=%s\\n\",\n\t\t\t\taconnector->dc_sink->edid_caps.display_name);\n\t\t\t}\n\t\t}\n\n\t\tnew_crtc_state = NULL;\n\t\told_crtc_state = NULL;\n\n\t\tif (acrtc) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\t\t\told_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);\n\t\t}\n\n\t\tif (old_crtc_state)\n\t\t\tpr_debug(\"old crtc en: %x a: %x m: %x a-chg: %x c-chg: %x\\n\",\n\t\t\told_crtc_state->enable,\n\t\t\told_crtc_state->active,\n\t\t\told_crtc_state->mode_changed,\n\t\t\told_crtc_state->active_changed,\n\t\t\told_crtc_state->connectors_changed);\n\n\t\tif (new_crtc_state)\n\t\t\tpr_debug(\"NEW crtc en: %x a: %x m: %x a-chg: %x c-chg: %x\\n\",\n\t\t\tnew_crtc_state->enable,\n\t\t\tnew_crtc_state->active,\n\t\t\tnew_crtc_state->mode_changed,\n\t\t\tnew_crtc_state->active_changed,\n\t\t\tnew_crtc_state->connectors_changed);\n\t}\n\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\t\tstruct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);\n\n\t\tif (!adev->dm.hdcp_workqueue)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = NULL;\n\t\told_crtc_state = NULL;\n\n\t\tif (acrtc) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\t\t\told_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);\n\t\t}\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (dm_new_crtc_state && dm_new_crtc_state->stream == NULL &&\n\t\t    connector->state->content_protection == DRM_MODE_CONTENT_PROTECTION_ENABLED) {\n\t\t\thdcp_reset_display(adev->dm.hdcp_workqueue, aconnector->dc_link->link_index);\n\t\t\tnew_con_state->content_protection = DRM_MODE_CONTENT_PROTECTION_DESIRED;\n\t\t\tdm_new_con_state->update_hdcp = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_content_protection_different(new_crtc_state, old_crtc_state, new_con_state,\n\t\t\t\t\t\t\t\t\t\t\told_con_state, connector, adev->dm.hdcp_workqueue)) {\n\t\t\t/* when display is unplugged from mst hub, connctor will\n\t\t\t * be destroyed within dm_dp_mst_connector_destroy. connector\n\t\t\t * hdcp perperties, like type, undesired, desired, enabled,\n\t\t\t * will be lost. So, save hdcp properties into hdcp_work within\n\t\t\t * amdgpu_dm_atomic_commit_tail. if the same display is\n\t\t\t * plugged back with same display index, its hdcp properties\n\t\t\t * will be retrieved from hdcp_work within dm_dp_mst_get_modes\n\t\t\t */\n\n\t\t\tbool enable_encryption = false;\n\n\t\t\tif (new_con_state->content_protection == DRM_MODE_CONTENT_PROTECTION_DESIRED)\n\t\t\t\tenable_encryption = true;\n\n\t\t\tif (aconnector->dc_link && aconnector->dc_sink &&\n\t\t\t\taconnector->dc_link->type == dc_connection_mst_branch) {\n\t\t\t\tstruct hdcp_workqueue *hdcp_work = adev->dm.hdcp_workqueue;\n\t\t\t\tstruct hdcp_workqueue *hdcp_w =\n\t\t\t\t\t&hdcp_work[aconnector->dc_link->link_index];\n\n\t\t\t\thdcp_w->hdcp_content_type[connector->index] =\n\t\t\t\t\tnew_con_state->hdcp_content_type;\n\t\t\t\thdcp_w->content_protection[connector->index] =\n\t\t\t\t\tnew_con_state->content_protection;\n\t\t\t}\n\n\t\t\tif (new_crtc_state && new_crtc_state->mode_changed &&\n\t\t\t\tnew_con_state->content_protection >= DRM_MODE_CONTENT_PROTECTION_DESIRED)\n\t\t\t\tenable_encryption = true;\n\n\t\t\tDRM_INFO(\"[HDCP_DM] hdcp_update_display enable_encryption = %x\\n\", enable_encryption);\n\n\t\t\thdcp_update_display(\n\t\t\t\tadev->dm.hdcp_workqueue, aconnector->dc_link->link_index, aconnector,\n\t\t\t\tnew_con_state->hdcp_content_type, enable_encryption);\n\t\t}\n\t}\n\n\t/* Handle connector state changes */\n\tfor_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct dm_connector_state *dm_old_con_state = to_dm_connector_state(old_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\t\tstruct dc_surface_update *dummy_updates;\n\t\tstruct dc_stream_update stream_update;\n\t\tstruct dc_info_packet hdr_packet;\n\t\tstruct dc_stream_status *status = NULL;\n\t\tbool abm_changed, hdr_changed, scaling_changed;\n\n\t\tmemset(&stream_update, 0, sizeof(stream_update));\n\n\t\tif (acrtc) {\n\t\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\t\t\told_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);\n\t\t}\n\n\t\t/* Skip any modesets/resets */\n\t\tif (!acrtc || drm_atomic_crtc_needs_modeset(new_crtc_state))\n\t\t\tcontinue;\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\tscaling_changed = is_scaling_state_different(dm_new_con_state,\n\t\t\t\t\t\t\t     dm_old_con_state);\n\n\t\tabm_changed = dm_new_crtc_state->abm_level !=\n\t\t\t      dm_old_crtc_state->abm_level;\n\n\t\thdr_changed =\n\t\t\t!drm_connector_atomic_hdr_metadata_equal(old_con_state, new_con_state);\n\n\t\tif (!scaling_changed && !abm_changed && !hdr_changed)\n\t\t\tcontinue;\n\n\t\tstream_update.stream = dm_new_crtc_state->stream;\n\t\tif (scaling_changed) {\n\t\t\tupdate_stream_scaling_settings(&dm_new_con_state->base.crtc->mode,\n\t\t\t\t\tdm_new_con_state, dm_new_crtc_state->stream);\n\n\t\t\tstream_update.src = dm_new_crtc_state->stream->src;\n\t\t\tstream_update.dst = dm_new_crtc_state->stream->dst;\n\t\t}\n\n\t\tif (abm_changed) {\n\t\t\tdm_new_crtc_state->stream->abm_level = dm_new_crtc_state->abm_level;\n\n\t\t\tstream_update.abm_level = &dm_new_crtc_state->abm_level;\n\t\t}\n\n\t\tif (hdr_changed) {\n\t\t\tfill_hdr_info_packet(new_con_state, &hdr_packet);\n\t\t\tstream_update.hdr_static_metadata = &hdr_packet;\n\t\t}\n\n\t\tstatus = dc_stream_get_status(dm_new_crtc_state->stream);\n\n\t\tif (WARN_ON(!status))\n\t\t\tcontinue;\n\n\t\tWARN_ON(!status->plane_count);\n\n\t\t/*\n\t\t * TODO: DC refuses to perform stream updates without a dc_surface_update.\n\t\t * Here we create an empty update on each plane.\n\t\t * To fix this, DC should permit updating only stream properties.\n\t\t */\n\t\tdummy_updates = kzalloc(sizeof(struct dc_surface_update) * MAX_SURFACES, GFP_ATOMIC);\n\t\tif (!dummy_updates) {\n\t\t\tDRM_ERROR(\"Failed to allocate memory for dummy_updates.\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = 0; j < status->plane_count; j++)\n\t\t\tdummy_updates[j].surface = status->plane_states[0];\n\n\n\t\tmutex_lock(&dm->dc_lock);\n\t\tdc_update_planes_and_stream(dm->dc,\n\t\t\t\t\t    dummy_updates,\n\t\t\t\t\t    status->plane_count,\n\t\t\t\t\t    dm_new_crtc_state->stream,\n\t\t\t\t\t    &stream_update);\n\t\tmutex_unlock(&dm->dc_lock);\n\t\tkfree(dummy_updates);\n\t}\n\n\t/**\n\t * Enable interrupts for CRTCs that are newly enabled or went through\n\t * a modeset. It was intentionally deferred until after the front end\n\t * state was modified to wait until the OTG was on and so the IRQ\n\t * handlers didn't access stale or invalid state.\n\t */\n\tfor_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);\n#ifdef CONFIG_DEBUG_FS\n\t\tenum amdgpu_dm_pipe_crc_source cur_crc_src;\n#endif\n\t\t/* Count number of newly disabled CRTCs for dropping PM refs later. */\n\t\tif (old_crtc_state->active && !new_crtc_state->active)\n\t\t\tcrtc_disable_count++;\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\t\tdm_old_crtc_state = to_dm_crtc_state(old_crtc_state);\n\n\t\t/* For freesync config update on crtc state and params for irq */\n\t\tupdate_stream_irq_parameters(dm, dm_new_crtc_state);\n\n#ifdef CONFIG_DEBUG_FS\n\t\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\t\tcur_crc_src = acrtc->dm_irq_params.crc_src;\n\t\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n#endif\n\n\t\tif (new_crtc_state->active &&\n\t\t    (!old_crtc_state->active ||\n\t\t     drm_atomic_crtc_needs_modeset(new_crtc_state))) {\n\t\t\tdc_stream_retain(dm_new_crtc_state->stream);\n\t\t\tacrtc->dm_irq_params.stream = dm_new_crtc_state->stream;\n\t\t\tmanage_dm_interrupts(adev, acrtc, true);\n\t\t}\n\t\t/* Handle vrr on->off / off->on transitions */\n\t\tamdgpu_dm_handle_vrr_transition(dm_old_crtc_state, dm_new_crtc_state);\n\n#ifdef CONFIG_DEBUG_FS\n\t\tif (new_crtc_state->active &&\n\t\t    (!old_crtc_state->active ||\n\t\t     drm_atomic_crtc_needs_modeset(new_crtc_state))) {\n\t\t\t/**\n\t\t\t * Frontend may have changed so reapply the CRC capture\n\t\t\t * settings for the stream.\n\t\t\t */\n\t\t\tif (amdgpu_dm_is_valid_crc_source(cur_crc_src)) {\n#if defined(CONFIG_DRM_AMD_SECURE_DISPLAY)\n\t\t\t\tif (amdgpu_dm_crc_window_is_activated(crtc)) {\n\t\t\t\t\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\t\t\t\t\tacrtc->dm_irq_params.window_param.update_win = true;\n\n\t\t\t\t\t/**\n\t\t\t\t\t * It takes 2 frames for HW to stably generate CRC when\n\t\t\t\t\t * resuming from suspend, so we set skip_frame_cnt 2.\n\t\t\t\t\t */\n\t\t\t\t\tacrtc->dm_irq_params.window_param.skip_frame_cnt = 2;\n\t\t\t\t\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n\t\t\t\t}\n#endif\n\t\t\t\tif (amdgpu_dm_crtc_configure_crc_source(\n\t\t\t\t\tcrtc, dm_new_crtc_state, cur_crc_src))\n\t\t\t\t\tDRM_DEBUG_DRIVER(\"Failed to configure crc source\");\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, j)\n\t\tif (new_crtc_state->async_flip)\n\t\t\twait_for_vblank = false;\n\n\t/* update planes when needed per crtc*/\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, j) {\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tif (dm_new_crtc_state->stream)\n\t\t\tamdgpu_dm_commit_planes(state, dev, dm, crtc, wait_for_vblank);\n\t}\n\n\t/* Enable writeback */\n\tfor_each_new_connector_in_state(state, connector, new_con_state, i) {\n\t\tstruct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);\n\t\tstruct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);\n\n\t\tif (connector->connector_type != DRM_MODE_CONNECTOR_WRITEBACK)\n\t\t\tcontinue;\n\n\t\tif (!new_con_state->writeback_job)\n\t\t\tcontinue;\n\n\t\tnew_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);\n\n\t\tif (!new_crtc_state)\n\t\t\tcontinue;\n\n\t\tif (acrtc->wb_enabled)\n\t\t\tcontinue;\n\n\t\tdm_new_crtc_state = to_dm_crtc_state(new_crtc_state);\n\n\t\tdm_set_writeback(dm, dm_new_crtc_state, connector, new_con_state);\n\t\tacrtc->wb_enabled = true;\n\t}\n\n\t/* Update audio instances for each connector. */\n\tamdgpu_dm_commit_audio(dev, state);\n\n\t/* restore the backlight level */\n\tfor (i = 0; i < dm->num_of_edps; i++) {\n\t\tif (dm->backlight_dev[i] &&\n\t\t    (dm->actual_brightness[i] != dm->brightness[i]))\n\t\t\tamdgpu_dm_backlight_set_level(dm, i, dm->brightness[i]);\n\t}\n\n\t/*\n\t * send vblank event on all events not handled in flip and\n\t * mark consumed event for drm_atomic_helper_commit_hw_done\n\t */\n\tspin_lock_irqsave(&adev_to_drm(adev)->event_lock, flags);\n\tfor_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {\n\n\t\tif (new_crtc_state->event)\n\t\t\tdrm_send_event_locked(dev, &new_crtc_state->event->base);\n\n\t\tnew_crtc_state->event = NULL;\n\t}\n\tspin_unlock_irqrestore(&adev_to_drm(adev)->event_lock, flags);\n\n\t/* Signal HW programming completion */\n\tdrm_atomic_helper_commit_hw_done(state);\n\n\tif (wait_for_vblank)\n\t\tdrm_atomic_helper_wait_for_flip_done(dev, state);\n\n\tdrm_atomic_helper_cleanup_planes(dev, state);\n\n\t/* Don't free the memory if we are hitting this as part of suspend.\n\t * This way we don't free any memory during suspend; see\n\t * amdgpu_bo_free_kernel().  The memory will be freed in the first\n\t * non-suspend modeset or when the driver is torn down.\n\t */\n\tif (!adev->in_suspend) {\n\t\t/* return the stolen vga memory back to VRAM */\n\t\tif (!adev->mman.keep_stolen_vga_memory)\n\t\t\tamdgpu_bo_free_kernel(&adev->mman.stolen_vga_memory, NULL, NULL);\n\t\tamdgpu_bo_free_kernel(&adev->mman.stolen_extended_memory, NULL, NULL);\n\t}\n\n\t/*\n\t * Finally, drop a runtime PM reference for each newly disabled CRTC,\n\t * so we can put the GPU into runtime suspend if we're not driving any\n\t * displays anymore\n\t */\n\tfor (i = 0; i < crtc_disable_count; i++)\n\t\tpm_runtime_put_autosuspend(dev->dev);\n\tpm_runtime_mark_last_busy(dev->dev);\n}"
    },
    {
        "var_name": "stream",
        "function_name": "dm_helpers_dp_write_dsc_enable",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_helpers.c",
            "region": {
                "startLine": 802,
                "startColumn": 33,
                "endColumn": 39
            },
            "context": {
                "startLine": 800,
                "endLine": 804,
                "snippet": {
                    "text": "(struct amdgpu_dm_connector *)stream->dm_stream_context;"
                }
            }
        },
        "function_code": "bool dm_helpers_dp_write_dsc_enable(\n\t\tstruct dc_context *ctx,\n\t\tconst struct dc_stream_state *stream,\n\t\tbool enable)\n{\n\tstatic const uint8_t DSC_DISABLE;\n\tstatic const uint8_t DSC_DECODING = 0x01;\n\tstatic const uint8_t DSC_PASSTHROUGH = 0x02;\n\n\tstruct amdgpu_dm_connector *aconnector =\n\t\t(struct amdgpu_dm_connector *)stream->dm_stream_context;\n\tstruct drm_device *dev = aconnector->base.dev;\n\tstruct drm_dp_mst_port *port;\n\tuint8_t enable_dsc = enable ? DSC_DECODING : DSC_DISABLE;\n\tuint8_t enable_passthrough = enable ? DSC_PASSTHROUGH : DSC_DISABLE;\n\tuint8_t ret = 0;\n\n\tif (!stream)\n\t\treturn false;\n\n\tif (stream->signal == SIGNAL_TYPE_DISPLAY_PORT_MST) {\n\t\tif (!aconnector->dsc_aux)\n\t\t\treturn false;\n\n\t\t// apply w/a to synaptics\n\t\tif (needs_dsc_aux_workaround(aconnector->dc_link) &&\n\t\t    (aconnector->mst_downstream_port_present.byte & 0x7) != 0x3)\n\t\t\treturn write_dsc_enable_synaptics_non_virtual_dpcd_mst(\n\t\t\t\taconnector->dsc_aux, stream, enable_dsc);\n\n\t\tport = aconnector->mst_output_port;\n\n\t\tif (enable) {\n\t\t\tif (port->passthrough_aux) {\n\t\t\t\tret = drm_dp_dpcd_write(port->passthrough_aux,\n\t\t\t\t\t\t\tDP_DSC_ENABLE,\n\t\t\t\t\t\t\t&enable_passthrough, 1);\n\t\t\t\tdrm_dbg_dp(dev,\n\t\t\t\t\t   \"Sent DSC pass-through enable to virtual dpcd port, ret = %u\\n\",\n\t\t\t\t\t   ret);\n\t\t\t}\n\n\t\t\tret = drm_dp_dpcd_write(aconnector->dsc_aux,\n\t\t\t\t\t\tDP_DSC_ENABLE, &enable_dsc, 1);\n\t\t\tdrm_dbg_dp(dev,\n\t\t\t\t   \"Sent DSC decoding enable to %s port, ret = %u\\n\",\n\t\t\t\t   (port->passthrough_aux) ? \"remote RX\" :\n\t\t\t\t   \"virtual dpcd\",\n\t\t\t\t   ret);\n\t\t} else {\n\t\t\tret = drm_dp_dpcd_write(aconnector->dsc_aux,\n\t\t\t\t\t\tDP_DSC_ENABLE, &enable_dsc, 1);\n\t\t\tdrm_dbg_dp(dev,\n\t\t\t\t   \"Sent DSC decoding disable to %s port, ret = %u\\n\",\n\t\t\t\t   (port->passthrough_aux) ? \"remote RX\" :\n\t\t\t\t   \"virtual dpcd\",\n\t\t\t\t   ret);\n\n\t\t\tif (port->passthrough_aux) {\n\t\t\t\tret = drm_dp_dpcd_write(port->passthrough_aux,\n\t\t\t\t\t\t\tDP_DSC_ENABLE,\n\t\t\t\t\t\t\t&enable_passthrough, 1);\n\t\t\t\tdrm_dbg_dp(dev,\n\t\t\t\t\t   \"Sent DSC pass-through disable to virtual dpcd port, ret = %u\\n\",\n\t\t\t\t\t   ret);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (stream->signal == SIGNAL_TYPE_DISPLAY_PORT || stream->signal == SIGNAL_TYPE_EDP) {\n\t\tif (stream->sink->link->dpcd_caps.dongle_type == DISPLAY_DONGLE_NONE) {\n\t\t\tret = dm_helpers_dp_write_dpcd(ctx, stream->link, DP_DSC_ENABLE, &enable_dsc, 1);\n\t\t\tdrm_dbg_dp(dev,\n\t\t\t\t   \"Send DSC %s to SST RX\\n\",\n\t\t\t\t   enable_dsc ? \"enable\" : \"disable\");\n\t\t} else if (stream->sink->link->dpcd_caps.dongle_type == DISPLAY_DONGLE_DP_HDMI_CONVERTER) {\n\t\t\tret = dm_helpers_dp_write_dpcd(ctx, stream->link, DP_DSC_ENABLE, &enable_dsc, 1);\n\t\t\tdrm_dbg_dp(dev,\n\t\t\t\t   \"Send DSC %s to DP-HDMI PCON\\n\",\n\t\t\t\t   enable_dsc ? \"enable\" : \"disable\");\n\t\t}\n\t}\n\n\treturn ret;\n}"
    },
    {
        "var_name": "afb",
        "function_name": "amdgpu_dm_plane_handle_cursor_update",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_plane.c",
            "region": {
                "startLine": 1283,
                "startColumn": 21,
                "endColumn": 24
            },
            "context": {
                "startLine": 1281,
                "endLine": 1285,
                "snippet": {
                    "text": "attributes.pitch = afb->base.pitches[0] / afb->base.format->cpp[0];"
                }
            }
        },
        "function_code": "void amdgpu_dm_plane_handle_cursor_update(struct drm_plane *plane,\n\t\t\t\t struct drm_plane_state *old_plane_state)\n{\n\tstruct amdgpu_device *adev = drm_to_adev(plane->dev);\n\tstruct amdgpu_framebuffer *afb = to_amdgpu_framebuffer(plane->state->fb);\n\tstruct drm_crtc *crtc = afb ? plane->state->crtc : old_plane_state->crtc;\n\tstruct dm_crtc_state *crtc_state = crtc ? to_dm_crtc_state(crtc->state) : NULL;\n\tstruct amdgpu_crtc *amdgpu_crtc = to_amdgpu_crtc(crtc);\n\tuint64_t address = afb ? afb->address : 0;\n\tstruct dc_cursor_position position = {0};\n\tstruct dc_cursor_attributes attributes;\n\tint ret;\n\n\tif (!plane->state->fb && !old_plane_state->fb)\n\t\treturn;\n\n\tdrm_dbg_atomic(plane->dev, \"crtc_id=%d with size %d to %d\\n\",\n\t\t       amdgpu_crtc->crtc_id, plane->state->crtc_w,\n\t\t       plane->state->crtc_h);\n\n\tret = amdgpu_dm_plane_get_cursor_position(plane, crtc, &position);\n\tif (ret)\n\t\treturn;\n\n\tif (!position.enable) {\n\t\t/* turn off cursor */\n\t\tif (crtc_state && crtc_state->stream) {\n\t\t\tmutex_lock(&adev->dm.dc_lock);\n\t\t\tdc_stream_set_cursor_position(crtc_state->stream,\n\t\t\t\t\t\t      &position);\n\t\t\tmutex_unlock(&adev->dm.dc_lock);\n\t\t}\n\t\treturn;\n\t}\n\n\tamdgpu_crtc->cursor_width = plane->state->crtc_w;\n\tamdgpu_crtc->cursor_height = plane->state->crtc_h;\n\n\tmemset(&attributes, 0, sizeof(attributes));\n\tattributes.address.high_part = upper_32_bits(address);\n\tattributes.address.low_part  = lower_32_bits(address);\n\tattributes.width             = plane->state->crtc_w;\n\tattributes.height            = plane->state->crtc_h;\n\tattributes.color_format      = CURSOR_MODE_COLOR_PRE_MULTIPLIED_ALPHA;\n\tattributes.rotation_angle    = 0;\n\tattributes.attribute_flags.value = 0;\n\n\t/* Enable cursor degamma ROM on DCN3+ for implicit sRGB degamma in DRM\n\t * legacy gamma setup.\n\t */\n\tif (crtc_state->cm_is_degamma_srgb &&\n\t    adev->dm.dc->caps.color.dpp.gamma_corr)\n\t\tattributes.attribute_flags.bits.ENABLE_CURSOR_DEGAMMA = 1;\n\n\tattributes.pitch = afb->base.pitches[0] / afb->base.format->cpp[0];\n\n\tif (crtc_state->stream) {\n\t\tmutex_lock(&adev->dm.dc_lock);\n\t\tif (!dc_stream_set_cursor_attributes(crtc_state->stream,\n\t\t\t\t\t\t\t &attributes))\n\t\t\tDRM_ERROR(\"DC failed to set cursor attributes\\n\");\n\n\t\tif (!dc_stream_set_cursor_position(crtc_state->stream,\n\t\t\t\t\t\t   &position))\n\t\t\tDRM_ERROR(\"DC failed to set cursor position\\n\");\n\t\tmutex_unlock(&adev->dm.dc_lock);\n\t}\n}"
    },
    {
        "var_name": "new_clocks",
        "function_name": "dcn32_auto_dpm_test_log",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c",
            "region": {
                "startLine": 536,
                "startColumn": 28,
                "endColumn": 38
            },
            "context": {
                "startLine": 534,
                "endLine": 538,
                "snippet": {
                    "text": "dramclk_khz_override = new_clocks->dramclk_khz;"
                }
            }
        },
        "function_code": "static void dcn32_auto_dpm_test_log(\n\t\tstruct dc_clocks *new_clocks,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct dc_state *context)\n{\n\tunsigned int dispclk_khz_reg, dppclk_khz_reg, dprefclk_khz_reg, dcfclk_khz_reg, dtbclk_khz_reg,\n\t\t\t\t fclk_khz_reg, mall_ss_size_bytes;\n\tint dramclk_khz_override, fclk_khz_override, num_fclk_levels;\n\n\tstruct pipe_ctx *pipe_ctx_list[MAX_PIPES];\n\tint active_pipe_count = 0;\n\n\tfor (int i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream && dc_state_get_pipe_subvp_type(context, pipe_ctx) != SUBVP_PHANTOM) {\n\t\t\tpipe_ctx_list[active_pipe_count] = pipe_ctx;\n\t\t\tactive_pipe_count++;\n\t\t}\n\t}\n\n\tmsleep(5);\n\n\tmall_ss_size_bytes = context->bw_ctx.bw.dcn.mall_ss_size_bytes;\n\n    dispclk_khz_reg    = REG_READ(CLK1_CLK0_CURRENT_CNT); // DISPCLK\n    dppclk_khz_reg     = REG_READ(CLK1_CLK1_CURRENT_CNT); // DPPCLK\n    dprefclk_khz_reg   = REG_READ(CLK1_CLK2_CURRENT_CNT); // DPREFCLK\n    dcfclk_khz_reg     = REG_READ(CLK1_CLK3_CURRENT_CNT); // DCFCLK\n    dtbclk_khz_reg     = REG_READ(CLK1_CLK4_CURRENT_CNT); // DTBCLK\n    fclk_khz_reg       = REG_READ(CLK4_CLK0_CURRENT_CNT); // FCLK\n\n    // Overrides for these clocks in case there is no p_state change support\n    dramclk_khz_override = new_clocks->dramclk_khz;\n    fclk_khz_override = new_clocks->fclk_khz;\n\n    num_fclk_levels = clk_mgr->base.bw_params->clk_table.num_entries_per_clk.num_fclk_levels - 1;\n\n    if (!new_clocks->p_state_change_support) {\n\t    dramclk_khz_override = clk_mgr->base.bw_params->max_memclk_mhz * 1000;\n    }\n    if (!new_clocks->fclk_p_state_change_support) {\n\t    fclk_khz_override = clk_mgr->base.bw_params->clk_table.entries[num_fclk_levels].fclk_mhz * 1000;\n    }\n\n\t////////////////////////////////////////////////////////////////////////////\n\t//\tIMPORTANT: \tWhen adding more clocks to these logs, do NOT put a newline\n\t//\t \t\t\tanywhere other than at the very end of the string.\n\t//\n\t//\tFormatting example (make sure to have \" - \" between each entry):\n\t//\n\t//\t\t\t\tAutoDPMTest: clk1:%d - clk2:%d - clk3:%d - clk4:%d\\n\"\n\t////////////////////////////////////////////////////////////////////////////\n\tif (new_clocks && active_pipe_count > 0 &&\n\t\tnew_clocks->dramclk_khz > 0 &&\n\t\tnew_clocks->fclk_khz > 0 &&\n\t\tnew_clocks->dcfclk_khz > 0 &&\n\t\tnew_clocks->dppclk_khz > 0) {\n\n\t\tuint32_t pix_clk_list[MAX_PIPES] = {0};\n\t\tint p_state_list[MAX_PIPES] = {0};\n\t\tint disp_src_width_list[MAX_PIPES] = {0};\n\t\tint disp_src_height_list[MAX_PIPES] = {0};\n\t\tuint64_t disp_src_refresh_list[MAX_PIPES] = {0};\n\t\tbool is_scaled_list[MAX_PIPES] = {0};\n\n\t\tfor (int i = 0; i < active_pipe_count; i++) {\n\t\t\tstruct pipe_ctx *curr_pipe_ctx = pipe_ctx_list[i];\n\t\t\tuint64_t refresh_rate;\n\n\t\t\tpix_clk_list[i] = curr_pipe_ctx->stream->timing.pix_clk_100hz;\n\t\t\tp_state_list[i] = curr_pipe_ctx->p_state_type;\n\n\t\t\trefresh_rate = (curr_pipe_ctx->stream->timing.pix_clk_100hz * (uint64_t)100 +\n\t\t\t\tcurr_pipe_ctx->stream->timing.v_total * curr_pipe_ctx->stream->timing.h_total - (uint64_t)1);\n\t\t\trefresh_rate = div_u64(refresh_rate, curr_pipe_ctx->stream->timing.v_total);\n\t\t\trefresh_rate = div_u64(refresh_rate, curr_pipe_ctx->stream->timing.h_total);\n\t\t\tdisp_src_refresh_list[i] = refresh_rate;\n\n\t\t\tif (curr_pipe_ctx->plane_state) {\n\t\t\t\tis_scaled_list[i] = !(dcn32_check_native_scaling(curr_pipe_ctx));\n\t\t\t\tdisp_src_width_list[i] = curr_pipe_ctx->plane_state->src_rect.width;\n\t\t\t\tdisp_src_height_list[i] = curr_pipe_ctx->plane_state->src_rect.height;\n\t\t\t}\n\t\t}\n\n\t\tDC_LOG_AUTO_DPM_TEST(\"AutoDPMTest: dramclk:%d - fclk:%d - \"\n\t\t\t\"dcfclk:%d - dppclk:%d - dispclk_hw:%d - \"\n\t\t\t\"dppclk_hw:%d - dprefclk_hw:%d - dcfclk_hw:%d - \"\n\t\t\t\"dtbclk_hw:%d - fclk_hw:%d - pix_clk_0:%d - pix_clk_1:%d - \"\n\t\t\t\"pix_clk_2:%d - pix_clk_3:%d - mall_ss_size:%d - p_state_type_0:%d - \"\n\t\t\t\"p_state_type_1:%d - p_state_type_2:%d - p_state_type_3:%d - \"\n\t\t\t\"pix_width_0:%d - pix_height_0:%d - refresh_rate_0:%lld - is_scaled_0:%d - \"\n\t\t\t\"pix_width_1:%d - pix_height_1:%d - refresh_rate_1:%lld - is_scaled_1:%d - \"\n\t\t\t\"pix_width_2:%d - pix_height_2:%d - refresh_rate_2:%lld - is_scaled_2:%d - \"\n\t\t\t\"pix_width_3:%d - pix_height_3:%d - refresh_rate_3:%lld - is_scaled_3:%d - LOG_END\\n\",\n\t\t\tdramclk_khz_override,\n\t\t\tfclk_khz_override,\n\t\t\tnew_clocks->dcfclk_khz,\n\t\t\tnew_clocks->dppclk_khz,\n\t\t\tdispclk_khz_reg,\n\t\t\tdppclk_khz_reg,\n\t\t\tdprefclk_khz_reg,\n\t\t\tdcfclk_khz_reg,\n\t\t\tdtbclk_khz_reg,\n\t\t\tfclk_khz_reg,\n\t\t\tpix_clk_list[0], pix_clk_list[1], pix_clk_list[3], pix_clk_list[2],\n\t\t\tmall_ss_size_bytes,\n\t\t\tp_state_list[0], p_state_list[1], p_state_list[2], p_state_list[3],\n\t\t\tdisp_src_width_list[0], disp_src_height_list[0], disp_src_refresh_list[0], is_scaled_list[0],\n\t\t\tdisp_src_width_list[1], disp_src_height_list[1], disp_src_refresh_list[1], is_scaled_list[1],\n\t\t\tdisp_src_width_list[2], disp_src_height_list[2], disp_src_refresh_list[2], is_scaled_list[2],\n\t\t\tdisp_src_width_list[3], disp_src_height_list[3], disp_src_refresh_list[3], is_scaled_list[3]);\n\t}\n}"
    },
    {
        "var_name": "new_clocks",
        "function_name": "dcn32_auto_dpm_test_log",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c",
            "region": {
                "startLine": 537,
                "startColumn": 25,
                "endColumn": 35
            },
            "context": {
                "startLine": 535,
                "endLine": 539,
                "snippet": {
                    "text": "fclk_khz_override = new_clocks->fclk_khz;"
                }
            }
        },
        "function_code": "static void dcn32_auto_dpm_test_log(\n\t\tstruct dc_clocks *new_clocks,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct dc_state *context)\n{\n\tunsigned int dispclk_khz_reg, dppclk_khz_reg, dprefclk_khz_reg, dcfclk_khz_reg, dtbclk_khz_reg,\n\t\t\t\t fclk_khz_reg, mall_ss_size_bytes;\n\tint dramclk_khz_override, fclk_khz_override, num_fclk_levels;\n\n\tstruct pipe_ctx *pipe_ctx_list[MAX_PIPES];\n\tint active_pipe_count = 0;\n\n\tfor (int i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream && dc_state_get_pipe_subvp_type(context, pipe_ctx) != SUBVP_PHANTOM) {\n\t\t\tpipe_ctx_list[active_pipe_count] = pipe_ctx;\n\t\t\tactive_pipe_count++;\n\t\t}\n\t}\n\n\tmsleep(5);\n\n\tmall_ss_size_bytes = context->bw_ctx.bw.dcn.mall_ss_size_bytes;\n\n    dispclk_khz_reg    = REG_READ(CLK1_CLK0_CURRENT_CNT); // DISPCLK\n    dppclk_khz_reg     = REG_READ(CLK1_CLK1_CURRENT_CNT); // DPPCLK\n    dprefclk_khz_reg   = REG_READ(CLK1_CLK2_CURRENT_CNT); // DPREFCLK\n    dcfclk_khz_reg     = REG_READ(CLK1_CLK3_CURRENT_CNT); // DCFCLK\n    dtbclk_khz_reg     = REG_READ(CLK1_CLK4_CURRENT_CNT); // DTBCLK\n    fclk_khz_reg       = REG_READ(CLK4_CLK0_CURRENT_CNT); // FCLK\n\n    // Overrides for these clocks in case there is no p_state change support\n    dramclk_khz_override = new_clocks->dramclk_khz;\n    fclk_khz_override = new_clocks->fclk_khz;\n\n    num_fclk_levels = clk_mgr->base.bw_params->clk_table.num_entries_per_clk.num_fclk_levels - 1;\n\n    if (!new_clocks->p_state_change_support) {\n\t    dramclk_khz_override = clk_mgr->base.bw_params->max_memclk_mhz * 1000;\n    }\n    if (!new_clocks->fclk_p_state_change_support) {\n\t    fclk_khz_override = clk_mgr->base.bw_params->clk_table.entries[num_fclk_levels].fclk_mhz * 1000;\n    }\n\n\t////////////////////////////////////////////////////////////////////////////\n\t//\tIMPORTANT: \tWhen adding more clocks to these logs, do NOT put a newline\n\t//\t \t\t\tanywhere other than at the very end of the string.\n\t//\n\t//\tFormatting example (make sure to have \" - \" between each entry):\n\t//\n\t//\t\t\t\tAutoDPMTest: clk1:%d - clk2:%d - clk3:%d - clk4:%d\\n\"\n\t////////////////////////////////////////////////////////////////////////////\n\tif (new_clocks && active_pipe_count > 0 &&\n\t\tnew_clocks->dramclk_khz > 0 &&\n\t\tnew_clocks->fclk_khz > 0 &&\n\t\tnew_clocks->dcfclk_khz > 0 &&\n\t\tnew_clocks->dppclk_khz > 0) {\n\n\t\tuint32_t pix_clk_list[MAX_PIPES] = {0};\n\t\tint p_state_list[MAX_PIPES] = {0};\n\t\tint disp_src_width_list[MAX_PIPES] = {0};\n\t\tint disp_src_height_list[MAX_PIPES] = {0};\n\t\tuint64_t disp_src_refresh_list[MAX_PIPES] = {0};\n\t\tbool is_scaled_list[MAX_PIPES] = {0};\n\n\t\tfor (int i = 0; i < active_pipe_count; i++) {\n\t\t\tstruct pipe_ctx *curr_pipe_ctx = pipe_ctx_list[i];\n\t\t\tuint64_t refresh_rate;\n\n\t\t\tpix_clk_list[i] = curr_pipe_ctx->stream->timing.pix_clk_100hz;\n\t\t\tp_state_list[i] = curr_pipe_ctx->p_state_type;\n\n\t\t\trefresh_rate = (curr_pipe_ctx->stream->timing.pix_clk_100hz * (uint64_t)100 +\n\t\t\t\tcurr_pipe_ctx->stream->timing.v_total * curr_pipe_ctx->stream->timing.h_total - (uint64_t)1);\n\t\t\trefresh_rate = div_u64(refresh_rate, curr_pipe_ctx->stream->timing.v_total);\n\t\t\trefresh_rate = div_u64(refresh_rate, curr_pipe_ctx->stream->timing.h_total);\n\t\t\tdisp_src_refresh_list[i] = refresh_rate;\n\n\t\t\tif (curr_pipe_ctx->plane_state) {\n\t\t\t\tis_scaled_list[i] = !(dcn32_check_native_scaling(curr_pipe_ctx));\n\t\t\t\tdisp_src_width_list[i] = curr_pipe_ctx->plane_state->src_rect.width;\n\t\t\t\tdisp_src_height_list[i] = curr_pipe_ctx->plane_state->src_rect.height;\n\t\t\t}\n\t\t}\n\n\t\tDC_LOG_AUTO_DPM_TEST(\"AutoDPMTest: dramclk:%d - fclk:%d - \"\n\t\t\t\"dcfclk:%d - dppclk:%d - dispclk_hw:%d - \"\n\t\t\t\"dppclk_hw:%d - dprefclk_hw:%d - dcfclk_hw:%d - \"\n\t\t\t\"dtbclk_hw:%d - fclk_hw:%d - pix_clk_0:%d - pix_clk_1:%d - \"\n\t\t\t\"pix_clk_2:%d - pix_clk_3:%d - mall_ss_size:%d - p_state_type_0:%d - \"\n\t\t\t\"p_state_type_1:%d - p_state_type_2:%d - p_state_type_3:%d - \"\n\t\t\t\"pix_width_0:%d - pix_height_0:%d - refresh_rate_0:%lld - is_scaled_0:%d - \"\n\t\t\t\"pix_width_1:%d - pix_height_1:%d - refresh_rate_1:%lld - is_scaled_1:%d - \"\n\t\t\t\"pix_width_2:%d - pix_height_2:%d - refresh_rate_2:%lld - is_scaled_2:%d - \"\n\t\t\t\"pix_width_3:%d - pix_height_3:%d - refresh_rate_3:%lld - is_scaled_3:%d - LOG_END\\n\",\n\t\t\tdramclk_khz_override,\n\t\t\tfclk_khz_override,\n\t\t\tnew_clocks->dcfclk_khz,\n\t\t\tnew_clocks->dppclk_khz,\n\t\t\tdispclk_khz_reg,\n\t\t\tdppclk_khz_reg,\n\t\t\tdprefclk_khz_reg,\n\t\t\tdcfclk_khz_reg,\n\t\t\tdtbclk_khz_reg,\n\t\t\tfclk_khz_reg,\n\t\t\tpix_clk_list[0], pix_clk_list[1], pix_clk_list[3], pix_clk_list[2],\n\t\t\tmall_ss_size_bytes,\n\t\t\tp_state_list[0], p_state_list[1], p_state_list[2], p_state_list[3],\n\t\t\tdisp_src_width_list[0], disp_src_height_list[0], disp_src_refresh_list[0], is_scaled_list[0],\n\t\t\tdisp_src_width_list[1], disp_src_height_list[1], disp_src_refresh_list[1], is_scaled_list[1],\n\t\t\tdisp_src_width_list[2], disp_src_height_list[2], disp_src_refresh_list[2], is_scaled_list[2],\n\t\t\tdisp_src_width_list[3], disp_src_height_list[3], disp_src_refresh_list[3], is_scaled_list[3]);\n\t}\n}"
    },
    {
        "var_name": "new_clocks",
        "function_name": "dcn32_auto_dpm_test_log",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c",
            "region": {
                "startLine": 541,
                "startColumn": 10,
                "endColumn": 20
            },
            "context": {
                "startLine": 539,
                "endLine": 543,
                "snippet": {
                    "text": "if (!new_clocks->p_state_change_support) {"
                }
            }
        },
        "function_code": "static void dcn32_auto_dpm_test_log(\n\t\tstruct dc_clocks *new_clocks,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct dc_state *context)\n{\n\tunsigned int dispclk_khz_reg, dppclk_khz_reg, dprefclk_khz_reg, dcfclk_khz_reg, dtbclk_khz_reg,\n\t\t\t\t fclk_khz_reg, mall_ss_size_bytes;\n\tint dramclk_khz_override, fclk_khz_override, num_fclk_levels;\n\n\tstruct pipe_ctx *pipe_ctx_list[MAX_PIPES];\n\tint active_pipe_count = 0;\n\n\tfor (int i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream && dc_state_get_pipe_subvp_type(context, pipe_ctx) != SUBVP_PHANTOM) {\n\t\t\tpipe_ctx_list[active_pipe_count] = pipe_ctx;\n\t\t\tactive_pipe_count++;\n\t\t}\n\t}\n\n\tmsleep(5);\n\n\tmall_ss_size_bytes = context->bw_ctx.bw.dcn.mall_ss_size_bytes;\n\n    dispclk_khz_reg    = REG_READ(CLK1_CLK0_CURRENT_CNT); // DISPCLK\n    dppclk_khz_reg     = REG_READ(CLK1_CLK1_CURRENT_CNT); // DPPCLK\n    dprefclk_khz_reg   = REG_READ(CLK1_CLK2_CURRENT_CNT); // DPREFCLK\n    dcfclk_khz_reg     = REG_READ(CLK1_CLK3_CURRENT_CNT); // DCFCLK\n    dtbclk_khz_reg     = REG_READ(CLK1_CLK4_CURRENT_CNT); // DTBCLK\n    fclk_khz_reg       = REG_READ(CLK4_CLK0_CURRENT_CNT); // FCLK\n\n    // Overrides for these clocks in case there is no p_state change support\n    dramclk_khz_override = new_clocks->dramclk_khz;\n    fclk_khz_override = new_clocks->fclk_khz;\n\n    num_fclk_levels = clk_mgr->base.bw_params->clk_table.num_entries_per_clk.num_fclk_levels - 1;\n\n    if (!new_clocks->p_state_change_support) {\n\t    dramclk_khz_override = clk_mgr->base.bw_params->max_memclk_mhz * 1000;\n    }\n    if (!new_clocks->fclk_p_state_change_support) {\n\t    fclk_khz_override = clk_mgr->base.bw_params->clk_table.entries[num_fclk_levels].fclk_mhz * 1000;\n    }\n\n\t////////////////////////////////////////////////////////////////////////////\n\t//\tIMPORTANT: \tWhen adding more clocks to these logs, do NOT put a newline\n\t//\t \t\t\tanywhere other than at the very end of the string.\n\t//\n\t//\tFormatting example (make sure to have \" - \" between each entry):\n\t//\n\t//\t\t\t\tAutoDPMTest: clk1:%d - clk2:%d - clk3:%d - clk4:%d\\n\"\n\t////////////////////////////////////////////////////////////////////////////\n\tif (new_clocks && active_pipe_count > 0 &&\n\t\tnew_clocks->dramclk_khz > 0 &&\n\t\tnew_clocks->fclk_khz > 0 &&\n\t\tnew_clocks->dcfclk_khz > 0 &&\n\t\tnew_clocks->dppclk_khz > 0) {\n\n\t\tuint32_t pix_clk_list[MAX_PIPES] = {0};\n\t\tint p_state_list[MAX_PIPES] = {0};\n\t\tint disp_src_width_list[MAX_PIPES] = {0};\n\t\tint disp_src_height_list[MAX_PIPES] = {0};\n\t\tuint64_t disp_src_refresh_list[MAX_PIPES] = {0};\n\t\tbool is_scaled_list[MAX_PIPES] = {0};\n\n\t\tfor (int i = 0; i < active_pipe_count; i++) {\n\t\t\tstruct pipe_ctx *curr_pipe_ctx = pipe_ctx_list[i];\n\t\t\tuint64_t refresh_rate;\n\n\t\t\tpix_clk_list[i] = curr_pipe_ctx->stream->timing.pix_clk_100hz;\n\t\t\tp_state_list[i] = curr_pipe_ctx->p_state_type;\n\n\t\t\trefresh_rate = (curr_pipe_ctx->stream->timing.pix_clk_100hz * (uint64_t)100 +\n\t\t\t\tcurr_pipe_ctx->stream->timing.v_total * curr_pipe_ctx->stream->timing.h_total - (uint64_t)1);\n\t\t\trefresh_rate = div_u64(refresh_rate, curr_pipe_ctx->stream->timing.v_total);\n\t\t\trefresh_rate = div_u64(refresh_rate, curr_pipe_ctx->stream->timing.h_total);\n\t\t\tdisp_src_refresh_list[i] = refresh_rate;\n\n\t\t\tif (curr_pipe_ctx->plane_state) {\n\t\t\t\tis_scaled_list[i] = !(dcn32_check_native_scaling(curr_pipe_ctx));\n\t\t\t\tdisp_src_width_list[i] = curr_pipe_ctx->plane_state->src_rect.width;\n\t\t\t\tdisp_src_height_list[i] = curr_pipe_ctx->plane_state->src_rect.height;\n\t\t\t}\n\t\t}\n\n\t\tDC_LOG_AUTO_DPM_TEST(\"AutoDPMTest: dramclk:%d - fclk:%d - \"\n\t\t\t\"dcfclk:%d - dppclk:%d - dispclk_hw:%d - \"\n\t\t\t\"dppclk_hw:%d - dprefclk_hw:%d - dcfclk_hw:%d - \"\n\t\t\t\"dtbclk_hw:%d - fclk_hw:%d - pix_clk_0:%d - pix_clk_1:%d - \"\n\t\t\t\"pix_clk_2:%d - pix_clk_3:%d - mall_ss_size:%d - p_state_type_0:%d - \"\n\t\t\t\"p_state_type_1:%d - p_state_type_2:%d - p_state_type_3:%d - \"\n\t\t\t\"pix_width_0:%d - pix_height_0:%d - refresh_rate_0:%lld - is_scaled_0:%d - \"\n\t\t\t\"pix_width_1:%d - pix_height_1:%d - refresh_rate_1:%lld - is_scaled_1:%d - \"\n\t\t\t\"pix_width_2:%d - pix_height_2:%d - refresh_rate_2:%lld - is_scaled_2:%d - \"\n\t\t\t\"pix_width_3:%d - pix_height_3:%d - refresh_rate_3:%lld - is_scaled_3:%d - LOG_END\\n\",\n\t\t\tdramclk_khz_override,\n\t\t\tfclk_khz_override,\n\t\t\tnew_clocks->dcfclk_khz,\n\t\t\tnew_clocks->dppclk_khz,\n\t\t\tdispclk_khz_reg,\n\t\t\tdppclk_khz_reg,\n\t\t\tdprefclk_khz_reg,\n\t\t\tdcfclk_khz_reg,\n\t\t\tdtbclk_khz_reg,\n\t\t\tfclk_khz_reg,\n\t\t\tpix_clk_list[0], pix_clk_list[1], pix_clk_list[3], pix_clk_list[2],\n\t\t\tmall_ss_size_bytes,\n\t\t\tp_state_list[0], p_state_list[1], p_state_list[2], p_state_list[3],\n\t\t\tdisp_src_width_list[0], disp_src_height_list[0], disp_src_refresh_list[0], is_scaled_list[0],\n\t\t\tdisp_src_width_list[1], disp_src_height_list[1], disp_src_refresh_list[1], is_scaled_list[1],\n\t\t\tdisp_src_width_list[2], disp_src_height_list[2], disp_src_refresh_list[2], is_scaled_list[2],\n\t\t\tdisp_src_width_list[3], disp_src_height_list[3], disp_src_refresh_list[3], is_scaled_list[3]);\n\t}\n}"
    },
    {
        "var_name": "new_clocks",
        "function_name": "dcn32_auto_dpm_test_log",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/clk_mgr/dcn32/dcn32_clk_mgr.c",
            "region": {
                "startLine": 544,
                "startColumn": 10,
                "endColumn": 20
            },
            "context": {
                "startLine": 542,
                "endLine": 546,
                "snippet": {
                    "text": "if (!new_clocks->fclk_p_state_change_support) {"
                }
            }
        },
        "function_code": "static void dcn32_auto_dpm_test_log(\n\t\tstruct dc_clocks *new_clocks,\n\t\tstruct clk_mgr_internal *clk_mgr,\n\t\tstruct dc_state *context)\n{\n\tunsigned int dispclk_khz_reg, dppclk_khz_reg, dprefclk_khz_reg, dcfclk_khz_reg, dtbclk_khz_reg,\n\t\t\t\t fclk_khz_reg, mall_ss_size_bytes;\n\tint dramclk_khz_override, fclk_khz_override, num_fclk_levels;\n\n\tstruct pipe_ctx *pipe_ctx_list[MAX_PIPES];\n\tint active_pipe_count = 0;\n\n\tfor (int i = 0; i < MAX_PIPES; i++) {\n\t\tstruct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe_ctx->stream && dc_state_get_pipe_subvp_type(context, pipe_ctx) != SUBVP_PHANTOM) {\n\t\t\tpipe_ctx_list[active_pipe_count] = pipe_ctx;\n\t\t\tactive_pipe_count++;\n\t\t}\n\t}\n\n\tmsleep(5);\n\n\tmall_ss_size_bytes = context->bw_ctx.bw.dcn.mall_ss_size_bytes;\n\n    dispclk_khz_reg    = REG_READ(CLK1_CLK0_CURRENT_CNT); // DISPCLK\n    dppclk_khz_reg     = REG_READ(CLK1_CLK1_CURRENT_CNT); // DPPCLK\n    dprefclk_khz_reg   = REG_READ(CLK1_CLK2_CURRENT_CNT); // DPREFCLK\n    dcfclk_khz_reg     = REG_READ(CLK1_CLK3_CURRENT_CNT); // DCFCLK\n    dtbclk_khz_reg     = REG_READ(CLK1_CLK4_CURRENT_CNT); // DTBCLK\n    fclk_khz_reg       = REG_READ(CLK4_CLK0_CURRENT_CNT); // FCLK\n\n    // Overrides for these clocks in case there is no p_state change support\n    dramclk_khz_override = new_clocks->dramclk_khz;\n    fclk_khz_override = new_clocks->fclk_khz;\n\n    num_fclk_levels = clk_mgr->base.bw_params->clk_table.num_entries_per_clk.num_fclk_levels - 1;\n\n    if (!new_clocks->p_state_change_support) {\n\t    dramclk_khz_override = clk_mgr->base.bw_params->max_memclk_mhz * 1000;\n    }\n    if (!new_clocks->fclk_p_state_change_support) {\n\t    fclk_khz_override = clk_mgr->base.bw_params->clk_table.entries[num_fclk_levels].fclk_mhz * 1000;\n    }\n\n\t////////////////////////////////////////////////////////////////////////////\n\t//\tIMPORTANT: \tWhen adding more clocks to these logs, do NOT put a newline\n\t//\t \t\t\tanywhere other than at the very end of the string.\n\t//\n\t//\tFormatting example (make sure to have \" - \" between each entry):\n\t//\n\t//\t\t\t\tAutoDPMTest: clk1:%d - clk2:%d - clk3:%d - clk4:%d\\n\"\n\t////////////////////////////////////////////////////////////////////////////\n\tif (new_clocks && active_pipe_count > 0 &&\n\t\tnew_clocks->dramclk_khz > 0 &&\n\t\tnew_clocks->fclk_khz > 0 &&\n\t\tnew_clocks->dcfclk_khz > 0 &&\n\t\tnew_clocks->dppclk_khz > 0) {\n\n\t\tuint32_t pix_clk_list[MAX_PIPES] = {0};\n\t\tint p_state_list[MAX_PIPES] = {0};\n\t\tint disp_src_width_list[MAX_PIPES] = {0};\n\t\tint disp_src_height_list[MAX_PIPES] = {0};\n\t\tuint64_t disp_src_refresh_list[MAX_PIPES] = {0};\n\t\tbool is_scaled_list[MAX_PIPES] = {0};\n\n\t\tfor (int i = 0; i < active_pipe_count; i++) {\n\t\t\tstruct pipe_ctx *curr_pipe_ctx = pipe_ctx_list[i];\n\t\t\tuint64_t refresh_rate;\n\n\t\t\tpix_clk_list[i] = curr_pipe_ctx->stream->timing.pix_clk_100hz;\n\t\t\tp_state_list[i] = curr_pipe_ctx->p_state_type;\n\n\t\t\trefresh_rate = (curr_pipe_ctx->stream->timing.pix_clk_100hz * (uint64_t)100 +\n\t\t\t\tcurr_pipe_ctx->stream->timing.v_total * curr_pipe_ctx->stream->timing.h_total - (uint64_t)1);\n\t\t\trefresh_rate = div_u64(refresh_rate, curr_pipe_ctx->stream->timing.v_total);\n\t\t\trefresh_rate = div_u64(refresh_rate, curr_pipe_ctx->stream->timing.h_total);\n\t\t\tdisp_src_refresh_list[i] = refresh_rate;\n\n\t\t\tif (curr_pipe_ctx->plane_state) {\n\t\t\t\tis_scaled_list[i] = !(dcn32_check_native_scaling(curr_pipe_ctx));\n\t\t\t\tdisp_src_width_list[i] = curr_pipe_ctx->plane_state->src_rect.width;\n\t\t\t\tdisp_src_height_list[i] = curr_pipe_ctx->plane_state->src_rect.height;\n\t\t\t}\n\t\t}\n\n\t\tDC_LOG_AUTO_DPM_TEST(\"AutoDPMTest: dramclk:%d - fclk:%d - \"\n\t\t\t\"dcfclk:%d - dppclk:%d - dispclk_hw:%d - \"\n\t\t\t\"dppclk_hw:%d - dprefclk_hw:%d - dcfclk_hw:%d - \"\n\t\t\t\"dtbclk_hw:%d - fclk_hw:%d - pix_clk_0:%d - pix_clk_1:%d - \"\n\t\t\t\"pix_clk_2:%d - pix_clk_3:%d - mall_ss_size:%d - p_state_type_0:%d - \"\n\t\t\t\"p_state_type_1:%d - p_state_type_2:%d - p_state_type_3:%d - \"\n\t\t\t\"pix_width_0:%d - pix_height_0:%d - refresh_rate_0:%lld - is_scaled_0:%d - \"\n\t\t\t\"pix_width_1:%d - pix_height_1:%d - refresh_rate_1:%lld - is_scaled_1:%d - \"\n\t\t\t\"pix_width_2:%d - pix_height_2:%d - refresh_rate_2:%lld - is_scaled_2:%d - \"\n\t\t\t\"pix_width_3:%d - pix_height_3:%d - refresh_rate_3:%lld - is_scaled_3:%d - LOG_END\\n\",\n\t\t\tdramclk_khz_override,\n\t\t\tfclk_khz_override,\n\t\t\tnew_clocks->dcfclk_khz,\n\t\t\tnew_clocks->dppclk_khz,\n\t\t\tdispclk_khz_reg,\n\t\t\tdppclk_khz_reg,\n\t\t\tdprefclk_khz_reg,\n\t\t\tdcfclk_khz_reg,\n\t\t\tdtbclk_khz_reg,\n\t\t\tfclk_khz_reg,\n\t\t\tpix_clk_list[0], pix_clk_list[1], pix_clk_list[3], pix_clk_list[2],\n\t\t\tmall_ss_size_bytes,\n\t\t\tp_state_list[0], p_state_list[1], p_state_list[2], p_state_list[3],\n\t\t\tdisp_src_width_list[0], disp_src_height_list[0], disp_src_refresh_list[0], is_scaled_list[0],\n\t\t\tdisp_src_width_list[1], disp_src_height_list[1], disp_src_refresh_list[1], is_scaled_list[1],\n\t\t\tdisp_src_width_list[2], disp_src_height_list[2], disp_src_refresh_list[2], is_scaled_list[2],\n\t\t\tdisp_src_width_list[3], disp_src_height_list[3], disp_src_refresh_list[3], is_scaled_list[3]);\n\t}\n}"
    },
    {
        "var_name": "hubp",
        "function_name": "hubp1_is_flip_pending",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hubp.c",
            "region": {
                "startLine": 752,
                "startColumn": 52,
                "endColumn": 56
            },
            "context": {
                "startLine": 750,
                "endLine": 754,
                "snippet": {
                    "text": "if (earliest_inuse_address.grph.addr.quad_part != hubp->request_address.grph.addr.quad_part)"
                }
            }
        },
        "function_code": "bool hubp1_is_flip_pending(struct hubp *hubp)\n{\n\tuint32_t flip_pending = 0;\n\tstruct dcn10_hubp *hubp1 = TO_DCN10_HUBP(hubp);\n\tstruct dc_plane_address earliest_inuse_address;\n\n\tif (hubp && hubp->power_gated)\n\t\treturn false;\n\n\tREG_GET(DCSURF_FLIP_CONTROL,\n\t\t\tSURFACE_FLIP_PENDING, &flip_pending);\n\n\tREG_GET(DCSURF_SURFACE_EARLIEST_INUSE,\n\t\t\tSURFACE_EARLIEST_INUSE_ADDRESS, &earliest_inuse_address.grph.addr.low_part);\n\n\tREG_GET(DCSURF_SURFACE_EARLIEST_INUSE_HIGH,\n\t\t\tSURFACE_EARLIEST_INUSE_ADDRESS_HIGH, &earliest_inuse_address.grph.addr.high_part);\n\n\tif (flip_pending)\n\t\treturn true;\n\n\tif (earliest_inuse_address.grph.addr.quad_part != hubp->request_address.grph.addr.quad_part)\n\t\treturn true;\n\n\treturn false;\n}"
    },
    {
        "var_name": "hubp",
        "function_name": "hubp2_is_flip_pending",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hubp.c",
            "region": {
                "startLine": 930,
                "startColumn": 52,
                "endColumn": 56
            },
            "context": {
                "startLine": 928,
                "endLine": 932,
                "snippet": {
                    "text": "if (earliest_inuse_address.grph.addr.quad_part != hubp->request_address.grph.addr.quad_part)"
                }
            }
        },
        "function_code": "bool hubp2_is_flip_pending(struct hubp *hubp)\n{\n\tuint32_t flip_pending = 0;\n\tstruct dcn20_hubp *hubp2 = TO_DCN20_HUBP(hubp);\n\tstruct dc_plane_address earliest_inuse_address;\n\n\tif (hubp && hubp->power_gated)\n\t\treturn false;\n\n\tREG_GET(DCSURF_FLIP_CONTROL,\n\t\t\tSURFACE_FLIP_PENDING, &flip_pending);\n\n\tREG_GET(DCSURF_SURFACE_EARLIEST_INUSE,\n\t\t\tSURFACE_EARLIEST_INUSE_ADDRESS, &earliest_inuse_address.grph.addr.low_part);\n\n\tREG_GET(DCSURF_SURFACE_EARLIEST_INUSE_HIGH,\n\t\t\tSURFACE_EARLIEST_INUSE_ADDRESS_HIGH, &earliest_inuse_address.grph.addr.high_part);\n\n\tif (flip_pending)\n\t\treturn true;\n\n\tif (earliest_inuse_address.grph.addr.quad_part != hubp->request_address.grph.addr.quad_part)\n\t\treturn true;\n\n\treturn false;\n}"
    },
    {
        "var_name": "drr_timing",
        "function_name": "subvp_drr_schedulable",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/dml/dcn32/dcn32_fpu.c",
            "region": {
                "startLine": 871,
                "startColumn": 38,
                "endColumn": 48
            },
            "context": {
                "startLine": 869,
                "endLine": 873,
                "snippet": {
                    "text": "if (stretched_drr_us < (1 / (double)drr_timing->min_refresh_in_uhz) * 1000000 * 1000000 &&"
                }
            }
        },
        "function_code": "static bool subvp_drr_schedulable(struct dc *dc, struct dc_state *context)\n{\n\tbool schedulable = false;\n\tuint32_t i;\n\tstruct pipe_ctx *pipe = NULL;\n\tstruct pipe_ctx *drr_pipe = NULL;\n\tstruct dc_crtc_timing *main_timing = NULL;\n\tstruct dc_crtc_timing *phantom_timing = NULL;\n\tstruct dc_crtc_timing *drr_timing = NULL;\n\tint16_t prefetch_us = 0;\n\tint16_t mall_region_us = 0;\n\tint16_t drr_frame_us = 0;\t// nominal frame time\n\tint16_t subvp_active_us = 0;\n\tint16_t stretched_drr_us = 0;\n\tint16_t drr_stretched_vblank_us = 0;\n\tint16_t max_vblank_mallregion = 0;\n\tstruct dc_stream_state *phantom_stream;\n\tbool subvp_found = false;\n\tbool drr_found = false;\n\n\t// Find SubVP pipe\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tpipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t// We check for master pipe, but it shouldn't matter since we only need\n\t\t// the pipe for timing info (stream should be same for any pipe splits)\n\t\tif (!resource_is_pipe_type(pipe, OTG_MASTER) ||\n\t\t\t\t!resource_is_pipe_type(pipe, DPP_PIPE))\n\t\t\tcontinue;\n\n\t\t// Find the SubVP pipe\n\t\tif (dc_state_get_pipe_subvp_type(context, pipe) == SUBVP_MAIN) {\n\t\t\tsubvp_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Find the DRR pipe\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tdrr_pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\t// We check for master pipe only\n\t\tif (!resource_is_pipe_type(drr_pipe, OTG_MASTER) ||\n\t\t\t\t!resource_is_pipe_type(drr_pipe, DPP_PIPE))\n\t\t\tcontinue;\n\n\t\tif (dc_state_get_pipe_subvp_type(context, drr_pipe) == SUBVP_NONE && drr_pipe->stream->ignore_msa_timing_param &&\n\t\t\t\t(drr_pipe->stream->allow_freesync || drr_pipe->stream->vrr_active_variable || drr_pipe->stream->vrr_active_fixed)) {\n\t\t\tdrr_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (subvp_found && drr_found) {\n\t\tphantom_stream = dc_state_get_paired_subvp_stream(context, pipe->stream);\n\t\tmain_timing = &pipe->stream->timing;\n\t\tphantom_timing = &phantom_stream->timing;\n\t\tdrr_timing = &drr_pipe->stream->timing;\n\t\tprefetch_us = (phantom_timing->v_total - phantom_timing->v_front_porch) * phantom_timing->h_total /\n\t\t\t\t(double)(phantom_timing->pix_clk_100hz * 100) * 1000000 +\n\t\t\t\tdc->caps.subvp_prefetch_end_to_mall_start_us;\n\t\tsubvp_active_us = main_timing->v_addressable * main_timing->h_total /\n\t\t\t\t(double)(main_timing->pix_clk_100hz * 100) * 1000000;\n\t\tdrr_frame_us = drr_timing->v_total * drr_timing->h_total /\n\t\t\t\t(double)(drr_timing->pix_clk_100hz * 100) * 1000000;\n\t\t// P-State allow width and FW delays already included phantom_timing->v_addressable\n\t\tmall_region_us = phantom_timing->v_addressable * phantom_timing->h_total /\n\t\t\t\t(double)(phantom_timing->pix_clk_100hz * 100) * 1000000;\n\t\tstretched_drr_us = drr_frame_us + mall_region_us + SUBVP_DRR_MARGIN_US;\n\t\tdrr_stretched_vblank_us = (drr_timing->v_total - drr_timing->v_addressable) * drr_timing->h_total /\n\t\t\t\t(double)(drr_timing->pix_clk_100hz * 100) * 1000000 + (stretched_drr_us - drr_frame_us);\n\t\tmax_vblank_mallregion = drr_stretched_vblank_us > mall_region_us ? drr_stretched_vblank_us : mall_region_us;\n\t}\n\n\t/* We consider SubVP + DRR schedulable if the stretched frame duration of the DRR display (i.e. the\n\t * highest refresh rate + margin that can support UCLK P-State switch) passes the static analysis\n\t * for VBLANK: (VACTIVE region of the SubVP pipe can fit the MALL prefetch, VBLANK frame time,\n\t * and the max of (VBLANK blanking time, MALL region)).\n\t */\n\tif (stretched_drr_us < (1 / (double)drr_timing->min_refresh_in_uhz) * 1000000 * 1000000 &&\n\t\t\tsubvp_active_us - prefetch_us - stretched_drr_us - max_vblank_mallregion > 0)\n\t\tschedulable = true;\n\n\treturn schedulable;\n}"
    },
    {
        "var_name": "context",
        "function_name": "dml2_validate_and_build_resource",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c",
            "region": {
                "startLine": 568,
                "startColumn": 30,
                "endColumn": 37
            },
            "context": {
                "startLine": 566,
                "endLine": 570,
                "snippet": {
                    "text": "struct dml2_context *dml2 = context->bw_ctx.dml2;"
                }
            }
        },
        "function_code": "static bool dml2_validate_and_build_resource(const struct dc *in_dc, struct dc_state *context)\n{\n\tstruct dml2_context *dml2 = context->bw_ctx.dml2;\n\tstruct dml2_wrapper_scratch *s = &dml2->v20.scratch;\n\tstruct dml2_dcn_clocks out_clks;\n\tunsigned int result = 0;\n\tbool need_recalculation = false;\n\n\tif (!context || context->stream_count == 0)\n\t\treturn true;\n\n\t/* Zero out before each call before proceeding */\n\tmemset(&dml2->v20.scratch, 0, sizeof(struct dml2_wrapper_scratch));\n\tmemset(&dml2->v20.dml_core_ctx.policy, 0, sizeof(struct dml_mode_eval_policy_st));\n\tmemset(&dml2->v20.dml_core_ctx.ms, 0, sizeof(struct mode_support_st));\n\tmemset(&dml2->v20.dml_core_ctx.mp, 0, sizeof(struct mode_program_st));\n\n\t/* Initialize DET scratch */\n\tdml2_initialize_det_scratch(dml2);\n\n\tcopy_dummy_pstate_table(s->dummy_pstate_table, in_dc->clk_mgr->bw_params->dummy_pstate_table, 4);\n\n\tresult = call_dml_mode_support_and_programming(context);\n\t/* Call map dc pipes to map the pipes based on the DML output. For correctly determining if recalculation\n\t * is required or not, the resource context needs to correctly reflect the number of active pipes. We would\n\t * only know the correct number if active pipes after dml2_map_dc_pipes is called.\n\t */\n\tif (result && !dml2->config.skip_hw_state_mapping)\n\t\tdml2_map_dc_pipes(dml2, context, &s->cur_display_config, &s->dml_to_dc_pipe_mapping, in_dc->current_state);\n\n\t/* Verify and update DET Buffer configuration if needed. dml2_verify_det_buffer_configuration will check if DET Buffer\n\t * size needs to be updated. If yes it will update the DETOverride variable and set need_recalculation flag to true.\n\t * Based on that flag, run mode support again. Verification needs to be run after dml_mode_programming because the getters\n\t * return correct det buffer values only after dml_mode_programming is called.\n\t */\n\tif (result && !dml2->config.skip_hw_state_mapping) {\n\t\tneed_recalculation = dml2_verify_det_buffer_configuration(dml2, context, &dml2->det_helper_scratch);\n\t\tif (need_recalculation) {\n\t\t\t/* Engage the DML again if recalculation is required. */\n\t\t\tcall_dml_mode_support_and_programming(context);\n\t\t\tif (!dml2->config.skip_hw_state_mapping) {\n\t\t\t\tdml2_map_dc_pipes(dml2, context, &s->cur_display_config, &s->dml_to_dc_pipe_mapping, in_dc->current_state);\n\t\t\t}\n\t\t\tneed_recalculation = dml2_verify_det_buffer_configuration(dml2, context, &dml2->det_helper_scratch);\n\t\t\tASSERT(need_recalculation == false);\n\t\t}\n\t}\n\n\tif (result) {\n\t\tunsigned int lowest_state_idx = s->mode_support_params.out_lowest_state_idx;\n\t\tout_clks.dispclk_khz = (unsigned int)dml2->v20.dml_core_ctx.mp.Dispclk_calculated * 1000;\n\t\tout_clks.p_state_supported = s->mode_support_info.DRAMClockChangeSupport[0] != dml_dram_clock_change_unsupported;\n\t\tif (in_dc->config.use_default_clock_table &&\n\t\t\t(lowest_state_idx < dml2->v20.dml_core_ctx.states.num_states - 1)) {\n\t\t\tlowest_state_idx = dml2->v20.dml_core_ctx.states.num_states - 1;\n\t\t\tout_clks.dispclk_khz = (unsigned int)dml2->v20.dml_core_ctx.states.state_array[lowest_state_idx].dispclk_mhz * 1000;\n\t\t}\n\n\t\tout_clks.dcfclk_khz = (unsigned int)dml2->v20.dml_core_ctx.states.state_array[lowest_state_idx].dcfclk_mhz * 1000;\n\t\tout_clks.fclk_khz = (unsigned int)dml2->v20.dml_core_ctx.states.state_array[lowest_state_idx].fabricclk_mhz * 1000;\n\t\tout_clks.uclk_mts = (unsigned int)dml2->v20.dml_core_ctx.states.state_array[lowest_state_idx].dram_speed_mts;\n\t\tout_clks.phyclk_khz = (unsigned int)dml2->v20.dml_core_ctx.states.state_array[lowest_state_idx].phyclk_mhz * 1000;\n\t\tout_clks.socclk_khz = (unsigned int)dml2->v20.dml_core_ctx.states.state_array[lowest_state_idx].socclk_mhz * 1000;\n\t\tout_clks.ref_dtbclk_khz = (unsigned int)dml2->v20.dml_core_ctx.states.state_array[lowest_state_idx].dtbclk_mhz * 1000;\n\t\tcontext->bw_ctx.bw.dcn.clk.dtbclk_en = is_dtbclk_required(in_dc, context);\n\n\t\tif (!dml2->config.skip_hw_state_mapping) {\n\t\t\t/* Call dml2_calculate_rq_and_dlg_params */\n\t\t\tdml2_calculate_rq_and_dlg_params(in_dc, context, &context->res_ctx, dml2, in_dc->res_pool->pipe_count);\n\t\t}\n\n\t\tdml2_copy_clocks_to_dc_state(&out_clks, context);\n\t\tdml2_extract_watermark_set(&context->bw_ctx.bw.dcn.watermarks.a, &dml2->v20.dml_core_ctx);\n\t\tdml2_extract_watermark_set(&context->bw_ctx.bw.dcn.watermarks.b, &dml2->v20.dml_core_ctx);\n\t\tmemcpy(&context->bw_ctx.bw.dcn.watermarks.c, &dml2->v20.g6_temp_read_watermark_set, sizeof(context->bw_ctx.bw.dcn.watermarks.c));\n\t\tdml2_extract_watermark_set(&context->bw_ctx.bw.dcn.watermarks.d, &dml2->v20.dml_core_ctx);\n\t\t//copy for deciding zstate use\n\t\tcontext->bw_ctx.dml.vba.StutterPeriod = context->bw_ctx.dml2->v20.dml_core_ctx.mp.StutterPeriod;\n\t}\n\n\treturn result;\n}"
    },
    {
        "var_name": "context",
        "function_name": "dml2_validate_only",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/dml2/dml2_wrapper.c",
            "region": {
                "startLine": 651,
                "startColumn": 30,
                "endColumn": 37
            },
            "context": {
                "startLine": 649,
                "endLine": 653,
                "snippet": {
                    "text": "struct dml2_context *dml2 = context->bw_ctx.dml2;"
                }
            }
        },
        "function_code": "static bool dml2_validate_only(struct dc_state *context)\n{\n\tstruct dml2_context *dml2 = context->bw_ctx.dml2;\n\tunsigned int result = 0;\n\n\tif (!context || context->stream_count == 0)\n\t\treturn true;\n\n\t/* Zero out before each call before proceeding */\n\tmemset(&dml2->v20.scratch, 0, sizeof(struct dml2_wrapper_scratch));\n\tmemset(&dml2->v20.dml_core_ctx.policy, 0, sizeof(struct dml_mode_eval_policy_st));\n\tmemset(&dml2->v20.dml_core_ctx.ms, 0, sizeof(struct mode_support_st));\n\tmemset(&dml2->v20.dml_core_ctx.mp, 0, sizeof(struct mode_program_st));\n\n\tbuild_unoptimized_policy_settings(dml2->v20.dml_core_ctx.project, &dml2->v20.dml_core_ctx.policy);\n\n\tmap_dc_state_into_dml_display_cfg(dml2, context, &dml2->v20.scratch.cur_display_config);\n\n\tresult = pack_and_call_dml_mode_support_ex(dml2,\n\t\t&dml2->v20.scratch.cur_display_config,\n\t\t&dml2->v20.scratch.mode_support_info);\n\n\tif (result)\n\t\tresult = does_configuration_meet_sw_policies(dml2, &dml2->v20.scratch.cur_display_config, &dml2->v20.scratch.mode_support_info);\n\n\treturn (result == 1) ? true : false;\n}"
    },
    {
        "var_name": "link",
        "function_name": "dce110_edp_wait_for_hpd_ready",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c",
            "region": {
                "startLine": 716,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 714,
                "endLine": 718,
                "snippet": {
                    "text": "struct dc_context *ctx = link->ctx;"
                }
            }
        },
        "function_code": "void dce110_edp_wait_for_hpd_ready(\n\t\tstruct dc_link *link,\n\t\tbool power_up)\n{\n\tstruct dc_context *ctx = link->ctx;\n\tstruct graphics_object_id connector = link->link_enc->connector;\n\tstruct gpio *hpd;\n\tbool edp_hpd_high = false;\n\tuint32_t time_elapsed = 0;\n\tuint32_t timeout = power_up ?\n\t\tPANEL_POWER_UP_TIMEOUT : PANEL_POWER_DOWN_TIMEOUT;\n\n\tif (dal_graphics_object_id_get_connector_id(connector)\n\t\t\t!= CONNECTOR_ID_EDP) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (!power_up)\n\t\t/*\n\t\t * From KV, we will not HPD low after turning off VCC -\n\t\t * instead, we will check the SW timer in power_up().\n\t\t */\n\t\treturn;\n\n\t/*\n\t * When we power on/off the eDP panel,\n\t * we need to wait until SENSE bit is high/low.\n\t */\n\n\t/* obtain HPD */\n\t/* TODO what to do with this? */\n\thpd = ctx->dc->link_srv->get_hpd_gpio(ctx->dc_bios, connector, ctx->gpio_service);\n\n\tif (!hpd) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (link != NULL) {\n\t\tif (link->panel_config.pps.extra_t3_ms > 0) {\n\t\t\tint extra_t3_in_ms = link->panel_config.pps.extra_t3_ms;\n\n\t\t\tmsleep(extra_t3_in_ms);\n\t\t}\n\t}\n\n\tdal_gpio_open(hpd, GPIO_MODE_INTERRUPT);\n\n\t/* wait until timeout or panel detected */\n\n\tdo {\n\t\tuint32_t detected = 0;\n\n\t\tdal_gpio_get_value(hpd, &detected);\n\n\t\tif (!(detected ^ power_up)) {\n\t\t\tedp_hpd_high = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(HPD_CHECK_INTERVAL);\n\n\t\ttime_elapsed += HPD_CHECK_INTERVAL;\n\t} while (time_elapsed < timeout);\n\n\tdal_gpio_close(hpd);\n\n\tdal_gpio_destroy_irq(&hpd);\n\n\t/* ensure that the panel is detected */\n\tif (!edp_hpd_high)\n\t\tDC_LOG_DC(\"%s: wait timed out!\\n\", __func__);\n}"
    },
    {
        "var_name": "link",
        "function_name": "dce110_edp_wait_for_hpd_ready",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c",
            "region": {
                "startLine": 717,
                "startColumn": 40,
                "endColumn": 44
            },
            "context": {
                "startLine": 715,
                "endLine": 719,
                "snippet": {
                    "text": "struct graphics_object_id connector = link->link_enc->connector;"
                }
            }
        },
        "function_code": "void dce110_edp_wait_for_hpd_ready(\n\t\tstruct dc_link *link,\n\t\tbool power_up)\n{\n\tstruct dc_context *ctx = link->ctx;\n\tstruct graphics_object_id connector = link->link_enc->connector;\n\tstruct gpio *hpd;\n\tbool edp_hpd_high = false;\n\tuint32_t time_elapsed = 0;\n\tuint32_t timeout = power_up ?\n\t\tPANEL_POWER_UP_TIMEOUT : PANEL_POWER_DOWN_TIMEOUT;\n\n\tif (dal_graphics_object_id_get_connector_id(connector)\n\t\t\t!= CONNECTOR_ID_EDP) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (!power_up)\n\t\t/*\n\t\t * From KV, we will not HPD low after turning off VCC -\n\t\t * instead, we will check the SW timer in power_up().\n\t\t */\n\t\treturn;\n\n\t/*\n\t * When we power on/off the eDP panel,\n\t * we need to wait until SENSE bit is high/low.\n\t */\n\n\t/* obtain HPD */\n\t/* TODO what to do with this? */\n\thpd = ctx->dc->link_srv->get_hpd_gpio(ctx->dc_bios, connector, ctx->gpio_service);\n\n\tif (!hpd) {\n\t\tBREAK_TO_DEBUGGER();\n\t\treturn;\n\t}\n\n\tif (link != NULL) {\n\t\tif (link->panel_config.pps.extra_t3_ms > 0) {\n\t\t\tint extra_t3_in_ms = link->panel_config.pps.extra_t3_ms;\n\n\t\t\tmsleep(extra_t3_in_ms);\n\t\t}\n\t}\n\n\tdal_gpio_open(hpd, GPIO_MODE_INTERRUPT);\n\n\t/* wait until timeout or panel detected */\n\n\tdo {\n\t\tuint32_t detected = 0;\n\n\t\tdal_gpio_get_value(hpd, &detected);\n\n\t\tif (!(detected ^ power_up)) {\n\t\t\tedp_hpd_high = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(HPD_CHECK_INTERVAL);\n\n\t\ttime_elapsed += HPD_CHECK_INTERVAL;\n\t} while (time_elapsed < timeout);\n\n\tdal_gpio_close(hpd);\n\n\tdal_gpio_destroy_irq(&hpd);\n\n\t/* ensure that the panel is detected */\n\tif (!edp_hpd_high)\n\t\tDC_LOG_DC(\"%s: wait timed out!\\n\", __func__);\n}"
    },
    {
        "var_name": "dccg",
        "function_name": "dce110_disable_stream",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/hwss/dce110/dce110_hwseq.c",
            "region": {
                "startLine": 1187,
                "startColumn": 4,
                "endColumn": 8
            },
            "context": {
                "startLine": 1185,
                "endLine": 1189,
                "snippet": {
                    "text": "dccg->funcs->set_dpstreamclk(dccg, REFCLK, tg->inst, dp_hpo_inst);"
                }
            }
        },
        "function_code": "void dce110_disable_stream(struct pipe_ctx *pipe_ctx)\n{\n\tstruct dc_stream_state *stream = pipe_ctx->stream;\n\tstruct dc_link *link = stream->link;\n\tstruct dc *dc = pipe_ctx->stream->ctx->dc;\n\tconst struct link_hwss *link_hwss = get_link_hwss(link, &pipe_ctx->link_res);\n\tstruct dccg *dccg = dc->res_pool->dccg;\n\tstruct timing_generator *tg = pipe_ctx->stream_res.tg;\n\tstruct dtbclk_dto_params dto_params = {0};\n\tint dp_hpo_inst;\n\tstruct link_encoder *link_enc = link_enc_cfg_get_link_enc(pipe_ctx->stream->link);\n\tstruct stream_encoder *stream_enc = pipe_ctx->stream_res.stream_enc;\n\n\tif (dc_is_hdmi_tmds_signal(pipe_ctx->stream->signal)) {\n\t\tpipe_ctx->stream_res.stream_enc->funcs->stop_hdmi_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc);\n\t\tpipe_ctx->stream_res.stream_enc->funcs->hdmi_reset_stream_attribute(\n\t\t\tpipe_ctx->stream_res.stream_enc);\n\t}\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\tpipe_ctx->stream_res.hpo_dp_stream_enc->funcs->stop_dp_info_packets(\n\t\t\t\t\tpipe_ctx->stream_res.hpo_dp_stream_enc);\n\t} else if (dc_is_dp_signal(pipe_ctx->stream->signal))\n\t\tpipe_ctx->stream_res.stream_enc->funcs->stop_dp_info_packets(\n\t\t\tpipe_ctx->stream_res.stream_enc);\n\n\tdc->hwss.disable_audio_stream(pipe_ctx);\n\n\tlink_hwss->reset_stream_encoder(pipe_ctx);\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(pipe_ctx) && dccg) {\n\t\tdto_params.otg_inst = tg->inst;\n\t\tdto_params.timing = &pipe_ctx->stream->timing;\n\t\tdp_hpo_inst = pipe_ctx->stream_res.hpo_dp_stream_enc->inst;\n\t\tif (dccg) {\n\t\t\tdccg->funcs->disable_symclk32_se(dccg, dp_hpo_inst);\n\t\t\tdccg->funcs->set_dpstreamclk(dccg, REFCLK, tg->inst, dp_hpo_inst);\n\t\t\tif (dccg && dccg->funcs->set_dtbclk_dto)\n\t\t\t\tdccg->funcs->set_dtbclk_dto(dccg, &dto_params);\n\t\t}\n\t} else if (dccg && dccg->funcs->disable_symclk_se) {\n\t\tdccg->funcs->disable_symclk_se(dccg, stream_enc->stream_enc_inst,\n\t\t\t\t\t       link_enc->transmitter - TRANSMITTER_UNIPHY_A);\n\t}\n\n\tif (dc->link_srv->dp_is_128b_132b_signal(pipe_ctx)) {\n\t\t/* TODO: This looks like a bug to me as we are disabling HPO IO when\n\t\t * we are just disabling a single HPO stream. Shouldn't we disable HPO\n\t\t * HW control only when HPOs for all streams are disabled?\n\t\t */\n\t\tif (pipe_ctx->stream->ctx->dc->hwseq->funcs.setup_hpo_hw_control)\n\t\t\tpipe_ctx->stream->ctx->dc->hwseq->funcs.setup_hpo_hw_control(\n\t\t\t\t\tpipe_ctx->stream->ctx->dc->hwseq, false);\n\t}\n}"
    },
    {
        "var_name": "hwseq",
        "function_name": "dcn20_post_unlock_program_front_end",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/dc/hwss/dcn20/dcn20_hwseq.c",
            "region": {
                "startLine": 2221,
                "startColumn": 6,
                "endColumn": 11
            },
            "context": {
                "startLine": 2219,
                "endLine": 2223,
                "snippet": {
                    "text": "if (hwseq->funcs.program_mall_pipe_config)"
                }
            }
        },
        "function_code": "void dcn20_post_unlock_program_front_end(\n\t\tstruct dc *dc,\n\t\tstruct dc_state *context)\n{\n\tint i;\n\tconst unsigned int TIMEOUT_FOR_PIPE_ENABLE_US = 100000;\n\tunsigned int polling_interval_us = 1;\n\tstruct dce_hwseq *hwseq = dc->hwseq;\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++)\n\t\tif (context->res_ctx.pipe_ctx[i].update_flags.bits.disable)\n\t\t\tdc->hwss.disable_plane(dc, dc->current_state, &dc->current_state->res_ctx.pipe_ctx[i]);\n\n\t/*\n\t * If we are enabling a pipe, we need to wait for pending clear as this is a critical\n\t * part of the enable operation otherwise, DM may request an immediate flip which\n\t * will cause HW to perform an \"immediate enable\" (as opposed to \"vsync enable\") which\n\t * is unsupported on DCN.\n\t */\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\t\t// Don't check flip pending on phantom pipes\n\t\tif (pipe->plane_state && !pipe->top_pipe && pipe->update_flags.bits.enable &&\n\t\t\t\tdc_state_get_pipe_subvp_type(context, pipe) != SUBVP_PHANTOM) {\n\t\t\tstruct hubp *hubp = pipe->plane_res.hubp;\n\t\t\tint j = 0;\n\t\t\tfor (j = 0; j < TIMEOUT_FOR_PIPE_ENABLE_US / polling_interval_us\n\t\t\t\t\t&& hubp->funcs->hubp_is_flip_pending(hubp); j++)\n\t\t\t\tudelay(polling_interval_us);\n\t\t}\n\t}\n\n\tif (dc->res_pool->hubbub->funcs->force_pstate_change_control)\n\t\tdc->res_pool->hubbub->funcs->force_pstate_change_control(\n\t\t\t\tdc->res_pool->hubbub, false, false);\n\n\tfor (i = 0; i < dc->res_pool->pipe_count; i++) {\n\t\tstruct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];\n\n\t\tif (pipe->plane_state && !pipe->top_pipe) {\n\t\t\t/* Program phantom pipe here to prevent a frame of underflow in the MPO transition\n\t\t\t * case (if a pipe being used for a video plane transitions to a phantom pipe, it\n\t\t\t * can underflow due to HUBP_VTG_SEL programming if done in the regular front end\n\t\t\t * programming sequence).\n\t\t\t */\n\t\t\twhile (pipe) {\n\t\t\t\tif (pipe->stream && dc_state_get_pipe_subvp_type(context, pipe) == SUBVP_PHANTOM) {\n\t\t\t\t\t/* When turning on the phantom pipe we want to run through the\n\t\t\t\t\t * entire enable sequence, so apply all the \"enable\" flags.\n\t\t\t\t\t */\n\t\t\t\t\tif (dc->hwss.apply_update_flags_for_phantom)\n\t\t\t\t\t\tdc->hwss.apply_update_flags_for_phantom(pipe);\n\t\t\t\t\tif (dc->hwss.update_phantom_vp_position)\n\t\t\t\t\t\tdc->hwss.update_phantom_vp_position(dc, context, pipe);\n\t\t\t\t\tdcn20_program_pipe(dc, pipe, context);\n\t\t\t\t}\n\t\t\t\tpipe = pipe->bottom_pipe;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* P-State support transitions:\n\t * Natural -> FPO: \t\tP-State disabled in prepare, force disallow anytime is safe\n\t * FPO -> Natural: \t\tUnforce anytime after FW disable is safe (P-State will assert naturally)\n\t * Unsupported -> FPO:\tP-State enabled in optimize, force disallow anytime is safe\n\t * FPO -> Unsupported:\tP-State disabled in prepare, unforce disallow anytime is safe\n\t * FPO <-> SubVP:\t\tForce disallow is maintained on the FPO / SubVP pipes\n\t */\n\tif (hwseq && hwseq->funcs.update_force_pstate)\n\t\tdc->hwseq->funcs.update_force_pstate(dc, context);\n\n\t/* Only program the MALL registers after all the main and phantom pipes\n\t * are done programming.\n\t */\n\tif (hwseq->funcs.program_mall_pipe_config)\n\t\thwseq->funcs.program_mall_pipe_config(dc, context);\n\n\t/* WA to apply WM setting*/\n\tif (hwseq->wa.DEGVIDCN21)\n\t\tdc->res_pool->hubbub->funcs->apply_DEDCN21_147_wa(dc->res_pool->hubbub);\n\n\n\t/* WA for stutter underflow during MPO transitions when adding 2nd plane */\n\tif (hwseq->wa.disallow_self_refresh_during_multi_plane_transition) {\n\n\t\tif (dc->current_state->stream_status[0].plane_count == 1 &&\n\t\t\t\tcontext->stream_status[0].plane_count > 1) {\n\n\t\t\tstruct timing_generator *tg = dc->res_pool->timing_generators[0];\n\n\t\t\tdc->res_pool->hubbub->funcs->allow_self_refresh_control(dc->res_pool->hubbub, false);\n\n\t\t\thwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied = true;\n\t\t\thwseq->wa_state.disallow_self_refresh_during_multi_plane_transition_applied_on_frame = tg->funcs->get_frame_count(tg);\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "dte_data",
        "function_name": "si_initialize_smc_dte_tables",
        "location": {
            "file_path": "drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c",
            "region": {
                "startLine": 2576,
                "startColumn": 6,
                "endColumn": 14
            },
            "context": {
                "startLine": 2574,
                "endLine": 2578,
                "snippet": {
                    "text": "if (dte_data->k <= 0)"
                }
            }
        },
        "function_code": "static int si_initialize_smc_dte_tables(struct amdgpu_device *adev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(adev);\n\tint ret = 0;\n\tstruct si_dte_data *dte_data = &si_pi->dte_data;\n\tSmc_SIslands_DTE_Configuration *dte_tables = NULL;\n\tu32 table_size;\n\tu8 tdep_count;\n\tu32 i;\n\n\tif (dte_data == NULL)\n\t\tsi_pi->enable_dte = false;\n\n\tif (si_pi->enable_dte == false)\n\t\treturn 0;\n\n\tif (dte_data->k <= 0)\n\t\treturn -EINVAL;\n\n\tdte_tables = kzalloc(sizeof(Smc_SIslands_DTE_Configuration), GFP_KERNEL);\n\tif (dte_tables == NULL) {\n\t\tsi_pi->enable_dte = false;\n\t\treturn -ENOMEM;\n\t}\n\n\ttable_size = dte_data->k;\n\n\tif (table_size > SMC_SISLANDS_DTE_MAX_FILTER_STAGES)\n\t\ttable_size = SMC_SISLANDS_DTE_MAX_FILTER_STAGES;\n\n\ttdep_count = dte_data->tdep_count;\n\tif (tdep_count > SMC_SISLANDS_DTE_MAX_TEMPERATURE_DEPENDENT_ARRAY_SIZE)\n\t\ttdep_count = SMC_SISLANDS_DTE_MAX_TEMPERATURE_DEPENDENT_ARRAY_SIZE;\n\n\tdte_tables->K = cpu_to_be32(table_size);\n\tdte_tables->T0 = cpu_to_be32(dte_data->t0);\n\tdte_tables->MaxT = cpu_to_be32(dte_data->max_t);\n\tdte_tables->WindowSize = dte_data->window_size;\n\tdte_tables->temp_select = dte_data->temp_select;\n\tdte_tables->DTE_mode = dte_data->dte_mode;\n\tdte_tables->Tthreshold = cpu_to_be32(dte_data->t_threshold);\n\n\tif (tdep_count > 0)\n\t\ttable_size--;\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tdte_tables->tau[i] = cpu_to_be32(dte_data->tau[i]);\n\t\tdte_tables->R[i]   = cpu_to_be32(dte_data->r[i]);\n\t}\n\n\tdte_tables->Tdep_count = tdep_count;\n\n\tfor (i = 0; i < (u32)tdep_count; i++) {\n\t\tdte_tables->T_limits[i] = dte_data->t_limits[i];\n\t\tdte_tables->Tdep_tau[i] = cpu_to_be32(dte_data->tdep_tau[i]);\n\t\tdte_tables->Tdep_R[i] = cpu_to_be32(dte_data->tdep_r[i]);\n\t}\n\n\tret = amdgpu_si_copy_bytes_to_smc(adev, si_pi->dte_table_start,\n\t\t\t\t\t  (u8 *)dte_tables,\n\t\t\t\t\t  sizeof(Smc_SIslands_DTE_Configuration),\n\t\t\t\t\t  si_pi->sram_end);\n\tkfree(dte_tables);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "lookup_table",
        "function_name": "phm_get_voltage_index",
        "location": {
            "file_path": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu_helper.c",
            "region": {
                "startLine": 392,
                "startColumn": 29,
                "endColumn": 41
            },
            "context": {
                "startLine": 390,
                "endLine": 394,
                "snippet": {
                    "text": "uint8_t count = (uint8_t) (lookup_table->count);"
                }
            }
        },
        "function_code": "uint8_t phm_get_voltage_index(\n\t\tstruct phm_ppt_v1_voltage_lookup_table *lookup_table, uint16_t voltage)\n{\n\tuint8_t count = (uint8_t) (lookup_table->count);\n\tuint8_t i;\n\n\tPP_ASSERT_WITH_CODE((NULL != lookup_table),\n\t\t\t\"Lookup Table empty.\", return 0);\n\tPP_ASSERT_WITH_CODE((0 != count),\n\t\t\t\"Lookup Table empty.\", return 0);\n\n\tfor (i = 0; i < lookup_table->count; i++) {\n\t\t/* find first voltage equal or bigger than requested */\n\t\tif (lookup_table->entries[i].us_vdd >= voltage)\n\t\t\treturn i;\n\t}\n\t/* voltage is bigger than max voltage in the table */\n\treturn i - 1;\n}"
    },
    {
        "var_name": "voltage_table",
        "function_name": "phm_get_voltage_id",
        "location": {
            "file_path": "drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu_helper.c",
            "region": {
                "startLine": 412,
                "startColumn": 29,
                "endColumn": 42
            },
            "context": {
                "startLine": 410,
                "endLine": 414,
                "snippet": {
                    "text": "uint8_t count = (uint8_t) (voltage_table->count);"
                }
            }
        },
        "function_code": "uint8_t phm_get_voltage_id(pp_atomctrl_voltage_table *voltage_table,\n\t\tuint32_t voltage)\n{\n\tuint8_t count = (uint8_t) (voltage_table->count);\n\tuint8_t i = 0;\n\n\tPP_ASSERT_WITH_CODE((NULL != voltage_table),\n\t\t\"Voltage Table empty.\", return 0;);\n\tPP_ASSERT_WITH_CODE((0 != count),\n\t\t\"Voltage Table empty.\", return 0;);\n\n\tfor (i = 0; i < count; i++) {\n\t\t/* find first voltage bigger than requested */\n\t\tif (voltage_table->entries[i].value >= voltage)\n\t\t\treturn i;\n\t}\n\n\t/* voltage is bigger than max voltage in the table */\n\treturn i - 1;\n}"
    },
    {
        "var_name": "bridge_state",
        "function_name": "imx8mp_hdmi_pvi_bridge_enable",
        "location": {
            "file_path": "drivers/gpu/drm/bridge/imx/imx8mp-hdmi-pvi.c",
            "region": {
                "startLine": 54,
                "startColumn": 35,
                "endColumn": 47
            },
            "context": {
                "startLine": 52,
                "endLine": 56,
                "snippet": {
                    "text": "struct drm_atomic_state *state = bridge_state->base.state;"
                }
            }
        },
        "function_code": "static void imx8mp_hdmi_pvi_bridge_enable(struct drm_bridge *bridge,\n\t\t\t\t\t  struct drm_bridge_state *bridge_state)\n{\n\tstruct drm_atomic_state *state = bridge_state->base.state;\n\tstruct imx8mp_hdmi_pvi *pvi = to_imx8mp_hdmi_pvi(bridge);\n\tstruct drm_connector_state *conn_state;\n\tconst struct drm_display_mode *mode;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_connector *connector;\n\tu32 bus_flags = 0, val;\n\n\tconnector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);\n\tconn_state = drm_atomic_get_new_connector_state(state, connector);\n\tcrtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);\n\n\tif (WARN_ON(pm_runtime_resume_and_get(pvi->dev)))\n\t\treturn;\n\n\tmode = &crtc_state->adjusted_mode;\n\n\tval = FIELD_PREP(PVI_CTRL_MODE_MASK, PVI_CTRL_MODE_LCDIF) | PVI_CTRL_EN;\n\n\tif (mode->flags & DRM_MODE_FLAG_PVSYNC)\n\t\tval |= PVI_CTRL_OP_VSYNC_POL | PVI_CTRL_INP_VSYNC_POL;\n\n\tif (mode->flags & DRM_MODE_FLAG_PHSYNC)\n\t\tval |= PVI_CTRL_OP_HSYNC_POL | PVI_CTRL_INP_HSYNC_POL;\n\n\tif (pvi->next_bridge->timings)\n\t\tbus_flags = pvi->next_bridge->timings->input_bus_flags;\n\telse if (bridge_state)\n\t\tbus_flags = bridge_state->input_bus_cfg.flags;\n\n\tif (bus_flags & DRM_BUS_FLAG_DE_HIGH)\n\t\tval |= PVI_CTRL_OP_DE_POL | PVI_CTRL_INP_DE_POL;\n\n\twritel(val, pvi->regs + HTX_PVI_CTRL);\n}"
    },
    {
        "var_name": "new_plane_state",
        "function_name": "drm_atomic_helper_async_check",
        "location": {
            "file_path": "drivers/gpu/drm/drm_atomic_helper.c",
            "region": {
                "startLine": 1894,
                "startColumn": 7,
                "endColumn": 22
            },
            "context": {
                "startLine": 1892,
                "endLine": 1896,
                "snippet": {
                    "text": "if (!new_plane_state->crtc ||"
                }
            }
        },
        "function_code": "int drm_atomic_helper_async_check(struct drm_device *dev,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_plane *plane = NULL;\n\tstruct drm_plane_state *old_plane_state = NULL;\n\tstruct drm_plane_state *new_plane_state = NULL;\n\tconst struct drm_plane_helper_funcs *funcs;\n\tint i, ret, n_planes = 0;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (drm_atomic_crtc_needs_modeset(crtc_state))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i)\n\t\tn_planes++;\n\n\t/* FIXME: we support only single plane updates for now */\n\tif (n_planes != 1) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"only single plane async updates are supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!new_plane_state->crtc ||\n\t    old_plane_state->crtc != new_plane_state->crtc) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] async update cannot change CRTC\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\tfuncs = plane->helper_private;\n\tif (!funcs->atomic_async_update) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] driver does not support async updates\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_plane_state->fence) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] missing fence for async update\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Don't do an async update if there is an outstanding commit modifying\n\t * the plane.  This prevents our async update's changes from getting\n\t * overridden by a previous synchronous update's state.\n\t */\n\tif (old_plane_state->commit &&\n\t    !try_wait_for_completion(&old_plane_state->commit->hw_done)) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] inflight previous commit preventing async commit\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EBUSY;\n\t}\n\n\tret = funcs->atomic_async_check(plane, state);\n\tif (ret != 0)\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] driver async check failed\\n\",\n\t\t\t       plane->base.id, plane->name);\n\treturn ret;\n}"
    },
    {
        "var_name": "plane",
        "function_name": "drm_atomic_helper_async_check",
        "location": {
            "file_path": "drivers/gpu/drm/drm_atomic_helper.c",
            "region": {
                "startLine": 1902,
                "startColumn": 10,
                "endColumn": 15
            },
            "context": {
                "startLine": 1900,
                "endLine": 1904,
                "snippet": {
                    "text": "funcs = plane->helper_private;"
                }
            }
        },
        "function_code": "int drm_atomic_helper_async_check(struct drm_device *dev,\n\t\t\t\t   struct drm_atomic_state *state)\n{\n\tstruct drm_crtc *crtc;\n\tstruct drm_crtc_state *crtc_state;\n\tstruct drm_plane *plane = NULL;\n\tstruct drm_plane_state *old_plane_state = NULL;\n\tstruct drm_plane_state *new_plane_state = NULL;\n\tconst struct drm_plane_helper_funcs *funcs;\n\tint i, ret, n_planes = 0;\n\n\tfor_each_new_crtc_in_state(state, crtc, crtc_state, i) {\n\t\tif (drm_atomic_crtc_needs_modeset(crtc_state))\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor_each_oldnew_plane_in_state(state, plane, old_plane_state, new_plane_state, i)\n\t\tn_planes++;\n\n\t/* FIXME: we support only single plane updates for now */\n\tif (n_planes != 1) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"only single plane async updates are supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!new_plane_state->crtc ||\n\t    old_plane_state->crtc != new_plane_state->crtc) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] async update cannot change CRTC\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\tfuncs = plane->helper_private;\n\tif (!funcs->atomic_async_update) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] driver does not support async updates\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (new_plane_state->fence) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] missing fence for async update\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Don't do an async update if there is an outstanding commit modifying\n\t * the plane.  This prevents our async update's changes from getting\n\t * overridden by a previous synchronous update's state.\n\t */\n\tif (old_plane_state->commit &&\n\t    !try_wait_for_completion(&old_plane_state->commit->hw_done)) {\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] inflight previous commit preventing async commit\\n\",\n\t\t\t       plane->base.id, plane->name);\n\t\treturn -EBUSY;\n\t}\n\n\tret = funcs->atomic_async_check(plane, state);\n\tif (ret != 0)\n\t\tdrm_dbg_atomic(dev,\n\t\t\t       \"[PLANE:%d:%s] driver async check failed\\n\",\n\t\t\t       plane->base.id, plane->name);\n\treturn ret;\n}"
    },
    {
        "var_name": "funcs",
        "function_name": "__drm_connector_init",
        "location": {
            "file_path": "drivers/gpu/drm/drm_connector.c",
            "region": {
                "startLine": 233,
                "startColumn": 5,
                "endColumn": 10
            },
            "context": {
                "startLine": 231,
                "endLine": 235,
                "snippet": {
                    "text": "(!funcs->atomic_destroy_state ||"
                }
            }
        },
        "function_code": "static int __drm_connector_init(struct drm_device *dev,\n\t\t\t\tstruct drm_connector *connector,\n\t\t\t\tconst struct drm_connector_funcs *funcs,\n\t\t\t\tint connector_type,\n\t\t\t\tstruct i2c_adapter *ddc)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tint ret;\n\tstruct ida *connector_ida =\n\t\t&drm_connector_enum_list[connector_type].ida;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev) &&\n\t\t(!funcs->atomic_destroy_state ||\n\t\t !funcs->atomic_duplicate_state));\n\n\tret = __drm_mode_object_add(dev, &connector->base,\n\t\t\t\t    DRM_MODE_OBJECT_CONNECTOR,\n\t\t\t\t    false, drm_connector_free);\n\tif (ret)\n\t\treturn ret;\n\n\tconnector->base.properties = &connector->properties;\n\tconnector->dev = dev;\n\tconnector->funcs = funcs;\n\n\t/* connector index is used with 32bit bitmasks */\n\tret = ida_alloc_max(&config->connector_ida, 31, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tDRM_DEBUG_KMS(\"Failed to allocate %s connector index: %d\\n\",\n\t\t\t      drm_connector_enum_list[connector_type].name,\n\t\t\t      ret);\n\t\tgoto out_put;\n\t}\n\tconnector->index = ret;\n\tret = 0;\n\n\tconnector->connector_type = connector_type;\n\tconnector->connector_type_id =\n\t\tida_alloc_min(connector_ida, 1, GFP_KERNEL);\n\tif (connector->connector_type_id < 0) {\n\t\tret = connector->connector_type_id;\n\t\tgoto out_put_id;\n\t}\n\tconnector->name =\n\t\tkasprintf(GFP_KERNEL, \"%s-%d\",\n\t\t\t  drm_connector_enum_list[connector_type].name,\n\t\t\t  connector->connector_type_id);\n\tif (!connector->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_type_id;\n\t}\n\n\t/* provide ddc symlink in sysfs */\n\tconnector->ddc = ddc;\n\n\tINIT_LIST_HEAD(&connector->global_connector_list_entry);\n\tINIT_LIST_HEAD(&connector->probed_modes);\n\tINIT_LIST_HEAD(&connector->modes);\n\tmutex_init(&connector->mutex);\n\tmutex_init(&connector->edid_override_mutex);\n\tconnector->edid_blob_ptr = NULL;\n\tconnector->epoch_counter = 0;\n\tconnector->tile_blob_ptr = NULL;\n\tconnector->status = connector_status_unknown;\n\tconnector->display_info.panel_orientation =\n\t\tDRM_MODE_PANEL_ORIENTATION_UNKNOWN;\n\n\tdrm_connector_get_cmdline_mode(connector);\n\n\t/* We should add connectors at the end to avoid upsetting the connector\n\t * index too much.\n\t */\n\tspin_lock_irq(&config->connector_list_lock);\n\tlist_add_tail(&connector->head, &config->connector_list);\n\tconfig->num_connector++;\n\tspin_unlock_irq(&config->connector_list_lock);\n\n\tif (connector_type != DRM_MODE_CONNECTOR_VIRTUAL &&\n\t    connector_type != DRM_MODE_CONNECTOR_WRITEBACK)\n\t\tdrm_connector_attach_edid_property(connector);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t      config->dpms_property, 0);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->link_status_property,\n\t\t\t\t   0);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->non_desktop_property,\n\t\t\t\t   0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->tile_property,\n\t\t\t\t   0);\n\n\tif (drm_core_check_feature(dev, DRIVER_ATOMIC)) {\n\t\tdrm_object_attach_property(&connector->base, config->prop_crtc_id, 0);\n\t}\n\n\tconnector->debugfs_entry = NULL;\nout_put_type_id:\n\tif (ret)\n\t\tida_free(connector_ida, connector->connector_type_id);\nout_put_id:\n\tif (ret)\n\t\tida_free(&config->connector_ida, connector->index);\nout_put:\n\tif (ret)\n\t\tdrm_mode_object_unregister(dev, &connector->base);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "funcs",
        "function_name": "__drm_connector_init",
        "location": {
            "file_path": "drivers/gpu/drm/drm_connector.c",
            "region": {
                "startLine": 234,
                "startColumn": 5,
                "endColumn": 10
            },
            "context": {
                "startLine": 232,
                "endLine": 236,
                "snippet": {
                    "text": "!funcs->atomic_duplicate_state));"
                }
            }
        },
        "function_code": "static int __drm_connector_init(struct drm_device *dev,\n\t\t\t\tstruct drm_connector *connector,\n\t\t\t\tconst struct drm_connector_funcs *funcs,\n\t\t\t\tint connector_type,\n\t\t\t\tstruct i2c_adapter *ddc)\n{\n\tstruct drm_mode_config *config = &dev->mode_config;\n\tint ret;\n\tstruct ida *connector_ida =\n\t\t&drm_connector_enum_list[connector_type].ida;\n\n\tWARN_ON(drm_drv_uses_atomic_modeset(dev) &&\n\t\t(!funcs->atomic_destroy_state ||\n\t\t !funcs->atomic_duplicate_state));\n\n\tret = __drm_mode_object_add(dev, &connector->base,\n\t\t\t\t    DRM_MODE_OBJECT_CONNECTOR,\n\t\t\t\t    false, drm_connector_free);\n\tif (ret)\n\t\treturn ret;\n\n\tconnector->base.properties = &connector->properties;\n\tconnector->dev = dev;\n\tconnector->funcs = funcs;\n\n\t/* connector index is used with 32bit bitmasks */\n\tret = ida_alloc_max(&config->connector_ida, 31, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tDRM_DEBUG_KMS(\"Failed to allocate %s connector index: %d\\n\",\n\t\t\t      drm_connector_enum_list[connector_type].name,\n\t\t\t      ret);\n\t\tgoto out_put;\n\t}\n\tconnector->index = ret;\n\tret = 0;\n\n\tconnector->connector_type = connector_type;\n\tconnector->connector_type_id =\n\t\tida_alloc_min(connector_ida, 1, GFP_KERNEL);\n\tif (connector->connector_type_id < 0) {\n\t\tret = connector->connector_type_id;\n\t\tgoto out_put_id;\n\t}\n\tconnector->name =\n\t\tkasprintf(GFP_KERNEL, \"%s-%d\",\n\t\t\t  drm_connector_enum_list[connector_type].name,\n\t\t\t  connector->connector_type_id);\n\tif (!connector->name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_put_type_id;\n\t}\n\n\t/* provide ddc symlink in sysfs */\n\tconnector->ddc = ddc;\n\n\tINIT_LIST_HEAD(&connector->global_connector_list_entry);\n\tINIT_LIST_HEAD(&connector->probed_modes);\n\tINIT_LIST_HEAD(&connector->modes);\n\tmutex_init(&connector->mutex);\n\tmutex_init(&connector->edid_override_mutex);\n\tconnector->edid_blob_ptr = NULL;\n\tconnector->epoch_counter = 0;\n\tconnector->tile_blob_ptr = NULL;\n\tconnector->status = connector_status_unknown;\n\tconnector->display_info.panel_orientation =\n\t\tDRM_MODE_PANEL_ORIENTATION_UNKNOWN;\n\n\tdrm_connector_get_cmdline_mode(connector);\n\n\t/* We should add connectors at the end to avoid upsetting the connector\n\t * index too much.\n\t */\n\tspin_lock_irq(&config->connector_list_lock);\n\tlist_add_tail(&connector->head, &config->connector_list);\n\tconfig->num_connector++;\n\tspin_unlock_irq(&config->connector_list_lock);\n\n\tif (connector_type != DRM_MODE_CONNECTOR_VIRTUAL &&\n\t    connector_type != DRM_MODE_CONNECTOR_WRITEBACK)\n\t\tdrm_connector_attach_edid_property(connector);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t      config->dpms_property, 0);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->link_status_property,\n\t\t\t\t   0);\n\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->non_desktop_property,\n\t\t\t\t   0);\n\tdrm_object_attach_property(&connector->base,\n\t\t\t\t   config->tile_property,\n\t\t\t\t   0);\n\n\tif (drm_core_check_feature(dev, DRIVER_ATOMIC)) {\n\t\tdrm_object_attach_property(&connector->base, config->prop_crtc_id, 0);\n\t}\n\n\tconnector->debugfs_entry = NULL;\nout_put_type_id:\n\tif (ret)\n\t\tida_free(connector_ida, connector->connector_type_id);\nout_put_id:\n\tif (ret)\n\t\tida_free(&config->connector_ida, connector->index);\nout_put:\n\tif (ret)\n\t\tdrm_mode_object_unregister(dev, &connector->base);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "plane",
        "function_name": "drm_mode_cursor_universal",
        "location": {
            "file_path": "drivers/gpu/drm/drm_plane.c",
            "region": {
                "startLine": 1154,
                "startColumn": 10,
                "endColumn": 15
            },
            "context": {
                "startLine": 1152,
                "endLine": 1156,
                "snippet": {
                    "text": "WARN_ON(plane->crtc != crtc && plane->crtc != NULL);"
                }
            }
        },
        "function_code": "static int drm_mode_cursor_universal(struct drm_crtc *crtc,\n\t\t\t\t     struct drm_mode_cursor2 *req,\n\t\t\t\t     struct drm_file *file_priv,\n\t\t\t\t     struct drm_modeset_acquire_ctx *ctx)\n{\n\tstruct drm_device *dev = crtc->dev;\n\tstruct drm_plane *plane = crtc->cursor;\n\tstruct drm_framebuffer *fb = NULL;\n\tstruct drm_mode_fb_cmd2 fbreq = {\n\t\t.width = req->width,\n\t\t.height = req->height,\n\t\t.pixel_format = DRM_FORMAT_ARGB8888,\n\t\t.pitches = { req->width * 4 },\n\t\t.handles = { req->handle },\n\t};\n\tint32_t crtc_x, crtc_y;\n\tuint32_t crtc_w = 0, crtc_h = 0;\n\tuint32_t src_w = 0, src_h = 0;\n\tint ret = 0;\n\n\tBUG_ON(!plane);\n\tWARN_ON(plane->crtc != crtc && plane->crtc != NULL);\n\n\t/*\n\t * Obtain fb we'll be using (either new or existing) and take an extra\n\t * reference to it if fb != null.  setplane will take care of dropping\n\t * the reference if the plane update fails.\n\t */\n\tif (req->flags & DRM_MODE_CURSOR_BO) {\n\t\tif (req->handle) {\n\t\t\tfb = drm_internal_framebuffer_create(dev, &fbreq, file_priv);\n\t\t\tif (IS_ERR(fb)) {\n\t\t\t\tDRM_DEBUG_KMS(\"failed to wrap cursor buffer in drm framebuffer\\n\");\n\t\t\t\treturn PTR_ERR(fb);\n\t\t\t}\n\n\t\t\tif (plane->hotspot_x_property && plane->state)\n\t\t\t\tplane->state->hotspot_x = req->hot_x;\n\t\t\tif (plane->hotspot_y_property && plane->state)\n\t\t\t\tplane->state->hotspot_y = req->hot_y;\n\t\t} else {\n\t\t\tfb = NULL;\n\t\t}\n\t} else {\n\t\tif (plane->state)\n\t\t\tfb = plane->state->fb;\n\t\telse\n\t\t\tfb = plane->fb;\n\n\t\tif (fb)\n\t\t\tdrm_framebuffer_get(fb);\n\t}\n\n\tif (req->flags & DRM_MODE_CURSOR_MOVE) {\n\t\tcrtc_x = req->x;\n\t\tcrtc_y = req->y;\n\t} else {\n\t\tcrtc_x = crtc->cursor_x;\n\t\tcrtc_y = crtc->cursor_y;\n\t}\n\n\tif (fb) {\n\t\tcrtc_w = fb->width;\n\t\tcrtc_h = fb->height;\n\t\tsrc_w = fb->width << 16;\n\t\tsrc_h = fb->height << 16;\n\t}\n\n\tif (drm_drv_uses_atomic_modeset(dev))\n\t\tret = __setplane_atomic(plane, crtc, fb,\n\t\t\t\t\tcrtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t0, 0, src_w, src_h, ctx);\n\telse\n\t\tret = __setplane_internal(plane, crtc, fb,\n\t\t\t\t\t  crtc_x, crtc_y, crtc_w, crtc_h,\n\t\t\t\t\t  0, 0, src_w, src_h, ctx);\n\n\tif (fb)\n\t\tdrm_framebuffer_put(fb);\n\n\t/* Update successful; save new cursor position, if necessary */\n\tif (ret == 0 && req->flags & DRM_MODE_CURSOR_MOVE) {\n\t\tcrtc->cursor_x = req->x;\n\t\tcrtc->cursor_y = req->y;\n\t}\n\n\treturn ret;\n}"
    },
    {
        "var_name": "timeline_wait",
        "function_name": "drm_syncobj_array_wait",
        "location": {
            "file_path": "drivers/gpu/drm/drm_syncobj.c",
            "region": {
                "startLine": 1249,
                "startColumn": 40,
                "endColumn": 53
            },
            "context": {
                "startLine": 1247,
                "endLine": 1251,
                "snippet": {
                    "text": "timeout = drm_timeout_abs_to_jiffies(timeline_wait->timeout_nsec);"
                }
            }
        },
        "function_code": "static int drm_syncobj_array_wait(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_private,\n\t\t\t\t  struct drm_syncobj_wait *wait,\n\t\t\t\t  struct drm_syncobj_timeline_wait *timeline_wait,\n\t\t\t\t  struct drm_syncobj **syncobjs, bool timeline,\n\t\t\t\t  ktime_t *deadline)\n{\n\tsigned long timeout = 0;\n\tuint32_t first = ~0;\n\n\tif (!timeline) {\n\t\ttimeout = drm_timeout_abs_to_jiffies(wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t wait->count_handles,\n\t\t\t\t\t\t\t wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\twait->first_signaled = first;\n\t} else {\n\t\ttimeout = drm_timeout_abs_to_jiffies(timeline_wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t u64_to_user_ptr(timeline_wait->points),\n\t\t\t\t\t\t\t timeline_wait->count_handles,\n\t\t\t\t\t\t\t timeline_wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\ttimeline_wait->first_signaled = first;\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "timeline_wait",
        "function_name": "drm_syncobj_array_wait",
        "location": {
            "file_path": "drivers/gpu/drm/drm_syncobj.c",
            "region": {
                "startLine": 1251,
                "startColumn": 25,
                "endColumn": 38
            },
            "context": {
                "startLine": 1249,
                "endLine": 1253,
                "snippet": {
                    "text": "u64_to_user_ptr(timeline_wait->points),"
                }
            }
        },
        "function_code": "static int drm_syncobj_array_wait(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_private,\n\t\t\t\t  struct drm_syncobj_wait *wait,\n\t\t\t\t  struct drm_syncobj_timeline_wait *timeline_wait,\n\t\t\t\t  struct drm_syncobj **syncobjs, bool timeline,\n\t\t\t\t  ktime_t *deadline)\n{\n\tsigned long timeout = 0;\n\tuint32_t first = ~0;\n\n\tif (!timeline) {\n\t\ttimeout = drm_timeout_abs_to_jiffies(wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t wait->count_handles,\n\t\t\t\t\t\t\t wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\twait->first_signaled = first;\n\t} else {\n\t\ttimeout = drm_timeout_abs_to_jiffies(timeline_wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t u64_to_user_ptr(timeline_wait->points),\n\t\t\t\t\t\t\t timeline_wait->count_handles,\n\t\t\t\t\t\t\t timeline_wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\ttimeline_wait->first_signaled = first;\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "timeline_wait",
        "function_name": "drm_syncobj_array_wait",
        "location": {
            "file_path": "drivers/gpu/drm/drm_syncobj.c",
            "region": {
                "startLine": 1252,
                "startColumn": 9,
                "endColumn": 22
            },
            "context": {
                "startLine": 1250,
                "endLine": 1254,
                "snippet": {
                    "text": "timeline_wait->count_handles,"
                }
            }
        },
        "function_code": "static int drm_syncobj_array_wait(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_private,\n\t\t\t\t  struct drm_syncobj_wait *wait,\n\t\t\t\t  struct drm_syncobj_timeline_wait *timeline_wait,\n\t\t\t\t  struct drm_syncobj **syncobjs, bool timeline,\n\t\t\t\t  ktime_t *deadline)\n{\n\tsigned long timeout = 0;\n\tuint32_t first = ~0;\n\n\tif (!timeline) {\n\t\ttimeout = drm_timeout_abs_to_jiffies(wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t wait->count_handles,\n\t\t\t\t\t\t\t wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\twait->first_signaled = first;\n\t} else {\n\t\ttimeout = drm_timeout_abs_to_jiffies(timeline_wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t u64_to_user_ptr(timeline_wait->points),\n\t\t\t\t\t\t\t timeline_wait->count_handles,\n\t\t\t\t\t\t\t timeline_wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\ttimeline_wait->first_signaled = first;\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "timeline_wait",
        "function_name": "drm_syncobj_array_wait",
        "location": {
            "file_path": "drivers/gpu/drm/drm_syncobj.c",
            "region": {
                "startLine": 1253,
                "startColumn": 9,
                "endColumn": 22
            },
            "context": {
                "startLine": 1251,
                "endLine": 1255,
                "snippet": {
                    "text": "timeline_wait->flags,"
                }
            }
        },
        "function_code": "static int drm_syncobj_array_wait(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_private,\n\t\t\t\t  struct drm_syncobj_wait *wait,\n\t\t\t\t  struct drm_syncobj_timeline_wait *timeline_wait,\n\t\t\t\t  struct drm_syncobj **syncobjs, bool timeline,\n\t\t\t\t  ktime_t *deadline)\n{\n\tsigned long timeout = 0;\n\tuint32_t first = ~0;\n\n\tif (!timeline) {\n\t\ttimeout = drm_timeout_abs_to_jiffies(wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t wait->count_handles,\n\t\t\t\t\t\t\t wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\twait->first_signaled = first;\n\t} else {\n\t\ttimeout = drm_timeout_abs_to_jiffies(timeline_wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t u64_to_user_ptr(timeline_wait->points),\n\t\t\t\t\t\t\t timeline_wait->count_handles,\n\t\t\t\t\t\t\t timeline_wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\ttimeline_wait->first_signaled = first;\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "timeline_wait",
        "function_name": "drm_syncobj_array_wait",
        "location": {
            "file_path": "drivers/gpu/drm/drm_syncobj.c",
            "region": {
                "startLine": 1258,
                "startColumn": 3,
                "endColumn": 16
            },
            "context": {
                "startLine": 1256,
                "endLine": 1260,
                "snippet": {
                    "text": "timeline_wait->first_signaled = first;"
                }
            }
        },
        "function_code": "static int drm_syncobj_array_wait(struct drm_device *dev,\n\t\t\t\t  struct drm_file *file_private,\n\t\t\t\t  struct drm_syncobj_wait *wait,\n\t\t\t\t  struct drm_syncobj_timeline_wait *timeline_wait,\n\t\t\t\t  struct drm_syncobj **syncobjs, bool timeline,\n\t\t\t\t  ktime_t *deadline)\n{\n\tsigned long timeout = 0;\n\tuint32_t first = ~0;\n\n\tif (!timeline) {\n\t\ttimeout = drm_timeout_abs_to_jiffies(wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t wait->count_handles,\n\t\t\t\t\t\t\t wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\twait->first_signaled = first;\n\t} else {\n\t\ttimeout = drm_timeout_abs_to_jiffies(timeline_wait->timeout_nsec);\n\t\ttimeout = drm_syncobj_array_wait_timeout(syncobjs,\n\t\t\t\t\t\t\t u64_to_user_ptr(timeline_wait->points),\n\t\t\t\t\t\t\t timeline_wait->count_handles,\n\t\t\t\t\t\t\t timeline_wait->flags,\n\t\t\t\t\t\t\t timeout, &first,\n\t\t\t\t\t\t\t deadline);\n\t\tif (timeout < 0)\n\t\t\treturn timeout;\n\t\ttimeline_wait->first_signaled = first;\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "connector",
        "function_name": "oaktrail_lvds_mode_set",
        "location": {
            "file_path": "drivers/gpu/drm/gma500/oaktrail_lvds.c",
            "region": {
                "startLine": 118,
                "startColumn": 7,
                "endColumn": 16
            },
            "context": {
                "startLine": 116,
                "endLine": 120,
                "snippet": {
                    "text": "if (connector->encoder && connector->encoder->crtc == crtc)"
                }
            }
        },
        "function_code": "static void oaktrail_lvds_mode_set(struct drm_encoder *encoder,\n\t\t\t       struct drm_display_mode *mode,\n\t\t\t       struct drm_display_mode *adjusted_mode)\n{\n\tstruct drm_device *dev = encoder->dev;\n\tstruct drm_psb_private *dev_priv = to_drm_psb_private(dev);\n\tstruct psb_intel_mode_device *mode_dev = &dev_priv->mode_dev;\n\tstruct drm_connector_list_iter conn_iter;\n\tstruct drm_connector *connector = NULL;\n\tstruct drm_crtc *crtc = encoder->crtc;\n\tu32 lvds_port;\n\tuint64_t v = DRM_MODE_SCALE_FULLSCREEN;\n\n\tif (!gma_power_begin(dev, true))\n\t\treturn;\n\n\t/*\n\t * The LVDS pin pair will already have been turned on in the\n\t * psb_intel_crtc_mode_set since it has a large impact on the DPLL\n\t * settings.\n\t */\n\tlvds_port = (REG_READ(LVDS) &\n\t\t    (~LVDS_PIPEB_SELECT)) |\n\t\t    LVDS_PORT_EN |\n\t\t    LVDS_BORDER_EN;\n\n\t/* If the firmware says dither on Moorestown, or the BIOS does\n\t   on Oaktrail then enable dithering */\n\tif (mode_dev->panel_wants_dither || dev_priv->lvds_dither)\n\t\tlvds_port |= MRST_PANEL_8TO6_DITHER_ENABLE;\n\n\tREG_WRITE(LVDS, lvds_port);\n\n\t/* Find the connector we're trying to set up */\n\tdrm_connector_list_iter_begin(dev, &conn_iter);\n\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\tif (connector->encoder && connector->encoder->crtc == crtc)\n\t\t\tbreak;\n\t}\n\n\tif (!connector) {\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t\tDRM_ERROR(\"Couldn't find connector when setting mode\");\n\t\tgma_power_end(dev);\n\t\treturn;\n\t}\n\n\tdrm_object_property_get_value( &connector->base,\n\t\tdev->mode_config.scaling_mode_property, &v);\n\tdrm_connector_list_iter_end(&conn_iter);\n\n\tif (v == DRM_MODE_SCALE_NO_SCALE)\n\t\tREG_WRITE(PFIT_CONTROL, 0);\n\telse if (v == DRM_MODE_SCALE_ASPECT) {\n\t\tif ((mode->vdisplay != adjusted_mode->crtc_vdisplay) ||\n\t\t    (mode->hdisplay != adjusted_mode->crtc_hdisplay)) {\n\t\t\tif ((adjusted_mode->crtc_hdisplay * mode->vdisplay) ==\n\t\t\t    (mode->hdisplay * adjusted_mode->crtc_vdisplay))\n\t\t\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\n\t\t\telse if ((adjusted_mode->crtc_hdisplay *\n\t\t\t\tmode->vdisplay) > (mode->hdisplay *\n\t\t\t\tadjusted_mode->crtc_vdisplay))\n\t\t\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE |\n\t\t\t\t\t  PFIT_SCALING_MODE_PILLARBOX);\n\t\t\telse\n\t\t\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE |\n\t\t\t\t\t  PFIT_SCALING_MODE_LETTERBOX);\n\t\t} else\n\t\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\n\t} else /*(v == DRM_MODE_SCALE_FULLSCREEN)*/\n\t\tREG_WRITE(PFIT_CONTROL, PFIT_ENABLE);\n\n\tgma_power_end(dev);\n}"
    },
    {
        "var_name": "(u8*)args",
        "function_name": "psb_intel_sdvo_write_cmd",
        "location": {
            "file_path": "drivers/gpu/drm/gma500/psb_intel_sdvo.c",
            "region": {
                "startLine": 471,
                "startColumn": 19,
                "endColumn": 28
            },
            "context": {
                "startLine": 469,
                "endLine": 473,
                "snippet": {
                    "text": "buf[2*i + 1] = ((u8*)args)[i];"
                }
            }
        },
        "function_code": "static bool psb_intel_sdvo_write_cmd(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd,\n\t\t\t\t const void *args, int args_len)\n{\n\tu8 buf[MAX_ARG_LEN*2 + 2], status;\n\tstruct i2c_msg msgs[MAX_ARG_LEN + 3];\n\tint i, ret;\n\n\tif (args_len > MAX_ARG_LEN) {\n\t\tDRM_ERROR(\"Need to increase arg length\\n\");\n\t\treturn false;\n\t}\n\n\tpsb_intel_sdvo_debug_write(psb_intel_sdvo, cmd, args, args_len);\n\n\tfor (i = 0; i < args_len; i++) {\n\t\tmsgs[i].addr = psb_intel_sdvo->slave_addr;\n\t\tmsgs[i].flags = 0;\n\t\tmsgs[i].len = 2;\n\t\tmsgs[i].buf = buf + 2 *i;\n\t\tbuf[2*i + 0] = SDVO_I2C_ARG_0 - i;\n\t\tbuf[2*i + 1] = ((u8*)args)[i];\n\t}\n\tmsgs[i].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i].flags = 0;\n\tmsgs[i].len = 2;\n\tmsgs[i].buf = buf + 2*i;\n\tbuf[2*i + 0] = SDVO_I2C_OPCODE;\n\tbuf[2*i + 1] = cmd;\n\n\t/* the following two are to read the response */\n\tstatus = SDVO_I2C_CMD_STATUS;\n\tmsgs[i+1].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i+1].flags = 0;\n\tmsgs[i+1].len = 1;\n\tmsgs[i+1].buf = &status;\n\n\tmsgs[i+2].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i+2].flags = I2C_M_RD;\n\tmsgs[i+2].len = 1;\n\tmsgs[i+2].buf = &status;\n\n\tret = i2c_transfer(psb_intel_sdvo->i2c, msgs, i+3);\n\tif (ret < 0) {\n\t\tDRM_DEBUG_KMS(\"I2c transfer returned %d\\n\", ret);\n\t\treturn false;\n\t}\n\tif (ret != i+3) {\n\t\t/* failure in I2C transfer */\n\t\tDRM_DEBUG_KMS(\"I2c transfer returned %d/%d\\n\", ret, i+3);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
    },
    {
        "var_name": "args",
        "function_name": "psb_intel_sdvo_write_cmd",
        "location": {
            "file_path": "drivers/gpu/drm/gma500/psb_intel_sdvo.c",
            "region": {
                "startLine": 471,
                "startColumn": 24,
                "endColumn": 28
            },
            "context": {
                "startLine": 469,
                "endLine": 473,
                "snippet": {
                    "text": "buf[2*i + 1] = ((u8*)args)[i];"
                }
            }
        },
        "function_code": "static bool psb_intel_sdvo_write_cmd(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd,\n\t\t\t\t const void *args, int args_len)\n{\n\tu8 buf[MAX_ARG_LEN*2 + 2], status;\n\tstruct i2c_msg msgs[MAX_ARG_LEN + 3];\n\tint i, ret;\n\n\tif (args_len > MAX_ARG_LEN) {\n\t\tDRM_ERROR(\"Need to increase arg length\\n\");\n\t\treturn false;\n\t}\n\n\tpsb_intel_sdvo_debug_write(psb_intel_sdvo, cmd, args, args_len);\n\n\tfor (i = 0; i < args_len; i++) {\n\t\tmsgs[i].addr = psb_intel_sdvo->slave_addr;\n\t\tmsgs[i].flags = 0;\n\t\tmsgs[i].len = 2;\n\t\tmsgs[i].buf = buf + 2 *i;\n\t\tbuf[2*i + 0] = SDVO_I2C_ARG_0 - i;\n\t\tbuf[2*i + 1] = ((u8*)args)[i];\n\t}\n\tmsgs[i].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i].flags = 0;\n\tmsgs[i].len = 2;\n\tmsgs[i].buf = buf + 2*i;\n\tbuf[2*i + 0] = SDVO_I2C_OPCODE;\n\tbuf[2*i + 1] = cmd;\n\n\t/* the following two are to read the response */\n\tstatus = SDVO_I2C_CMD_STATUS;\n\tmsgs[i+1].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i+1].flags = 0;\n\tmsgs[i+1].len = 1;\n\tmsgs[i+1].buf = &status;\n\n\tmsgs[i+2].addr = psb_intel_sdvo->slave_addr;\n\tmsgs[i+2].flags = I2C_M_RD;\n\tmsgs[i+2].len = 1;\n\tmsgs[i+2].buf = &status;\n\n\tret = i2c_transfer(psb_intel_sdvo->i2c, msgs, i+3);\n\tif (ret < 0) {\n\t\tDRM_DEBUG_KMS(\"I2c transfer returned %d\\n\", ret);\n\t\treturn false;\n\t}\n\tif (ret != i+3) {\n\t\t/* failure in I2C transfer */\n\t\tDRM_DEBUG_KMS(\"I2c transfer returned %d/%d\\n\", ret, i+3);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
    },
    {
        "var_name": "fb",
        "function_name": "gud_pipe_check",
        "location": {
            "file_path": "drivers/gpu/drm/gud/gud_pipe.c",
            "region": {
                "startLine": 460,
                "startColumn": 41,
                "endColumn": 43
            },
            "context": {
                "startLine": 458,
                "endLine": 462,
                "snippet": {
                    "text": "const struct drm_format_info *format = fb->format;"
                }
            }
        },
        "function_code": "int gud_pipe_check(struct drm_simple_display_pipe *pipe,\n\t\t   struct drm_plane_state *new_plane_state,\n\t\t   struct drm_crtc_state *new_crtc_state)\n{\n\tstruct gud_device *gdrm = to_gud_device(pipe->crtc.dev);\n\tstruct drm_plane_state *old_plane_state = pipe->plane.state;\n\tconst struct drm_display_mode *mode = &new_crtc_state->mode;\n\tstruct drm_atomic_state *state = new_plane_state->state;\n\tstruct drm_framebuffer *old_fb = old_plane_state->fb;\n\tstruct drm_connector_state *connector_state = NULL;\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tstruct drm_connector *connector;\n\tunsigned int i, num_properties;\n\tstruct gud_state_req *req;\n\tint idx, ret;\n\tsize_t len;\n\n\tif (WARN_ON_ONCE(!fb))\n\t\treturn -EINVAL;\n\n\tif (old_plane_state->rotation != new_plane_state->rotation)\n\t\tnew_crtc_state->mode_changed = true;\n\n\tif (old_fb && old_fb->format != format)\n\t\tnew_crtc_state->mode_changed = true;\n\n\tif (!new_crtc_state->mode_changed && !new_crtc_state->connectors_changed)\n\t\treturn 0;\n\n\t/* Only one connector is supported */\n\tif (hweight32(new_crtc_state->connector_mask) != 1)\n\t\treturn -EINVAL;\n\n\tif (format->format == DRM_FORMAT_XRGB8888 && gdrm->xrgb8888_emulation_format)\n\t\tformat = gdrm->xrgb8888_emulation_format;\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->crtc)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * DRM_IOCTL_MODE_OBJ_SETPROPERTY on the rotation property will not have\n\t * the connector included in the state.\n\t */\n\tif (!connector_state) {\n\t\tstruct drm_connector_list_iter conn_iter;\n\n\t\tdrm_connector_list_iter_begin(pipe->crtc.dev, &conn_iter);\n\t\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t\tif (connector->state->crtc) {\n\t\t\t\tconnector_state = connector->state;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t}\n\n\tif (WARN_ON_ONCE(!connector_state))\n\t\treturn -ENOENT;\n\n\tlen = struct_size(req, properties,\n\t\t\t  size_add(GUD_PROPERTIES_MAX_NUM, GUD_CONNECTOR_PROPERTIES_MAX_NUM));\n\treq = kzalloc(len, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tgud_from_display_mode(&req->mode, mode);\n\n\treq->format = gud_from_fourcc(format->format);\n\tif (WARN_ON_ONCE(!req->format)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treq->connector = drm_connector_index(connector_state->connector);\n\n\tret = gud_connector_fill_properties(connector_state, req->properties);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnum_properties = ret;\n\tfor (i = 0; i < gdrm->num_properties; i++) {\n\t\tu16 prop = gdrm->properties[i];\n\t\tu64 val;\n\n\t\tswitch (prop) {\n\t\tcase GUD_PROPERTY_ROTATION:\n\t\t\t/* DRM UAPI matches the protocol so use value directly */\n\t\t\tval = new_plane_state->rotation;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\treq->properties[num_properties + i].prop = cpu_to_le16(prop);\n\t\treq->properties[num_properties + i].val = cpu_to_le64(val);\n\t\tnum_properties++;\n\t}\n\n\tif (drm_dev_enter(fb->dev, &idx)) {\n\t\tlen = struct_size(req, properties, num_properties);\n\t\tret = gud_usb_set(gdrm, GUD_REQ_SET_STATE_CHECK, 0, req, len);\n\t\tdrm_dev_exit(idx);\n\t}  else {\n\t\tret = -ENODEV;\n\t}\nout:\n\tkfree(req);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "connector_state",
        "function_name": "gud_pipe_check",
        "location": {
            "file_path": "drivers/gpu/drm/gud/gud_pipe.c",
            "region": {
                "startLine": 487,
                "startColumn": 7,
                "endColumn": 22
            },
            "context": {
                "startLine": 485,
                "endLine": 489,
                "snippet": {
                    "text": "if (connector_state->crtc)"
                }
            }
        },
        "function_code": "int gud_pipe_check(struct drm_simple_display_pipe *pipe,\n\t\t   struct drm_plane_state *new_plane_state,\n\t\t   struct drm_crtc_state *new_crtc_state)\n{\n\tstruct gud_device *gdrm = to_gud_device(pipe->crtc.dev);\n\tstruct drm_plane_state *old_plane_state = pipe->plane.state;\n\tconst struct drm_display_mode *mode = &new_crtc_state->mode;\n\tstruct drm_atomic_state *state = new_plane_state->state;\n\tstruct drm_framebuffer *old_fb = old_plane_state->fb;\n\tstruct drm_connector_state *connector_state = NULL;\n\tstruct drm_framebuffer *fb = new_plane_state->fb;\n\tconst struct drm_format_info *format = fb->format;\n\tstruct drm_connector *connector;\n\tunsigned int i, num_properties;\n\tstruct gud_state_req *req;\n\tint idx, ret;\n\tsize_t len;\n\n\tif (WARN_ON_ONCE(!fb))\n\t\treturn -EINVAL;\n\n\tif (old_plane_state->rotation != new_plane_state->rotation)\n\t\tnew_crtc_state->mode_changed = true;\n\n\tif (old_fb && old_fb->format != format)\n\t\tnew_crtc_state->mode_changed = true;\n\n\tif (!new_crtc_state->mode_changed && !new_crtc_state->connectors_changed)\n\t\treturn 0;\n\n\t/* Only one connector is supported */\n\tif (hweight32(new_crtc_state->connector_mask) != 1)\n\t\treturn -EINVAL;\n\n\tif (format->format == DRM_FORMAT_XRGB8888 && gdrm->xrgb8888_emulation_format)\n\t\tformat = gdrm->xrgb8888_emulation_format;\n\n\tfor_each_new_connector_in_state(state, connector, connector_state, i) {\n\t\tif (connector_state->crtc)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * DRM_IOCTL_MODE_OBJ_SETPROPERTY on the rotation property will not have\n\t * the connector included in the state.\n\t */\n\tif (!connector_state) {\n\t\tstruct drm_connector_list_iter conn_iter;\n\n\t\tdrm_connector_list_iter_begin(pipe->crtc.dev, &conn_iter);\n\t\tdrm_for_each_connector_iter(connector, &conn_iter) {\n\t\t\tif (connector->state->crtc) {\n\t\t\t\tconnector_state = connector->state;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdrm_connector_list_iter_end(&conn_iter);\n\t}\n\n\tif (WARN_ON_ONCE(!connector_state))\n\t\treturn -ENOENT;\n\n\tlen = struct_size(req, properties,\n\t\t\t  size_add(GUD_PROPERTIES_MAX_NUM, GUD_CONNECTOR_PROPERTIES_MAX_NUM));\n\treq = kzalloc(len, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tgud_from_display_mode(&req->mode, mode);\n\n\treq->format = gud_from_fourcc(format->format);\n\tif (WARN_ON_ONCE(!req->format)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\treq->connector = drm_connector_index(connector_state->connector);\n\n\tret = gud_connector_fill_properties(connector_state, req->properties);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnum_properties = ret;\n\tfor (i = 0; i < gdrm->num_properties; i++) {\n\t\tu16 prop = gdrm->properties[i];\n\t\tu64 val;\n\n\t\tswitch (prop) {\n\t\tcase GUD_PROPERTY_ROTATION:\n\t\t\t/* DRM UAPI matches the protocol so use value directly */\n\t\t\tval = new_plane_state->rotation;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\treq->properties[num_properties + i].prop = cpu_to_le16(prop);\n\t\treq->properties[num_properties + i].val = cpu_to_le64(val);\n\t\tnum_properties++;\n\t}\n\n\tif (drm_dev_enter(fb->dev, &idx)) {\n\t\tlen = struct_size(req, properties, num_properties);\n\t\tret = gud_usb_set(gdrm, GUD_REQ_SET_STATE_CHECK, 0, req, len);\n\t\tdrm_dev_exit(idx);\n\t}  else {\n\t\tret = -ENODEV;\n\t}\nout:\n\tkfree(req);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "fb",
        "function_name": "intel_plane_atomic_check_with_state",
        "location": {
            "file_path": "drivers/gpu/drm/i915/display/intel_atomic_plane.c",
            "region": {
                "startLine": 633,
                "startColumn": 42,
                "endColumn": 44
            },
            "context": {
                "startLine": 631,
                "endLine": 635,
                "snippet": {
                    "text": "intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))"
                }
            }
        },
        "function_code": "int intel_plane_atomic_check_with_state(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\tstruct intel_crtc_state *new_crtc_state,\n\t\t\t\t\tconst struct intel_plane_state *old_plane_state,\n\t\t\t\t\tstruct intel_plane_state *new_plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(new_plane_state->uapi.plane);\n\tconst struct drm_framebuffer *fb = new_plane_state->hw.fb;\n\tint ret;\n\n\tintel_plane_set_invisible(new_crtc_state, new_plane_state);\n\tnew_crtc_state->enabled_planes &= ~BIT(plane->id);\n\n\tif (!new_plane_state->hw.crtc && !old_plane_state->hw.crtc)\n\t\treturn 0;\n\n\tret = plane->check_plane(new_crtc_state, new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fb)\n\t\tnew_crtc_state->enabled_planes |= BIT(plane->id);\n\n\t/* FIXME pre-g4x don't work like this */\n\tif (new_plane_state->uapi.visible)\n\t\tnew_crtc_state->active_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_plane_is_scaled(new_plane_state))\n\t\tnew_crtc_state->scaled_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\tnew_crtc_state->nv12_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    fb->format->format == DRM_FORMAT_C8)\n\t\tnew_crtc_state->c8_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible || old_plane_state->uapi.visible)\n\t\tnew_crtc_state->update_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier)) {\n\t\tnew_crtc_state->data_rate_y[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 0);\n\t\tnew_crtc_state->data_rate[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 1);\n\n\t\tnew_crtc_state->rel_data_rate_y[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 0);\n\t\tnew_crtc_state->rel_data_rate[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 1);\n\t} else if (new_plane_state->uapi.visible) {\n\t\tnew_crtc_state->data_rate[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 0);\n\n\t\tnew_crtc_state->rel_data_rate[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 0);\n\t}\n\n\treturn intel_plane_atomic_calc_changes(old_crtc_state, new_crtc_state,\n\t\t\t\t\t       old_plane_state, new_plane_state);\n}"
    },
    {
        "var_name": "fb",
        "function_name": "intel_plane_atomic_check_with_state",
        "location": {
            "file_path": "drivers/gpu/drm/i915/display/intel_atomic_plane.c",
            "region": {
                "startLine": 637,
                "startColumn": 6,
                "endColumn": 8
            },
            "context": {
                "startLine": 635,
                "endLine": 639,
                "snippet": {
                    "text": "fb->format->format == DRM_FORMAT_C8)"
                }
            }
        },
        "function_code": "int intel_plane_atomic_check_with_state(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\tstruct intel_crtc_state *new_crtc_state,\n\t\t\t\t\tconst struct intel_plane_state *old_plane_state,\n\t\t\t\t\tstruct intel_plane_state *new_plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(new_plane_state->uapi.plane);\n\tconst struct drm_framebuffer *fb = new_plane_state->hw.fb;\n\tint ret;\n\n\tintel_plane_set_invisible(new_crtc_state, new_plane_state);\n\tnew_crtc_state->enabled_planes &= ~BIT(plane->id);\n\n\tif (!new_plane_state->hw.crtc && !old_plane_state->hw.crtc)\n\t\treturn 0;\n\n\tret = plane->check_plane(new_crtc_state, new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fb)\n\t\tnew_crtc_state->enabled_planes |= BIT(plane->id);\n\n\t/* FIXME pre-g4x don't work like this */\n\tif (new_plane_state->uapi.visible)\n\t\tnew_crtc_state->active_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_plane_is_scaled(new_plane_state))\n\t\tnew_crtc_state->scaled_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\tnew_crtc_state->nv12_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    fb->format->format == DRM_FORMAT_C8)\n\t\tnew_crtc_state->c8_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible || old_plane_state->uapi.visible)\n\t\tnew_crtc_state->update_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier)) {\n\t\tnew_crtc_state->data_rate_y[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 0);\n\t\tnew_crtc_state->data_rate[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 1);\n\n\t\tnew_crtc_state->rel_data_rate_y[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 0);\n\t\tnew_crtc_state->rel_data_rate[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 1);\n\t} else if (new_plane_state->uapi.visible) {\n\t\tnew_crtc_state->data_rate[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 0);\n\n\t\tnew_crtc_state->rel_data_rate[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 0);\n\t}\n\n\treturn intel_plane_atomic_calc_changes(old_crtc_state, new_crtc_state,\n\t\t\t\t\t       old_plane_state, new_plane_state);\n}"
    },
    {
        "var_name": "fb",
        "function_name": "intel_plane_atomic_check_with_state",
        "location": {
            "file_path": "drivers/gpu/drm/i915/display/intel_atomic_plane.c",
            "region": {
                "startLine": 644,
                "startColumn": 42,
                "endColumn": 44
            },
            "context": {
                "startLine": 642,
                "endLine": 646,
                "snippet": {
                    "text": "intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier)) {"
                }
            }
        },
        "function_code": "int intel_plane_atomic_check_with_state(const struct intel_crtc_state *old_crtc_state,\n\t\t\t\t\tstruct intel_crtc_state *new_crtc_state,\n\t\t\t\t\tconst struct intel_plane_state *old_plane_state,\n\t\t\t\t\tstruct intel_plane_state *new_plane_state)\n{\n\tstruct intel_plane *plane = to_intel_plane(new_plane_state->uapi.plane);\n\tconst struct drm_framebuffer *fb = new_plane_state->hw.fb;\n\tint ret;\n\n\tintel_plane_set_invisible(new_crtc_state, new_plane_state);\n\tnew_crtc_state->enabled_planes &= ~BIT(plane->id);\n\n\tif (!new_plane_state->hw.crtc && !old_plane_state->hw.crtc)\n\t\treturn 0;\n\n\tret = plane->check_plane(new_crtc_state, new_plane_state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fb)\n\t\tnew_crtc_state->enabled_planes |= BIT(plane->id);\n\n\t/* FIXME pre-g4x don't work like this */\n\tif (new_plane_state->uapi.visible)\n\t\tnew_crtc_state->active_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_plane_is_scaled(new_plane_state))\n\t\tnew_crtc_state->scaled_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\tnew_crtc_state->nv12_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    fb->format->format == DRM_FORMAT_C8)\n\t\tnew_crtc_state->c8_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible || old_plane_state->uapi.visible)\n\t\tnew_crtc_state->update_planes |= BIT(plane->id);\n\n\tif (new_plane_state->uapi.visible &&\n\t    intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier)) {\n\t\tnew_crtc_state->data_rate_y[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 0);\n\t\tnew_crtc_state->data_rate[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 1);\n\n\t\tnew_crtc_state->rel_data_rate_y[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 0);\n\t\tnew_crtc_state->rel_data_rate[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 1);\n\t} else if (new_plane_state->uapi.visible) {\n\t\tnew_crtc_state->data_rate[plane->id] =\n\t\t\tintel_plane_data_rate(new_crtc_state, new_plane_state, 0);\n\n\t\tnew_crtc_state->rel_data_rate[plane->id] =\n\t\t\tintel_plane_relative_data_rate(new_crtc_state,\n\t\t\t\t\t\t       new_plane_state, 0);\n\t}\n\n\treturn intel_plane_atomic_calc_changes(old_crtc_state, new_crtc_state,\n\t\t\t\t\t       old_plane_state, new_plane_state);\n}"
    },
    {
        "var_name": "dmc",
        "function_name": "intel_dmc_debugfs_status_show",
        "location": {
            "file_path": "drivers/gpu/drm/i915/display/intel_dmc.c",
            "region": {
                "startLine": 1173,
                "startColumn": 36,
                "endColumn": 39
            },
            "context": {
                "startLine": 1171,
                "endLine": 1175,
                "snippet": {
                    "text": "seq_printf(m, \"version: %d.%d\\n\", DMC_VERSION_MAJOR(dmc->version),"
                }
            }
        },
        "function_code": "static int intel_dmc_debugfs_status_show(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = m->private;\n\tstruct intel_dmc *dmc = i915_to_dmc(i915);\n\tintel_wakeref_t wakeref;\n\ti915_reg_t dc5_reg, dc6_reg = INVALID_MMIO_REG;\n\n\tif (!HAS_DMC(i915))\n\t\treturn -ENODEV;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\tseq_printf(m, \"DMC initialized: %s\\n\", str_yes_no(dmc));\n\tseq_printf(m, \"fw loaded: %s\\n\",\n\t\t   str_yes_no(intel_dmc_has_payload(i915)));\n\tseq_printf(m, \"path: %s\\n\", dmc ? dmc->fw_path : \"N/A\");\n\tseq_printf(m, \"Pipe A fw needed: %s\\n\",\n\t\t   str_yes_no(DISPLAY_VER(i915) >= 12));\n\tseq_printf(m, \"Pipe A fw loaded: %s\\n\",\n\t\t   str_yes_no(has_dmc_id_fw(i915, DMC_FW_PIPEA)));\n\tseq_printf(m, \"Pipe B fw needed: %s\\n\",\n\t\t   str_yes_no(IS_ALDERLAKE_P(i915) ||\n\t\t\t      DISPLAY_VER(i915) >= 14));\n\tseq_printf(m, \"Pipe B fw loaded: %s\\n\",\n\t\t   str_yes_no(has_dmc_id_fw(i915, DMC_FW_PIPEB)));\n\n\tif (!intel_dmc_has_payload(i915))\n\t\tgoto out;\n\n\tseq_printf(m, \"version: %d.%d\\n\", DMC_VERSION_MAJOR(dmc->version),\n\t\t   DMC_VERSION_MINOR(dmc->version));\n\n\tif (DISPLAY_VER(i915) >= 12) {\n\t\ti915_reg_t dc3co_reg;\n\n\t\tif (IS_DGFX(i915) || DISPLAY_VER(i915) >= 14) {\n\t\t\tdc3co_reg = DG1_DMC_DEBUG3;\n\t\t\tdc5_reg = DG1_DMC_DEBUG_DC5_COUNT;\n\t\t} else {\n\t\t\tdc3co_reg = TGL_DMC_DEBUG3;\n\t\t\tdc5_reg = TGL_DMC_DEBUG_DC5_COUNT;\n\t\t\tdc6_reg = TGL_DMC_DEBUG_DC6_COUNT;\n\t\t}\n\n\t\tseq_printf(m, \"DC3CO count: %d\\n\",\n\t\t\t   intel_de_read(i915, dc3co_reg));\n\t} else {\n\t\tdc5_reg = IS_BROXTON(i915) ? BXT_DMC_DC3_DC5_COUNT :\n\t\t\tSKL_DMC_DC3_DC5_COUNT;\n\t\tif (!IS_GEMINILAKE(i915) && !IS_BROXTON(i915))\n\t\t\tdc6_reg = SKL_DMC_DC5_DC6_COUNT;\n\t}\n\n\tseq_printf(m, \"DC3 -> DC5 count: %d\\n\", intel_de_read(i915, dc5_reg));\n\tif (i915_mmio_reg_valid(dc6_reg))\n\t\tseq_printf(m, \"DC5 -> DC6 count: %d\\n\",\n\t\t\t   intel_de_read(i915, dc6_reg));\n\n\tseq_printf(m, \"program base: 0x%08x\\n\",\n\t\t   intel_de_read(i915, DMC_PROGRAM(dmc->dmc_info[DMC_FW_MAIN].start_mmioaddr, 0)));\n\nout:\n\tseq_printf(m, \"ssp base: 0x%08x\\n\",\n\t\t   intel_de_read(i915, DMC_SSP_BASE));\n\tseq_printf(m, \"htp: 0x%08x\\n\", intel_de_read(i915, DMC_HTP_SKL));\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "dmc",
        "function_name": "intel_dmc_debugfs_status_show",
        "location": {
            "file_path": "drivers/gpu/drm/i915/display/intel_dmc.c",
            "region": {
                "startLine": 1203,
                "startColumn": 26,
                "endColumn": 29
            },
            "context": {
                "startLine": 1201,
                "endLine": 1205,
                "snippet": {
                    "text": "intel_de_read(i915, DMC_PROGRAM(dmc->dmc_info[DMC_FW_MAIN].start_mmioaddr, 0)));"
                }
            }
        },
        "function_code": "static int intel_dmc_debugfs_status_show(struct seq_file *m, void *unused)\n{\n\tstruct drm_i915_private *i915 = m->private;\n\tstruct intel_dmc *dmc = i915_to_dmc(i915);\n\tintel_wakeref_t wakeref;\n\ti915_reg_t dc5_reg, dc6_reg = INVALID_MMIO_REG;\n\n\tif (!HAS_DMC(i915))\n\t\treturn -ENODEV;\n\n\twakeref = intel_runtime_pm_get(&i915->runtime_pm);\n\n\tseq_printf(m, \"DMC initialized: %s\\n\", str_yes_no(dmc));\n\tseq_printf(m, \"fw loaded: %s\\n\",\n\t\t   str_yes_no(intel_dmc_has_payload(i915)));\n\tseq_printf(m, \"path: %s\\n\", dmc ? dmc->fw_path : \"N/A\");\n\tseq_printf(m, \"Pipe A fw needed: %s\\n\",\n\t\t   str_yes_no(DISPLAY_VER(i915) >= 12));\n\tseq_printf(m, \"Pipe A fw loaded: %s\\n\",\n\t\t   str_yes_no(has_dmc_id_fw(i915, DMC_FW_PIPEA)));\n\tseq_printf(m, \"Pipe B fw needed: %s\\n\",\n\t\t   str_yes_no(IS_ALDERLAKE_P(i915) ||\n\t\t\t      DISPLAY_VER(i915) >= 14));\n\tseq_printf(m, \"Pipe B fw loaded: %s\\n\",\n\t\t   str_yes_no(has_dmc_id_fw(i915, DMC_FW_PIPEB)));\n\n\tif (!intel_dmc_has_payload(i915))\n\t\tgoto out;\n\n\tseq_printf(m, \"version: %d.%d\\n\", DMC_VERSION_MAJOR(dmc->version),\n\t\t   DMC_VERSION_MINOR(dmc->version));\n\n\tif (DISPLAY_VER(i915) >= 12) {\n\t\ti915_reg_t dc3co_reg;\n\n\t\tif (IS_DGFX(i915) || DISPLAY_VER(i915) >= 14) {\n\t\t\tdc3co_reg = DG1_DMC_DEBUG3;\n\t\t\tdc5_reg = DG1_DMC_DEBUG_DC5_COUNT;\n\t\t} else {\n\t\t\tdc3co_reg = TGL_DMC_DEBUG3;\n\t\t\tdc5_reg = TGL_DMC_DEBUG_DC5_COUNT;\n\t\t\tdc6_reg = TGL_DMC_DEBUG_DC6_COUNT;\n\t\t}\n\n\t\tseq_printf(m, \"DC3CO count: %d\\n\",\n\t\t\t   intel_de_read(i915, dc3co_reg));\n\t} else {\n\t\tdc5_reg = IS_BROXTON(i915) ? BXT_DMC_DC3_DC5_COUNT :\n\t\t\tSKL_DMC_DC3_DC5_COUNT;\n\t\tif (!IS_GEMINILAKE(i915) && !IS_BROXTON(i915))\n\t\t\tdc6_reg = SKL_DMC_DC5_DC6_COUNT;\n\t}\n\n\tseq_printf(m, \"DC3 -> DC5 count: %d\\n\", intel_de_read(i915, dc5_reg));\n\tif (i915_mmio_reg_valid(dc6_reg))\n\t\tseq_printf(m, \"DC5 -> DC6 count: %d\\n\",\n\t\t\t   intel_de_read(i915, dc6_reg));\n\n\tseq_printf(m, \"program base: 0x%08x\\n\",\n\t\t   intel_de_read(i915, DMC_PROGRAM(dmc->dmc_info[DMC_FW_MAIN].start_mmioaddr, 0)));\n\nout:\n\tseq_printf(m, \"ssp base: 0x%08x\\n\",\n\t\t   intel_de_read(i915, DMC_SSP_BASE));\n\tseq_printf(m, \"htp: 0x%08x\\n\", intel_de_read(i915, DMC_HTP_SKL));\n\n\tintel_runtime_pm_put(&i915->runtime_pm, wakeref);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "fb",
        "function_name": "skl_update_scaler_plane",
        "location": {
            "file_path": "drivers/gpu/drm/i915/display/skl_scaler.c",
            "region": {
                "startLine": 307,
                "startColumn": 10,
                "endColumn": 12
            },
            "context": {
                "startLine": 305,
                "endLine": 309,
                "snippet": {
                    "text": "switch (fb->format->format) {"
                }
            }
        },
        "function_code": "int skl_update_scaler_plane(struct intel_crtc_state *crtc_state,\n\t\t\t    struct intel_plane_state *plane_state)\n{\n\tstruct intel_plane *intel_plane =\n\t\tto_intel_plane(plane_state->uapi.plane);\n\tstruct drm_i915_private *dev_priv = to_i915(intel_plane->base.dev);\n\tstruct drm_framebuffer *fb = plane_state->hw.fb;\n\tint ret;\n\tbool force_detach = !fb || !plane_state->uapi.visible;\n\tbool need_scaler = false;\n\n\t/* Pre-gen11 and SDR planes always need a scaler for planar formats. */\n\tif (!icl_is_hdr_plane(dev_priv, intel_plane->id) &&\n\t    fb && intel_format_info_is_yuv_semiplanar(fb->format, fb->modifier))\n\t\tneed_scaler = true;\n\n\tret = skl_update_scaler(crtc_state, force_detach,\n\t\t\t\tdrm_plane_index(&intel_plane->base),\n\t\t\t\t&plane_state->scaler_id,\n\t\t\t\tdrm_rect_width(&plane_state->uapi.src) >> 16,\n\t\t\t\tdrm_rect_height(&plane_state->uapi.src) >> 16,\n\t\t\t\tdrm_rect_width(&plane_state->uapi.dst),\n\t\t\t\tdrm_rect_height(&plane_state->uapi.dst),\n\t\t\t\tfb ? fb->format : NULL,\n\t\t\t\tfb ? fb->modifier : 0,\n\t\t\t\tneed_scaler);\n\n\tif (ret || plane_state->scaler_id < 0)\n\t\treturn ret;\n\n\t/* check colorkey */\n\tif (plane_state->ckey.flags) {\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[PLANE:%d:%s] scaling with color key not allowed\",\n\t\t\t    intel_plane->base.base.id,\n\t\t\t    intel_plane->base.name);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Check src format */\n\tswitch (fb->format->format) {\n\tcase DRM_FORMAT_RGB565:\n\tcase DRM_FORMAT_XBGR8888:\n\tcase DRM_FORMAT_XRGB8888:\n\tcase DRM_FORMAT_ABGR8888:\n\tcase DRM_FORMAT_ARGB8888:\n\tcase DRM_FORMAT_XRGB2101010:\n\tcase DRM_FORMAT_XBGR2101010:\n\tcase DRM_FORMAT_ARGB2101010:\n\tcase DRM_FORMAT_ABGR2101010:\n\tcase DRM_FORMAT_YUYV:\n\tcase DRM_FORMAT_YVYU:\n\tcase DRM_FORMAT_UYVY:\n\tcase DRM_FORMAT_VYUY:\n\tcase DRM_FORMAT_NV12:\n\tcase DRM_FORMAT_XYUV8888:\n\tcase DRM_FORMAT_P010:\n\tcase DRM_FORMAT_P012:\n\tcase DRM_FORMAT_P016:\n\tcase DRM_FORMAT_Y210:\n\tcase DRM_FORMAT_Y212:\n\tcase DRM_FORMAT_Y216:\n\tcase DRM_FORMAT_XVYU2101010:\n\tcase DRM_FORMAT_XVYU12_16161616:\n\tcase DRM_FORMAT_XVYU16161616:\n\t\tbreak;\n\tcase DRM_FORMAT_XBGR16161616F:\n\tcase DRM_FORMAT_ABGR16161616F:\n\tcase DRM_FORMAT_XRGB16161616F:\n\tcase DRM_FORMAT_ARGB16161616F:\n\t\tif (DISPLAY_VER(dev_priv) >= 11)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tdrm_dbg_kms(&dev_priv->drm,\n\t\t\t    \"[PLANE:%d:%s] FB:%d unsupported scaling format 0x%x\\n\",\n\t\t\t    intel_plane->base.base.id, intel_plane->base.name,\n\t\t\t    fb->base.id, fb->format->format);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "dst_reg",
        "function_name": "i915_ttm_memcpy_init",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gem/i915_gem_ttm_move.c",
            "region": {
                "startLine": 327,
                "startColumn": 25,
                "endColumn": 32
            },
            "context": {
                "startLine": 325,
                "endLine": 329,
                "snippet": {
                    "text": "&dst_rsgt->table, dst_reg->region.start);"
                }
            }
        },
        "function_code": "static void i915_ttm_memcpy_init(struct i915_ttm_memcpy_arg *arg,\n\t\t\t\t struct ttm_buffer_object *bo, bool clear,\n\t\t\t\t struct ttm_resource *dst_mem,\n\t\t\t\t struct ttm_tt *dst_ttm,\n\t\t\t\t struct i915_refct_sgt *dst_rsgt)\n{\n\tstruct drm_i915_gem_object *obj = i915_ttm_to_gem(bo);\n\tstruct intel_memory_region *dst_reg, *src_reg;\n\n\tdst_reg = i915_ttm_region(bo->bdev, dst_mem->mem_type);\n\tsrc_reg = i915_ttm_region(bo->bdev, bo->resource->mem_type);\n\tGEM_BUG_ON(!dst_reg || !src_reg);\n\n\targ->dst_iter = !i915_ttm_cpu_maps_iomem(dst_mem) ?\n\t\tttm_kmap_iter_tt_init(&arg->_dst_iter.tt, dst_ttm) :\n\t\tttm_kmap_iter_iomap_init(&arg->_dst_iter.io, &dst_reg->iomap,\n\t\t\t\t\t &dst_rsgt->table, dst_reg->region.start);\n\n\targ->src_iter = !i915_ttm_cpu_maps_iomem(bo->resource) ?\n\t\tttm_kmap_iter_tt_init(&arg->_src_iter.tt, bo->ttm) :\n\t\tttm_kmap_iter_iomap_init(&arg->_src_iter.io, &src_reg->iomap,\n\t\t\t\t\t &obj->ttm.cached_io_rsgt->table,\n\t\t\t\t\t src_reg->region.start);\n\targ->clear = clear;\n\targ->num_pages = bo->base.size >> PAGE_SHIFT;\n\n\targ->dst_rsgt = i915_refct_sgt_get(dst_rsgt);\n\targ->src_rsgt = clear ? NULL :\n\t\ti915_ttm_resource_get_st(obj, bo->resource);\n}"
    },
    {
        "var_name": "src_reg",
        "function_name": "i915_ttm_memcpy_init",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gem/i915_gem_ttm_move.c",
            "region": {
                "startLine": 333,
                "startColumn": 7,
                "endColumn": 14
            },
            "context": {
                "startLine": 331,
                "endLine": 335,
                "snippet": {
                    "text": "src_reg->region.start);"
                }
            }
        },
        "function_code": "static void i915_ttm_memcpy_init(struct i915_ttm_memcpy_arg *arg,\n\t\t\t\t struct ttm_buffer_object *bo, bool clear,\n\t\t\t\t struct ttm_resource *dst_mem,\n\t\t\t\t struct ttm_tt *dst_ttm,\n\t\t\t\t struct i915_refct_sgt *dst_rsgt)\n{\n\tstruct drm_i915_gem_object *obj = i915_ttm_to_gem(bo);\n\tstruct intel_memory_region *dst_reg, *src_reg;\n\n\tdst_reg = i915_ttm_region(bo->bdev, dst_mem->mem_type);\n\tsrc_reg = i915_ttm_region(bo->bdev, bo->resource->mem_type);\n\tGEM_BUG_ON(!dst_reg || !src_reg);\n\n\targ->dst_iter = !i915_ttm_cpu_maps_iomem(dst_mem) ?\n\t\tttm_kmap_iter_tt_init(&arg->_dst_iter.tt, dst_ttm) :\n\t\tttm_kmap_iter_iomap_init(&arg->_dst_iter.io, &dst_reg->iomap,\n\t\t\t\t\t &dst_rsgt->table, dst_reg->region.start);\n\n\targ->src_iter = !i915_ttm_cpu_maps_iomem(bo->resource) ?\n\t\tttm_kmap_iter_tt_init(&arg->_src_iter.tt, bo->ttm) :\n\t\tttm_kmap_iter_iomap_init(&arg->_src_iter.io, &src_reg->iomap,\n\t\t\t\t\t &obj->ttm.cached_io_rsgt->table,\n\t\t\t\t\t src_reg->region.start);\n\targ->clear = clear;\n\targ->num_pages = bo->base.size >> PAGE_SHIFT;\n\n\targ->dst_rsgt = i915_refct_sgt_get(dst_rsgt);\n\targ->src_rsgt = clear ? NULL :\n\t\ti915_ttm_resource_get_st(obj, bo->resource);\n}"
    },
    {
        "var_name": "dst_mr",
        "function_name": "igt_create_migrate",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gem/selftests/i915_gem_migrate.c",
            "region": {
                "startLine": 60,
                "startColumn": 46,
                "endColumn": 52
            },
            "context": {
                "startLine": 58,
                "endLine": 62,
                "snippet": {
                    "text": "obj = i915_gem_object_create_region(src_mr, dst_mr->min_page_size, 0, 0);"
                }
            }
        },
        "function_code": "static int igt_create_migrate(struct intel_gt *gt, enum intel_region_id src,\n\t\t\t      enum intel_region_id dst)\n{\n\tstruct drm_i915_private *i915 = gt->i915;\n\tstruct intel_memory_region *src_mr = i915->mm.regions[src];\n\tstruct intel_memory_region *dst_mr = i915->mm.regions[dst];\n\tstruct drm_i915_gem_object *obj;\n\tstruct i915_gem_ww_ctx ww;\n\tint err = 0;\n\n\tGEM_BUG_ON(!src_mr);\n\tGEM_BUG_ON(!dst_mr);\n\n\t/* Switch object backing-store on create */\n\tobj = i915_gem_object_create_region(src_mr, dst_mr->min_page_size, 0, 0);\n\tif (IS_ERR(obj))\n\t\treturn PTR_ERR(obj);\n\n\tfor_i915_gem_ww(&ww, err, true) {\n\t\terr = i915_gem_object_lock(obj, &ww);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\terr = igt_fill_check_buffer(obj, gt, true);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\terr = i915_gem_object_migrate(obj, &ww, dst);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\terr = i915_gem_object_pin_pages(obj);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tif (i915_gem_object_can_migrate(obj, src))\n\t\t\terr = -EINVAL;\n\n\t\ti915_gem_object_unpin_pages(obj);\n\t\terr = i915_gem_object_wait_migration(obj, true);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\terr = igt_fill_check_buffer(obj, gt, false);\n\t}\n\ti915_gem_object_put(obj);\n\n\treturn err;\n}"
    },
    {
        "var_name": "ce",
        "function_name": "gen8_ggtt_bind_get_ce",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/intel_ggtt.c",
            "region": {
                "startLine": 321,
                "startColumn": 22,
                "endColumn": 24
            },
            "context": {
                "startLine": 319,
                "endLine": 323,
                "snippet": {
                    "text": "intel_engine_pm_get(ce->engine);"
                }
            }
        },
        "function_code": "static struct intel_context *gen8_ggtt_bind_get_ce(struct i915_ggtt *ggtt, intel_wakeref_t *wakeref)\n{\n\tstruct intel_context *ce;\n\tstruct intel_gt *gt = ggtt->vm.gt;\n\n\tif (intel_gt_is_wedged(gt))\n\t\treturn NULL;\n\n\tce = gt->engine[BCS0]->bind_context;\n\tGEM_BUG_ON(!ce);\n\n\t/*\n\t * If the GT is not awake already at this stage then fallback\n\t * to pci based GGTT update otherwise __intel_wakeref_get_first()\n\t * would conflict with fs_reclaim trying to allocate memory while\n\t * doing rpm_resume().\n\t */\n\t*wakeref = intel_gt_pm_get_if_awake(gt);\n\tif (!*wakeref)\n\t\treturn NULL;\n\n\tintel_engine_pm_get(ce->engine);\n\n\treturn ce;\n}"
    },
    {
        "var_name": "tlbinv",
        "function_name": "pte_tlbinv",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/selftest_tlb.c",
            "region": {
                "startLine": 171,
                "startColumn": 3,
                "endColumn": 9
            },
            "context": {
                "startLine": 169,
                "endLine": 173,
                "snippet": {
                    "text": "tlbinv(ce->vm, addr & -length, length);"
                }
            }
        },
        "function_code": "static int\npte_tlbinv(struct intel_context *ce,\n\t   struct i915_vma *va,\n\t   struct i915_vma *vb,\n\t   u64 align,\n\t   void (*tlbinv)(struct i915_address_space *vm, u64 addr, u64 length),\n\t   u64 length,\n\t   struct rnd_state *prng)\n{\n\tconst unsigned int pat_index =\n\t\ti915_gem_get_pat_index(ce->vm->i915, I915_CACHE_NONE);\n\tstruct drm_i915_gem_object *batch;\n\tstruct drm_mm_node vb_node;\n\tstruct i915_request *rq;\n\tstruct i915_vma *vma;\n\tu64 addr;\n\tint err;\n\tu32 *cs;\n\n\tbatch = i915_gem_object_create_internal(ce->vm->i915, 4096);\n\tif (IS_ERR(batch))\n\t\treturn PTR_ERR(batch);\n\n\tvma = i915_vma_instance(batch, ce->vm, NULL);\n\tif (IS_ERR(vma)) {\n\t\terr = PTR_ERR(vma);\n\t\tgoto out;\n\t}\n\n\terr = i915_vma_pin(vma, 0, 0, PIN_USER);\n\tif (err)\n\t\tgoto out;\n\n\t/* Pin va at random but aligned offset after vma */\n\taddr = round_up(vma->node.start + vma->node.size, align);\n\t/* MI_CONDITIONAL_BATCH_BUFFER_END limits address to 48b */\n\taddr = igt_random_offset(prng, addr, min(ce->vm->total, BIT_ULL(48)),\n\t\t\t\t va->size, align);\n\terr = i915_vma_pin(va,  0, 0, addr | PIN_OFFSET_FIXED | PIN_USER);\n\tif (err) {\n\t\tpr_err(\"Cannot pin at %llx+%llx\\n\", addr, va->size);\n\t\tgoto out;\n\t}\n\tGEM_BUG_ON(i915_vma_offset(va) != addr);\n\tif (vb != va) {\n\t\tvb_node = vb->node;\n\t\tvb->node = va->node; /* overwrites the _same_ PTE  */\n\t}\n\n\t/*\n\t * Now choose random dword at the 1st pinned page.\n\t *\n\t * SZ_64K pages on dg1 require that the whole PT be marked\n\t * containing 64KiB entries. So we make sure that vma\n\t * covers the whole PT, despite being randomly aligned to 64KiB\n\t * and restrict our sampling to the 2MiB PT within where\n\t * we know that we will be using 64KiB pages.\n\t */\n\tif (align == SZ_64K)\n\t\taddr = round_up(addr, SZ_2M);\n\taddr = igt_random_offset(prng, addr, addr + align, 8, 8);\n\n\tif (va != vb)\n\t\tpr_info(\"%s(%s): Sampling %llx, with alignment %llx, using PTE size %x (phys %x, sg %x), invalidate:%llx+%llx\\n\",\n\t\t\tce->engine->name, va->obj->mm.region->name ?: \"smem\",\n\t\t\taddr, align, va->resource->page_sizes_gtt,\n\t\t\tva->page_sizes.phys, va->page_sizes.sg,\n\t\t\taddr & -length, length);\n\n\tcs = i915_gem_object_pin_map_unlocked(batch, I915_MAP_WC);\n\t*cs++ = MI_NOOP; /* for later termination */\n\t/*\n\t * Sample the target to see if we spot the updated backing store.\n\t * Gen8 VCS compares immediate value with bitwise-and of two\n\t * consecutive DWORDS pointed by addr, other gen/engines compare value\n\t * with DWORD pointed by addr. Moreover we want to exercise DWORD size\n\t * invalidations. To fulfill all these requirements below values\n\t * have been chosen.\n\t */\n\t*cs++ = MI_CONDITIONAL_BATCH_BUFFER_END | MI_DO_COMPARE | 2;\n\t*cs++ = 0; /* break if *addr == 0 */\n\t*cs++ = lower_32_bits(addr);\n\t*cs++ = upper_32_bits(addr);\n\tvma_set_qw(va, addr, -1);\n\tvma_set_qw(vb, addr, 0);\n\n\t/* Keep sampling until we get bored */\n\t*cs++ = MI_BATCH_BUFFER_START | BIT(8) | 1;\n\t*cs++ = lower_32_bits(i915_vma_offset(vma));\n\t*cs++ = upper_32_bits(i915_vma_offset(vma));\n\n\ti915_gem_object_flush_map(batch);\n\n\trq = i915_request_create(ce);\n\tif (IS_ERR(rq)) {\n\t\terr = PTR_ERR(rq);\n\t\tgoto out_va;\n\t}\n\n\terr = rq->engine->emit_bb_start(rq, i915_vma_offset(vma), 0, 0);\n\tif (err) {\n\t\ti915_request_add(rq);\n\t\tgoto out_va;\n\t}\n\n\ti915_request_get(rq);\n\ti915_request_add(rq);\n\n\t/*\n\t * Short sleep to sanitycheck the batch is spinning before we begin.\n\t * FIXME: Why is GSC so slow?\n\t */\n\tif (ce->engine->class == OTHER_CLASS)\n\t\tmsleep(200);\n\telse\n\t\tmsleep(10);\n\n\tif (va == vb) {\n\t\tif (!i915_request_completed(rq)) {\n\t\t\tpr_err(\"%s(%s): Semaphore sanitycheck failed %llx, with alignment %llx, using PTE size %x (phys %x, sg %x)\\n\",\n\t\t\t       ce->engine->name, va->obj->mm.region->name ?: \"smem\",\n\t\t\t       addr, align, va->resource->page_sizes_gtt,\n\t\t\t       va->page_sizes.phys, va->page_sizes.sg);\n\t\t\terr = -EIO;\n\t\t}\n\t} else if (!i915_request_completed(rq)) {\n\t\tstruct i915_vma_resource vb_res = {\n\t\t\t.bi.pages = vb->obj->mm.pages,\n\t\t\t.bi.page_sizes = vb->obj->mm.page_sizes,\n\t\t\t.start = i915_vma_offset(vb),\n\t\t\t.vma_size = i915_vma_size(vb)\n\t\t};\n\t\tunsigned int pte_flags = 0;\n\n\t\t/* Flip the PTE between A and B */\n\t\tif (i915_gem_object_is_lmem(vb->obj))\n\t\t\tpte_flags |= PTE_LM;\n\t\tce->vm->insert_entries(ce->vm, &vb_res, pat_index, pte_flags);\n\n\t\t/* Flush the PTE update to concurrent HW */\n\t\ttlbinv(ce->vm, addr & -length, length);\n\n\t\tif (wait_for(i915_request_completed(rq), HZ / 2)) {\n\t\t\tpr_err(\"%s: Request did not complete; the COND_BBE did not read the updated PTE\\n\",\n\t\t\t       ce->engine->name);\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\tpr_err(\"Spinner ended unexpectedly\\n\");\n\t\terr = -EIO;\n\t}\n\ti915_request_put(rq);\n\n\tcs = page_mask_bits(batch->mm.mapping);\n\t*cs = MI_BATCH_BUFFER_END;\n\twmb();\n\nout_va:\n\tif (vb != va)\n\t\tvb->node = vb_node;\n\ti915_vma_unpin(va);\n\tif (i915_vma_unbind_unlocked(va))\n\t\terr = -EIO;\nout:\n\ti915_gem_object_put(batch);\n\treturn err;\n}"
    },
    {
        "var_name": "desc",
        "function_name": "guc_context_policy_init_v69",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c",
            "region": {
                "startLine": 2697,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2695,
                "endLine": 2699,
                "snippet": {
                    "text": "desc->policy_flags = 0;"
                }
            }
        },
        "function_code": "static void guc_context_policy_init_v69(struct intel_engine_cs *engine,\n\t\t\t\t\tstruct guc_lrc_desc_v69 *desc)\n{\n\tdesc->policy_flags = 0;\n\n\tif (engine->flags & I915_ENGINE_WANT_FORCED_PREEMPTION)\n\t\tdesc->policy_flags |= CONTEXT_POLICY_FLAG_PREEMPT_TO_IDLE_V69;\n\n\t/* NB: For both of these, zero means disabled. */\n\tGEM_BUG_ON(overflows_type(engine->props.timeslice_duration_ms * 1000,\n\t\t\t\t  desc->execution_quantum));\n\tGEM_BUG_ON(overflows_type(engine->props.preempt_timeout_ms * 1000,\n\t\t\t\t  desc->preemption_timeout));\n\tdesc->execution_quantum = engine->props.timeslice_duration_ms * 1000;\n\tdesc->preemption_timeout = engine->props.preempt_timeout_ms * 1000;\n}"
    },
    {
        "var_name": "desc",
        "function_name": "prepare_context_registration_info_v69",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c",
            "region": {
                "startLine": 2750,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2748,
                "endLine": 2752,
                "snippet": {
                    "text": "desc->engine_class = engine_class_to_guc_class(engine->class);"
                }
            }
        },
        "function_code": "static void prepare_context_registration_info_v69(struct intel_context *ce)\n{\n\tstruct intel_engine_cs *engine = ce->engine;\n\tstruct intel_guc *guc = &engine->gt->uc.guc;\n\tu32 ctx_id = ce->guc_id.id;\n\tstruct guc_lrc_desc_v69 *desc;\n\tstruct intel_context *child;\n\n\tGEM_BUG_ON(!engine->mask);\n\n\t/*\n\t * Ensure LRC + CT vmas are is same region as write barrier is done\n\t * based on CT vma region.\n\t */\n\tGEM_BUG_ON(i915_gem_object_is_lmem(guc->ct.vma->obj) !=\n\t\t   i915_gem_object_is_lmem(ce->ring->vma->obj));\n\n\tdesc = __get_lrc_desc_v69(guc, ctx_id);\n\tGEM_BUG_ON(!desc);\n\tdesc->engine_class = engine_class_to_guc_class(engine->class);\n\tdesc->engine_submit_mask = engine->logical_mask;\n\tdesc->hw_context_desc = ce->lrc.lrca;\n\tdesc->priority = ce->guc_state.prio;\n\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\tguc_context_policy_init_v69(engine, desc);\n\n\t/*\n\t * If context is a parent, we need to register a process descriptor\n\t * describing a work queue and register all child contexts.\n\t */\n\tif (intel_context_is_parent(ce)) {\n\t\tstruct guc_process_desc_v69 *pdesc;\n\n\t\tce->parallel.guc.wqi_tail = 0;\n\t\tce->parallel.guc.wqi_head = 0;\n\n\t\tdesc->process_desc = i915_ggtt_offset(ce->state) +\n\t\t\t__get_parent_scratch_offset(ce);\n\t\tdesc->wq_addr = i915_ggtt_offset(ce->state) +\n\t\t\t__get_wq_offset(ce);\n\t\tdesc->wq_size = WQ_SIZE;\n\n\t\tpdesc = __get_process_desc_v69(ce);\n\t\tmemset(pdesc, 0, sizeof(*(pdesc)));\n\t\tpdesc->stage_id = ce->guc_id.id;\n\t\tpdesc->wq_base_addr = desc->wq_addr;\n\t\tpdesc->wq_size_bytes = desc->wq_size;\n\t\tpdesc->wq_status = WQ_STATUS_ACTIVE;\n\n\t\tce->parallel.guc.wq_head = &pdesc->head;\n\t\tce->parallel.guc.wq_tail = &pdesc->tail;\n\t\tce->parallel.guc.wq_status = &pdesc->wq_status;\n\n\t\tfor_each_child(ce, child) {\n\t\t\tdesc = __get_lrc_desc_v69(guc, child->guc_id.id);\n\n\t\t\tdesc->engine_class =\n\t\t\t\tengine_class_to_guc_class(engine->class);\n\t\t\tdesc->hw_context_desc = child->lrc.lrca;\n\t\t\tdesc->priority = ce->guc_state.prio;\n\t\t\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\t\t\tguc_context_policy_init_v69(engine, desc);\n\t\t}\n\n\t\tclear_children_join_go_memory(ce);\n\t}\n}"
    },
    {
        "var_name": "desc",
        "function_name": "prepare_context_registration_info_v69",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c",
            "region": {
                "startLine": 2751,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2749,
                "endLine": 2753,
                "snippet": {
                    "text": "desc->engine_submit_mask = engine->logical_mask;"
                }
            }
        },
        "function_code": "static void prepare_context_registration_info_v69(struct intel_context *ce)\n{\n\tstruct intel_engine_cs *engine = ce->engine;\n\tstruct intel_guc *guc = &engine->gt->uc.guc;\n\tu32 ctx_id = ce->guc_id.id;\n\tstruct guc_lrc_desc_v69 *desc;\n\tstruct intel_context *child;\n\n\tGEM_BUG_ON(!engine->mask);\n\n\t/*\n\t * Ensure LRC + CT vmas are is same region as write barrier is done\n\t * based on CT vma region.\n\t */\n\tGEM_BUG_ON(i915_gem_object_is_lmem(guc->ct.vma->obj) !=\n\t\t   i915_gem_object_is_lmem(ce->ring->vma->obj));\n\n\tdesc = __get_lrc_desc_v69(guc, ctx_id);\n\tGEM_BUG_ON(!desc);\n\tdesc->engine_class = engine_class_to_guc_class(engine->class);\n\tdesc->engine_submit_mask = engine->logical_mask;\n\tdesc->hw_context_desc = ce->lrc.lrca;\n\tdesc->priority = ce->guc_state.prio;\n\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\tguc_context_policy_init_v69(engine, desc);\n\n\t/*\n\t * If context is a parent, we need to register a process descriptor\n\t * describing a work queue and register all child contexts.\n\t */\n\tif (intel_context_is_parent(ce)) {\n\t\tstruct guc_process_desc_v69 *pdesc;\n\n\t\tce->parallel.guc.wqi_tail = 0;\n\t\tce->parallel.guc.wqi_head = 0;\n\n\t\tdesc->process_desc = i915_ggtt_offset(ce->state) +\n\t\t\t__get_parent_scratch_offset(ce);\n\t\tdesc->wq_addr = i915_ggtt_offset(ce->state) +\n\t\t\t__get_wq_offset(ce);\n\t\tdesc->wq_size = WQ_SIZE;\n\n\t\tpdesc = __get_process_desc_v69(ce);\n\t\tmemset(pdesc, 0, sizeof(*(pdesc)));\n\t\tpdesc->stage_id = ce->guc_id.id;\n\t\tpdesc->wq_base_addr = desc->wq_addr;\n\t\tpdesc->wq_size_bytes = desc->wq_size;\n\t\tpdesc->wq_status = WQ_STATUS_ACTIVE;\n\n\t\tce->parallel.guc.wq_head = &pdesc->head;\n\t\tce->parallel.guc.wq_tail = &pdesc->tail;\n\t\tce->parallel.guc.wq_status = &pdesc->wq_status;\n\n\t\tfor_each_child(ce, child) {\n\t\t\tdesc = __get_lrc_desc_v69(guc, child->guc_id.id);\n\n\t\t\tdesc->engine_class =\n\t\t\t\tengine_class_to_guc_class(engine->class);\n\t\t\tdesc->hw_context_desc = child->lrc.lrca;\n\t\t\tdesc->priority = ce->guc_state.prio;\n\t\t\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\t\t\tguc_context_policy_init_v69(engine, desc);\n\t\t}\n\n\t\tclear_children_join_go_memory(ce);\n\t}\n}"
    },
    {
        "var_name": "desc",
        "function_name": "prepare_context_registration_info_v69",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c",
            "region": {
                "startLine": 2752,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2750,
                "endLine": 2754,
                "snippet": {
                    "text": "desc->hw_context_desc = ce->lrc.lrca;"
                }
            }
        },
        "function_code": "static void prepare_context_registration_info_v69(struct intel_context *ce)\n{\n\tstruct intel_engine_cs *engine = ce->engine;\n\tstruct intel_guc *guc = &engine->gt->uc.guc;\n\tu32 ctx_id = ce->guc_id.id;\n\tstruct guc_lrc_desc_v69 *desc;\n\tstruct intel_context *child;\n\n\tGEM_BUG_ON(!engine->mask);\n\n\t/*\n\t * Ensure LRC + CT vmas are is same region as write barrier is done\n\t * based on CT vma region.\n\t */\n\tGEM_BUG_ON(i915_gem_object_is_lmem(guc->ct.vma->obj) !=\n\t\t   i915_gem_object_is_lmem(ce->ring->vma->obj));\n\n\tdesc = __get_lrc_desc_v69(guc, ctx_id);\n\tGEM_BUG_ON(!desc);\n\tdesc->engine_class = engine_class_to_guc_class(engine->class);\n\tdesc->engine_submit_mask = engine->logical_mask;\n\tdesc->hw_context_desc = ce->lrc.lrca;\n\tdesc->priority = ce->guc_state.prio;\n\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\tguc_context_policy_init_v69(engine, desc);\n\n\t/*\n\t * If context is a parent, we need to register a process descriptor\n\t * describing a work queue and register all child contexts.\n\t */\n\tif (intel_context_is_parent(ce)) {\n\t\tstruct guc_process_desc_v69 *pdesc;\n\n\t\tce->parallel.guc.wqi_tail = 0;\n\t\tce->parallel.guc.wqi_head = 0;\n\n\t\tdesc->process_desc = i915_ggtt_offset(ce->state) +\n\t\t\t__get_parent_scratch_offset(ce);\n\t\tdesc->wq_addr = i915_ggtt_offset(ce->state) +\n\t\t\t__get_wq_offset(ce);\n\t\tdesc->wq_size = WQ_SIZE;\n\n\t\tpdesc = __get_process_desc_v69(ce);\n\t\tmemset(pdesc, 0, sizeof(*(pdesc)));\n\t\tpdesc->stage_id = ce->guc_id.id;\n\t\tpdesc->wq_base_addr = desc->wq_addr;\n\t\tpdesc->wq_size_bytes = desc->wq_size;\n\t\tpdesc->wq_status = WQ_STATUS_ACTIVE;\n\n\t\tce->parallel.guc.wq_head = &pdesc->head;\n\t\tce->parallel.guc.wq_tail = &pdesc->tail;\n\t\tce->parallel.guc.wq_status = &pdesc->wq_status;\n\n\t\tfor_each_child(ce, child) {\n\t\t\tdesc = __get_lrc_desc_v69(guc, child->guc_id.id);\n\n\t\t\tdesc->engine_class =\n\t\t\t\tengine_class_to_guc_class(engine->class);\n\t\t\tdesc->hw_context_desc = child->lrc.lrca;\n\t\t\tdesc->priority = ce->guc_state.prio;\n\t\t\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\t\t\tguc_context_policy_init_v69(engine, desc);\n\t\t}\n\n\t\tclear_children_join_go_memory(ce);\n\t}\n}"
    },
    {
        "var_name": "desc",
        "function_name": "prepare_context_registration_info_v69",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c",
            "region": {
                "startLine": 2753,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2751,
                "endLine": 2755,
                "snippet": {
                    "text": "desc->priority = ce->guc_state.prio;"
                }
            }
        },
        "function_code": "static void prepare_context_registration_info_v69(struct intel_context *ce)\n{\n\tstruct intel_engine_cs *engine = ce->engine;\n\tstruct intel_guc *guc = &engine->gt->uc.guc;\n\tu32 ctx_id = ce->guc_id.id;\n\tstruct guc_lrc_desc_v69 *desc;\n\tstruct intel_context *child;\n\n\tGEM_BUG_ON(!engine->mask);\n\n\t/*\n\t * Ensure LRC + CT vmas are is same region as write barrier is done\n\t * based on CT vma region.\n\t */\n\tGEM_BUG_ON(i915_gem_object_is_lmem(guc->ct.vma->obj) !=\n\t\t   i915_gem_object_is_lmem(ce->ring->vma->obj));\n\n\tdesc = __get_lrc_desc_v69(guc, ctx_id);\n\tGEM_BUG_ON(!desc);\n\tdesc->engine_class = engine_class_to_guc_class(engine->class);\n\tdesc->engine_submit_mask = engine->logical_mask;\n\tdesc->hw_context_desc = ce->lrc.lrca;\n\tdesc->priority = ce->guc_state.prio;\n\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\tguc_context_policy_init_v69(engine, desc);\n\n\t/*\n\t * If context is a parent, we need to register a process descriptor\n\t * describing a work queue and register all child contexts.\n\t */\n\tif (intel_context_is_parent(ce)) {\n\t\tstruct guc_process_desc_v69 *pdesc;\n\n\t\tce->parallel.guc.wqi_tail = 0;\n\t\tce->parallel.guc.wqi_head = 0;\n\n\t\tdesc->process_desc = i915_ggtt_offset(ce->state) +\n\t\t\t__get_parent_scratch_offset(ce);\n\t\tdesc->wq_addr = i915_ggtt_offset(ce->state) +\n\t\t\t__get_wq_offset(ce);\n\t\tdesc->wq_size = WQ_SIZE;\n\n\t\tpdesc = __get_process_desc_v69(ce);\n\t\tmemset(pdesc, 0, sizeof(*(pdesc)));\n\t\tpdesc->stage_id = ce->guc_id.id;\n\t\tpdesc->wq_base_addr = desc->wq_addr;\n\t\tpdesc->wq_size_bytes = desc->wq_size;\n\t\tpdesc->wq_status = WQ_STATUS_ACTIVE;\n\n\t\tce->parallel.guc.wq_head = &pdesc->head;\n\t\tce->parallel.guc.wq_tail = &pdesc->tail;\n\t\tce->parallel.guc.wq_status = &pdesc->wq_status;\n\n\t\tfor_each_child(ce, child) {\n\t\t\tdesc = __get_lrc_desc_v69(guc, child->guc_id.id);\n\n\t\t\tdesc->engine_class =\n\t\t\t\tengine_class_to_guc_class(engine->class);\n\t\t\tdesc->hw_context_desc = child->lrc.lrca;\n\t\t\tdesc->priority = ce->guc_state.prio;\n\t\t\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\t\t\tguc_context_policy_init_v69(engine, desc);\n\t\t}\n\n\t\tclear_children_join_go_memory(ce);\n\t}\n}"
    },
    {
        "var_name": "desc",
        "function_name": "prepare_context_registration_info_v69",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c",
            "region": {
                "startLine": 2754,
                "startColumn": 2,
                "endColumn": 6
            },
            "context": {
                "startLine": 2752,
                "endLine": 2756,
                "snippet": {
                    "text": "desc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;"
                }
            }
        },
        "function_code": "static void prepare_context_registration_info_v69(struct intel_context *ce)\n{\n\tstruct intel_engine_cs *engine = ce->engine;\n\tstruct intel_guc *guc = &engine->gt->uc.guc;\n\tu32 ctx_id = ce->guc_id.id;\n\tstruct guc_lrc_desc_v69 *desc;\n\tstruct intel_context *child;\n\n\tGEM_BUG_ON(!engine->mask);\n\n\t/*\n\t * Ensure LRC + CT vmas are is same region as write barrier is done\n\t * based on CT vma region.\n\t */\n\tGEM_BUG_ON(i915_gem_object_is_lmem(guc->ct.vma->obj) !=\n\t\t   i915_gem_object_is_lmem(ce->ring->vma->obj));\n\n\tdesc = __get_lrc_desc_v69(guc, ctx_id);\n\tGEM_BUG_ON(!desc);\n\tdesc->engine_class = engine_class_to_guc_class(engine->class);\n\tdesc->engine_submit_mask = engine->logical_mask;\n\tdesc->hw_context_desc = ce->lrc.lrca;\n\tdesc->priority = ce->guc_state.prio;\n\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\tguc_context_policy_init_v69(engine, desc);\n\n\t/*\n\t * If context is a parent, we need to register a process descriptor\n\t * describing a work queue and register all child contexts.\n\t */\n\tif (intel_context_is_parent(ce)) {\n\t\tstruct guc_process_desc_v69 *pdesc;\n\n\t\tce->parallel.guc.wqi_tail = 0;\n\t\tce->parallel.guc.wqi_head = 0;\n\n\t\tdesc->process_desc = i915_ggtt_offset(ce->state) +\n\t\t\t__get_parent_scratch_offset(ce);\n\t\tdesc->wq_addr = i915_ggtt_offset(ce->state) +\n\t\t\t__get_wq_offset(ce);\n\t\tdesc->wq_size = WQ_SIZE;\n\n\t\tpdesc = __get_process_desc_v69(ce);\n\t\tmemset(pdesc, 0, sizeof(*(pdesc)));\n\t\tpdesc->stage_id = ce->guc_id.id;\n\t\tpdesc->wq_base_addr = desc->wq_addr;\n\t\tpdesc->wq_size_bytes = desc->wq_size;\n\t\tpdesc->wq_status = WQ_STATUS_ACTIVE;\n\n\t\tce->parallel.guc.wq_head = &pdesc->head;\n\t\tce->parallel.guc.wq_tail = &pdesc->tail;\n\t\tce->parallel.guc.wq_status = &pdesc->wq_status;\n\n\t\tfor_each_child(ce, child) {\n\t\t\tdesc = __get_lrc_desc_v69(guc, child->guc_id.id);\n\n\t\t\tdesc->engine_class =\n\t\t\t\tengine_class_to_guc_class(engine->class);\n\t\t\tdesc->hw_context_desc = child->lrc.lrca;\n\t\t\tdesc->priority = ce->guc_state.prio;\n\t\t\tdesc->context_flags = CONTEXT_REGISTRATION_FLAG_KMD;\n\t\t\tguc_context_policy_init_v69(engine, desc);\n\t\t}\n\n\t\tclear_children_join_go_memory(ce);\n\t}\n}"
    },
    {
        "var_name": "handler",
        "function_name": "intel_vgpu_trigger_virtual_event",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gvt/interrupt.c",
            "region": {
                "startLine": 688,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 686,
                "endLine": 690,
                "snippet": {
                    "text": "handler(irq, event, vgpu);"
                }
            }
        },
        "function_code": "void intel_vgpu_trigger_virtual_event(struct intel_vgpu *vgpu,\n\tenum intel_gvt_event_type event)\n{\n\tstruct drm_i915_private *i915 = vgpu->gvt->gt->i915;\n\tstruct intel_gvt *gvt = vgpu->gvt;\n\tstruct intel_gvt_irq *irq = &gvt->irq;\n\tgvt_event_virt_handler_t handler;\n\tconst struct intel_gvt_irq_ops *ops = gvt->irq.ops;\n\n\thandler = get_event_virt_handler(irq, event);\n\tdrm_WARN_ON(&i915->drm, !handler);\n\n\thandler(irq, event, vgpu);\n\n\tops->check_pending_irq(vgpu);\n}"
    },
    {
        "var_name": "engine",
        "function_name": "create_vcs_context",
        "location": {
            "file_path": "drivers/gpu/drm/i915/pxp/intel_pxp.c",
            "region": {
                "startLine": 100,
                "startColumn": 50,
                "endColumn": 56
            },
            "context": {
                "startLine": 98,
                "endLine": 102,
                "snippet": {
                    "text": "ce = intel_engine_create_pinned_context(engine, engine->gt->vm, SZ_4K,"
                }
            }
        },
        "function_code": "static int create_vcs_context(struct intel_pxp *pxp)\n{\n\tstatic struct lock_class_key pxp_lock;\n\tstruct intel_gt *gt = pxp->ctrl_gt;\n\tstruct intel_engine_cs *engine;\n\tstruct intel_context *ce;\n\tint i;\n\n\t/*\n\t * Find the first VCS engine present. We're guaranteed there is one\n\t * if we're in this function due to the check in has_pxp\n\t */\n\tfor (i = 0, engine = NULL; !engine; i++)\n\t\tengine = gt->engine_class[VIDEO_DECODE_CLASS][i];\n\n\tGEM_BUG_ON(!engine || engine->class != VIDEO_DECODE_CLASS);\n\n\tce = intel_engine_create_pinned_context(engine, engine->gt->vm, SZ_4K,\n\t\t\t\t\t\tI915_GEM_HWS_PXP_ADDR,\n\t\t\t\t\t\t&pxp_lock, \"pxp_context\");\n\tif (IS_ERR(ce)) {\n\t\tdrm_err(&gt->i915->drm, \"failed to create VCS ctx for PXP\\n\");\n\t\treturn PTR_ERR(ce);\n\t}\n\n\tpxp->ce = ce;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "lvds_mux",
        "function_name": "imx_ldb_encoder_enable",
        "location": {
            "file_path": "drivers/gpu/drm/imx/ipuv3/imx-ldb.c",
            "region": {
                "startLine": 243,
                "startColumn": 35,
                "endColumn": 43
            },
            "context": {
                "startLine": 241,
                "endLine": 245,
                "snippet": {
                    "text": "regmap_update_bits(ldb->regmap, lvds_mux->reg, lvds_mux->mask,"
                }
            }
        },
        "function_code": "static void imx_ldb_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\tint mux = drm_of_encoder_active_port_id(imx_ldb_ch->child, encoder);\n\n\tif (mux < 0 || mux >= ARRAY_SIZE(ldb->clk_sel)) {\n\t\tdev_warn(ldb->dev, \"%s: invalid mux %d\\n\", __func__, mux);\n\t\treturn;\n\t}\n\n\tdrm_panel_prepare(imx_ldb_ch->panel);\n\n\tif (dual) {\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[0]);\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[1]);\n\n\t\tclk_prepare_enable(ldb->clk[0]);\n\t\tclk_prepare_enable(ldb->clk[1]);\n\t} else {\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[imx_ldb_ch->chno]);\n\t}\n\n\tif (imx_ldb_ch == &ldb->channel[0] || dual) {\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\t\tif (mux == 0 || ldb->lvds_mux)\n\t\t\tldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI0;\n\t\telse if (mux == 1)\n\t\t\tldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI1;\n\t}\n\tif (imx_ldb_ch == &ldb->channel[1] || dual) {\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\t\tif (mux == 1 || ldb->lvds_mux)\n\t\t\tldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI1;\n\t\telse if (mux == 0)\n\t\t\tldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI0;\n\t}\n\n\tif (ldb->lvds_mux) {\n\t\tconst struct bus_mux *lvds_mux = NULL;\n\n\t\tif (imx_ldb_ch == &ldb->channel[0])\n\t\t\tlvds_mux = &ldb->lvds_mux[0];\n\t\telse if (imx_ldb_ch == &ldb->channel[1])\n\t\t\tlvds_mux = &ldb->lvds_mux[1];\n\n\t\tregmap_update_bits(ldb->regmap, lvds_mux->reg, lvds_mux->mask,\n\t\t\t\t   mux << lvds_mux->shift);\n\t}\n\n\tregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\n\n\tdrm_panel_enable(imx_ldb_ch->panel);\n}"
    },
    {
        "var_name": "lvds_mux",
        "function_name": "imx_ldb_encoder_enable",
        "location": {
            "file_path": "drivers/gpu/drm/imx/ipuv3/imx-ldb.c",
            "region": {
                "startLine": 244,
                "startColumn": 15,
                "endColumn": 23
            },
            "context": {
                "startLine": 242,
                "endLine": 246,
                "snippet": {
                    "text": "mux << lvds_mux->shift);"
                }
            }
        },
        "function_code": "static void imx_ldb_encoder_enable(struct drm_encoder *encoder)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\tint mux = drm_of_encoder_active_port_id(imx_ldb_ch->child, encoder);\n\n\tif (mux < 0 || mux >= ARRAY_SIZE(ldb->clk_sel)) {\n\t\tdev_warn(ldb->dev, \"%s: invalid mux %d\\n\", __func__, mux);\n\t\treturn;\n\t}\n\n\tdrm_panel_prepare(imx_ldb_ch->panel);\n\n\tif (dual) {\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[0]);\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[1]);\n\n\t\tclk_prepare_enable(ldb->clk[0]);\n\t\tclk_prepare_enable(ldb->clk[1]);\n\t} else {\n\t\tclk_set_parent(ldb->clk_sel[mux], ldb->clk[imx_ldb_ch->chno]);\n\t}\n\n\tif (imx_ldb_ch == &ldb->channel[0] || dual) {\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\t\tif (mux == 0 || ldb->lvds_mux)\n\t\t\tldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI0;\n\t\telse if (mux == 1)\n\t\t\tldb->ldb_ctrl |= LDB_CH0_MODE_EN_TO_DI1;\n\t}\n\tif (imx_ldb_ch == &ldb->channel[1] || dual) {\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\t\tif (mux == 1 || ldb->lvds_mux)\n\t\t\tldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI1;\n\t\telse if (mux == 0)\n\t\t\tldb->ldb_ctrl |= LDB_CH1_MODE_EN_TO_DI0;\n\t}\n\n\tif (ldb->lvds_mux) {\n\t\tconst struct bus_mux *lvds_mux = NULL;\n\n\t\tif (imx_ldb_ch == &ldb->channel[0])\n\t\t\tlvds_mux = &ldb->lvds_mux[0];\n\t\telse if (imx_ldb_ch == &ldb->channel[1])\n\t\t\tlvds_mux = &ldb->lvds_mux[1];\n\n\t\tregmap_update_bits(ldb->regmap, lvds_mux->reg, lvds_mux->mask,\n\t\t\t\t   mux << lvds_mux->shift);\n\t}\n\n\tregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\n\n\tdrm_panel_enable(imx_ldb_ch->panel);\n}"
    },
    {
        "var_name": "lvds_mux",
        "function_name": "imx_ldb_encoder_disable",
        "location": {
            "file_path": "drivers/gpu/drm/imx/ipuv3/imx-ldb.c",
            "region": {
                "startLine": 348,
                "startColumn": 28,
                "endColumn": 36
            },
            "context": {
                "startLine": 346,
                "endLine": 350,
                "snippet": {
                    "text": "regmap_read(ldb->regmap, lvds_mux->reg, &mux);"
                }
            }
        },
        "function_code": "static void imx_ldb_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\tint mux, ret;\n\n\tdrm_panel_disable(imx_ldb_ch->panel);\n\n\tif (imx_ldb_ch == &ldb->channel[0] || dual)\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\tif (imx_ldb_ch == &ldb->channel[1] || dual)\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\n\tregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\n\n\tif (dual) {\n\t\tclk_disable_unprepare(ldb->clk[0]);\n\t\tclk_disable_unprepare(ldb->clk[1]);\n\t}\n\n\tif (ldb->lvds_mux) {\n\t\tconst struct bus_mux *lvds_mux = NULL;\n\n\t\tif (imx_ldb_ch == &ldb->channel[0])\n\t\t\tlvds_mux = &ldb->lvds_mux[0];\n\t\telse if (imx_ldb_ch == &ldb->channel[1])\n\t\t\tlvds_mux = &ldb->lvds_mux[1];\n\n\t\tregmap_read(ldb->regmap, lvds_mux->reg, &mux);\n\t\tmux &= lvds_mux->mask;\n\t\tmux >>= lvds_mux->shift;\n\t} else {\n\t\tmux = (imx_ldb_ch == &ldb->channel[0]) ? 0 : 1;\n\t}\n\n\t/* set display clock mux back to original input clock */\n\tret = clk_set_parent(ldb->clk_sel[mux], ldb->clk_parent[mux]);\n\tif (ret)\n\t\tdev_err(ldb->dev,\n\t\t\t\"unable to set di%d parent clock to original parent\\n\",\n\t\t\tmux);\n\n\tdrm_panel_unprepare(imx_ldb_ch->panel);\n}"
    },
    {
        "var_name": "lvds_mux",
        "function_name": "imx_ldb_encoder_disable",
        "location": {
            "file_path": "drivers/gpu/drm/imx/ipuv3/imx-ldb.c",
            "region": {
                "startLine": 349,
                "startColumn": 10,
                "endColumn": 18
            },
            "context": {
                "startLine": 347,
                "endLine": 351,
                "snippet": {
                    "text": "mux &= lvds_mux->mask;"
                }
            }
        },
        "function_code": "static void imx_ldb_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\tint mux, ret;\n\n\tdrm_panel_disable(imx_ldb_ch->panel);\n\n\tif (imx_ldb_ch == &ldb->channel[0] || dual)\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\tif (imx_ldb_ch == &ldb->channel[1] || dual)\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\n\tregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\n\n\tif (dual) {\n\t\tclk_disable_unprepare(ldb->clk[0]);\n\t\tclk_disable_unprepare(ldb->clk[1]);\n\t}\n\n\tif (ldb->lvds_mux) {\n\t\tconst struct bus_mux *lvds_mux = NULL;\n\n\t\tif (imx_ldb_ch == &ldb->channel[0])\n\t\t\tlvds_mux = &ldb->lvds_mux[0];\n\t\telse if (imx_ldb_ch == &ldb->channel[1])\n\t\t\tlvds_mux = &ldb->lvds_mux[1];\n\n\t\tregmap_read(ldb->regmap, lvds_mux->reg, &mux);\n\t\tmux &= lvds_mux->mask;\n\t\tmux >>= lvds_mux->shift;\n\t} else {\n\t\tmux = (imx_ldb_ch == &ldb->channel[0]) ? 0 : 1;\n\t}\n\n\t/* set display clock mux back to original input clock */\n\tret = clk_set_parent(ldb->clk_sel[mux], ldb->clk_parent[mux]);\n\tif (ret)\n\t\tdev_err(ldb->dev,\n\t\t\t\"unable to set di%d parent clock to original parent\\n\",\n\t\t\tmux);\n\n\tdrm_panel_unprepare(imx_ldb_ch->panel);\n}"
    },
    {
        "var_name": "lvds_mux",
        "function_name": "imx_ldb_encoder_disable",
        "location": {
            "file_path": "drivers/gpu/drm/imx/ipuv3/imx-ldb.c",
            "region": {
                "startLine": 350,
                "startColumn": 11,
                "endColumn": 19
            },
            "context": {
                "startLine": 348,
                "endLine": 352,
                "snippet": {
                    "text": "mux >>= lvds_mux->shift;"
                }
            }
        },
        "function_code": "static void imx_ldb_encoder_disable(struct drm_encoder *encoder)\n{\n\tstruct imx_ldb_channel *imx_ldb_ch = enc_to_imx_ldb_ch(encoder);\n\tstruct imx_ldb *ldb = imx_ldb_ch->ldb;\n\tint dual = ldb->ldb_ctrl & LDB_SPLIT_MODE_EN;\n\tint mux, ret;\n\n\tdrm_panel_disable(imx_ldb_ch->panel);\n\n\tif (imx_ldb_ch == &ldb->channel[0] || dual)\n\t\tldb->ldb_ctrl &= ~LDB_CH0_MODE_EN_MASK;\n\tif (imx_ldb_ch == &ldb->channel[1] || dual)\n\t\tldb->ldb_ctrl &= ~LDB_CH1_MODE_EN_MASK;\n\n\tregmap_write(ldb->regmap, IOMUXC_GPR2, ldb->ldb_ctrl);\n\n\tif (dual) {\n\t\tclk_disable_unprepare(ldb->clk[0]);\n\t\tclk_disable_unprepare(ldb->clk[1]);\n\t}\n\n\tif (ldb->lvds_mux) {\n\t\tconst struct bus_mux *lvds_mux = NULL;\n\n\t\tif (imx_ldb_ch == &ldb->channel[0])\n\t\t\tlvds_mux = &ldb->lvds_mux[0];\n\t\telse if (imx_ldb_ch == &ldb->channel[1])\n\t\t\tlvds_mux = &ldb->lvds_mux[1];\n\n\t\tregmap_read(ldb->regmap, lvds_mux->reg, &mux);\n\t\tmux &= lvds_mux->mask;\n\t\tmux >>= lvds_mux->shift;\n\t} else {\n\t\tmux = (imx_ldb_ch == &ldb->channel[0]) ? 0 : 1;\n\t}\n\n\t/* set display clock mux back to original input clock */\n\tret = clk_set_parent(ldb->clk_sel[mux], ldb->clk_parent[mux]);\n\tif (ret)\n\t\tdev_err(ldb->dev,\n\t\t\t\"unable to set di%d parent clock to original parent\\n\",\n\t\t\tmux);\n\n\tdrm_panel_unprepare(imx_ldb_ch->panel);\n}"
    },
    {
        "var_name": "dma_obj",
        "function_name": "drm_plane_state_to_eba",
        "location": {
            "file_path": "drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c",
            "region": {
                "startLine": 135,
                "startColumn": 9,
                "endColumn": 16
            },
            "context": {
                "startLine": 133,
                "endLine": 137,
                "snippet": {
                    "text": "return dma_obj->dma_addr + fb->offsets[plane] + fb->pitches[plane] * y +"
                }
            }
        },
        "function_code": "static inline unsigned long\ndrm_plane_state_to_eba(struct drm_plane_state *state, int plane)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *dma_obj;\n\tint x = state->src.x1 >> 16;\n\tint y = state->src.y1 >> 16;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, plane);\n\tBUG_ON(!dma_obj);\n\n\treturn dma_obj->dma_addr + fb->offsets[plane] + fb->pitches[plane] * y +\n\t       fb->format->cpp[plane] * x;\n}"
    },
    {
        "var_name": "dma_obj",
        "function_name": "drm_plane_state_to_ubo",
        "location": {
            "file_path": "drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c",
            "region": {
                "startLine": 154,
                "startColumn": 9,
                "endColumn": 16
            },
            "context": {
                "startLine": 152,
                "endLine": 156,
                "snippet": {
                    "text": "return dma_obj->dma_addr + fb->offsets[1] + fb->pitches[1] * y +"
                }
            }
        },
        "function_code": "static inline unsigned long\ndrm_plane_state_to_ubo(struct drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *dma_obj;\n\tunsigned long eba = drm_plane_state_to_eba(state, 0);\n\tint x = state->src.x1 >> 16;\n\tint y = state->src.y1 >> 16;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, 1);\n\tBUG_ON(!dma_obj);\n\n\tx /= fb->format->hsub;\n\ty /= fb->format->vsub;\n\n\treturn dma_obj->dma_addr + fb->offsets[1] + fb->pitches[1] * y +\n\t       fb->format->cpp[1] * x - eba;\n}"
    },
    {
        "var_name": "dma_obj",
        "function_name": "drm_plane_state_to_vbo",
        "location": {
            "file_path": "drivers/gpu/drm/imx/ipuv3/ipuv3-plane.c",
            "region": {
                "startLine": 173,
                "startColumn": 9,
                "endColumn": 16
            },
            "context": {
                "startLine": 171,
                "endLine": 175,
                "snippet": {
                    "text": "return dma_obj->dma_addr + fb->offsets[2] + fb->pitches[2] * y +"
                }
            }
        },
        "function_code": "static inline unsigned long\ndrm_plane_state_to_vbo(struct drm_plane_state *state)\n{\n\tstruct drm_framebuffer *fb = state->fb;\n\tstruct drm_gem_dma_object *dma_obj;\n\tunsigned long eba = drm_plane_state_to_eba(state, 0);\n\tint x = state->src.x1 >> 16;\n\tint y = state->src.y1 >> 16;\n\n\tdma_obj = drm_fb_dma_get_gem_obj(fb, 2);\n\tBUG_ON(!dma_obj);\n\n\tx /= fb->format->hsub;\n\ty /= fb->format->vsub;\n\n\treturn dma_obj->dma_addr + fb->offsets[2] + fb->pitches[2] * y +\n\t       fb->format->cpp[2] * x - eba;\n}"
    },
    {
        "var_name": "pdev",
        "function_name": "a5xx_gpu_init",
        "location": {
            "file_path": "drivers/gpu/drm/msm/adreno/a5xx_gpu.c",
            "region": {
                "startLine": 1743,
                "startColumn": 42,
                "endColumn": 46
            },
            "context": {
                "startLine": 1741,
                "endLine": 1745,
                "snippet": {
                    "text": "struct adreno_platform_config *config = pdev->dev.platform_data;"
                }
            }
        },
        "function_code": "struct msm_gpu *a5xx_gpu_init(struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct platform_device *pdev = priv->gpu_pdev;\n\tstruct adreno_platform_config *config = pdev->dev.platform_data;\n\tstruct a5xx_gpu *a5xx_gpu = NULL;\n\tstruct adreno_gpu *adreno_gpu;\n\tstruct msm_gpu *gpu;\n\tunsigned int nr_rings;\n\tint ret;\n\n\tif (!pdev) {\n\t\tDRM_DEV_ERROR(dev->dev, \"No A5XX device is defined\\n\");\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\ta5xx_gpu = kzalloc(sizeof(*a5xx_gpu), GFP_KERNEL);\n\tif (!a5xx_gpu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tadreno_gpu = &a5xx_gpu->base;\n\tgpu = &adreno_gpu->base;\n\n\tadreno_gpu->registers = a5xx_registers;\n\n\ta5xx_gpu->lm_leakage = 0x4E001A;\n\n\tcheck_speed_bin(&pdev->dev);\n\n\tnr_rings = 4;\n\n\tif (config->info->revn == 510)\n\t\tnr_rings = 1;\n\n\tret = adreno_gpu_init(dev, pdev, adreno_gpu, &funcs, nr_rings);\n\tif (ret) {\n\t\ta5xx_destroy(&(a5xx_gpu->base.base));\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (gpu->aspace)\n\t\tmsm_mmu_set_fault_handler(gpu->aspace->mmu, gpu, a5xx_fault_handler);\n\n\t/* Set up the preemption specific bits and pieces for each ringbuffer */\n\ta5xx_preempt_init(gpu);\n\n\t/* Set the highest bank bit */\n\tif (adreno_is_a540(adreno_gpu) || adreno_is_a530(adreno_gpu))\n\t\tadreno_gpu->ubwc_config.highest_bank_bit = 15;\n\telse\n\t\tadreno_gpu->ubwc_config.highest_bank_bit = 14;\n\n\treturn gpu;\n}"
    },
    {
        "var_name": "phys_enc",
        "function_name": "dpu_encoder_helper_split_config",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c",
            "region": {
                "startLine": 511,
                "startColumn": 7,
                "endColumn": 15
            },
            "context": {
                "startLine": 509,
                "endLine": 513,
                "snippet": {
                    "text": "if (!phys_enc->hw_mdptop || !phys_enc->parent) {"
                }
            }
        },
        "function_code": "void dpu_encoder_helper_split_config(\n\t\tstruct dpu_encoder_phys *phys_enc,\n\t\tenum dpu_intf interface)\n{\n\tstruct dpu_encoder_virt *dpu_enc;\n\tstruct split_pipe_cfg cfg = { 0 };\n\tstruct dpu_hw_mdp *hw_mdptop;\n\tstruct msm_display_info *disp_info;\n\n\tif (!phys_enc->hw_mdptop || !phys_enc->parent) {\n\t\tDPU_ERROR(\"invalid arg(s), encoder %d\\n\", phys_enc != NULL);\n\t\treturn;\n\t}\n\n\tdpu_enc = to_dpu_encoder_virt(phys_enc->parent);\n\thw_mdptop = phys_enc->hw_mdptop;\n\tdisp_info = &dpu_enc->disp_info;\n\n\tif (disp_info->intf_type != INTF_DSI)\n\t\treturn;\n\n\t/**\n\t * disable split modes since encoder will be operating in as the only\n\t * encoder, either for the entire use case in the case of, for example,\n\t * single DSI, or for this frame in the case of left/right only partial\n\t * update.\n\t */\n\tif (phys_enc->split_role == ENC_ROLE_SOLO) {\n\t\tif (hw_mdptop->ops.setup_split_pipe)\n\t\t\thw_mdptop->ops.setup_split_pipe(hw_mdptop, &cfg);\n\t\treturn;\n\t}\n\n\tcfg.en = true;\n\tcfg.mode = phys_enc->intf_mode;\n\tcfg.intf = interface;\n\n\tif (cfg.en && phys_enc->ops.needs_single_flush &&\n\t\t\tphys_enc->ops.needs_single_flush(phys_enc))\n\t\tcfg.split_flush_en = true;\n\n\tif (phys_enc->split_role == ENC_ROLE_MASTER) {\n\t\tDPU_DEBUG_ENC(dpu_enc, \"enable %d\\n\", cfg.en);\n\n\t\tif (hw_mdptop->ops.setup_split_pipe)\n\t\t\thw_mdptop->ops.setup_split_pipe(hw_mdptop, &cfg);\n\t}\n}"
    },
    {
        "var_name": "dpu_enc",
        "function_name": "dpu_encoder_virt_atomic_mode_set",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c",
            "region": {
                "startLine": 1185,
                "startColumn": 35,
                "endColumn": 42
            },
            "context": {
                "startLine": 1183,
                "endLine": 1187,
                "snippet": {
                    "text": "struct dpu_encoder_phys *phys = dpu_enc->phys_encs[i];"
                }
            }
        },
        "function_code": "static void dpu_encoder_virt_atomic_mode_set(struct drm_encoder *drm_enc,\n\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct dpu_encoder_virt *dpu_enc;\n\tstruct msm_drm_private *priv;\n\tstruct dpu_kms *dpu_kms;\n\tstruct dpu_crtc_state *cstate;\n\tstruct dpu_global_state *global_state;\n\tstruct dpu_hw_blk *hw_pp[MAX_CHANNELS_PER_ENC];\n\tstruct dpu_hw_blk *hw_ctl[MAX_CHANNELS_PER_ENC];\n\tstruct dpu_hw_blk *hw_lm[MAX_CHANNELS_PER_ENC];\n\tstruct dpu_hw_blk *hw_dspp[MAX_CHANNELS_PER_ENC] = { NULL };\n\tstruct dpu_hw_blk *hw_dsc[MAX_CHANNELS_PER_ENC];\n\tint num_lm, num_ctl, num_pp, num_dsc;\n\tunsigned int dsc_mask = 0;\n\tint i;\n\n\tif (!drm_enc) {\n\t\tDPU_ERROR(\"invalid encoder\\n\");\n\t\treturn;\n\t}\n\n\tdpu_enc = to_dpu_encoder_virt(drm_enc);\n\tDPU_DEBUG_ENC(dpu_enc, \"\\n\");\n\n\tpriv = drm_enc->dev->dev_private;\n\tdpu_kms = to_dpu_kms(priv->kms);\n\n\tglobal_state = dpu_kms_get_existing_global_state(dpu_kms);\n\tif (IS_ERR_OR_NULL(global_state)) {\n\t\tDPU_ERROR(\"Failed to get global state\");\n\t\treturn;\n\t}\n\n\ttrace_dpu_enc_mode_set(DRMID(drm_enc));\n\n\t/* Query resource that have been reserved in atomic check step. */\n\tnum_pp = dpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\tdrm_enc->base.id, DPU_HW_BLK_PINGPONG, hw_pp,\n\t\tARRAY_SIZE(hw_pp));\n\tnum_ctl = dpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\tdrm_enc->base.id, DPU_HW_BLK_CTL, hw_ctl, ARRAY_SIZE(hw_ctl));\n\tnum_lm = dpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\tdrm_enc->base.id, DPU_HW_BLK_LM, hw_lm, ARRAY_SIZE(hw_lm));\n\tdpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\tdrm_enc->base.id, DPU_HW_BLK_DSPP, hw_dspp,\n\t\tARRAY_SIZE(hw_dspp));\n\n\tfor (i = 0; i < MAX_CHANNELS_PER_ENC; i++)\n\t\tdpu_enc->hw_pp[i] = i < num_pp ? to_dpu_hw_pingpong(hw_pp[i])\n\t\t\t\t\t\t: NULL;\n\n\tnum_dsc = dpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\t\t\t\t\tdrm_enc->base.id, DPU_HW_BLK_DSC,\n\t\t\t\t\t\thw_dsc, ARRAY_SIZE(hw_dsc));\n\tfor (i = 0; i < num_dsc; i++) {\n\t\tdpu_enc->hw_dsc[i] = to_dpu_hw_dsc(hw_dsc[i]);\n\t\tdsc_mask |= BIT(dpu_enc->hw_dsc[i]->idx - DSC_0);\n\t}\n\n\tdpu_enc->dsc_mask = dsc_mask;\n\n\tif ((dpu_enc->disp_info.intf_type == INTF_WB && conn_state->writeback_job) ||\n\t    dpu_enc->disp_info.intf_type == INTF_DP) {\n\t\tstruct dpu_hw_blk *hw_cdm = NULL;\n\n\t\tdpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\t\t\t\t      drm_enc->base.id, DPU_HW_BLK_CDM,\n\t\t\t\t\t      &hw_cdm, 1);\n\t\tdpu_enc->cur_master->hw_cdm = hw_cdm ? to_dpu_hw_cdm(hw_cdm) : NULL;\n\t}\n\n\tcstate = to_dpu_crtc_state(crtc_state);\n\n\tfor (i = 0; i < num_lm; i++) {\n\t\tint ctl_idx = (i < num_ctl) ? i : (num_ctl-1);\n\n\t\tcstate->mixers[i].hw_lm = to_dpu_hw_mixer(hw_lm[i]);\n\t\tcstate->mixers[i].lm_ctl = to_dpu_hw_ctl(hw_ctl[ctl_idx]);\n\t\tcstate->mixers[i].hw_dspp = to_dpu_hw_dspp(hw_dspp[i]);\n\t}\n\n\tcstate->num_mixers = num_lm;\n\n\tdpu_enc->connector = conn_state->connector;\n\n\tfor (i = 0; i < dpu_enc->num_phys_encs; i++) {\n\t\tstruct dpu_encoder_phys *phys = dpu_enc->phys_encs[i];\n\n\t\tif (!dpu_enc->hw_pp[i]) {\n\t\t\tDPU_ERROR_ENC(dpu_enc,\n\t\t\t\t\"no pp block assigned at idx: %d\\n\", i);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hw_ctl[i]) {\n\t\t\tDPU_ERROR_ENC(dpu_enc,\n\t\t\t\t\"no ctl block assigned at idx: %d\\n\", i);\n\t\t\treturn;\n\t\t}\n\n\t\tphys->hw_pp = dpu_enc->hw_pp[i];\n\t\tphys->hw_ctl = to_dpu_hw_ctl(hw_ctl[i]);\n\n\t\tphys->cached_mode = crtc_state->adjusted_mode;\n\t}\n}"
    },
    {
        "var_name": "dpu_enc",
        "function_name": "dpu_encoder_virt_atomic_mode_set",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c",
            "region": {
                "startLine": 1187,
                "startColumn": 8,
                "endColumn": 15
            },
            "context": {
                "startLine": 1185,
                "endLine": 1189,
                "snippet": {
                    "text": "if (!dpu_enc->hw_pp[i]) {"
                }
            }
        },
        "function_code": "static void dpu_encoder_virt_atomic_mode_set(struct drm_encoder *drm_enc,\n\t\t\t\t\t     struct drm_crtc_state *crtc_state,\n\t\t\t\t\t     struct drm_connector_state *conn_state)\n{\n\tstruct dpu_encoder_virt *dpu_enc;\n\tstruct msm_drm_private *priv;\n\tstruct dpu_kms *dpu_kms;\n\tstruct dpu_crtc_state *cstate;\n\tstruct dpu_global_state *global_state;\n\tstruct dpu_hw_blk *hw_pp[MAX_CHANNELS_PER_ENC];\n\tstruct dpu_hw_blk *hw_ctl[MAX_CHANNELS_PER_ENC];\n\tstruct dpu_hw_blk *hw_lm[MAX_CHANNELS_PER_ENC];\n\tstruct dpu_hw_blk *hw_dspp[MAX_CHANNELS_PER_ENC] = { NULL };\n\tstruct dpu_hw_blk *hw_dsc[MAX_CHANNELS_PER_ENC];\n\tint num_lm, num_ctl, num_pp, num_dsc;\n\tunsigned int dsc_mask = 0;\n\tint i;\n\n\tif (!drm_enc) {\n\t\tDPU_ERROR(\"invalid encoder\\n\");\n\t\treturn;\n\t}\n\n\tdpu_enc = to_dpu_encoder_virt(drm_enc);\n\tDPU_DEBUG_ENC(dpu_enc, \"\\n\");\n\n\tpriv = drm_enc->dev->dev_private;\n\tdpu_kms = to_dpu_kms(priv->kms);\n\n\tglobal_state = dpu_kms_get_existing_global_state(dpu_kms);\n\tif (IS_ERR_OR_NULL(global_state)) {\n\t\tDPU_ERROR(\"Failed to get global state\");\n\t\treturn;\n\t}\n\n\ttrace_dpu_enc_mode_set(DRMID(drm_enc));\n\n\t/* Query resource that have been reserved in atomic check step. */\n\tnum_pp = dpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\tdrm_enc->base.id, DPU_HW_BLK_PINGPONG, hw_pp,\n\t\tARRAY_SIZE(hw_pp));\n\tnum_ctl = dpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\tdrm_enc->base.id, DPU_HW_BLK_CTL, hw_ctl, ARRAY_SIZE(hw_ctl));\n\tnum_lm = dpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\tdrm_enc->base.id, DPU_HW_BLK_LM, hw_lm, ARRAY_SIZE(hw_lm));\n\tdpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\tdrm_enc->base.id, DPU_HW_BLK_DSPP, hw_dspp,\n\t\tARRAY_SIZE(hw_dspp));\n\n\tfor (i = 0; i < MAX_CHANNELS_PER_ENC; i++)\n\t\tdpu_enc->hw_pp[i] = i < num_pp ? to_dpu_hw_pingpong(hw_pp[i])\n\t\t\t\t\t\t: NULL;\n\n\tnum_dsc = dpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\t\t\t\t\tdrm_enc->base.id, DPU_HW_BLK_DSC,\n\t\t\t\t\t\thw_dsc, ARRAY_SIZE(hw_dsc));\n\tfor (i = 0; i < num_dsc; i++) {\n\t\tdpu_enc->hw_dsc[i] = to_dpu_hw_dsc(hw_dsc[i]);\n\t\tdsc_mask |= BIT(dpu_enc->hw_dsc[i]->idx - DSC_0);\n\t}\n\n\tdpu_enc->dsc_mask = dsc_mask;\n\n\tif ((dpu_enc->disp_info.intf_type == INTF_WB && conn_state->writeback_job) ||\n\t    dpu_enc->disp_info.intf_type == INTF_DP) {\n\t\tstruct dpu_hw_blk *hw_cdm = NULL;\n\n\t\tdpu_rm_get_assigned_resources(&dpu_kms->rm, global_state,\n\t\t\t\t\t      drm_enc->base.id, DPU_HW_BLK_CDM,\n\t\t\t\t\t      &hw_cdm, 1);\n\t\tdpu_enc->cur_master->hw_cdm = hw_cdm ? to_dpu_hw_cdm(hw_cdm) : NULL;\n\t}\n\n\tcstate = to_dpu_crtc_state(crtc_state);\n\n\tfor (i = 0; i < num_lm; i++) {\n\t\tint ctl_idx = (i < num_ctl) ? i : (num_ctl-1);\n\n\t\tcstate->mixers[i].hw_lm = to_dpu_hw_mixer(hw_lm[i]);\n\t\tcstate->mixers[i].lm_ctl = to_dpu_hw_ctl(hw_ctl[ctl_idx]);\n\t\tcstate->mixers[i].hw_dspp = to_dpu_hw_dspp(hw_dspp[i]);\n\t}\n\n\tcstate->num_mixers = num_lm;\n\n\tdpu_enc->connector = conn_state->connector;\n\n\tfor (i = 0; i < dpu_enc->num_phys_encs; i++) {\n\t\tstruct dpu_encoder_phys *phys = dpu_enc->phys_encs[i];\n\n\t\tif (!dpu_enc->hw_pp[i]) {\n\t\t\tDPU_ERROR_ENC(dpu_enc,\n\t\t\t\t\"no pp block assigned at idx: %d\\n\", i);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hw_ctl[i]) {\n\t\t\tDPU_ERROR_ENC(dpu_enc,\n\t\t\t\t\"no ctl block assigned at idx: %d\\n\", i);\n\t\t\treturn;\n\t\t}\n\n\t\tphys->hw_pp = dpu_enc->hw_pp[i];\n\t\tphys->hw_ctl = to_dpu_hw_ctl(hw_ctl[i]);\n\n\t\tphys->cached_mode = crtc_state->adjusted_mode;\n\t}\n}"
    },
    {
        "var_name": "dpu_enc",
        "function_name": "dpu_encoder_prep_dsc",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c",
            "region": {
                "startLine": 1915,
                "startColumn": 14,
                "endColumn": 21
            },
            "context": {
                "startLine": 1913,
                "endLine": 1917,
                "snippet": {
                    "text": "hw_pp[i] = dpu_enc->hw_pp[i];"
                }
            }
        },
        "function_code": "static void dpu_encoder_prep_dsc(struct dpu_encoder_virt *dpu_enc,\n\t\t\t\t struct drm_dsc_config *dsc)\n{\n\t/* coding only for 2LM, 2enc, 1 dsc config */\n\tstruct dpu_encoder_phys *enc_master = dpu_enc->cur_master;\n\tstruct dpu_hw_ctl *ctl = enc_master->hw_ctl;\n\tstruct dpu_hw_dsc *hw_dsc[MAX_CHANNELS_PER_ENC];\n\tstruct dpu_hw_pingpong *hw_pp[MAX_CHANNELS_PER_ENC];\n\tint this_frame_slices;\n\tint intf_ip_w, enc_ip_w;\n\tint dsc_common_mode;\n\tint pic_width;\n\tu32 initial_lines;\n\tint i;\n\n\tfor (i = 0; i < MAX_CHANNELS_PER_ENC; i++) {\n\t\thw_pp[i] = dpu_enc->hw_pp[i];\n\t\thw_dsc[i] = dpu_enc->hw_dsc[i];\n\n\t\tif (!hw_pp[i] || !hw_dsc[i]) {\n\t\t\tDPU_ERROR_ENC(dpu_enc, \"invalid params for DSC\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdsc_common_mode = 0;\n\tpic_width = dsc->pic_width;\n\n\tdsc_common_mode = DSC_MODE_SPLIT_PANEL;\n\tif (dpu_encoder_use_dsc_merge(enc_master->parent))\n\t\tdsc_common_mode |= DSC_MODE_MULTIPLEX;\n\tif (enc_master->intf_mode == INTF_MODE_VIDEO)\n\t\tdsc_common_mode |= DSC_MODE_VIDEO;\n\n\tthis_frame_slices = pic_width / dsc->slice_width;\n\tintf_ip_w = this_frame_slices * dsc->slice_width;\n\n\t/*\n\t * dsc merge case: when using 2 encoders for the same stream,\n\t * no. of slices need to be same on both the encoders.\n\t */\n\tenc_ip_w = intf_ip_w / 2;\n\tinitial_lines = dpu_encoder_dsc_initial_line_calc(dsc, enc_ip_w);\n\n\tfor (i = 0; i < MAX_CHANNELS_PER_ENC; i++)\n\t\tdpu_encoder_dsc_pipe_cfg(ctl, hw_dsc[i], hw_pp[i],\n\t\t\t\t\t dsc, dsc_common_mode, initial_lines);\n}"
    },
    {
        "var_name": "dpu_enc",
        "function_name": "dpu_encoder_prep_dsc",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c",
            "region": {
                "startLine": 1916,
                "startColumn": 15,
                "endColumn": 22
            },
            "context": {
                "startLine": 1914,
                "endLine": 1918,
                "snippet": {
                    "text": "hw_dsc[i] = dpu_enc->hw_dsc[i];"
                }
            }
        },
        "function_code": "static void dpu_encoder_prep_dsc(struct dpu_encoder_virt *dpu_enc,\n\t\t\t\t struct drm_dsc_config *dsc)\n{\n\t/* coding only for 2LM, 2enc, 1 dsc config */\n\tstruct dpu_encoder_phys *enc_master = dpu_enc->cur_master;\n\tstruct dpu_hw_ctl *ctl = enc_master->hw_ctl;\n\tstruct dpu_hw_dsc *hw_dsc[MAX_CHANNELS_PER_ENC];\n\tstruct dpu_hw_pingpong *hw_pp[MAX_CHANNELS_PER_ENC];\n\tint this_frame_slices;\n\tint intf_ip_w, enc_ip_w;\n\tint dsc_common_mode;\n\tint pic_width;\n\tu32 initial_lines;\n\tint i;\n\n\tfor (i = 0; i < MAX_CHANNELS_PER_ENC; i++) {\n\t\thw_pp[i] = dpu_enc->hw_pp[i];\n\t\thw_dsc[i] = dpu_enc->hw_dsc[i];\n\n\t\tif (!hw_pp[i] || !hw_dsc[i]) {\n\t\t\tDPU_ERROR_ENC(dpu_enc, \"invalid params for DSC\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdsc_common_mode = 0;\n\tpic_width = dsc->pic_width;\n\n\tdsc_common_mode = DSC_MODE_SPLIT_PANEL;\n\tif (dpu_encoder_use_dsc_merge(enc_master->parent))\n\t\tdsc_common_mode |= DSC_MODE_MULTIPLEX;\n\tif (enc_master->intf_mode == INTF_MODE_VIDEO)\n\t\tdsc_common_mode |= DSC_MODE_VIDEO;\n\n\tthis_frame_slices = pic_width / dsc->slice_width;\n\tintf_ip_w = this_frame_slices * dsc->slice_width;\n\n\t/*\n\t * dsc merge case: when using 2 encoders for the same stream,\n\t * no. of slices need to be same on both the encoders.\n\t */\n\tenc_ip_w = intf_ip_w / 2;\n\tinitial_lines = dpu_encoder_dsc_initial_line_calc(dsc, enc_ip_w);\n\n\tfor (i = 0; i < MAX_CHANNELS_PER_ENC; i++)\n\t\tdpu_encoder_dsc_pipe_cfg(ctl, hw_dsc[i], hw_pp[i],\n\t\t\t\t\t dsc, dsc_common_mode, initial_lines);\n}"
    },
    {
        "var_name": "dpu_enc",
        "function_name": "dpu_encoder_virt_add_phys_encs",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c",
            "region": {
                "startLine": 2315,
                "startColumn": 6,
                "endColumn": 13
            },
            "context": {
                "startLine": 2313,
                "endLine": 2317,
                "snippet": {
                    "text": "if (dpu_enc->num_phys_encs + NUM_PHYS_ENCODER_TYPES >="
                }
            }
        },
        "function_code": "static int dpu_encoder_virt_add_phys_encs(\n\t\tstruct drm_device *dev,\n\t\tstruct msm_display_info *disp_info,\n\t\tstruct dpu_encoder_virt *dpu_enc,\n\t\tstruct dpu_enc_phys_init_params *params)\n{\n\tstruct dpu_encoder_phys *enc = NULL;\n\n\tDPU_DEBUG_ENC(dpu_enc, \"\\n\");\n\n\t/*\n\t * We may create up to NUM_PHYS_ENCODER_TYPES physical encoder types\n\t * in this function, check up-front.\n\t */\n\tif (dpu_enc->num_phys_encs + NUM_PHYS_ENCODER_TYPES >=\n\t\t\tARRAY_SIZE(dpu_enc->phys_encs)) {\n\t\tDPU_ERROR_ENC(dpu_enc, \"too many physical encoders %d\\n\",\n\t\t\t  dpu_enc->num_phys_encs);\n\t\treturn -EINVAL;\n\t}\n\n\n\tif (disp_info->intf_type == INTF_WB) {\n\t\tenc = dpu_encoder_phys_wb_init(dev, params);\n\n\t\tif (IS_ERR(enc)) {\n\t\t\tDPU_ERROR_ENC(dpu_enc, \"failed to init wb enc: %ld\\n\",\n\t\t\t\tPTR_ERR(enc));\n\t\t\treturn PTR_ERR(enc);\n\t\t}\n\n\t\tdpu_enc->phys_encs[dpu_enc->num_phys_encs] = enc;\n\t\t++dpu_enc->num_phys_encs;\n\t} else if (disp_info->is_cmd_mode) {\n\t\tenc = dpu_encoder_phys_cmd_init(dev, params);\n\n\t\tif (IS_ERR(enc)) {\n\t\t\tDPU_ERROR_ENC(dpu_enc, \"failed to init cmd enc: %ld\\n\",\n\t\t\t\tPTR_ERR(enc));\n\t\t\treturn PTR_ERR(enc);\n\t\t}\n\n\t\tdpu_enc->phys_encs[dpu_enc->num_phys_encs] = enc;\n\t\t++dpu_enc->num_phys_encs;\n\t} else {\n\t\tenc = dpu_encoder_phys_vid_init(dev, params);\n\n\t\tif (IS_ERR(enc)) {\n\t\t\tDPU_ERROR_ENC(dpu_enc, \"failed to init vid enc: %ld\\n\",\n\t\t\t\tPTR_ERR(enc));\n\t\t\treturn PTR_ERR(enc);\n\t\t}\n\n\t\tdpu_enc->phys_encs[dpu_enc->num_phys_encs] = enc;\n\t\t++dpu_enc->num_phys_encs;\n\t}\n\n\tif (params->split_role == ENC_ROLE_SLAVE)\n\t\tdpu_enc->cur_slave = enc;\n\telse\n\t\tdpu_enc->cur_master = enc;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "dpu_enc",
        "function_name": "dpu_encoder_virt_add_phys_encs",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder.c",
            "region": {
                "startLine": 2316,
                "startColumn": 15,
                "endColumn": 22
            },
            "context": {
                "startLine": 2314,
                "endLine": 2318,
                "snippet": {
                    "text": "ARRAY_SIZE(dpu_enc->phys_encs)) {"
                }
            }
        },
        "function_code": "static int dpu_encoder_virt_add_phys_encs(\n\t\tstruct drm_device *dev,\n\t\tstruct msm_display_info *disp_info,\n\t\tstruct dpu_encoder_virt *dpu_enc,\n\t\tstruct dpu_enc_phys_init_params *params)\n{\n\tstruct dpu_encoder_phys *enc = NULL;\n\n\tDPU_DEBUG_ENC(dpu_enc, \"\\n\");\n\n\t/*\n\t * We may create up to NUM_PHYS_ENCODER_TYPES physical encoder types\n\t * in this function, check up-front.\n\t */\n\tif (dpu_enc->num_phys_encs + NUM_PHYS_ENCODER_TYPES >=\n\t\t\tARRAY_SIZE(dpu_enc->phys_encs)) {\n\t\tDPU_ERROR_ENC(dpu_enc, \"too many physical encoders %d\\n\",\n\t\t\t  dpu_enc->num_phys_encs);\n\t\treturn -EINVAL;\n\t}\n\n\n\tif (disp_info->intf_type == INTF_WB) {\n\t\tenc = dpu_encoder_phys_wb_init(dev, params);\n\n\t\tif (IS_ERR(enc)) {\n\t\t\tDPU_ERROR_ENC(dpu_enc, \"failed to init wb enc: %ld\\n\",\n\t\t\t\tPTR_ERR(enc));\n\t\t\treturn PTR_ERR(enc);\n\t\t}\n\n\t\tdpu_enc->phys_encs[dpu_enc->num_phys_encs] = enc;\n\t\t++dpu_enc->num_phys_encs;\n\t} else if (disp_info->is_cmd_mode) {\n\t\tenc = dpu_encoder_phys_cmd_init(dev, params);\n\n\t\tif (IS_ERR(enc)) {\n\t\t\tDPU_ERROR_ENC(dpu_enc, \"failed to init cmd enc: %ld\\n\",\n\t\t\t\tPTR_ERR(enc));\n\t\t\treturn PTR_ERR(enc);\n\t\t}\n\n\t\tdpu_enc->phys_encs[dpu_enc->num_phys_encs] = enc;\n\t\t++dpu_enc->num_phys_encs;\n\t} else {\n\t\tenc = dpu_encoder_phys_vid_init(dev, params);\n\n\t\tif (IS_ERR(enc)) {\n\t\t\tDPU_ERROR_ENC(dpu_enc, \"failed to init vid enc: %ld\\n\",\n\t\t\t\tPTR_ERR(enc));\n\t\t\treturn PTR_ERR(enc);\n\t\t}\n\n\t\tdpu_enc->phys_encs[dpu_enc->num_phys_encs] = enc;\n\t\t++dpu_enc->num_phys_encs;\n\t}\n\n\tif (params->split_role == ENC_ROLE_SLAVE)\n\t\tdpu_enc->cur_slave = enc;\n\telse\n\t\tdpu_enc->cur_master = enc;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "phys_enc",
        "function_name": "_dpu_encoder_phys_cmd_pingpong_config",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_cmd.c",
            "region": {
                "startLine": 414,
                "startColumn": 7,
                "endColumn": 15
            },
            "context": {
                "startLine": 412,
                "endLine": 416,
                "snippet": {
                    "text": "if (!phys_enc->hw_pp || !phys_enc->hw_ctl->ops.setup_intf_cfg) {"
                }
            }
        },
        "function_code": "static void _dpu_encoder_phys_cmd_pingpong_config(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_encoder_phys_cmd *cmd_enc =\n\t\tto_dpu_encoder_phys_cmd(phys_enc);\n\n\tif (!phys_enc->hw_pp || !phys_enc->hw_ctl->ops.setup_intf_cfg) {\n\t\tDPU_ERROR(\"invalid arg(s), enc %d\\n\", phys_enc != NULL);\n\t\treturn;\n\t}\n\n\tDPU_DEBUG_CMDENC(cmd_enc, \"pp %d, enabling mode:\\n\",\n\t\t\tphys_enc->hw_pp->idx - PINGPONG_0);\n\tdrm_mode_debug_printmodeline(&phys_enc->cached_mode);\n\n\t_dpu_encoder_phys_cmd_update_intf_cfg(phys_enc);\n\tdpu_encoder_phys_cmd_tearcheck_config(phys_enc);\n}"
    },
    {
        "var_name": "phys_enc",
        "function_name": "dpu_encoder_phys_cmd_enable_helper",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_cmd.c",
            "region": {
                "startLine": 442,
                "startColumn": 7,
                "endColumn": 15
            },
            "context": {
                "startLine": 440,
                "endLine": 444,
                "snippet": {
                    "text": "if (!phys_enc->hw_pp) {"
                }
            }
        },
        "function_code": "static void dpu_encoder_phys_cmd_enable_helper(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct dpu_hw_ctl *ctl;\n\n\tif (!phys_enc->hw_pp) {\n\t\tDPU_ERROR(\"invalid arg(s), encoder %d\\n\", phys_enc != NULL);\n\t\treturn;\n\t}\n\n\tdpu_encoder_helper_split_config(phys_enc, phys_enc->hw_intf->idx);\n\n\t_dpu_encoder_phys_cmd_pingpong_config(phys_enc);\n\n\tctl = phys_enc->hw_ctl;\n\tctl->ops.update_pending_flush_intf(ctl, phys_enc->hw_intf->idx);\n}"
    },
    {
        "var_name": "cmd_enc",
        "function_name": "dpu_encoder_phys_cmd_init",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_cmd.c",
            "region": {
                "startLine": 741,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 739,
                "endLine": 743,
                "snippet": {
                    "text": "cmd_enc->stream_sel = 0;"
                }
            }
        },
        "function_code": "struct dpu_encoder_phys *dpu_encoder_phys_cmd_init(struct drm_device *dev,\n\t\tstruct dpu_enc_phys_init_params *p)\n{\n\tstruct dpu_encoder_phys *phys_enc = NULL;\n\tstruct dpu_encoder_phys_cmd *cmd_enc = NULL;\n\n\tDPU_DEBUG(\"intf\\n\");\n\n\tcmd_enc = drmm_kzalloc(dev, sizeof(*cmd_enc), GFP_KERNEL);\n\tif (!cmd_enc) {\n\t\tDPU_ERROR(\"failed to allocate\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tphys_enc = &cmd_enc->base;\n\n\tdpu_encoder_phys_init(phys_enc, p);\n\n\tmutex_init(&phys_enc->vblank_ctl_lock);\n\tphys_enc->vblank_refcount = 0;\n\n\tdpu_encoder_phys_cmd_init_ops(&phys_enc->ops);\n\tphys_enc->intf_mode = INTF_MODE_CMD;\n\tphys_enc->irq[INTR_IDX_UNDERRUN] = phys_enc->hw_intf->cap->intr_underrun;\n\n\tcmd_enc->stream_sel = 0;\n\n\tif (!phys_enc->hw_intf) {\n\t\tDPU_ERROR_CMDENC(cmd_enc, \"no INTF provided\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* DPU before 5.0 use PINGPONG for TE handling */\n\tif (phys_enc->dpu_kms->catalog->mdss_ver->core_major_ver >= 5)\n\t\tphys_enc->has_intf_te = true;\n\n\tif (phys_enc->has_intf_te && !phys_enc->hw_intf->ops.enable_tearcheck) {\n\t\tDPU_ERROR_CMDENC(cmd_enc, \"tearcheck not supported\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tatomic_set(&cmd_enc->pending_vblank_cnt, 0);\n\tinit_waitqueue_head(&cmd_enc->pending_vblank_wq);\n\n\tDPU_DEBUG_CMDENC(cmd_enc, \"created\\n\");\n\n\treturn phys_enc;\n}"
    },
    {
        "var_name": "phys_enc",
        "function_name": "dpu_encoder_phys_vid_setup_timing_engine",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_encoder_phys_vid.c",
            "region": {
                "startLine": 245,
                "startColumn": 7,
                "endColumn": 15
            },
            "context": {
                "startLine": 243,
                "endLine": 247,
                "snippet": {
                    "text": "if (!phys_enc->hw_ctl->ops.setup_intf_cfg) {"
                }
            }
        },
        "function_code": "static void dpu_encoder_phys_vid_setup_timing_engine(\n\t\tstruct dpu_encoder_phys *phys_enc)\n{\n\tstruct drm_display_mode mode;\n\tstruct dpu_hw_intf_timing_params timing_params = { 0 };\n\tconst struct dpu_format *fmt = NULL;\n\tu32 fmt_fourcc;\n\tunsigned long lock_flags;\n\tstruct dpu_hw_intf_cfg intf_cfg = { 0 };\n\n\tdrm_mode_init(&mode, &phys_enc->cached_mode);\n\n\tif (!phys_enc->hw_ctl->ops.setup_intf_cfg) {\n\t\tDPU_ERROR(\"invalid encoder %d\\n\", phys_enc != NULL);\n\t\treturn;\n\t}\n\n\tif (!phys_enc->hw_intf->ops.setup_timing_gen) {\n\t\tDPU_ERROR(\"timing engine setup is not supported\\n\");\n\t\treturn;\n\t}\n\n\tDPU_DEBUG_VIDENC(phys_enc, \"enabling mode:\\n\");\n\tdrm_mode_debug_printmodeline(&mode);\n\n\tfmt_fourcc = dpu_encoder_get_drm_fmt(phys_enc);\n\n\tif (phys_enc->split_role != ENC_ROLE_SOLO || fmt_fourcc == DRM_FORMAT_YUV420) {\n\t\tmode.hdisplay >>= 1;\n\t\tmode.htotal >>= 1;\n\t\tmode.hsync_start >>= 1;\n\t\tmode.hsync_end >>= 1;\n\t\tmode.hskew >>= 1;\n\n\t\tDPU_DEBUG_VIDENC(phys_enc,\n\t\t\t\"split_role %d, halve horizontal %d %d %d %d %d\\n\",\n\t\t\tphys_enc->split_role,\n\t\t\tmode.hdisplay, mode.htotal,\n\t\t\tmode.hsync_start, mode.hsync_end,\n\t\t\tmode.hskew);\n\t}\n\n\tdrm_mode_to_intf_timing_params(phys_enc, &mode, &timing_params);\n\n\tfmt = dpu_get_dpu_format(fmt_fourcc);\n\tDPU_DEBUG_VIDENC(phys_enc, \"fmt_fourcc 0x%X\\n\", fmt_fourcc);\n\n\tif (phys_enc->hw_cdm)\n\t\tintf_cfg.cdm = phys_enc->hw_cdm->idx;\n\tintf_cfg.intf = phys_enc->hw_intf->idx;\n\tintf_cfg.intf_mode_sel = DPU_CTL_MODE_SEL_VID;\n\tintf_cfg.stream_sel = 0; /* Don't care value for video mode */\n\tintf_cfg.mode_3d = dpu_encoder_helper_get_3d_blend_mode(phys_enc);\n\tintf_cfg.dsc = dpu_encoder_helper_get_dsc(phys_enc);\n\tif (phys_enc->hw_pp->merge_3d)\n\t\tintf_cfg.merge_3d = phys_enc->hw_pp->merge_3d->idx;\n\n\tspin_lock_irqsave(phys_enc->enc_spinlock, lock_flags);\n\tphys_enc->hw_intf->ops.setup_timing_gen(phys_enc->hw_intf,\n\t\t\t&timing_params, fmt);\n\tphys_enc->hw_ctl->ops.setup_intf_cfg(phys_enc->hw_ctl, &intf_cfg);\n\n\t/* setup which pp blk will connect to this intf */\n\tif (phys_enc->hw_intf->ops.bind_pingpong_blk)\n\t\tphys_enc->hw_intf->ops.bind_pingpong_blk(\n\t\t\t\tphys_enc->hw_intf,\n\t\t\t\tphys_enc->hw_pp->idx);\n\n\tif (phys_enc->hw_pp->merge_3d)\n\t\tphys_enc->hw_pp->merge_3d->ops.setup_3d_mode(phys_enc->hw_pp->merge_3d, intf_cfg.mode_3d);\n\n\tspin_unlock_irqrestore(phys_enc->enc_spinlock, lock_flags);\n\n\tprogrammable_fetch_config(phys_enc, &timing_params);\n}"
    },
    {
        "var_name": "plane",
        "function_name": "_dpu_plane_get_kms",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c",
            "region": {
                "startLine": 100,
                "startColumn": 33,
                "endColumn": 38
            },
            "context": {
                "startLine": 98,
                "endLine": 102,
                "snippet": {
                    "text": "struct msm_drm_private *priv = plane->dev->dev_private;"
                }
            }
        },
        "function_code": "static struct dpu_kms *_dpu_plane_get_kms(struct drm_plane *plane)\n{\n\tstruct msm_drm_private *priv = plane->dev->dev_private;\n\n\treturn to_dpu_kms(priv->kms);\n}"
    },
    {
        "var_name": "pll_rate",
        "function_name": "mpd4_lvds_pll_enable",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/mdp4/mdp4_lvds_pll.c",
            "region": {
                "startLine": 64,
                "startColumn": 44,
                "endColumn": 52
            },
            "context": {
                "startLine": 62,
                "endLine": 66,
                "snippet": {
                    "text": "DBG(\"pixclk=%lu (%lu)\", lvds_pll->pixclk, pll_rate->rate);"
                }
            }
        },
        "function_code": "static int mpd4_lvds_pll_enable(struct clk_hw *hw)\n{\n\tstruct mdp4_lvds_pll *lvds_pll = to_mdp4_lvds_pll(hw);\n\tstruct mdp4_kms *mdp4_kms = get_kms(lvds_pll);\n\tconst struct pll_rate *pll_rate = find_rate(lvds_pll->pixclk);\n\tint i;\n\n\tDBG(\"pixclk=%lu (%lu)\", lvds_pll->pixclk, pll_rate->rate);\n\n\tif (WARN_ON(!pll_rate))\n\t\treturn -EINVAL;\n\n\tmdp4_write(mdp4_kms, REG_MDP4_LCDC_LVDS_PHY_RESET, 0x33);\n\n\tfor (i = 0; pll_rate->conf[i].reg; i++)\n\t\tmdp4_write(mdp4_kms, pll_rate->conf[i].reg, pll_rate->conf[i].val);\n\n\tmdp4_write(mdp4_kms, REG_MDP4_LVDS_PHY_PLL_CTRL_0, 0x01);\n\n\t/* Wait until LVDS PLL is locked and ready */\n\twhile (!mdp4_read(mdp4_kms, REG_MDP4_LVDS_PHY_PLL_LOCKED))\n\t\tcpu_relax();\n\n\treturn 0;\n}"
    },
    {
        "var_name": "arcs",
        "function_name": "msm_hdmi_audio_update",
        "location": {
            "file_path": "drivers/gpu/drm/msm/hdmi/hdmi_audio.c",
            "region": {
                "startLine": 118,
                "startColumn": 9,
                "endColumn": 13
            },
            "context": {
                "startLine": 116,
                "endLine": 120,
                "snippet": {
                    "text": "n   = arcs->lut[audio->rate].n;"
                }
            }
        },
        "function_code": "int msm_hdmi_audio_update(struct hdmi *hdmi)\n{\n\tstruct hdmi_audio *audio = &hdmi->audio;\n\tstruct hdmi_audio_infoframe *info = &audio->infoframe;\n\tconst struct hdmi_msm_audio_arcs *arcs = NULL;\n\tbool enabled = audio->enabled;\n\tuint32_t acr_pkt_ctrl, vbi_pkt_ctrl, aud_pkt_ctrl;\n\tuint32_t infofrm_ctrl, audio_config;\n\n\tDBG(\"audio: enabled=%d, channels=%d, channel_allocation=0x%x, \"\n\t\t\"level_shift_value=%d, downmix_inhibit=%d, rate=%d\",\n\t\taudio->enabled, info->channels,  info->channel_allocation,\n\t\tinfo->level_shift_value, info->downmix_inhibit, audio->rate);\n\tDBG(\"video: power_on=%d, pixclock=%lu\", hdmi->power_on, hdmi->pixclock);\n\n\tif (enabled && !(hdmi->power_on && hdmi->pixclock)) {\n\t\tDBG(\"disabling audio: no video\");\n\t\tenabled = false;\n\t}\n\n\tif (enabled) {\n\t\tarcs = get_arcs(hdmi->pixclock);\n\t\tif (!arcs) {\n\t\t\tDBG(\"disabling audio: unsupported pixclock: %lu\",\n\t\t\t\t\thdmi->pixclock);\n\t\t\tenabled = false;\n\t\t}\n\t}\n\n\t/* Read first before writing */\n\tacr_pkt_ctrl = hdmi_read(hdmi, REG_HDMI_ACR_PKT_CTRL);\n\tvbi_pkt_ctrl = hdmi_read(hdmi, REG_HDMI_VBI_PKT_CTRL);\n\taud_pkt_ctrl = hdmi_read(hdmi, REG_HDMI_AUDIO_PKT_CTRL1);\n\tinfofrm_ctrl = hdmi_read(hdmi, REG_HDMI_INFOFRAME_CTRL0);\n\taudio_config = hdmi_read(hdmi, REG_HDMI_AUDIO_CFG);\n\n\t/* Clear N/CTS selection bits */\n\tacr_pkt_ctrl &= ~HDMI_ACR_PKT_CTRL_SELECT__MASK;\n\n\tif (enabled) {\n\t\tuint32_t n, cts, multiplier;\n\t\tenum hdmi_acr_cts select;\n\t\tuint8_t buf[14];\n\n\t\tn   = arcs->lut[audio->rate].n;\n\t\tcts = arcs->lut[audio->rate].cts;\n\n\t\tif ((MSM_HDMI_SAMPLE_RATE_192KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_176_4KHZ == audio->rate)) {\n\t\t\tmultiplier = 4;\n\t\t\tn >>= 2; /* divide N by 4 and use multiplier */\n\t\t} else if ((MSM_HDMI_SAMPLE_RATE_96KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_88_2KHZ == audio->rate)) {\n\t\t\tmultiplier = 2;\n\t\t\tn >>= 1; /* divide N by 2 and use multiplier */\n\t\t} else {\n\t\t\tmultiplier = 1;\n\t\t}\n\n\t\tDBG(\"n=%u, cts=%u, multiplier=%u\", n, cts, multiplier);\n\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_SOURCE;\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_AUDIO_PRIORITY;\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_N_MULTIPLIER(multiplier);\n\n\t\tif ((MSM_HDMI_SAMPLE_RATE_48KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_96KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_192KHZ == audio->rate))\n\t\t\tselect = ACR_48;\n\t\telse if ((MSM_HDMI_SAMPLE_RATE_44_1KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_88_2KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_176_4KHZ == audio->rate))\n\t\t\tselect = ACR_44;\n\t\telse /* default to 32k */\n\t\t\tselect = ACR_32;\n\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_SELECT(select);\n\n\t\thdmi_write(hdmi, REG_HDMI_ACR_0(select - 1),\n\t\t\t\tHDMI_ACR_0_CTS(cts));\n\t\thdmi_write(hdmi, REG_HDMI_ACR_1(select - 1),\n\t\t\t\tHDMI_ACR_1_N(n));\n\n\t\thdmi_write(hdmi, REG_HDMI_AUDIO_PKT_CTRL2,\n\t\t\t\tCOND(info->channels != 2, HDMI_AUDIO_PKT_CTRL2_LAYOUT) |\n\t\t\t\tHDMI_AUDIO_PKT_CTRL2_OVERRIDE);\n\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_CONT;\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_SEND;\n\n\t\t/* configure infoframe: */\n\t\thdmi_audio_infoframe_pack(info, buf, sizeof(buf));\n\t\thdmi_write(hdmi, REG_HDMI_AUDIO_INFO0,\n\t\t\t\t(buf[3] <<  0) | (buf[4] <<  8) |\n\t\t\t\t(buf[5] << 16) | (buf[6] << 24));\n\t\thdmi_write(hdmi, REG_HDMI_AUDIO_INFO1,\n\t\t\t\t(buf[7] <<  0) | (buf[8] << 8));\n\n\t\thdmi_write(hdmi, REG_HDMI_GC, 0);\n\n\t\tvbi_pkt_ctrl |= HDMI_VBI_PKT_CTRL_GC_ENABLE;\n\t\tvbi_pkt_ctrl |= HDMI_VBI_PKT_CTRL_GC_EVERY_FRAME;\n\n\t\taud_pkt_ctrl |= HDMI_AUDIO_PKT_CTRL1_AUDIO_SAMPLE_SEND;\n\n\t\tinfofrm_ctrl |= HDMI_INFOFRAME_CTRL0_AUDIO_INFO_SEND;\n\t\tinfofrm_ctrl |= HDMI_INFOFRAME_CTRL0_AUDIO_INFO_CONT;\n\t\tinfofrm_ctrl |= HDMI_INFOFRAME_CTRL0_AUDIO_INFO_SOURCE;\n\t\tinfofrm_ctrl |= HDMI_INFOFRAME_CTRL0_AUDIO_INFO_UPDATE;\n\n\t\taudio_config &= ~HDMI_AUDIO_CFG_FIFO_WATERMARK__MASK;\n\t\taudio_config |= HDMI_AUDIO_CFG_FIFO_WATERMARK(4);\n\t\taudio_config |= HDMI_AUDIO_CFG_ENGINE_ENABLE;\n\t} else {\n\t\tacr_pkt_ctrl &= ~HDMI_ACR_PKT_CTRL_CONT;\n\t\tacr_pkt_ctrl &= ~HDMI_ACR_PKT_CTRL_SEND;\n\t\tvbi_pkt_ctrl &= ~HDMI_VBI_PKT_CTRL_GC_ENABLE;\n\t\tvbi_pkt_ctrl &= ~HDMI_VBI_PKT_CTRL_GC_EVERY_FRAME;\n\t\taud_pkt_ctrl &= ~HDMI_AUDIO_PKT_CTRL1_AUDIO_SAMPLE_SEND;\n\t\tinfofrm_ctrl &= ~HDMI_INFOFRAME_CTRL0_AUDIO_INFO_SEND;\n\t\tinfofrm_ctrl &= ~HDMI_INFOFRAME_CTRL0_AUDIO_INFO_CONT;\n\t\tinfofrm_ctrl &= ~HDMI_INFOFRAME_CTRL0_AUDIO_INFO_SOURCE;\n\t\tinfofrm_ctrl &= ~HDMI_INFOFRAME_CTRL0_AUDIO_INFO_UPDATE;\n\t\taudio_config &= ~HDMI_AUDIO_CFG_ENGINE_ENABLE;\n\t}\n\n\thdmi_write(hdmi, REG_HDMI_ACR_PKT_CTRL, acr_pkt_ctrl);\n\thdmi_write(hdmi, REG_HDMI_VBI_PKT_CTRL, vbi_pkt_ctrl);\n\thdmi_write(hdmi, REG_HDMI_AUDIO_PKT_CTRL1, aud_pkt_ctrl);\n\thdmi_write(hdmi, REG_HDMI_INFOFRAME_CTRL0, infofrm_ctrl);\n\n\thdmi_write(hdmi, REG_HDMI_AUD_INT,\n\t\t\tCOND(enabled, HDMI_AUD_INT_AUD_FIFO_URUN_INT) |\n\t\t\tCOND(enabled, HDMI_AUD_INT_AUD_SAM_DROP_INT));\n\n\thdmi_write(hdmi, REG_HDMI_AUDIO_CFG, audio_config);\n\n\n\tDBG(\"audio %sabled\", enabled ? \"en\" : \"dis\");\n\n\treturn 0;\n}"
    },
    {
        "var_name": "arcs",
        "function_name": "msm_hdmi_audio_update",
        "location": {
            "file_path": "drivers/gpu/drm/msm/hdmi/hdmi_audio.c",
            "region": {
                "startLine": 119,
                "startColumn": 9,
                "endColumn": 13
            },
            "context": {
                "startLine": 117,
                "endLine": 121,
                "snippet": {
                    "text": "cts = arcs->lut[audio->rate].cts;"
                }
            }
        },
        "function_code": "int msm_hdmi_audio_update(struct hdmi *hdmi)\n{\n\tstruct hdmi_audio *audio = &hdmi->audio;\n\tstruct hdmi_audio_infoframe *info = &audio->infoframe;\n\tconst struct hdmi_msm_audio_arcs *arcs = NULL;\n\tbool enabled = audio->enabled;\n\tuint32_t acr_pkt_ctrl, vbi_pkt_ctrl, aud_pkt_ctrl;\n\tuint32_t infofrm_ctrl, audio_config;\n\n\tDBG(\"audio: enabled=%d, channels=%d, channel_allocation=0x%x, \"\n\t\t\"level_shift_value=%d, downmix_inhibit=%d, rate=%d\",\n\t\taudio->enabled, info->channels,  info->channel_allocation,\n\t\tinfo->level_shift_value, info->downmix_inhibit, audio->rate);\n\tDBG(\"video: power_on=%d, pixclock=%lu\", hdmi->power_on, hdmi->pixclock);\n\n\tif (enabled && !(hdmi->power_on && hdmi->pixclock)) {\n\t\tDBG(\"disabling audio: no video\");\n\t\tenabled = false;\n\t}\n\n\tif (enabled) {\n\t\tarcs = get_arcs(hdmi->pixclock);\n\t\tif (!arcs) {\n\t\t\tDBG(\"disabling audio: unsupported pixclock: %lu\",\n\t\t\t\t\thdmi->pixclock);\n\t\t\tenabled = false;\n\t\t}\n\t}\n\n\t/* Read first before writing */\n\tacr_pkt_ctrl = hdmi_read(hdmi, REG_HDMI_ACR_PKT_CTRL);\n\tvbi_pkt_ctrl = hdmi_read(hdmi, REG_HDMI_VBI_PKT_CTRL);\n\taud_pkt_ctrl = hdmi_read(hdmi, REG_HDMI_AUDIO_PKT_CTRL1);\n\tinfofrm_ctrl = hdmi_read(hdmi, REG_HDMI_INFOFRAME_CTRL0);\n\taudio_config = hdmi_read(hdmi, REG_HDMI_AUDIO_CFG);\n\n\t/* Clear N/CTS selection bits */\n\tacr_pkt_ctrl &= ~HDMI_ACR_PKT_CTRL_SELECT__MASK;\n\n\tif (enabled) {\n\t\tuint32_t n, cts, multiplier;\n\t\tenum hdmi_acr_cts select;\n\t\tuint8_t buf[14];\n\n\t\tn   = arcs->lut[audio->rate].n;\n\t\tcts = arcs->lut[audio->rate].cts;\n\n\t\tif ((MSM_HDMI_SAMPLE_RATE_192KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_176_4KHZ == audio->rate)) {\n\t\t\tmultiplier = 4;\n\t\t\tn >>= 2; /* divide N by 4 and use multiplier */\n\t\t} else if ((MSM_HDMI_SAMPLE_RATE_96KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_88_2KHZ == audio->rate)) {\n\t\t\tmultiplier = 2;\n\t\t\tn >>= 1; /* divide N by 2 and use multiplier */\n\t\t} else {\n\t\t\tmultiplier = 1;\n\t\t}\n\n\t\tDBG(\"n=%u, cts=%u, multiplier=%u\", n, cts, multiplier);\n\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_SOURCE;\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_AUDIO_PRIORITY;\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_N_MULTIPLIER(multiplier);\n\n\t\tif ((MSM_HDMI_SAMPLE_RATE_48KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_96KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_192KHZ == audio->rate))\n\t\t\tselect = ACR_48;\n\t\telse if ((MSM_HDMI_SAMPLE_RATE_44_1KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_88_2KHZ == audio->rate) ||\n\t\t\t\t(MSM_HDMI_SAMPLE_RATE_176_4KHZ == audio->rate))\n\t\t\tselect = ACR_44;\n\t\telse /* default to 32k */\n\t\t\tselect = ACR_32;\n\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_SELECT(select);\n\n\t\thdmi_write(hdmi, REG_HDMI_ACR_0(select - 1),\n\t\t\t\tHDMI_ACR_0_CTS(cts));\n\t\thdmi_write(hdmi, REG_HDMI_ACR_1(select - 1),\n\t\t\t\tHDMI_ACR_1_N(n));\n\n\t\thdmi_write(hdmi, REG_HDMI_AUDIO_PKT_CTRL2,\n\t\t\t\tCOND(info->channels != 2, HDMI_AUDIO_PKT_CTRL2_LAYOUT) |\n\t\t\t\tHDMI_AUDIO_PKT_CTRL2_OVERRIDE);\n\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_CONT;\n\t\tacr_pkt_ctrl |= HDMI_ACR_PKT_CTRL_SEND;\n\n\t\t/* configure infoframe: */\n\t\thdmi_audio_infoframe_pack(info, buf, sizeof(buf));\n\t\thdmi_write(hdmi, REG_HDMI_AUDIO_INFO0,\n\t\t\t\t(buf[3] <<  0) | (buf[4] <<  8) |\n\t\t\t\t(buf[5] << 16) | (buf[6] << 24));\n\t\thdmi_write(hdmi, REG_HDMI_AUDIO_INFO1,\n\t\t\t\t(buf[7] <<  0) | (buf[8] << 8));\n\n\t\thdmi_write(hdmi, REG_HDMI_GC, 0);\n\n\t\tvbi_pkt_ctrl |= HDMI_VBI_PKT_CTRL_GC_ENABLE;\n\t\tvbi_pkt_ctrl |= HDMI_VBI_PKT_CTRL_GC_EVERY_FRAME;\n\n\t\taud_pkt_ctrl |= HDMI_AUDIO_PKT_CTRL1_AUDIO_SAMPLE_SEND;\n\n\t\tinfofrm_ctrl |= HDMI_INFOFRAME_CTRL0_AUDIO_INFO_SEND;\n\t\tinfofrm_ctrl |= HDMI_INFOFRAME_CTRL0_AUDIO_INFO_CONT;\n\t\tinfofrm_ctrl |= HDMI_INFOFRAME_CTRL0_AUDIO_INFO_SOURCE;\n\t\tinfofrm_ctrl |= HDMI_INFOFRAME_CTRL0_AUDIO_INFO_UPDATE;\n\n\t\taudio_config &= ~HDMI_AUDIO_CFG_FIFO_WATERMARK__MASK;\n\t\taudio_config |= HDMI_AUDIO_CFG_FIFO_WATERMARK(4);\n\t\taudio_config |= HDMI_AUDIO_CFG_ENGINE_ENABLE;\n\t} else {\n\t\tacr_pkt_ctrl &= ~HDMI_ACR_PKT_CTRL_CONT;\n\t\tacr_pkt_ctrl &= ~HDMI_ACR_PKT_CTRL_SEND;\n\t\tvbi_pkt_ctrl &= ~HDMI_VBI_PKT_CTRL_GC_ENABLE;\n\t\tvbi_pkt_ctrl &= ~HDMI_VBI_PKT_CTRL_GC_EVERY_FRAME;\n\t\taud_pkt_ctrl &= ~HDMI_AUDIO_PKT_CTRL1_AUDIO_SAMPLE_SEND;\n\t\tinfofrm_ctrl &= ~HDMI_INFOFRAME_CTRL0_AUDIO_INFO_SEND;\n\t\tinfofrm_ctrl &= ~HDMI_INFOFRAME_CTRL0_AUDIO_INFO_CONT;\n\t\tinfofrm_ctrl &= ~HDMI_INFOFRAME_CTRL0_AUDIO_INFO_SOURCE;\n\t\tinfofrm_ctrl &= ~HDMI_INFOFRAME_CTRL0_AUDIO_INFO_UPDATE;\n\t\taudio_config &= ~HDMI_AUDIO_CFG_ENGINE_ENABLE;\n\t}\n\n\thdmi_write(hdmi, REG_HDMI_ACR_PKT_CTRL, acr_pkt_ctrl);\n\thdmi_write(hdmi, REG_HDMI_VBI_PKT_CTRL, vbi_pkt_ctrl);\n\thdmi_write(hdmi, REG_HDMI_AUDIO_PKT_CTRL1, aud_pkt_ctrl);\n\thdmi_write(hdmi, REG_HDMI_INFOFRAME_CTRL0, infofrm_ctrl);\n\n\thdmi_write(hdmi, REG_HDMI_AUD_INT,\n\t\t\tCOND(enabled, HDMI_AUD_INT_AUD_FIFO_URUN_INT) |\n\t\t\tCOND(enabled, HDMI_AUD_INT_AUD_SAM_DROP_INT));\n\n\thdmi_write(hdmi, REG_HDMI_AUDIO_CFG, audio_config);\n\n\n\tDBG(\"audio %sabled\", enabled ? \"en\" : \"dis\");\n\n\treturn 0;\n}"
    },
    {
        "var_name": "kms",
        "function_name": "msm_irq",
        "location": {
            "file_path": "drivers/gpu/drm/msm/msm_kms.c",
            "region": {
                "startLine": 41,
                "startColumn": 9,
                "endColumn": 12
            },
            "context": {
                "startLine": 39,
                "endLine": 43,
                "snippet": {
                    "text": "return kms->funcs->irq(kms);"
                }
            }
        },
        "function_code": "static irqreturn_t msm_irq(int irq, void *arg)\n{\n\tstruct drm_device *dev = arg;\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_kms *kms = priv->kms;\n\n\tBUG_ON(!kms);\n\n\treturn kms->funcs->irq(kms);\n}"
    },
    {
        "var_name": "kms",
        "function_name": "msm_irq_preinstall",
        "location": {
            "file_path": "drivers/gpu/drm/msm/msm_kms.c",
            "region": {
                "startLine": 51,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 49,
                "endLine": 53,
                "snippet": {
                    "text": "kms->funcs->irq_preinstall(kms);"
                }
            }
        },
        "function_code": "static void msm_irq_preinstall(struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_kms *kms = priv->kms;\n\n\tBUG_ON(!kms);\n\n\tkms->funcs->irq_preinstall(kms);\n}"
    },
    {
        "var_name": "kms",
        "function_name": "msm_irq_postinstall",
        "location": {
            "file_path": "drivers/gpu/drm/msm/msm_kms.c",
            "region": {
                "startLine": 61,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 59,
                "endLine": 63,
                "snippet": {
                    "text": "if (kms->funcs->irq_postinstall)"
                }
            }
        },
        "function_code": "static int msm_irq_postinstall(struct drm_device *dev)\n{\n\tstruct msm_drm_private *priv = dev->dev_private;\n\tstruct msm_kms *kms = priv->kms;\n\n\tBUG_ON(!kms);\n\n\tif (kms->funcs->irq_postinstall)\n\t\treturn kms->funcs->irq_postinstall(kms);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "drm_fb",
        "function_name": "nv04_crtc_do_mode_set_base",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/dispnv04/crtc.c",
            "region": {
                "startLine": 854,
                "startColumn": 28,
                "endColumn": 34
            },
            "context": {
                "startLine": 852,
                "endLine": 856,
                "snippet": {
                    "text": "nvbo = nouveau_gem_object(drm_fb->obj[0]);"
                }
            }
        },
        "function_code": "static int\nnv04_crtc_do_mode_set_base(struct drm_crtc *crtc,\n\t\t\t   struct drm_framebuffer *passed_fb,\n\t\t\t   int x, int y, bool atomic)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\tstruct nouveau_bo *nvbo;\n\tstruct drm_framebuffer *drm_fb;\n\tint arb_burst, arb_lwm;\n\n\tNV_DEBUG(drm, \"index %d\\n\", nv_crtc->index);\n\n\t/* no fb bound */\n\tif (!atomic && !crtc->primary->fb) {\n\t\tNV_DEBUG(drm, \"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\n\t/* If atomic, we want to switch to the fb we were passed, so\n\t * now we update pointers to do that.\n\t */\n\tif (atomic) {\n\t\tdrm_fb = passed_fb;\n\t} else {\n\t\tdrm_fb = crtc->primary->fb;\n\t}\n\n\tnvbo = nouveau_gem_object(drm_fb->obj[0]);\n\tnv_crtc->fb.offset = nvbo->offset;\n\n\tif (nv_crtc->lut.depth != drm_fb->format->depth) {\n\t\tnv_crtc->lut.depth = drm_fb->format->depth;\n\t\tnv_crtc_gamma_load(crtc);\n\t}\n\n\t/* Update the framebuffer format. */\n\tregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] &= ~3;\n\tregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] |= (drm_fb->format->depth + 1) / 8;\n\tregp->ramdac_gen_ctrl &= ~NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\n\tif (drm_fb->format->depth == 16)\n\t\tregp->ramdac_gen_ctrl |= NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_PIXEL_INDEX);\n\tNVWriteRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_GENERAL_CONTROL,\n\t\t      regp->ramdac_gen_ctrl);\n\n\tregp->CRTC[NV_CIO_CR_OFFSET_INDEX] = drm_fb->pitches[0] >> 3;\n\tregp->CRTC[NV_CIO_CRE_RPC0_INDEX] =\n\t\tXLATE(drm_fb->pitches[0] >> 3, 8, NV_CIO_CRE_RPC0_OFFSET_10_8);\n\tregp->CRTC[NV_CIO_CRE_42] =\n\t\tXLATE(drm_fb->pitches[0] / 8, 11, NV_CIO_CRE_42_OFFSET_11);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_RPC0_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CR_OFFSET_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_42);\n\n\t/* Update the framebuffer location. */\n\tregp->fb_start = nv_crtc->fb.offset & ~3;\n\tregp->fb_start += (y * drm_fb->pitches[0]) + (x * drm_fb->format->cpp[0]);\n\tnv_set_crtc_base(dev, nv_crtc->index, regp->fb_start);\n\n\t/* Update the arbitration parameters. */\n\tnouveau_calc_arb(dev, crtc->mode.clock, drm_fb->format->cpp[0] * 8,\n\t\t\t &arb_burst, &arb_lwm);\n\n\tregp->CRTC[NV_CIO_CRE_FF_INDEX] = arb_burst;\n\tregp->CRTC[NV_CIO_CRE_FFLWM__INDEX] = arb_lwm & 0xff;\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_FF_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_FFLWM__INDEX);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_KELVIN) {\n\t\tregp->CRTC[NV_CIO_CRE_47] = arb_lwm >> 8;\n\t\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_47);\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "drm_fb",
        "function_name": "nv04_crtc_do_mode_set_base",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/dispnv04/crtc.c",
            "region": {
                "startLine": 857,
                "startColumn": 28,
                "endColumn": 34
            },
            "context": {
                "startLine": 855,
                "endLine": 859,
                "snippet": {
                    "text": "if (nv_crtc->lut.depth != drm_fb->format->depth) {"
                }
            }
        },
        "function_code": "static int\nnv04_crtc_do_mode_set_base(struct drm_crtc *crtc,\n\t\t\t   struct drm_framebuffer *passed_fb,\n\t\t\t   int x, int y, bool atomic)\n{\n\tstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\n\tstruct drm_device *dev = crtc->dev;\n\tstruct nouveau_drm *drm = nouveau_drm(dev);\n\tstruct nv04_crtc_reg *regp = &nv04_display(dev)->mode_reg.crtc_reg[nv_crtc->index];\n\tstruct nouveau_bo *nvbo;\n\tstruct drm_framebuffer *drm_fb;\n\tint arb_burst, arb_lwm;\n\n\tNV_DEBUG(drm, \"index %d\\n\", nv_crtc->index);\n\n\t/* no fb bound */\n\tif (!atomic && !crtc->primary->fb) {\n\t\tNV_DEBUG(drm, \"No FB bound\\n\");\n\t\treturn 0;\n\t}\n\n\t/* If atomic, we want to switch to the fb we were passed, so\n\t * now we update pointers to do that.\n\t */\n\tif (atomic) {\n\t\tdrm_fb = passed_fb;\n\t} else {\n\t\tdrm_fb = crtc->primary->fb;\n\t}\n\n\tnvbo = nouveau_gem_object(drm_fb->obj[0]);\n\tnv_crtc->fb.offset = nvbo->offset;\n\n\tif (nv_crtc->lut.depth != drm_fb->format->depth) {\n\t\tnv_crtc->lut.depth = drm_fb->format->depth;\n\t\tnv_crtc_gamma_load(crtc);\n\t}\n\n\t/* Update the framebuffer format. */\n\tregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] &= ~3;\n\tregp->CRTC[NV_CIO_CRE_PIXEL_INDEX] |= (drm_fb->format->depth + 1) / 8;\n\tregp->ramdac_gen_ctrl &= ~NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\n\tif (drm_fb->format->depth == 16)\n\t\tregp->ramdac_gen_ctrl |= NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL;\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_PIXEL_INDEX);\n\tNVWriteRAMDAC(dev, nv_crtc->index, NV_PRAMDAC_GENERAL_CONTROL,\n\t\t      regp->ramdac_gen_ctrl);\n\n\tregp->CRTC[NV_CIO_CR_OFFSET_INDEX] = drm_fb->pitches[0] >> 3;\n\tregp->CRTC[NV_CIO_CRE_RPC0_INDEX] =\n\t\tXLATE(drm_fb->pitches[0] >> 3, 8, NV_CIO_CRE_RPC0_OFFSET_10_8);\n\tregp->CRTC[NV_CIO_CRE_42] =\n\t\tXLATE(drm_fb->pitches[0] / 8, 11, NV_CIO_CRE_42_OFFSET_11);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_RPC0_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CR_OFFSET_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_42);\n\n\t/* Update the framebuffer location. */\n\tregp->fb_start = nv_crtc->fb.offset & ~3;\n\tregp->fb_start += (y * drm_fb->pitches[0]) + (x * drm_fb->format->cpp[0]);\n\tnv_set_crtc_base(dev, nv_crtc->index, regp->fb_start);\n\n\t/* Update the arbitration parameters. */\n\tnouveau_calc_arb(dev, crtc->mode.clock, drm_fb->format->cpp[0] * 8,\n\t\t\t &arb_burst, &arb_lwm);\n\n\tregp->CRTC[NV_CIO_CRE_FF_INDEX] = arb_burst;\n\tregp->CRTC[NV_CIO_CRE_FFLWM__INDEX] = arb_lwm & 0xff;\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_FF_INDEX);\n\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_FFLWM__INDEX);\n\n\tif (drm->client.device.info.family >= NV_DEVICE_INFO_V0_KELVIN) {\n\t\tregp->CRTC[NV_CIO_CRE_47] = arb_lwm >> 8;\n\t\tcrtc_wr_cio_state(crtc, regp, NV_CIO_CRE_47);\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "outp",
        "function_name": "nouveau_dp_irq",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/nouveau_dp.c",
            "region": {
                "startLine": 502,
                "startColumn": 40,
                "endColumn": 44
            },
            "context": {
                "startLine": 500,
                "endLine": 504,
                "snippet": {
                    "text": "struct nouveau_drm *drm = nouveau_drm(outp->base.base.dev);"
                }
            }
        },
        "function_code": "void\nnouveau_dp_irq(struct work_struct *work)\n{\n\tstruct nouveau_connector *nv_connector =\n\t\tcontainer_of(work, typeof(*nv_connector), irq_work);\n\tstruct drm_connector *connector = &nv_connector->base;\n\tstruct nouveau_encoder *outp = find_encoder(connector, DCB_OUTPUT_DP);\n\tstruct nouveau_drm *drm = nouveau_drm(outp->base.base.dev);\n\tstruct nv50_mstm *mstm;\n\tu64 hpd = 0;\n\tint ret;\n\n\tif (!outp)\n\t\treturn;\n\n\tmstm = outp->dp.mstm;\n\tNV_DEBUG(drm, \"service %s\\n\", connector->name);\n\n\tmutex_lock(&outp->dp.hpd_irq_lock);\n\n\tif (mstm && mstm->is_mst) {\n\t\tif (!nv50_mstm_service(drm, nv_connector, mstm))\n\t\t\thpd |= NVIF_CONN_EVENT_V0_UNPLUG;\n\t} else {\n\t\tdrm_dp_cec_irq(&nv_connector->aux);\n\n\t\tif (nouveau_dp_has_sink_count(connector, outp)) {\n\t\t\tret = drm_dp_read_sink_count(&nv_connector->aux);\n\t\t\tif (ret != outp->dp.sink_count)\n\t\t\t\thpd |= NVIF_CONN_EVENT_V0_PLUG;\n\t\t\tif (ret >= 0)\n\t\t\t\toutp->dp.sink_count = ret;\n\t\t}\n\t}\n\n\tmutex_unlock(&outp->dp.hpd_irq_lock);\n\n\tnouveau_connector_hpd(nv_connector, NVIF_CONN_EVENT_V0_IRQ | hpd);\n}"
    },
    {
        "var_name": "args",
        "function_name": "op_map_prepare",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/nouveau_uvmm.c",
            "region": {
                "startLine": 593,
                "startColumn": 17,
                "endColumn": 21
            },
            "context": {
                "startLine": 591,
                "endLine": 595,
                "snippet": {
                    "text": "uvma->region = args->region;"
                }
            }
        },
        "function_code": "static int\nop_map_prepare(struct nouveau_uvmm *uvmm,\n\t       struct nouveau_uvma **puvma,\n\t       struct drm_gpuva_op_map *op,\n\t       struct uvmm_map_args *args)\n{\n\tstruct nouveau_uvma *uvma;\n\tint ret;\n\n\tret = nouveau_uvma_alloc(&uvma);\n\tif (ret)\n\t\treturn ret;\n\n\tuvma->region = args->region;\n\tuvma->kind = args->kind;\n\n\tdrm_gpuva_map(&uvmm->base, &uvma->va, op);\n\n\t/* Keep a reference until this uvma is destroyed. */\n\tnouveau_uvma_gem_get(uvma);\n\n\t*puvma = uvma;\n\treturn 0;\n}"
    },
    {
        "var_name": "args",
        "function_name": "op_map_prepare",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/nouveau_uvmm.c",
            "region": {
                "startLine": 594,
                "startColumn": 15,
                "endColumn": 19
            },
            "context": {
                "startLine": 592,
                "endLine": 596,
                "snippet": {
                    "text": "uvma->kind = args->kind;"
                }
            }
        },
        "function_code": "static int\nop_map_prepare(struct nouveau_uvmm *uvmm,\n\t       struct nouveau_uvma **puvma,\n\t       struct drm_gpuva_op_map *op,\n\t       struct uvmm_map_args *args)\n{\n\tstruct nouveau_uvma *uvma;\n\tint ret;\n\n\tret = nouveau_uvma_alloc(&uvma);\n\tif (ret)\n\t\treturn ret;\n\n\tuvma->region = args->region;\n\tuvma->kind = args->kind;\n\n\tdrm_gpuva_map(&uvmm->base, &uvma->va, op);\n\n\t/* Keep a reference until this uvma is destroyed. */\n\tnouveau_uvma_gem_get(uvma);\n\n\t*puvma = uvma;\n\treturn 0;\n}"
    },
    {
        "var_name": "fecs_inst",
        "function_name": "ga102_gr_load",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/nvkm/engine/gr/ga102.c",
            "region": {
                "startLine": 322,
                "startColumn": 21,
                "endColumn": 30
            },
            "context": {
                "startLine": 320,
                "endLine": 324,
                "snippet": {
                    "text": "fw->data + fecs_inst->data_offset,"
                }
            }
        },
        "function_code": "static int\nga102_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tconst struct firmware *fw;\n\tconst struct netlist_image *net;\n\tconst struct netlist_region *fecs_inst = NULL;\n\tconst struct netlist_region *fecs_data = NULL;\n\tconst struct netlist_region *gpccs_inst = NULL;\n\tconst struct netlist_region *gpccs_data = NULL;\n\tint ret, i;\n\n\tret = nvkm_firmware_get(subdev, \"gr/NET_img\", 0, &fw);\n\tif (ret)\n\t\treturn ret;\n\n\tnet = (const void *)fw->data;\n\tnvkm_debug(subdev, \"netlist version %d, %d regions\\n\",\n\t\t   net->header.version, net->header.regions);\n\n\tfor (i = 0; i < net->header.regions; i++) {\n\t\tconst struct netlist_region *reg = &net->regions[i];\n\t\tstruct nvkm_blob blob = {\n\t\t\t.data = (void *)fw->data + reg->data_offset,\n\t\t\t.size = reg->data_size,\n\t\t};\n\n\t\tnvkm_debug(subdev, \"\\t%2d: %08x %08x\\n\",\n\t\t\t   reg->region_id, reg->data_offset, reg->data_size);\n\n\t\tswitch (reg->region_id) {\n\t\tcase  0: fecs_data = reg; break;\n\t\tcase  1: fecs_inst = reg; break;\n\t\tcase  2: gpccs_data = reg; break;\n\t\tcase  3: gpccs_inst = reg; break;\n\t\tcase  4: gk20a_gr_av_to_init(&blob, &gr->bundle); break;\n\t\tcase  5: gk20a_gr_aiv_to_init(&blob, &gr->sw_ctx); break;\n\t\tcase  7: gk20a_gr_av_to_method(&blob, &gr->method); break;\n\t\tcase 28: tu102_gr_av_to_init_veid(&blob, &gr->bundle_veid); break;\n\t\tcase 34: ga102_gr_av64_to_init(&blob, &gr->bundle64); break;\n\t\tcase 48: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx1); break;\n\t\tcase 49: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx2); break;\n\t\tcase 50: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx3); break;\n\t\tcase 51: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx4); break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->fecs.falcon, NVKM_ACR_LSF_FECS,\n\t\t\t\t\t    \"gr/fecs_\", ver, fwif->fecs,\n\t\t\t\t\t    fw->data + fecs_inst->data_offset,\n\t\t\t\t\t\t       fecs_inst->data_size,\n\t\t\t\t\t    fw->data + fecs_data->data_offset,\n\t\t\t\t\t\t       fecs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->gpccs.falcon, NVKM_ACR_LSF_GPCCS,\n\t\t\t\t\t    \"gr/gpccs_\", ver, fwif->gpccs,\n\t\t\t\t\t    fw->data + gpccs_inst->data_offset,\n\t\t\t\t\t\t       gpccs_inst->data_size,\n\t\t\t\t\t    fw->data + gpccs_data->data_offset,\n\t\t\t\t\t\t       gpccs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tgr->firmware = true;\n\n\tnvkm_firmware_put(fw);\n\treturn 0;\n}"
    },
    {
        "var_name": "fecs_inst",
        "function_name": "ga102_gr_load",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/nvkm/engine/gr/ga102.c",
            "region": {
                "startLine": 323,
                "startColumn": 14,
                "endColumn": 23
            },
            "context": {
                "startLine": 321,
                "endLine": 325,
                "snippet": {
                    "text": "fecs_inst->data_size,"
                }
            }
        },
        "function_code": "static int\nga102_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tconst struct firmware *fw;\n\tconst struct netlist_image *net;\n\tconst struct netlist_region *fecs_inst = NULL;\n\tconst struct netlist_region *fecs_data = NULL;\n\tconst struct netlist_region *gpccs_inst = NULL;\n\tconst struct netlist_region *gpccs_data = NULL;\n\tint ret, i;\n\n\tret = nvkm_firmware_get(subdev, \"gr/NET_img\", 0, &fw);\n\tif (ret)\n\t\treturn ret;\n\n\tnet = (const void *)fw->data;\n\tnvkm_debug(subdev, \"netlist version %d, %d regions\\n\",\n\t\t   net->header.version, net->header.regions);\n\n\tfor (i = 0; i < net->header.regions; i++) {\n\t\tconst struct netlist_region *reg = &net->regions[i];\n\t\tstruct nvkm_blob blob = {\n\t\t\t.data = (void *)fw->data + reg->data_offset,\n\t\t\t.size = reg->data_size,\n\t\t};\n\n\t\tnvkm_debug(subdev, \"\\t%2d: %08x %08x\\n\",\n\t\t\t   reg->region_id, reg->data_offset, reg->data_size);\n\n\t\tswitch (reg->region_id) {\n\t\tcase  0: fecs_data = reg; break;\n\t\tcase  1: fecs_inst = reg; break;\n\t\tcase  2: gpccs_data = reg; break;\n\t\tcase  3: gpccs_inst = reg; break;\n\t\tcase  4: gk20a_gr_av_to_init(&blob, &gr->bundle); break;\n\t\tcase  5: gk20a_gr_aiv_to_init(&blob, &gr->sw_ctx); break;\n\t\tcase  7: gk20a_gr_av_to_method(&blob, &gr->method); break;\n\t\tcase 28: tu102_gr_av_to_init_veid(&blob, &gr->bundle_veid); break;\n\t\tcase 34: ga102_gr_av64_to_init(&blob, &gr->bundle64); break;\n\t\tcase 48: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx1); break;\n\t\tcase 49: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx2); break;\n\t\tcase 50: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx3); break;\n\t\tcase 51: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx4); break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->fecs.falcon, NVKM_ACR_LSF_FECS,\n\t\t\t\t\t    \"gr/fecs_\", ver, fwif->fecs,\n\t\t\t\t\t    fw->data + fecs_inst->data_offset,\n\t\t\t\t\t\t       fecs_inst->data_size,\n\t\t\t\t\t    fw->data + fecs_data->data_offset,\n\t\t\t\t\t\t       fecs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->gpccs.falcon, NVKM_ACR_LSF_GPCCS,\n\t\t\t\t\t    \"gr/gpccs_\", ver, fwif->gpccs,\n\t\t\t\t\t    fw->data + gpccs_inst->data_offset,\n\t\t\t\t\t\t       gpccs_inst->data_size,\n\t\t\t\t\t    fw->data + gpccs_data->data_offset,\n\t\t\t\t\t\t       gpccs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tgr->firmware = true;\n\n\tnvkm_firmware_put(fw);\n\treturn 0;\n}"
    },
    {
        "var_name": "fecs_data",
        "function_name": "ga102_gr_load",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/nvkm/engine/gr/ga102.c",
            "region": {
                "startLine": 324,
                "startColumn": 21,
                "endColumn": 30
            },
            "context": {
                "startLine": 322,
                "endLine": 326,
                "snippet": {
                    "text": "fw->data + fecs_data->data_offset,"
                }
            }
        },
        "function_code": "static int\nga102_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tconst struct firmware *fw;\n\tconst struct netlist_image *net;\n\tconst struct netlist_region *fecs_inst = NULL;\n\tconst struct netlist_region *fecs_data = NULL;\n\tconst struct netlist_region *gpccs_inst = NULL;\n\tconst struct netlist_region *gpccs_data = NULL;\n\tint ret, i;\n\n\tret = nvkm_firmware_get(subdev, \"gr/NET_img\", 0, &fw);\n\tif (ret)\n\t\treturn ret;\n\n\tnet = (const void *)fw->data;\n\tnvkm_debug(subdev, \"netlist version %d, %d regions\\n\",\n\t\t   net->header.version, net->header.regions);\n\n\tfor (i = 0; i < net->header.regions; i++) {\n\t\tconst struct netlist_region *reg = &net->regions[i];\n\t\tstruct nvkm_blob blob = {\n\t\t\t.data = (void *)fw->data + reg->data_offset,\n\t\t\t.size = reg->data_size,\n\t\t};\n\n\t\tnvkm_debug(subdev, \"\\t%2d: %08x %08x\\n\",\n\t\t\t   reg->region_id, reg->data_offset, reg->data_size);\n\n\t\tswitch (reg->region_id) {\n\t\tcase  0: fecs_data = reg; break;\n\t\tcase  1: fecs_inst = reg; break;\n\t\tcase  2: gpccs_data = reg; break;\n\t\tcase  3: gpccs_inst = reg; break;\n\t\tcase  4: gk20a_gr_av_to_init(&blob, &gr->bundle); break;\n\t\tcase  5: gk20a_gr_aiv_to_init(&blob, &gr->sw_ctx); break;\n\t\tcase  7: gk20a_gr_av_to_method(&blob, &gr->method); break;\n\t\tcase 28: tu102_gr_av_to_init_veid(&blob, &gr->bundle_veid); break;\n\t\tcase 34: ga102_gr_av64_to_init(&blob, &gr->bundle64); break;\n\t\tcase 48: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx1); break;\n\t\tcase 49: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx2); break;\n\t\tcase 50: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx3); break;\n\t\tcase 51: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx4); break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->fecs.falcon, NVKM_ACR_LSF_FECS,\n\t\t\t\t\t    \"gr/fecs_\", ver, fwif->fecs,\n\t\t\t\t\t    fw->data + fecs_inst->data_offset,\n\t\t\t\t\t\t       fecs_inst->data_size,\n\t\t\t\t\t    fw->data + fecs_data->data_offset,\n\t\t\t\t\t\t       fecs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->gpccs.falcon, NVKM_ACR_LSF_GPCCS,\n\t\t\t\t\t    \"gr/gpccs_\", ver, fwif->gpccs,\n\t\t\t\t\t    fw->data + gpccs_inst->data_offset,\n\t\t\t\t\t\t       gpccs_inst->data_size,\n\t\t\t\t\t    fw->data + gpccs_data->data_offset,\n\t\t\t\t\t\t       gpccs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tgr->firmware = true;\n\n\tnvkm_firmware_put(fw);\n\treturn 0;\n}"
    },
    {
        "var_name": "fecs_data",
        "function_name": "ga102_gr_load",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/nvkm/engine/gr/ga102.c",
            "region": {
                "startLine": 325,
                "startColumn": 14,
                "endColumn": 23
            },
            "context": {
                "startLine": 323,
                "endLine": 327,
                "snippet": {
                    "text": "fecs_data->data_size);"
                }
            }
        },
        "function_code": "static int\nga102_gr_load(struct gf100_gr *gr, int ver, const struct gf100_gr_fwif *fwif)\n{\n\tstruct nvkm_subdev *subdev = &gr->base.engine.subdev;\n\tconst struct firmware *fw;\n\tconst struct netlist_image *net;\n\tconst struct netlist_region *fecs_inst = NULL;\n\tconst struct netlist_region *fecs_data = NULL;\n\tconst struct netlist_region *gpccs_inst = NULL;\n\tconst struct netlist_region *gpccs_data = NULL;\n\tint ret, i;\n\n\tret = nvkm_firmware_get(subdev, \"gr/NET_img\", 0, &fw);\n\tif (ret)\n\t\treturn ret;\n\n\tnet = (const void *)fw->data;\n\tnvkm_debug(subdev, \"netlist version %d, %d regions\\n\",\n\t\t   net->header.version, net->header.regions);\n\n\tfor (i = 0; i < net->header.regions; i++) {\n\t\tconst struct netlist_region *reg = &net->regions[i];\n\t\tstruct nvkm_blob blob = {\n\t\t\t.data = (void *)fw->data + reg->data_offset,\n\t\t\t.size = reg->data_size,\n\t\t};\n\n\t\tnvkm_debug(subdev, \"\\t%2d: %08x %08x\\n\",\n\t\t\t   reg->region_id, reg->data_offset, reg->data_size);\n\n\t\tswitch (reg->region_id) {\n\t\tcase  0: fecs_data = reg; break;\n\t\tcase  1: fecs_inst = reg; break;\n\t\tcase  2: gpccs_data = reg; break;\n\t\tcase  3: gpccs_inst = reg; break;\n\t\tcase  4: gk20a_gr_av_to_init(&blob, &gr->bundle); break;\n\t\tcase  5: gk20a_gr_aiv_to_init(&blob, &gr->sw_ctx); break;\n\t\tcase  7: gk20a_gr_av_to_method(&blob, &gr->method); break;\n\t\tcase 28: tu102_gr_av_to_init_veid(&blob, &gr->bundle_veid); break;\n\t\tcase 34: ga102_gr_av64_to_init(&blob, &gr->bundle64); break;\n\t\tcase 48: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx1); break;\n\t\tcase 49: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx2); break;\n\t\tcase 50: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx3); break;\n\t\tcase 51: gk20a_gr_av_to_init(&blob, &gr->sw_nonctx4); break;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->fecs.falcon, NVKM_ACR_LSF_FECS,\n\t\t\t\t\t    \"gr/fecs_\", ver, fwif->fecs,\n\t\t\t\t\t    fw->data + fecs_inst->data_offset,\n\t\t\t\t\t\t       fecs_inst->data_size,\n\t\t\t\t\t    fw->data + fecs_data->data_offset,\n\t\t\t\t\t\t       fecs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nvkm_acr_lsfw_load_bl_sig_net(subdev, &gr->gpccs.falcon, NVKM_ACR_LSF_GPCCS,\n\t\t\t\t\t    \"gr/gpccs_\", ver, fwif->gpccs,\n\t\t\t\t\t    fw->data + gpccs_inst->data_offset,\n\t\t\t\t\t\t       gpccs_inst->data_size,\n\t\t\t\t\t    fw->data + gpccs_data->data_offset,\n\t\t\t\t\t\t       gpccs_data->data_size);\n\tif (ret)\n\t\treturn ret;\n\n\tgr->firmware = true;\n\n\tnvkm_firmware_put(fw);\n\treturn 0;\n}"
    },
    {
        "var_name": "page",
        "function_name": "nvkm_vmm_pt_new",
        "location": {
            "file_path": "drivers/gpu/drm/nouveau/nvkm/subdev/mmu/vmm.c",
            "region": {
                "startLine": 49,
                "startColumn": 39,
                "endColumn": 43
            },
            "context": {
                "startLine": 47,
                "endLine": 51,
                "snippet": {
                    "text": "const struct nvkm_vmm_desc *pair = page[-1].desc;"
                }
            }
        },
        "function_code": "static struct nvkm_vmm_pt *\nnvkm_vmm_pt_new(const struct nvkm_vmm_desc *desc, bool sparse,\n\t\tconst struct nvkm_vmm_page *page)\n{\n\tconst u32 pten = 1 << desc->bits;\n\tstruct nvkm_vmm_pt *pgt;\n\tu32 lpte = 0;\n\n\tif (desc->type > PGT) {\n\t\tif (desc->type == SPT) {\n\t\t\tconst struct nvkm_vmm_desc *pair = page[-1].desc;\n\t\t\tlpte = pten >> (desc->bits - pair->bits);\n\t\t} else {\n\t\t\tlpte = pten;\n\t\t}\n\t}\n\n\tif (!(pgt = kzalloc(sizeof(*pgt) + lpte, GFP_KERNEL)))\n\t\treturn NULL;\n\tpgt->page = page ? page->shift : 0;\n\tpgt->sparse = sparse;\n\n\tif (desc->type == PGD) {\n\t\tpgt->pde = kvcalloc(pten, sizeof(*pgt->pde), GFP_KERNEL);\n\t\tif (!pgt->pde) {\n\t\t\tkfree(pgt);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pgt;\n}"
    },
    {
        "var_name": "dst",
        "function_name": "omapdss_device_disconnect",
        "location": {
            "file_path": "drivers/gpu/drm/omapdrm/dss/base.c",
            "region": {
                "startLine": 169,
                "startColumn": 44,
                "endColumn": 47
            },
            "context": {
                "startLine": 167,
                "endLine": 171,
                "snippet": {
                    "text": "struct dss_device *dss = src ? src->dss : dst->dss;"
                }
            }
        },
        "function_code": "void omapdss_device_disconnect(struct omap_dss_device *src,\n\t\t\t       struct omap_dss_device *dst)\n{\n\tstruct dss_device *dss = src ? src->dss : dst->dss;\n\n\tdev_dbg(&dss->pdev->dev, \"disconnect(%s, %s)\\n\",\n\t\tsrc ? dev_name(src->dev) : \"NULL\",\n\t\tdst ? dev_name(dst->dev) : \"NULL\");\n\n\tif (!dst) {\n\t\tWARN_ON(!src->bridge);\n\t\treturn;\n\t}\n\n\tif (!dst->id && !omapdss_device_is_connected(dst)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tdst->dss = NULL;\n}"
    },
    {
        "var_name": "engine",
        "function_name": "dmm_txn_init",
        "location": {
            "file_path": "drivers/gpu/drm/omapdrm/omap_dmm_tiler.c",
            "region": {
                "startLine": 331,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 329,
                "endLine": 333,
                "snippet": {
                    "text": "engine->tcm = tcm;"
                }
            }
        },
        "function_code": "static struct dmm_txn *dmm_txn_init(struct dmm *dmm, struct tcm *tcm)\n{\n\tstruct dmm_txn *txn = NULL;\n\tstruct refill_engine *engine = NULL;\n\tint ret;\n\tunsigned long flags;\n\n\n\t/* wait until an engine is available */\n\tret = wait_event_interruptible(omap_dmm->engine_queue,\n\t\tatomic_add_unless(&omap_dmm->engine_counter, -1, 0));\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t/* grab an idle engine */\n\tspin_lock_irqsave(&list_lock, flags);\n\tif (!list_empty(&dmm->idle_head)) {\n\t\tengine = list_entry(dmm->idle_head.next, struct refill_engine,\n\t\t\t\t\tidle_node);\n\t\tlist_del(&engine->idle_node);\n\t}\n\tspin_unlock_irqrestore(&list_lock, flags);\n\n\tBUG_ON(!engine);\n\n\ttxn = &engine->txn;\n\tengine->tcm = tcm;\n\ttxn->engine_handle = engine;\n\ttxn->last_pat = NULL;\n\ttxn->current_va = engine->refill_va;\n\ttxn->current_pa = engine->refill_pa;\n\n\treturn txn;\n}"
    },
    {
        "var_name": "engine",
        "function_name": "dmm_txn_init",
        "location": {
            "file_path": "drivers/gpu/drm/omapdrm/omap_dmm_tiler.c",
            "region": {
                "startLine": 334,
                "startColumn": 20,
                "endColumn": 26
            },
            "context": {
                "startLine": 332,
                "endLine": 336,
                "snippet": {
                    "text": "txn->current_va = engine->refill_va;"
                }
            }
        },
        "function_code": "static struct dmm_txn *dmm_txn_init(struct dmm *dmm, struct tcm *tcm)\n{\n\tstruct dmm_txn *txn = NULL;\n\tstruct refill_engine *engine = NULL;\n\tint ret;\n\tunsigned long flags;\n\n\n\t/* wait until an engine is available */\n\tret = wait_event_interruptible(omap_dmm->engine_queue,\n\t\tatomic_add_unless(&omap_dmm->engine_counter, -1, 0));\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t/* grab an idle engine */\n\tspin_lock_irqsave(&list_lock, flags);\n\tif (!list_empty(&dmm->idle_head)) {\n\t\tengine = list_entry(dmm->idle_head.next, struct refill_engine,\n\t\t\t\t\tidle_node);\n\t\tlist_del(&engine->idle_node);\n\t}\n\tspin_unlock_irqrestore(&list_lock, flags);\n\n\tBUG_ON(!engine);\n\n\ttxn = &engine->txn;\n\tengine->tcm = tcm;\n\ttxn->engine_handle = engine;\n\ttxn->last_pat = NULL;\n\ttxn->current_va = engine->refill_va;\n\ttxn->current_pa = engine->refill_pa;\n\n\treturn txn;\n}"
    },
    {
        "var_name": "engine",
        "function_name": "dmm_txn_init",
        "location": {
            "file_path": "drivers/gpu/drm/omapdrm/omap_dmm_tiler.c",
            "region": {
                "startLine": 335,
                "startColumn": 20,
                "endColumn": 26
            },
            "context": {
                "startLine": 333,
                "endLine": 337,
                "snippet": {
                    "text": "txn->current_pa = engine->refill_pa;"
                }
            }
        },
        "function_code": "static struct dmm_txn *dmm_txn_init(struct dmm *dmm, struct tcm *tcm)\n{\n\tstruct dmm_txn *txn = NULL;\n\tstruct refill_engine *engine = NULL;\n\tint ret;\n\tunsigned long flags;\n\n\n\t/* wait until an engine is available */\n\tret = wait_event_interruptible(omap_dmm->engine_queue,\n\t\tatomic_add_unless(&omap_dmm->engine_counter, -1, 0));\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t/* grab an idle engine */\n\tspin_lock_irqsave(&list_lock, flags);\n\tif (!list_empty(&dmm->idle_head)) {\n\t\tengine = list_entry(dmm->idle_head.next, struct refill_engine,\n\t\t\t\t\tidle_node);\n\t\tlist_del(&engine->idle_node);\n\t}\n\tspin_unlock_irqrestore(&list_lock, flags);\n\n\tBUG_ON(!engine);\n\n\ttxn = &engine->txn;\n\tengine->tcm = tcm;\n\ttxn->engine_handle = engine;\n\ttxn->last_pat = NULL;\n\ttxn->current_va = engine->refill_va;\n\ttxn->current_pa = engine->refill_pa;\n\n\treturn txn;\n}"
    },
    {
        "var_name": "job",
        "function_name": "panfrost_dequeue_job",
        "location": {
            "file_path": "drivers/gpu/drm/panfrost/panfrost_job.c",
            "region": {
                "startLine": 162,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 160,
                "endLine": 164,
                "snippet": {
                    "text": "if (job->is_profiled) {"
                }
            }
        },
        "function_code": "static struct panfrost_job *\npanfrost_dequeue_job(struct panfrost_device *pfdev, int slot)\n{\n\tstruct panfrost_job *job = pfdev->jobs[slot][0];\n\n\tWARN_ON(!job);\n\tif (job->is_profiled) {\n\t\tif (job->engine_usage) {\n\t\t\tjob->engine_usage->elapsed_ns[slot] +=\n\t\t\t\tktime_to_ns(ktime_sub(ktime_get(), job->start_time));\n\t\t\tjob->engine_usage->cycles[slot] +=\n\t\t\t\tpanfrost_cycle_counter_read(pfdev) - job->start_cycles;\n\t\t}\n\t\tpanfrost_cycle_counter_put(job->pfdev);\n\t}\n\n\tpfdev->jobs[slot][0] = pfdev->jobs[slot][1];\n\tpfdev->jobs[slot][1] = NULL;\n\n\treturn job;\n}"
    },
    {
        "var_name": "dte_data",
        "function_name": "si_initialize_smc_dte_tables",
        "location": {
            "file_path": "drivers/gpu/drm/radeon/si_dpm.c",
            "region": {
                "startLine": 2419,
                "startColumn": 6,
                "endColumn": 14
            },
            "context": {
                "startLine": 2417,
                "endLine": 2421,
                "snippet": {
                    "text": "if (dte_data->k <= 0)"
                }
            }
        },
        "function_code": "static int si_initialize_smc_dte_tables(struct radeon_device *rdev)\n{\n\tstruct si_power_info *si_pi = si_get_pi(rdev);\n\tint ret = 0;\n\tstruct si_dte_data *dte_data = &si_pi->dte_data;\n\tSmc_SIslands_DTE_Configuration *dte_tables = NULL;\n\tu32 table_size;\n\tu8 tdep_count;\n\tu32 i;\n\n\tif (dte_data == NULL)\n\t\tsi_pi->enable_dte = false;\n\n\tif (si_pi->enable_dte == false)\n\t\treturn 0;\n\n\tif (dte_data->k <= 0)\n\t\treturn -EINVAL;\n\n\tdte_tables = kzalloc(sizeof(Smc_SIslands_DTE_Configuration), GFP_KERNEL);\n\tif (dte_tables == NULL) {\n\t\tsi_pi->enable_dte = false;\n\t\treturn -ENOMEM;\n\t}\n\n\ttable_size = dte_data->k;\n\n\tif (table_size > SMC_SISLANDS_DTE_MAX_FILTER_STAGES)\n\t\ttable_size = SMC_SISLANDS_DTE_MAX_FILTER_STAGES;\n\n\ttdep_count = dte_data->tdep_count;\n\tif (tdep_count > SMC_SISLANDS_DTE_MAX_TEMPERATURE_DEPENDENT_ARRAY_SIZE)\n\t\ttdep_count = SMC_SISLANDS_DTE_MAX_TEMPERATURE_DEPENDENT_ARRAY_SIZE;\n\n\tdte_tables->K = cpu_to_be32(table_size);\n\tdte_tables->T0 = cpu_to_be32(dte_data->t0);\n\tdte_tables->MaxT = cpu_to_be32(dte_data->max_t);\n\tdte_tables->WindowSize = dte_data->window_size;\n\tdte_tables->temp_select = dte_data->temp_select;\n\tdte_tables->DTE_mode = dte_data->dte_mode;\n\tdte_tables->Tthreshold = cpu_to_be32(dte_data->t_threshold);\n\n\tif (tdep_count > 0)\n\t\ttable_size--;\n\n\tfor (i = 0; i < table_size; i++) {\n\t\tdte_tables->tau[i] = cpu_to_be32(dte_data->tau[i]);\n\t\tdte_tables->R[i]   = cpu_to_be32(dte_data->r[i]);\n\t}\n\n\tdte_tables->Tdep_count = tdep_count;\n\n\tfor (i = 0; i < (u32)tdep_count; i++) {\n\t\tdte_tables->T_limits[i] = dte_data->t_limits[i];\n\t\tdte_tables->Tdep_tau[i] = cpu_to_be32(dte_data->tdep_tau[i]);\n\t\tdte_tables->Tdep_R[i] = cpu_to_be32(dte_data->tdep_r[i]);\n\t}\n\n\tret = si_copy_bytes_to_smc(rdev, si_pi->dte_table_start, (u8 *)dte_tables,\n\t\t\t\t   sizeof(Smc_SIslands_DTE_Configuration), si_pi->sram_end);\n\tkfree(dte_tables);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "entity",
        "function_name": "drm_sched_job_arm",
        "location": {
            "file_path": "drivers/gpu/drm/scheduler/sched_main.c",
            "region": {
                "startLine": 843,
                "startColumn": 10,
                "endColumn": 16
            },
            "context": {
                "startLine": 841,
                "endLine": 845,
                "snippet": {
                    "text": "sched = entity->rq->sched;"
                }
            }
        },
        "function_code": "void drm_sched_job_arm(struct drm_sched_job *job)\n{\n\tstruct drm_gpu_scheduler *sched;\n\tstruct drm_sched_entity *entity = job->entity;\n\n\tBUG_ON(!entity);\n\tdrm_sched_entity_select_rq(entity);\n\tsched = entity->rq->sched;\n\n\tjob->sched = sched;\n\tjob->s_priority = entity->priority;\n\tjob->id = atomic64_inc_return(&sched->job_id_count);\n\n\tdrm_sched_fence_init(job->s_fence, job->entity);\n}"
    },
    {
        "var_name": "entity",
        "function_name": "drm_sched_job_arm",
        "location": {
            "file_path": "drivers/gpu/drm/scheduler/sched_main.c",
            "region": {
                "startLine": 846,
                "startColumn": 20,
                "endColumn": 26
            },
            "context": {
                "startLine": 844,
                "endLine": 848,
                "snippet": {
                    "text": "job->s_priority = entity->priority;"
                }
            }
        },
        "function_code": "void drm_sched_job_arm(struct drm_sched_job *job)\n{\n\tstruct drm_gpu_scheduler *sched;\n\tstruct drm_sched_entity *entity = job->entity;\n\n\tBUG_ON(!entity);\n\tdrm_sched_entity_select_rq(entity);\n\tsched = entity->rq->sched;\n\n\tjob->sched = sched;\n\tjob->s_priority = entity->priority;\n\tjob->id = atomic64_inc_return(&sched->job_id_count);\n\n\tdrm_sched_fence_init(job->s_fence, job->entity);\n}"
    },
    {
        "var_name": "old",
        "function_name": "tegra_shared_plane_set_owner",
        "location": {
            "file_path": "drivers/gpu/drm/tegra/hub.c",
            "region": {
                "startLine": 265,
                "startColumn": 40,
                "endColumn": 43
            },
            "context": {
                "startLine": 263,
                "endLine": 267,
                "snippet": {
                    "text": "struct device *dev = new ? new->dev : old->dev;"
                }
            }
        },
        "function_code": "static int tegra_shared_plane_set_owner(struct tegra_plane *plane,\n\t\t\t\t\tstruct tegra_dc *new)\n{\n\tunsigned int offset =\n\t\ttegra_plane_offset(plane, DC_WIN_CORE_WINDOWGROUP_SET_CONTROL);\n\tstruct tegra_dc *old = plane->dc, *dc = new ? new : old;\n\tstruct device *dev = new ? new->dev : old->dev;\n\tunsigned int owner, index = plane->index;\n\tu32 value;\n\n\tvalue = tegra_dc_readl(dc, offset);\n\towner = value & OWNER_MASK;\n\n\tif (new && (owner != OWNER_MASK && owner != new->pipe)) {\n\t\tdev_WARN(dev, \"window %u owned by head %u\\n\", index, owner);\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * This seems to happen whenever the head has been disabled with one\n\t * or more windows being active. This is harmless because we'll just\n\t * reassign the window to the new head anyway.\n\t */\n\tif (old && owner == OWNER_MASK)\n\t\tdev_dbg(dev, \"window %u not owned by head %u but %u\\n\", index,\n\t\t\told->pipe, owner);\n\n\tvalue &= ~OWNER_MASK;\n\n\tif (new)\n\t\tvalue |= OWNER(new->pipe);\n\telse\n\t\tvalue |= OWNER_MASK;\n\n\ttegra_dc_writel(dc, value, offset);\n\n\tplane->dc = new;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "swap_storage",
        "function_name": "ttm_tt_swapin",
        "location": {
            "file_path": "drivers/gpu/drm/ttm/ttm_tt.c",
            "region": {
                "startLine": 224,
                "startColumn": 15,
                "endColumn": 27
            },
            "context": {
                "startLine": 222,
                "endLine": 226,
                "snippet": {
                    "text": "swap_space = swap_storage->f_mapping;"
                }
            }
        },
        "function_code": "int ttm_tt_swapin(struct ttm_tt *ttm)\n{\n\tstruct address_space *swap_space;\n\tstruct file *swap_storage;\n\tstruct page *from_page;\n\tstruct page *to_page;\n\tgfp_t gfp_mask;\n\tint i, ret;\n\n\tswap_storage = ttm->swap_storage;\n\tBUG_ON(swap_storage == NULL);\n\n\tswap_space = swap_storage->f_mapping;\n\tgfp_mask = mapping_gfp_mask(swap_space);\n\n\tfor (i = 0; i < ttm->num_pages; ++i) {\n\t\tfrom_page = shmem_read_mapping_page_gfp(swap_space, i,\n\t\t\t\t\t\t\tgfp_mask);\n\t\tif (IS_ERR(from_page)) {\n\t\t\tret = PTR_ERR(from_page);\n\t\t\tgoto out_err;\n\t\t}\n\t\tto_page = ttm->pages[i];\n\t\tif (unlikely(to_page == NULL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tcopy_highpage(to_page, from_page);\n\t\tput_page(from_page);\n\t}\n\n\tfput(swap_storage);\n\tttm->swap_storage = NULL;\n\tttm->page_flags &= ~TTM_TT_FLAG_SWAPPED;\n\n\treturn 0;\n\nout_err:\n\treturn ret;\n}"
    },
    {
        "var_name": "record",
        "function_name": "vbva_buffer_end_update",
        "location": {
            "file_path": "drivers/gpu/drm/vboxvideo/vbva_base.c",
            "region": {
                "startLine": 203,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 201,
                "endLine": 205,
                "snippet": {
                    "text": "record->len_and_flags &= ~VBVA_F_RECORD_PARTIAL;"
                }
            }
        },
        "function_code": "void vbva_buffer_end_update(struct vbva_buf_ctx *vbva_ctx)\n{\n\tstruct vbva_record *record = vbva_ctx->record;\n\n\tWARN_ON(!vbva_ctx->vbva || !record ||\n\t\t!(record->len_and_flags & VBVA_F_RECORD_PARTIAL));\n\n\t/* Mark the record completed. */\n\trecord->len_and_flags &= ~VBVA_F_RECORD_PARTIAL;\n\n\tvbva_ctx->buffer_overflow = false;\n\tvbva_ctx->record = NULL;\n}"
    },
    {
        "var_name": "plane_state",
        "function_name": "vkms_crtc_atomic_check",
        "location": {
            "file_path": "drivers/gpu/drm/vkms/vkms_crtc.c",
            "region": {
                "startLine": 198,
                "startColumn": 8,
                "endColumn": 19
            },
            "context": {
                "startLine": 196,
                "endLine": 200,
                "snippet": {
                    "text": "if (!plane_state->visible)"
                }
            }
        },
        "function_code": "static int vkms_crtc_atomic_check(struct drm_crtc *crtc,\n\t\t\t\t  struct drm_atomic_state *state)\n{\n\tstruct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,\n\t\t\t\t\t\t\t\t\t  crtc);\n\tstruct vkms_crtc_state *vkms_state = to_vkms_crtc_state(crtc_state);\n\tstruct drm_plane *plane;\n\tstruct drm_plane_state *plane_state;\n\tint i = 0, ret;\n\n\tif (vkms_state->active_planes)\n\t\treturn 0;\n\n\tret = drm_atomic_add_affected_planes(crtc_state->state, crtc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdrm_for_each_plane_mask(plane, crtc->dev, crtc_state->plane_mask) {\n\t\tplane_state = drm_atomic_get_existing_plane_state(crtc_state->state,\n\t\t\t\t\t\t\t\t  plane);\n\t\tWARN_ON(!plane_state);\n\n\t\tif (!plane_state->visible)\n\t\t\tcontinue;\n\n\t\ti++;\n\t}\n\n\tvkms_state->active_planes = kcalloc(i, sizeof(plane), GFP_KERNEL);\n\tif (!vkms_state->active_planes)\n\t\treturn -ENOMEM;\n\tvkms_state->num_active_planes = i;\n\n\ti = 0;\n\tdrm_for_each_plane_mask(plane, crtc->dev, crtc_state->plane_mask) {\n\t\tplane_state = drm_atomic_get_existing_plane_state(crtc_state->state,\n\t\t\t\t\t\t\t\t  plane);\n\n\t\tif (!plane_state->visible)\n\t\t\tcontinue;\n\n\t\tvkms_state->active_planes[i++] =\n\t\t\tto_vkms_plane_state(plane_state);\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "msg",
        "function_name": "relay_handle_reply",
        "location": {
            "file_path": "drivers/gpu/drm/xe/xe_guc_relay.c",
            "region": {
                "startLine": 578,
                "startColumn": 31,
                "endColumn": 34
            },
            "context": {
                "startLine": 576,
                "endLine": 580,
                "snippet": {
                    "text": "memcpy(pending->response, msg, 4 * len);"
                }
            }
        },
        "function_code": "static int relay_handle_reply(struct xe_guc_relay *relay, u32 origin,\n\t\t\t      u32 rid, int reply, const u32 *msg, u32 len)\n{\n\tstruct relay_transaction *pending;\n\tint err = -ESRCH;\n\n\tspin_lock(&relay->lock);\n\tlist_for_each_entry(pending, &relay->pending_relays, link) {\n\t\tif (pending->remote != origin || pending->rid != rid) {\n\t\t\trelay_debug(relay, \"%u.%u still awaits response\\n\",\n\t\t\t\t    pending->remote, pending->rid);\n\t\t\tcontinue;\n\t\t}\n\t\terr = 0; /* found! */\n\t\tif (reply == 0) {\n\t\t\tif (len > pending->response_len) {\n\t\t\t\treply = -ENOBUFS;\n\t\t\t\terr = -ENOBUFS;\n\t\t\t} else {\n\t\t\t\tmemcpy(pending->response, msg, 4 * len);\n\t\t\t\tpending->response_len = len;\n\t\t\t}\n\t\t}\n\t\tpending->reply = reply;\n\t\tcomplete_all(&pending->done);\n\t\tbreak;\n\t}\n\tspin_unlock(&relay->lock);\n\n\treturn err;\n}"
    },
    {
        "var_name": "vm",
        "function_name": "xe_vm_obj",
        "location": {
            "file_path": "drivers/gpu/drm/xe/xe_vm.c",
            "region": {
                "startLine": 44,
                "startColumn": 9,
                "endColumn": 11
            },
            "context": {
                "startLine": 42,
                "endLine": 46,
                "snippet": {
                    "text": "return vm->gpuvm.r_obj;"
                }
            }
        },
        "function_code": "static struct drm_gem_object *xe_vm_obj(struct xe_vm *vm)\n{\n\treturn vm->gpuvm.r_obj;\n}"
    },
    {
        "var_name": "client",
        "function_name": "vga_switcheroo_debugfs_write",
        "location": {
            "file_path": "drivers/gpu/vga/vga_switcheroo.c",
            "region": {
                "startLine": 801,
                "startColumn": 8,
                "endColumn": 14
            },
            "context": {
                "startLine": 799,
                "endLine": 803,
                "snippet": {
                    "text": "if (client->active || client_is_audio(client))"
                }
            }
        },
        "function_code": "static ssize_t\nvga_switcheroo_debugfs_write(struct file *filp, const char __user *ubuf,\n\t\t\t     size_t cnt, loff_t *ppos)\n{\n\tchar usercmd[64];\n\tint ret;\n\tbool delay = false, can_switch;\n\tbool just_mux = false;\n\tenum vga_switcheroo_client_id client_id = VGA_SWITCHEROO_UNKNOWN_ID;\n\tstruct vga_switcheroo_client *client = NULL;\n\n\tif (cnt > 63)\n\t\tcnt = 63;\n\n\tif (copy_from_user(usercmd, ubuf, cnt))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&vgasr_mutex);\n\n\tif (!vgasr_priv.active) {\n\t\tcnt = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* pwr off the device not in use */\n\tif (strncmp(usercmd, \"OFF\", 3) == 0) {\n\t\tlist_for_each_entry(client, &vgasr_priv.clients, list) {\n\t\t\tif (client->active || client_is_audio(client))\n\t\t\t\tcontinue;\n\t\t\tif (client->driver_power_control)\n\t\t\t\tcontinue;\n\t\t\tset_audio_state(client->id, VGA_SWITCHEROO_OFF);\n\t\t\tif (client->pwr_state == VGA_SWITCHEROO_ON)\n\t\t\t\tvga_switchoff(client);\n\t\t}\n\t\tgoto out;\n\t}\n\t/* pwr on the device not in use */\n\tif (strncmp(usercmd, \"ON\", 2) == 0) {\n\t\tlist_for_each_entry(client, &vgasr_priv.clients, list) {\n\t\t\tif (client->active || client_is_audio(client))\n\t\t\t\tcontinue;\n\t\t\tif (client->driver_power_control)\n\t\t\t\tcontinue;\n\t\t\tif (client->pwr_state == VGA_SWITCHEROO_OFF)\n\t\t\t\tvga_switchon(client);\n\t\t\tset_audio_state(client->id, VGA_SWITCHEROO_ON);\n\t\t}\n\t\tgoto out;\n\t}\n\n\t/* request a delayed switch - test can we switch now */\n\tif (strncmp(usercmd, \"DIGD\", 4) == 0) {\n\t\tclient_id = VGA_SWITCHEROO_IGD;\n\t\tdelay = true;\n\t}\n\n\tif (strncmp(usercmd, \"DDIS\", 4) == 0) {\n\t\tclient_id = VGA_SWITCHEROO_DIS;\n\t\tdelay = true;\n\t}\n\n\tif (strncmp(usercmd, \"IGD\", 3) == 0)\n\t\tclient_id = VGA_SWITCHEROO_IGD;\n\n\tif (strncmp(usercmd, \"DIS\", 3) == 0)\n\t\tclient_id = VGA_SWITCHEROO_DIS;\n\n\tif (strncmp(usercmd, \"MIGD\", 4) == 0) {\n\t\tjust_mux = true;\n\t\tclient_id = VGA_SWITCHEROO_IGD;\n\t}\n\tif (strncmp(usercmd, \"MDIS\", 4) == 0) {\n\t\tjust_mux = true;\n\t\tclient_id = VGA_SWITCHEROO_DIS;\n\t}\n\n\tif (client_id == VGA_SWITCHEROO_UNKNOWN_ID)\n\t\tgoto out;\n\tclient = find_client_from_id(&vgasr_priv.clients, client_id);\n\tif (!client)\n\t\tgoto out;\n\n\tvgasr_priv.delayed_switch_active = false;\n\n\tif (just_mux) {\n\t\tmutex_lock(&vgasr_priv.mux_hw_lock);\n\t\tret = vgasr_priv.handler->switchto(client_id);\n\t\tmutex_unlock(&vgasr_priv.mux_hw_lock);\n\t\tgoto out;\n\t}\n\n\tif (client->active)\n\t\tgoto out;\n\n\t/* okay we want a switch - test if devices are willing to switch */\n\tcan_switch = check_can_switch();\n\n\tif (can_switch == false && delay == false)\n\t\tgoto out;\n\n\tif (can_switch) {\n\t\tret = vga_switchto_stage1(client);\n\t\tif (ret)\n\t\t\tpr_err(\"switching failed stage 1 %d\\n\", ret);\n\n\t\tret = vga_switchto_stage2(client);\n\t\tif (ret)\n\t\t\tpr_err(\"switching failed stage 2 %d\\n\", ret);\n\n\t} else {\n\t\tpr_info(\"setting delayed switch to client %d\\n\", client->id);\n\t\tvgasr_priv.delayed_switch_active = true;\n\t\tvgasr_priv.delayed_client_id = client_id;\n\n\t\tret = vga_switchto_stage1(client);\n\t\tif (ret)\n\t\t\tpr_err(\"delayed switching stage 1 failed %d\\n\", ret);\n\t}\n\nout:\n\tmutex_unlock(&vgasr_mutex);\n\treturn cnt;\n}"
    },
    {
        "var_name": "payloads",
        "function_name": "hdlc_tx_frames",
        "location": {
            "file_path": "drivers/greybus/gb-beagleplay.c",
            "region": {
                "startLine": 227,
                "startColumn": 26,
                "endColumn": 34
            },
            "context": {
                "startLine": 225,
                "endLine": 229,
                "snippet": {
                    "text": "hdlc_append_tx_buf(bg, payloads[i].buf, payloads[i].len);"
                }
            }
        },
        "function_code": "static void hdlc_tx_frames(struct gb_beagleplay *bg, u8 address, u8 control,\n\t\t\t   const struct hdlc_payload payloads[], size_t count)\n{\n\tsize_t i;\n\n\tspin_lock(&bg->tx_producer_lock);\n\n\thdlc_append_tx_frame(bg);\n\thdlc_append_tx_u8(bg, address);\n\thdlc_append_tx_u8(bg, control);\n\n\tfor (i = 0; i < count; ++i)\n\t\thdlc_append_tx_buf(bg, payloads[i].buf, payloads[i].len);\n\n\thdlc_append_tx_crc(bg);\n\thdlc_append_tx_frame(bg);\n\n\tspin_unlock(&bg->tx_producer_lock);\n\n\tschedule_work(&bg->tx_work);\n}"
    },
    {
        "var_name": "hidinput",
        "function_name": "cougar_probe",
        "location": {
            "file_path": "drivers/hid/hid-cougar.c",
            "region": {
                "startLine": 234,
                "startColumn": 8,
                "endColumn": 16
            },
            "context": {
                "startLine": 232,
                "endLine": 236,
                "snippet": {
                    "text": "if (hidinput->registered && hidinput->input != NULL) {"
                }
            }
        },
        "function_code": "static int cougar_probe(struct hid_device *hdev,\n\t\t\tconst struct hid_device_id *id)\n{\n\tstruct cougar *cougar;\n\tstruct hid_input *next, *hidinput = NULL;\n\tunsigned int connect_mask;\n\tint error;\n\n\tcougar = devm_kzalloc(&hdev->dev, sizeof(*cougar), GFP_KERNEL);\n\tif (!cougar)\n\t\treturn -ENOMEM;\n\thid_set_drvdata(hdev, cougar);\n\n\terror = hid_parse(hdev);\n\tif (error) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\treturn error;\n\t}\n\n\tif (hdev->collection->usage == COUGAR_VENDOR_USAGE) {\n\t\tcougar->special_intf = true;\n\t\tconnect_mask = HID_CONNECT_HIDRAW;\n\t} else\n\t\tconnect_mask = HID_CONNECT_DEFAULT;\n\n\terror = hid_hw_start(hdev, connect_mask);\n\tif (error) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\treturn error;\n\t}\n\n\terror = cougar_bind_shared_data(hdev, cougar);\n\tif (error)\n\t\tgoto fail_stop_and_cleanup;\n\n\t/* The custom vendor interface will use the hid_input registered\n\t * for the keyboard interface, in order to send translated key codes\n\t * to it.\n\t */\n\tif (hdev->collection->usage == HID_GD_KEYBOARD) {\n\t\tlist_for_each_entry_safe(hidinput, next, &hdev->inputs, list) {\n\t\t\tif (hidinput->registered && hidinput->input != NULL) {\n\t\t\t\tcougar->shared->input = hidinput->input;\n\t\t\t\tcougar->shared->enabled = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (hdev->collection->usage == COUGAR_VENDOR_USAGE) {\n\t\t/* Preinit the mapping table */\n\t\tcougar_fix_g6_mapping();\n\t\terror = hid_hw_open(hdev);\n\t\tif (error)\n\t\t\tgoto fail_stop_and_cleanup;\n\t}\n\treturn 0;\n\nfail_stop_and_cleanup:\n\thid_hw_stop(hdev);\n\treturn error;\n}"
    },
    {
        "var_name": "data",
        "function_name": "cp2112_write_read_req",
        "location": {
            "file_path": "drivers/hid/hid-cp2112.c",
            "region": {
                "startLine": 467,
                "startColumn": 37,
                "endColumn": 41
            },
            "context": {
                "startLine": 465,
                "endLine": 469,
                "snippet": {
                    "text": "memcpy(&report->target_address[1], data, data_length);"
                }
            }
        },
        "function_code": "static int cp2112_write_read_req(void *buf, u8 slave_address, u16 length,\n\t\t\t\t u8 command, u8 *data, u8 data_length)\n{\n\tstruct cp2112_write_read_req_report *report = buf;\n\n\tif (length < 1 || length > 512\n\t    || data_length > sizeof(report->target_address) - 1)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_READ_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = cpu_to_be16(length);\n\treport->target_address_length = data_length + 1;\n\treport->target_address[0] = command;\n\tmemcpy(&report->target_address[1], data, data_length);\n\treturn data_length + 6;\n}"
    },
    {
        "var_name": "data",
        "function_name": "cp2112_write_req",
        "location": {
            "file_path": "drivers/hid/hid-cp2112.c",
            "region": {
                "startLine": 483,
                "startColumn": 27,
                "endColumn": 31
            },
            "context": {
                "startLine": 481,
                "endLine": 485,
                "snippet": {
                    "text": "memcpy(&report->data[1], data, data_length);"
                }
            }
        },
        "function_code": "static int cp2112_write_req(void *buf, u8 slave_address, u8 command, u8 *data,\n\t\t\t    u8 data_length)\n{\n\tstruct cp2112_write_req_report *report = buf;\n\n\tif (data_length > sizeof(report->data) - 1)\n\t\treturn -EINVAL;\n\n\treport->report = CP2112_DATA_WRITE_REQUEST;\n\treport->slave_address = slave_address << 1;\n\treport->length = data_length + 1;\n\treport->data[0] = command;\n\tmemcpy(&report->data[1], data, data_length);\n\treturn data_length + 4;\n}"
    },
    {
        "var_name": "data",
        "function_name": "ft260_smbus_write",
        "location": {
            "file_path": "drivers/hid/hid-ft260.c",
            "region": {
                "startLine": 486,
                "startColumn": 25,
                "endColumn": 29
            },
            "context": {
                "startLine": 484,
                "endLine": 488,
                "snippet": {
                    "text": "memcpy(&rep->data[1], data, data_len);"
                }
            }
        },
        "function_code": "static int ft260_smbus_write(struct ft260_device *dev, u8 addr, u8 cmd,\n\t\t\t     u8 *data, u8 data_len, u8 flag)\n{\n\tint ret = 0;\n\tint len = 4;\n\n\tstruct ft260_i2c_write_request_report *rep =\n\t\t(struct ft260_i2c_write_request_report *)dev->write_buf;\n\n\tif (data_len >= sizeof(rep->data))\n\t\treturn -EINVAL;\n\n\trep->address = addr;\n\trep->data[0] = cmd;\n\trep->length = data_len + 1;\n\trep->flag = flag;\n\tlen += rep->length;\n\n\trep->report = FT260_I2C_DATA_REPORT_ID(len);\n\n\tif (data_len > 0)\n\t\tmemcpy(&rep->data[1], data, data_len);\n\n\tft260_dbg(\"rep %#02x addr %#02x cmd %#02x datlen %d replen %d\\n\",\n\t\t  rep->report, addr, cmd, rep->length, len);\n\n\tret = ft260_hid_output_report_check_status(dev, (u8 *)rep, len);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "mcp_smbus_write",
        "location": {
            "file_path": "drivers/hid/hid-mcp2221.c",
            "region": {
                "startLine": 424,
                "startColumn": 19,
                "endColumn": 22
            },
            "context": {
                "startLine": 422,
                "endLine": 426,
                "snippet": {
                    "text": "mcp->txbuf[5] = buf[0];"
                }
            }
        },
        "function_code": "static int mcp_smbus_write(struct mcp2221 *mcp, u16 addr,\n\t\t\t\tu8 command, u8 *buf, u8 len, int type,\n\t\t\t\tu8 last_status)\n{\n\tint data_len, ret;\n\n\tmcp->txbuf[0] = type;\n\tmcp->txbuf[1] = len + 1; /* 1 is due to command byte itself */\n\tmcp->txbuf[2] = 0;\n\tmcp->txbuf[3] = (u8)(addr << 1);\n\tmcp->txbuf[4] = command;\n\n\tswitch (len) {\n\tcase 0:\n\t\tdata_len = 5;\n\t\tbreak;\n\tcase 1:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tdata_len = 6;\n\t\tbreak;\n\tcase 2:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tmcp->txbuf[6] = buf[1];\n\t\tdata_len = 7;\n\t\tbreak;\n\tdefault:\n\t\tif (len > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&mcp->txbuf[5], buf, len);\n\t\tdata_len = len + 5;\n\t}\n\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, data_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (last_status) {\n\t\tusleep_range(980, 1000);\n\n\t\tret = mcp_chk_last_cmd_status_free_bus(mcp);\n\t}\n\n\treturn ret;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "mcp_smbus_write",
        "location": {
            "file_path": "drivers/hid/hid-mcp2221.c",
            "region": {
                "startLine": 428,
                "startColumn": 19,
                "endColumn": 22
            },
            "context": {
                "startLine": 426,
                "endLine": 430,
                "snippet": {
                    "text": "mcp->txbuf[5] = buf[0];"
                }
            }
        },
        "function_code": "static int mcp_smbus_write(struct mcp2221 *mcp, u16 addr,\n\t\t\t\tu8 command, u8 *buf, u8 len, int type,\n\t\t\t\tu8 last_status)\n{\n\tint data_len, ret;\n\n\tmcp->txbuf[0] = type;\n\tmcp->txbuf[1] = len + 1; /* 1 is due to command byte itself */\n\tmcp->txbuf[2] = 0;\n\tmcp->txbuf[3] = (u8)(addr << 1);\n\tmcp->txbuf[4] = command;\n\n\tswitch (len) {\n\tcase 0:\n\t\tdata_len = 5;\n\t\tbreak;\n\tcase 1:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tdata_len = 6;\n\t\tbreak;\n\tcase 2:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tmcp->txbuf[6] = buf[1];\n\t\tdata_len = 7;\n\t\tbreak;\n\tdefault:\n\t\tif (len > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&mcp->txbuf[5], buf, len);\n\t\tdata_len = len + 5;\n\t}\n\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, data_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (last_status) {\n\t\tusleep_range(980, 1000);\n\n\t\tret = mcp_chk_last_cmd_status_free_bus(mcp);\n\t}\n\n\treturn ret;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "mcp_smbus_write",
        "location": {
            "file_path": "drivers/hid/hid-mcp2221.c",
            "region": {
                "startLine": 429,
                "startColumn": 19,
                "endColumn": 22
            },
            "context": {
                "startLine": 427,
                "endLine": 431,
                "snippet": {
                    "text": "mcp->txbuf[6] = buf[1];"
                }
            }
        },
        "function_code": "static int mcp_smbus_write(struct mcp2221 *mcp, u16 addr,\n\t\t\t\tu8 command, u8 *buf, u8 len, int type,\n\t\t\t\tu8 last_status)\n{\n\tint data_len, ret;\n\n\tmcp->txbuf[0] = type;\n\tmcp->txbuf[1] = len + 1; /* 1 is due to command byte itself */\n\tmcp->txbuf[2] = 0;\n\tmcp->txbuf[3] = (u8)(addr << 1);\n\tmcp->txbuf[4] = command;\n\n\tswitch (len) {\n\tcase 0:\n\t\tdata_len = 5;\n\t\tbreak;\n\tcase 1:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tdata_len = 6;\n\t\tbreak;\n\tcase 2:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tmcp->txbuf[6] = buf[1];\n\t\tdata_len = 7;\n\t\tbreak;\n\tdefault:\n\t\tif (len > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&mcp->txbuf[5], buf, len);\n\t\tdata_len = len + 5;\n\t}\n\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, data_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (last_status) {\n\t\tusleep_range(980, 1000);\n\n\t\tret = mcp_chk_last_cmd_status_free_bus(mcp);\n\t}\n\n\treturn ret;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "mcp_smbus_write",
        "location": {
            "file_path": "drivers/hid/hid-mcp2221.c",
            "region": {
                "startLine": 436,
                "startColumn": 26,
                "endColumn": 29
            },
            "context": {
                "startLine": 434,
                "endLine": 438,
                "snippet": {
                    "text": "memcpy(&mcp->txbuf[5], buf, len);"
                }
            }
        },
        "function_code": "static int mcp_smbus_write(struct mcp2221 *mcp, u16 addr,\n\t\t\t\tu8 command, u8 *buf, u8 len, int type,\n\t\t\t\tu8 last_status)\n{\n\tint data_len, ret;\n\n\tmcp->txbuf[0] = type;\n\tmcp->txbuf[1] = len + 1; /* 1 is due to command byte itself */\n\tmcp->txbuf[2] = 0;\n\tmcp->txbuf[3] = (u8)(addr << 1);\n\tmcp->txbuf[4] = command;\n\n\tswitch (len) {\n\tcase 0:\n\t\tdata_len = 5;\n\t\tbreak;\n\tcase 1:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tdata_len = 6;\n\t\tbreak;\n\tcase 2:\n\t\tmcp->txbuf[5] = buf[0];\n\t\tmcp->txbuf[6] = buf[1];\n\t\tdata_len = 7;\n\t\tbreak;\n\tdefault:\n\t\tif (len > I2C_SMBUS_BLOCK_MAX)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&mcp->txbuf[5], buf, len);\n\t\tdata_len = len + 5;\n\t}\n\n\tret = mcp_send_data_req_status(mcp, mcp->txbuf, data_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (last_status) {\n\t\tusleep_range(980, 1000);\n\n\t\tret = mcp_chk_last_cmd_status_free_bus(mcp);\n\t}\n\n\treturn ret;\n}"
    },
    {
        "var_name": "report",
        "function_name": "picolcd_report",
        "location": {
            "file_path": "drivers/hid/hid-picolcd_core.c",
            "region": {
                "startLine": 59,
                "startColumn": 7,
                "endColumn": 13
            },
            "context": {
                "startLine": 57,
                "endLine": 61,
                "snippet": {
                    "text": "if (report->id == id)"
                }
            }
        },
        "function_code": "struct hid_report *picolcd_report(int id, struct hid_device *hdev, int dir)\n{\n\tstruct list_head *feature_report_list = &hdev->report_enum[dir].report_list;\n\tstruct hid_report *report = NULL;\n\n\tlist_for_each_entry(report, feature_report_list, list) {\n\t\tif (report->id == id)\n\t\t\treturn report;\n\t}\n\thid_warn(hdev, \"No report with id 0x%x found\\n\", id);\n\treturn NULL;\n}"
    },
    {
        "var_name": "cl",
        "function_name": "ipc_tx_send",
        "location": {
            "file_path": "drivers/hid/intel-ish-hid/ishtp/client.c",
            "region": {
                "startLine": 821,
                "startColumn": 6,
                "endColumn": 8
            },
            "context": {
                "startLine": 819,
                "endLine": 823,
                "snippet": {
                    "text": "if (cl->state != ISHTP_CL_CONNECTED)"
                }
            }
        },
        "function_code": "static void ipc_tx_send(void *prm)\n{\n\tstruct ishtp_cl\t*cl = prm;\n\tstruct ishtp_cl_tx_ring\t*cl_msg;\n\tsize_t\trem;\n\tstruct ishtp_device\t*dev = (cl ? cl->dev : NULL);\n\tstruct ishtp_msg_hdr\tishtp_hdr;\n\tunsigned long\ttx_flags, tx_free_flags;\n\tunsigned char\t*pmsg;\n\n\tif (!dev)\n\t\treturn;\n\n\t/*\n\t * Other conditions if some critical error has\n\t * occurred before this callback is called\n\t */\n\tif (dev->dev_state != ISHTP_DEV_ENABLED)\n\t\treturn;\n\n\tif (cl->state != ISHTP_CL_CONNECTED)\n\t\treturn;\n\n\tspin_lock_irqsave(&cl->tx_list_spinlock, tx_flags);\n\tif (list_empty(&cl->tx_list.list)) {\n\t\tspin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);\n\t\treturn;\n\t}\n\n\tif (cl->ishtp_flow_ctrl_creds != 1 && !cl->sending) {\n\t\tspin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);\n\t\treturn;\n\t}\n\n\tif (!cl->sending) {\n\t\t--cl->ishtp_flow_ctrl_creds;\n\t\tcl->last_ipc_acked = 0;\n\t\tcl->last_tx_path = CL_TX_PATH_IPC;\n\t\tcl->sending = 1;\n\t}\n\n\tcl_msg = list_entry(cl->tx_list.list.next, struct ishtp_cl_tx_ring,\n\t\t\t    list);\n\trem = cl_msg->send_buf.size - cl->tx_offs;\n\n\twhile (rem > 0) {\n\t\tishtp_hdr.host_addr = cl->host_client_id;\n\t\tishtp_hdr.fw_addr = cl->fw_client_id;\n\t\tishtp_hdr.reserved = 0;\n\t\tpmsg = cl_msg->send_buf.data + cl->tx_offs;\n\n\t\tif (rem <= dev->mtu) {\n\t\t\t/* Last fragment or only one packet */\n\t\t\tishtp_hdr.length = rem;\n\t\t\tishtp_hdr.msg_complete = 1;\n\t\t\t/* Submit to IPC queue with no callback */\n\t\t\tishtp_write_message(dev, &ishtp_hdr, pmsg);\n\t\t\tcl->tx_offs = 0;\n\t\t\tcl->sending = 0;\n\n\t\t\tbreak;\n\t\t} else {\n\t\t\t/* Send ipc fragment */\n\t\t\tishtp_hdr.length = dev->mtu;\n\t\t\tishtp_hdr.msg_complete = 0;\n\t\t\t/* All fregments submitted to IPC queue with no callback */\n\t\t\tishtp_write_message(dev, &ishtp_hdr, pmsg);\n\t\t\tcl->tx_offs += dev->mtu;\n\t\t\trem = cl_msg->send_buf.size - cl->tx_offs;\n\t\t}\n\t}\n\n\tlist_del_init(&cl_msg->list);\n\tspin_unlock_irqrestore(&cl->tx_list_spinlock, tx_flags);\n\n\tspin_lock_irqsave(&cl->tx_free_list_spinlock, tx_free_flags);\n\tlist_add_tail(&cl_msg->list, &cl->tx_free_list.list);\n\t++cl->tx_ring_free_size;\n\tspin_unlock_irqrestore(&cl->tx_free_list_spinlock,\n\t\ttx_free_flags);\n}"
    },
    {
        "var_name": "msg",
        "function_name": "ssi_async",
        "location": {
            "file_path": "drivers/hsi/controllers/omap_ssi_port.c",
            "region": {
                "startLine": 373,
                "startColumn": 39,
                "endColumn": 42
            },
            "context": {
                "startLine": 371,
                "endLine": 375,
                "snippet": {
                    "text": "struct hsi_port *port = hsi_get_port(msg->cl);"
                }
            }
        },
        "function_code": "static int ssi_async(struct hsi_msg *msg)\n{\n\tstruct hsi_port *port = hsi_get_port(msg->cl);\n\tstruct omap_ssi_port *omap_port = hsi_port_drvdata(port);\n\tstruct list_head *queue;\n\tint err = 0;\n\n\tBUG_ON(!msg);\n\n\tif (msg->sgt.nents > 1)\n\t\treturn -ENOSYS; /* TODO: Add sg support */\n\n\tif (msg->break_frame)\n\t\treturn ssi_async_break(msg);\n\n\tif (msg->ttype) {\n\t\tBUG_ON(msg->channel >= omap_port->sst.channels);\n\t\tqueue = &omap_port->txqueue[msg->channel];\n\t} else {\n\t\tBUG_ON(msg->channel >= omap_port->ssr.channels);\n\t\tqueue = &omap_port->rxqueue[msg->channel];\n\t}\n\tmsg->status = HSI_STATUS_QUEUED;\n\n\tpm_runtime_get_sync(omap_port->pdev);\n\tspin_lock_bh(&omap_port->lock);\n\tlist_add_tail(&msg->link, queue);\n\terr = ssi_start_transfer(queue);\n\tif (err < 0) {\n\t\tlist_del(&msg->link);\n\t\tmsg->status = HSI_STATUS_ERROR;\n\t}\n\tspin_unlock_bh(&omap_port->lock);\n\tpm_runtime_mark_last_busy(omap_port->pdev);\n\tpm_runtime_put_autosuspend(omap_port->pdev);\n\tdev_dbg(&port->device, \"msg status %d ttype %d ch %d\\n\",\n\t\t\t\tmsg->status, msg->ttype, msg->channel);\n\n\treturn err;\n}"
    },
    {
        "var_name": "userdata",
        "function_name": "__vmbus_open",
        "location": {
            "file_path": "drivers/hv/channel.c",
            "region": {
                "startLine": 716,
                "startColumn": 30,
                "endColumn": 38
            },
            "context": {
                "startLine": 714,
                "endLine": 718,
                "snippet": {
                    "text": "memcpy(open_msg->userdata, userdata, userdatalen);"
                }
            }
        },
        "function_code": "static int __vmbus_open(struct vmbus_channel *newchannel,\n\t\t       void *userdata, u32 userdatalen,\n\t\t       void (*onchannelcallback)(void *context), void *context)\n{\n\tstruct vmbus_channel_open_channel *open_msg;\n\tstruct vmbus_channel_msginfo *open_info = NULL;\n\tstruct page *page = newchannel->ringbuffer_page;\n\tu32 send_pages, recv_pages;\n\tunsigned long flags;\n\tint err;\n\n\tif (userdatalen > MAX_USER_DEFINED_BYTES)\n\t\treturn -EINVAL;\n\n\tsend_pages = newchannel->ringbuffer_send_offset;\n\trecv_pages = newchannel->ringbuffer_pagecount - send_pages;\n\n\tif (newchannel->state != CHANNEL_OPEN_STATE)\n\t\treturn -EINVAL;\n\n\t/* Create and init requestor */\n\tif (newchannel->rqstor_size) {\n\t\tif (vmbus_alloc_requestor(&newchannel->requestor, newchannel->rqstor_size))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tnewchannel->state = CHANNEL_OPENING_STATE;\n\tnewchannel->onchannel_callback = onchannelcallback;\n\tnewchannel->channel_callback_context = context;\n\n\tif (!newchannel->max_pkt_size)\n\t\tnewchannel->max_pkt_size = VMBUS_DEFAULT_MAX_PKT_SIZE;\n\n\t/* Establish the gpadl for the ring buffer */\n\tnewchannel->ringbuffer_gpadlhandle.gpadl_handle = 0;\n\n\terr = __vmbus_establish_gpadl(newchannel, HV_GPADL_RING,\n\t\t\t\t      page_address(newchannel->ringbuffer_page),\n\t\t\t\t      (send_pages + recv_pages) << PAGE_SHIFT,\n\t\t\t\t      newchannel->ringbuffer_send_offset << PAGE_SHIFT,\n\t\t\t\t      &newchannel->ringbuffer_gpadlhandle);\n\tif (err)\n\t\tgoto error_clean_ring;\n\n\terr = hv_ringbuffer_init(&newchannel->outbound,\n\t\t\t\t page, send_pages, 0);\n\tif (err)\n\t\tgoto error_free_gpadl;\n\n\terr = hv_ringbuffer_init(&newchannel->inbound, &page[send_pages],\n\t\t\t\t recv_pages, newchannel->max_pkt_size);\n\tif (err)\n\t\tgoto error_free_gpadl;\n\n\t/* Create and init the channel open message */\n\topen_info = kzalloc(sizeof(*open_info) +\n\t\t\t   sizeof(struct vmbus_channel_open_channel),\n\t\t\t   GFP_KERNEL);\n\tif (!open_info) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free_gpadl;\n\t}\n\n\tinit_completion(&open_info->waitevent);\n\topen_info->waiting_channel = newchannel;\n\n\topen_msg = (struct vmbus_channel_open_channel *)open_info->msg;\n\topen_msg->header.msgtype = CHANNELMSG_OPENCHANNEL;\n\topen_msg->openid = newchannel->offermsg.child_relid;\n\topen_msg->child_relid = newchannel->offermsg.child_relid;\n\topen_msg->ringbuffer_gpadlhandle\n\t\t= newchannel->ringbuffer_gpadlhandle.gpadl_handle;\n\t/*\n\t * The unit of ->downstream_ringbuffer_pageoffset is HV_HYP_PAGE and\n\t * the unit of ->ringbuffer_send_offset (i.e. send_pages) is PAGE, so\n\t * here we calculate it into HV_HYP_PAGE.\n\t */\n\topen_msg->downstream_ringbuffer_pageoffset =\n\t\thv_ring_gpadl_send_hvpgoffset(send_pages << PAGE_SHIFT);\n\topen_msg->target_vp = hv_cpu_number_to_vp_number(newchannel->target_cpu);\n\n\tif (userdatalen)\n\t\tmemcpy(open_msg->userdata, userdata, userdatalen);\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_add_tail(&open_info->msglistentry,\n\t\t      &vmbus_connection.chn_msg_list);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tif (newchannel->rescind) {\n\t\terr = -ENODEV;\n\t\tgoto error_clean_msglist;\n\t}\n\n\terr = vmbus_post_msg(open_msg,\n\t\t\t     sizeof(struct vmbus_channel_open_channel), true);\n\n\ttrace_vmbus_open(open_msg, err);\n\n\tif (err != 0)\n\t\tgoto error_clean_msglist;\n\n\twait_for_completion(&open_info->waitevent);\n\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_del(&open_info->msglistentry);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\n\n\tif (newchannel->rescind) {\n\t\terr = -ENODEV;\n\t\tgoto error_free_info;\n\t}\n\n\tif (open_info->response.open_result.status) {\n\t\terr = -EAGAIN;\n\t\tgoto error_free_info;\n\t}\n\n\tnewchannel->state = CHANNEL_OPENED_STATE;\n\tkfree(open_info);\n\treturn 0;\n\nerror_clean_msglist:\n\tspin_lock_irqsave(&vmbus_connection.channelmsg_lock, flags);\n\tlist_del(&open_info->msglistentry);\n\tspin_unlock_irqrestore(&vmbus_connection.channelmsg_lock, flags);\nerror_free_info:\n\tkfree(open_info);\nerror_free_gpadl:\n\tvmbus_teardown_gpadl(newchannel, &newchannel->ringbuffer_gpadlhandle);\nerror_clean_ring:\n\thv_ringbuffer_cleanup(&newchannel->outbound);\n\thv_ringbuffer_cleanup(&newchannel->inbound);\n\tvmbus_free_requestor(&newchannel->requestor);\n\tnewchannel->state = CHANNEL_OPEN_STATE;\n\treturn err;\n}"
    },
    {
        "var_name": "msg_to_host",
        "function_name": "kvp_respond_to_host",
        "location": {
            "file_path": "drivers/hv/hv_kvp.c",
            "region": {
                "startLine": 589,
                "startColumn": 13,
                "endColumn": 24
            },
            "context": {
                "startLine": 587,
                "endLine": 591,
                "snippet": {
                    "text": "key_name = msg_to_host->body.kvp_enum_data.data.key;"
                }
            }
        },
        "function_code": "static void\nkvp_respond_to_host(struct hv_kvp_msg *msg_to_host, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_exchg_msg_value  *kvp_data;\n\tchar\t*key_name;\n\tchar\t*value;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen = 0;\n\tint\tvaluelen = 0;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\tint ret;\n\n\t/*\n\t * Copy the global state for completing the transaction. Note that\n\t * only one transaction can be active at a time.\n\t */\n\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\n\tif (channel->onchannel_callback == NULL)\n\t\t/*\n\t\t * We have raced with util driver being unloaded;\n\t\t * silently return.\n\t\t */\n\t\treturn;\n\n\ticmsghdrp->status = error;\n\n\t/*\n\t * If the error parameter is set, terminate the host's enumeration\n\t * on this pool.\n\t */\n\tif (error) {\n\t\t/*\n\t\t * Something failed or we have timed out;\n\t\t * terminate the current host-side iteration.\n\t\t */\n\t\tgoto response_done;\n\t}\n\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\n\tswitch (kvp_transaction.kvp_msg->kvp_hdr.operation) {\n\tcase KVP_OP_GET_IP_INFO:\n\t\tret = process_ob_ipinfo(msg_to_host,\n\t\t\t\t (struct hv_kvp_ip_msg *)kvp_msg,\n\t\t\t\t KVP_OP_GET_IP_INFO);\n\t\tif (ret < 0)\n\t\t\ticmsghdrp->status = HV_E_FAIL;\n\n\t\tgoto response_done;\n\tcase KVP_OP_SET_IP_INFO:\n\t\tgoto response_done;\n\tcase KVP_OP_GET:\n\t\tkvp_data = &kvp_msg->body.kvp_get.data;\n\t\tgoto copy_value;\n\n\tcase KVP_OP_SET:\n\tcase KVP_OP_DELETE:\n\t\tgoto response_done;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvp_data = &kvp_msg->body.kvp_enum_data.data;\n\tkey_name = msg_to_host->body.kvp_enum_data.data.key;\n\n\t/*\n\t * The windows host expects the key/value pair to be encoded\n\t * in utf16. Ensure that the key/value size reported to the host\n\t * will be less than or equal to the MAX size (including the\n\t * terminating character).\n\t */\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) kvp_data->key,\n\t\t\t\t(HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2) - 2);\n\tkvp_data->key_size = 2*(keylen + 1); /* utf16 encoding */\n\ncopy_value:\n\tvalue = msg_to_host->body.kvp_enum_data.data.value;\n\tvaluelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) kvp_data->value,\n\t\t\t\t(HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2) - 2);\n\tkvp_data->value_size = 2*(valuelen + 1); /* utf16 encoding */\n\n\t/*\n\t * If the utf8s to utf16s conversion failed; notify host\n\t * of the error.\n\t */\n\tif ((keylen < 0) || (valuelen < 0))\n\t\ticmsghdrp->status = HV_E_FAIL;\n\n\tkvp_data->value_type = REG_SZ; /* all our values are strings */\n\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}"
    },
    {
        "var_name": "msg_to_host",
        "function_name": "kvp_respond_to_host",
        "location": {
            "file_path": "drivers/hv/hv_kvp.c",
            "region": {
                "startLine": 603,
                "startColumn": 10,
                "endColumn": 21
            },
            "context": {
                "startLine": 601,
                "endLine": 605,
                "snippet": {
                    "text": "value = msg_to_host->body.kvp_enum_data.data.value;"
                }
            }
        },
        "function_code": "static void\nkvp_respond_to_host(struct hv_kvp_msg *msg_to_host, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_exchg_msg_value  *kvp_data;\n\tchar\t*key_name;\n\tchar\t*value;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen = 0;\n\tint\tvaluelen = 0;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\tint ret;\n\n\t/*\n\t * Copy the global state for completing the transaction. Note that\n\t * only one transaction can be active at a time.\n\t */\n\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\n\tif (channel->onchannel_callback == NULL)\n\t\t/*\n\t\t * We have raced with util driver being unloaded;\n\t\t * silently return.\n\t\t */\n\t\treturn;\n\n\ticmsghdrp->status = error;\n\n\t/*\n\t * If the error parameter is set, terminate the host's enumeration\n\t * on this pool.\n\t */\n\tif (error) {\n\t\t/*\n\t\t * Something failed or we have timed out;\n\t\t * terminate the current host-side iteration.\n\t\t */\n\t\tgoto response_done;\n\t}\n\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\n\tswitch (kvp_transaction.kvp_msg->kvp_hdr.operation) {\n\tcase KVP_OP_GET_IP_INFO:\n\t\tret = process_ob_ipinfo(msg_to_host,\n\t\t\t\t (struct hv_kvp_ip_msg *)kvp_msg,\n\t\t\t\t KVP_OP_GET_IP_INFO);\n\t\tif (ret < 0)\n\t\t\ticmsghdrp->status = HV_E_FAIL;\n\n\t\tgoto response_done;\n\tcase KVP_OP_SET_IP_INFO:\n\t\tgoto response_done;\n\tcase KVP_OP_GET:\n\t\tkvp_data = &kvp_msg->body.kvp_get.data;\n\t\tgoto copy_value;\n\n\tcase KVP_OP_SET:\n\tcase KVP_OP_DELETE:\n\t\tgoto response_done;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvp_data = &kvp_msg->body.kvp_enum_data.data;\n\tkey_name = msg_to_host->body.kvp_enum_data.data.key;\n\n\t/*\n\t * The windows host expects the key/value pair to be encoded\n\t * in utf16. Ensure that the key/value size reported to the host\n\t * will be less than or equal to the MAX size (including the\n\t * terminating character).\n\t */\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) kvp_data->key,\n\t\t\t\t(HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2) - 2);\n\tkvp_data->key_size = 2*(keylen + 1); /* utf16 encoding */\n\ncopy_value:\n\tvalue = msg_to_host->body.kvp_enum_data.data.value;\n\tvaluelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,\n\t\t\t\t(wchar_t *) kvp_data->value,\n\t\t\t\t(HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2) - 2);\n\tkvp_data->value_size = 2*(valuelen + 1); /* utf16 encoding */\n\n\t/*\n\t * If the utf8s to utf16s conversion failed; notify host\n\t * of the error.\n\t */\n\tif ((keylen < 0) || (valuelen < 0))\n\t\ticmsghdrp->status = HV_E_FAIL;\n\n\tkvp_data->value_type = REG_SZ; /* all our values are strings */\n\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}"
    },
    {
        "var_name": "data",
        "function_name": "watchdog_disable",
        "location": {
            "file_path": "drivers/hwmon/w83793.c",
            "region": {
                "startLine": 1274,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 1272,
                "endLine": 1276,
                "snippet": {
                    "text": "if (!data->client) {"
                }
            }
        },
        "function_code": "static int watchdog_disable(struct w83793_data *data)\n{\n\tint ret = 0;\n\n\tmutex_lock(&data->watchdog_lock);\n\tif (!data->client) {\n\t\tret = -ENODEV;\n\t\tgoto leave;\n\t}\n\n\t/* Disable Soft Watchdog */\n\tw83793_write_value(data->client, W83793_REG_WDT_LOCK, 0xAA);\n\nleave:\n\tmutex_unlock(&data->watchdog_lock);\n\treturn ret;\n}"
    },
    {
        "var_name": "data",
        "function_name": "watchdog_notify_sys",
        "location": {
            "file_path": "drivers/hwmon/w83793.c",
            "region": {
                "startLine": 1476,
                "startColumn": 8,
                "endColumn": 12
            },
            "context": {
                "startLine": 1474,
                "endLine": 1478,
                "snippet": {
                    "text": "if (data->watchdog_miscdev.minor)"
                }
            }
        },
        "function_code": "static int watchdog_notify_sys(struct notifier_block *this, unsigned long code,\n\t\t\t       void *unused)\n{\n\tstruct w83793_data *data = NULL;\n\n\tif (code == SYS_DOWN || code == SYS_HALT) {\n\n\t\t/* Disable each registered watchdog */\n\t\tmutex_lock(&watchdog_data_mutex);\n\t\tlist_for_each_entry(data, &watchdog_data_list, list) {\n\t\t\tif (data->watchdog_miscdev.minor)\n\t\t\t\twatchdog_disable(data);\n\t\t}\n\t\tmutex_unlock(&watchdog_data_mutex);\n\t}\n\n\treturn NOTIFY_DONE;\n}"
    },
    {
        "var_name": "feat_csdev",
        "function_name": "cscfg_get_feat_csdev",
        "location": {
            "file_path": "drivers/hwtracing/coresight/coresight-syscfg.c",
            "region": {
                "startLine": 38,
                "startColumn": 14,
                "endColumn": 24
            },
            "context": {
                "startLine": 36,
                "endLine": 40,
                "snippet": {
                    "text": "if (strcmp(feat_csdev->feat_desc->name, name) == 0)"
                }
            }
        },
        "function_code": "static struct cscfg_feature_csdev *\ncscfg_get_feat_csdev(struct coresight_device *csdev, const char *name)\n{\n\tstruct cscfg_feature_csdev *feat_csdev = NULL;\n\n\tlist_for_each_entry(feat_csdev, &csdev->feature_csdev_list, node) {\n\t\tif (strcmp(feat_csdev->feat_desc->name, name) == 0)\n\t\t\treturn feat_csdev;\n\t}\n\treturn NULL;\n}"
    },
    {
        "var_name": "drvdata",
        "function_name": "tpdm_datasets_setup",
        "location": {
            "file_path": "drivers/hwtracing/coresight/coresight-tpdm.c",
            "region": {
                "startLine": 529,
                "startColumn": 23,
                "endColumn": 30
            },
            "context": {
                "startLine": 527,
                "endLine": 531,
                "snippet": {
                    "text": "pidr = readl_relaxed(drvdata->base + CORESIGHT_PERIPHIDR0);"
                }
            }
        },
        "function_code": "static int tpdm_datasets_setup(struct tpdm_drvdata *drvdata)\n{\n\tu32 pidr;\n\n\t/*  Get the datasets present on the TPDM. */\n\tpidr = readl_relaxed(drvdata->base + CORESIGHT_PERIPHIDR0);\n\tdrvdata->datasets |= pidr & GENMASK(TPDM_DATASETS - 1, 0);\n\n\tif (tpdm_has_dsb_dataset(drvdata) && (!drvdata->dsb)) {\n\t\tdrvdata->dsb = devm_kzalloc(drvdata->dev,\n\t\t\t\t\t\tsizeof(*drvdata->dsb), GFP_KERNEL);\n\t\tif (!drvdata->dsb)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (tpdm_has_cmb_dataset(drvdata) && (!drvdata->cmb)) {\n\t\tdrvdata->cmb = devm_kzalloc(drvdata->dev,\n\t\t\t\t\t\tsizeof(*drvdata->cmb), GFP_KERNEL);\n\t\tif (!drvdata->cmb)\n\t\t\treturn -ENOMEM;\n\t}\n\ttpdm_reset_datasets(drvdata);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "drvdata",
        "function_name": "tpdm_datasets_setup",
        "location": {
            "file_path": "drivers/hwtracing/coresight/coresight-tpdm.c",
            "region": {
                "startLine": 530,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 528,
                "endLine": 532,
                "snippet": {
                    "text": "drvdata->datasets |= pidr & GENMASK(TPDM_DATASETS - 1, 0);"
                }
            }
        },
        "function_code": "static int tpdm_datasets_setup(struct tpdm_drvdata *drvdata)\n{\n\tu32 pidr;\n\n\t/*  Get the datasets present on the TPDM. */\n\tpidr = readl_relaxed(drvdata->base + CORESIGHT_PERIPHIDR0);\n\tdrvdata->datasets |= pidr & GENMASK(TPDM_DATASETS - 1, 0);\n\n\tif (tpdm_has_dsb_dataset(drvdata) && (!drvdata->dsb)) {\n\t\tdrvdata->dsb = devm_kzalloc(drvdata->dev,\n\t\t\t\t\t\tsizeof(*drvdata->dsb), GFP_KERNEL);\n\t\tif (!drvdata->dsb)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (tpdm_has_cmb_dataset(drvdata) && (!drvdata->cmb)) {\n\t\tdrvdata->cmb = devm_kzalloc(drvdata->dev,\n\t\t\t\t\t\tsizeof(*drvdata->cmb), GFP_KERNEL);\n\t\tif (!drvdata->cmb)\n\t\t\treturn -ENOMEM;\n\t}\n\ttpdm_reset_datasets(drvdata);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "drvdata",
        "function_name": "tpdm_probe",
        "location": {
            "file_path": "drivers/hwtracing/coresight/coresight-tpdm.c",
            "region": {
                "startLine": 1254,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1252,
                "endLine": 1256,
                "snippet": {
                    "text": "drvdata->base = base;"
                }
            }
        },
        "function_code": "static int tpdm_probe(struct amba_device *adev, const struct amba_id *id)\n{\n\tvoid __iomem *base;\n\tstruct device *dev = &adev->dev;\n\tstruct coresight_platform_data *pdata;\n\tstruct tpdm_drvdata *drvdata;\n\tstruct coresight_desc desc = { 0 };\n\tint ret;\n\n\tpdata = coresight_get_platform_data(dev);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\tadev->dev.platform_data = pdata;\n\n\t/* driver data*/\n\tdrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\tif (!drvdata)\n\t\treturn -ENOMEM;\n\tdrvdata->dev = &adev->dev;\n\tdev_set_drvdata(dev, drvdata);\n\n\tbase = devm_ioremap_resource(dev, &adev->res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tdrvdata->base = base;\n\n\tret = tpdm_datasets_setup(drvdata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (drvdata && tpdm_has_dsb_dataset(drvdata))\n\t\tof_property_read_u32(drvdata->dev->of_node,\n\t\t\t   \"qcom,dsb-msrs-num\", &drvdata->dsb_msr_num);\n\n\tif (drvdata && tpdm_has_cmb_dataset(drvdata))\n\t\tof_property_read_u32(drvdata->dev->of_node,\n\t\t\t   \"qcom,cmb-msrs-num\", &drvdata->cmb_msr_num);\n\n\t/* Set up coresight component description */\n\tdesc.name = coresight_alloc_device_name(&tpdm_devs, dev);\n\tif (!desc.name)\n\t\treturn -ENOMEM;\n\tdesc.type = CORESIGHT_DEV_TYPE_SOURCE;\n\tdesc.subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_TPDM;\n\tdesc.ops = &tpdm_cs_ops;\n\tdesc.pdata = adev->dev.platform_data;\n\tdesc.dev = &adev->dev;\n\tdesc.access = CSDEV_ACCESS_IOMEM(base);\n\tdesc.groups = tpdm_attr_grps;\n\tdrvdata->csdev = coresight_register(&desc);\n\tif (IS_ERR(drvdata->csdev))\n\t\treturn PTR_ERR(drvdata->csdev);\n\n\tspin_lock_init(&drvdata->spinlock);\n\n\t/* Decrease pm refcount when probe is done.*/\n\tpm_runtime_put(&adev->dev);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "val2",
        "function_name": "bno055_get_regmask",
        "location": {
            "file_path": "drivers/iio/imu/bno055/bno055.c",
            "region": {
                "startLine": 573,
                "startColumn": 4,
                "endColumn": 8
            },
            "context": {
                "startLine": 571,
                "endLine": 575,
                "snippet": {
                    "text": "*val2 = attr->vals[idx * 2 + 1];"
                }
            }
        },
        "function_code": "static int bno055_get_regmask(struct bno055_priv *priv, int *val, int *val2,\n\t\t\t      int reg, int mask, struct bno055_sysfs_attr *attr)\n{\n\tconst int shift = __ffs(mask);\n\tint hwval, idx;\n\tint ret;\n\tint i;\n\n\tret = regmap_read(priv->regmap, reg, &hwval);\n\tif (ret)\n\t\treturn ret;\n\n\tidx = (hwval & mask) >> shift;\n\tif (attr->hw_xlate)\n\t\tfor (i = 0; i < attr->len; i++)\n\t\t\tif (attr->hw_xlate[i] == idx) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\tif (attr->type == IIO_VAL_INT) {\n\t\t*val = attr->vals[idx];\n\t} else { /* IIO_VAL_INT_PLUS_MICRO or IIO_VAL_FRACTIONAL */\n\t\t*val = attr->vals[idx * 2];\n\t\t*val2 = attr->vals[idx * 2 + 1];\n\t}\n\n\treturn attr->type;\n}"
    },
    {
        "var_name": "qhp",
        "function_name": "__c4iw_poll_cq_one",
        "location": {
            "file_path": "drivers/infiniband/hw/cxgb4/cq.c",
            "region": {
                "startLine": 803,
                "startColumn": 23,
                "endColumn": 26
            },
            "context": {
                "startLine": 801,
                "endLine": 805,
                "snippet": {
                    "text": "c4iw_invalidate_mr(qhp->rhp, wc->ex.invalidate_rkey);"
                }
            }
        },
        "function_code": "static int __c4iw_poll_cq_one(struct c4iw_cq *chp, struct c4iw_qp *qhp,\n\t\t\t      struct ib_wc *wc, struct c4iw_srq *srq)\n{\n\tstruct t4_cqe cqe;\n\tstruct t4_wq *wq = qhp ? &qhp->wq : NULL;\n\tu32 credit = 0;\n\tu8 cqe_flushed;\n\tu64 cookie = 0;\n\tint ret;\n\n\tret = poll_cq(wq, &(chp->cq), &cqe, &cqe_flushed, &cookie, &credit,\n\t\t      srq ? &srq->wq : NULL);\n\tif (ret)\n\t\tgoto out;\n\n\twc->wr_id = cookie;\n\twc->qp = &qhp->ibqp;\n\twc->vendor_err = CQE_STATUS(&cqe);\n\twc->wc_flags = 0;\n\n\t/*\n\t * Simulate a SRQ_LIMIT_REACHED HW notification if required.\n\t */\n\tif (srq && !(srq->flags & T4_SRQ_LIMIT_SUPPORT) && srq->armed &&\n\t    srq->wq.in_use < srq->srq_limit)\n\t\tc4iw_dispatch_srq_limit_reached_event(srq);\n\n\tpr_debug(\"qpid 0x%x type %d opcode %d status 0x%x len %u wrid hi 0x%x lo 0x%x cookie 0x%llx\\n\",\n\t\t CQE_QPID(&cqe),\n\t\t CQE_TYPE(&cqe), CQE_OPCODE(&cqe),\n\t\t CQE_STATUS(&cqe), CQE_LEN(&cqe),\n\t\t CQE_WRID_HI(&cqe), CQE_WRID_LOW(&cqe),\n\t\t (unsigned long long)cookie);\n\n\tif (CQE_TYPE(&cqe) == 0) {\n\t\tif (!CQE_STATUS(&cqe))\n\t\t\twc->byte_len = CQE_LEN(&cqe);\n\t\telse\n\t\t\twc->byte_len = 0;\n\n\t\tswitch (CQE_OPCODE(&cqe)) {\n\t\tcase FW_RI_SEND:\n\t\t\twc->opcode = IB_WC_RECV;\n\t\t\tbreak;\n\t\tcase FW_RI_SEND_WITH_INV:\n\t\tcase FW_RI_SEND_WITH_SE_INV:\n\t\t\twc->opcode = IB_WC_RECV;\n\t\t\twc->ex.invalidate_rkey = CQE_WRID_STAG(&cqe);\n\t\t\twc->wc_flags |= IB_WC_WITH_INVALIDATE;\n\t\t\tc4iw_invalidate_mr(qhp->rhp, wc->ex.invalidate_rkey);\n\t\t\tbreak;\n\t\tcase FW_RI_WRITE_IMMEDIATE:\n\t\t\twc->opcode = IB_WC_RECV_RDMA_WITH_IMM;\n\t\t\twc->ex.imm_data = CQE_IMM_DATA(&cqe);\n\t\t\twc->wc_flags |= IB_WC_WITH_IMM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unexpected opcode %d in the CQE received for QPID=0x%0x\\n\",\n\t\t\t       CQE_OPCODE(&cqe), CQE_QPID(&cqe));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tswitch (CQE_OPCODE(&cqe)) {\n\t\tcase FW_RI_WRITE_IMMEDIATE:\n\t\tcase FW_RI_RDMA_WRITE:\n\t\t\twc->opcode = IB_WC_RDMA_WRITE;\n\t\t\tbreak;\n\t\tcase FW_RI_READ_REQ:\n\t\t\twc->opcode = IB_WC_RDMA_READ;\n\t\t\twc->byte_len = CQE_LEN(&cqe);\n\t\t\tbreak;\n\t\tcase FW_RI_SEND_WITH_INV:\n\t\tcase FW_RI_SEND_WITH_SE_INV:\n\t\t\twc->opcode = IB_WC_SEND;\n\t\t\twc->wc_flags |= IB_WC_WITH_INVALIDATE;\n\t\t\tbreak;\n\t\tcase FW_RI_SEND:\n\t\tcase FW_RI_SEND_WITH_SE:\n\t\t\twc->opcode = IB_WC_SEND;\n\t\t\tbreak;\n\n\t\tcase FW_RI_LOCAL_INV:\n\t\t\twc->opcode = IB_WC_LOCAL_INV;\n\t\t\tbreak;\n\t\tcase FW_RI_FAST_REGISTER:\n\t\t\twc->opcode = IB_WC_REG_MR;\n\n\t\t\t/* Invalidate the MR if the fastreg failed */\n\t\t\tif (CQE_STATUS(&cqe) != T4_ERR_SUCCESS)\n\t\t\t\tc4iw_invalidate_mr(qhp->rhp,\n\t\t\t\t\t\t   CQE_WRID_FR_STAG(&cqe));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unexpected opcode %d in the CQE received for QPID=0x%0x\\n\",\n\t\t\t       CQE_OPCODE(&cqe), CQE_QPID(&cqe));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (cqe_flushed)\n\t\twc->status = IB_WC_WR_FLUSH_ERR;\n\telse {\n\n\t\tswitch (CQE_STATUS(&cqe)) {\n\t\tcase T4_ERR_SUCCESS:\n\t\t\twc->status = IB_WC_SUCCESS;\n\t\t\tbreak;\n\t\tcase T4_ERR_STAG:\n\t\t\twc->status = IB_WC_LOC_ACCESS_ERR;\n\t\t\tbreak;\n\t\tcase T4_ERR_PDID:\n\t\t\twc->status = IB_WC_LOC_PROT_ERR;\n\t\t\tbreak;\n\t\tcase T4_ERR_QPID:\n\t\tcase T4_ERR_ACCESS:\n\t\t\twc->status = IB_WC_LOC_ACCESS_ERR;\n\t\t\tbreak;\n\t\tcase T4_ERR_WRAP:\n\t\t\twc->status = IB_WC_GENERAL_ERR;\n\t\t\tbreak;\n\t\tcase T4_ERR_BOUND:\n\t\t\twc->status = IB_WC_LOC_LEN_ERR;\n\t\t\tbreak;\n\t\tcase T4_ERR_INVALIDATE_SHARED_MR:\n\t\tcase T4_ERR_INVALIDATE_MR_WITH_MW_BOUND:\n\t\t\twc->status = IB_WC_MW_BIND_ERR;\n\t\t\tbreak;\n\t\tcase T4_ERR_CRC:\n\t\tcase T4_ERR_MARKER:\n\t\tcase T4_ERR_PDU_LEN_ERR:\n\t\tcase T4_ERR_OUT_OF_RQE:\n\t\tcase T4_ERR_DDP_VERSION:\n\t\tcase T4_ERR_RDMA_VERSION:\n\t\tcase T4_ERR_DDP_QUEUE_NUM:\n\t\tcase T4_ERR_MSN:\n\t\tcase T4_ERR_TBIT:\n\t\tcase T4_ERR_MO:\n\t\tcase T4_ERR_MSN_RANGE:\n\t\tcase T4_ERR_IRD_OVERFLOW:\n\t\tcase T4_ERR_OPCODE:\n\t\tcase T4_ERR_INTERNAL_ERR:\n\t\t\twc->status = IB_WC_FATAL_ERR;\n\t\t\tbreak;\n\t\tcase T4_ERR_SWFLUSH:\n\t\t\twc->status = IB_WC_WR_FLUSH_ERR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unexpected cqe_status 0x%x for QPID=0x%0x\\n\",\n\t\t\t       CQE_STATUS(&cqe), CQE_QPID(&cqe));\n\t\t\twc->status = IB_WC_FATAL_ERR;\n\t\t}\n\t}\nout:\n\treturn ret;\n}"
    },
    {
        "var_name": "page",
        "function_name": "erdma_map_user_dbrecords",
        "location": {
            "file_path": "drivers/infiniband/hw/erdma/erdma_verbs.c",
            "region": {
                "startLine": 815,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 813,
                "endLine": 817,
                "snippet": {
                    "text": "if (page->va == (dbrecords_va & PAGE_MASK))"
                }
            }
        },
        "function_code": "static int erdma_map_user_dbrecords(struct erdma_ucontext *ctx,\n\t\t\t\t    u64 dbrecords_va,\n\t\t\t\t    struct erdma_user_dbrecords_page **dbr_page,\n\t\t\t\t    dma_addr_t *dma_addr)\n{\n\tstruct erdma_user_dbrecords_page *page = NULL;\n\tint rv = 0;\n\n\tmutex_lock(&ctx->dbrecords_page_mutex);\n\n\tlist_for_each_entry(page, &ctx->dbrecords_page_list, list)\n\t\tif (page->va == (dbrecords_va & PAGE_MASK))\n\t\t\tgoto found;\n\n\tpage = kmalloc(sizeof(*page), GFP_KERNEL);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpage->va = (dbrecords_va & PAGE_MASK);\n\tpage->refcnt = 0;\n\n\tpage->umem = ib_umem_get(ctx->ibucontext.device,\n\t\t\t\t dbrecords_va & PAGE_MASK, PAGE_SIZE, 0);\n\tif (IS_ERR(page->umem)) {\n\t\trv = PTR_ERR(page->umem);\n\t\tkfree(page);\n\t\tgoto out;\n\t}\n\n\tlist_add(&page->list, &ctx->dbrecords_page_list);\n\nfound:\n\t*dma_addr = sg_dma_address(page->umem->sgt_append.sgt.sgl) +\n\t\t    (dbrecords_va & ~PAGE_MASK);\n\t*dbr_page = page;\n\tpage->refcnt++;\n\nout:\n\tmutex_unlock(&ctx->dbrecords_page_mutex);\n\treturn rv;\n}"
    },
    {
        "var_name": "attr",
        "function_name": "hns_roce_v2_set_path",
        "location": {
            "file_path": "drivers/infiniband/hw/hns/hns_roce_hw_v2.c",
            "region": {
                "startLine": 4872,
                "startColumn": 39,
                "endColumn": 43
            },
            "context": {
                "startLine": 4870,
                "endLine": 4874,
                "snippet": {
                    "text": "ib_port = (attr_mask & IB_QP_PORT) ? attr->port_num : hr_qp->port + 1;"
                }
            }
        },
        "function_code": "static int hns_roce_v2_set_path(struct ib_qp *ibqp,\n\t\t\t\tconst struct ib_qp_attr *attr,\n\t\t\t\tint attr_mask,\n\t\t\t\tstruct hns_roce_v2_qp_context *context,\n\t\t\t\tstruct hns_roce_v2_qp_context *qpc_mask)\n{\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(&attr->ah_attr);\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ibqp->device);\n\tstruct hns_roce_qp *hr_qp = to_hr_qp(ibqp);\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tconst struct ib_gid_attr *gid_attr = NULL;\n\tu8 sl = rdma_ah_get_sl(&attr->ah_attr);\n\tint is_roce_protocol;\n\tu16 vlan_id = 0xffff;\n\tbool is_udp = false;\n\tu32 max_sl;\n\tu8 ib_port;\n\tu8 hr_port;\n\tint ret;\n\n\tmax_sl = min_t(u32, MAX_SERVICE_LEVEL, hr_dev->caps.sl_num - 1);\n\tif (unlikely(sl > max_sl)) {\n\t\tibdev_err_ratelimited(ibdev,\n\t\t\t\t      \"failed to fill QPC, sl (%u) shouldn't be larger than %u.\\n\",\n\t\t\t\t      sl, max_sl);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If free_mr_en of qp is set, it means that this qp comes from\n\t * free mr. This qp will perform the loopback operation.\n\t * In the loopback scenario, only sl needs to be set.\n\t */\n\tif (hr_qp->free_mr_en) {\n\t\thr_reg_write(context, QPC_SL, sl);\n\t\thr_reg_clear(qpc_mask, QPC_SL);\n\t\thr_qp->sl = sl;\n\t\treturn 0;\n\t}\n\n\tib_port = (attr_mask & IB_QP_PORT) ? attr->port_num : hr_qp->port + 1;\n\thr_port = ib_port - 1;\n\tis_roce_protocol = rdma_cap_eth_ah(&hr_dev->ib_dev, ib_port) &&\n\t\t\t   rdma_ah_get_ah_flags(&attr->ah_attr) & IB_AH_GRH;\n\n\tif (is_roce_protocol) {\n\t\tgid_attr = attr->ah_attr.grh.sgid_attr;\n\t\tret = rdma_read_gid_l2_fields(gid_attr, &vlan_id, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tis_udp = (gid_attr->gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP);\n\t}\n\n\t/* Only HIP08 needs to set the vlan_en bits in QPC */\n\tif (vlan_id < VLAN_N_VID &&\n\t    hr_dev->pci_dev->revision == PCI_REVISION_ID_HIP08) {\n\t\thr_reg_enable(context, QPC_RQ_VLAN_EN);\n\t\thr_reg_clear(qpc_mask, QPC_RQ_VLAN_EN);\n\t\thr_reg_enable(context, QPC_SQ_VLAN_EN);\n\t\thr_reg_clear(qpc_mask, QPC_SQ_VLAN_EN);\n\t}\n\n\thr_reg_write(context, QPC_VLAN_ID, vlan_id);\n\thr_reg_clear(qpc_mask, QPC_VLAN_ID);\n\n\tif (grh->sgid_index >= hr_dev->caps.gid_table_len[hr_port]) {\n\t\tibdev_err(ibdev, \"sgid_index(%u) too large. max is %d\\n\",\n\t\t\t  grh->sgid_index, hr_dev->caps.gid_table_len[hr_port]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->ah_attr.type != RDMA_AH_ATTR_TYPE_ROCE) {\n\t\tibdev_err(ibdev, \"ah attr is not RDMA roce type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thr_reg_write(context, QPC_UDPSPN,\n\t\t     is_udp ? rdma_get_udp_sport(grh->flow_label, ibqp->qp_num,\n\t\t\t\t\t\t attr->dest_qp_num) :\n\t\t\t\t    0);\n\n\thr_reg_clear(qpc_mask, QPC_UDPSPN);\n\n\thr_reg_write(context, QPC_GMV_IDX, grh->sgid_index);\n\n\thr_reg_clear(qpc_mask, QPC_GMV_IDX);\n\n\thr_reg_write(context, QPC_HOPLIMIT, grh->hop_limit);\n\thr_reg_clear(qpc_mask, QPC_HOPLIMIT);\n\n\tret = fill_cong_field(ibqp, attr, context, qpc_mask);\n\tif (ret)\n\t\treturn ret;\n\n\thr_reg_write(context, QPC_TC, get_tclass(&attr->ah_attr.grh));\n\thr_reg_clear(qpc_mask, QPC_TC);\n\n\thr_reg_write(context, QPC_FL, grh->flow_label);\n\thr_reg_clear(qpc_mask, QPC_FL);\n\tmemcpy(context->dgid, grh->dgid.raw, sizeof(grh->dgid.raw));\n\tmemset(qpc_mask->dgid, 0, sizeof(grh->dgid.raw));\n\n\thr_qp->sl = sl;\n\thr_reg_write(context, QPC_SL, hr_qp->sl);\n\thr_reg_clear(qpc_mask, QPC_SL);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "attr",
        "function_name": "hns_roce_v2_set_path",
        "location": {
            "file_path": "drivers/infiniband/hw/hns/hns_roce_hw_v2.c",
            "region": {
                "startLine": 4878,
                "startColumn": 14,
                "endColumn": 18
            },
            "context": {
                "startLine": 4876,
                "endLine": 4880,
                "snippet": {
                    "text": "gid_attr = attr->ah_attr.grh.sgid_attr;"
                }
            }
        },
        "function_code": "static int hns_roce_v2_set_path(struct ib_qp *ibqp,\n\t\t\t\tconst struct ib_qp_attr *attr,\n\t\t\t\tint attr_mask,\n\t\t\t\tstruct hns_roce_v2_qp_context *context,\n\t\t\t\tstruct hns_roce_v2_qp_context *qpc_mask)\n{\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(&attr->ah_attr);\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ibqp->device);\n\tstruct hns_roce_qp *hr_qp = to_hr_qp(ibqp);\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tconst struct ib_gid_attr *gid_attr = NULL;\n\tu8 sl = rdma_ah_get_sl(&attr->ah_attr);\n\tint is_roce_protocol;\n\tu16 vlan_id = 0xffff;\n\tbool is_udp = false;\n\tu32 max_sl;\n\tu8 ib_port;\n\tu8 hr_port;\n\tint ret;\n\n\tmax_sl = min_t(u32, MAX_SERVICE_LEVEL, hr_dev->caps.sl_num - 1);\n\tif (unlikely(sl > max_sl)) {\n\t\tibdev_err_ratelimited(ibdev,\n\t\t\t\t      \"failed to fill QPC, sl (%u) shouldn't be larger than %u.\\n\",\n\t\t\t\t      sl, max_sl);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If free_mr_en of qp is set, it means that this qp comes from\n\t * free mr. This qp will perform the loopback operation.\n\t * In the loopback scenario, only sl needs to be set.\n\t */\n\tif (hr_qp->free_mr_en) {\n\t\thr_reg_write(context, QPC_SL, sl);\n\t\thr_reg_clear(qpc_mask, QPC_SL);\n\t\thr_qp->sl = sl;\n\t\treturn 0;\n\t}\n\n\tib_port = (attr_mask & IB_QP_PORT) ? attr->port_num : hr_qp->port + 1;\n\thr_port = ib_port - 1;\n\tis_roce_protocol = rdma_cap_eth_ah(&hr_dev->ib_dev, ib_port) &&\n\t\t\t   rdma_ah_get_ah_flags(&attr->ah_attr) & IB_AH_GRH;\n\n\tif (is_roce_protocol) {\n\t\tgid_attr = attr->ah_attr.grh.sgid_attr;\n\t\tret = rdma_read_gid_l2_fields(gid_attr, &vlan_id, NULL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tis_udp = (gid_attr->gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP);\n\t}\n\n\t/* Only HIP08 needs to set the vlan_en bits in QPC */\n\tif (vlan_id < VLAN_N_VID &&\n\t    hr_dev->pci_dev->revision == PCI_REVISION_ID_HIP08) {\n\t\thr_reg_enable(context, QPC_RQ_VLAN_EN);\n\t\thr_reg_clear(qpc_mask, QPC_RQ_VLAN_EN);\n\t\thr_reg_enable(context, QPC_SQ_VLAN_EN);\n\t\thr_reg_clear(qpc_mask, QPC_SQ_VLAN_EN);\n\t}\n\n\thr_reg_write(context, QPC_VLAN_ID, vlan_id);\n\thr_reg_clear(qpc_mask, QPC_VLAN_ID);\n\n\tif (grh->sgid_index >= hr_dev->caps.gid_table_len[hr_port]) {\n\t\tibdev_err(ibdev, \"sgid_index(%u) too large. max is %d\\n\",\n\t\t\t  grh->sgid_index, hr_dev->caps.gid_table_len[hr_port]);\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->ah_attr.type != RDMA_AH_ATTR_TYPE_ROCE) {\n\t\tibdev_err(ibdev, \"ah attr is not RDMA roce type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thr_reg_write(context, QPC_UDPSPN,\n\t\t     is_udp ? rdma_get_udp_sport(grh->flow_label, ibqp->qp_num,\n\t\t\t\t\t\t attr->dest_qp_num) :\n\t\t\t\t    0);\n\n\thr_reg_clear(qpc_mask, QPC_UDPSPN);\n\n\thr_reg_write(context, QPC_GMV_IDX, grh->sgid_index);\n\n\thr_reg_clear(qpc_mask, QPC_GMV_IDX);\n\n\thr_reg_write(context, QPC_HOPLIMIT, grh->hop_limit);\n\thr_reg_clear(qpc_mask, QPC_HOPLIMIT);\n\n\tret = fill_cong_field(ibqp, attr, context, qpc_mask);\n\tif (ret)\n\t\treturn ret;\n\n\thr_reg_write(context, QPC_TC, get_tclass(&attr->ah_attr.grh));\n\thr_reg_clear(qpc_mask, QPC_TC);\n\n\thr_reg_write(context, QPC_FL, grh->flow_label);\n\thr_reg_clear(qpc_mask, QPC_FL);\n\tmemcpy(context->dgid, grh->dgid.raw, sizeof(grh->dgid.raw));\n\tmemset(qpc_mask->dgid, 0, sizeof(grh->dgid.raw));\n\n\thr_qp->sl = sl;\n\thr_reg_write(context, QPC_SL, hr_qp->sl);\n\thr_reg_clear(qpc_mask, QPC_SL);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "attr",
        "function_name": "hns_roce_v2_record_opt_fields",
        "location": {
            "file_path": "drivers/infiniband/hw/hns/hns_roce_hw_v2.c",
            "region": {
                "startLine": 5133,
                "startColumn": 25,
                "endColumn": 29
            },
            "context": {
                "startLine": 5131,
                "endLine": 5135,
                "snippet": {
                    "text": "hr_qp->atomic_rd_en = attr->qp_access_flags;"
                }
            }
        },
        "function_code": "static void hns_roce_v2_record_opt_fields(struct ib_qp *ibqp,\n\t\t\t\t\t  const struct ib_qp_attr *attr,\n\t\t\t\t\t  int attr_mask)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ibqp->device);\n\tstruct hns_roce_qp *hr_qp = to_hr_qp(ibqp);\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\thr_qp->atomic_rd_en = attr->qp_access_flags;\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\thr_qp->resp_depth = attr->max_dest_rd_atomic;\n\tif (attr_mask & IB_QP_PORT) {\n\t\thr_qp->port = attr->port_num - 1;\n\t\thr_qp->phy_port = hr_dev->iboe.phy_port[hr_qp->port];\n\t}\n}"
    },
    {
        "var_name": "cqp_request",
        "function_name": "irdma_cqp_ce_handler",
        "location": {
            "file_path": "drivers/infiniband/hw/irdma/hw.c",
            "region": {
                "startLine": 2094,
                "startColumn": 45,
                "endColumn": 56
            },
            "context": {
                "startLine": 2092,
                "endLine": 2096,
                "snippet": {
                    "text": "if (info.error && irdma_cqp_crit_err(dev, cqp_request->info.cqp_cmd,"
                }
            }
        },
        "function_code": "void irdma_cqp_ce_handler(struct irdma_pci_f *rf, struct irdma_sc_cq *cq)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct irdma_sc_dev *dev = &rf->sc_dev;\n\tu32 cqe_count = 0;\n\tstruct irdma_ccq_cqe_info info;\n\tunsigned long flags;\n\tint ret;\n\n\tdo {\n\t\tmemset(&info, 0, sizeof(info));\n\t\tspin_lock_irqsave(&rf->cqp.compl_lock, flags);\n\t\tret = irdma_sc_ccq_get_cqe_info(cq, &info);\n\t\tspin_unlock_irqrestore(&rf->cqp.compl_lock, flags);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tcqp_request = (struct irdma_cqp_request *)\n\t\t\t      (unsigned long)info.scratch;\n\t\tif (info.error && irdma_cqp_crit_err(dev, cqp_request->info.cqp_cmd,\n\t\t\t\t\t\t     info.maj_err_code,\n\t\t\t\t\t\t     info.min_err_code))\n\t\t\tibdev_err(&rf->iwdev->ibdev, \"cqp opcode = 0x%x maj_err_code = 0x%x min_err_code = 0x%x\\n\",\n\t\t\t\t  info.op_code, info.maj_err_code, info.min_err_code);\n\t\tif (cqp_request) {\n\t\t\tcqp_request->compl_info.maj_err_code = info.maj_err_code;\n\t\t\tcqp_request->compl_info.min_err_code = info.min_err_code;\n\t\t\tcqp_request->compl_info.op_ret_val = info.op_ret_val;\n\t\t\tcqp_request->compl_info.error = info.error;\n\n\t\t\tif (cqp_request->waiting) {\n\t\t\t\tWRITE_ONCE(cqp_request->request_done, true);\n\t\t\t\twake_up(&cqp_request->waitq);\n\t\t\t\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\t\t\t} else {\n\t\t\t\tif (cqp_request->callback_fcn)\n\t\t\t\t\tcqp_request->callback_fcn(cqp_request);\n\t\t\t\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\t\t\t}\n\t\t}\n\n\t\tcqe_count++;\n\t} while (1);\n\n\tif (cqe_count) {\n\t\tirdma_process_bh(dev);\n\t\tirdma_sc_ccq_arm(cq);\n\t}\n}"
    },
    {
        "var_name": "udata",
        "function_name": "irdma_create_user_ah",
        "location": {
            "file_path": "drivers/infiniband/hw/irdma/verbs.c",
            "region": {
                "startLine": 4625,
                "startColumn": 59,
                "endColumn": 64
            },
            "context": {
                "startLine": 4623,
                "endLine": 4627,
                "snippet": {
                    "text": "err = ib_copy_to_udata(udata, &uresp, min(sizeof(uresp), udata->outlen));"
                }
            }
        },
        "function_code": "static int irdma_create_user_ah(struct ib_ah *ibah,\n\t\t\t\tstruct rdma_ah_init_attr *attr,\n\t\t\t\tstruct ib_udata *udata)\n{\n#define IRDMA_CREATE_AH_MIN_RESP_LEN offsetofend(struct irdma_create_ah_resp, rsvd)\n\tstruct irdma_ah *ah = container_of(ibah, struct irdma_ah, ibah);\n\tstruct irdma_device *iwdev = to_iwdev(ibah->pd->device);\n\tstruct irdma_create_ah_resp uresp;\n\tstruct irdma_ah *parent_ah;\n\tint err;\n\n\tif (udata && udata->outlen < IRDMA_CREATE_AH_MIN_RESP_LEN)\n\t\treturn -EINVAL;\n\n\terr = irdma_setup_ah(ibah, attr);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&iwdev->ah_tbl_lock);\n\tif (!irdma_ah_exists(iwdev, ah)) {\n\t\terr = irdma_create_hw_ah(iwdev, ah, true);\n\t\tif (err) {\n\t\t\tmutex_unlock(&iwdev->ah_tbl_lock);\n\t\t\treturn err;\n\t\t}\n\t\t/* Add new AH to list */\n\t\tparent_ah = kmemdup(ah, sizeof(*ah), GFP_KERNEL);\n\t\tif (parent_ah) {\n\t\t\tu32 key = parent_ah->sc_ah.ah_info.dest_ip_addr[0] ^\n\t\t\t\t  parent_ah->sc_ah.ah_info.dest_ip_addr[1] ^\n\t\t\t\t  parent_ah->sc_ah.ah_info.dest_ip_addr[2] ^\n\t\t\t\t  parent_ah->sc_ah.ah_info.dest_ip_addr[3];\n\n\t\t\tah->parent_ah = parent_ah;\n\t\t\thash_add(iwdev->ah_hash_tbl, &parent_ah->list, key);\n\t\t\trefcount_set(&parent_ah->refcnt, 1);\n\t\t}\n\t}\n\tmutex_unlock(&iwdev->ah_tbl_lock);\n\n\turesp.ah_id = ah->sc_ah.ah_info.ah_idx;\n\terr = ib_copy_to_udata(udata, &uresp, min(sizeof(uresp), udata->outlen));\n\tif (err)\n\t\tirdma_destroy_ah(ibah, attr->flags);\n\n\treturn err;\n}"
    },
    {
        "var_name": "mem_p",
        "function_name": "siw_rx_data",
        "location": {
            "file_path": "drivers/infiniband/sw/siw/siw_qp_rx.c",
            "region": {
                "startLine": 413,
                "startColumn": 6,
                "endColumn": 11
            },
            "context": {
                "startLine": 411,
                "endLine": 415,
                "snippet": {
                    "text": "if (mem_p->mem_obj == NULL)"
                }
            }
        },
        "function_code": "static int siw_rx_data(struct siw_mem *mem_p, struct siw_rx_stream *srx,\n\t\t       unsigned int *pbl_idx, u64 addr, int bytes)\n{\n\tint rv;\n\n\tif (mem_p->mem_obj == NULL)\n\t\trv = siw_rx_kva(srx, ib_virt_dma_to_ptr(addr), bytes);\n\telse if (!mem_p->is_pbl)\n\t\trv = siw_rx_umem(srx, mem_p->umem, addr, bytes);\n\telse\n\t\trv = siw_rx_pbl(srx, pbl_idx, mem_p, addr, bytes);\n\treturn rv;\n}"
    },
    {
        "var_name": "mem_p",
        "function_name": "siw_rx_data",
        "location": {
            "file_path": "drivers/infiniband/sw/siw/siw_qp_rx.c",
            "region": {
                "startLine": 415,
                "startColumn": 12,
                "endColumn": 17
            },
            "context": {
                "startLine": 413,
                "endLine": 417,
                "snippet": {
                    "text": "else if (!mem_p->is_pbl)"
                }
            }
        },
        "function_code": "static int siw_rx_data(struct siw_mem *mem_p, struct siw_rx_stream *srx,\n\t\t       unsigned int *pbl_idx, u64 addr, int bytes)\n{\n\tint rv;\n\n\tif (mem_p->mem_obj == NULL)\n\t\trv = siw_rx_kva(srx, ib_virt_dma_to_ptr(addr), bytes);\n\telse if (!mem_p->is_pbl)\n\t\trv = siw_rx_umem(srx, mem_p->umem, addr, bytes);\n\telse\n\t\trv = siw_rx_pbl(srx, pbl_idx, mem_p, addr, bytes);\n\treturn rv;\n}"
    },
    {
        "var_name": "device",
        "function_name": "isert_device_put",
        "location": {
            "file_path": "drivers/infiniband/ulp/isert/ib_isert.c",
            "region": {
                "startLine": 254,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 252,
                "endLine": 256,
                "snippet": {
                    "text": "device->refcount--;"
                }
            }
        },
        "function_code": "static void\nisert_device_put(struct isert_device *device)\n{\n\tmutex_lock(&device_list_mutex);\n\tdevice->refcount--;\n\tisert_info(\"device %p refcount %d\\n\", device, device->refcount);\n\tif (!device->refcount) {\n\t\tisert_free_device_ib_res(device);\n\t\tlist_del(&device->dev_node);\n\t\tkfree(device);\n\t}\n\tmutex_unlock(&device_list_mutex);\n}"
    },
    {
        "var_name": "login",
        "function_name": "isert_rx_login_req",
        "location": {
            "file_path": "drivers/infiniband/ulp/isert/ib_isert.c",
            "region": {
                "startLine": 992,
                "startColumn": 6,
                "endColumn": 11
            },
            "context": {
                "startLine": 990,
                "endLine": 994,
                "snippet": {
                    "text": "if (login->first_request) {"
                }
            }
        },
        "function_code": "static void\nisert_rx_login_req(struct isert_conn *isert_conn)\n{\n\tstruct iser_rx_desc *rx_desc = isert_conn->login_desc;\n\tint rx_buflen = isert_conn->login_req_len;\n\tstruct iscsit_conn *conn = isert_conn->conn;\n\tstruct iscsi_login *login = conn->conn_login;\n\tint size;\n\n\tisert_info(\"conn %p\\n\", isert_conn);\n\n\tWARN_ON_ONCE(!login);\n\n\tif (login->first_request) {\n\t\tstruct iscsi_login_req *login_req =\n\t\t\t(struct iscsi_login_req *)isert_get_iscsi_hdr(rx_desc);\n\t\t/*\n\t\t * Setup the initial iscsi_login values from the leading\n\t\t * login request PDU.\n\t\t */\n\t\tlogin->leading_connection = (!login_req->tsih) ? 1 : 0;\n\t\tlogin->current_stage = ISCSI_LOGIN_CURRENT_STAGE(\n\t\t\t\tlogin_req->flags);\n\t\tlogin->version_min\t= login_req->min_version;\n\t\tlogin->version_max\t= login_req->max_version;\n\t\tmemcpy(login->isid, login_req->isid, 6);\n\t\tlogin->cmd_sn\t\t= be32_to_cpu(login_req->cmdsn);\n\t\tlogin->init_task_tag\t= login_req->itt;\n\t\tlogin->initial_exp_statsn = be32_to_cpu(login_req->exp_statsn);\n\t\tlogin->cid\t\t= be16_to_cpu(login_req->cid);\n\t\tlogin->tsih\t\t= be16_to_cpu(login_req->tsih);\n\t}\n\n\tmemcpy(&login->req[0], isert_get_iscsi_hdr(rx_desc), ISCSI_HDR_LEN);\n\n\tsize = min(rx_buflen, MAX_KEY_VALUE_PAIRS);\n\tisert_dbg(\"Using login payload size: %d, rx_buflen: %d \"\n\t\t  \"MAX_KEY_VALUE_PAIRS: %d\\n\", size, rx_buflen,\n\t\t  MAX_KEY_VALUE_PAIRS);\n\tmemcpy(login->req_buf, isert_get_data(rx_desc), size);\n\n\tif (login->first_request) {\n\t\tcomplete(&isert_conn->login_comp);\n\t\treturn;\n\t}\n\tqueue_delayed_work(isert_login_wq, &conn->login_work, 0);\n}"
    },
    {
        "var_name": "ch",
        "function_name": "srpt_post_recv",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 848,
                "startColumn": 23,
                "endColumn": 25
            },
            "context": {
                "startLine": 846,
                "endLine": 850,
                "snippet": {
                    "text": "return ib_post_recv(ch->qp, &wr, NULL);"
                }
            }
        },
        "function_code": "static int srpt_post_recv(struct srpt_device *sdev, struct srpt_rdma_ch *ch,\n\t\t\t  struct srpt_recv_ioctx *ioctx)\n{\n\tstruct ib_sge list;\n\tstruct ib_recv_wr wr;\n\n\tBUG_ON(!sdev);\n\tlist.addr = ioctx->ioctx.dma + ioctx->ioctx.offset;\n\tlist.length = srp_max_req_size;\n\tlist.lkey = sdev->lkey;\n\n\tioctx->ioctx.cqe.done = srpt_recv_done;\n\twr.wr_cqe = &ioctx->ioctx.cqe;\n\twr.next = NULL;\n\twr.sg_list = &list;\n\twr.num_sge = 1;\n\n\tif (sdev->use_srq)\n\t\treturn ib_post_srq_recv(sdev->srq, &wr, NULL);\n\telse\n\t\treturn ib_post_recv(ch->qp, &wr, NULL);\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_cmd_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1393,
                "startColumn": 9,
                "endColumn": 16
            },
            "context": {
                "startLine": 1391,
                "endLine": 1395,
                "snippet": {
                    "text": "memset(srp_rsp, 0, sizeof(*srp_rsp));"
                }
            }
        },
        "function_code": "static int srpt_build_cmd_rsp(struct srpt_rdma_ch *ch,\n\t\t\t      struct srpt_send_ioctx *ioctx, u64 tag,\n\t\t\t      int status)\n{\n\tstruct se_cmd *cmd = &ioctx->cmd;\n\tstruct srp_rsp *srp_rsp;\n\tconst u8 *sense_data;\n\tint sense_data_len, max_sense_len;\n\tu32 resid = cmd->residual_count;\n\n\t/*\n\t * The lowest bit of all SAM-3 status codes is zero (see also\n\t * paragraph 5.3 in SAM-3).\n\t */\n\tWARN_ON(status & 1);\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\n\tsense_data = ioctx->sense_data;\n\tsense_data_len = ioctx->cmd.scsi_sense_length;\n\tWARN_ON(sense_data_len > sizeof(ioctx->sense_data));\n\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\tsrp_rsp->status = status;\n\n\tif (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an underflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOUNDER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an underflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIUNDER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t} else if (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an overflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOOVER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an overflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIOVER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t}\n\n\tif (sense_data_len) {\n\t\tBUILD_BUG_ON(MIN_MAX_RSP_SIZE <= sizeof(*srp_rsp));\n\t\tmax_sense_len = ch->max_ti_iu_len - sizeof(*srp_rsp);\n\t\tif (sense_data_len > max_sense_len) {\n\t\t\tpr_warn(\"truncated sense data from %d to %d bytes\\n\",\n\t\t\t\tsense_data_len, max_sense_len);\n\t\t\tsense_data_len = max_sense_len;\n\t\t}\n\n\t\tsrp_rsp->flags |= SRP_RSP_FLAG_SNSVALID;\n\t\tsrp_rsp->sense_data_len = cpu_to_be32(sense_data_len);\n\t\tmemcpy(srp_rsp->data, sense_data, sense_data_len);\n\t}\n\n\treturn sizeof(*srp_rsp) + sense_data_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_cmd_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1394,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1392,
                "endLine": 1396,
                "snippet": {
                    "text": "srp_rsp->opcode = SRP_RSP;"
                }
            }
        },
        "function_code": "static int srpt_build_cmd_rsp(struct srpt_rdma_ch *ch,\n\t\t\t      struct srpt_send_ioctx *ioctx, u64 tag,\n\t\t\t      int status)\n{\n\tstruct se_cmd *cmd = &ioctx->cmd;\n\tstruct srp_rsp *srp_rsp;\n\tconst u8 *sense_data;\n\tint sense_data_len, max_sense_len;\n\tu32 resid = cmd->residual_count;\n\n\t/*\n\t * The lowest bit of all SAM-3 status codes is zero (see also\n\t * paragraph 5.3 in SAM-3).\n\t */\n\tWARN_ON(status & 1);\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\n\tsense_data = ioctx->sense_data;\n\tsense_data_len = ioctx->cmd.scsi_sense_length;\n\tWARN_ON(sense_data_len > sizeof(ioctx->sense_data));\n\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\tsrp_rsp->status = status;\n\n\tif (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an underflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOUNDER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an underflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIUNDER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t} else if (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an overflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOOVER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an overflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIOVER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t}\n\n\tif (sense_data_len) {\n\t\tBUILD_BUG_ON(MIN_MAX_RSP_SIZE <= sizeof(*srp_rsp));\n\t\tmax_sense_len = ch->max_ti_iu_len - sizeof(*srp_rsp);\n\t\tif (sense_data_len > max_sense_len) {\n\t\t\tpr_warn(\"truncated sense data from %d to %d bytes\\n\",\n\t\t\t\tsense_data_len, max_sense_len);\n\t\t\tsense_data_len = max_sense_len;\n\t\t}\n\n\t\tsrp_rsp->flags |= SRP_RSP_FLAG_SNSVALID;\n\t\tsrp_rsp->sense_data_len = cpu_to_be32(sense_data_len);\n\t\tmemcpy(srp_rsp->data, sense_data, sense_data_len);\n\t}\n\n\treturn sizeof(*srp_rsp) + sense_data_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_cmd_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1395,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1393,
                "endLine": 1397,
                "snippet": {
                    "text": "srp_rsp->req_lim_delta ="
                }
            }
        },
        "function_code": "static int srpt_build_cmd_rsp(struct srpt_rdma_ch *ch,\n\t\t\t      struct srpt_send_ioctx *ioctx, u64 tag,\n\t\t\t      int status)\n{\n\tstruct se_cmd *cmd = &ioctx->cmd;\n\tstruct srp_rsp *srp_rsp;\n\tconst u8 *sense_data;\n\tint sense_data_len, max_sense_len;\n\tu32 resid = cmd->residual_count;\n\n\t/*\n\t * The lowest bit of all SAM-3 status codes is zero (see also\n\t * paragraph 5.3 in SAM-3).\n\t */\n\tWARN_ON(status & 1);\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\n\tsense_data = ioctx->sense_data;\n\tsense_data_len = ioctx->cmd.scsi_sense_length;\n\tWARN_ON(sense_data_len > sizeof(ioctx->sense_data));\n\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\tsrp_rsp->status = status;\n\n\tif (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an underflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOUNDER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an underflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIUNDER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t} else if (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an overflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOOVER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an overflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIOVER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t}\n\n\tif (sense_data_len) {\n\t\tBUILD_BUG_ON(MIN_MAX_RSP_SIZE <= sizeof(*srp_rsp));\n\t\tmax_sense_len = ch->max_ti_iu_len - sizeof(*srp_rsp);\n\t\tif (sense_data_len > max_sense_len) {\n\t\t\tpr_warn(\"truncated sense data from %d to %d bytes\\n\",\n\t\t\t\tsense_data_len, max_sense_len);\n\t\t\tsense_data_len = max_sense_len;\n\t\t}\n\n\t\tsrp_rsp->flags |= SRP_RSP_FLAG_SNSVALID;\n\t\tsrp_rsp->sense_data_len = cpu_to_be32(sense_data_len);\n\t\tmemcpy(srp_rsp->data, sense_data, sense_data_len);\n\t}\n\n\treturn sizeof(*srp_rsp) + sense_data_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_cmd_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1397,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1395,
                "endLine": 1399,
                "snippet": {
                    "text": "srp_rsp->tag = tag;"
                }
            }
        },
        "function_code": "static int srpt_build_cmd_rsp(struct srpt_rdma_ch *ch,\n\t\t\t      struct srpt_send_ioctx *ioctx, u64 tag,\n\t\t\t      int status)\n{\n\tstruct se_cmd *cmd = &ioctx->cmd;\n\tstruct srp_rsp *srp_rsp;\n\tconst u8 *sense_data;\n\tint sense_data_len, max_sense_len;\n\tu32 resid = cmd->residual_count;\n\n\t/*\n\t * The lowest bit of all SAM-3 status codes is zero (see also\n\t * paragraph 5.3 in SAM-3).\n\t */\n\tWARN_ON(status & 1);\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\n\tsense_data = ioctx->sense_data;\n\tsense_data_len = ioctx->cmd.scsi_sense_length;\n\tWARN_ON(sense_data_len > sizeof(ioctx->sense_data));\n\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\tsrp_rsp->status = status;\n\n\tif (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an underflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOUNDER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an underflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIUNDER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t} else if (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an overflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOOVER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an overflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIOVER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t}\n\n\tif (sense_data_len) {\n\t\tBUILD_BUG_ON(MIN_MAX_RSP_SIZE <= sizeof(*srp_rsp));\n\t\tmax_sense_len = ch->max_ti_iu_len - sizeof(*srp_rsp);\n\t\tif (sense_data_len > max_sense_len) {\n\t\t\tpr_warn(\"truncated sense data from %d to %d bytes\\n\",\n\t\t\t\tsense_data_len, max_sense_len);\n\t\t\tsense_data_len = max_sense_len;\n\t\t}\n\n\t\tsrp_rsp->flags |= SRP_RSP_FLAG_SNSVALID;\n\t\tsrp_rsp->sense_data_len = cpu_to_be32(sense_data_len);\n\t\tmemcpy(srp_rsp->data, sense_data, sense_data_len);\n\t}\n\n\treturn sizeof(*srp_rsp) + sense_data_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_cmd_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1398,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1396,
                "endLine": 1400,
                "snippet": {
                    "text": "srp_rsp->status = status;"
                }
            }
        },
        "function_code": "static int srpt_build_cmd_rsp(struct srpt_rdma_ch *ch,\n\t\t\t      struct srpt_send_ioctx *ioctx, u64 tag,\n\t\t\t      int status)\n{\n\tstruct se_cmd *cmd = &ioctx->cmd;\n\tstruct srp_rsp *srp_rsp;\n\tconst u8 *sense_data;\n\tint sense_data_len, max_sense_len;\n\tu32 resid = cmd->residual_count;\n\n\t/*\n\t * The lowest bit of all SAM-3 status codes is zero (see also\n\t * paragraph 5.3 in SAM-3).\n\t */\n\tWARN_ON(status & 1);\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\n\tsense_data = ioctx->sense_data;\n\tsense_data_len = ioctx->cmd.scsi_sense_length;\n\tWARN_ON(sense_data_len > sizeof(ioctx->sense_data));\n\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\tsrp_rsp->status = status;\n\n\tif (cmd->se_cmd_flags & SCF_UNDERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an underflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOUNDER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an underflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIUNDER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t} else if (cmd->se_cmd_flags & SCF_OVERFLOW_BIT) {\n\t\tif (cmd->data_direction == DMA_TO_DEVICE) {\n\t\t\t/* residual data from an overflow write */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DOOVER;\n\t\t\tsrp_rsp->data_out_res_cnt = cpu_to_be32(resid);\n\t\t} else if (cmd->data_direction == DMA_FROM_DEVICE) {\n\t\t\t/* residual data from an overflow read */\n\t\t\tsrp_rsp->flags = SRP_RSP_FLAG_DIOVER;\n\t\t\tsrp_rsp->data_in_res_cnt = cpu_to_be32(resid);\n\t\t}\n\t}\n\n\tif (sense_data_len) {\n\t\tBUILD_BUG_ON(MIN_MAX_RSP_SIZE <= sizeof(*srp_rsp));\n\t\tmax_sense_len = ch->max_ti_iu_len - sizeof(*srp_rsp);\n\t\tif (sense_data_len > max_sense_len) {\n\t\t\tpr_warn(\"truncated sense data from %d to %d bytes\\n\",\n\t\t\t\tsense_data_len, max_sense_len);\n\t\t\tsense_data_len = max_sense_len;\n\t\t}\n\n\t\tsrp_rsp->flags |= SRP_RSP_FLAG_SNSVALID;\n\t\tsrp_rsp->sense_data_len = cpu_to_be32(sense_data_len);\n\t\tmemcpy(srp_rsp->data, sense_data, sense_data_len);\n\t}\n\n\treturn sizeof(*srp_rsp) + sense_data_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_tskmgmt_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1465,
                "startColumn": 9,
                "endColumn": 16
            },
            "context": {
                "startLine": 1463,
                "endLine": 1467,
                "snippet": {
                    "text": "memset(srp_rsp, 0, sizeof(*srp_rsp));"
                }
            }
        },
        "function_code": "static int srpt_build_tskmgmt_rsp(struct srpt_rdma_ch *ch,\n\t\t\t\t  struct srpt_send_ioctx *ioctx,\n\t\t\t\t  u8 rsp_code, u64 tag)\n{\n\tstruct srp_rsp *srp_rsp;\n\tint resp_data_len;\n\tint resp_len;\n\n\tresp_data_len = 4;\n\tresp_len = sizeof(*srp_rsp) + resp_data_len;\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\n\tsrp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\tsrp_rsp->resp_data_len = cpu_to_be32(resp_data_len);\n\tsrp_rsp->data[3] = rsp_code;\n\n\treturn resp_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_tskmgmt_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1467,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1465,
                "endLine": 1469,
                "snippet": {
                    "text": "srp_rsp->opcode = SRP_RSP;"
                }
            }
        },
        "function_code": "static int srpt_build_tskmgmt_rsp(struct srpt_rdma_ch *ch,\n\t\t\t\t  struct srpt_send_ioctx *ioctx,\n\t\t\t\t  u8 rsp_code, u64 tag)\n{\n\tstruct srp_rsp *srp_rsp;\n\tint resp_data_len;\n\tint resp_len;\n\n\tresp_data_len = 4;\n\tresp_len = sizeof(*srp_rsp) + resp_data_len;\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\n\tsrp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\tsrp_rsp->resp_data_len = cpu_to_be32(resp_data_len);\n\tsrp_rsp->data[3] = rsp_code;\n\n\treturn resp_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_tskmgmt_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1468,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1466,
                "endLine": 1470,
                "snippet": {
                    "text": "srp_rsp->req_lim_delta ="
                }
            }
        },
        "function_code": "static int srpt_build_tskmgmt_rsp(struct srpt_rdma_ch *ch,\n\t\t\t\t  struct srpt_send_ioctx *ioctx,\n\t\t\t\t  u8 rsp_code, u64 tag)\n{\n\tstruct srp_rsp *srp_rsp;\n\tint resp_data_len;\n\tint resp_len;\n\n\tresp_data_len = 4;\n\tresp_len = sizeof(*srp_rsp) + resp_data_len;\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\n\tsrp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\tsrp_rsp->resp_data_len = cpu_to_be32(resp_data_len);\n\tsrp_rsp->data[3] = rsp_code;\n\n\treturn resp_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_tskmgmt_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1470,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1468,
                "endLine": 1472,
                "snippet": {
                    "text": "srp_rsp->tag = tag;"
                }
            }
        },
        "function_code": "static int srpt_build_tskmgmt_rsp(struct srpt_rdma_ch *ch,\n\t\t\t\t  struct srpt_send_ioctx *ioctx,\n\t\t\t\t  u8 rsp_code, u64 tag)\n{\n\tstruct srp_rsp *srp_rsp;\n\tint resp_data_len;\n\tint resp_len;\n\n\tresp_data_len = 4;\n\tresp_len = sizeof(*srp_rsp) + resp_data_len;\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\n\tsrp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\tsrp_rsp->resp_data_len = cpu_to_be32(resp_data_len);\n\tsrp_rsp->data[3] = rsp_code;\n\n\treturn resp_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_tskmgmt_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1472,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1470,
                "endLine": 1474,
                "snippet": {
                    "text": "srp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;"
                }
            }
        },
        "function_code": "static int srpt_build_tskmgmt_rsp(struct srpt_rdma_ch *ch,\n\t\t\t\t  struct srpt_send_ioctx *ioctx,\n\t\t\t\t  u8 rsp_code, u64 tag)\n{\n\tstruct srp_rsp *srp_rsp;\n\tint resp_data_len;\n\tint resp_len;\n\n\tresp_data_len = 4;\n\tresp_len = sizeof(*srp_rsp) + resp_data_len;\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\n\tsrp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\tsrp_rsp->resp_data_len = cpu_to_be32(resp_data_len);\n\tsrp_rsp->data[3] = rsp_code;\n\n\treturn resp_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_tskmgmt_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1473,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1471,
                "endLine": 1475,
                "snippet": {
                    "text": "srp_rsp->resp_data_len = cpu_to_be32(resp_data_len);"
                }
            }
        },
        "function_code": "static int srpt_build_tskmgmt_rsp(struct srpt_rdma_ch *ch,\n\t\t\t\t  struct srpt_send_ioctx *ioctx,\n\t\t\t\t  u8 rsp_code, u64 tag)\n{\n\tstruct srp_rsp *srp_rsp;\n\tint resp_data_len;\n\tint resp_len;\n\n\tresp_data_len = 4;\n\tresp_len = sizeof(*srp_rsp) + resp_data_len;\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\n\tsrp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\tsrp_rsp->resp_data_len = cpu_to_be32(resp_data_len);\n\tsrp_rsp->data[3] = rsp_code;\n\n\treturn resp_len;\n}"
    },
    {
        "var_name": "srp_rsp",
        "function_name": "srpt_build_tskmgmt_rsp",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 1474,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 1472,
                "endLine": 1476,
                "snippet": {
                    "text": "srp_rsp->data[3] = rsp_code;"
                }
            }
        },
        "function_code": "static int srpt_build_tskmgmt_rsp(struct srpt_rdma_ch *ch,\n\t\t\t\t  struct srpt_send_ioctx *ioctx,\n\t\t\t\t  u8 rsp_code, u64 tag)\n{\n\tstruct srp_rsp *srp_rsp;\n\tint resp_data_len;\n\tint resp_len;\n\n\tresp_data_len = 4;\n\tresp_len = sizeof(*srp_rsp) + resp_data_len;\n\n\tsrp_rsp = ioctx->ioctx.buf;\n\tBUG_ON(!srp_rsp);\n\tmemset(srp_rsp, 0, sizeof(*srp_rsp));\n\n\tsrp_rsp->opcode = SRP_RSP;\n\tsrp_rsp->req_lim_delta =\n\t\tcpu_to_be32(1 + atomic_xchg(&ch->req_lim_delta, 0));\n\tsrp_rsp->tag = tag;\n\n\tsrp_rsp->flags |= SRP_RSP_FLAG_RSPVALID;\n\tsrp_rsp->resp_data_len = cpu_to_be32(resp_data_len);\n\tsrp_rsp->data[3] = rsp_code;\n\n\treturn resp_len;\n}"
    },
    {
        "var_name": "ib_cm_id",
        "function_name": "srpt_cm_req_recv",
        "location": {
            "file_path": "drivers/infiniband/ulp/srpt/ib_srpt.c",
            "region": {
                "startLine": 2235,
                "startColumn": 3,
                "endColumn": 11
            },
            "context": {
                "startLine": 2233,
                "endLine": 2237,
                "snippet": {
                    "text": "ib_cm_id->context = ch;"
                }
            }
        },
        "function_code": "static int srpt_cm_req_recv(struct srpt_device *const sdev,\n\t\t\t    struct ib_cm_id *ib_cm_id,\n\t\t\t    struct rdma_cm_id *rdma_cm_id,\n\t\t\t    u8 port_num, __be16 pkey,\n\t\t\t    const struct srp_login_req *req,\n\t\t\t    const char *src_addr)\n{\n\tstruct srpt_port *sport = &sdev->port[port_num - 1];\n\tstruct srpt_nexus *nexus;\n\tstruct srp_login_rsp *rsp = NULL;\n\tstruct srp_login_rej *rej = NULL;\n\tunion {\n\t\tstruct rdma_conn_param rdma_cm;\n\t\tstruct ib_cm_rep_param ib_cm;\n\t} *rep_param = NULL;\n\tstruct srpt_rdma_ch *ch = NULL;\n\tchar i_port_id[36];\n\tu32 it_iu_len;\n\tint i, tag_num, tag_size, ret;\n\tstruct srpt_tpg *stpg;\n\n\tWARN_ON_ONCE(irqs_disabled());\n\n\tit_iu_len = be32_to_cpu(req->req_it_iu_len);\n\n\tpr_info(\"Received SRP_LOGIN_REQ with i_port_id %pI6, t_port_id %pI6 and it_iu_len %d on port %d (guid=%pI6); pkey %#04x\\n\",\n\t\treq->initiator_port_id, req->target_port_id, it_iu_len,\n\t\tport_num, &sport->gid, be16_to_cpu(pkey));\n\n\tnexus = srpt_get_nexus(sport, req->initiator_port_id,\n\t\t\t       req->target_port_id);\n\tif (IS_ERR(nexus)) {\n\t\tret = PTR_ERR(nexus);\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\trsp = kzalloc(sizeof(*rsp), GFP_KERNEL);\n\trej = kzalloc(sizeof(*rej), GFP_KERNEL);\n\trep_param = kzalloc(sizeof(*rep_param), GFP_KERNEL);\n\tif (!rsp || !rej || !rep_param)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (it_iu_len > srp_max_req_size || it_iu_len < 64) {\n\t\trej->reason = cpu_to_be32(\n\t\t\t\tSRP_LOGIN_REJ_REQ_IT_IU_LENGTH_TOO_LARGE);\n\t\tpr_err(\"rejected SRP_LOGIN_REQ because its length (%d bytes) is out of range (%d .. %d)\\n\",\n\t\t       it_iu_len, 64, srp_max_req_size);\n\t\tgoto reject;\n\t}\n\n\tif (!sport->enabled) {\n\t\trej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);\n\t\tpr_info(\"rejected SRP_LOGIN_REQ because target port %s_%d has not yet been enabled\\n\",\n\t\t\tdev_name(&sport->sdev->device->dev), port_num);\n\t\tgoto reject;\n\t}\n\n\tif (*(__be64 *)req->target_port_id != cpu_to_be64(srpt_service_guid)\n\t    || *(__be64 *)(req->target_port_id + 8) !=\n\t       cpu_to_be64(srpt_service_guid)) {\n\t\trej->reason = cpu_to_be32(\n\t\t\t\tSRP_LOGIN_REJ_UNABLE_ASSOCIATE_CHANNEL);\n\t\tpr_err(\"rejected SRP_LOGIN_REQ because it has an invalid target port identifier.\\n\");\n\t\tgoto reject;\n\t}\n\n\tret = -ENOMEM;\n\tch = kzalloc(sizeof(*ch), GFP_KERNEL);\n\tif (!ch) {\n\t\trej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);\n\t\tpr_err(\"rejected SRP_LOGIN_REQ because out of memory.\\n\");\n\t\tgoto reject;\n\t}\n\n\tkref_init(&ch->kref);\n\tch->pkey = be16_to_cpu(pkey);\n\tch->nexus = nexus;\n\tch->zw_cqe.done = srpt_zerolength_write_done;\n\tINIT_WORK(&ch->release_work, srpt_release_channel_work);\n\tch->sport = sport;\n\tif (rdma_cm_id) {\n\t\tch->using_rdma_cm = true;\n\t\tch->rdma_cm.cm_id = rdma_cm_id;\n\t\trdma_cm_id->context = ch;\n\t} else {\n\t\tch->ib_cm.cm_id = ib_cm_id;\n\t\tib_cm_id->context = ch;\n\t}\n\t/*\n\t * ch->rq_size should be at least as large as the initiator queue\n\t * depth to avoid that the initiator driver has to report QUEUE_FULL\n\t * to the SCSI mid-layer.\n\t */\n\tch->rq_size = min(MAX_SRPT_RQ_SIZE, sdev->device->attrs.max_qp_wr);\n\tspin_lock_init(&ch->spinlock);\n\tch->state = CH_CONNECTING;\n\tINIT_LIST_HEAD(&ch->cmd_wait_list);\n\tch->max_rsp_size = ch->sport->port_attrib.srp_max_rsp_size;\n\n\tch->rsp_buf_cache = kmem_cache_create(\"srpt-rsp-buf\", ch->max_rsp_size,\n\t\t\t\t\t      512, 0, NULL);\n\tif (!ch->rsp_buf_cache)\n\t\tgoto free_ch;\n\n\tch->ioctx_ring = (struct srpt_send_ioctx **)\n\t\tsrpt_alloc_ioctx_ring(ch->sport->sdev, ch->rq_size,\n\t\t\t\t      sizeof(*ch->ioctx_ring[0]),\n\t\t\t\t      ch->rsp_buf_cache, 0, DMA_TO_DEVICE);\n\tif (!ch->ioctx_ring) {\n\t\tpr_err(\"rejected SRP_LOGIN_REQ because creating a new QP SQ ring failed.\\n\");\n\t\trej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);\n\t\tgoto free_rsp_cache;\n\t}\n\n\tfor (i = 0; i < ch->rq_size; i++)\n\t\tch->ioctx_ring[i]->ch = ch;\n\tif (!sdev->use_srq) {\n\t\tu16 imm_data_offset = req->req_flags & SRP_IMMED_REQUESTED ?\n\t\t\tbe16_to_cpu(req->imm_data_offset) : 0;\n\t\tu16 alignment_offset;\n\t\tu32 req_sz;\n\n\t\tif (req->req_flags & SRP_IMMED_REQUESTED)\n\t\t\tpr_debug(\"imm_data_offset = %d\\n\",\n\t\t\t\t be16_to_cpu(req->imm_data_offset));\n\t\tif (imm_data_offset >= sizeof(struct srp_cmd)) {\n\t\t\tch->imm_data_offset = imm_data_offset;\n\t\t\trsp->rsp_flags |= SRP_LOGIN_RSP_IMMED_SUPP;\n\t\t} else {\n\t\t\tch->imm_data_offset = 0;\n\t\t}\n\t\talignment_offset = round_up(imm_data_offset, 512) -\n\t\t\timm_data_offset;\n\t\treq_sz = alignment_offset + imm_data_offset + srp_max_req_size;\n\t\tch->req_buf_cache = kmem_cache_create(\"srpt-req-buf\", req_sz,\n\t\t\t\t\t\t      512, 0, NULL);\n\t\tif (!ch->req_buf_cache)\n\t\t\tgoto free_rsp_ring;\n\n\t\tch->ioctx_recv_ring = (struct srpt_recv_ioctx **)\n\t\t\tsrpt_alloc_ioctx_ring(ch->sport->sdev, ch->rq_size,\n\t\t\t\t\t      sizeof(*ch->ioctx_recv_ring[0]),\n\t\t\t\t\t      ch->req_buf_cache,\n\t\t\t\t\t      alignment_offset,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\tif (!ch->ioctx_recv_ring) {\n\t\t\tpr_err(\"rejected SRP_LOGIN_REQ because creating a new QP RQ ring failed.\\n\");\n\t\t\trej->reason =\n\t\t\t    cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);\n\t\t\tgoto free_recv_cache;\n\t\t}\n\t\tfor (i = 0; i < ch->rq_size; i++)\n\t\t\tINIT_LIST_HEAD(&ch->ioctx_recv_ring[i]->wait_list);\n\t}\n\n\tret = srpt_create_ch_ib(ch);\n\tif (ret) {\n\t\trej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);\n\t\tpr_err(\"rejected SRP_LOGIN_REQ because creating a new RDMA channel failed.\\n\");\n\t\tgoto free_recv_ring;\n\t}\n\n\tstrscpy(ch->sess_name, src_addr, sizeof(ch->sess_name));\n\tsnprintf(i_port_id, sizeof(i_port_id), \"0x%016llx%016llx\",\n\t\t\tbe64_to_cpu(*(__be64 *)nexus->i_port_id),\n\t\t\tbe64_to_cpu(*(__be64 *)(nexus->i_port_id + 8)));\n\n\tpr_debug(\"registering src addr %s or i_port_id %s\\n\", ch->sess_name,\n\t\t i_port_id);\n\n\ttag_num = ch->rq_size;\n\ttag_size = 1; /* ib_srpt does not use se_sess->sess_cmd_map */\n\n\tif (sport->guid_id) {\n\t\tmutex_lock(&sport->guid_id->mutex);\n\t\tlist_for_each_entry(stpg, &sport->guid_id->tpg_list, entry) {\n\t\t\tif (!IS_ERR_OR_NULL(ch->sess))\n\t\t\t\tbreak;\n\t\t\tch->sess = target_setup_session(&stpg->tpg, tag_num,\n\t\t\t\t\t\ttag_size, TARGET_PROT_NORMAL,\n\t\t\t\t\t\tch->sess_name, ch, NULL);\n\t\t}\n\t\tmutex_unlock(&sport->guid_id->mutex);\n\t}\n\n\tif (sport->gid_id) {\n\t\tmutex_lock(&sport->gid_id->mutex);\n\t\tlist_for_each_entry(stpg, &sport->gid_id->tpg_list, entry) {\n\t\t\tif (!IS_ERR_OR_NULL(ch->sess))\n\t\t\t\tbreak;\n\t\t\tch->sess = target_setup_session(&stpg->tpg, tag_num,\n\t\t\t\t\ttag_size, TARGET_PROT_NORMAL, i_port_id,\n\t\t\t\t\tch, NULL);\n\t\t\tif (!IS_ERR_OR_NULL(ch->sess))\n\t\t\t\tbreak;\n\t\t\t/* Retry without leading \"0x\" */\n\t\t\tch->sess = target_setup_session(&stpg->tpg, tag_num,\n\t\t\t\t\t\ttag_size, TARGET_PROT_NORMAL,\n\t\t\t\t\t\ti_port_id + 2, ch, NULL);\n\t\t}\n\t\tmutex_unlock(&sport->gid_id->mutex);\n\t}\n\n\tif (IS_ERR_OR_NULL(ch->sess)) {\n\t\tWARN_ON_ONCE(ch->sess == NULL);\n\t\tret = PTR_ERR(ch->sess);\n\t\tch->sess = NULL;\n\t\tpr_info(\"Rejected login for initiator %s: ret = %d.\\n\",\n\t\t\tch->sess_name, ret);\n\t\trej->reason = cpu_to_be32(ret == -ENOMEM ?\n\t\t\t\tSRP_LOGIN_REJ_INSUFFICIENT_RESOURCES :\n\t\t\t\tSRP_LOGIN_REJ_CHANNEL_LIMIT_REACHED);\n\t\tgoto destroy_ib;\n\t}\n\n\t/*\n\t * Once a session has been created destruction of srpt_rdma_ch objects\n\t * will decrement sport->refcount. Hence increment sport->refcount now.\n\t */\n\tatomic_inc(&sport->refcount);\n\n\tmutex_lock(&sport->mutex);\n\n\tif ((req->req_flags & SRP_MTCH_ACTION) == SRP_MULTICHAN_SINGLE) {\n\t\tstruct srpt_rdma_ch *ch2;\n\n\t\tlist_for_each_entry(ch2, &nexus->ch_list, list) {\n\t\t\tif (srpt_disconnect_ch(ch2) < 0)\n\t\t\t\tcontinue;\n\t\t\tpr_info(\"Relogin - closed existing channel %s\\n\",\n\t\t\t\tch2->sess_name);\n\t\t\trsp->rsp_flags |= SRP_LOGIN_RSP_MULTICHAN_TERMINATED;\n\t\t}\n\t} else {\n\t\trsp->rsp_flags |= SRP_LOGIN_RSP_MULTICHAN_MAINTAINED;\n\t}\n\n\tlist_add_tail_rcu(&ch->list, &nexus->ch_list);\n\n\tif (!sport->enabled) {\n\t\trej->reason = cpu_to_be32(\n\t\t\t\tSRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);\n\t\tpr_info(\"rejected SRP_LOGIN_REQ because target %s_%d is not enabled\\n\",\n\t\t\tdev_name(&sdev->device->dev), port_num);\n\t\tmutex_unlock(&sport->mutex);\n\t\tret = -EINVAL;\n\t\tgoto reject;\n\t}\n\n\tmutex_unlock(&sport->mutex);\n\n\tret = ch->using_rdma_cm ? 0 : srpt_ch_qp_rtr(ch, ch->qp);\n\tif (ret) {\n\t\trej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);\n\t\tpr_err(\"rejected SRP_LOGIN_REQ because enabling RTR failed (error code = %d)\\n\",\n\t\t       ret);\n\t\tgoto reject;\n\t}\n\n\tpr_debug(\"Establish connection sess=%p name=%s ch=%p\\n\", ch->sess,\n\t\t ch->sess_name, ch);\n\n\t/* create srp_login_response */\n\trsp->opcode = SRP_LOGIN_RSP;\n\trsp->tag = req->tag;\n\trsp->max_it_iu_len = cpu_to_be32(srp_max_req_size);\n\trsp->max_ti_iu_len = req->req_it_iu_len;\n\tch->max_ti_iu_len = it_iu_len;\n\trsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT |\n\t\t\t\t   SRP_BUF_FORMAT_INDIRECT);\n\trsp->req_lim_delta = cpu_to_be32(ch->rq_size);\n\tatomic_set(&ch->req_lim, ch->rq_size);\n\tatomic_set(&ch->req_lim_delta, 0);\n\n\t/* create cm reply */\n\tif (ch->using_rdma_cm) {\n\t\trep_param->rdma_cm.private_data = (void *)rsp;\n\t\trep_param->rdma_cm.private_data_len = sizeof(*rsp);\n\t\trep_param->rdma_cm.rnr_retry_count = 7;\n\t\trep_param->rdma_cm.flow_control = 1;\n\t\trep_param->rdma_cm.responder_resources = 4;\n\t\trep_param->rdma_cm.initiator_depth = 4;\n\t} else {\n\t\trep_param->ib_cm.qp_num = ch->qp->qp_num;\n\t\trep_param->ib_cm.private_data = (void *)rsp;\n\t\trep_param->ib_cm.private_data_len = sizeof(*rsp);\n\t\trep_param->ib_cm.rnr_retry_count = 7;\n\t\trep_param->ib_cm.flow_control = 1;\n\t\trep_param->ib_cm.failover_accepted = 0;\n\t\trep_param->ib_cm.srq = 1;\n\t\trep_param->ib_cm.responder_resources = 4;\n\t\trep_param->ib_cm.initiator_depth = 4;\n\t}\n\n\t/*\n\t * Hold the sport mutex while accepting a connection to avoid that\n\t * srpt_disconnect_ch() is invoked concurrently with this code.\n\t */\n\tmutex_lock(&sport->mutex);\n\tif (sport->enabled && ch->state == CH_CONNECTING) {\n\t\tif (ch->using_rdma_cm)\n\t\t\tret = rdma_accept(rdma_cm_id, &rep_param->rdma_cm);\n\t\telse\n\t\t\tret = ib_send_cm_rep(ib_cm_id, &rep_param->ib_cm);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&sport->mutex);\n\n\tswitch (ret) {\n\tcase 0:\n\t\tbreak;\n\tcase -EINVAL:\n\t\tgoto reject;\n\tdefault:\n\t\trej->reason = cpu_to_be32(SRP_LOGIN_REJ_INSUFFICIENT_RESOURCES);\n\t\tpr_err(\"sending SRP_LOGIN_REQ response failed (error code = %d)\\n\",\n\t\t       ret);\n\t\tgoto reject;\n\t}\n\n\tgoto out;\n\ndestroy_ib:\n\tsrpt_destroy_ch_ib(ch);\n\nfree_recv_ring:\n\tsrpt_free_ioctx_ring((struct srpt_ioctx **)ch->ioctx_recv_ring,\n\t\t\t     ch->sport->sdev, ch->rq_size,\n\t\t\t     ch->req_buf_cache, DMA_FROM_DEVICE);\n\nfree_recv_cache:\n\tkmem_cache_destroy(ch->req_buf_cache);\n\nfree_rsp_ring:\n\tsrpt_free_ioctx_ring((struct srpt_ioctx **)ch->ioctx_ring,\n\t\t\t     ch->sport->sdev, ch->rq_size,\n\t\t\t     ch->rsp_buf_cache, DMA_TO_DEVICE);\n\nfree_rsp_cache:\n\tkmem_cache_destroy(ch->rsp_buf_cache);\n\nfree_ch:\n\tif (rdma_cm_id)\n\t\trdma_cm_id->context = NULL;\n\telse\n\t\tib_cm_id->context = NULL;\n\tkfree(ch);\n\tch = NULL;\n\n\tWARN_ON_ONCE(ret == 0);\n\nreject:\n\tpr_info(\"Rejecting login with reason %#x\\n\", be32_to_cpu(rej->reason));\n\trej->opcode = SRP_LOGIN_REJ;\n\trej->tag = req->tag;\n\trej->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT |\n\t\t\t\t   SRP_BUF_FORMAT_INDIRECT);\n\n\tif (rdma_cm_id)\n\t\trdma_reject(rdma_cm_id, rej, sizeof(*rej),\n\t\t\t    IB_CM_REJ_CONSUMER_DEFINED);\n\telse\n\t\tib_send_cm_rej(ib_cm_id, IB_CM_REJ_CONSUMER_DEFINED, NULL, 0,\n\t\t\t       rej, sizeof(*rej));\n\n\tif (ch && ch->sess) {\n\t\tsrpt_close_ch(ch);\n\t\t/*\n\t\t * Tell the caller not to free cm_id since\n\t\t * srpt_release_channel_work() will do that.\n\t\t */\n\t\tret = 0;\n\t}\n\nout:\n\tkfree(rep_param);\n\tkfree(rsp);\n\tkfree(rej);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "client",
        "function_name": "evdev_pass_values",
        "location": {
            "file_path": "drivers/input/evdev.c",
            "region": {
                "startLine": 253,
                "startColumn": 6,
                "endColumn": 12
            },
            "context": {
                "startLine": 251,
                "endLine": 255,
                "snippet": {
                    "text": "if (client->revoked)"
                }
            }
        },
        "function_code": "static void evdev_pass_values(struct evdev_client *client,\n\t\t\tconst struct input_value *vals, unsigned int count,\n\t\t\tktime_t *ev_time)\n{\n\tconst struct input_value *v;\n\tstruct input_event event;\n\tstruct timespec64 ts;\n\tbool wakeup = false;\n\n\tif (client->revoked)\n\t\treturn;\n\n\tts = ktime_to_timespec64(ev_time[client->clk_type]);\n\tevent.input_event_sec = ts.tv_sec;\n\tevent.input_event_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t/* Interrupts are disabled, just acquire the lock. */\n\tspin_lock(&client->buffer_lock);\n\n\tfor (v = vals; v != vals + count; v++) {\n\t\tif (__evdev_is_filtered(client, v->type, v->code))\n\t\t\tcontinue;\n\n\t\tif (v->type == EV_SYN && v->code == SYN_REPORT) {\n\t\t\t/* drop empty SYN_REPORT */\n\t\t\tif (client->packet_head == client->head)\n\t\t\t\tcontinue;\n\n\t\t\twakeup = true;\n\t\t}\n\n\t\tevent.type = v->type;\n\t\tevent.code = v->code;\n\t\tevent.value = v->value;\n\t\t__pass_event(client, &event);\n\t}\n\n\tspin_unlock(&client->buffer_lock);\n\n\tif (wakeup)\n\t\twake_up_interruptible_poll(&client->wait,\n\t\t\tEPOLLIN | EPOLLOUT | EPOLLRDNORM | EPOLLWRNORM);\n}"
    },
    {
        "var_name": "handle",
        "function_name": "input_to_handler",
        "location": {
            "file_path": "drivers/input/input.c",
            "region": {
                "startLine": 110,
                "startColumn": 34,
                "endColumn": 40
            },
            "context": {
                "startLine": 108,
                "endLine": 112,
                "snippet": {
                    "text": "struct input_handler *handler = handle->handler;"
                }
            }
        },
        "function_code": "static unsigned int input_to_handler(struct input_handle *handle,\n\t\t\tstruct input_value *vals, unsigned int count)\n{\n\tstruct input_handler *handler = handle->handler;\n\tstruct input_value *end = vals;\n\tstruct input_value *v;\n\n\tif (handler->filter) {\n\t\tfor (v = vals; v != vals + count; v++) {\n\t\t\tif (handler->filter(handle, v->type, v->code, v->value))\n\t\t\t\tcontinue;\n\t\t\tif (end != v)\n\t\t\t\t*end = *v;\n\t\t\tend++;\n\t\t}\n\t\tcount = end - vals;\n\t}\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (handler->events)\n\t\thandler->events(handle, vals, count);\n\telse if (handler->event)\n\t\tfor (v = vals; v != vals + count; v++)\n\t\t\thandler->event(handle, v->type, v->code, v->value);\n\n\treturn count;\n}"
    },
    {
        "var_name": "handle",
        "function_name": "input_pass_values",
        "location": {
            "file_path": "drivers/input/input.c",
            "region": {
                "startLine": 160,
                "startColumn": 8,
                "endColumn": 14
            },
            "context": {
                "startLine": 158,
                "endLine": 162,
                "snippet": {
                    "text": "if (handle->open) {"
                }
            }
        },
        "function_code": "static void input_pass_values(struct input_dev *dev,\n\t\t\t      struct input_value *vals, unsigned int count)\n{\n\tstruct input_handle *handle;\n\tstruct input_value *v;\n\n\tlockdep_assert_held(&dev->event_lock);\n\n\tif (!count)\n\t\treturn;\n\n\trcu_read_lock();\n\n\thandle = rcu_dereference(dev->grab);\n\tif (handle) {\n\t\tcount = input_to_handler(handle, vals, count);\n\t} else {\n\t\tlist_for_each_entry_rcu(handle, &dev->h_list, d_node)\n\t\t\tif (handle->open) {\n\t\t\t\tcount = input_to_handler(handle, vals, count);\n\t\t\t\tif (!count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t/* trigger auto repeat for key events */\n\tif (test_bit(EV_REP, dev->evbit) && test_bit(EV_KEY, dev->evbit)) {\n\t\tfor (v = vals; v != vals + count; v++) {\n\t\t\tif (v->type == EV_KEY && v->value != 2) {\n\t\t\t\tif (v->value)\n\t\t\t\t\tinput_start_autorepeat(dev, v->code);\n\t\t\t\telse\n\t\t\t\t\tinput_stop_autorepeat(dev);\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "buf",
        "function_name": "input_print_modalias_parts",
        "location": {
            "file_path": "drivers/input/input.c",
            "region": {
                "startLine": 1395,
                "startColumn": 17,
                "endColumn": 20
            },
            "context": {
                "startLine": 1393,
                "endLine": 1397,
                "snippet": {
                    "text": "len = snprintf(buf, max(size, 0),"
                }
            }
        },
        "function_code": "static int input_print_modalias_parts(char *buf, int size, int full_len,\n\t\t\t\t      const struct input_dev *id)\n{\n\tint len, klen, remainder, space;\n\n\tlen = snprintf(buf, max(size, 0),\n\t\t       \"input:b%04Xv%04Xp%04Xe%04X-\",\n\t\t       id->id.bustype, id->id.vendor,\n\t\t       id->id.product, id->id.version);\n\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'e', id->evbit, 0, EV_MAX);\n\n\t/*\n\t * Calculate the remaining space in the buffer making sure we\n\t * have place for the terminating 0.\n\t */\n\tspace = max(size - (len + 1), 0);\n\n\tklen = input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'k', id->keybit, KEY_MIN_INTERESTING, KEY_MAX);\n\tlen += klen;\n\n\t/*\n\t * If we have more data than we can fit in the buffer, check\n\t * if we can trim key data to fit in the rest. We will indicate\n\t * that key data is incomplete by adding \"+\" sign at the end, like\n\t * this: * \"k1,2,3,45,+,\".\n\t *\n\t * Note that we shortest key info (if present) is \"k+,\" so we\n\t * can only try to trim if key data is longer than that.\n\t */\n\tif (full_len && size < full_len + 1 && klen > 3) {\n\t\tremainder = full_len - len;\n\t\t/*\n\t\t * We can only trim if we have space for the remainder\n\t\t * and also for at least \"k+,\" which is 3 more characters.\n\t\t */\n\t\tif (remainder <= space - 3) {\n\t\t\t/*\n\t\t\t * We are guaranteed to have 'k' in the buffer, so\n\t\t\t * we need at least 3 additional bytes for storing\n\t\t\t * \"+,\" in addition to the remainder.\n\t\t\t */\n\t\t\tfor (int i = size - 1 - remainder - 3; i >= 0; i--) {\n\t\t\t\tif (buf[i] == 'k' || buf[i] == ',') {\n\t\t\t\t\tstrcpy(buf + i + 1, \"+,\");\n\t\t\t\t\tlen = i + 3; /* Not counting '\\0' */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'r', id->relbit, 0, REL_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'a', id->absbit, 0, ABS_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'm', id->mscbit, 0, MSC_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'l', id->ledbit, 0, LED_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t's', id->sndbit, 0, SND_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'f', id->ffbit, 0, FF_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'w', id->swbit, 0, SW_MAX);\n\n\treturn len;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "input_print_modalias_parts",
        "location": {
            "file_path": "drivers/input/input.c",
            "region": {
                "startLine": 1435,
                "startColumn": 9,
                "endColumn": 12
            },
            "context": {
                "startLine": 1433,
                "endLine": 1437,
                "snippet": {
                    "text": "if (buf[i] == 'k' || buf[i] == ',') {"
                }
            }
        },
        "function_code": "static int input_print_modalias_parts(char *buf, int size, int full_len,\n\t\t\t\t      const struct input_dev *id)\n{\n\tint len, klen, remainder, space;\n\n\tlen = snprintf(buf, max(size, 0),\n\t\t       \"input:b%04Xv%04Xp%04Xe%04X-\",\n\t\t       id->id.bustype, id->id.vendor,\n\t\t       id->id.product, id->id.version);\n\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'e', id->evbit, 0, EV_MAX);\n\n\t/*\n\t * Calculate the remaining space in the buffer making sure we\n\t * have place for the terminating 0.\n\t */\n\tspace = max(size - (len + 1), 0);\n\n\tklen = input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'k', id->keybit, KEY_MIN_INTERESTING, KEY_MAX);\n\tlen += klen;\n\n\t/*\n\t * If we have more data than we can fit in the buffer, check\n\t * if we can trim key data to fit in the rest. We will indicate\n\t * that key data is incomplete by adding \"+\" sign at the end, like\n\t * this: * \"k1,2,3,45,+,\".\n\t *\n\t * Note that we shortest key info (if present) is \"k+,\" so we\n\t * can only try to trim if key data is longer than that.\n\t */\n\tif (full_len && size < full_len + 1 && klen > 3) {\n\t\tremainder = full_len - len;\n\t\t/*\n\t\t * We can only trim if we have space for the remainder\n\t\t * and also for at least \"k+,\" which is 3 more characters.\n\t\t */\n\t\tif (remainder <= space - 3) {\n\t\t\t/*\n\t\t\t * We are guaranteed to have 'k' in the buffer, so\n\t\t\t * we need at least 3 additional bytes for storing\n\t\t\t * \"+,\" in addition to the remainder.\n\t\t\t */\n\t\t\tfor (int i = size - 1 - remainder - 3; i >= 0; i--) {\n\t\t\t\tif (buf[i] == 'k' || buf[i] == ',') {\n\t\t\t\t\tstrcpy(buf + i + 1, \"+,\");\n\t\t\t\t\tlen = i + 3; /* Not counting '\\0' */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'r', id->relbit, 0, REL_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'a', id->absbit, 0, ABS_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'm', id->mscbit, 0, MSC_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'l', id->ledbit, 0, LED_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t's', id->sndbit, 0, SND_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'f', id->ffbit, 0, FF_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'w', id->swbit, 0, SW_MAX);\n\n\treturn len;\n}"
    },
    {
        "var_name": "dev",
        "function_name": "hil_dev_interrupt",
        "location": {
            "file_path": "drivers/input/keyboard/hil_kbd.c",
            "region": {
                "startLine": 284,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 282,
                "endLine": 286,
                "snippet": {
                    "text": "if (dev->idx4 >= HIL_PACKET_MAX_LENGTH * sizeof(hil_packet)) {"
                }
            }
        },
        "function_code": "static irqreturn_t hil_dev_interrupt(struct serio *serio,\n\t\t\t\tunsigned char data, unsigned int flags)\n{\n\tstruct hil_dev *dev;\n\thil_packet packet;\n\tint idx;\n\n\tdev = serio_get_drvdata(serio);\n\tBUG_ON(dev == NULL);\n\n\tif (dev->idx4 >= HIL_PACKET_MAX_LENGTH * sizeof(hil_packet)) {\n\t\thil_dev_process_err(dev);\n\t\tgoto out;\n\t}\n\n\tidx = dev->idx4 / 4;\n\tif (!(dev->idx4 % 4))\n\t\tdev->data[idx] = 0;\n\tpacket = dev->data[idx];\n\tpacket |= ((hil_packet)data) << ((3 - (dev->idx4 % 4)) * 8);\n\tdev->data[idx] = packet;\n\n\t/* Records of N 4-byte hil_packets must terminate with a command. */\n\tif ((++dev->idx4 % 4) == 0) {\n\t\tif ((packet & 0xffff0000) != HIL_ERR_INT) {\n\t\t\thil_dev_process_err(dev);\n\t\t} else if (packet & HIL_PKT_CMD) {\n\t\t\tif (hil_dev_is_command_response(packet))\n\t\t\t\thil_dev_handle_command_response(dev);\n\t\t\telse if (dev->is_pointer)\n\t\t\t\thil_dev_handle_ptr_events(dev);\n\t\t\telse\n\t\t\t\thil_dev_handle_kbd_events(dev);\n\t\t\tdev->idx4 = 0;\n\t\t}\n\t}\n out:\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "dev",
        "function_name": "hil_dev_disconnect",
        "location": {
            "file_path": "drivers/input/keyboard/hil_kbd.c",
            "region": {
                "startLine": 321,
                "startColumn": 26,
                "endColumn": 29
            },
            "context": {
                "startLine": 319,
                "endLine": 323,
                "snippet": {
                    "text": "input_unregister_device(dev->dev);"
                }
            }
        },
        "function_code": "static void hil_dev_disconnect(struct serio *serio)\n{\n\tstruct hil_dev *dev = serio_get_drvdata(serio);\n\n\tBUG_ON(dev == NULL);\n\n\tserio_close(serio);\n\tinput_unregister_device(dev->dev);\n\tserio_set_drvdata(serio, NULL);\n\tkfree(dev);\n}"
    },
    {
        "var_name": "map",
        "function_name": "hil_mlc_serio_write",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 817,
                "startColumn": 8,
                "endColumn": 11
            },
            "context": {
                "startLine": 815,
                "endLine": 819,
                "snippet": {
                    "text": "mlc = map->mlc;"
                }
            }
        },
        "function_code": "static int hil_mlc_serio_write(struct serio *serio, unsigned char c)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\tstruct serio_driver *drv;\n\tuint8_t *idx, *last;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tmlc->serio_opacket[map->didx] |=\n\t\t((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\n\n\tif (mlc->serio_oidx[map->didx] >= 3) {\n\t\t/* for now only commands */\n\t\tif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\n\t\t\treturn -EIO;\n\t\tswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\n\t\tcase HIL_CMD_IDD:\n\t\t\tidx = mlc->di[map->didx].idd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RSC:\n\t\t\tidx = mlc->di[map->didx].rsc;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_EXD:\n\t\t\tidx = mlc->di[map->didx].exd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RNM:\n\t\t\tidx = mlc->di[map->didx].rnm;\n\t\t\tgoto emu;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmlc->serio_oidx[map->didx] = 0;\n\t\tmlc->serio_opacket[map->didx] = 0;\n\t}\n\n\tmlc->serio_oidx[map->didx]++;\n\treturn -EIO;\n emu:\n\tdrv = serio->drv;\n\tBUG_ON(drv == NULL);\n\n\tlast = idx + 15;\n\twhile ((last != idx) && (*last == 0))\n\t\tlast--;\n\n\twhile (idx != last) {\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, *idx, 0);\n\t\tidx++;\n\t}\n\tdrv->interrupt(serio, 0, 0);\n\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\tdrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\n\tdrv->interrupt(serio, *idx, 0);\n\n\tmlc->serio_oidx[map->didx] = 0;\n\tmlc->serio_opacket[map->didx] = 0;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "mlc",
        "function_name": "hil_mlc_serio_write",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 820,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 818,
                "endLine": 822,
                "snippet": {
                    "text": "mlc->serio_opacket[map->didx] |="
                }
            }
        },
        "function_code": "static int hil_mlc_serio_write(struct serio *serio, unsigned char c)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\tstruct serio_driver *drv;\n\tuint8_t *idx, *last;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tmlc->serio_opacket[map->didx] |=\n\t\t((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\n\n\tif (mlc->serio_oidx[map->didx] >= 3) {\n\t\t/* for now only commands */\n\t\tif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\n\t\t\treturn -EIO;\n\t\tswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\n\t\tcase HIL_CMD_IDD:\n\t\t\tidx = mlc->di[map->didx].idd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RSC:\n\t\t\tidx = mlc->di[map->didx].rsc;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_EXD:\n\t\t\tidx = mlc->di[map->didx].exd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RNM:\n\t\t\tidx = mlc->di[map->didx].rnm;\n\t\t\tgoto emu;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmlc->serio_oidx[map->didx] = 0;\n\t\tmlc->serio_opacket[map->didx] = 0;\n\t}\n\n\tmlc->serio_oidx[map->didx]++;\n\treturn -EIO;\n emu:\n\tdrv = serio->drv;\n\tBUG_ON(drv == NULL);\n\n\tlast = idx + 15;\n\twhile ((last != idx) && (*last == 0))\n\t\tlast--;\n\n\twhile (idx != last) {\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, *idx, 0);\n\t\tidx++;\n\t}\n\tdrv->interrupt(serio, 0, 0);\n\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\tdrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\n\tdrv->interrupt(serio, *idx, 0);\n\n\tmlc->serio_oidx[map->didx] = 0;\n\tmlc->serio_opacket[map->didx] = 0;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "map",
        "function_name": "hil_mlc_serio_write",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 820,
                "startColumn": 21,
                "endColumn": 24
            },
            "context": {
                "startLine": 818,
                "endLine": 822,
                "snippet": {
                    "text": "mlc->serio_opacket[map->didx] |="
                }
            }
        },
        "function_code": "static int hil_mlc_serio_write(struct serio *serio, unsigned char c)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\tstruct serio_driver *drv;\n\tuint8_t *idx, *last;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tmlc->serio_opacket[map->didx] |=\n\t\t((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\n\n\tif (mlc->serio_oidx[map->didx] >= 3) {\n\t\t/* for now only commands */\n\t\tif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\n\t\t\treturn -EIO;\n\t\tswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\n\t\tcase HIL_CMD_IDD:\n\t\t\tidx = mlc->di[map->didx].idd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RSC:\n\t\t\tidx = mlc->di[map->didx].rsc;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_EXD:\n\t\t\tidx = mlc->di[map->didx].exd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RNM:\n\t\t\tidx = mlc->di[map->didx].rnm;\n\t\t\tgoto emu;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmlc->serio_oidx[map->didx] = 0;\n\t\tmlc->serio_opacket[map->didx] = 0;\n\t}\n\n\tmlc->serio_oidx[map->didx]++;\n\treturn -EIO;\n emu:\n\tdrv = serio->drv;\n\tBUG_ON(drv == NULL);\n\n\tlast = idx + 15;\n\twhile ((last != idx) && (*last == 0))\n\t\tlast--;\n\n\twhile (idx != last) {\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, *idx, 0);\n\t\tidx++;\n\t}\n\tdrv->interrupt(serio, 0, 0);\n\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\tdrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\n\tdrv->interrupt(serio, *idx, 0);\n\n\tmlc->serio_oidx[map->didx] = 0;\n\tmlc->serio_opacket[map->didx] = 0;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "mlc",
        "function_name": "hil_mlc_serio_write",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 821,
                "startColumn": 32,
                "endColumn": 35
            },
            "context": {
                "startLine": 819,
                "endLine": 823,
                "snippet": {
                    "text": "((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));"
                }
            }
        },
        "function_code": "static int hil_mlc_serio_write(struct serio *serio, unsigned char c)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\tstruct serio_driver *drv;\n\tuint8_t *idx, *last;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tmlc->serio_opacket[map->didx] |=\n\t\t((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\n\n\tif (mlc->serio_oidx[map->didx] >= 3) {\n\t\t/* for now only commands */\n\t\tif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\n\t\t\treturn -EIO;\n\t\tswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\n\t\tcase HIL_CMD_IDD:\n\t\t\tidx = mlc->di[map->didx].idd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RSC:\n\t\t\tidx = mlc->di[map->didx].rsc;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_EXD:\n\t\t\tidx = mlc->di[map->didx].exd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RNM:\n\t\t\tidx = mlc->di[map->didx].rnm;\n\t\t\tgoto emu;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmlc->serio_oidx[map->didx] = 0;\n\t\tmlc->serio_opacket[map->didx] = 0;\n\t}\n\n\tmlc->serio_oidx[map->didx]++;\n\treturn -EIO;\n emu:\n\tdrv = serio->drv;\n\tBUG_ON(drv == NULL);\n\n\tlast = idx + 15;\n\twhile ((last != idx) && (*last == 0))\n\t\tlast--;\n\n\twhile (idx != last) {\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, *idx, 0);\n\t\tidx++;\n\t}\n\tdrv->interrupt(serio, 0, 0);\n\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\tdrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\n\tdrv->interrupt(serio, *idx, 0);\n\n\tmlc->serio_oidx[map->didx] = 0;\n\tmlc->serio_opacket[map->didx] = 0;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "map",
        "function_name": "hil_mlc_serio_write",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 821,
                "startColumn": 48,
                "endColumn": 51
            },
            "context": {
                "startLine": 819,
                "endLine": 823,
                "snippet": {
                    "text": "((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));"
                }
            }
        },
        "function_code": "static int hil_mlc_serio_write(struct serio *serio, unsigned char c)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\tstruct serio_driver *drv;\n\tuint8_t *idx, *last;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tmlc->serio_opacket[map->didx] |=\n\t\t((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\n\n\tif (mlc->serio_oidx[map->didx] >= 3) {\n\t\t/* for now only commands */\n\t\tif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\n\t\t\treturn -EIO;\n\t\tswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\n\t\tcase HIL_CMD_IDD:\n\t\t\tidx = mlc->di[map->didx].idd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RSC:\n\t\t\tidx = mlc->di[map->didx].rsc;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_EXD:\n\t\t\tidx = mlc->di[map->didx].exd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RNM:\n\t\t\tidx = mlc->di[map->didx].rnm;\n\t\t\tgoto emu;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmlc->serio_oidx[map->didx] = 0;\n\t\tmlc->serio_opacket[map->didx] = 0;\n\t}\n\n\tmlc->serio_oidx[map->didx]++;\n\treturn -EIO;\n emu:\n\tdrv = serio->drv;\n\tBUG_ON(drv == NULL);\n\n\tlast = idx + 15;\n\twhile ((last != idx) && (*last == 0))\n\t\tlast--;\n\n\twhile (idx != last) {\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, *idx, 0);\n\t\tidx++;\n\t}\n\tdrv->interrupt(serio, 0, 0);\n\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\tdrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\n\tdrv->interrupt(serio, *idx, 0);\n\n\tmlc->serio_oidx[map->didx] = 0;\n\tmlc->serio_opacket[map->didx] = 0;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "mlc",
        "function_name": "hil_mlc_serio_write",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 823,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 821,
                "endLine": 825,
                "snippet": {
                    "text": "if (mlc->serio_oidx[map->didx] >= 3) {"
                }
            }
        },
        "function_code": "static int hil_mlc_serio_write(struct serio *serio, unsigned char c)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\tstruct serio_driver *drv;\n\tuint8_t *idx, *last;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tmlc->serio_opacket[map->didx] |=\n\t\t((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\n\n\tif (mlc->serio_oidx[map->didx] >= 3) {\n\t\t/* for now only commands */\n\t\tif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\n\t\t\treturn -EIO;\n\t\tswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\n\t\tcase HIL_CMD_IDD:\n\t\t\tidx = mlc->di[map->didx].idd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RSC:\n\t\t\tidx = mlc->di[map->didx].rsc;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_EXD:\n\t\t\tidx = mlc->di[map->didx].exd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RNM:\n\t\t\tidx = mlc->di[map->didx].rnm;\n\t\t\tgoto emu;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmlc->serio_oidx[map->didx] = 0;\n\t\tmlc->serio_opacket[map->didx] = 0;\n\t}\n\n\tmlc->serio_oidx[map->didx]++;\n\treturn -EIO;\n emu:\n\tdrv = serio->drv;\n\tBUG_ON(drv == NULL);\n\n\tlast = idx + 15;\n\twhile ((last != idx) && (*last == 0))\n\t\tlast--;\n\n\twhile (idx != last) {\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, *idx, 0);\n\t\tidx++;\n\t}\n\tdrv->interrupt(serio, 0, 0);\n\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\tdrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\n\tdrv->interrupt(serio, *idx, 0);\n\n\tmlc->serio_oidx[map->didx] = 0;\n\tmlc->serio_opacket[map->didx] = 0;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "map",
        "function_name": "hil_mlc_serio_write",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 823,
                "startColumn": 22,
                "endColumn": 25
            },
            "context": {
                "startLine": 821,
                "endLine": 825,
                "snippet": {
                    "text": "if (mlc->serio_oidx[map->didx] >= 3) {"
                }
            }
        },
        "function_code": "static int hil_mlc_serio_write(struct serio *serio, unsigned char c)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\tstruct serio_driver *drv;\n\tuint8_t *idx, *last;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tmlc->serio_opacket[map->didx] |=\n\t\t((hil_packet)c) << (8 * (3 - mlc->serio_oidx[map->didx]));\n\n\tif (mlc->serio_oidx[map->didx] >= 3) {\n\t\t/* for now only commands */\n\t\tif (!(mlc->serio_opacket[map->didx] & HIL_PKT_CMD))\n\t\t\treturn -EIO;\n\t\tswitch (mlc->serio_opacket[map->didx] & HIL_PKT_DATA_MASK) {\n\t\tcase HIL_CMD_IDD:\n\t\t\tidx = mlc->di[map->didx].idd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RSC:\n\t\t\tidx = mlc->di[map->didx].rsc;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_EXD:\n\t\t\tidx = mlc->di[map->didx].exd;\n\t\t\tgoto emu;\n\t\tcase HIL_CMD_RNM:\n\t\t\tidx = mlc->di[map->didx].rnm;\n\t\t\tgoto emu;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tmlc->serio_oidx[map->didx] = 0;\n\t\tmlc->serio_opacket[map->didx] = 0;\n\t}\n\n\tmlc->serio_oidx[map->didx]++;\n\treturn -EIO;\n emu:\n\tdrv = serio->drv;\n\tBUG_ON(drv == NULL);\n\n\tlast = idx + 15;\n\twhile ((last != idx) && (*last == 0))\n\t\tlast--;\n\n\twhile (idx != last) {\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\t\tdrv->interrupt(serio, 0, 0);\n\t\tdrv->interrupt(serio, *idx, 0);\n\t\tidx++;\n\t}\n\tdrv->interrupt(serio, 0, 0);\n\tdrv->interrupt(serio, HIL_ERR_INT >> 16, 0);\n\tdrv->interrupt(serio, HIL_PKT_CMD >> 8, 0);\n\tdrv->interrupt(serio, *idx, 0);\n\n\tmlc->serio_oidx[map->didx] = 0;\n\tmlc->serio_opacket[map->didx] = 0;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "map",
        "function_name": "hil_mlc_serio_open",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 886,
                "startColumn": 8,
                "endColumn": 11
            },
            "context": {
                "startLine": 884,
                "endLine": 888,
                "snippet": {
                    "text": "mlc = map->mlc;"
                }
            }
        },
        "function_code": "static int hil_mlc_serio_open(struct serio *serio)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\n\tif (serio_get_drvdata(serio) != NULL)\n\t\treturn -EBUSY;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "map",
        "function_name": "hil_mlc_serio_close",
        "location": {
            "file_path": "drivers/input/serio/hil_mlc.c",
            "region": {
                "startLine": 900,
                "startColumn": 8,
                "endColumn": 11
            },
            "context": {
                "startLine": 898,
                "endLine": 902,
                "snippet": {
                    "text": "mlc = map->mlc;"
                }
            }
        },
        "function_code": "static void hil_mlc_serio_close(struct serio *serio)\n{\n\tstruct hil_mlc_serio_map *map;\n\tstruct hil_mlc *mlc;\n\n\tmap = serio->port_data;\n\tBUG_ON(map == NULL);\n\n\tmlc = map->mlc;\n\tBUG_ON(mlc == NULL);\n\n\tserio_set_drvdata(serio, NULL);\n\tserio->drv = NULL;\n\t/* TODO wake up interruptable */\n}"
    },
    {
        "var_name": "param",
        "function_name": "__ps2_command",
        "location": {
            "file_path": "drivers/input/serio/libps2.c",
            "region": {
                "startLine": 284,
                "startColumn": 21,
                "endColumn": 26
            },
            "context": {
                "startLine": 282,
                "endLine": 286,
                "snippet": {
                    "text": "memcpy(send_param, param, send);"
                }
            }
        },
        "function_code": "int __ps2_command(struct ps2dev *ps2dev, u8 *param, unsigned int command)\n{\n\tunsigned int timeout;\n\tunsigned int send = (command >> 12) & 0xf;\n\tunsigned int receive = (command >> 8) & 0xf;\n\tint rc;\n\tint i;\n\tu8 send_param[16];\n\n\tif (receive > sizeof(ps2dev->cmdbuf)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (send && !param) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(send_param, param, send);\n\n\tserio_pause_rx(ps2dev->serio);\n\n\tps2dev->cmdcnt = receive;\n\n\tswitch (command) {\n\tcase PS2_CMD_GETID:\n\t\t/*\n\t\t * Some mice do not ACK the \"get ID\" command, prepare to\n\t\t * handle this.\n\t\t */\n\t\tps2dev->flags = PS2_FLAG_WAITID;\n\t\tbreak;\n\n\tcase PS2_CMD_SETLEDS:\n\tcase PS2_CMD_EX_SETLEDS:\n\tcase PS2_CMD_SETREP:\n\t\tps2dev->flags = PS2_FLAG_PASS_NOACK;\n\t\tbreak;\n\n\tdefault:\n\t\tps2dev->flags = 0;\n\t\tbreak;\n\t}\n\n\tif (receive) {\n\t\t/* Indicate that we expect response to the command. */\n\t\tps2dev->flags |= PS2_FLAG_CMD | PS2_FLAG_CMD1;\n\t\tif (param)\n\t\t\tfor (i = 0; i < receive; i++)\n\t\t\t\tps2dev->cmdbuf[(receive - 1) - i] = param[i];\n\t}\n\n\t/*\n\t * Some devices (Synaptics) perform the reset before\n\t * ACKing the reset command, and so it can take a long\n\t * time before the ACK arrives.\n\t */\n\ttimeout = command == PS2_CMD_RESET_BAT ? 1000 : 200;\n\n\trc = ps2_do_sendbyte(ps2dev, command & 0xff, timeout, 2);\n\tif (rc)\n\t\tgoto out_reset_flags;\n\n\t/* Send command parameters, if any. */\n\tfor (i = 0; i < send; i++) {\n\t\trc = ps2_do_sendbyte(ps2dev, param[i], 200, 2);\n\t\tif (rc)\n\t\t\tgoto out_reset_flags;\n\t}\n\n\tserio_continue_rx(ps2dev->serio);\n\n\t/*\n\t * The reset command takes a long time to execute.\n\t */\n\ttimeout = msecs_to_jiffies(command == PS2_CMD_RESET_BAT ? 4000 : 500);\n\n\ttimeout = wait_event_timeout(ps2dev->wait,\n\t\t\t\t     !(ps2dev->flags & PS2_FLAG_CMD1), timeout);\n\n\tif (ps2dev->cmdcnt && !(ps2dev->flags & PS2_FLAG_CMD1)) {\n\n\t\ttimeout = ps2_adjust_timeout(ps2dev, command, timeout);\n\t\twait_event_timeout(ps2dev->wait,\n\t\t\t\t   !(ps2dev->flags & PS2_FLAG_CMD), timeout);\n\t}\n\n\tserio_pause_rx(ps2dev->serio);\n\n\tif (param) {\n\t\tfor (i = 0; i < receive; i++)\n\t\t\tparam[i] = ps2dev->cmdbuf[(receive - 1) - i];\n\t\tkmsan_unpoison_memory(param, receive);\n\t}\n\n\tif (ps2dev->cmdcnt &&\n\t    (command != PS2_CMD_RESET_BAT || ps2dev->cmdcnt != 1)) {\n\t\trc = -EPROTO;\n\t\tgoto out_reset_flags;\n\t}\n\n\trc = 0;\n\n out_reset_flags:\n\tps2dev->flags = 0;\n\tserio_continue_rx(ps2dev->serio);\n\n\tdev_dbg(&ps2dev->serio->dev,\n\t\t\"%02x [%*ph] - %x/%08lx [%*ph]\\n\",\n\t\tcommand & 0xff, send, send_param,\n\t\tps2dev->nak, ps2dev->flags,\n\t\treceive, param ?: send_param);\n\n\t/*\n\t * ps_command() handles resends itself, so do not leak -EAGAIN\n\t * to the callers.\n\t */\n\treturn rc != -EAGAIN ? rc : -EPROTO;\n}"
    },
    {
        "var_name": "pci_seg",
        "function_name": "get_dev_table",
        "location": {
            "file_path": "drivers/iommu/amd/iommu.c",
            "region": {
                "startLine": 130,
                "startColumn": 14,
                "endColumn": 21
            },
            "context": {
                "startLine": 128,
                "endLine": 132,
                "snippet": {
                    "text": "dev_table = pci_seg->dev_table;"
                }
            }
        },
        "function_code": "struct dev_table_entry *get_dev_table(struct amd_iommu *iommu)\n{\n\tstruct dev_table_entry *dev_table;\n\tstruct amd_iommu_pci_seg *pci_seg = iommu->pci_seg;\n\n\tBUG_ON(pci_seg == NULL);\n\tdev_table = pci_seg->dev_table;\n\tBUG_ON(dev_table == NULL);\n\n\treturn dev_table;\n}"
    },
    {
        "var_name": "irq_data",
        "function_name": "irq_remapping_alloc",
        "location": {
            "file_path": "drivers/iommu/amd/iommu.c",
            "region": {
                "startLine": 3433,
                "startColumn": 3,
                "endColumn": 11
            },
            "context": {
                "startLine": 3431,
                "endLine": 3435,
                "snippet": {
                    "text": "irq_data->hwirq = (devid << 16) + i;"
                }
            }
        },
        "function_code": "static int irq_remapping_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t       unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct irq_data *irq_data;\n\tstruct amd_ir_data *data = NULL;\n\tstruct amd_iommu *iommu;\n\tstruct irq_cfg *cfg;\n\tint i, ret, devid, seg, sbdf;\n\tint index;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\tif (nr_irqs > 1 && info->type != X86_IRQ_ALLOC_TYPE_PCI_MSI)\n\t\treturn -EINVAL;\n\n\tsbdf = get_devid(info);\n\tif (sbdf < 0)\n\t\treturn -EINVAL;\n\n\tseg = PCI_SBDF_TO_SEGID(sbdf);\n\tdevid = PCI_SBDF_TO_DEVID(sbdf);\n\tiommu = __rlookup_amd_iommu(seg, devid);\n\tif (!iommu)\n\t\treturn -EINVAL;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (info->type == X86_IRQ_ALLOC_TYPE_IOAPIC) {\n\t\tstruct irq_remap_table *table;\n\n\t\ttable = alloc_irq_table(iommu, devid, NULL);\n\t\tif (table) {\n\t\t\tif (!table->min_index) {\n\t\t\t\t/*\n\t\t\t\t * Keep the first 32 indexes free for IOAPIC\n\t\t\t\t * interrupts.\n\t\t\t\t */\n\t\t\t\ttable->min_index = 32;\n\t\t\t\tfor (i = 0; i < 32; ++i)\n\t\t\t\t\tiommu->irte_ops->set_allocated(table, i);\n\t\t\t}\n\t\t\tWARN_ON(table->min_index != 32);\n\t\t\tindex = info->ioapic.pin;\n\t\t} else {\n\t\t\tindex = -ENOMEM;\n\t\t}\n\t} else if (info->type == X86_IRQ_ALLOC_TYPE_PCI_MSI ||\n\t\t   info->type == X86_IRQ_ALLOC_TYPE_PCI_MSIX) {\n\t\tbool align = (info->type == X86_IRQ_ALLOC_TYPE_PCI_MSI);\n\n\t\tindex = alloc_irq_index(iommu, devid, nr_irqs, align,\n\t\t\t\t\tmsi_desc_to_pci_dev(info->desc));\n\t} else {\n\t\tindex = alloc_irq_index(iommu, devid, nr_irqs, false, NULL);\n\t}\n\n\tif (index < 0) {\n\t\tpr_warn(\"Failed to allocate IRTE\\n\");\n\t\tret = index;\n\t\tgoto out_free_parent;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tcfg = irq_data ? irqd_cfg(irq_data) : NULL;\n\t\tif (!cfg) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (!data)\n\t\t\tgoto out_free_data;\n\n\t\tif (!AMD_IOMMU_GUEST_IR_GA(amd_iommu_guest_ir))\n\t\t\tdata->entry = kzalloc(sizeof(union irte), GFP_KERNEL);\n\t\telse\n\t\t\tdata->entry = kzalloc(sizeof(struct irte_ga),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!data->entry) {\n\t\t\tkfree(data);\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tdata->iommu = iommu;\n\t\tirq_data->hwirq = (devid << 16) + i;\n\t\tirq_data->chip_data = data;\n\t\tirq_data->chip = &amd_ir_chip;\n\t\tirq_remapping_prepare_irte(data, cfg, info, devid, index, i);\n\t\tirq_set_status_flags(virq + i, IRQ_MOVE_PCNTXT);\n\t}\n\n\treturn 0;\n\nout_free_data:\n\tfor (i--; i >= 0; i--) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tkfree(irq_data->chip_data);\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tfree_irte(iommu, devid, index + i);\nout_free_parent:\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n\treturn ret;\n}"
    },
    {
        "var_name": "irq_data",
        "function_name": "irq_remapping_alloc",
        "location": {
            "file_path": "drivers/iommu/amd/iommu.c",
            "region": {
                "startLine": 3434,
                "startColumn": 3,
                "endColumn": 11
            },
            "context": {
                "startLine": 3432,
                "endLine": 3436,
                "snippet": {
                    "text": "irq_data->chip_data = data;"
                }
            }
        },
        "function_code": "static int irq_remapping_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t       unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct irq_data *irq_data;\n\tstruct amd_ir_data *data = NULL;\n\tstruct amd_iommu *iommu;\n\tstruct irq_cfg *cfg;\n\tint i, ret, devid, seg, sbdf;\n\tint index;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\tif (nr_irqs > 1 && info->type != X86_IRQ_ALLOC_TYPE_PCI_MSI)\n\t\treturn -EINVAL;\n\n\tsbdf = get_devid(info);\n\tif (sbdf < 0)\n\t\treturn -EINVAL;\n\n\tseg = PCI_SBDF_TO_SEGID(sbdf);\n\tdevid = PCI_SBDF_TO_DEVID(sbdf);\n\tiommu = __rlookup_amd_iommu(seg, devid);\n\tif (!iommu)\n\t\treturn -EINVAL;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (info->type == X86_IRQ_ALLOC_TYPE_IOAPIC) {\n\t\tstruct irq_remap_table *table;\n\n\t\ttable = alloc_irq_table(iommu, devid, NULL);\n\t\tif (table) {\n\t\t\tif (!table->min_index) {\n\t\t\t\t/*\n\t\t\t\t * Keep the first 32 indexes free for IOAPIC\n\t\t\t\t * interrupts.\n\t\t\t\t */\n\t\t\t\ttable->min_index = 32;\n\t\t\t\tfor (i = 0; i < 32; ++i)\n\t\t\t\t\tiommu->irte_ops->set_allocated(table, i);\n\t\t\t}\n\t\t\tWARN_ON(table->min_index != 32);\n\t\t\tindex = info->ioapic.pin;\n\t\t} else {\n\t\t\tindex = -ENOMEM;\n\t\t}\n\t} else if (info->type == X86_IRQ_ALLOC_TYPE_PCI_MSI ||\n\t\t   info->type == X86_IRQ_ALLOC_TYPE_PCI_MSIX) {\n\t\tbool align = (info->type == X86_IRQ_ALLOC_TYPE_PCI_MSI);\n\n\t\tindex = alloc_irq_index(iommu, devid, nr_irqs, align,\n\t\t\t\t\tmsi_desc_to_pci_dev(info->desc));\n\t} else {\n\t\tindex = alloc_irq_index(iommu, devid, nr_irqs, false, NULL);\n\t}\n\n\tif (index < 0) {\n\t\tpr_warn(\"Failed to allocate IRTE\\n\");\n\t\tret = index;\n\t\tgoto out_free_parent;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tcfg = irq_data ? irqd_cfg(irq_data) : NULL;\n\t\tif (!cfg) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (!data)\n\t\t\tgoto out_free_data;\n\n\t\tif (!AMD_IOMMU_GUEST_IR_GA(amd_iommu_guest_ir))\n\t\t\tdata->entry = kzalloc(sizeof(union irte), GFP_KERNEL);\n\t\telse\n\t\t\tdata->entry = kzalloc(sizeof(struct irte_ga),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!data->entry) {\n\t\t\tkfree(data);\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tdata->iommu = iommu;\n\t\tirq_data->hwirq = (devid << 16) + i;\n\t\tirq_data->chip_data = data;\n\t\tirq_data->chip = &amd_ir_chip;\n\t\tirq_remapping_prepare_irte(data, cfg, info, devid, index, i);\n\t\tirq_set_status_flags(virq + i, IRQ_MOVE_PCNTXT);\n\t}\n\n\treturn 0;\n\nout_free_data:\n\tfor (i--; i >= 0; i--) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tkfree(irq_data->chip_data);\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tfree_irte(iommu, devid, index + i);\nout_free_parent:\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n\treturn ret;\n}"
    },
    {
        "var_name": "irq_data",
        "function_name": "irq_remapping_alloc",
        "location": {
            "file_path": "drivers/iommu/amd/iommu.c",
            "region": {
                "startLine": 3435,
                "startColumn": 3,
                "endColumn": 11
            },
            "context": {
                "startLine": 3433,
                "endLine": 3437,
                "snippet": {
                    "text": "irq_data->chip = &amd_ir_chip;"
                }
            }
        },
        "function_code": "static int irq_remapping_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t       unsigned int nr_irqs, void *arg)\n{\n\tstruct irq_alloc_info *info = arg;\n\tstruct irq_data *irq_data;\n\tstruct amd_ir_data *data = NULL;\n\tstruct amd_iommu *iommu;\n\tstruct irq_cfg *cfg;\n\tint i, ret, devid, seg, sbdf;\n\tint index;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\tif (nr_irqs > 1 && info->type != X86_IRQ_ALLOC_TYPE_PCI_MSI)\n\t\treturn -EINVAL;\n\n\tsbdf = get_devid(info);\n\tif (sbdf < 0)\n\t\treturn -EINVAL;\n\n\tseg = PCI_SBDF_TO_SEGID(sbdf);\n\tdevid = PCI_SBDF_TO_DEVID(sbdf);\n\tiommu = __rlookup_amd_iommu(seg, devid);\n\tif (!iommu)\n\t\treturn -EINVAL;\n\n\tret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, arg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (info->type == X86_IRQ_ALLOC_TYPE_IOAPIC) {\n\t\tstruct irq_remap_table *table;\n\n\t\ttable = alloc_irq_table(iommu, devid, NULL);\n\t\tif (table) {\n\t\t\tif (!table->min_index) {\n\t\t\t\t/*\n\t\t\t\t * Keep the first 32 indexes free for IOAPIC\n\t\t\t\t * interrupts.\n\t\t\t\t */\n\t\t\t\ttable->min_index = 32;\n\t\t\t\tfor (i = 0; i < 32; ++i)\n\t\t\t\t\tiommu->irte_ops->set_allocated(table, i);\n\t\t\t}\n\t\t\tWARN_ON(table->min_index != 32);\n\t\t\tindex = info->ioapic.pin;\n\t\t} else {\n\t\t\tindex = -ENOMEM;\n\t\t}\n\t} else if (info->type == X86_IRQ_ALLOC_TYPE_PCI_MSI ||\n\t\t   info->type == X86_IRQ_ALLOC_TYPE_PCI_MSIX) {\n\t\tbool align = (info->type == X86_IRQ_ALLOC_TYPE_PCI_MSI);\n\n\t\tindex = alloc_irq_index(iommu, devid, nr_irqs, align,\n\t\t\t\t\tmsi_desc_to_pci_dev(info->desc));\n\t} else {\n\t\tindex = alloc_irq_index(iommu, devid, nr_irqs, false, NULL);\n\t}\n\n\tif (index < 0) {\n\t\tpr_warn(\"Failed to allocate IRTE\\n\");\n\t\tret = index;\n\t\tgoto out_free_parent;\n\t}\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tcfg = irq_data ? irqd_cfg(irq_data) : NULL;\n\t\tif (!cfg) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (!data)\n\t\t\tgoto out_free_data;\n\n\t\tif (!AMD_IOMMU_GUEST_IR_GA(amd_iommu_guest_ir))\n\t\t\tdata->entry = kzalloc(sizeof(union irte), GFP_KERNEL);\n\t\telse\n\t\t\tdata->entry = kzalloc(sizeof(struct irte_ga),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!data->entry) {\n\t\t\tkfree(data);\n\t\t\tgoto out_free_data;\n\t\t}\n\n\t\tdata->iommu = iommu;\n\t\tirq_data->hwirq = (devid << 16) + i;\n\t\tirq_data->chip_data = data;\n\t\tirq_data->chip = &amd_ir_chip;\n\t\tirq_remapping_prepare_irte(data, cfg, info, devid, index, i);\n\t\tirq_set_status_flags(virq + i, IRQ_MOVE_PCNTXT);\n\t}\n\n\treturn 0;\n\nout_free_data:\n\tfor (i--; i >= 0; i--) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tkfree(irq_data->chip_data);\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tfree_irte(iommu, devid, index + i);\nout_free_parent:\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n\treturn ret;\n}"
    },
    {
        "var_name": "pdev",
        "function_name": "has_external_pci",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 3548,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 3546,
                "endLine": 3550,
                "snippet": {
                    "text": "if (pdev->external_facing) {"
                }
            }
        },
        "function_code": "static bool has_external_pci(void)\n{\n\tstruct pci_dev *pdev = NULL;\n\n\tfor_each_pci_dev(pdev)\n\t\tif (pdev->external_facing) {\n\t\t\tpci_dev_put(pdev);\n\t\t\treturn true;\n\t\t}\n\n\treturn false;\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_disable_protect_mem_regions",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1594,
                "startColumn": 7,
                "endColumn": 12
            },
            "context": {
                "startLine": 1592,
                "endLine": 1596,
                "snippet": {
                    "text": "if (!cap_plmr(iommu->cap) && !cap_phmr(iommu->cap))"
                }
            }
        },
        "function_code": "static void iommu_disable_protect_mem_regions(struct intel_iommu *iommu)\n{\n\tu32 pmen;\n\tunsigned long flags;\n\n\tif (!cap_plmr(iommu->cap) && !cap_phmr(iommu->cap))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tpmen = readl(iommu->reg + DMAR_PMEN_REG);\n\tpmen &= ~DMA_PMEN_EPM;\n\twritel(pmen, iommu->reg + DMAR_PMEN_REG);\n\n\t/* wait for the protected region status bit to clear */\n\tIOMMU_WAIT_OP(iommu, DMAR_PMEN_REG,\n\t\treadl, !(pmen & DMA_PMEN_PRS), pmen);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_set_root_entry",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1139,
                "startColumn": 22,
                "endColumn": 27
            },
            "context": {
                "startLine": 1137,
                "endLine": 1141,
                "snippet": {
                    "text": "addr = virt_to_phys(iommu->root_entry);"
                }
            }
        },
        "function_code": "static void iommu_set_root_entry(struct intel_iommu *iommu)\n{\n\tu64 addr;\n\tu32 sts;\n\tunsigned long flag;\n\n\taddr = virt_to_phys(iommu->root_entry);\n\tif (sm_supported(iommu))\n\t\taddr |= DMA_RTADDR_SMT;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flag);\n\tdmar_writeq(iommu->reg + DMAR_RTADDR_REG, addr);\n\n\twritel(iommu->gcmd | DMA_GCMD_SRTP, iommu->reg + DMAR_GCMD_REG);\n\n\t/* Make sure hardware complete it */\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_RTPS), sts);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flag);\n\n\t/*\n\t * Hardware invalidates all DMA remapping hardware translation\n\t * caches as part of SRTP flow.\n\t */\n\tif (cap_esrtps(iommu->cap))\n\t\treturn;\n\n\tiommu->flush.flush_context(iommu, 0, 0, 0, DMA_CCMD_GLOBAL_INVL);\n\tif (sm_supported(iommu))\n\t\tqi_flush_pasid_cache(iommu, 0, QI_PC_GLOBAL, 0);\n\tiommu->flush.flush_iotlb(iommu, 0, 0, 0, DMA_TLB_GLOBAL_FLUSH);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_set_root_entry",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1144,
                "startColumn": 2,
                "endColumn": 7
            },
            "context": {
                "startLine": 1142,
                "endLine": 1146,
                "snippet": {
                    "text": "dmar_writeq(iommu->reg + DMAR_RTADDR_REG, addr);"
                }
            }
        },
        "function_code": "static void iommu_set_root_entry(struct intel_iommu *iommu)\n{\n\tu64 addr;\n\tu32 sts;\n\tunsigned long flag;\n\n\taddr = virt_to_phys(iommu->root_entry);\n\tif (sm_supported(iommu))\n\t\taddr |= DMA_RTADDR_SMT;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flag);\n\tdmar_writeq(iommu->reg + DMAR_RTADDR_REG, addr);\n\n\twritel(iommu->gcmd | DMA_GCMD_SRTP, iommu->reg + DMAR_GCMD_REG);\n\n\t/* Make sure hardware complete it */\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_RTPS), sts);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flag);\n\n\t/*\n\t * Hardware invalidates all DMA remapping hardware translation\n\t * caches as part of SRTP flow.\n\t */\n\tif (cap_esrtps(iommu->cap))\n\t\treturn;\n\n\tiommu->flush.flush_context(iommu, 0, 0, 0, DMA_CCMD_GLOBAL_INVL);\n\tif (sm_supported(iommu))\n\t\tqi_flush_pasid_cache(iommu, 0, QI_PC_GLOBAL, 0);\n\tiommu->flush.flush_iotlb(iommu, 0, 0, 0, DMA_TLB_GLOBAL_FLUSH);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_set_root_entry",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1146,
                "startColumn": 9,
                "endColumn": 14
            },
            "context": {
                "startLine": 1144,
                "endLine": 1148,
                "snippet": {
                    "text": "writel(iommu->gcmd | DMA_GCMD_SRTP, iommu->reg + DMAR_GCMD_REG);"
                }
            }
        },
        "function_code": "static void iommu_set_root_entry(struct intel_iommu *iommu)\n{\n\tu64 addr;\n\tu32 sts;\n\tunsigned long flag;\n\n\taddr = virt_to_phys(iommu->root_entry);\n\tif (sm_supported(iommu))\n\t\taddr |= DMA_RTADDR_SMT;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flag);\n\tdmar_writeq(iommu->reg + DMAR_RTADDR_REG, addr);\n\n\twritel(iommu->gcmd | DMA_GCMD_SRTP, iommu->reg + DMAR_GCMD_REG);\n\n\t/* Make sure hardware complete it */\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_RTPS), sts);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flag);\n\n\t/*\n\t * Hardware invalidates all DMA remapping hardware translation\n\t * caches as part of SRTP flow.\n\t */\n\tif (cap_esrtps(iommu->cap))\n\t\treturn;\n\n\tiommu->flush.flush_context(iommu, 0, 0, 0, DMA_CCMD_GLOBAL_INVL);\n\tif (sm_supported(iommu))\n\t\tqi_flush_pasid_cache(iommu, 0, QI_PC_GLOBAL, 0);\n\tiommu->flush.flush_iotlb(iommu, 0, 0, 0, DMA_TLB_GLOBAL_FLUSH);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_set_root_entry",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1149,
                "startColumn": 2,
                "endColumn": 7
            },
            "context": {
                "startLine": 1147,
                "endLine": 1151,
                "snippet": {
                    "text": "IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,"
                }
            }
        },
        "function_code": "static void iommu_set_root_entry(struct intel_iommu *iommu)\n{\n\tu64 addr;\n\tu32 sts;\n\tunsigned long flag;\n\n\taddr = virt_to_phys(iommu->root_entry);\n\tif (sm_supported(iommu))\n\t\taddr |= DMA_RTADDR_SMT;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flag);\n\tdmar_writeq(iommu->reg + DMAR_RTADDR_REG, addr);\n\n\twritel(iommu->gcmd | DMA_GCMD_SRTP, iommu->reg + DMAR_GCMD_REG);\n\n\t/* Make sure hardware complete it */\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_RTPS), sts);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flag);\n\n\t/*\n\t * Hardware invalidates all DMA remapping hardware translation\n\t * caches as part of SRTP flow.\n\t */\n\tif (cap_esrtps(iommu->cap))\n\t\treturn;\n\n\tiommu->flush.flush_context(iommu, 0, 0, 0, DMA_CCMD_GLOBAL_INVL);\n\tif (sm_supported(iommu))\n\t\tqi_flush_pasid_cache(iommu, 0, QI_PC_GLOBAL, 0);\n\tiommu->flush.flush_iotlb(iommu, 0, 0, 0, DMA_TLB_GLOBAL_FLUSH);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_disable_protect_mem_regions",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1594,
                "startColumn": 7,
                "endColumn": 12
            },
            "context": {
                "startLine": 1592,
                "endLine": 1596,
                "snippet": {
                    "text": "if (!cap_plmr(iommu->cap) && !cap_phmr(iommu->cap))"
                }
            }
        },
        "function_code": "static void iommu_disable_protect_mem_regions(struct intel_iommu *iommu)\n{\n\tu32 pmen;\n\tunsigned long flags;\n\n\tif (!cap_plmr(iommu->cap) && !cap_phmr(iommu->cap))\n\t\treturn;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tpmen = readl(iommu->reg + DMAR_PMEN_REG);\n\tpmen &= ~DMA_PMEN_EPM;\n\twritel(pmen, iommu->reg + DMAR_PMEN_REG);\n\n\t/* wait for the protected region status bit to clear */\n\tIOMMU_WAIT_OP(iommu, DMAR_PMEN_REG,\n\t\treadl, !(pmen & DMA_PMEN_PRS), pmen);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_enable_translation",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1615,
                "startColumn": 2,
                "endColumn": 7
            },
            "context": {
                "startLine": 1613,
                "endLine": 1617,
                "snippet": {
                    "text": "iommu->gcmd |= DMA_GCMD_TE;"
                }
            }
        },
        "function_code": "static void iommu_enable_translation(struct intel_iommu *iommu)\n{\n\tu32 sts;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tiommu->gcmd |= DMA_GCMD_TE;\n\twritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\n\n\t/* Make sure hardware complete it */\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_TES), sts);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_enable_translation",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1616,
                "startColumn": 9,
                "endColumn": 14
            },
            "context": {
                "startLine": 1614,
                "endLine": 1618,
                "snippet": {
                    "text": "writel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);"
                }
            }
        },
        "function_code": "static void iommu_enable_translation(struct intel_iommu *iommu)\n{\n\tu32 sts;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tiommu->gcmd |= DMA_GCMD_TE;\n\twritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\n\n\t/* Make sure hardware complete it */\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_TES), sts);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "iommu_enable_translation",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 1619,
                "startColumn": 2,
                "endColumn": 7
            },
            "context": {
                "startLine": 1617,
                "endLine": 1621,
                "snippet": {
                    "text": "IOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,"
                }
            }
        },
        "function_code": "static void iommu_enable_translation(struct intel_iommu *iommu)\n{\n\tu32 sts;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tiommu->gcmd |= DMA_GCMD_TE;\n\twritel(iommu->gcmd, iommu->reg + DMAR_GCMD_REG);\n\n\t/* Make sure hardware complete it */\n\tIOMMU_WAIT_OP(iommu, DMAR_GSTS_REG,\n\t\t      readl, (sts & DMA_GSTS_TES), sts);\n\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "init_iommu_hw",
        "location": {
            "file_path": "drivers/iommu/intel/iommu.c",
            "region": {
                "startLine": 2807,
                "startColumn": 7,
                "endColumn": 12
            },
            "context": {
                "startLine": 2805,
                "endLine": 2809,
                "snippet": {
                    "text": "if (iommu->qi) {"
                }
            }
        },
        "function_code": "static int init_iommu_hw(void)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu = NULL;\n\tint ret;\n\n\tfor_each_active_iommu(iommu, drhd) {\n\t\tif (iommu->qi) {\n\t\t\tret = dmar_reenable_qi(iommu);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor_each_iommu(iommu, drhd) {\n\t\tif (drhd->ignored) {\n\t\t\t/*\n\t\t\t * we always have to disable PMRs or DMA may fail on\n\t\t\t * this device\n\t\t\t */\n\t\t\tif (force_on)\n\t\t\t\tiommu_disable_protect_mem_regions(iommu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tiommu_flush_write_buffer(iommu);\n\t\tiommu_set_root_entry(iommu);\n\t\tiommu_enable_translation(iommu);\n\t\tiommu_disable_protect_mem_regions(iommu);\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "disable_irq_remapping",
        "location": {
            "file_path": "drivers/iommu/intel/irq_remapping.c",
            "region": {
                "startLine": 1035,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 1033,
                "endLine": 1037,
                "snippet": {
                    "text": "if (!ecap_ir_support(iommu->ecap))"
                }
            }
        },
        "function_code": "static void disable_irq_remapping(void)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tstruct intel_iommu *iommu = NULL;\n\n\t/*\n\t * Disable Interrupt-remapping for all the DRHD's now.\n\t */\n\tfor_each_iommu(iommu, drhd) {\n\t\tif (!ecap_ir_support(iommu->ecap))\n\t\t\tcontinue;\n\n\t\tiommu_disable_irq_remapping(iommu);\n\t}\n\n\t/*\n\t * Clear Posted-Interrupts capability.\n\t */\n\tif (!disable_irq_post)\n\t\tintel_irq_remap_ops.capability &= ~(1 << IRQ_POSTING_CAP);\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "reenable_irq_remapping",
        "location": {
            "file_path": "drivers/iommu/intel/irq_remapping.c",
            "region": {
                "startLine": 1055,
                "startColumn": 7,
                "endColumn": 12
            },
            "context": {
                "startLine": 1053,
                "endLine": 1057,
                "snippet": {
                    "text": "if (iommu->qi)"
                }
            }
        },
        "function_code": "static int reenable_irq_remapping(int eim)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tbool setup = false;\n\tstruct intel_iommu *iommu = NULL;\n\n\tfor_each_iommu(iommu, drhd)\n\t\tif (iommu->qi)\n\t\t\tdmar_reenable_qi(iommu);\n\n\t/*\n\t * Setup Interrupt-remapping for all the DRHD's now.\n\t */\n\tfor_each_iommu(iommu, drhd) {\n\t\tif (!ecap_ir_support(iommu->ecap))\n\t\t\tcontinue;\n\n\t\t/* Set up interrupt remapping for iommu.*/\n\t\tiommu_set_irq_remapping(iommu, eim);\n\t\tiommu_enable_irq_remapping(iommu);\n\t\tsetup = true;\n\t}\n\n\tif (!setup)\n\t\tgoto error;\n\n\tset_irq_posting_cap();\n\n\treturn 0;\n\nerror:\n\t/*\n\t * handle error condition gracefully here!\n\t */\n\treturn -1;\n}"
    },
    {
        "var_name": "iommu",
        "function_name": "reenable_irq_remapping",
        "location": {
            "file_path": "drivers/iommu/intel/irq_remapping.c",
            "region": {
                "startLine": 1062,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 1060,
                "endLine": 1064,
                "snippet": {
                    "text": "if (!ecap_ir_support(iommu->ecap))"
                }
            }
        },
        "function_code": "static int reenable_irq_remapping(int eim)\n{\n\tstruct dmar_drhd_unit *drhd;\n\tbool setup = false;\n\tstruct intel_iommu *iommu = NULL;\n\n\tfor_each_iommu(iommu, drhd)\n\t\tif (iommu->qi)\n\t\t\tdmar_reenable_qi(iommu);\n\n\t/*\n\t * Setup Interrupt-remapping for all the DRHD's now.\n\t */\n\tfor_each_iommu(iommu, drhd) {\n\t\tif (!ecap_ir_support(iommu->ecap))\n\t\t\tcontinue;\n\n\t\t/* Set up interrupt remapping for iommu.*/\n\t\tiommu_set_irq_remapping(iommu, eim);\n\t\tiommu_enable_irq_remapping(iommu);\n\t\tsetup = true;\n\t}\n\n\tif (!setup)\n\t\tgoto error;\n\n\tset_irq_posting_cap();\n\n\treturn 0;\n\nerror:\n\t/*\n\t * handle error condition gracefully here!\n\t */\n\treturn -1;\n}"
    },
    {
        "var_name": "sdev",
        "function_name": "sprd_iommu_write",
        "location": {
            "file_path": "drivers/iommu/sprd-iommu.c",
            "region": {
                "startLine": 94,
                "startColumn": 22,
                "endColumn": 26
            },
            "context": {
                "startLine": 92,
                "endLine": 96,
                "snippet": {
                    "text": "writel_relaxed(val, sdev->base + reg);"
                }
            }
        },
        "function_code": "static inline void\nsprd_iommu_write(struct sprd_iommu_device *sdev, unsigned int reg, u32 val)\n{\n\twritel_relaxed(val, sdev->base + reg);\n}"
    },
    {
        "var_name": "sdev",
        "function_name": "sprd_iommu_read",
        "location": {
            "file_path": "drivers/iommu/sprd-iommu.c",
            "region": {
                "startLine": 100,
                "startColumn": 23,
                "endColumn": 27
            },
            "context": {
                "startLine": 98,
                "endLine": 102,
                "snippet": {
                    "text": "return readl_relaxed(sdev->base + reg);"
                }
            }
        },
        "function_code": "static inline u32\nsprd_iommu_read(struct sprd_iommu_device *sdev, unsigned int reg)\n{\n\treturn readl_relaxed(sdev->base + reg);\n}"
    },
    {
        "var_name": "sdev",
        "function_name": "sprd_iommu_hw_en",
        "location": {
            "file_path": "drivers/iommu/sprd-iommu.c",
            "region": {
                "startLine": 215,
                "startColumn": 6,
                "endColumn": 10
            },
            "context": {
                "startLine": 213,
                "endLine": 217,
                "snippet": {
                    "text": "if (sdev->ver == SPRD_IOMMU_EX)"
                }
            }
        },
        "function_code": "static void sprd_iommu_hw_en(struct sprd_iommu_device *sdev, bool en)\n{\n\tunsigned int reg_cfg;\n\tu32 mask, val;\n\n\tif (sdev->ver == SPRD_IOMMU_EX)\n\t\treg_cfg = SPRD_EX_CFG;\n\telse\n\t\treg_cfg = SPRD_VAU_CFG;\n\n\tmask = SPRD_IOMMU_EN | SPRD_IOMMU_GATE_EN;\n\tval = en ? mask : 0;\n\tsprd_iommu_update_bits(sdev, reg_cfg, mask, 0, val);\n}"
    },
    {
        "var_name": "vm",
        "function_name": "its_vpe_irq_domain_alloc",
        "location": {
            "file_path": "drivers/irqchip/irq-gic-v3-its.c",
            "region": {
                "startLine": 4527,
                "startColumn": 2,
                "endColumn": 4
            },
            "context": {
                "startLine": 4525,
                "endLine": 4529,
                "snippet": {
                    "text": "vm->db_bitmap = bitmap;"
                }
            }
        },
        "function_code": "static int its_vpe_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t    unsigned int nr_irqs, void *args)\n{\n\tstruct irq_chip *irqchip = &its_vpe_irq_chip;\n\tstruct its_vm *vm = args;\n\tunsigned long *bitmap;\n\tstruct page *vprop_page;\n\tint base, nr_ids, i, err = 0;\n\n\tBUG_ON(!vm);\n\n\tbitmap = its_lpi_alloc(roundup_pow_of_two(nr_irqs), &base, &nr_ids);\n\tif (!bitmap)\n\t\treturn -ENOMEM;\n\n\tif (nr_ids < nr_irqs) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvprop_page = its_allocate_prop_table(GFP_KERNEL);\n\tif (!vprop_page) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvm->db_bitmap = bitmap;\n\tvm->db_lpi_base = base;\n\tvm->nr_db_lpis = nr_ids;\n\tvm->vprop_page = vprop_page;\n\n\tif (gic_rdists->has_rvpeid)\n\t\tirqchip = &its_vpe_4_1_irq_chip;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tvm->vpes[i]->vpe_db_lpi = base + i;\n\t\terr = its_vpe_init(vm->vpes[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = its_irq_gic_domain_alloc(domain, virq + i,\n\t\t\t\t\t       vm->vpes[i]->vpe_db_lpi);\n\t\tif (err)\n\t\t\tbreak;\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, i,\n\t\t\t\t\t      irqchip, vm->vpes[i]);\n\t\tset_bit(i, bitmap);\n\t\tirqd_set_resend_when_in_progress(irq_get_irq_data(virq + i));\n\t}\n\n\tif (err)\n\t\tits_vpe_irq_domain_free(domain, virq, i);\n\n\treturn err;\n}"
    },
    {
        "var_name": "vm",
        "function_name": "its_vpe_irq_domain_alloc",
        "location": {
            "file_path": "drivers/irqchip/irq-gic-v3-its.c",
            "region": {
                "startLine": 4528,
                "startColumn": 2,
                "endColumn": 4
            },
            "context": {
                "startLine": 4526,
                "endLine": 4530,
                "snippet": {
                    "text": "vm->db_lpi_base = base;"
                }
            }
        },
        "function_code": "static int its_vpe_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t    unsigned int nr_irqs, void *args)\n{\n\tstruct irq_chip *irqchip = &its_vpe_irq_chip;\n\tstruct its_vm *vm = args;\n\tunsigned long *bitmap;\n\tstruct page *vprop_page;\n\tint base, nr_ids, i, err = 0;\n\n\tBUG_ON(!vm);\n\n\tbitmap = its_lpi_alloc(roundup_pow_of_two(nr_irqs), &base, &nr_ids);\n\tif (!bitmap)\n\t\treturn -ENOMEM;\n\n\tif (nr_ids < nr_irqs) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvprop_page = its_allocate_prop_table(GFP_KERNEL);\n\tif (!vprop_page) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvm->db_bitmap = bitmap;\n\tvm->db_lpi_base = base;\n\tvm->nr_db_lpis = nr_ids;\n\tvm->vprop_page = vprop_page;\n\n\tif (gic_rdists->has_rvpeid)\n\t\tirqchip = &its_vpe_4_1_irq_chip;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tvm->vpes[i]->vpe_db_lpi = base + i;\n\t\terr = its_vpe_init(vm->vpes[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = its_irq_gic_domain_alloc(domain, virq + i,\n\t\t\t\t\t       vm->vpes[i]->vpe_db_lpi);\n\t\tif (err)\n\t\t\tbreak;\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, i,\n\t\t\t\t\t      irqchip, vm->vpes[i]);\n\t\tset_bit(i, bitmap);\n\t\tirqd_set_resend_when_in_progress(irq_get_irq_data(virq + i));\n\t}\n\n\tif (err)\n\t\tits_vpe_irq_domain_free(domain, virq, i);\n\n\treturn err;\n}"
    },
    {
        "var_name": "vm",
        "function_name": "its_vpe_irq_domain_alloc",
        "location": {
            "file_path": "drivers/irqchip/irq-gic-v3-its.c",
            "region": {
                "startLine": 4529,
                "startColumn": 2,
                "endColumn": 4
            },
            "context": {
                "startLine": 4527,
                "endLine": 4531,
                "snippet": {
                    "text": "vm->nr_db_lpis = nr_ids;"
                }
            }
        },
        "function_code": "static int its_vpe_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t    unsigned int nr_irqs, void *args)\n{\n\tstruct irq_chip *irqchip = &its_vpe_irq_chip;\n\tstruct its_vm *vm = args;\n\tunsigned long *bitmap;\n\tstruct page *vprop_page;\n\tint base, nr_ids, i, err = 0;\n\n\tBUG_ON(!vm);\n\n\tbitmap = its_lpi_alloc(roundup_pow_of_two(nr_irqs), &base, &nr_ids);\n\tif (!bitmap)\n\t\treturn -ENOMEM;\n\n\tif (nr_ids < nr_irqs) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvprop_page = its_allocate_prop_table(GFP_KERNEL);\n\tif (!vprop_page) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvm->db_bitmap = bitmap;\n\tvm->db_lpi_base = base;\n\tvm->nr_db_lpis = nr_ids;\n\tvm->vprop_page = vprop_page;\n\n\tif (gic_rdists->has_rvpeid)\n\t\tirqchip = &its_vpe_4_1_irq_chip;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tvm->vpes[i]->vpe_db_lpi = base + i;\n\t\terr = its_vpe_init(vm->vpes[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = its_irq_gic_domain_alloc(domain, virq + i,\n\t\t\t\t\t       vm->vpes[i]->vpe_db_lpi);\n\t\tif (err)\n\t\t\tbreak;\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, i,\n\t\t\t\t\t      irqchip, vm->vpes[i]);\n\t\tset_bit(i, bitmap);\n\t\tirqd_set_resend_when_in_progress(irq_get_irq_data(virq + i));\n\t}\n\n\tif (err)\n\t\tits_vpe_irq_domain_free(domain, virq, i);\n\n\treturn err;\n}"
    },
    {
        "var_name": "vm",
        "function_name": "its_vpe_irq_domain_alloc",
        "location": {
            "file_path": "drivers/irqchip/irq-gic-v3-its.c",
            "region": {
                "startLine": 4530,
                "startColumn": 2,
                "endColumn": 4
            },
            "context": {
                "startLine": 4528,
                "endLine": 4532,
                "snippet": {
                    "text": "vm->vprop_page = vprop_page;"
                }
            }
        },
        "function_code": "static int its_vpe_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t    unsigned int nr_irqs, void *args)\n{\n\tstruct irq_chip *irqchip = &its_vpe_irq_chip;\n\tstruct its_vm *vm = args;\n\tunsigned long *bitmap;\n\tstruct page *vprop_page;\n\tint base, nr_ids, i, err = 0;\n\n\tBUG_ON(!vm);\n\n\tbitmap = its_lpi_alloc(roundup_pow_of_two(nr_irqs), &base, &nr_ids);\n\tif (!bitmap)\n\t\treturn -ENOMEM;\n\n\tif (nr_ids < nr_irqs) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvprop_page = its_allocate_prop_table(GFP_KERNEL);\n\tif (!vprop_page) {\n\t\tits_lpi_free(bitmap, base, nr_ids);\n\t\treturn -ENOMEM;\n\t}\n\n\tvm->db_bitmap = bitmap;\n\tvm->db_lpi_base = base;\n\tvm->nr_db_lpis = nr_ids;\n\tvm->vprop_page = vprop_page;\n\n\tif (gic_rdists->has_rvpeid)\n\t\tirqchip = &its_vpe_4_1_irq_chip;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tvm->vpes[i]->vpe_db_lpi = base + i;\n\t\terr = its_vpe_init(vm->vpes[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t\terr = its_irq_gic_domain_alloc(domain, virq + i,\n\t\t\t\t\t       vm->vpes[i]->vpe_db_lpi);\n\t\tif (err)\n\t\t\tbreak;\n\t\tirq_domain_set_hwirq_and_chip(domain, virq + i, i,\n\t\t\t\t\t      irqchip, vm->vpes[i]);\n\t\tset_bit(i, bitmap);\n\t\tirqd_set_resend_when_in_progress(irq_get_irq_data(virq + i));\n\t}\n\n\tif (err)\n\t\tits_vpe_irq_domain_free(domain, virq, i);\n\n\treturn err;\n}"
    },
    {
        "var_name": "dch",
        "function_name": "hfcmulti_rx",
        "location": {
            "file_path": "drivers/isdn/hardware/mISDN/hfcmulti.c",
            "region": {
                "startLine": 2228,
                "startColumn": 12,
                "endColumn": 15
            },
            "context": {
                "startLine": 2226,
                "endLine": 2230,
                "snippet": {
                    "text": "maxlen = dch->maxlen + 3;"
                }
            }
        },
        "function_code": "static void\nhfcmulti_rx(struct hfc_multi *hc, int ch)\n{\n\tint temp;\n\tint Zsize, z1, z2 = 0; /* = 0, to make GCC happy */\n\tint f1 = 0, f2 = 0; /* = 0, to make GCC happy */\n\tint again = 0;\n\tstruct\tbchannel *bch;\n\tstruct  dchannel *dch = NULL;\n\tstruct sk_buff\t*skb, **sp = NULL;\n\tint\tmaxlen;\n\n\tbch = hc->chan[ch].bch;\n\tif (bch) {\n\t\tif (!test_bit(FLG_ACTIVE, &bch->Flags))\n\t\t\treturn;\n\t} else if (hc->chan[ch].dch) {\n\t\tdch = hc->chan[ch].dch;\n\t\tif (!test_bit(FLG_ACTIVE, &dch->Flags))\n\t\t\treturn;\n\t} else {\n\t\treturn;\n\t}\nnext_frame:\n\t/* on first AND before getting next valid frame, R_FIFO must be written\n\t   to. */\n\tif (test_bit(HFC_CHIP_B410P, &hc->chip) &&\n\t    (hc->chan[ch].protocol == ISDN_P_B_RAW) &&\n\t    (hc->chan[ch].slot_rx < 0) &&\n\t    (hc->chan[ch].slot_tx < 0))\n\t\tHFC_outb_nodebug(hc, R_FIFO, 0x20 | (ch << 1) | 1);\n\telse\n\t\tHFC_outb_nodebug(hc, R_FIFO, (ch << 1) | 1);\n\tHFC_wait_nodebug(hc);\n\n\t/* ignore if rx is off BUT change fifo (above) to start pending TX */\n\tif (hc->chan[ch].rx_off) {\n\t\tif (bch)\n\t\t\tbch->dropcnt += poll; /* not exact but fair enough */\n\t\treturn;\n\t}\n\n\tif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\n\t\tf1 = HFC_inb_nodebug(hc, A_F1);\n\t\twhile (f1 != (temp = HFC_inb_nodebug(hc, A_F1))) {\n\t\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s(card %d): reread f1 because %d!=%d\\n\",\n\t\t\t\t       __func__, hc->id + 1, temp, f1);\n\t\t\tf1 = temp; /* repeat until F1 is equal */\n\t\t}\n\t\tf2 = HFC_inb_nodebug(hc, A_F2);\n\t}\n\tz1 = HFC_inw_nodebug(hc, A_Z1) - hc->Zmin;\n\twhile (z1 != (temp = (HFC_inw_nodebug(hc, A_Z1) - hc->Zmin))) {\n\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\tprintk(KERN_DEBUG \"%s(card %d): reread z2 because \"\n\t\t\t       \"%d!=%d\\n\", __func__, hc->id + 1, temp, z2);\n\t\tz1 = temp; /* repeat until Z1 is equal */\n\t}\n\tz2 = HFC_inw_nodebug(hc, A_Z2) - hc->Zmin;\n\tZsize = z1 - z2;\n\tif ((dch || test_bit(FLG_HDLC, &bch->Flags)) && f1 != f2)\n\t\t/* complete hdlc frame */\n\t\tZsize++;\n\tif (Zsize < 0)\n\t\tZsize += hc->Zlen;\n\t/* if buffer is empty */\n\tif (Zsize <= 0)\n\t\treturn;\n\n\tif (bch) {\n\t\tmaxlen = bchannel_get_rxbuf(bch, Zsize);\n\t\tif (maxlen < 0) {\n\t\t\tpr_warn(\"card%d.B%d: No bufferspace for %d bytes\\n\",\n\t\t\t\thc->id + 1, bch->nr, Zsize);\n\t\t\treturn;\n\t\t}\n\t\tsp = &bch->rx_skb;\n\t\tmaxlen = bch->maxlen;\n\t} else { /* Dchannel */\n\t\tsp = &dch->rx_skb;\n\t\tmaxlen = dch->maxlen + 3;\n\t\tif (*sp == NULL) {\n\t\t\t*sp = mI_alloc_skb(maxlen, GFP_ATOMIC);\n\t\t\tif (*sp == NULL) {\n\t\t\t\tpr_warn(\"card%d: No mem for dch rx_skb\\n\",\n\t\t\t\t\thc->id + 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t/* show activity */\n\tif (dch)\n\t\thc->activity_rx |= 1 << hc->chan[ch].port;\n\n\t/* empty fifo with what we have */\n\tif (dch || test_bit(FLG_HDLC, &bch->Flags)) {\n\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\tprintk(KERN_DEBUG \"%s(card %d): fifo(%d) reading %d \"\n\t\t\t       \"bytes (z1=%04x, z2=%04x) HDLC %s (f1=%d, f2=%d) \"\n\t\t\t       \"got=%d (again %d)\\n\", __func__, hc->id + 1, ch,\n\t\t\t       Zsize, z1, z2, (f1 == f2) ? \"fragment\" : \"COMPLETE\",\n\t\t\t       f1, f2, Zsize + (*sp)->len, again);\n\t\t/* HDLC */\n\t\tif ((Zsize + (*sp)->len) > maxlen) {\n\t\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t       \"%s(card %d): hdlc-frame too large.\\n\",\n\t\t\t\t       __func__, hc->id + 1);\n\t\t\tskb_trim(*sp, 0);\n\t\t\tHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_RES_F);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t\treturn;\n\t\t}\n\n\t\thc->read_fifo(hc, skb_put(*sp, Zsize), Zsize);\n\n\t\tif (f1 != f2) {\n\t\t\t/* increment Z2,F2-counter */\n\t\t\tHFC_outb_nodebug(hc, R_INC_RES_FIFO, V_INC_F);\n\t\t\tHFC_wait_nodebug(hc);\n\t\t\t/* check size */\n\t\t\tif ((*sp)->len < 4) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s(card %d): Frame below minimum \"\n\t\t\t\t\t       \"size\\n\", __func__, hc->id + 1);\n\t\t\t\tskb_trim(*sp, 0);\n\t\t\t\tgoto next_frame;\n\t\t\t}\n\t\t\t/* there is at least one complete frame, check crc */\n\t\t\tif ((*sp)->data[(*sp)->len - 1]) {\n\t\t\t\tif (debug & DEBUG_HFCMULTI_CRC)\n\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t       \"%s: CRC-error\\n\", __func__);\n\t\t\t\tskb_trim(*sp, 0);\n\t\t\t\tgoto next_frame;\n\t\t\t}\n\t\t\tskb_trim(*sp, (*sp)->len - 3);\n\t\t\tif ((*sp)->len < MISDN_COPY_SIZE) {\n\t\t\t\tskb = *sp;\n\t\t\t\t*sp = mI_alloc_skb(skb->len, GFP_ATOMIC);\n\t\t\t\tif (*sp) {\n\t\t\t\t\tskb_put_data(*sp, skb->data, skb->len);\n\t\t\t\t\tskb_trim(skb, 0);\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: No mem\\n\",\n\t\t\t\t\t       __func__);\n\t\t\t\t\t*sp = skb;\n\t\t\t\t\tskb = NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t\tif (debug & DEBUG_HFCMULTI_FIFO) {\n\t\t\t\tprintk(KERN_DEBUG \"%s(card %d):\",\n\t\t\t\t       __func__, hc->id + 1);\n\t\t\t\ttemp = 0;\n\t\t\t\twhile (temp < (*sp)->len)\n\t\t\t\t\tprintk(\" %02x\", (*sp)->data[temp++]);\n\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n\t\t\tif (dch)\n\t\t\t\trecv_Dchannel(dch);\n\t\t\telse\n\t\t\t\trecv_Bchannel(bch, MISDN_ID_ANY, false);\n\t\t\t*sp = skb;\n\t\t\tagain++;\n\t\t\tgoto next_frame;\n\t\t}\n\t\t/* there is an incomplete frame */\n\t} else {\n\t\t/* transparent */\n\t\thc->read_fifo(hc, skb_put(*sp, Zsize), Zsize);\n\t\tif (debug & DEBUG_HFCMULTI_FIFO)\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       \"%s(card %d): fifo(%d) reading %d bytes \"\n\t\t\t       \"(z1=%04x, z2=%04x) TRANS\\n\",\n\t\t\t       __func__, hc->id + 1, ch, Zsize, z1, z2);\n\t\t/* only bch is transparent */\n\t\trecv_Bchannel(bch, hc->chan[ch].Zfill, false);\n\t}\n}"
    },
    {
        "var_name": "buf",
        "function_name": "pattern_trig_store_patterns_int",
        "location": {
            "file_path": "drivers/leds/trigger/ledtrig-pattern.c",
            "region": {
                "startLine": 253,
                "startColumn": 48,
                "endColumn": 51
            },
            "context": {
                "startLine": 251,
                "endLine": 255,
                "snippet": {
                    "text": "data->patterns[data->npatterns].brightness = buf[i];"
                }
            }
        },
        "function_code": "static int pattern_trig_store_patterns_int(struct pattern_trig_data *data,\n\t\t\t\t\t   const u32 *buf, size_t count)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i += 2) {\n\t\tdata->patterns[data->npatterns].brightness = buf[i];\n\t\tdata->patterns[data->npatterns].delta_t = buf[i + 1];\n\t\tdata->npatterns++;\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "pattern_trig_store_patterns_int",
        "location": {
            "file_path": "drivers/leds/trigger/ledtrig-pattern.c",
            "region": {
                "startLine": 254,
                "startColumn": 45,
                "endColumn": 48
            },
            "context": {
                "startLine": 252,
                "endLine": 256,
                "snippet": {
                    "text": "data->patterns[data->npatterns].delta_t = buf[i + 1];"
                }
            }
        },
        "function_code": "static int pattern_trig_store_patterns_int(struct pattern_trig_data *data,\n\t\t\t\t\t   const u32 *buf, size_t count)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < count; i += 2) {\n\t\tdata->patterns[data->npatterns].brightness = buf[i];\n\t\tdata->patterns[data->npatterns].delta_t = buf[i + 1];\n\t\tdata->npatterns++;\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "pm121_cpu_state",
        "function_name": "pm121_tick",
        "location": {
            "file_path": "drivers/macintosh/windfarm_pm121.c",
            "region": {
                "startLine": 812,
                "startColumn": 32,
                "endColumn": 47
            },
            "context": {
                "startLine": 810,
                "endLine": 814,
                "snippet": {
                    "text": "average_power = total_power / pm121_cpu_state->pid.param.history_len;"
                }
            }
        },
        "function_code": "static void pm121_tick(void)\n{\n\tunsigned int last_failure = pm121_failure_state;\n\tunsigned int new_failure;\n\ts32 total_power;\n\tint i;\n\n\tif (!pm121_started) {\n\t\tpr_debug(\"pm121: creating control loops !\\n\");\n\t\tfor (i = 0; i < N_LOOPS; i++)\n\t\t\tpm121_create_sys_fans(i);\n\n\t\tpm121_create_cpu_fans();\n\t\tpm121_started = true;\n\t}\n\n\t/* skipping ticks */\n\tif (pm121_skipping && --pm121_skipping)\n\t\treturn;\n\n\t/* compute average power */\n\ttotal_power = 0;\n\tfor (i = 0; i < pm121_cpu_state->pid.param.history_len; i++)\n\t\ttotal_power += pm121_cpu_state->pid.powers[i];\n\n\taverage_power = total_power / pm121_cpu_state->pid.param.history_len;\n\n\n\tpm121_failure_state = 0;\n\tfor (i = 0 ; i < N_LOOPS; i++) {\n\t\tif (pm121_sys_state[i])\n\t\t\tpm121_sys_fans_tick(i);\n\t}\n\n\tif (pm121_cpu_state)\n\t\tpm121_cpu_fans_tick(pm121_cpu_state);\n\n\tpm121_readjust = 0;\n\tnew_failure = pm121_failure_state & ~last_failure;\n\n\t/* If entering failure mode, clamp cpufreq and ramp all\n\t * fans to full speed.\n\t */\n\tif (pm121_failure_state && !last_failure) {\n\t\tfor (i = 0; i < N_CONTROLS; i++) {\n\t\t\tif (controls[i])\n\t\t\t\twf_control_set_max(controls[i]);\n\t\t}\n\t}\n\n\t/* If leaving failure mode, unclamp cpufreq and readjust\n\t * all fans on next iteration\n\t */\n\tif (!pm121_failure_state && last_failure) {\n\t\tif (controls[CPUFREQ])\n\t\t\twf_control_set_min(controls[CPUFREQ]);\n\t\tpm121_readjust = 1;\n\t}\n\n\t/* Overtemp condition detected, notify and start skipping a couple\n\t * ticks to let the temperature go down\n\t */\n\tif (new_failure & FAILURE_OVERTEMP) {\n\t\twf_set_overtemp();\n\t\tpm121_skipping = 2;\n\t\tpm121_overtemp = true;\n\t}\n\n\t/* We only clear the overtemp condition if overtemp is cleared\n\t * _and_ no other failure is present. Since a sensor error will\n\t * clear the overtemp condition (can't measure temperature) at\n\t * the control loop levels, but we don't want to keep it clear\n\t * here in this case\n\t */\n\tif (!pm121_failure_state && pm121_overtemp) {\n\t\twf_clear_overtemp();\n\t\tpm121_overtemp = false;\n\t}\n}"
    },
    {
        "var_name": "e",
        "function_name": "queue_promotion",
        "location": {
            "file_path": "drivers/md/dm-cache-policy-smq.c",
            "region": {
                "startLine": 1266,
                "startColumn": 2,
                "endColumn": 3
            },
            "context": {
                "startLine": 1264,
                "endLine": 1268,
                "snippet": {
                    "text": "e->pending_work = true;"
                }
            }
        },
        "function_code": "static void queue_promotion(struct smq_policy *mq, dm_oblock_t oblock,\n\t\t\t    struct policy_work **workp)\n{\n\tint r;\n\tstruct entry *e;\n\tstruct policy_work work;\n\n\tif (!mq->migrations_allowed)\n\t\treturn;\n\n\tif (allocator_empty(&mq->cache_alloc)) {\n\t\t/*\n\t\t * We always claim to be 'idle' to ensure some demotions happen\n\t\t * with continuous loads.\n\t\t */\n\t\tif (!free_target_met(mq))\n\t\t\tqueue_demotion(mq);\n\t\treturn;\n\t}\n\n\tif (btracker_promotion_already_present(mq->bg_work, oblock))\n\t\treturn;\n\n\t/*\n\t * We allocate the entry now to reserve the cblock.  If the\n\t * background work is aborted we must remember to free it.\n\t */\n\te = alloc_entry(&mq->cache_alloc);\n\tBUG_ON(!e);\n\te->pending_work = true;\n\twork.op = POLICY_PROMOTE;\n\twork.oblock = oblock;\n\twork.cblock = infer_cblock(mq, e);\n\tr = btracker_queue(mq->bg_work, &work, workp);\n\tif (r)\n\t\tfree_entry(&mq->cache_alloc, e);\n}"
    },
    {
        "var_name": "fe",
        "function_name": "userspace_mark_region",
        "location": {
            "file_path": "drivers/md/dm-log-userspace-base.c",
            "region": {
                "startLine": 658,
                "startColumn": 2,
                "endColumn": 4
            },
            "context": {
                "startLine": 656,
                "endLine": 660,
                "snippet": {
                    "text": "fe->type = DM_ULOG_MARK_REGION;"
                }
            }
        },
        "function_code": "static void userspace_mark_region(struct dm_dirty_log *log, region_t region)\n{\n\tunsigned long flags;\n\tstruct log_c *lc = log->context;\n\tstruct dm_dirty_log_flush_entry *fe;\n\n\t/* Wait for an allocation, but _never_ fail */\n\tfe = mempool_alloc(&lc->flush_entry_pool, GFP_NOIO);\n\tBUG_ON(!fe);\n\n\tspin_lock_irqsave(&lc->flush_lock, flags);\n\tfe->type = DM_ULOG_MARK_REGION;\n\tfe->region = region;\n\tlist_add(&fe->list, &lc->mark_list);\n\tspin_unlock_irqrestore(&lc->flush_lock, flags);\n}"
    },
    {
        "var_name": "fe",
        "function_name": "userspace_mark_region",
        "location": {
            "file_path": "drivers/md/dm-log-userspace-base.c",
            "region": {
                "startLine": 659,
                "startColumn": 2,
                "endColumn": 4
            },
            "context": {
                "startLine": 657,
                "endLine": 661,
                "snippet": {
                    "text": "fe->region = region;"
                }
            }
        },
        "function_code": "static void userspace_mark_region(struct dm_dirty_log *log, region_t region)\n{\n\tunsigned long flags;\n\tstruct log_c *lc = log->context;\n\tstruct dm_dirty_log_flush_entry *fe;\n\n\t/* Wait for an allocation, but _never_ fail */\n\tfe = mempool_alloc(&lc->flush_entry_pool, GFP_NOIO);\n\tBUG_ON(!fe);\n\n\tspin_lock_irqsave(&lc->flush_lock, flags);\n\tfe->type = DM_ULOG_MARK_REGION;\n\tfe->region = region;\n\tlist_add(&fe->list, &lc->mark_list);\n\tspin_unlock_irqrestore(&lc->flush_lock, flags);\n}"
    },
    {
        "var_name": "data",
        "function_name": "write_metadata",
        "location": {
            "file_path": "drivers/md/dm-log-writes.c",
            "region": {
                "startLine": 238,
                "startColumn": 26,
                "endColumn": 30
            },
            "context": {
                "startLine": 236,
                "endLine": 240,
                "snippet": {
                    "text": "memcpy(ptr + entrylen, data, datalen);"
                }
            }
        },
        "function_code": "static int write_metadata(struct log_writes_c *lc, void *entry,\n\t\t\t  size_t entrylen, void *data, size_t datalen,\n\t\t\t  sector_t sector)\n{\n\tstruct bio *bio;\n\tstruct page *page;\n\tvoid *ptr;\n\tsize_t ret;\n\n\tbio = bio_alloc(lc->logdev->bdev, 1, REQ_OP_WRITE, GFP_KERNEL);\n\tbio->bi_iter.bi_size = 0;\n\tbio->bi_iter.bi_sector = sector;\n\tbio->bi_end_io = (sector == WRITE_LOG_SUPER_SECTOR) ?\n\t\t\t  log_end_super : log_end_io;\n\tbio->bi_private = lc;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page) {\n\t\tDMERR(\"Couldn't alloc log page\");\n\t\tbio_put(bio);\n\t\tgoto error;\n\t}\n\n\tptr = kmap_local_page(page);\n\tmemcpy(ptr, entry, entrylen);\n\tif (datalen)\n\t\tmemcpy(ptr + entrylen, data, datalen);\n\tmemset(ptr + entrylen + datalen, 0,\n\t       lc->sectorsize - entrylen - datalen);\n\tkunmap_local(ptr);\n\n\tret = bio_add_page(bio, page, lc->sectorsize, 0);\n\tif (ret != lc->sectorsize) {\n\t\tDMERR(\"Couldn't add page to the log block\");\n\t\tgoto error_bio;\n\t}\n\tsubmit_bio(bio);\n\treturn 0;\nerror_bio:\n\tbio_put(bio);\n\t__free_page(page);\nerror:\n\tput_io_block(lc);\n\treturn -1;\n}"
    },
    {
        "var_name": "reg",
        "function_name": "dm_rh_mark_nosync",
        "location": {
            "file_path": "drivers/md/dm-region-hash.c",
            "region": {
                "startLine": 433,
                "startColumn": 16,
                "endColumn": 19
            },
            "context": {
                "startLine": 431,
                "endLine": 435,
                "snippet": {
                    "text": "recovering = (reg->state == DM_RH_RECOVERING);"
                }
            }
        },
        "function_code": "void dm_rh_mark_nosync(struct dm_region_hash *rh, struct bio *bio)\n{\n\tunsigned long flags;\n\tstruct dm_dirty_log *log = rh->log;\n\tstruct dm_region *reg;\n\tregion_t region = dm_rh_bio_to_region(rh, bio);\n\tint recovering = 0;\n\n\tif (bio->bi_opf & REQ_PREFLUSH) {\n\t\trh->flush_failure = 1;\n\t\treturn;\n\t}\n\n\tif (bio_op(bio) == REQ_OP_DISCARD)\n\t\treturn;\n\n\t/* We must inform the log that the sync count has changed. */\n\tlog->type->set_region_sync(log, region, 0);\n\n\tread_lock(&rh->hash_lock);\n\treg = __rh_find(rh, region);\n\tread_unlock(&rh->hash_lock);\n\n\t/* region hash entry should exist because write was in-flight */\n\tBUG_ON(!reg);\n\tBUG_ON(!list_empty(&reg->list));\n\n\tspin_lock_irqsave(&rh->region_lock, flags);\n\t/*\n\t * Possible cases:\n\t *   1) DM_RH_DIRTY\n\t *   2) DM_RH_NOSYNC: was dirty, other preceding writes failed\n\t *   3) DM_RH_RECOVERING: flushing pending writes\n\t * Either case, the region should have not been connected to list.\n\t */\n\trecovering = (reg->state == DM_RH_RECOVERING);\n\treg->state = DM_RH_NOSYNC;\n\tBUG_ON(!list_empty(&reg->list));\n\tspin_unlock_irqrestore(&rh->region_lock, flags);\n\n\tif (recovering)\n\t\tcomplete_resync_work(reg, 0);\n}"
    },
    {
        "var_name": "reg",
        "function_name": "dm_rh_mark_nosync",
        "location": {
            "file_path": "drivers/md/dm-region-hash.c",
            "region": {
                "startLine": 434,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 432,
                "endLine": 436,
                "snippet": {
                    "text": "reg->state = DM_RH_NOSYNC;"
                }
            }
        },
        "function_code": "void dm_rh_mark_nosync(struct dm_region_hash *rh, struct bio *bio)\n{\n\tunsigned long flags;\n\tstruct dm_dirty_log *log = rh->log;\n\tstruct dm_region *reg;\n\tregion_t region = dm_rh_bio_to_region(rh, bio);\n\tint recovering = 0;\n\n\tif (bio->bi_opf & REQ_PREFLUSH) {\n\t\trh->flush_failure = 1;\n\t\treturn;\n\t}\n\n\tif (bio_op(bio) == REQ_OP_DISCARD)\n\t\treturn;\n\n\t/* We must inform the log that the sync count has changed. */\n\tlog->type->set_region_sync(log, region, 0);\n\n\tread_lock(&rh->hash_lock);\n\treg = __rh_find(rh, region);\n\tread_unlock(&rh->hash_lock);\n\n\t/* region hash entry should exist because write was in-flight */\n\tBUG_ON(!reg);\n\tBUG_ON(!list_empty(&reg->list));\n\n\tspin_lock_irqsave(&rh->region_lock, flags);\n\t/*\n\t * Possible cases:\n\t *   1) DM_RH_DIRTY\n\t *   2) DM_RH_NOSYNC: was dirty, other preceding writes failed\n\t *   3) DM_RH_RECOVERING: flushing pending writes\n\t * Either case, the region should have not been connected to list.\n\t */\n\trecovering = (reg->state == DM_RH_RECOVERING);\n\treg->state = DM_RH_NOSYNC;\n\tBUG_ON(!list_empty(&reg->list));\n\tspin_unlock_irqrestore(&rh->region_lock, flags);\n\n\tif (recovering)\n\t\tcomplete_resync_work(reg, 0);\n}"
    },
    {
        "var_name": "dd",
        "function_name": "dm_table_get_integrity_disk",
        "location": {
            "file_path": "drivers/md/dm-table.c",
            "region": {
                "startLine": 1145,
                "startColumn": 19,
                "endColumn": 21
            },
            "context": {
                "startLine": 1143,
                "endLine": 1147,
                "snippet": {
                    "text": "template_disk = dd->dm_dev->bdev->bd_disk;"
                }
            }
        },
        "function_code": "static struct gendisk *dm_table_get_integrity_disk(struct dm_table *t)\n{\n\tstruct list_head *devices = dm_table_get_devices(t);\n\tstruct dm_dev_internal *dd = NULL;\n\tstruct gendisk *prev_disk = NULL, *template_disk = NULL;\n\n\tfor (unsigned int i = 0; i < t->num_targets; i++) {\n\t\tstruct dm_target *ti = dm_table_get_target(t, i);\n\n\t\tif (!dm_target_passes_integrity(ti->type))\n\t\t\tgoto no_integrity;\n\t}\n\n\tlist_for_each_entry(dd, devices, list) {\n\t\ttemplate_disk = dd->dm_dev->bdev->bd_disk;\n\t\tif (!integrity_profile_exists(template_disk))\n\t\t\tgoto no_integrity;\n\t\telse if (prev_disk &&\n\t\t\t blk_integrity_compare(prev_disk, template_disk) < 0)\n\t\t\tgoto no_integrity;\n\t\tprev_disk = template_disk;\n\t}\n\n\treturn template_disk;\n\nno_integrity:\n\tif (prev_disk)\n\t\tDMWARN(\"%s: integrity not set: %s and %s profile mismatch\",\n\t\t       dm_device_name(t->md),\n\t\t       prev_disk->disk_name,\n\t\t       template_disk->disk_name);\n\treturn NULL;\n}"
    },
    {
        "var_name": "bin",
        "function_name": "vdo_remove_lock_holder_from_packer",
        "location": {
            "file_path": "drivers/md/dm-vdo/packer.c",
            "region": {
                "startLine": 677,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 675,
                "endLine": 679,
                "snippet": {
                    "text": "bin->slots_used--;"
                }
            }
        },
        "function_code": "void vdo_remove_lock_holder_from_packer(struct vdo_completion *completion)\n{\n\tstruct data_vio *data_vio = as_data_vio(completion);\n\tstruct packer *packer = get_packer_from_data_vio(data_vio);\n\tstruct data_vio *lock_holder;\n\tstruct packer_bin *bin;\n\tslot_number_t slot;\n\n\tassert_data_vio_in_packer_zone(data_vio);\n\n\tlock_holder = vdo_forget(data_vio->compression.lock_holder);\n\tbin = lock_holder->compression.bin;\n\tVDO_ASSERT_LOG_ONLY((bin != NULL), \"data_vio in packer has a bin\");\n\n\tslot = lock_holder->compression.slot;\n\tbin->slots_used--;\n\tif (slot < bin->slots_used) {\n\t\tbin->incoming[slot] = bin->incoming[bin->slots_used];\n\t\tbin->incoming[slot]->compression.slot = slot;\n\t}\n\n\tlock_holder->compression.bin = NULL;\n\tlock_holder->compression.slot = 0;\n\n\tif (bin != packer->canceled_bin) {\n\t\tbin->free_space += lock_holder->compression.size;\n\t\tinsert_in_sorted_list(packer, bin);\n\t}\n\n\tabort_packing(lock_holder);\n\tcheck_for_drain_complete(packer);\n}"
    },
    {
        "var_name": "bin",
        "function_name": "vdo_remove_lock_holder_from_packer",
        "location": {
            "file_path": "drivers/md/dm-vdo/packer.c",
            "region": {
                "startLine": 678,
                "startColumn": 13,
                "endColumn": 16
            },
            "context": {
                "startLine": 676,
                "endLine": 680,
                "snippet": {
                    "text": "if (slot < bin->slots_used) {"
                }
            }
        },
        "function_code": "void vdo_remove_lock_holder_from_packer(struct vdo_completion *completion)\n{\n\tstruct data_vio *data_vio = as_data_vio(completion);\n\tstruct packer *packer = get_packer_from_data_vio(data_vio);\n\tstruct data_vio *lock_holder;\n\tstruct packer_bin *bin;\n\tslot_number_t slot;\n\n\tassert_data_vio_in_packer_zone(data_vio);\n\n\tlock_holder = vdo_forget(data_vio->compression.lock_holder);\n\tbin = lock_holder->compression.bin;\n\tVDO_ASSERT_LOG_ONLY((bin != NULL), \"data_vio in packer has a bin\");\n\n\tslot = lock_holder->compression.slot;\n\tbin->slots_used--;\n\tif (slot < bin->slots_used) {\n\t\tbin->incoming[slot] = bin->incoming[bin->slots_used];\n\t\tbin->incoming[slot]->compression.slot = slot;\n\t}\n\n\tlock_holder->compression.bin = NULL;\n\tlock_holder->compression.slot = 0;\n\n\tif (bin != packer->canceled_bin) {\n\t\tbin->free_space += lock_holder->compression.size;\n\t\tinsert_in_sorted_list(packer, bin);\n\t}\n\n\tabort_packing(lock_holder);\n\tcheck_for_drain_complete(packer);\n}"
    },
    {
        "var_name": "slab_journal_point",
        "function_name": "adjust_reference_count",
        "location": {
            "file_path": "drivers/md/dm-vdo/slab-depot.c",
            "region": {
                "startLine": 1652,
                "startColumn": 34,
                "endColumn": 52
            },
            "context": {
                "startLine": 1650,
                "endLine": 1654,
                "snippet": {
                    "text": "sequence_number_t entry_lock = slab_journal_point->sequence_number;"
                }
            }
        },
        "function_code": "static int __must_check adjust_reference_count(struct vdo_slab *slab,\n\t\t\t\t\t       struct reference_updater *updater,\n\t\t\t\t\t       const struct journal_point *slab_journal_point)\n{\n\tslab_block_number block_number;\n\tint result;\n\tstruct reference_block *block;\n\tbool provisional_decrement = false;\n\n\tif (!is_slab_open(slab))\n\t\treturn VDO_INVALID_ADMIN_STATE;\n\n\tresult = slab_block_number_from_pbn(slab, updater->zpbn.pbn, &block_number);\n\tif (result != VDO_SUCCESS)\n\t\treturn result;\n\n\tblock = get_reference_block(slab, block_number);\n\tresult = update_reference_count(slab, block, block_number, slab_journal_point,\n\t\t\t\t\tupdater, NORMAL_OPERATION, true,\n\t\t\t\t\t&provisional_decrement);\n\tif ((result != VDO_SUCCESS) || provisional_decrement)\n\t\treturn result;\n\n\tif (block->is_dirty && (block->slab_journal_lock > 0)) {\n\t\tsequence_number_t entry_lock = slab_journal_point->sequence_number;\n\t\t/*\n\t\t * This block is already dirty and a slab journal entry has been made for it since\n\t\t * the last time it was clean. We must release the per-entry slab journal lock for\n\t\t * the entry associated with the update we are now doing.\n\t\t */\n\t\tresult = VDO_ASSERT(is_valid_journal_point(slab_journal_point),\n\t\t\t\t    \"Reference count adjustments need slab journal points.\");\n\t\tif (result != VDO_SUCCESS)\n\t\t\treturn result;\n\n\t\tadjust_slab_journal_block_reference(&slab->journal, entry_lock, -1);\n\t\treturn VDO_SUCCESS;\n\t}\n\n\t/*\n\t * This may be the first time we are applying an update for which there is a slab journal\n\t * entry to this block since the block was cleaned. Therefore, we convert the per-entry\n\t * slab journal lock to an uncommitted reference block lock, if there is a per-entry lock.\n\t */\n\tif (is_valid_journal_point(slab_journal_point))\n\t\tblock->slab_journal_lock = slab_journal_point->sequence_number;\n\telse\n\t\tblock->slab_journal_lock = 0;\n\n\tdirty_block(block);\n\treturn VDO_SUCCESS;\n}"
    },
    {
        "var_name": "list",
        "function_name": "dm_poll_bio",
        "location": {
            "file_path": "drivers/md/dm.c",
            "region": {
                "startLine": 1910,
                "startColumn": 20,
                "endColumn": 24
            },
            "context": {
                "startLine": 1908,
                "endLine": 1912,
                "snippet": {
                    "text": "bio->bi_private = list->data;"
                }
            }
        },
        "function_code": "static int dm_poll_bio(struct bio *bio, struct io_comp_batch *iob,\n\t\t       unsigned int flags)\n{\n\tstruct dm_io **head = dm_poll_list_head(bio);\n\tstruct dm_io *list = *head;\n\tstruct dm_io *tmp = NULL;\n\tstruct dm_io *curr, *next;\n\n\t/* Only poll normal bio which was marked as REQ_DM_POLL_LIST */\n\tif (!(bio->bi_opf & REQ_DM_POLL_LIST))\n\t\treturn 0;\n\n\tWARN_ON_ONCE(!list);\n\n\t/*\n\t * Restore .bi_private before possibly completing dm_io.\n\t *\n\t * bio_poll() is only possible once @bio has been completely\n\t * submitted via submit_bio_noacct()'s depth-first submission.\n\t * So there is no dm_queue_poll_io() race associated with\n\t * clearing REQ_DM_POLL_LIST here.\n\t */\n\tbio->bi_opf &= ~REQ_DM_POLL_LIST;\n\tbio->bi_private = list->data;\n\n\tfor (curr = list, next = curr->next; curr; curr = next, next =\n\t\t\tcurr ? curr->next : NULL) {\n\t\tif (dm_poll_dm_io(curr, iob, flags)) {\n\t\t\t/*\n\t\t\t * clone_endio() has already occurred, so no\n\t\t\t * error handling is needed here.\n\t\t\t */\n\t\t\t__dm_io_dec_pending(curr);\n\t\t} else {\n\t\t\tcurr->next = tmp;\n\t\t\ttmp = curr;\n\t\t}\n\t}\n\n\t/* Not done? */\n\tif (tmp) {\n\t\tbio->bi_opf |= REQ_DM_POLL_LIST;\n\t\t/* Reset bio->bi_private to dm_io list head */\n\t\t*head = tmp;\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "vb2_dma_sg_vaddr",
        "location": {
            "file_path": "drivers/media/common/videobuf2/videobuf2-dma-sg.c",
            "region": {
                "startLine": 312,
                "startColumn": 7,
                "endColumn": 10
            },
            "context": {
                "startLine": 310,
                "endLine": 314,
                "snippet": {
                    "text": "if (!buf->vaddr) {"
                }
            }
        },
        "function_code": "static void *vb2_dma_sg_vaddr(struct vb2_buffer *vb, void *buf_priv)\n{\n\tstruct vb2_dma_sg_buf *buf = buf_priv;\n\tstruct iosys_map map;\n\tint ret;\n\n\tBUG_ON(!buf);\n\n\tif (!buf->vaddr) {\n\t\tif (buf->db_attach) {\n\t\t\tret = dma_buf_vmap_unlocked(buf->db_attach->dmabuf, &map);\n\t\t\tbuf->vaddr = ret ? NULL : map.vaddr;\n\t\t} else {\n\t\t\tbuf->vaddr = vm_map_ram(buf->pages, buf->num_pages, -1);\n\t\t}\n\t}\n\n\t/* add offset in case userptr is not page-aligned */\n\treturn buf->vaddr ? buf->vaddr + buf->offset : NULL;\n}"
    },
    {
        "var_name": "node",
        "function_name": "dvb_register_device",
        "location": {
            "file_path": "drivers/media/dvb-core/dvbdev.c",
            "region": {
                "startLine": 482,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 480,
                "endLine": 484,
                "snippet": {
                    "text": "if (node->fops->owner == adap->module &&"
                }
            }
        },
        "function_code": "int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,\n\t\t\tconst struct dvb_device *template, void *priv,\n\t\t\tenum dvb_device_type type, int demux_sink_pads)\n{\n\tstruct dvb_device *dvbdev;\n\tstruct file_operations *dvbdevfops = NULL;\n\tstruct dvbdevfops_node *node = NULL, *new_node = NULL;\n\tstruct device *clsdev;\n\tint minor;\n\tint id, ret;\n\n\tmutex_lock(&dvbdev_register_lock);\n\n\tid = dvbdev_get_free_id(adap, type);\n\tif (id < 0) {\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\t*pdvbdev = NULL;\n\t\tpr_err(\"%s: couldn't find free device id\\n\", __func__);\n\t\treturn -ENFILE;\n\t}\n\n\t*pdvbdev = dvbdev = kzalloc(sizeof(*dvbdev), GFP_KERNEL);\n\tif (!dvbdev) {\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * When a device of the same type is probe()d more than once,\n\t * the first allocated fops are used. This prevents memory leaks\n\t * that can occur when the same device is probe()d repeatedly.\n\t */\n\tlist_for_each_entry(node, &dvbdevfops_list, list_head) {\n\t\tif (node->fops->owner == adap->module &&\n\t\t    node->type == type && node->template == template) {\n\t\t\tdvbdevfops = node->fops;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!dvbdevfops) {\n\t\tdvbdevfops = kmemdup(template->fops, sizeof(*dvbdevfops), GFP_KERNEL);\n\t\tif (!dvbdevfops) {\n\t\t\tkfree(dvbdev);\n\t\t\t*pdvbdev = NULL;\n\t\t\tmutex_unlock(&dvbdev_register_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnew_node = kzalloc(sizeof(*new_node), GFP_KERNEL);\n\t\tif (!new_node) {\n\t\t\tkfree(dvbdevfops);\n\t\t\tkfree(dvbdev);\n\t\t\t*pdvbdev = NULL;\n\t\t\tmutex_unlock(&dvbdev_register_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tnew_node->fops = dvbdevfops;\n\t\tnew_node->type = type;\n\t\tnew_node->template = template;\n\t\tlist_add_tail(&new_node->list_head, &dvbdevfops_list);\n\t}\n\n\tmemcpy(dvbdev, template, sizeof(struct dvb_device));\n\tkref_init(&dvbdev->ref);\n\tdvbdev->type = type;\n\tdvbdev->id = id;\n\tdvbdev->adapter = adap;\n\tdvbdev->priv = priv;\n\tdvbdev->fops = dvbdevfops;\n\tinit_waitqueue_head(&dvbdev->wait_queue);\n\tdvbdevfops->owner = adap->module;\n\tlist_add_tail(&dvbdev->list_head, &adap->device_list);\n\tdown_write(&minor_rwsem);\n#ifdef CONFIG_DVB_DYNAMIC_MINORS\n\tfor (minor = 0; minor < MAX_DVB_MINORS; minor++)\n\t\tif (!dvb_minors[minor])\n\t\t\tbreak;\n\tif (minor == MAX_DVB_MINORS) {\n\t\tif (new_node) {\n\t\t\tlist_del(&new_node->list_head);\n\t\t\tkfree(dvbdevfops);\n\t\t\tkfree(new_node);\n\t\t}\n\t\tlist_del(&dvbdev->list_head);\n\t\tkfree(dvbdev);\n\t\t*pdvbdev = NULL;\n\t\tup_write(&minor_rwsem);\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn -EINVAL;\n\t}\n#else\n\tminor = nums2minor(adap->num, type, id);\n#endif\n\tdvbdev->minor = minor;\n\tdvb_minors[minor] = dvb_device_get(dvbdev);\n\tup_write(&minor_rwsem);\n\tret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);\n\tif (ret) {\n\t\tpr_err(\"%s: dvb_register_media_device failed to create the mediagraph\\n\",\n\t\t       __func__);\n\t\tif (new_node) {\n\t\t\tlist_del(&new_node->list_head);\n\t\t\tkfree(dvbdevfops);\n\t\t\tkfree(new_node);\n\t\t}\n\t\tdvb_media_device_free(dvbdev);\n\t\tlist_del(&dvbdev->list_head);\n\t\tkfree(dvbdev);\n\t\t*pdvbdev = NULL;\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn ret;\n\t}\n\n\tclsdev = device_create(dvb_class, adap->device,\n\t\t\t       MKDEV(DVB_MAJOR, minor),\n\t\t\t       dvbdev, \"dvb%d.%s%d\", adap->num, dnames[type], id);\n\tif (IS_ERR(clsdev)) {\n\t\tpr_err(\"%s: failed to create device dvb%d.%s%d (%ld)\\n\",\n\t\t       __func__, adap->num, dnames[type], id, PTR_ERR(clsdev));\n\t\tif (new_node) {\n\t\t\tlist_del(&new_node->list_head);\n\t\t\tkfree(dvbdevfops);\n\t\t\tkfree(new_node);\n\t\t}\n\t\tdvb_media_device_free(dvbdev);\n\t\tlist_del(&dvbdev->list_head);\n\t\tkfree(dvbdev);\n\t\t*pdvbdev = NULL;\n\t\tmutex_unlock(&dvbdev_register_lock);\n\t\treturn PTR_ERR(clsdev);\n\t}\n\n\tdprintk(\"DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\\n\",\n\t\tadap->num, dnames[type], id, minor, minor);\n\n\tmutex_unlock(&dvbdev_register_lock);\n\treturn 0;\n}"
    },
    {
        "var_name": "r_dev_addr",
        "function_name": "drxbsp_i2c_write_read",
        "location": {
            "file_path": "drivers/media/dvb-frontends/drx39xyj/drxj.c",
            "region": {
                "startLine": 1320,
                "startColumn": 11,
                "endColumn": 21
            },
            "context": {
                "startLine": 1318,
                "endLine": 1322,
                "snippet": {
                    "text": "state = r_dev_addr->user_data;"
                }
            }
        },
        "function_code": "int drxbsp_i2c_write_read(struct i2c_device_addr *w_dev_addr,\n\t\t\t\t u16 w_count,\n\t\t\t\t u8 *wData,\n\t\t\t\t struct i2c_device_addr *r_dev_addr,\n\t\t\t\t u16 r_count, u8 *r_data)\n{\n\tstruct drx39xxj_state *state;\n\tstruct i2c_msg msg[2];\n\tunsigned int num_msgs;\n\n\tif (w_dev_addr == NULL) {\n\t\t/* Read only */\n\t\tstate = r_dev_addr->user_data;\n\t\tmsg[0].addr = r_dev_addr->i2c_addr >> 1;\n\t\tmsg[0].flags = I2C_M_RD;\n\t\tmsg[0].buf = r_data;\n\t\tmsg[0].len = r_count;\n\t\tnum_msgs = 1;\n\t} else if (r_dev_addr == NULL) {\n\t\t/* Write only */\n\t\tstate = w_dev_addr->user_data;\n\t\tmsg[0].addr = w_dev_addr->i2c_addr >> 1;\n\t\tmsg[0].flags = 0;\n\t\tmsg[0].buf = wData;\n\t\tmsg[0].len = w_count;\n\t\tnum_msgs = 1;\n\t} else {\n\t\t/* Both write and read */\n\t\tstate = w_dev_addr->user_data;\n\t\tmsg[0].addr = w_dev_addr->i2c_addr >> 1;\n\t\tmsg[0].flags = 0;\n\t\tmsg[0].buf = wData;\n\t\tmsg[0].len = w_count;\n\t\tmsg[1].addr = r_dev_addr->i2c_addr >> 1;\n\t\tmsg[1].flags = I2C_M_RD;\n\t\tmsg[1].buf = r_data;\n\t\tmsg[1].len = r_count;\n\t\tnum_msgs = 2;\n\t}\n\n\tif (state->i2c == NULL) {\n\t\tpr_err(\"i2c was zero, aborting\\n\");\n\t\treturn 0;\n\t}\n\tif (i2c_transfer(state->i2c, msg, num_msgs) != num_msgs) {\n\t\tpr_warn(\"drx3933: I2C write/read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n#ifdef DJH_DEBUG\n\tif (w_dev_addr == NULL || r_dev_addr == NULL)\n\t\treturn 0;\n\n\tstate = w_dev_addr->user_data;\n\n\tif (state->i2c == NULL)\n\t\treturn 0;\n\n\tmsg[0].addr = w_dev_addr->i2c_addr;\n\tmsg[0].flags = 0;\n\tmsg[0].buf = wData;\n\tmsg[0].len = w_count;\n\tmsg[1].addr = r_dev_addr->i2c_addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = r_data;\n\tmsg[1].len = r_count;\n\tnum_msgs = 2;\n\n\tpr_debug(\"drx3933 i2c operation addr=%x i2c=%p, wc=%x rc=%x\\n\",\n\t       w_dev_addr->i2c_addr, state->i2c, w_count, r_count);\n\n\tif (i2c_transfer(state->i2c, msg, 2) != 2) {\n\t\tpr_warn(\"drx3933: I2C write/read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n#endif\n\treturn 0;\n}"
    },
    {
        "var_name": "r_dev_addr",
        "function_name": "drxbsp_i2c_write_read",
        "location": {
            "file_path": "drivers/media/dvb-frontends/drx39xyj/drxj.c",
            "region": {
                "startLine": 1321,
                "startColumn": 17,
                "endColumn": 27
            },
            "context": {
                "startLine": 1319,
                "endLine": 1323,
                "snippet": {
                    "text": "msg[0].addr = r_dev_addr->i2c_addr >> 1;"
                }
            }
        },
        "function_code": "int drxbsp_i2c_write_read(struct i2c_device_addr *w_dev_addr,\n\t\t\t\t u16 w_count,\n\t\t\t\t u8 *wData,\n\t\t\t\t struct i2c_device_addr *r_dev_addr,\n\t\t\t\t u16 r_count, u8 *r_data)\n{\n\tstruct drx39xxj_state *state;\n\tstruct i2c_msg msg[2];\n\tunsigned int num_msgs;\n\n\tif (w_dev_addr == NULL) {\n\t\t/* Read only */\n\t\tstate = r_dev_addr->user_data;\n\t\tmsg[0].addr = r_dev_addr->i2c_addr >> 1;\n\t\tmsg[0].flags = I2C_M_RD;\n\t\tmsg[0].buf = r_data;\n\t\tmsg[0].len = r_count;\n\t\tnum_msgs = 1;\n\t} else if (r_dev_addr == NULL) {\n\t\t/* Write only */\n\t\tstate = w_dev_addr->user_data;\n\t\tmsg[0].addr = w_dev_addr->i2c_addr >> 1;\n\t\tmsg[0].flags = 0;\n\t\tmsg[0].buf = wData;\n\t\tmsg[0].len = w_count;\n\t\tnum_msgs = 1;\n\t} else {\n\t\t/* Both write and read */\n\t\tstate = w_dev_addr->user_data;\n\t\tmsg[0].addr = w_dev_addr->i2c_addr >> 1;\n\t\tmsg[0].flags = 0;\n\t\tmsg[0].buf = wData;\n\t\tmsg[0].len = w_count;\n\t\tmsg[1].addr = r_dev_addr->i2c_addr >> 1;\n\t\tmsg[1].flags = I2C_M_RD;\n\t\tmsg[1].buf = r_data;\n\t\tmsg[1].len = r_count;\n\t\tnum_msgs = 2;\n\t}\n\n\tif (state->i2c == NULL) {\n\t\tpr_err(\"i2c was zero, aborting\\n\");\n\t\treturn 0;\n\t}\n\tif (i2c_transfer(state->i2c, msg, num_msgs) != num_msgs) {\n\t\tpr_warn(\"drx3933: I2C write/read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n\n#ifdef DJH_DEBUG\n\tif (w_dev_addr == NULL || r_dev_addr == NULL)\n\t\treturn 0;\n\n\tstate = w_dev_addr->user_data;\n\n\tif (state->i2c == NULL)\n\t\treturn 0;\n\n\tmsg[0].addr = w_dev_addr->i2c_addr;\n\tmsg[0].flags = 0;\n\tmsg[0].buf = wData;\n\tmsg[0].len = w_count;\n\tmsg[1].addr = r_dev_addr->i2c_addr;\n\tmsg[1].flags = I2C_M_RD;\n\tmsg[1].buf = r_data;\n\tmsg[1].len = r_count;\n\tnum_msgs = 2;\n\n\tpr_debug(\"drx3933 i2c operation addr=%x i2c=%p, wc=%x rc=%x\\n\",\n\t       w_dev_addr->i2c_addr, state->i2c, w_count, r_count);\n\n\tif (i2c_transfer(state->i2c, msg, 2) != 2) {\n\t\tpr_warn(\"drx3933: I2C write/read failed\\n\");\n\t\treturn -EREMOTEIO;\n\t}\n#endif\n\treturn 0;\n}"
    },
    {
        "var_name": "p_block",
        "function_name": "write_block",
        "location": {
            "file_path": "drivers/media/dvb-frontends/drxk_hard.c",
            "region": {
                "startLine": 428,
                "startColumn": 37,
                "endColumn": 44
            },
            "context": {
                "startLine": 426,
                "endLine": 430,
                "snippet": {
                    "text": "memcpy(&state->chunk[adr_length], p_block, chunk);"
                }
            }
        },
        "function_code": "static int write_block(struct drxk_state *state, u32 address,\n\t\t      const int block_size, const u8 p_block[])\n{\n\tint status = 0, blk_size = block_size;\n\tu8 flags = 0;\n\n\tif (state->single_master)\n\t\tflags |= 0xC0;\n\n\twhile (blk_size > 0) {\n\t\tint chunk = blk_size > state->m_chunk_size ?\n\t\t    state->m_chunk_size : blk_size;\n\t\tu8 *adr_buf = &state->chunk[0];\n\t\tu32 adr_length = 0;\n\n\t\tif (DRXDAP_FASI_LONG_FORMAT(address) || (flags != 0)) {\n\t\t\tadr_buf[0] = (((address << 1) & 0xFF) | 0x01);\n\t\t\tadr_buf[1] = ((address >> 16) & 0xFF);\n\t\t\tadr_buf[2] = ((address >> 24) & 0xFF);\n\t\t\tadr_buf[3] = ((address >> 7) & 0xFF);\n\t\t\tadr_buf[2] |= flags;\n\t\t\tadr_length = 4;\n\t\t\tif (chunk == state->m_chunk_size)\n\t\t\t\tchunk -= 2;\n\t\t} else {\n\t\t\tadr_buf[0] = ((address << 1) & 0xFF);\n\t\t\tadr_buf[1] = (((address >> 16) & 0x0F) |\n\t\t\t\t     ((address >> 18) & 0xF0));\n\t\t\tadr_length = 2;\n\t\t}\n\t\tmemcpy(&state->chunk[adr_length], p_block, chunk);\n\t\tdprintk(2, \"(0x%08x, 0x%02x)\\n\", address, flags);\n\t\tif (p_block)\n\t\t\tdprintk(2, \"%*ph\\n\", chunk, p_block);\n\t\tstatus = i2c_write(state, state->demod_address,\n\t\t\t\t   &state->chunk[0], chunk + adr_length);\n\t\tif (status < 0) {\n\t\t\tpr_err(\"%s: i2c write error at addr 0x%02x\\n\",\n\t\t\t       __func__, address);\n\t\t\tbreak;\n\t\t}\n\t\tp_block += chunk;\n\t\taddress += (chunk >> 1);\n\t\tblk_size -= chunk;\n\t}\n\treturn status;\n}"
    },
    {
        "var_name": "source",
        "function_name": "media_create_pad_links",
        "location": {
            "file_path": "drivers/media/mc/mc-entity.c",
            "region": {
                "startLine": 1220,
                "startColumn": 8,
                "endColumn": 14
            },
            "context": {
                "startLine": 1218,
                "endLine": 1222,
                "snippet": {
                    "text": "if (source->function != source_function)"
                }
            }
        },
        "function_code": "int media_create_pad_links(const struct media_device *mdev,\n\t\t\t   const u32 source_function,\n\t\t\t   struct media_entity *source,\n\t\t\t   const u16 source_pad,\n\t\t\t   const u32 sink_function,\n\t\t\t   struct media_entity *sink,\n\t\t\t   const u16 sink_pad,\n\t\t\t   u32 flags,\n\t\t\t   const bool allow_both_undefined)\n{\n\tstruct media_entity *entity;\n\tunsigned function;\n\tint ret;\n\n\t/* Trivial case: 1:1 relation */\n\tif (source && sink)\n\t\treturn media_create_pad_link(source, source_pad,\n\t\t\t\t\t     sink, sink_pad, flags);\n\n\t/* Worse case scenario: n:n relation */\n\tif (!source && !sink) {\n\t\tif (!allow_both_undefined)\n\t\t\treturn 0;\n\t\tmedia_device_for_each_entity(source, mdev) {\n\t\t\tif (source->function != source_function)\n\t\t\t\tcontinue;\n\t\t\tmedia_device_for_each_entity(sink, mdev) {\n\t\t\t\tif (sink->function != sink_function)\n\t\t\t\t\tcontinue;\n\t\t\t\tret = media_create_pad_link(source, source_pad,\n\t\t\t\t\t\t\t    sink, sink_pad,\n\t\t\t\t\t\t\t    flags);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tflags &= ~(MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t   MEDIA_LNK_FL_IMMUTABLE);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Handle 1:n and n:1 cases */\n\tif (source)\n\t\tfunction = sink_function;\n\telse\n\t\tfunction = source_function;\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif (entity->function != function)\n\t\t\tcontinue;\n\n\t\tif (source)\n\t\t\tret = media_create_pad_link(source, source_pad,\n\t\t\t\t\t\t    entity, sink_pad, flags);\n\t\telse\n\t\t\tret = media_create_pad_link(entity, source_pad,\n\t\t\t\t\t\t    sink, sink_pad, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tflags &= ~(MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "sink",
        "function_name": "media_create_pad_links",
        "location": {
            "file_path": "drivers/media/mc/mc-entity.c",
            "region": {
                "startLine": 1223,
                "startColumn": 9,
                "endColumn": 13
            },
            "context": {
                "startLine": 1221,
                "endLine": 1225,
                "snippet": {
                    "text": "if (sink->function != sink_function)"
                }
            }
        },
        "function_code": "int media_create_pad_links(const struct media_device *mdev,\n\t\t\t   const u32 source_function,\n\t\t\t   struct media_entity *source,\n\t\t\t   const u16 source_pad,\n\t\t\t   const u32 sink_function,\n\t\t\t   struct media_entity *sink,\n\t\t\t   const u16 sink_pad,\n\t\t\t   u32 flags,\n\t\t\t   const bool allow_both_undefined)\n{\n\tstruct media_entity *entity;\n\tunsigned function;\n\tint ret;\n\n\t/* Trivial case: 1:1 relation */\n\tif (source && sink)\n\t\treturn media_create_pad_link(source, source_pad,\n\t\t\t\t\t     sink, sink_pad, flags);\n\n\t/* Worse case scenario: n:n relation */\n\tif (!source && !sink) {\n\t\tif (!allow_both_undefined)\n\t\t\treturn 0;\n\t\tmedia_device_for_each_entity(source, mdev) {\n\t\t\tif (source->function != source_function)\n\t\t\t\tcontinue;\n\t\t\tmedia_device_for_each_entity(sink, mdev) {\n\t\t\t\tif (sink->function != sink_function)\n\t\t\t\t\tcontinue;\n\t\t\t\tret = media_create_pad_link(source, source_pad,\n\t\t\t\t\t\t\t    sink, sink_pad,\n\t\t\t\t\t\t\t    flags);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\tflags &= ~(MEDIA_LNK_FL_ENABLED |\n\t\t\t\t\t   MEDIA_LNK_FL_IMMUTABLE);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Handle 1:n and n:1 cases */\n\tif (source)\n\t\tfunction = sink_function;\n\telse\n\t\tfunction = source_function;\n\n\tmedia_device_for_each_entity(entity, mdev) {\n\t\tif (entity->function != function)\n\t\t\tcontinue;\n\n\t\tif (source)\n\t\t\tret = media_create_pad_link(source, source_pad,\n\t\t\t\t\t\t    entity, sink_pad, flags);\n\t\telse\n\t\t\tret = media_create_pad_link(entity, source_pad,\n\t\t\t\t\t\t    sink, sink_pad, flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tflags &= ~(MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE);\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "mantis",
        "function_name": "mantis_i2c_xfer",
        "location": {
            "file_path": "drivers/media/pci/mantis/mantis_i2c.c",
            "region": {
                "startLine": 125,
                "startColumn": 11,
                "endColumn": 17
            },
            "context": {
                "startLine": 123,
                "endLine": 127,
                "snippet": {
                    "text": "config = mantis->hwconfig;"
                }
            }
        },
        "function_code": "static int mantis_i2c_xfer(struct i2c_adapter *adapter, struct i2c_msg *msgs, int num)\n{\n\tint ret = 0, i = 0, trials;\n\tu32 stat, data, txd;\n\tstruct mantis_pci *mantis;\n\tstruct mantis_hwconfig *config;\n\n\tmantis = i2c_get_adapdata(adapter);\n\tBUG_ON(!mantis);\n\tconfig = mantis->hwconfig;\n\tBUG_ON(!config);\n\n\tdprintk(MANTIS_DEBUG, 1, \"Messages:%d\", num);\n\tmutex_lock(&mantis->i2c_lock);\n\n\twhile (i < num) {\n\t\t/* Byte MODE */\n\t\tif ((config->i2c_mode & MANTIS_BYTE_MODE) &&\n\t\t    ((i + 1) < num)\t\t\t&&\n\t\t    (msgs[i].len < 2)\t\t\t&&\n\t\t    (msgs[i + 1].len < 2)\t\t&&\n\t\t    (msgs[i + 1].flags & I2C_M_RD)) {\n\n\t\t\tdprintk(MANTIS_DEBUG, 0, \"        Byte MODE:\\n\");\n\n\t\t\t/* Read operation */\n\t\t\ttxd = msgs[i].addr << 25 | (0x1 << 24)\n\t\t\t\t\t\t | (msgs[i].buf[0] << 16)\n\t\t\t\t\t\t | MANTIS_I2C_RATE_3;\n\n\t\t\tmmwrite(txd, MANTIS_I2CDATA_CTL);\n\t\t\t/* wait for xfer completion */\n\t\t\tfor (trials = 0; trials < TRIALS; trials++) {\n\t\t\t\tstat = mmread(MANTIS_INT_STAT);\n\t\t\t\tif (stat & MANTIS_INT_I2CDONE)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* check for xfer completion */\n\t\t\tif (stat & MANTIS_INT_I2CDONE) {\n\t\t\t\t/* check xfer was acknowledged */\n\t\t\t\tif (stat & MANTIS_INT_I2CRACK) {\n\t\t\t\t\tdata = mmread(MANTIS_I2CDATA_CTL);\n\t\t\t\t\tmsgs[i + 1].buf[0] = (data >> 8) & 0xff;\n\t\t\t\t\tdprintk(MANTIS_DEBUG, 0, \"        Byte <%d> RXD=0x%02x  [%02x]\\n\", 0x0, data, msgs[i + 1].buf[0]);\n\t\t\t\t} else {\n\t\t\t\t\t/* I/O error */\n\t\t\t\t\tdprintk(MANTIS_ERROR, 1, \"        I/O error, LINE:%d\", __LINE__);\n\t\t\t\t\tret = -EIO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* I/O error */\n\t\t\t\tdprintk(MANTIS_ERROR, 1, \"        I/O error, LINE:%d\", __LINE__);\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti += 2; /* Write/Read operation in one go */\n\t\t}\n\n\t\tif (i < num) {\n\t\t\tif (msgs[i].flags & I2C_M_RD)\n\t\t\t\tret = mantis_i2c_read(mantis, &msgs[i]);\n\t\t\telse\n\t\t\t\tret = mantis_i2c_write(mantis, &msgs[i]);\n\n\t\t\ti++;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto bail_out;\n\t\t}\n\n\t}\n\n\tmutex_unlock(&mantis->i2c_lock);\n\n\treturn num;\n\nbail_out:\n\tmutex_unlock(&mantis->i2c_lock);\n\treturn ret;\n}"
    },
    {
        "var_name": "out",
        "function_name": "ngene_command_i2c_read",
        "location": {
            "file_path": "drivers/media/pci/ngene/ngene-i2c.c",
            "region": {
                "startLine": 39,
                "startColumn": 31,
                "endColumn": 34
            },
            "context": {
                "startLine": 37,
                "endLine": 41,
                "snippet": {
                    "text": "memcpy(com.cmd.I2CRead.Data, out, outlen);"
                }
            }
        },
        "function_code": "static int ngene_command_i2c_read(struct ngene *dev, u8 adr,\n\t\t\t   u8 *out, u8 outlen, u8 *in, u8 inlen, int flag)\n{\n\tstruct ngene_command com;\n\n\tcom.cmd.hdr.Opcode = CMD_I2C_READ;\n\tcom.cmd.hdr.Length = outlen + 3;\n\tcom.cmd.I2CRead.Device = adr << 1;\n\tmemcpy(com.cmd.I2CRead.Data, out, outlen);\n\tcom.cmd.I2CRead.Data[outlen] = inlen;\n\tcom.cmd.I2CRead.Data[outlen + 1] = 0;\n\tcom.in_len = outlen + 3;\n\tcom.out_len = inlen + 1;\n\n\tif (ngene_command(dev, &com) < 0)\n\t\treturn -EIO;\n\n\tif ((com.cmd.raw8[0] >> 1) != adr)\n\t\treturn -EIO;\n\n\tif (flag)\n\t\tmemcpy(in, com.cmd.raw8, inlen + 1);\n\telse\n\t\tmemcpy(in, com.cmd.raw8 + 1, inlen);\n\treturn 0;\n}"
    },
    {
        "var_name": "core",
        "function_name": "vpu_get_resource",
        "location": {
            "file_path": "drivers/media/platform/amphion/vpu_core.c",
            "region": {
                "startLine": 532,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 530,
                "endLine": 534,
                "snippet": {
                    "text": "if (core->type == inst->type) {"
                }
            }
        },
        "function_code": "const struct vpu_core_resources *vpu_get_resource(struct vpu_inst *inst)\n{\n\tstruct vpu_dev *vpu;\n\tstruct vpu_core *core = NULL;\n\tconst struct vpu_core_resources *res = NULL;\n\n\tif (!inst || !inst->vpu)\n\t\treturn NULL;\n\n\tif (inst->core && inst->core->res)\n\t\treturn inst->core->res;\n\n\tvpu = inst->vpu;\n\tmutex_lock(&vpu->lock);\n\tlist_for_each_entry(core, &vpu->cores, list) {\n\t\tif (core->type == inst->type) {\n\t\t\tres = core->res;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vpu->lock);\n\n\treturn res;\n}"
    },
    {
        "var_name": "inst",
        "function_name": "vpu_core_resume_work",
        "location": {
            "file_path": "drivers/media/platform/amphion/vpu_core.c",
            "region": {
                "startLine": 773,
                "startColumn": 14,
                "endColumn": 18
            },
            "context": {
                "startLine": 771,
                "endLine": 775,
                "snippet": {
                    "text": "queue_work(inst->workqueue, &inst->msg_work);"
                }
            }
        },
        "function_code": "static void vpu_core_resume_work(struct vpu_core *core)\n{\n\tstruct vpu_inst *inst = NULL;\n\tunsigned long delay = msecs_to_jiffies(10);\n\n\tqueue_work(core->workqueue, &core->msg_work);\n\tqueue_delayed_work(core->workqueue, &core->msg_delayed_work, delay);\n\n\tmutex_lock(&core->lock);\n\tlist_for_each_entry(inst, &core->instances, list)\n\t\tqueue_work(inst->workqueue, &inst->msg_work);\n\tmutex_unlock(&core->lock);\n}"
    },
    {
        "var_name": "ctrl",
        "function_name": "ctrl_to_dec_ctx",
        "location": {
            "file_path": "drivers/media/platform/mediatek/vcodec/decoder/mtk_vcodec_dec_drv.h",
            "region": {
                "startLine": 317,
                "startColumn": 22,
                "endColumn": 26
            },
            "context": {
                "startLine": 315,
                "endLine": 319,
                "snippet": {
                    "text": "return container_of(ctrl->handler, struct mtk_vcodec_dec_ctx, ctrl_hdl);"
                }
            }
        },
        "function_code": "static inline struct mtk_vcodec_dec_ctx *ctrl_to_dec_ctx(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mtk_vcodec_dec_ctx, ctrl_hdl);\n}"
    },
    {
        "var_name": "b",
        "function_name": "tegra_vde_h264_setup_frame",
        "location": {
            "file_path": "drivers/media/platform/nvidia/tegra-vde/h264.c",
            "region": {
                "startLine": 740,
                "startColumn": 15,
                "endColumn": 16
            },
            "context": {
                "startLine": 738,
                "endLine": 742,
                "snippet": {
                    "text": "frame_num = b->refs[ref_id].frame_num;"
                }
            }
        },
        "function_code": "static int tegra_vde_h264_setup_frame(struct tegra_ctx *ctx,\n\t\t\t\t      struct tegra_vde_h264_decoder_ctx *h264,\n\t\t\t\t      struct v4l2_h264_reflist_builder *b,\n\t\t\t\t      struct vb2_buffer *vb,\n\t\t\t\t      unsigned int ref_id,\n\t\t\t\t      unsigned int id)\n{\n\tstruct v4l2_pix_format_mplane *pixfmt = &ctx->decoded_fmt.fmt.pix_mp;\n\tstruct tegra_m2m_buffer *tb = vb_to_tegra_buf(vb);\n\tstruct tegra_ctx_h264 *h = &ctx->h264;\n\tstruct tegra_vde *vde = ctx->vde;\n\tstruct device *dev = vde->dev;\n\tunsigned int cstride, lstride;\n\tunsigned int flags = 0;\n\tsize_t lsize, csize;\n\tint err, frame_num;\n\n\tlsize = h264->pic_width_in_mbs * 16 * h264->pic_height_in_mbs * 16;\n\tcsize = h264->pic_width_in_mbs *  8 * h264->pic_height_in_mbs *  8;\n\tlstride = pixfmt->plane_fmt[0].bytesperline;\n\tcstride = pixfmt->plane_fmt[1].bytesperline;\n\n\terr = tegra_vde_validate_vb_size(ctx, vb, 0, lsize);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_validate_vb_size(ctx, vb, 1, csize);\n\tif (err)\n\t\treturn err;\n\n\terr = tegra_vde_validate_vb_size(ctx, vb, 2, csize);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb->aux || tb->aux->size < csize) {\n\t\tdev_err(dev, \"Too small aux size %zd, should be at least %zu\\n\",\n\t\t\ttb->aux ? tb->aux->size : -1, csize);\n\t\treturn -EINVAL;\n\t}\n\n\tif (id == 0) {\n\t\tframe_num = h->decode_params->frame_num;\n\n\t\tif (h->decode_params->nal_ref_idc)\n\t\t\tflags |= FLAG_REFERENCE;\n\t} else {\n\t\tframe_num = b->refs[ref_id].frame_num;\n\t}\n\n\tif (tb->b_frame)\n\t\tflags |= FLAG_B_FRAME;\n\n\tvde->frames[id].flags = flags;\n\tvde->frames[id].y_addr = tb->dma_addr[0];\n\tvde->frames[id].cb_addr = tb->dma_addr[1];\n\tvde->frames[id].cr_addr = tb->dma_addr[2];\n\tvde->frames[id].aux_addr = tb->aux->dma_addr;\n\tvde->frames[id].frame_num = frame_num & 0x7fffff;\n\tvde->frames[id].luma_atoms_pitch = lstride / VDE_ATOM;\n\tvde->frames[id].chroma_atoms_pitch = cstride / VDE_ATOM;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "handler",
        "function_name": "hfi_process_msg_packet",
        "location": {
            "file_path": "drivers/media/platform/qcom/venus/hfi_msgs.c",
            "region": {
                "startLine": 792,
                "startColumn": 6,
                "endColumn": 13
            },
            "context": {
                "startLine": 790,
                "endLine": 794,
                "snippet": {
                    "text": "if (handler->is_sys_pkt) {"
                }
            }
        },
        "function_code": "u32 hfi_process_msg_packet(struct venus_core *core, struct hfi_pkt_hdr *hdr)\n{\n\tconst struct hfi_done_handler *handler;\n\tstruct device *dev = core->dev;\n\tstruct venus_inst *inst;\n\tbool found = false;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(handlers); i++) {\n\t\thandler = &handlers[i];\n\t\tif (handler->pkt != hdr->pkt_type)\n\t\t\tcontinue;\n\t\tfound = true;\n\t\tbreak;\n\t}\n\n\tif (!found)\n\t\treturn hdr->pkt_type;\n\n\tif (hdr->size && hdr->size < handler->pkt_sz &&\n\t    hdr->size < handler->pkt_sz2) {\n\t\tdev_err(dev, \"bad packet size (%d should be %d, pkt type:%x)\\n\",\n\t\t\thdr->size, handler->pkt_sz, hdr->pkt_type);\n\n\t\treturn hdr->pkt_type;\n\t}\n\n\tif (handler->is_sys_pkt) {\n\t\tinst = NULL;\n\t} else {\n\t\tstruct hfi_session_pkt *pkt;\n\n\t\tpkt = (struct hfi_session_pkt *)hdr;\n\t\tinst = to_instance(core, pkt->shdr.session_id);\n\n\t\tif (!inst)\n\t\t\tdev_warn(dev, \"no valid instance(pkt session_id:%x, pkt:%x)\\n\",\n\t\t\t\t pkt->shdr.session_id,\n\t\t\t\t handler ? handler->pkt : 0);\n\n\t\t/*\n\t\t * Event of type HFI_EVENT_SYS_ERROR will not have any session\n\t\t * associated with it\n\t\t */\n\t\tif (!inst && hdr->pkt_type != HFI_MSG_EVENT_NOTIFY) {\n\t\t\tdev_err(dev, \"got invalid session id:%x\\n\",\n\t\t\t\tpkt->shdr.session_id);\n\t\t\tgoto invalid_session;\n\t\t}\n\t}\n\n\thandler->done(core, inst, hdr);\n\ninvalid_session:\n\treturn hdr->pkt_type;\n}"
    },
    {
        "var_name": "inst",
        "function_name": "load_per_type",
        "location": {
            "file_path": "drivers/media/platform/qcom/venus/pm_helpers.c",
            "region": {
                "startLine": 167,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 165,
                "endLine": 169,
                "snippet": {
                    "text": "if (inst->session_type != session_type)"
                }
            }
        },
        "function_code": "static u32 load_per_type(struct venus_core *core, u32 session_type)\n{\n\tstruct venus_inst *inst = NULL;\n\tu32 mbs_per_sec = 0;\n\n\tlist_for_each_entry(inst, &core->instances, list) {\n\t\tif (inst->session_type != session_type)\n\t\t\tcontinue;\n\n\t\tmbs_per_sec += load_per_instance(inst);\n\t}\n\n\treturn mbs_per_sec;\n}"
    },
    {
        "var_name": "inst",
        "function_name": "mbs_to_bw",
        "location": {
            "file_path": "drivers/media/platform/qcom/venus/pm_helpers.c",
            "region": {
                "startLine": 178,
                "startColumn": 38,
                "endColumn": 42
            },
            "context": {
                "startLine": 176,
                "endLine": 180,
                "snippet": {
                    "text": "const struct venus_resources *res = inst->core->res;"
                }
            }
        },
        "function_code": "static void mbs_to_bw(struct venus_inst *inst, u32 mbs, u32 *avg, u32 *peak)\n{\n\tconst struct venus_resources *res = inst->core->res;\n\tconst struct bw_tbl *bw_tbl;\n\tunsigned int num_rows, i;\n\n\t*avg = 0;\n\t*peak = 0;\n\n\tif (mbs == 0)\n\t\treturn;\n\n\tif (inst->session_type == VIDC_SESSION_TYPE_ENC) {\n\t\tnum_rows = res->bw_tbl_enc_size;\n\t\tbw_tbl = res->bw_tbl_enc;\n\t} else if (inst->session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tnum_rows = res->bw_tbl_dec_size;\n\t\tbw_tbl = res->bw_tbl_dec;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (!bw_tbl || num_rows == 0)\n\t\treturn;\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tif (i != 0 && mbs > bw_tbl[i].mbs_per_sec)\n\t\t\tbreak;\n\n\t\tif (inst->dpb_fmt & HFI_COLOR_FORMAT_10_BIT_BASE) {\n\t\t\t*avg = bw_tbl[i].avg_10bit;\n\t\t\t*peak = bw_tbl[i].peak_10bit;\n\t\t} else {\n\t\t\t*avg = bw_tbl[i].avg;\n\t\t\t*peak = bw_tbl[i].peak;\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "inst",
        "function_name": "mbs_to_bw",
        "location": {
            "file_path": "drivers/media/platform/qcom/venus/pm_helpers.c",
            "region": {
                "startLine": 188,
                "startColumn": 6,
                "endColumn": 10
            },
            "context": {
                "startLine": 186,
                "endLine": 190,
                "snippet": {
                    "text": "if (inst->session_type == VIDC_SESSION_TYPE_ENC) {"
                }
            }
        },
        "function_code": "static void mbs_to_bw(struct venus_inst *inst, u32 mbs, u32 *avg, u32 *peak)\n{\n\tconst struct venus_resources *res = inst->core->res;\n\tconst struct bw_tbl *bw_tbl;\n\tunsigned int num_rows, i;\n\n\t*avg = 0;\n\t*peak = 0;\n\n\tif (mbs == 0)\n\t\treturn;\n\n\tif (inst->session_type == VIDC_SESSION_TYPE_ENC) {\n\t\tnum_rows = res->bw_tbl_enc_size;\n\t\tbw_tbl = res->bw_tbl_enc;\n\t} else if (inst->session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tnum_rows = res->bw_tbl_dec_size;\n\t\tbw_tbl = res->bw_tbl_dec;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (!bw_tbl || num_rows == 0)\n\t\treturn;\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tif (i != 0 && mbs > bw_tbl[i].mbs_per_sec)\n\t\t\tbreak;\n\n\t\tif (inst->dpb_fmt & HFI_COLOR_FORMAT_10_BIT_BASE) {\n\t\t\t*avg = bw_tbl[i].avg_10bit;\n\t\t\t*peak = bw_tbl[i].peak_10bit;\n\t\t} else {\n\t\t\t*avg = bw_tbl[i].avg;\n\t\t\t*peak = bw_tbl[i].peak;\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "inst",
        "function_name": "mbs_to_bw",
        "location": {
            "file_path": "drivers/media/platform/qcom/venus/pm_helpers.c",
            "region": {
                "startLine": 191,
                "startColumn": 13,
                "endColumn": 17
            },
            "context": {
                "startLine": 189,
                "endLine": 193,
                "snippet": {
                    "text": "} else if (inst->session_type == VIDC_SESSION_TYPE_DEC) {"
                }
            }
        },
        "function_code": "static void mbs_to_bw(struct venus_inst *inst, u32 mbs, u32 *avg, u32 *peak)\n{\n\tconst struct venus_resources *res = inst->core->res;\n\tconst struct bw_tbl *bw_tbl;\n\tunsigned int num_rows, i;\n\n\t*avg = 0;\n\t*peak = 0;\n\n\tif (mbs == 0)\n\t\treturn;\n\n\tif (inst->session_type == VIDC_SESSION_TYPE_ENC) {\n\t\tnum_rows = res->bw_tbl_enc_size;\n\t\tbw_tbl = res->bw_tbl_enc;\n\t} else if (inst->session_type == VIDC_SESSION_TYPE_DEC) {\n\t\tnum_rows = res->bw_tbl_dec_size;\n\t\tbw_tbl = res->bw_tbl_dec;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (!bw_tbl || num_rows == 0)\n\t\treturn;\n\n\tfor (i = 0; i < num_rows; i++) {\n\t\tif (i != 0 && mbs > bw_tbl[i].mbs_per_sec)\n\t\t\tbreak;\n\n\t\tif (inst->dpb_fmt & HFI_COLOR_FORMAT_10_BIT_BASE) {\n\t\t\t*avg = bw_tbl[i].avg_10bit;\n\t\t\t*peak = bw_tbl[i].peak_10bit;\n\t\t} else {\n\t\t\t*avg = bw_tbl[i].avg;\n\t\t\t*peak = bw_tbl[i].peak;\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "inst",
        "function_name": "power_save_mode_enable",
        "location": {
            "file_path": "drivers/media/platform/qcom/venus/pm_helpers.c",
            "region": {
                "startLine": 533,
                "startColumn": 6,
                "endColumn": 10
            },
            "context": {
                "startLine": 531,
                "endLine": 535,
                "snippet": {
                    "text": "if (inst->session_type != VIDC_SESSION_TYPE_ENC)"
                }
            }
        },
        "function_code": "static inline int power_save_mode_enable(struct venus_inst *inst,\n\t\t\t\t\t bool enable)\n{\n\tstruct venc_controls *enc_ctr = &inst->controls.enc;\n\tconst u32 ptype = HFI_PROPERTY_CONFIG_VENC_PERF_MODE;\n\tu32 venc_mode;\n\tint ret = 0;\n\n\tif (inst->session_type != VIDC_SESSION_TYPE_ENC)\n\t\treturn 0;\n\n\tif (enc_ctr->bitrate_mode == V4L2_MPEG_VIDEO_BITRATE_MODE_CQ)\n\t\tenable = false;\n\n\tvenc_mode = enable ? HFI_VENC_PERFMODE_POWER_SAVE :\n\t\tHFI_VENC_PERFMODE_MAX_QUALITY;\n\n\tret = hfi_session_set_property(inst, ptype, &venc_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tinst->flags = enable ? inst->flags | VENUS_LOW_POWER :\n\t\tinst->flags & ~VENUS_LOW_POWER;\n\n\treturn ret;\n}"
    },
    {
        "var_name": "inst",
        "function_name": "move_core_to_power_save_mode",
        "location": {
            "file_path": "drivers/media/platform/qcom/venus/pm_helpers.c",
            "region": {
                "startLine": 559,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 557,
                "endLine": 561,
                "snippet": {
                    "text": "if (inst->clk_data.core_id == core_id &&"
                }
            }
        },
        "function_code": "static int move_core_to_power_save_mode(struct venus_core *core,\n\t\t\t\t\tu32 core_id)\n{\n\tstruct venus_inst *inst = NULL;\n\n\tmutex_lock(&core->lock);\n\tlist_for_each_entry(inst, &core->instances, list) {\n\t\tif (inst->clk_data.core_id == core_id &&\n\t\t    inst->session_type == VIDC_SESSION_TYPE_ENC)\n\t\t\tpower_save_mode_enable(inst, true);\n\t}\n\tmutex_unlock(&core->lock);\n\treturn 0;\n}"
    },
    {
        "var_name": "inst",
        "function_name": "move_core_to_power_save_mode",
        "location": {
            "file_path": "drivers/media/platform/qcom/venus/pm_helpers.c",
            "region": {
                "startLine": 560,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 558,
                "endLine": 562,
                "snippet": {
                    "text": "inst->session_type == VIDC_SESSION_TYPE_ENC)"
                }
            }
        },
        "function_code": "static int move_core_to_power_save_mode(struct venus_core *core,\n\t\t\t\t\tu32 core_id)\n{\n\tstruct venus_inst *inst = NULL;\n\n\tmutex_lock(&core->lock);\n\tlist_for_each_entry(inst, &core->instances, list) {\n\t\tif (inst->clk_data.core_id == core_id &&\n\t\t    inst->session_type == VIDC_SESSION_TYPE_ENC)\n\t\t\tpower_save_mode_enable(inst, true);\n\t}\n\tmutex_unlock(&core->lock);\n\treturn 0;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "rga_isr",
        "location": {
            "file_path": "drivers/media/platform/rockchip/rga/rga.c",
            "region": {
                "startLine": 70,
                "startColumn": 33,
                "endColumn": 36
            },
            "context": {
                "startLine": 68,
                "endLine": 72,
                "snippet": {
                    "text": "src = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);"
                }
            }
        },
        "function_code": "static irqreturn_t rga_isr(int irq, void *prv)\n{\n\tstruct rockchip_rga *rga = prv;\n\tint intr;\n\n\tintr = rga_read(rga, RGA_INT) & 0xf;\n\n\trga_mod(rga, RGA_INT, intr << 4, 0xf << 4);\n\n\tif (intr & 0x04) {\n\t\tstruct vb2_v4l2_buffer *src, *dst;\n\t\tstruct rga_ctx *ctx = rga->curr;\n\n\t\tWARN_ON(!ctx);\n\n\t\trga->curr = NULL;\n\n\t\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tWARN_ON(!src);\n\t\tWARN_ON(!dst);\n\n\t\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\t\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_job_finish(rga->m2m_dev, ctx->fh.m2m_ctx);\n\t}\n\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "rga_isr",
        "location": {
            "file_path": "drivers/media/platform/rockchip/rga/rga.c",
            "region": {
                "startLine": 71,
                "startColumn": 33,
                "endColumn": 36
            },
            "context": {
                "startLine": 69,
                "endLine": 73,
                "snippet": {
                    "text": "dst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);"
                }
            }
        },
        "function_code": "static irqreturn_t rga_isr(int irq, void *prv)\n{\n\tstruct rockchip_rga *rga = prv;\n\tint intr;\n\n\tintr = rga_read(rga, RGA_INT) & 0xf;\n\n\trga_mod(rga, RGA_INT, intr << 4, 0xf << 4);\n\n\tif (intr & 0x04) {\n\t\tstruct vb2_v4l2_buffer *src, *dst;\n\t\tstruct rga_ctx *ctx = rga->curr;\n\n\t\tWARN_ON(!ctx);\n\n\t\trga->curr = NULL;\n\n\t\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tWARN_ON(!src);\n\t\tWARN_ON(!dst);\n\n\t\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\t\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_job_finish(rga->m2m_dev, ctx->fh.m2m_ctx);\n\t}\n\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "rga_isr",
        "location": {
            "file_path": "drivers/media/platform/rockchip/rga/rga.c",
            "region": {
                "startLine": 80,
                "startColumn": 37,
                "endColumn": 40
            },
            "context": {
                "startLine": 78,
                "endLine": 82,
                "snippet": {
                    "text": "v4l2_m2m_job_finish(rga->m2m_dev, ctx->fh.m2m_ctx);"
                }
            }
        },
        "function_code": "static irqreturn_t rga_isr(int irq, void *prv)\n{\n\tstruct rockchip_rga *rga = prv;\n\tint intr;\n\n\tintr = rga_read(rga, RGA_INT) & 0xf;\n\n\trga_mod(rga, RGA_INT, intr << 4, 0xf << 4);\n\n\tif (intr & 0x04) {\n\t\tstruct vb2_v4l2_buffer *src, *dst;\n\t\tstruct rga_ctx *ctx = rga->curr;\n\n\t\tWARN_ON(!ctx);\n\n\t\trga->curr = NULL;\n\n\t\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\t\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\t\tWARN_ON(!src);\n\t\tWARN_ON(!dst);\n\n\t\tv4l2_m2m_buf_copy_metadata(src, dst, true);\n\n\t\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\t\tv4l2_m2m_job_finish(rga->m2m_dev, ctx->fh.m2m_ctx);\n\t}\n\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "me",
        "function_name": "entity_to_fimc_mdev",
        "location": {
            "file_path": "drivers/media/platform/samsung/exynos4-is/media-dev.h",
            "region": {
                "startLine": 157,
                "startColumn": 9,
                "endColumn": 11
            },
            "context": {
                "startLine": 155,
                "endLine": 159,
                "snippet": {
                    "text": "return me->graph_obj.mdev == NULL ? NULL :"
                }
            }
        },
        "function_code": "static inline struct fimc_md *entity_to_fimc_mdev(struct media_entity *me)\n{\n\treturn me->graph_obj.mdev == NULL ? NULL :\n\t\tcontainer_of(me->graph_obj.mdev, struct fimc_md, media_dev);\n}"
    },
    {
        "var_name": "p",
        "function_name": "fimc_pipeline_s_power",
        "location": {
            "file_path": "drivers/media/platform/samsung/exynos4-is/media-dev.c",
            "region": {
                "startLine": 164,
                "startColumn": 6,
                "endColumn": 7
            },
            "context": {
                "startLine": 162,
                "endLine": 166,
                "snippet": {
                    "text": "if (p->subdevs[IDX_SENSOR] == NULL)"
                }
            }
        },
        "function_code": "static int fimc_pipeline_s_power(struct fimc_pipeline *p, bool on)\n{\n\tstatic const u8 seq[2][IDX_MAX - 1] = {\n\t\t{ IDX_IS_ISP, IDX_SENSOR, IDX_CSIS, IDX_FLITE },\n\t\t{ IDX_CSIS, IDX_FLITE, IDX_SENSOR, IDX_IS_ISP },\n\t};\n\tint i, ret = 0;\n\n\tif (p->subdevs[IDX_SENSOR] == NULL)\n\t\treturn -ENXIO;\n\n\tfor (i = 0; i < IDX_MAX - 1; i++) {\n\t\tunsigned int idx = seq[on][i];\n\n\t\tret = __subdev_set_power(p->subdevs[idx], on);\n\n\n\t\tif (ret < 0 && ret != -ENXIO)\n\t\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tfor (; i >= 0; i--) {\n\t\tunsigned int idx = seq[on][i];\n\t\t__subdev_set_power(p->subdevs[idx], !on);\n\t}\n\treturn ret;\n}"
    },
    {
        "var_name": "p",
        "function_name": "__fimc_pipeline_close",
        "location": {
            "file_path": "drivers/media/platform/samsung/exynos4-is/media-dev.c",
            "region": {
                "startLine": 274,
                "startColumn": 43,
                "endColumn": 44
            },
            "context": {
                "startLine": 272,
                "endLine": 276,
                "snippet": {
                    "text": "if (!IS_ERR(fmd->wbclk[CLK_IDX_WB_B]) && p->subdevs[IDX_IS_ISP])"
                }
            }
        },
        "function_code": "static int __fimc_pipeline_close(struct exynos_media_pipeline *ep)\n{\n\tstruct fimc_pipeline *p = to_fimc_pipeline(ep);\n\tstruct v4l2_subdev *sd = p ? p->subdevs[IDX_SENSOR] : NULL;\n\tstruct fimc_md *fmd;\n\tint ret;\n\n\tif (sd == NULL) {\n\t\tpr_warn(\"%s(): No sensor subdev\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tret = fimc_pipeline_s_power(p, 0);\n\n\tfmd = entity_to_fimc_mdev(&sd->entity);\n\n\t/* Disable PXLASYNC clock if this pipeline includes FIMC-IS */\n\tif (!IS_ERR(fmd->wbclk[CLK_IDX_WB_B]) && p->subdevs[IDX_IS_ISP])\n\t\tclk_disable_unprepare(fmd->wbclk[CLK_IDX_WB_B]);\n\n\treturn ret == -ENXIO ? 0 : ret;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 553,
                "startColumn": 32,
                "endColumn": 35
            },
            "context": {
                "startLine": 551,
                "endLine": 555,
                "snippet": {
                    "text": "src = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);"
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 554,
                "startColumn": 32,
                "endColumn": 35
            },
            "context": {
                "startLine": 552,
                "endLine": 556,
                "snippet": {
                    "text": "dst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);"
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "dst",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 559,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 557,
                "endLine": 561,
                "snippet": {
                    "text": "dst->timecode = src->timecode;"
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "src",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 559,
                "startColumn": 18,
                "endColumn": 21
            },
            "context": {
                "startLine": 557,
                "endLine": 561,
                "snippet": {
                    "text": "dst->timecode = src->timecode;"
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "dst",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 560,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 558,
                "endLine": 562,
                "snippet": {
                    "text": "dst->vb2_buf.timestamp = src->vb2_buf.timestamp;"
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "src",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 560,
                "startColumn": 27,
                "endColumn": 30
            },
            "context": {
                "startLine": 558,
                "endLine": 562,
                "snippet": {
                    "text": "dst->vb2_buf.timestamp = src->vb2_buf.timestamp;"
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "dst",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 561,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 559,
                "endLine": 563,
                "snippet": {
                    "text": "dst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;"
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "dst",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 562,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 560,
                "endLine": 564,
                "snippet": {
                    "text": "dst->flags |="
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "g2d_isr",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-g2d/g2d.c",
            "region": {
                "startLine": 567,
                "startColumn": 36,
                "endColumn": 39
            },
            "context": {
                "startLine": 565,
                "endLine": 569,
                "snippet": {
                    "text": "v4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);"
                }
            }
        },
        "function_code": "static irqreturn_t g2d_isr(int irq, void *prv)\n{\n\tstruct g2d_dev *dev = prv;\n\tstruct g2d_ctx *ctx = dev->curr;\n\tstruct vb2_v4l2_buffer *src, *dst;\n\n\tg2d_clear_int(dev);\n\tclk_disable(dev->gate);\n\n\tBUG_ON(ctx == NULL);\n\n\tsrc = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\n\tdst = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\n\n\tBUG_ON(src == NULL);\n\tBUG_ON(dst == NULL);\n\n\tdst->timecode = src->timecode;\n\tdst->vb2_buf.timestamp = src->vb2_buf.timestamp;\n\tdst->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\tdst->flags |=\n\t\tsrc->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\n\n\tv4l2_m2m_buf_done(src, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_buf_done(dst, VB2_BUF_STATE_DONE);\n\tv4l2_m2m_job_finish(dev->m2m_dev, ctx->fh.m2m_ctx);\n\n\tdev->curr = NULL;\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "q_data",
        "function_name": "s5p_jpeg_g_fmt",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c",
            "region": {
                "startLine": 1346,
                "startColumn": 15,
                "endColumn": 21
            },
            "context": {
                "startLine": 1344,
                "endLine": 1348,
                "snippet": {
                    "text": "pix->width = q_data->w;"
                }
            }
        },
        "function_code": "static int s5p_jpeg_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct s5p_jpeg_ctx *ct = fh_to_ctx(priv);\n\n\tvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    ct->mode == S5P_JPEG_DECODE && !ct->hdr_parsed)\n\t\treturn -EINVAL;\n\tq_data = get_q_data(ct, f->type);\n\tBUG_ON(q_data == NULL);\n\n\tpix->width = q_data->w;\n\tpix->height = q_data->h;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->pixelformat = q_data->fmt->fourcc;\n\tpix->bytesperline = 0;\n\tif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\n\t\tu32 bpl = q_data->w;\n\n\t\tif (q_data->fmt->colplanes == 1)\n\t\t\tbpl = (bpl * q_data->fmt->depth) >> 3;\n\t\tpix->bytesperline = bpl;\n\t}\n\tpix->sizeimage = q_data->size;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "q_data",
        "function_name": "s5p_jpeg_g_fmt",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c",
            "region": {
                "startLine": 1347,
                "startColumn": 16,
                "endColumn": 22
            },
            "context": {
                "startLine": 1345,
                "endLine": 1349,
                "snippet": {
                    "text": "pix->height = q_data->h;"
                }
            }
        },
        "function_code": "static int s5p_jpeg_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct s5p_jpeg_ctx *ct = fh_to_ctx(priv);\n\n\tvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    ct->mode == S5P_JPEG_DECODE && !ct->hdr_parsed)\n\t\treturn -EINVAL;\n\tq_data = get_q_data(ct, f->type);\n\tBUG_ON(q_data == NULL);\n\n\tpix->width = q_data->w;\n\tpix->height = q_data->h;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->pixelformat = q_data->fmt->fourcc;\n\tpix->bytesperline = 0;\n\tif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\n\t\tu32 bpl = q_data->w;\n\n\t\tif (q_data->fmt->colplanes == 1)\n\t\t\tbpl = (bpl * q_data->fmt->depth) >> 3;\n\t\tpix->bytesperline = bpl;\n\t}\n\tpix->sizeimage = q_data->size;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "q_data",
        "function_name": "s5p_jpeg_g_fmt",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c",
            "region": {
                "startLine": 1349,
                "startColumn": 21,
                "endColumn": 27
            },
            "context": {
                "startLine": 1347,
                "endLine": 1351,
                "snippet": {
                    "text": "pix->pixelformat = q_data->fmt->fourcc;"
                }
            }
        },
        "function_code": "static int s5p_jpeg_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct s5p_jpeg_ctx *ct = fh_to_ctx(priv);\n\n\tvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    ct->mode == S5P_JPEG_DECODE && !ct->hdr_parsed)\n\t\treturn -EINVAL;\n\tq_data = get_q_data(ct, f->type);\n\tBUG_ON(q_data == NULL);\n\n\tpix->width = q_data->w;\n\tpix->height = q_data->h;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->pixelformat = q_data->fmt->fourcc;\n\tpix->bytesperline = 0;\n\tif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\n\t\tu32 bpl = q_data->w;\n\n\t\tif (q_data->fmt->colplanes == 1)\n\t\t\tbpl = (bpl * q_data->fmt->depth) >> 3;\n\t\tpix->bytesperline = bpl;\n\t}\n\tpix->sizeimage = q_data->size;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "q_data",
        "function_name": "s5p_jpeg_g_fmt",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c",
            "region": {
                "startLine": 1351,
                "startColumn": 6,
                "endColumn": 12
            },
            "context": {
                "startLine": 1349,
                "endLine": 1353,
                "snippet": {
                    "text": "if (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {"
                }
            }
        },
        "function_code": "static int s5p_jpeg_g_fmt(struct file *file, void *priv, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct s5p_jpeg_ctx *ct = fh_to_ctx(priv);\n\n\tvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tif (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE &&\n\t    ct->mode == S5P_JPEG_DECODE && !ct->hdr_parsed)\n\t\treturn -EINVAL;\n\tq_data = get_q_data(ct, f->type);\n\tBUG_ON(q_data == NULL);\n\n\tpix->width = q_data->w;\n\tpix->height = q_data->h;\n\tpix->field = V4L2_FIELD_NONE;\n\tpix->pixelformat = q_data->fmt->fourcc;\n\tpix->bytesperline = 0;\n\tif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\n\t\tu32 bpl = q_data->w;\n\n\t\tif (q_data->fmt->colplanes == 1)\n\t\t\tbpl = (bpl * q_data->fmt->depth) >> 3;\n\t\tpix->bytesperline = bpl;\n\t}\n\tpix->sizeimage = q_data->size;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "q_data",
        "function_name": "s5p_jpeg_s_fmt",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c",
            "region": {
                "startLine": 1606,
                "startColumn": 2,
                "endColumn": 8
            },
            "context": {
                "startLine": 1604,
                "endLine": 1608,
                "snippet": {
                    "text": "q_data->fmt = s5p_jpeg_find_format(ct, pix->pixelformat, f_type);"
                }
            }
        },
        "function_code": "static int s5p_jpeg_s_fmt(struct s5p_jpeg_ctx *ct, struct v4l2_format *f)\n{\n\tstruct vb2_queue *vq;\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tstruct v4l2_pix_format *pix = &f->fmt.pix;\n\tstruct v4l2_ctrl *ctrl_subs;\n\tstruct v4l2_rect scale_rect;\n\tunsigned int f_type;\n\n\tvq = v4l2_m2m_get_vq(ct->fh.m2m_ctx, f->type);\n\tif (!vq)\n\t\treturn -EINVAL;\n\n\tq_data = get_q_data(ct, f->type);\n\tBUG_ON(q_data == NULL);\n\n\tif (vb2_is_busy(vq)) {\n\t\tv4l2_err(&ct->jpeg->v4l2_dev, \"%s queue busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tf_type = V4L2_TYPE_IS_OUTPUT(f->type) ?\n\t\t\tFMT_TYPE_OUTPUT : FMT_TYPE_CAPTURE;\n\n\tq_data->fmt = s5p_jpeg_find_format(ct, pix->pixelformat, f_type);\n\tif (ct->mode == S5P_JPEG_ENCODE ||\n\t\t(ct->mode == S5P_JPEG_DECODE &&\n\t\tq_data->fmt->fourcc != V4L2_PIX_FMT_JPEG)) {\n\t\tq_data->w = pix->width;\n\t\tq_data->h = pix->height;\n\t}\n\tif (q_data->fmt->fourcc != V4L2_PIX_FMT_JPEG) {\n\t\t/*\n\t\t * During encoding Exynos4x12 SoCs access wider memory area\n\t\t * than it results from Image_x and Image_y values written to\n\t\t * the JPEG_IMAGE_SIZE register. In order to avoid sysmmu\n\t\t * page fault calculate proper buffer size in such a case.\n\t\t */\n\t\tif (ct->jpeg->variant->hw_ex4_compat &&\n\t\t    f_type == FMT_TYPE_OUTPUT && ct->mode == S5P_JPEG_ENCODE)\n\t\t\tq_data->size = exynos4_jpeg_get_output_buffer_size(ct,\n\t\t\t\t\t\t\tf,\n\t\t\t\t\t\t\tq_data->fmt->depth);\n\t\telse\n\t\t\tq_data->size = q_data->w * q_data->h *\n\t\t\t\t\t\tq_data->fmt->depth >> 3;\n\t} else {\n\t\tq_data->size = pix->sizeimage;\n\t}\n\n\tif (f_type == FMT_TYPE_OUTPUT) {\n\t\tctrl_subs = v4l2_ctrl_find(&ct->ctrl_handler,\n\t\t\t\t\tV4L2_CID_JPEG_CHROMA_SUBSAMPLING);\n\t\tif (ctrl_subs)\n\t\t\tv4l2_ctrl_s_ctrl(ctrl_subs, q_data->fmt->subsampling);\n\t\tct->crop_altered = false;\n\t}\n\n\t/*\n\t * For decoding init crop_rect with capture buffer dimmensions which\n\t * contain aligned dimensions of the input JPEG image and do it only\n\t * if crop rectangle hasn't been altered by the user space e.g. with\n\t * S_SELECTION ioctl. For encoding assign output buffer dimensions.\n\t */\n\tif (!ct->crop_altered &&\n\t    ((ct->mode == S5P_JPEG_DECODE && f_type == FMT_TYPE_CAPTURE) ||\n\t     (ct->mode == S5P_JPEG_ENCODE && f_type == FMT_TYPE_OUTPUT))) {\n\t\tct->crop_rect.width = pix->width;\n\t\tct->crop_rect.height = pix->height;\n\t}\n\n\t/*\n\t * Prevent downscaling to YUV420 format by more than 2\n\t * for Exynos3250/compatible SoC as it produces broken raw image\n\t * in such cases.\n\t */\n\tif (ct->mode == S5P_JPEG_DECODE &&\n\t    f_type == FMT_TYPE_CAPTURE &&\n\t    ct->jpeg->variant->hw3250_compat &&\n\t    pix->pixelformat == V4L2_PIX_FMT_YUV420 &&\n\t    ct->scale_factor > 2) {\n\t\tscale_rect.width = ct->out_q.w / 2;\n\t\tscale_rect.height = ct->out_q.h / 2;\n\t\texynos3250_jpeg_try_downscale(ct, &scale_rect);\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": "q_data",
        "function_name": "s5p_jpeg_queue_setup",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c",
            "region": {
                "startLine": 2458,
                "startColumn": 9,
                "endColumn": 15
            },
            "context": {
                "startLine": 2456,
                "endLine": 2460,
                "snippet": {
                    "text": "size = q_data->size;"
                }
            }
        },
        "function_code": "static int s5p_jpeg_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vq);\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\tunsigned int size, count = *nbuffers;\n\n\tq_data = get_q_data(ctx, vq->type);\n\tBUG_ON(q_data == NULL);\n\n\tsize = q_data->size;\n\n\t/*\n\t * header is parsed during decoding and parsed information stored\n\t * in the context so we do not allow another buffer to overwrite it\n\t */\n\tif (ctx->mode == S5P_JPEG_DECODE)\n\t\tcount = 1;\n\n\t*nbuffers = count;\n\t*nplanes = 1;\n\tsizes[0] = size;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "q_data",
        "function_name": "s5p_jpeg_buf_prepare",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-jpeg/jpeg-core.c",
            "region": {
                "startLine": 2482,
                "startColumn": 30,
                "endColumn": 36
            },
            "context": {
                "startLine": 2480,
                "endLine": 2484,
                "snippet": {
                    "text": "if (vb2_plane_size(vb, 0) < q_data->size) {"
                }
            }
        },
        "function_code": "static int s5p_jpeg_buf_prepare(struct vb2_buffer *vb)\n{\n\tstruct s5p_jpeg_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct s5p_jpeg_q_data *q_data = NULL;\n\n\tq_data = get_q_data(ctx, vb->vb2_queue->type);\n\tBUG_ON(q_data == NULL);\n\n\tif (vb2_plane_size(vb, 0) < q_data->size) {\n\t\tpr_err(\"%s data will not fit into plane (%lu < %lu)\\n\",\n\t\t\t\t__func__, vb2_plane_size(vb, 0),\n\t\t\t\t(long)q_data->size);\n\t\treturn -EINVAL;\n\t}\n\n\tvb2_set_plane_payload(vb, 0, q_data->size);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "s5p_mfc_irq",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c",
            "region": {
                "startLine": 706,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 704,
                "endLine": 708,
                "snippet": {
                    "text": "ctx->inst_no = s5p_mfc_hw_call(dev->mfc_ops, get_inst_no, dev);"
                }
            }
        },
        "function_code": "static irqreturn_t s5p_mfc_irq(int irq, void *priv)\n{\n\tstruct s5p_mfc_dev *dev = priv;\n\tstruct s5p_mfc_ctx *ctx;\n\tunsigned int reason;\n\tunsigned int err;\n\n\tmfc_debug_enter();\n\t/* Reset the timeout watchdog */\n\tatomic_set(&dev->watchdog_cnt, 0);\n\tspin_lock(&dev->irqlock);\n\tctx = dev->ctx[dev->curr_ctx];\n\t/* Get the reason of interrupt and the error code */\n\treason = s5p_mfc_hw_call(dev->mfc_ops, get_int_reason, dev);\n\terr = s5p_mfc_hw_call(dev->mfc_ops, get_int_err, dev);\n\tmfc_debug(1, \"Int reason: %d (err: %08x)\\n\", reason, err);\n\tswitch (reason) {\n\tcase S5P_MFC_R2H_CMD_ERR_RET:\n\t\t/* An error has occurred */\n\t\tif (ctx->state == MFCINST_RUNNING &&\n\t\t\t(s5p_mfc_hw_call(dev->mfc_ops, err_dec, err) >=\n\t\t\t\tdev->warn_start ||\n\t\t\t\terr == S5P_FIMV_ERR_NO_VALID_SEQ_HDR ||\n\t\t\t\terr == S5P_FIMV_ERR_INCOMPLETE_FRAME ||\n\t\t\t\terr == S5P_FIMV_ERR_TIMEOUT))\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\telse\n\t\t\ts5p_mfc_handle_error(dev, ctx, reason, err);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SLICE_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FIELD_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FRAME_DONE_RET:\n\t\tif (ctx->c_ops->post_frame_start) {\n\t\t\tif (ctx->c_ops->post_frame_start(ctx))\n\t\t\t\tmfc_err(\"post_frame_start() failed\\n\");\n\n\t\t\tif (ctx->state == MFCINST_FINISHING &&\n\t\t\t\t\t\tlist_empty(&ctx->ref_queue)) {\n\t\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\t\t\ts5p_mfc_clock_off(dev);\n\t\t\twake_up_ctx(ctx, reason, err);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\t} else {\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\t}\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SEQ_DONE_RET:\n\t\ts5p_mfc_handle_seq_done(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_OPEN_INSTANCE_RET:\n\t\tctx->inst_no = s5p_mfc_hw_call(dev->mfc_ops, get_inst_no, dev);\n\t\tctx->state = MFCINST_GOT_INST;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_CLOSE_INSTANCE_RET:\n\t\tctx->inst_no = MFC_NO_INSTANCE_SET;\n\t\tctx->state = MFCINST_FREE;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_SYS_INIT_RET:\n\tcase S5P_MFC_R2H_CMD_FW_STATUS_RET:\n\tcase S5P_MFC_R2H_CMD_SLEEP_RET:\n\tcase S5P_MFC_R2H_CMD_WAKEUP_RET:\n\t\tif (ctx)\n\t\t\tclear_work_bit(ctx);\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tclear_bit(0, &dev->hw_lock);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\twake_up_dev(dev, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_INIT_BUFFERS_RET:\n\t\ts5p_mfc_handle_init_buffers(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_COMPLETE_SEQ_RET:\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tctx->int_type = reason;\n\t\tctx->int_err = err;\n\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_DPB_FLUSH_RET:\n\t\tctx->state = MFCINST_RUNNING;\n\t\tgoto irq_cleanup_hw;\n\n\tdefault:\n\t\tmfc_debug(2, \"Unknown int reason\\n\");\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t}\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug_leave();\n\treturn IRQ_HANDLED;\nirq_cleanup_hw:\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\tctx->int_type = reason;\n\tctx->int_err = err;\n\tctx->int_cond = 1;\n\tif (test_and_clear_bit(0, &dev->hw_lock) == 0)\n\t\tmfc_err(\"Failed to unlock hw\\n\");\n\n\ts5p_mfc_clock_off(dev);\n\tclear_work_bit(ctx);\n\twake_up(&ctx->queue);\n\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug(2, \"Exit via irq_cleanup_hw\\n\");\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "s5p_mfc_irq",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c",
            "region": {
                "startLine": 707,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 705,
                "endLine": 709,
                "snippet": {
                    "text": "ctx->state = MFCINST_GOT_INST;"
                }
            }
        },
        "function_code": "static irqreturn_t s5p_mfc_irq(int irq, void *priv)\n{\n\tstruct s5p_mfc_dev *dev = priv;\n\tstruct s5p_mfc_ctx *ctx;\n\tunsigned int reason;\n\tunsigned int err;\n\n\tmfc_debug_enter();\n\t/* Reset the timeout watchdog */\n\tatomic_set(&dev->watchdog_cnt, 0);\n\tspin_lock(&dev->irqlock);\n\tctx = dev->ctx[dev->curr_ctx];\n\t/* Get the reason of interrupt and the error code */\n\treason = s5p_mfc_hw_call(dev->mfc_ops, get_int_reason, dev);\n\terr = s5p_mfc_hw_call(dev->mfc_ops, get_int_err, dev);\n\tmfc_debug(1, \"Int reason: %d (err: %08x)\\n\", reason, err);\n\tswitch (reason) {\n\tcase S5P_MFC_R2H_CMD_ERR_RET:\n\t\t/* An error has occurred */\n\t\tif (ctx->state == MFCINST_RUNNING &&\n\t\t\t(s5p_mfc_hw_call(dev->mfc_ops, err_dec, err) >=\n\t\t\t\tdev->warn_start ||\n\t\t\t\terr == S5P_FIMV_ERR_NO_VALID_SEQ_HDR ||\n\t\t\t\terr == S5P_FIMV_ERR_INCOMPLETE_FRAME ||\n\t\t\t\terr == S5P_FIMV_ERR_TIMEOUT))\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\telse\n\t\t\ts5p_mfc_handle_error(dev, ctx, reason, err);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SLICE_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FIELD_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FRAME_DONE_RET:\n\t\tif (ctx->c_ops->post_frame_start) {\n\t\t\tif (ctx->c_ops->post_frame_start(ctx))\n\t\t\t\tmfc_err(\"post_frame_start() failed\\n\");\n\n\t\t\tif (ctx->state == MFCINST_FINISHING &&\n\t\t\t\t\t\tlist_empty(&ctx->ref_queue)) {\n\t\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\t\t\ts5p_mfc_clock_off(dev);\n\t\t\twake_up_ctx(ctx, reason, err);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\t} else {\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\t}\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SEQ_DONE_RET:\n\t\ts5p_mfc_handle_seq_done(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_OPEN_INSTANCE_RET:\n\t\tctx->inst_no = s5p_mfc_hw_call(dev->mfc_ops, get_inst_no, dev);\n\t\tctx->state = MFCINST_GOT_INST;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_CLOSE_INSTANCE_RET:\n\t\tctx->inst_no = MFC_NO_INSTANCE_SET;\n\t\tctx->state = MFCINST_FREE;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_SYS_INIT_RET:\n\tcase S5P_MFC_R2H_CMD_FW_STATUS_RET:\n\tcase S5P_MFC_R2H_CMD_SLEEP_RET:\n\tcase S5P_MFC_R2H_CMD_WAKEUP_RET:\n\t\tif (ctx)\n\t\t\tclear_work_bit(ctx);\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tclear_bit(0, &dev->hw_lock);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\twake_up_dev(dev, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_INIT_BUFFERS_RET:\n\t\ts5p_mfc_handle_init_buffers(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_COMPLETE_SEQ_RET:\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tctx->int_type = reason;\n\t\tctx->int_err = err;\n\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_DPB_FLUSH_RET:\n\t\tctx->state = MFCINST_RUNNING;\n\t\tgoto irq_cleanup_hw;\n\n\tdefault:\n\t\tmfc_debug(2, \"Unknown int reason\\n\");\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t}\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug_leave();\n\treturn IRQ_HANDLED;\nirq_cleanup_hw:\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\tctx->int_type = reason;\n\tctx->int_err = err;\n\tctx->int_cond = 1;\n\tif (test_and_clear_bit(0, &dev->hw_lock) == 0)\n\t\tmfc_err(\"Failed to unlock hw\\n\");\n\n\ts5p_mfc_clock_off(dev);\n\tclear_work_bit(ctx);\n\twake_up(&ctx->queue);\n\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug(2, \"Exit via irq_cleanup_hw\\n\");\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "s5p_mfc_irq",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c",
            "region": {
                "startLine": 711,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 709,
                "endLine": 713,
                "snippet": {
                    "text": "ctx->inst_no = MFC_NO_INSTANCE_SET;"
                }
            }
        },
        "function_code": "static irqreturn_t s5p_mfc_irq(int irq, void *priv)\n{\n\tstruct s5p_mfc_dev *dev = priv;\n\tstruct s5p_mfc_ctx *ctx;\n\tunsigned int reason;\n\tunsigned int err;\n\n\tmfc_debug_enter();\n\t/* Reset the timeout watchdog */\n\tatomic_set(&dev->watchdog_cnt, 0);\n\tspin_lock(&dev->irqlock);\n\tctx = dev->ctx[dev->curr_ctx];\n\t/* Get the reason of interrupt and the error code */\n\treason = s5p_mfc_hw_call(dev->mfc_ops, get_int_reason, dev);\n\terr = s5p_mfc_hw_call(dev->mfc_ops, get_int_err, dev);\n\tmfc_debug(1, \"Int reason: %d (err: %08x)\\n\", reason, err);\n\tswitch (reason) {\n\tcase S5P_MFC_R2H_CMD_ERR_RET:\n\t\t/* An error has occurred */\n\t\tif (ctx->state == MFCINST_RUNNING &&\n\t\t\t(s5p_mfc_hw_call(dev->mfc_ops, err_dec, err) >=\n\t\t\t\tdev->warn_start ||\n\t\t\t\terr == S5P_FIMV_ERR_NO_VALID_SEQ_HDR ||\n\t\t\t\terr == S5P_FIMV_ERR_INCOMPLETE_FRAME ||\n\t\t\t\terr == S5P_FIMV_ERR_TIMEOUT))\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\telse\n\t\t\ts5p_mfc_handle_error(dev, ctx, reason, err);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SLICE_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FIELD_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FRAME_DONE_RET:\n\t\tif (ctx->c_ops->post_frame_start) {\n\t\t\tif (ctx->c_ops->post_frame_start(ctx))\n\t\t\t\tmfc_err(\"post_frame_start() failed\\n\");\n\n\t\t\tif (ctx->state == MFCINST_FINISHING &&\n\t\t\t\t\t\tlist_empty(&ctx->ref_queue)) {\n\t\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\t\t\ts5p_mfc_clock_off(dev);\n\t\t\twake_up_ctx(ctx, reason, err);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\t} else {\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\t}\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SEQ_DONE_RET:\n\t\ts5p_mfc_handle_seq_done(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_OPEN_INSTANCE_RET:\n\t\tctx->inst_no = s5p_mfc_hw_call(dev->mfc_ops, get_inst_no, dev);\n\t\tctx->state = MFCINST_GOT_INST;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_CLOSE_INSTANCE_RET:\n\t\tctx->inst_no = MFC_NO_INSTANCE_SET;\n\t\tctx->state = MFCINST_FREE;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_SYS_INIT_RET:\n\tcase S5P_MFC_R2H_CMD_FW_STATUS_RET:\n\tcase S5P_MFC_R2H_CMD_SLEEP_RET:\n\tcase S5P_MFC_R2H_CMD_WAKEUP_RET:\n\t\tif (ctx)\n\t\t\tclear_work_bit(ctx);\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tclear_bit(0, &dev->hw_lock);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\twake_up_dev(dev, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_INIT_BUFFERS_RET:\n\t\ts5p_mfc_handle_init_buffers(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_COMPLETE_SEQ_RET:\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tctx->int_type = reason;\n\t\tctx->int_err = err;\n\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_DPB_FLUSH_RET:\n\t\tctx->state = MFCINST_RUNNING;\n\t\tgoto irq_cleanup_hw;\n\n\tdefault:\n\t\tmfc_debug(2, \"Unknown int reason\\n\");\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t}\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug_leave();\n\treturn IRQ_HANDLED;\nirq_cleanup_hw:\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\tctx->int_type = reason;\n\tctx->int_err = err;\n\tctx->int_cond = 1;\n\tif (test_and_clear_bit(0, &dev->hw_lock) == 0)\n\t\tmfc_err(\"Failed to unlock hw\\n\");\n\n\ts5p_mfc_clock_off(dev);\n\tclear_work_bit(ctx);\n\twake_up(&ctx->queue);\n\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug(2, \"Exit via irq_cleanup_hw\\n\");\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "s5p_mfc_irq",
        "location": {
            "file_path": "drivers/media/platform/samsung/s5p-mfc/s5p_mfc.c",
            "region": {
                "startLine": 712,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 710,
                "endLine": 714,
                "snippet": {
                    "text": "ctx->state = MFCINST_FREE;"
                }
            }
        },
        "function_code": "static irqreturn_t s5p_mfc_irq(int irq, void *priv)\n{\n\tstruct s5p_mfc_dev *dev = priv;\n\tstruct s5p_mfc_ctx *ctx;\n\tunsigned int reason;\n\tunsigned int err;\n\n\tmfc_debug_enter();\n\t/* Reset the timeout watchdog */\n\tatomic_set(&dev->watchdog_cnt, 0);\n\tspin_lock(&dev->irqlock);\n\tctx = dev->ctx[dev->curr_ctx];\n\t/* Get the reason of interrupt and the error code */\n\treason = s5p_mfc_hw_call(dev->mfc_ops, get_int_reason, dev);\n\terr = s5p_mfc_hw_call(dev->mfc_ops, get_int_err, dev);\n\tmfc_debug(1, \"Int reason: %d (err: %08x)\\n\", reason, err);\n\tswitch (reason) {\n\tcase S5P_MFC_R2H_CMD_ERR_RET:\n\t\t/* An error has occurred */\n\t\tif (ctx->state == MFCINST_RUNNING &&\n\t\t\t(s5p_mfc_hw_call(dev->mfc_ops, err_dec, err) >=\n\t\t\t\tdev->warn_start ||\n\t\t\t\terr == S5P_FIMV_ERR_NO_VALID_SEQ_HDR ||\n\t\t\t\terr == S5P_FIMV_ERR_INCOMPLETE_FRAME ||\n\t\t\t\terr == S5P_FIMV_ERR_TIMEOUT))\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\telse\n\t\t\ts5p_mfc_handle_error(dev, ctx, reason, err);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SLICE_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FIELD_DONE_RET:\n\tcase S5P_MFC_R2H_CMD_FRAME_DONE_RET:\n\t\tif (ctx->c_ops->post_frame_start) {\n\t\t\tif (ctx->c_ops->post_frame_start(ctx))\n\t\t\t\tmfc_err(\"post_frame_start() failed\\n\");\n\n\t\t\tif (ctx->state == MFCINST_FINISHING &&\n\t\t\t\t\t\tlist_empty(&ctx->ref_queue)) {\n\t\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\t\tWARN_ON(test_and_clear_bit(0, &dev->hw_lock) == 0);\n\t\t\ts5p_mfc_clock_off(dev);\n\t\t\twake_up_ctx(ctx, reason, err);\n\t\t\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\t\t} else {\n\t\t\ts5p_mfc_handle_frame(ctx, reason, err);\n\t\t}\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_SEQ_DONE_RET:\n\t\ts5p_mfc_handle_seq_done(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_OPEN_INSTANCE_RET:\n\t\tctx->inst_no = s5p_mfc_hw_call(dev->mfc_ops, get_inst_no, dev);\n\t\tctx->state = MFCINST_GOT_INST;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_CLOSE_INSTANCE_RET:\n\t\tctx->inst_no = MFC_NO_INSTANCE_SET;\n\t\tctx->state = MFCINST_FREE;\n\t\tgoto irq_cleanup_hw;\n\n\tcase S5P_MFC_R2H_CMD_SYS_INIT_RET:\n\tcase S5P_MFC_R2H_CMD_FW_STATUS_RET:\n\tcase S5P_MFC_R2H_CMD_SLEEP_RET:\n\tcase S5P_MFC_R2H_CMD_WAKEUP_RET:\n\t\tif (ctx)\n\t\t\tclear_work_bit(ctx);\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tclear_bit(0, &dev->hw_lock);\n\t\tclear_bit(0, &dev->enter_suspend);\n\t\twake_up_dev(dev, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_INIT_BUFFERS_RET:\n\t\ts5p_mfc_handle_init_buffers(ctx, reason, err);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_COMPLETE_SEQ_RET:\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t\tctx->int_type = reason;\n\t\tctx->int_err = err;\n\t\ts5p_mfc_handle_stream_complete(ctx);\n\t\tbreak;\n\n\tcase S5P_MFC_R2H_CMD_DPB_FLUSH_RET:\n\t\tctx->state = MFCINST_RUNNING;\n\t\tgoto irq_cleanup_hw;\n\n\tdefault:\n\t\tmfc_debug(2, \"Unknown int reason\\n\");\n\t\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\t}\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug_leave();\n\treturn IRQ_HANDLED;\nirq_cleanup_hw:\n\ts5p_mfc_hw_call(dev->mfc_ops, clear_int_flags, dev);\n\tctx->int_type = reason;\n\tctx->int_err = err;\n\tctx->int_cond = 1;\n\tif (test_and_clear_bit(0, &dev->hw_lock) == 0)\n\t\tmfc_err(\"Failed to unlock hw\\n\");\n\n\ts5p_mfc_clock_off(dev);\n\tclear_work_bit(ctx);\n\twake_up(&ctx->queue);\n\n\ts5p_mfc_hw_call(dev->mfc_ops, try_run, dev);\n\tspin_unlock(&dev->irqlock);\n\tmfc_debug(2, \"Exit via irq_cleanup_hw\\n\");\n\treturn IRQ_HANDLED;\n}"
    },
    {
        "var_name": "map",
        "function_name": "seek_rc_map",
        "location": {
            "file_path": "drivers/media/rc/rc-main.c",
            "region": {
                "startLine": 96,
                "startColumn": 21,
                "endColumn": 24
            },
            "context": {
                "startLine": 94,
                "endLine": 98,
                "snippet": {
                    "text": "if (!strcmp(name, map->map.name)) {"
                }
            }
        },
        "function_code": "static struct rc_map_list *seek_rc_map(const char *name)\n{\n\tstruct rc_map_list *map = NULL;\n\n\tspin_lock(&rc_map_lock);\n\tlist_for_each_entry(map, &rc_map_list, list) {\n\t\tif (!strcmp(name, map->map.name)) {\n\t\t\tspin_unlock(&rc_map_lock);\n\t\t\treturn map;\n\t\t}\n\t}\n\tspin_unlock(&rc_map_lock);\n\n\treturn NULL;\n}"
    },
    {
        "var_name": "wbuf",
        "function_name": "dibusb_i2c_msg",
        "location": {
            "file_path": "drivers/media/usb/dvb-usb/dibusb-common.c",
            "region": {
                "startLine": 161,
                "startColumn": 21,
                "endColumn": 25
            },
            "context": {
                "startLine": 159,
                "endLine": 163,
                "snippet": {
                    "text": "memcpy(&sndbuf[2], wbuf, wlen);"
                }
            }
        },
        "function_code": "static int dibusb_i2c_msg(struct dvb_usb_device *d, u8 addr,\n\t\t\t  u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\n{\n\tu8 *sndbuf;\n\tint ret, wo, len;\n\n\t/* write only ? */\n\two = (rbuf == NULL || rlen == 0);\n\n\tlen = 2 + wlen + (wo ? 0 : 2);\n\n\tsndbuf = kmalloc(MAX_XFER_SIZE, GFP_KERNEL);\n\tif (!sndbuf)\n\t\treturn -ENOMEM;\n\n\tif (4 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto ret;\n\t}\n\n\tsndbuf[0] = wo ? DIBUSB_REQ_I2C_WRITE : DIBUSB_REQ_I2C_READ;\n\tsndbuf[1] = (addr << 1) | (wo ? 0 : 1);\n\n\tmemcpy(&sndbuf[2], wbuf, wlen);\n\n\tif (!wo) {\n\t\tsndbuf[wlen + 2] = (rlen >> 8) & 0xff;\n\t\tsndbuf[wlen + 3] = rlen & 0xff;\n\t}\n\n\tret = dvb_usb_generic_rw(d, sndbuf, len, rbuf, rlen, 0);\n\nret:\n\tkfree(sndbuf);\n\treturn ret;\n}"
    },
    {
        "var_name": "rbuf",
        "function_name": "dtv5100_i2c_msg",
        "location": {
            "file_path": "drivers/media/usb/dvb-usb/dtv5100.c",
            "region": {
                "startLine": 58,
                "startColumn": 19,
                "endColumn": 23
            },
            "context": {
                "startLine": 56,
                "endLine": 60,
                "snippet": {
                    "text": "memcpy(st->data, rbuf, rlen);"
                }
            }
        },
        "function_code": "static int dtv5100_i2c_msg(struct dvb_usb_device *d, u8 addr,\n\t\t\t   u8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\n{\n\tstruct dtv5100_state *st = d->priv;\n\tunsigned int pipe;\n\tu8 request;\n\tu8 type;\n\tu16 value;\n\tu16 index;\n\n\tswitch (wlen) {\n\tcase 1:\n\t\t/* write { reg }, read { value } */\n\t\tpipe = usb_rcvctrlpipe(d->udev, 0);\n\t\trequest = (addr == DTV5100_DEMOD_ADDR ? DTV5100_DEMOD_READ :\n\t\t\t\t\t\t\tDTV5100_TUNER_READ);\n\t\ttype = USB_TYPE_VENDOR | USB_DIR_IN;\n\t\tvalue = 0;\n\t\tbreak;\n\tcase 2:\n\t\t/* write { reg, value } */\n\t\tpipe = usb_sndctrlpipe(d->udev, 0);\n\t\trequest = (addr == DTV5100_DEMOD_ADDR ? DTV5100_DEMOD_WRITE :\n\t\t\t\t\t\t\tDTV5100_TUNER_WRITE);\n\t\ttype = USB_TYPE_VENDOR | USB_DIR_OUT;\n\t\tvalue = wbuf[1];\n\t\tbreak;\n\tdefault:\n\t\twarn(\"wlen = %x, aborting.\", wlen);\n\t\treturn -EINVAL;\n\t}\n\tindex = (addr << 8) + wbuf[0];\n\n\tmemcpy(st->data, rbuf, rlen);\n\tmsleep(1); /* avoid I2C errors */\n\treturn usb_control_msg(d->udev, pipe, request,\n\t\t\t       type, value, index, st->data, rlen,\n\t\t\t       DTV5100_USB_TIMEOUT);\n}"
    },
    {
        "var_name": "snd_buf",
        "function_name": "pctv452e_i2c_msg",
        "location": {
            "file_path": "drivers/media/usb/dvb-usb/pctv452e.c",
            "region": {
                "startLine": 443,
                "startColumn": 18,
                "endColumn": 25
            },
            "context": {
                "startLine": 441,
                "endLine": 445,
                "snippet": {
                    "text": "memcpy(buf + 7, snd_buf, snd_len);"
                }
            }
        },
        "function_code": "static int pctv452e_i2c_msg(struct dvb_usb_device *d, u8 addr,\n\t\t\t\tconst u8 *snd_buf, u8 snd_len,\n\t\t\t\tu8 *rcv_buf, u8 rcv_len)\n{\n\tstruct pctv452e_state *state = d->priv;\n\tu8 *buf;\n\tu8 id;\n\tint ret;\n\n\tbuf = kmalloc(64, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tid = state->c++;\n\n\tret = -EINVAL;\n\tif (snd_len > 64 - 7 || rcv_len > 64 - 7)\n\t\tgoto failed;\n\n\tbuf[0] = SYNC_BYTE_OUT;\n\tbuf[1] = id;\n\tbuf[2] = PCTV_CMD_I2C;\n\tbuf[3] = snd_len + 3;\n\tbuf[4] = addr << 1;\n\tbuf[5] = snd_len;\n\tbuf[6] = rcv_len;\n\n\tmemcpy(buf + 7, snd_buf, snd_len);\n\n\tret = dvb_usb_generic_rw(d, buf, 7 + snd_len,\n\t\t\t\t  buf, /* rcv_len */ 64,\n\t\t\t\t  /* delay_ms */ 0);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\t/* TT USB protocol error. */\n\tret = -EIO;\n\tif (SYNC_BYTE_IN != buf[0] || id != buf[1])\n\t\tgoto failed;\n\n\t/* I2C device didn't respond as expected. */\n\tret = -EREMOTEIO;\n\tif (buf[5] < snd_len || buf[6] < rcv_len)\n\t\tgoto failed;\n\n\tmemcpy(rcv_buf, buf + 7, rcv_len);\n\n\tkfree(buf);\n\treturn rcv_len;\n\nfailed:\n\terr(\"I2C error %d; %02X %02X  %02X %02X %02X -> %*ph\",\n\t     ret, SYNC_BYTE_OUT, id, addr << 1, snd_len, rcv_len,\n\t     7, buf);\n\n\tkfree(buf);\n\treturn ret;\n}"
    },
    {
        "var_name": "ops",
        "function_name": "em28xx_init_extension",
        "location": {
            "file_path": "drivers/media/usb/em28xx/em28xx-core.c",
            "region": {
                "startLine": 1115,
                "startColumn": 7,
                "endColumn": 10
            },
            "context": {
                "startLine": 1113,
                "endLine": 1117,
                "snippet": {
                    "text": "if (ops->init) {"
                }
            }
        },
        "function_code": "void em28xx_init_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_add_tail(&dev->devlist, &em28xx_devlist);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (ops->init) {\n\t\t\tops->init(dev);\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->init(dev->dev_next);\n\t\t}\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n}"
    },
    {
        "var_name": "ops",
        "function_name": "em28xx_init_extension",
        "location": {
            "file_path": "drivers/media/usb/em28xx/em28xx-core.c",
            "region": {
                "startLine": 1116,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 1114,
                "endLine": 1118,
                "snippet": {
                    "text": "ops->init(dev);"
                }
            }
        },
        "function_code": "void em28xx_init_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_add_tail(&dev->devlist, &em28xx_devlist);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (ops->init) {\n\t\t\tops->init(dev);\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->init(dev->dev_next);\n\t\t}\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n}"
    },
    {
        "var_name": "ops",
        "function_name": "em28xx_init_extension",
        "location": {
            "file_path": "drivers/media/usb/em28xx/em28xx-core.c",
            "region": {
                "startLine": 1118,
                "startColumn": 5,
                "endColumn": 8
            },
            "context": {
                "startLine": 1116,
                "endLine": 1120,
                "snippet": {
                    "text": "ops->init(dev->dev_next);"
                }
            }
        },
        "function_code": "void em28xx_init_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_add_tail(&dev->devlist, &em28xx_devlist);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (ops->init) {\n\t\t\tops->init(dev);\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->init(dev->dev_next);\n\t\t}\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n}"
    },
    {
        "var_name": "ops",
        "function_name": "em28xx_close_extension",
        "location": {
            "file_path": "drivers/media/usb/em28xx/em28xx-core.c",
            "region": {
                "startLine": 1130,
                "startColumn": 7,
                "endColumn": 10
            },
            "context": {
                "startLine": 1128,
                "endLine": 1132,
                "snippet": {
                    "text": "if (ops->fini) {"
                }
            }
        },
        "function_code": "void em28xx_close_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (ops->fini) {\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->fini(dev->dev_next);\n\t\t\tops->fini(dev);\n\t\t}\n\t}\n\tlist_del(&dev->devlist);\n\tmutex_unlock(&em28xx_devlist_mutex);\n}"
    },
    {
        "var_name": "ops",
        "function_name": "em28xx_close_extension",
        "location": {
            "file_path": "drivers/media/usb/em28xx/em28xx-core.c",
            "region": {
                "startLine": 1132,
                "startColumn": 5,
                "endColumn": 8
            },
            "context": {
                "startLine": 1130,
                "endLine": 1134,
                "snippet": {
                    "text": "ops->fini(dev->dev_next);"
                }
            }
        },
        "function_code": "void em28xx_close_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (ops->fini) {\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->fini(dev->dev_next);\n\t\t\tops->fini(dev);\n\t\t}\n\t}\n\tlist_del(&dev->devlist);\n\tmutex_unlock(&em28xx_devlist_mutex);\n}"
    },
    {
        "var_name": "ops",
        "function_name": "em28xx_close_extension",
        "location": {
            "file_path": "drivers/media/usb/em28xx/em28xx-core.c",
            "region": {
                "startLine": 1133,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 1131,
                "endLine": 1135,
                "snippet": {
                    "text": "ops->fini(dev);"
                }
            }
        },
        "function_code": "void em28xx_close_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (ops->fini) {\n\t\t\tif (dev->dev_next)\n\t\t\t\tops->fini(dev->dev_next);\n\t\t\tops->fini(dev);\n\t\t}\n\t}\n\tlist_del(&dev->devlist);\n\tmutex_unlock(&em28xx_devlist_mutex);\n}"
    },
    {
        "var_name": "ops",
        "function_name": "em28xx_suspend_extension",
        "location": {
            "file_path": "drivers/media/usb/em28xx/em28xx-core.c",
            "region": {
                "startLine": 1147,
                "startColumn": 8,
                "endColumn": 11
            },
            "context": {
                "startLine": 1145,
                "endLine": 1149,
                "snippet": {
                    "text": "if (!ops->suspend)"
                }
            }
        },
        "function_code": "int em28xx_suspend_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tdev_info(&dev->intf->dev, \"Suspending extensions\\n\");\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (!ops->suspend)\n\t\t\tcontinue;\n\t\tops->suspend(dev);\n\t\tif (dev->dev_next)\n\t\t\tops->suspend(dev->dev_next);\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n\treturn 0;\n}"
    },
    {
        "var_name": "ops",
        "function_name": "em28xx_resume_extension",
        "location": {
            "file_path": "drivers/media/usb/em28xx/em28xx-core.c",
            "region": {
                "startLine": 1164,
                "startColumn": 8,
                "endColumn": 11
            },
            "context": {
                "startLine": 1162,
                "endLine": 1166,
                "snippet": {
                    "text": "if (!ops->resume)"
                }
            }
        },
        "function_code": "int em28xx_resume_extension(struct em28xx *dev)\n{\n\tconst struct em28xx_ops *ops = NULL;\n\n\tdev_info(&dev->intf->dev, \"Resuming extensions\\n\");\n\tmutex_lock(&em28xx_devlist_mutex);\n\tlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\n\t\tif (!ops->resume)\n\t\t\tcontinue;\n\t\tops->resume(dev);\n\t\tif (dev->dev_next)\n\t\t\tops->resume(dev->dev_next);\n\t}\n\tmutex_unlock(&em28xx_devlist_mutex);\n\treturn 0;\n}"
    },
    {
        "var_name": "names",
        "function_name": "parse_token",
        "location": {
            "file_path": "drivers/media/usb/pvrusb2/pvrusb2-ctrl.c",
            "region": {
                "startLine": 363,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 361,
                "endLine": 365,
                "snippet": {
                    "text": "if (!names[idx]) continue;"
                }
            }
        },
        "function_code": "static int parse_token(const char *ptr,unsigned int len,\n\t\t       int *valptr,\n\t\t       const char * const *names, unsigned int namecnt)\n{\n\tunsigned int slen;\n\tunsigned int idx;\n\t*valptr = 0;\n\tif (!names) namecnt = 0;\n\tfor (idx = 0; idx < namecnt; idx++) {\n\t\tif (!names[idx]) continue;\n\t\tslen = strlen(names[idx]);\n\t\tif (slen != len) continue;\n\t\tif (memcmp(names[idx],ptr,slen)) continue;\n\t\t*valptr = idx;\n\t\treturn 0;\n\t}\n\treturn kstrtoint(ptr, 0, valptr) ? -EINVAL : 1;\n}"
    },
    {
        "var_name": "ref",
        "function_name": "v4l2_query_ext_ctrl",
        "location": {
            "file_path": "drivers/media/v4l2-core/v4l2-ctrls-api.c",
            "region": {
                "startLine": 1076,
                "startColumn": 19,
                "endColumn": 22
            },
            "context": {
                "startLine": 1074,
                "endLine": 1078,
                "snippet": {
                    "text": "is_compound = ref->ctrl->is_array ||"
                }
            }
        },
        "function_code": "int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)\n{\n\tconst unsigned int next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;\n\tu32 id = qc->id & V4L2_CTRL_ID_MASK;\n\tstruct v4l2_ctrl_ref *ref;\n\tstruct v4l2_ctrl *ctrl;\n\n\tif (!hdl)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hdl->lock);\n\n\t/* Try to find it */\n\tref = find_ref(hdl, id);\n\n\tif ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {\n\t\tbool is_compound;\n\t\t/* Match any control that is not hidden */\n\t\tunsigned int mask = 1;\n\t\tbool match = false;\n\n\t\tif ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {\n\t\t\t/* Match any hidden control */\n\t\t\tmatch = true;\n\t\t} else if ((qc->id & next_flags) == next_flags) {\n\t\t\t/* Match any control, compound or not */\n\t\t\tmask = 0;\n\t\t}\n\n\t\t/* Find the next control with ID > qc->id */\n\n\t\t/* Did we reach the end of the control list? */\n\t\tif (id >= node2id(hdl->ctrl_refs.prev)) {\n\t\t\tref = NULL; /* Yes, so there is no next control */\n\t\t} else if (ref) {\n\t\t\t/*\n\t\t\t * We found a control with the given ID, so just get\n\t\t\t * the next valid one in the list.\n\t\t\t */\n\t\t\tlist_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {\n\t\t\t\tis_compound = ref->ctrl->is_array ||\n\t\t\t\t\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\n\t\t\t\tif (id < ref->ctrl->id &&\n\t\t\t\t    (is_compound & mask) == match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&ref->node == &hdl->ctrl_refs)\n\t\t\t\tref = NULL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * No control with the given ID exists, so start\n\t\t\t * searching for the next largest ID. We know there\n\t\t\t * is one, otherwise the first 'if' above would have\n\t\t\t * been true.\n\t\t\t */\n\t\t\tlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\n\t\t\t\tis_compound = ref->ctrl->is_array ||\n\t\t\t\t\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\n\t\t\t\tif (id < ref->ctrl->id &&\n\t\t\t\t    (is_compound & mask) == match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&ref->node == &hdl->ctrl_refs)\n\t\t\t\tref = NULL;\n\t\t}\n\t}\n\tmutex_unlock(hdl->lock);\n\n\tif (!ref)\n\t\treturn -EINVAL;\n\n\tctrl = ref->ctrl;\n\tmemset(qc, 0, sizeof(*qc));\n\tif (id >= V4L2_CID_PRIVATE_BASE)\n\t\tqc->id = id;\n\telse\n\t\tqc->id = ctrl->id;\n\tstrscpy(qc->name, ctrl->name, sizeof(qc->name));\n\tqc->flags = user_flags(ctrl);\n\tqc->type = ctrl->type;\n\tqc->elem_size = ctrl->elem_size;\n\tqc->elems = ctrl->elems;\n\tqc->nr_of_dims = ctrl->nr_of_dims;\n\tmemcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));\n\tqc->minimum = ctrl->minimum;\n\tqc->maximum = ctrl->maximum;\n\tqc->default_value = ctrl->default_value;\n\tif (ctrl->type == V4L2_CTRL_TYPE_MENU ||\n\t    ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\n\t\tqc->step = 1;\n\telse\n\t\tqc->step = ctrl->step;\n\treturn 0;\n}"
    },
    {
        "var_name": "ref",
        "function_name": "v4l2_query_ext_ctrl",
        "location": {
            "file_path": "drivers/media/v4l2-core/v4l2-ctrls-api.c",
            "region": {
                "startLine": 1077,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 1075,
                "endLine": 1079,
                "snippet": {
                    "text": "ref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;"
                }
            }
        },
        "function_code": "int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)\n{\n\tconst unsigned int next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;\n\tu32 id = qc->id & V4L2_CTRL_ID_MASK;\n\tstruct v4l2_ctrl_ref *ref;\n\tstruct v4l2_ctrl *ctrl;\n\n\tif (!hdl)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hdl->lock);\n\n\t/* Try to find it */\n\tref = find_ref(hdl, id);\n\n\tif ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {\n\t\tbool is_compound;\n\t\t/* Match any control that is not hidden */\n\t\tunsigned int mask = 1;\n\t\tbool match = false;\n\n\t\tif ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {\n\t\t\t/* Match any hidden control */\n\t\t\tmatch = true;\n\t\t} else if ((qc->id & next_flags) == next_flags) {\n\t\t\t/* Match any control, compound or not */\n\t\t\tmask = 0;\n\t\t}\n\n\t\t/* Find the next control with ID > qc->id */\n\n\t\t/* Did we reach the end of the control list? */\n\t\tif (id >= node2id(hdl->ctrl_refs.prev)) {\n\t\t\tref = NULL; /* Yes, so there is no next control */\n\t\t} else if (ref) {\n\t\t\t/*\n\t\t\t * We found a control with the given ID, so just get\n\t\t\t * the next valid one in the list.\n\t\t\t */\n\t\t\tlist_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {\n\t\t\t\tis_compound = ref->ctrl->is_array ||\n\t\t\t\t\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\n\t\t\t\tif (id < ref->ctrl->id &&\n\t\t\t\t    (is_compound & mask) == match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&ref->node == &hdl->ctrl_refs)\n\t\t\t\tref = NULL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * No control with the given ID exists, so start\n\t\t\t * searching for the next largest ID. We know there\n\t\t\t * is one, otherwise the first 'if' above would have\n\t\t\t * been true.\n\t\t\t */\n\t\t\tlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\n\t\t\t\tis_compound = ref->ctrl->is_array ||\n\t\t\t\t\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\n\t\t\t\tif (id < ref->ctrl->id &&\n\t\t\t\t    (is_compound & mask) == match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&ref->node == &hdl->ctrl_refs)\n\t\t\t\tref = NULL;\n\t\t}\n\t}\n\tmutex_unlock(hdl->lock);\n\n\tif (!ref)\n\t\treturn -EINVAL;\n\n\tctrl = ref->ctrl;\n\tmemset(qc, 0, sizeof(*qc));\n\tif (id >= V4L2_CID_PRIVATE_BASE)\n\t\tqc->id = id;\n\telse\n\t\tqc->id = ctrl->id;\n\tstrscpy(qc->name, ctrl->name, sizeof(qc->name));\n\tqc->flags = user_flags(ctrl);\n\tqc->type = ctrl->type;\n\tqc->elem_size = ctrl->elem_size;\n\tqc->elems = ctrl->elems;\n\tqc->nr_of_dims = ctrl->nr_of_dims;\n\tmemcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));\n\tqc->minimum = ctrl->minimum;\n\tqc->maximum = ctrl->maximum;\n\tqc->default_value = ctrl->default_value;\n\tif (ctrl->type == V4L2_CTRL_TYPE_MENU ||\n\t    ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\n\t\tqc->step = 1;\n\telse\n\t\tqc->step = ctrl->step;\n\treturn 0;\n}"
    },
    {
        "var_name": "ref",
        "function_name": "v4l2_query_ext_ctrl",
        "location": {
            "file_path": "drivers/media/v4l2-core/v4l2-ctrls-api.c",
            "region": {
                "startLine": 1078,
                "startColumn": 14,
                "endColumn": 17
            },
            "context": {
                "startLine": 1076,
                "endLine": 1080,
                "snippet": {
                    "text": "if (id < ref->ctrl->id &&"
                }
            }
        },
        "function_code": "int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctrl *qc)\n{\n\tconst unsigned int next_flags = V4L2_CTRL_FLAG_NEXT_CTRL | V4L2_CTRL_FLAG_NEXT_COMPOUND;\n\tu32 id = qc->id & V4L2_CTRL_ID_MASK;\n\tstruct v4l2_ctrl_ref *ref;\n\tstruct v4l2_ctrl *ctrl;\n\n\tif (!hdl)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hdl->lock);\n\n\t/* Try to find it */\n\tref = find_ref(hdl, id);\n\n\tif ((qc->id & next_flags) && !list_empty(&hdl->ctrl_refs)) {\n\t\tbool is_compound;\n\t\t/* Match any control that is not hidden */\n\t\tunsigned int mask = 1;\n\t\tbool match = false;\n\n\t\tif ((qc->id & next_flags) == V4L2_CTRL_FLAG_NEXT_COMPOUND) {\n\t\t\t/* Match any hidden control */\n\t\t\tmatch = true;\n\t\t} else if ((qc->id & next_flags) == next_flags) {\n\t\t\t/* Match any control, compound or not */\n\t\t\tmask = 0;\n\t\t}\n\n\t\t/* Find the next control with ID > qc->id */\n\n\t\t/* Did we reach the end of the control list? */\n\t\tif (id >= node2id(hdl->ctrl_refs.prev)) {\n\t\t\tref = NULL; /* Yes, so there is no next control */\n\t\t} else if (ref) {\n\t\t\t/*\n\t\t\t * We found a control with the given ID, so just get\n\t\t\t * the next valid one in the list.\n\t\t\t */\n\t\t\tlist_for_each_entry_continue(ref, &hdl->ctrl_refs, node) {\n\t\t\t\tis_compound = ref->ctrl->is_array ||\n\t\t\t\t\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\n\t\t\t\tif (id < ref->ctrl->id &&\n\t\t\t\t    (is_compound & mask) == match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&ref->node == &hdl->ctrl_refs)\n\t\t\t\tref = NULL;\n\t\t} else {\n\t\t\t/*\n\t\t\t * No control with the given ID exists, so start\n\t\t\t * searching for the next largest ID. We know there\n\t\t\t * is one, otherwise the first 'if' above would have\n\t\t\t * been true.\n\t\t\t */\n\t\t\tlist_for_each_entry(ref, &hdl->ctrl_refs, node) {\n\t\t\t\tis_compound = ref->ctrl->is_array ||\n\t\t\t\t\tref->ctrl->type >= V4L2_CTRL_COMPOUND_TYPES;\n\t\t\t\tif (id < ref->ctrl->id &&\n\t\t\t\t    (is_compound & mask) == match)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&ref->node == &hdl->ctrl_refs)\n\t\t\t\tref = NULL;\n\t\t}\n\t}\n\tmutex_unlock(hdl->lock);\n\n\tif (!ref)\n\t\treturn -EINVAL;\n\n\tctrl = ref->ctrl;\n\tmemset(qc, 0, sizeof(*qc));\n\tif (id >= V4L2_CID_PRIVATE_BASE)\n\t\tqc->id = id;\n\telse\n\t\tqc->id = ctrl->id;\n\tstrscpy(qc->name, ctrl->name, sizeof(qc->name));\n\tqc->flags = user_flags(ctrl);\n\tqc->type = ctrl->type;\n\tqc->elem_size = ctrl->elem_size;\n\tqc->elems = ctrl->elems;\n\tqc->nr_of_dims = ctrl->nr_of_dims;\n\tmemcpy(qc->dims, ctrl->dims, qc->nr_of_dims * sizeof(qc->dims[0]));\n\tqc->minimum = ctrl->minimum;\n\tqc->maximum = ctrl->maximum;\n\tqc->default_value = ctrl->default_value;\n\tif (ctrl->type == V4L2_CTRL_TYPE_MENU ||\n\t    ctrl->type == V4L2_CTRL_TYPE_INTEGER_MENU)\n\t\tqc->step = 1;\n\telse\n\t\tqc->step = ctrl->step;\n\treturn 0;\n}"
    },
    {
        "var_name": "v4l2_flash",
        "function_name": "v4l2_flash_set_led_brightness",
        "location": {
            "file_path": "drivers/media/v4l2-core/v4l2-flash-led-class.c",
            "region": {
                "startLine": 82,
                "startColumn": 29,
                "endColumn": 39
            },
            "context": {
                "startLine": 80,
                "endLine": 84,
                "snippet": {
                    "text": "struct v4l2_ctrl **ctrls = v4l2_flash->ctrls;"
                }
            }
        },
        "function_code": "static int v4l2_flash_set_led_brightness(struct v4l2_flash *v4l2_flash,\n\t\t\t\t\t struct v4l2_ctrl *ctrl)\n{\n\tstruct v4l2_ctrl **ctrls = v4l2_flash->ctrls;\n\tstruct led_classdev *led_cdev;\n\tenum led_brightness brightness;\n\n\tif (has_flash_op(v4l2_flash, intensity_to_led_brightness))\n\t\tbrightness = call_flash_op(v4l2_flash,\n\t\t\t\t\tintensity_to_led_brightness,\n\t\t\t\t\tctrl->val);\n\telse\n\t\tbrightness = __intensity_to_led_brightness(ctrl, ctrl->val);\n\t/*\n\t * In case a LED Flash class driver provides ops for custom\n\t * brightness <-> intensity conversion, it also must have defined\n\t * related v4l2 control step == 1. In such a case a backward conversion\n\t * from led brightness to v4l2 intensity is required to find out the\n\t * aligned intensity value.\n\t */\n\tif (has_flash_op(v4l2_flash, led_brightness_to_intensity))\n\t\tctrl->val = call_flash_op(v4l2_flash,\n\t\t\t\t\tled_brightness_to_intensity,\n\t\t\t\t\tbrightness);\n\n\tif (ctrl == ctrls[TORCH_INTENSITY]) {\n\t\tif (ctrls[LED_MODE]->val != V4L2_FLASH_LED_MODE_TORCH)\n\t\t\treturn 0;\n\n\t\tif (WARN_ON_ONCE(!v4l2_flash->fled_cdev))\n\t\t\treturn -EINVAL;\n\n\t\tled_cdev = &v4l2_flash->fled_cdev->led_cdev;\n\t} else {\n\t\tif (WARN_ON_ONCE(!v4l2_flash->iled_cdev))\n\t\t\treturn -EINVAL;\n\n\t\tled_cdev = v4l2_flash->iled_cdev;\n\t}\n\n\treturn led_set_brightness_sync(led_cdev, brightness);\n}"
    },
    {
        "var_name": "mc",
        "function_name": "tegra234_mc_icc_aggregate",
        "location": {
            "file_path": "drivers/memory/tegra/tegra234.c",
            "region": {
                "startLine": 1104,
                "startColumn": 7,
                "endColumn": 9
            },
            "context": {
                "startLine": 1102,
                "endLine": 1106,
                "snippet": {
                    "text": "if (!mc->bwmgr_mrq_supported)"
                }
            }
        },
        "function_code": "static int tegra234_mc_icc_aggregate(struct icc_node *node, u32 tag, u32 avg_bw,\n\t\t\t\t     u32 peak_bw, u32 *agg_avg, u32 *agg_peak)\n{\n\tstruct icc_provider *p = node->provider;\n\tstruct tegra_mc *mc = icc_provider_to_tegra_mc(p);\n\n\tif (!mc->bwmgr_mrq_supported)\n\t\treturn 0;\n\n\tif (node->id == TEGRA_ICC_MC_CPU_CLUSTER0 ||\n\t    node->id == TEGRA_ICC_MC_CPU_CLUSTER1 ||\n\t    node->id == TEGRA_ICC_MC_CPU_CLUSTER2) {\n\t\tif (mc)\n\t\t\tpeak_bw = peak_bw * mc->num_channels;\n\t}\n\n\t*agg_avg += avg_bw;\n\t*agg_peak = max(*agg_peak, peak_bw);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "ioc",
        "function_name": "mpt_get_fw_exp_ver",
        "location": {
            "file_path": "drivers/message/fusion/mptbase.c",
            "region": {
                "startLine": 6786,
                "startColumn": 7,
                "endColumn": 10
            },
            "context": {
                "startLine": 6784,
                "endLine": 6788,
                "snippet": {
                    "text": "if ((ioc->facts.FWVersion.Word >> 24) == 0x0E) {"
                }
            }
        },
        "function_code": "static void\nmpt_get_fw_exp_ver(char *buf, MPT_ADAPTER *ioc)\n{\n\tbuf[0] ='\\0';\n\tif ((ioc->facts.FWVersion.Word >> 24) == 0x0E) {\n\t\tsprintf(buf, \" (Exp %02d%02d)\",\n\t\t\t(ioc->facts.FWVersion.Word >> 16) & 0x00FF,\t/* Month */\n\t\t\t(ioc->facts.FWVersion.Word >> 8) & 0x1F);\t/* Day */\n\n\t\t/* insider hack! */\n\t\tif ((ioc->facts.FWVersion.Word >> 8) & 0x80)\n\t\t\tstrcat(buf, \" [MDBG]\");\n\t}\n}"
    },
    {
        "var_name": "ioc",
        "function_name": "seq_mpt_print_ioc_summary",
        "location": {
            "file_path": "drivers/message/fusion/mptbase.c",
            "region": {
                "startLine": 6855,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 6853,
                "endLine": 6857,
                "snippet": {
                    "text": "ioc->name,"
                }
            }
        },
        "function_code": "static void seq_mpt_print_ioc_summary(MPT_ADAPTER *ioc, struct seq_file *m, int showlan)\n{\n\tchar expVer[32];\n\n\tmpt_get_fw_exp_ver(expVer, ioc);\n\n\t/*\n\t *  Shorter summary of attached ioc's...\n\t */\n\tseq_printf(m, \"%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d\",\n\t\t\tioc->name,\n\t\t\tioc->prod_name,\n\t\t\tMPT_FW_REV_MAGIC_ID_STRING,\t/* \"FwRev=\" or somesuch */\n\t\t\tioc->facts.FWVersion.Word,\n\t\t\texpVer,\n\t\t\tioc->facts.NumberOfPorts,\n\t\t\tioc->req_depth);\n\n\tif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\n\t\tu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\tseq_printf(m, \", LanAddr=%pMR\", a);\n\t}\n\n\tseq_printf(m, \", IRQ=%d\", ioc->pci_irq);\n\n\tif (!ioc->active)\n\t\tseq_printf(m, \" (disabled)\");\n\n\tseq_putc(m, '\\n');\n}"
    },
    {
        "var_name": "ioc",
        "function_name": "seq_mpt_print_ioc_summary",
        "location": {
            "file_path": "drivers/message/fusion/mptbase.c",
            "region": {
                "startLine": 6856,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 6854,
                "endLine": 6858,
                "snippet": {
                    "text": "ioc->prod_name,"
                }
            }
        },
        "function_code": "static void seq_mpt_print_ioc_summary(MPT_ADAPTER *ioc, struct seq_file *m, int showlan)\n{\n\tchar expVer[32];\n\n\tmpt_get_fw_exp_ver(expVer, ioc);\n\n\t/*\n\t *  Shorter summary of attached ioc's...\n\t */\n\tseq_printf(m, \"%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d\",\n\t\t\tioc->name,\n\t\t\tioc->prod_name,\n\t\t\tMPT_FW_REV_MAGIC_ID_STRING,\t/* \"FwRev=\" or somesuch */\n\t\t\tioc->facts.FWVersion.Word,\n\t\t\texpVer,\n\t\t\tioc->facts.NumberOfPorts,\n\t\t\tioc->req_depth);\n\n\tif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\n\t\tu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\tseq_printf(m, \", LanAddr=%pMR\", a);\n\t}\n\n\tseq_printf(m, \", IRQ=%d\", ioc->pci_irq);\n\n\tif (!ioc->active)\n\t\tseq_printf(m, \" (disabled)\");\n\n\tseq_putc(m, '\\n');\n}"
    },
    {
        "var_name": "ioc",
        "function_name": "seq_mpt_print_ioc_summary",
        "location": {
            "file_path": "drivers/message/fusion/mptbase.c",
            "region": {
                "startLine": 6858,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 6856,
                "endLine": 6860,
                "snippet": {
                    "text": "ioc->facts.FWVersion.Word,"
                }
            }
        },
        "function_code": "static void seq_mpt_print_ioc_summary(MPT_ADAPTER *ioc, struct seq_file *m, int showlan)\n{\n\tchar expVer[32];\n\n\tmpt_get_fw_exp_ver(expVer, ioc);\n\n\t/*\n\t *  Shorter summary of attached ioc's...\n\t */\n\tseq_printf(m, \"%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d\",\n\t\t\tioc->name,\n\t\t\tioc->prod_name,\n\t\t\tMPT_FW_REV_MAGIC_ID_STRING,\t/* \"FwRev=\" or somesuch */\n\t\t\tioc->facts.FWVersion.Word,\n\t\t\texpVer,\n\t\t\tioc->facts.NumberOfPorts,\n\t\t\tioc->req_depth);\n\n\tif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\n\t\tu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\tseq_printf(m, \", LanAddr=%pMR\", a);\n\t}\n\n\tseq_printf(m, \", IRQ=%d\", ioc->pci_irq);\n\n\tif (!ioc->active)\n\t\tseq_printf(m, \" (disabled)\");\n\n\tseq_putc(m, '\\n');\n}"
    },
    {
        "var_name": "ioc",
        "function_name": "seq_mpt_print_ioc_summary",
        "location": {
            "file_path": "drivers/message/fusion/mptbase.c",
            "region": {
                "startLine": 6860,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 6858,
                "endLine": 6862,
                "snippet": {
                    "text": "ioc->facts.NumberOfPorts,"
                }
            }
        },
        "function_code": "static void seq_mpt_print_ioc_summary(MPT_ADAPTER *ioc, struct seq_file *m, int showlan)\n{\n\tchar expVer[32];\n\n\tmpt_get_fw_exp_ver(expVer, ioc);\n\n\t/*\n\t *  Shorter summary of attached ioc's...\n\t */\n\tseq_printf(m, \"%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d\",\n\t\t\tioc->name,\n\t\t\tioc->prod_name,\n\t\t\tMPT_FW_REV_MAGIC_ID_STRING,\t/* \"FwRev=\" or somesuch */\n\t\t\tioc->facts.FWVersion.Word,\n\t\t\texpVer,\n\t\t\tioc->facts.NumberOfPorts,\n\t\t\tioc->req_depth);\n\n\tif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\n\t\tu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\tseq_printf(m, \", LanAddr=%pMR\", a);\n\t}\n\n\tseq_printf(m, \", IRQ=%d\", ioc->pci_irq);\n\n\tif (!ioc->active)\n\t\tseq_printf(m, \" (disabled)\");\n\n\tseq_putc(m, '\\n');\n}"
    },
    {
        "var_name": "ioc",
        "function_name": "seq_mpt_print_ioc_summary",
        "location": {
            "file_path": "drivers/message/fusion/mptbase.c",
            "region": {
                "startLine": 6861,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 6859,
                "endLine": 6863,
                "snippet": {
                    "text": "ioc->req_depth);"
                }
            }
        },
        "function_code": "static void seq_mpt_print_ioc_summary(MPT_ADAPTER *ioc, struct seq_file *m, int showlan)\n{\n\tchar expVer[32];\n\n\tmpt_get_fw_exp_ver(expVer, ioc);\n\n\t/*\n\t *  Shorter summary of attached ioc's...\n\t */\n\tseq_printf(m, \"%s: %s, %s%08xh%s, Ports=%d, MaxQ=%d\",\n\t\t\tioc->name,\n\t\t\tioc->prod_name,\n\t\t\tMPT_FW_REV_MAGIC_ID_STRING,\t/* \"FwRev=\" or somesuch */\n\t\t\tioc->facts.FWVersion.Word,\n\t\t\texpVer,\n\t\t\tioc->facts.NumberOfPorts,\n\t\t\tioc->req_depth);\n\n\tif (showlan && (ioc->pfacts[0].ProtocolFlags & MPI_PORTFACTS_PROTOCOL_LAN)) {\n\t\tu8 *a = (u8*)&ioc->lan_cnfg_page1.HardwareAddressLow;\n\t\tseq_printf(m, \", LanAddr=%pMR\", a);\n\t}\n\n\tseq_printf(m, \", IRQ=%d\", ioc->pci_irq);\n\n\tif (!ioc->active)\n\t\tseq_printf(m, \" (disabled)\");\n\n\tseq_putc(m, '\\n');\n}"
    },
    {
        "var_name": "port_info",
        "function_name": "mptsas_expander_event_add",
        "location": {
            "file_path": "drivers/message/fusion/mptsas.c",
            "region": {
                "startLine": 3452,
                "startColumn": 2,
                "endColumn": 11
            },
            "context": {
                "startLine": 3450,
                "endLine": 3454,
                "snippet": {
                    "text": "port_info->num_phys = (expander_data->NumPhys) ?"
                }
            }
        },
        "function_code": "static void\nmptsas_expander_event_add(MPT_ADAPTER *ioc,\n    MpiEventDataSasExpanderStatusChange_t *expander_data)\n{\n\tstruct mptsas_portinfo *port_info;\n\tint i;\n\t__le64 sas_address;\n\n\tport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\n\tBUG_ON(!port_info);\n\tport_info->num_phys = (expander_data->NumPhys) ?\n\t    expander_data->NumPhys : 1;\n\tport_info->phy_info = kcalloc(port_info->num_phys,\n\t    sizeof(struct mptsas_phyinfo), GFP_KERNEL);\n\tBUG_ON(!port_info->phy_info);\n\tmemcpy(&sas_address, &expander_data->SASAddress, sizeof(__le64));\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tport_info->phy_info[i].portinfo = port_info;\n\t\tport_info->phy_info[i].handle =\n\t\t    le16_to_cpu(expander_data->DevHandle);\n\t\tport_info->phy_info[i].identify.sas_address =\n\t\t    le64_to_cpu(sas_address);\n\t\tport_info->phy_info[i].identify.handle_parent =\n\t\t    le16_to_cpu(expander_data->ParentDevHandle);\n\t}\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_add_tail(&port_info->list, &ioc->sas_topology);\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\n\tprintk(MYIOC_s_INFO_FMT \"add expander: num_phys %d, \"\n\t    \"sas_addr (0x%llx)\\n\", ioc->name, port_info->num_phys,\n\t    (unsigned long long)sas_address);\n\n\tmptsas_expander_refresh(ioc, port_info);\n}"
    },
    {
        "var_name": "port_info",
        "function_name": "mptsas_expander_event_add",
        "location": {
            "file_path": "drivers/message/fusion/mptsas.c",
            "region": {
                "startLine": 3454,
                "startColumn": 2,
                "endColumn": 11
            },
            "context": {
                "startLine": 3452,
                "endLine": 3456,
                "snippet": {
                    "text": "port_info->phy_info = kcalloc(port_info->num_phys,"
                }
            }
        },
        "function_code": "static void\nmptsas_expander_event_add(MPT_ADAPTER *ioc,\n    MpiEventDataSasExpanderStatusChange_t *expander_data)\n{\n\tstruct mptsas_portinfo *port_info;\n\tint i;\n\t__le64 sas_address;\n\n\tport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\n\tBUG_ON(!port_info);\n\tport_info->num_phys = (expander_data->NumPhys) ?\n\t    expander_data->NumPhys : 1;\n\tport_info->phy_info = kcalloc(port_info->num_phys,\n\t    sizeof(struct mptsas_phyinfo), GFP_KERNEL);\n\tBUG_ON(!port_info->phy_info);\n\tmemcpy(&sas_address, &expander_data->SASAddress, sizeof(__le64));\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tport_info->phy_info[i].portinfo = port_info;\n\t\tport_info->phy_info[i].handle =\n\t\t    le16_to_cpu(expander_data->DevHandle);\n\t\tport_info->phy_info[i].identify.sas_address =\n\t\t    le64_to_cpu(sas_address);\n\t\tport_info->phy_info[i].identify.handle_parent =\n\t\t    le16_to_cpu(expander_data->ParentDevHandle);\n\t}\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_add_tail(&port_info->list, &ioc->sas_topology);\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\n\tprintk(MYIOC_s_INFO_FMT \"add expander: num_phys %d, \"\n\t    \"sas_addr (0x%llx)\\n\", ioc->name, port_info->num_phys,\n\t    (unsigned long long)sas_address);\n\n\tmptsas_expander_refresh(ioc, port_info);\n}"
    },
    {
        "var_name": "port_info",
        "function_name": "mptsas_expander_event_add",
        "location": {
            "file_path": "drivers/message/fusion/mptsas.c",
            "region": {
                "startLine": 3456,
                "startColumn": 10,
                "endColumn": 19
            },
            "context": {
                "startLine": 3454,
                "endLine": 3458,
                "snippet": {
                    "text": "BUG_ON(!port_info->phy_info);"
                }
            }
        },
        "function_code": "static void\nmptsas_expander_event_add(MPT_ADAPTER *ioc,\n    MpiEventDataSasExpanderStatusChange_t *expander_data)\n{\n\tstruct mptsas_portinfo *port_info;\n\tint i;\n\t__le64 sas_address;\n\n\tport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\n\tBUG_ON(!port_info);\n\tport_info->num_phys = (expander_data->NumPhys) ?\n\t    expander_data->NumPhys : 1;\n\tport_info->phy_info = kcalloc(port_info->num_phys,\n\t    sizeof(struct mptsas_phyinfo), GFP_KERNEL);\n\tBUG_ON(!port_info->phy_info);\n\tmemcpy(&sas_address, &expander_data->SASAddress, sizeof(__le64));\n\tfor (i = 0; i < port_info->num_phys; i++) {\n\t\tport_info->phy_info[i].portinfo = port_info;\n\t\tport_info->phy_info[i].handle =\n\t\t    le16_to_cpu(expander_data->DevHandle);\n\t\tport_info->phy_info[i].identify.sas_address =\n\t\t    le64_to_cpu(sas_address);\n\t\tport_info->phy_info[i].identify.handle_parent =\n\t\t    le16_to_cpu(expander_data->ParentDevHandle);\n\t}\n\n\tmutex_lock(&ioc->sas_topology_mutex);\n\tlist_add_tail(&port_info->list, &ioc->sas_topology);\n\tmutex_unlock(&ioc->sas_topology_mutex);\n\n\tprintk(MYIOC_s_INFO_FMT \"add expander: num_phys %d, \"\n\t    \"sas_addr (0x%llx)\\n\", ioc->name, port_info->num_phys,\n\t    (unsigned long long)sas_address);\n\n\tmptsas_expander_refresh(ioc, port_info);\n}"
    },
    {
        "var_name": "pdata",
        "function_name": "max8925_irq_init",
        "location": {
            "file_path": "drivers/mfd/max8925-core.c",
            "region": {
                "startLine": 705,
                "startColumn": 7,
                "endColumn": 12
            },
            "context": {
                "startLine": 703,
                "endLine": 707,
                "snippet": {
                    "text": "if (!pdata->tsc_irq) {"
                }
            }
        },
        "function_code": "static int max8925_irq_init(struct max8925_chip *chip, int irq,\n\t\t\t    struct max8925_platform_data *pdata)\n{\n\tunsigned long flags = IRQF_TRIGGER_FALLING | IRQF_ONESHOT;\n\tint ret;\n\tstruct device_node *node = chip->dev->of_node;\n\n\t/* clear all interrupts */\n\tmax8925_reg_read(chip->i2c, MAX8925_CHG_IRQ1);\n\tmax8925_reg_read(chip->i2c, MAX8925_CHG_IRQ2);\n\tmax8925_reg_read(chip->i2c, MAX8925_ON_OFF_IRQ1);\n\tmax8925_reg_read(chip->i2c, MAX8925_ON_OFF_IRQ2);\n\tmax8925_reg_read(chip->rtc, MAX8925_RTC_IRQ);\n\tmax8925_reg_read(chip->adc, MAX8925_TSC_IRQ);\n\t/* mask all interrupts except for TSC */\n\tmax8925_reg_write(chip->rtc, MAX8925_ALARM0_CNTL, 0);\n\tmax8925_reg_write(chip->rtc, MAX8925_ALARM1_CNTL, 0);\n\tmax8925_reg_write(chip->i2c, MAX8925_CHG_IRQ1_MASK, 0xff);\n\tmax8925_reg_write(chip->i2c, MAX8925_CHG_IRQ2_MASK, 0xff);\n\tmax8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ1_MASK, 0xff);\n\tmax8925_reg_write(chip->i2c, MAX8925_ON_OFF_IRQ2_MASK, 0xff);\n\tmax8925_reg_write(chip->rtc, MAX8925_RTC_IRQ_MASK, 0xff);\n\n\tmutex_init(&chip->irq_lock);\n\tchip->irq_base = irq_alloc_descs(-1, 0, MAX8925_NR_IRQS, 0);\n\tif (chip->irq_base < 0) {\n\t\tdev_err(chip->dev, \"Failed to allocate interrupts, ret:%d\\n\",\n\t\t\tchip->irq_base);\n\t\treturn -EBUSY;\n\t}\n\n\tirq_domain_add_legacy(node, MAX8925_NR_IRQS, chip->irq_base, 0,\n\t\t\t      &max8925_irq_domain_ops, chip);\n\n\t/* request irq handler for pmic main irq*/\n\tchip->core_irq = irq;\n\tif (!chip->core_irq)\n\t\treturn -EBUSY;\n\tret = request_threaded_irq(irq, NULL, max8925_irq, flags | IRQF_ONESHOT,\n\t\t\t\t   \"max8925\", chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to request core IRQ: %d\\n\", ret);\n\t\tchip->core_irq = 0;\n\t\treturn -EBUSY;\n\t}\n\n\t/* request irq handler for pmic tsc irq*/\n\n\t/* mask TSC interrupt */\n\tmax8925_reg_write(chip->adc, MAX8925_TSC_IRQ_MASK, 0x0f);\n\n\tif (!pdata->tsc_irq) {\n\t\tdev_warn(chip->dev, \"No interrupt support on TSC IRQ\\n\");\n\t\treturn 0;\n\t}\n\tchip->tsc_irq = pdata->tsc_irq;\n\tret = request_threaded_irq(chip->tsc_irq, NULL, max8925_tsc_irq,\n\t\t\t\t   flags | IRQF_ONESHOT, \"max8925-tsc\", chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to request TSC IRQ: %d\\n\", ret);\n\t\tchip->tsc_irq = 0;\n\t}\n\treturn 0;\n}"
    },
    {
        "var_name": "entry",
        "function_name": "bcm_vk_read",
        "location": {
            "file_path": "drivers/misc/bcm-vk/bcm_vk_msg.c",
            "region": {
                "startLine": 1055,
                "startColumn": 31,
                "endColumn": 36
            },
            "context": {
                "startLine": 1053,
                "endLine": 1057,
                "snippet": {
                    "text": "struct vk_msg_blk tmp_msg = entry->to_h_msg[0];"
                }
            }
        },
        "function_code": "ssize_t bcm_vk_read(struct file *p_file,\n\t\t    char __user *buf,\n\t\t    size_t count,\n\t\t    loff_t *f_pos)\n{\n\tssize_t rc = -ENOMSG;\n\tstruct bcm_vk_ctx *ctx = p_file->private_data;\n\tstruct bcm_vk *vk = container_of(ctx->miscdev, struct bcm_vk,\n\t\t\t\t\t miscdev);\n\tstruct device *dev = &vk->pdev->dev;\n\tstruct bcm_vk_msg_chan *chan = &vk->to_h_msg_chan;\n\tstruct bcm_vk_wkent *entry = NULL, *iter;\n\tu32 q_num;\n\tu32 rsp_length;\n\n\tif (!bcm_vk_drv_access_ok(vk))\n\t\treturn -EPERM;\n\n\tdev_dbg(dev, \"Buf count %zu\\n\", count);\n\n\t/*\n\t * search through the pendq on the to_h chan, and return only those\n\t * that belongs to the same context.  Search is always from the high to\n\t * the low priority queues\n\t */\n\tspin_lock(&chan->pendq_lock);\n\tfor (q_num = 0; q_num < chan->q_nr; q_num++) {\n\t\tlist_for_each_entry(iter, &chan->pendq[q_num], node) {\n\t\t\tif (iter->ctx->idx == ctx->idx) {\n\t\t\t\tif (count >=\n\t\t\t\t    (iter->to_h_blks * VK_MSGQ_BLK_SIZE)) {\n\t\t\t\t\tlist_del(&iter->node);\n\t\t\t\t\tatomic_dec(&ctx->pend_cnt);\n\t\t\t\t\tentry = iter;\n\t\t\t\t} else {\n\t\t\t\t\t/* buffer not big enough */\n\t\t\t\t\trc = -EMSGSIZE;\n\t\t\t\t}\n\t\t\t\tgoto read_loop_exit;\n\t\t\t}\n\t\t}\n\t}\nread_loop_exit:\n\tspin_unlock(&chan->pendq_lock);\n\n\tif (entry) {\n\t\t/* retrieve the passed down msg_id */\n\t\tset_msg_id(&entry->to_h_msg[0], entry->usr_msg_id);\n\t\trsp_length = entry->to_h_blks * VK_MSGQ_BLK_SIZE;\n\t\tif (copy_to_user(buf, entry->to_h_msg, rsp_length) == 0)\n\t\t\trc = rsp_length;\n\n\t\tbcm_vk_free_wkent(dev, entry);\n\t} else if (rc == -EMSGSIZE) {\n\t\tstruct vk_msg_blk tmp_msg = entry->to_h_msg[0];\n\n\t\t/*\n\t\t * in this case, return just the first block, so\n\t\t * that app knows what size it is looking for.\n\t\t */\n\t\tset_msg_id(&tmp_msg, entry->usr_msg_id);\n\t\ttmp_msg.size = entry->to_h_blks - 1;\n\t\tif (copy_to_user(buf, &tmp_msg, VK_MSGQ_BLK_SIZE) != 0) {\n\t\t\tdev_err(dev, \"Error return 1st block in -EMSGSIZE\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\treturn rc;\n}"
    },
    {
        "var_name": "entry",
        "function_name": "bcm_vk_read",
        "location": {
            "file_path": "drivers/misc/bcm-vk/bcm_vk_msg.c",
            "region": {
                "startLine": 1061,
                "startColumn": 24,
                "endColumn": 29
            },
            "context": {
                "startLine": 1059,
                "endLine": 1063,
                "snippet": {
                    "text": "set_msg_id(&tmp_msg, entry->usr_msg_id);"
                }
            }
        },
        "function_code": "ssize_t bcm_vk_read(struct file *p_file,\n\t\t    char __user *buf,\n\t\t    size_t count,\n\t\t    loff_t *f_pos)\n{\n\tssize_t rc = -ENOMSG;\n\tstruct bcm_vk_ctx *ctx = p_file->private_data;\n\tstruct bcm_vk *vk = container_of(ctx->miscdev, struct bcm_vk,\n\t\t\t\t\t miscdev);\n\tstruct device *dev = &vk->pdev->dev;\n\tstruct bcm_vk_msg_chan *chan = &vk->to_h_msg_chan;\n\tstruct bcm_vk_wkent *entry = NULL, *iter;\n\tu32 q_num;\n\tu32 rsp_length;\n\n\tif (!bcm_vk_drv_access_ok(vk))\n\t\treturn -EPERM;\n\n\tdev_dbg(dev, \"Buf count %zu\\n\", count);\n\n\t/*\n\t * search through the pendq on the to_h chan, and return only those\n\t * that belongs to the same context.  Search is always from the high to\n\t * the low priority queues\n\t */\n\tspin_lock(&chan->pendq_lock);\n\tfor (q_num = 0; q_num < chan->q_nr; q_num++) {\n\t\tlist_for_each_entry(iter, &chan->pendq[q_num], node) {\n\t\t\tif (iter->ctx->idx == ctx->idx) {\n\t\t\t\tif (count >=\n\t\t\t\t    (iter->to_h_blks * VK_MSGQ_BLK_SIZE)) {\n\t\t\t\t\tlist_del(&iter->node);\n\t\t\t\t\tatomic_dec(&ctx->pend_cnt);\n\t\t\t\t\tentry = iter;\n\t\t\t\t} else {\n\t\t\t\t\t/* buffer not big enough */\n\t\t\t\t\trc = -EMSGSIZE;\n\t\t\t\t}\n\t\t\t\tgoto read_loop_exit;\n\t\t\t}\n\t\t}\n\t}\nread_loop_exit:\n\tspin_unlock(&chan->pendq_lock);\n\n\tif (entry) {\n\t\t/* retrieve the passed down msg_id */\n\t\tset_msg_id(&entry->to_h_msg[0], entry->usr_msg_id);\n\t\trsp_length = entry->to_h_blks * VK_MSGQ_BLK_SIZE;\n\t\tif (copy_to_user(buf, entry->to_h_msg, rsp_length) == 0)\n\t\t\trc = rsp_length;\n\n\t\tbcm_vk_free_wkent(dev, entry);\n\t} else if (rc == -EMSGSIZE) {\n\t\tstruct vk_msg_blk tmp_msg = entry->to_h_msg[0];\n\n\t\t/*\n\t\t * in this case, return just the first block, so\n\t\t * that app knows what size it is looking for.\n\t\t */\n\t\tset_msg_id(&tmp_msg, entry->usr_msg_id);\n\t\ttmp_msg.size = entry->to_h_blks - 1;\n\t\tif (copy_to_user(buf, &tmp_msg, VK_MSGQ_BLK_SIZE) != 0) {\n\t\t\tdev_err(dev, \"Error return 1st block in -EMSGSIZE\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\treturn rc;\n}"
    },
    {
        "var_name": "entry",
        "function_name": "bcm_vk_read",
        "location": {
            "file_path": "drivers/misc/bcm-vk/bcm_vk_msg.c",
            "region": {
                "startLine": 1062,
                "startColumn": 18,
                "endColumn": 23
            },
            "context": {
                "startLine": 1060,
                "endLine": 1064,
                "snippet": {
                    "text": "tmp_msg.size = entry->to_h_blks - 1;"
                }
            }
        },
        "function_code": "ssize_t bcm_vk_read(struct file *p_file,\n\t\t    char __user *buf,\n\t\t    size_t count,\n\t\t    loff_t *f_pos)\n{\n\tssize_t rc = -ENOMSG;\n\tstruct bcm_vk_ctx *ctx = p_file->private_data;\n\tstruct bcm_vk *vk = container_of(ctx->miscdev, struct bcm_vk,\n\t\t\t\t\t miscdev);\n\tstruct device *dev = &vk->pdev->dev;\n\tstruct bcm_vk_msg_chan *chan = &vk->to_h_msg_chan;\n\tstruct bcm_vk_wkent *entry = NULL, *iter;\n\tu32 q_num;\n\tu32 rsp_length;\n\n\tif (!bcm_vk_drv_access_ok(vk))\n\t\treturn -EPERM;\n\n\tdev_dbg(dev, \"Buf count %zu\\n\", count);\n\n\t/*\n\t * search through the pendq on the to_h chan, and return only those\n\t * that belongs to the same context.  Search is always from the high to\n\t * the low priority queues\n\t */\n\tspin_lock(&chan->pendq_lock);\n\tfor (q_num = 0; q_num < chan->q_nr; q_num++) {\n\t\tlist_for_each_entry(iter, &chan->pendq[q_num], node) {\n\t\t\tif (iter->ctx->idx == ctx->idx) {\n\t\t\t\tif (count >=\n\t\t\t\t    (iter->to_h_blks * VK_MSGQ_BLK_SIZE)) {\n\t\t\t\t\tlist_del(&iter->node);\n\t\t\t\t\tatomic_dec(&ctx->pend_cnt);\n\t\t\t\t\tentry = iter;\n\t\t\t\t} else {\n\t\t\t\t\t/* buffer not big enough */\n\t\t\t\t\trc = -EMSGSIZE;\n\t\t\t\t}\n\t\t\t\tgoto read_loop_exit;\n\t\t\t}\n\t\t}\n\t}\nread_loop_exit:\n\tspin_unlock(&chan->pendq_lock);\n\n\tif (entry) {\n\t\t/* retrieve the passed down msg_id */\n\t\tset_msg_id(&entry->to_h_msg[0], entry->usr_msg_id);\n\t\trsp_length = entry->to_h_blks * VK_MSGQ_BLK_SIZE;\n\t\tif (copy_to_user(buf, entry->to_h_msg, rsp_length) == 0)\n\t\t\trc = rsp_length;\n\n\t\tbcm_vk_free_wkent(dev, entry);\n\t} else if (rc == -EMSGSIZE) {\n\t\tstruct vk_msg_blk tmp_msg = entry->to_h_msg[0];\n\n\t\t/*\n\t\t * in this case, return just the first block, so\n\t\t * that app knows what size it is looking for.\n\t\t */\n\t\tset_msg_id(&tmp_msg, entry->usr_msg_id);\n\t\ttmp_msg.size = entry->to_h_blks - 1;\n\t\tif (copy_to_user(buf, &tmp_msg, VK_MSGQ_BLK_SIZE) != 0) {\n\t\t\tdev_err(dev, \"Error return 1st block in -EMSGSIZE\\n\");\n\t\t\trc = -EFAULT;\n\t\t}\n\t}\n\treturn rc;\n}"
    },
    {
        "var_name": "afu",
        "function_name": "guest_collect_vpd",
        "location": {
            "file_path": "drivers/misc/cxl/guest.c",
            "region": {
                "startLine": 120,
                "startColumn": 26,
                "endColumn": 29
            },
            "context": {
                "startLine": 118,
                "endLine": 122,
                "snippet": {
                    "text": "rc = cxl_h_collect_vpd(afu->guest->handle, 0,"
                }
            }
        },
        "function_code": "static ssize_t guest_collect_vpd(struct cxl *adapter, struct cxl_afu *afu,\n\t\t\tvoid *buf, size_t len)\n{\n\tunsigned int entries, mod;\n\tunsigned long **vpd_buf = NULL;\n\tstruct sg_list *le;\n\tint rc = 0, i, tocopy;\n\tu64 out = 0;\n\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\n\t/* number of entries in the list */\n\tentries = len / SG_BUFFER_SIZE;\n\tmod = len % SG_BUFFER_SIZE;\n\tif (mod)\n\t\tentries++;\n\n\tif (entries > SG_MAX_ENTRIES) {\n\t\tentries = SG_MAX_ENTRIES;\n\t\tlen = SG_MAX_ENTRIES * SG_BUFFER_SIZE;\n\t\tmod = 0;\n\t}\n\n\tvpd_buf = kcalloc(entries, sizeof(unsigned long *), GFP_KERNEL);\n\tif (!vpd_buf)\n\t\treturn -ENOMEM;\n\n\tle = (struct sg_list *)get_zeroed_page(GFP_KERNEL);\n\tif (!le) {\n\t\trc = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tfor (i = 0; i < entries; i++) {\n\t\tvpd_buf[i] = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!vpd_buf[i]) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err2;\n\t\t}\n\t\tle[i].phys_addr = cpu_to_be64(virt_to_phys(vpd_buf[i]));\n\t\tle[i].len = cpu_to_be64(SG_BUFFER_SIZE);\n\t\tif ((i == (entries - 1)) && mod)\n\t\t\tle[i].len = cpu_to_be64(mod);\n\t}\n\n\tif (adapter)\n\t\trc = cxl_h_collect_vpd_adapter(adapter->guest->handle,\n\t\t\t\t\tvirt_to_phys(le), entries, &out);\n\telse\n\t\trc = cxl_h_collect_vpd(afu->guest->handle, 0,\n\t\t\t\tvirt_to_phys(le), entries, &out);\n\tpr_devel(\"length of available (entries: %i), vpd: %#llx\\n\",\n\t\tentries, out);\n\n\tif (!rc) {\n\t\t/*\n\t\t * hcall returns in 'out' the size of available VPDs.\n\t\t * It fills the buffer with as much data as possible.\n\t\t */\n\t\tif (out < len)\n\t\t\tlen = out;\n\t\trc = len;\n\t\tif (out) {\n\t\t\tfor (i = 0; i < entries; i++) {\n\t\t\t\tif (len < SG_BUFFER_SIZE)\n\t\t\t\t\ttocopy = len;\n\t\t\t\telse\n\t\t\t\t\ttocopy = SG_BUFFER_SIZE;\n\t\t\t\tmemcpy(buf, vpd_buf[i], tocopy);\n\t\t\t\tbuf += tocopy;\n\t\t\t\tlen -= tocopy;\n\t\t\t}\n\t\t}\n\t}\nerr2:\n\tfor (i = 0; i < entries; i++) {\n\t\tif (vpd_buf[i])\n\t\t\tfree_page((unsigned long) vpd_buf[i]);\n\t}\n\tfree_page((unsigned long) le);\nerr1:\n\tkfree(vpd_buf);\n\treturn rc;\n}"
    },
    {
        "var_name": "map",
        "function_name": "fastrpc_map_lookup",
        "location": {
            "file_path": "drivers/misc/fastrpc.c",
            "region": {
                "startLine": 373,
                "startColumn": 7,
                "endColumn": 10
            },
            "context": {
                "startLine": 371,
                "endLine": 375,
                "snippet": {
                    "text": "if (map->fd != fd)"
                }
            }
        },
        "function_code": "static int fastrpc_map_lookup(struct fastrpc_user *fl, int fd,\n\t\t\t    struct fastrpc_map **ppmap, bool take_ref)\n{\n\tstruct fastrpc_session_ctx *sess = fl->sctx;\n\tstruct fastrpc_map *map = NULL;\n\tint ret = -ENOENT;\n\n\tspin_lock(&fl->lock);\n\tlist_for_each_entry(map, &fl->maps, node) {\n\t\tif (map->fd != fd)\n\t\t\tcontinue;\n\n\t\tif (take_ref) {\n\t\t\tret = fastrpc_map_get(map);\n\t\t\tif (ret) {\n\t\t\t\tdev_dbg(sess->dev, \"%s: Failed to get map fd=%d ret=%d\\n\",\n\t\t\t\t\t__func__, fd, ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*ppmap = map;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&fl->lock);\n\n\treturn ret;\n}"
    },
    {
        "var_name": "(volatile int*)0",
        "function_name": "lkdtm_EXCEPTION",
        "location": {
            "file_path": "drivers/misc/lkdtm/bugs.c",
            "region": {
                "startLine": 122,
                "startColumn": 4,
                "endColumn": 20
            },
            "context": {
                "startLine": 120,
                "endLine": 124,
                "snippet": {
                    "text": "*((volatile int *) 0) = 0;"
                }
            }
        },
        "function_code": "static void lkdtm_EXCEPTION(void)\n{\n\t*((volatile int *) 0) = 0;\n}"
    },
    {
        "var_name": "ptr",
        "function_name": "lkdtm_ACCESS_NULL",
        "location": {
            "file_path": "drivers/misc/lkdtm/perms.c",
            "region": {
                "startLine": 259,
                "startColumn": 9,
                "endColumn": 12
            },
            "context": {
                "startLine": 257,
                "endLine": 261,
                "snippet": {
                    "text": "tmp = *ptr;"
                }
            }
        },
        "function_code": "static void lkdtm_ACCESS_NULL(void)\n{\n\tunsigned long tmp;\n\tvolatile unsigned long *ptr = (unsigned long *)NULL;\n\n\tpr_info(\"attempting bad read at %px\\n\", ptr);\n\ttmp = *ptr;\n\ttmp += 0xc0dec0de;\n\tpr_err(\"FAIL: survived bad read\\n\");\n\n\tpr_info(\"attempting bad write at %px\\n\", ptr);\n\t*ptr = tmp;\n\tpr_err(\"FAIL: survived bad write\\n\");\n}"
    },
    {
        "var_name": "ptr",
        "function_name": "lkdtm_ACCESS_NULL",
        "location": {
            "file_path": "drivers/misc/lkdtm/perms.c",
            "region": {
                "startLine": 264,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 262,
                "endLine": 266,
                "snippet": {
                    "text": "*ptr = tmp;"
                }
            }
        },
        "function_code": "static void lkdtm_ACCESS_NULL(void)\n{\n\tunsigned long tmp;\n\tvolatile unsigned long *ptr = (unsigned long *)NULL;\n\n\tpr_info(\"attempting bad read at %px\\n\", ptr);\n\ttmp = *ptr;\n\ttmp += 0xc0dec0de;\n\tpr_err(\"FAIL: survived bad read\\n\");\n\n\tpr_info(\"attempting bad write at %px\\n\", ptr);\n\t*ptr = tmp;\n\tpr_err(\"FAIL: survived bad write\\n\");\n}"
    },
    {
        "var_name": "kgts",
        "function_name": "gru_get_cb_exception_detail",
        "location": {
            "file_path": "drivers/misc/sgi-gru/grukservices.c",
            "region": {
                "startLine": 412,
                "startColumn": 11,
                "endColumn": 15
            },
            "context": {
                "startLine": 410,
                "endLine": 414,
                "snippet": {
                    "text": "cbrnum = thread_cbr_number(kgts, get_cb_number(cb));"
                }
            }
        },
        "function_code": "int gru_get_cb_exception_detail(void *cb,\n\t\tstruct control_block_extended_exc_detail *excdet)\n{\n\tstruct gru_control_block_extended *cbe;\n\tstruct gru_thread_state *kgts = NULL;\n\tunsigned long off;\n\tint cbrnum, bid;\n\n\t/*\n\t * Locate kgts for cb. This algorithm is SLOW but\n\t * this function is rarely called (ie., almost never).\n\t * Performance does not matter.\n\t */\n\tfor_each_possible_blade(bid) {\n\t\tif (!gru_base[bid])\n\t\t\tbreak;\n\t\tkgts = gru_base[bid]->bs_kgts;\n\t\tif (!kgts || !kgts->ts_gru)\n\t\t\tcontinue;\n\t\toff = cb - kgts->ts_gru->gs_gru_base_vaddr;\n\t\tif (off < GRU_SIZE)\n\t\t\tbreak;\n\t\tkgts = NULL;\n\t}\n\tBUG_ON(!kgts);\n\tcbrnum = thread_cbr_number(kgts, get_cb_number(cb));\n\tcbe = get_cbe(GRUBASE(cb), cbrnum);\n\tgru_flush_cache(cbe);\t/* CBE not coherent */\n\tsync_core();\n\texcdet->opc = cbe->opccpy;\n\texcdet->exopc = cbe->exopccpy;\n\texcdet->ecause = cbe->ecause;\n\texcdet->exceptdet0 = cbe->idef1upd;\n\texcdet->exceptdet1 = cbe->idef3upd;\n\tgru_flush_cache(cbe);\n\treturn 0;\n}"
    },
    {
        "var_name": "st_gdata",
        "function_name": "st_send_frame",
        "location": {
            "file_path": "drivers/misc/ti-st/st_core.c",
            "region": {
                "startLine": 100,
                "startColumn": 13,
                "endColumn": 21
            },
            "context": {
                "startLine": 98,
                "endLine": 102,
                "snippet": {
                    "text": "kfree_skb(st_gdata->rx_skb);"
                }
            }
        },
        "function_code": "static void st_send_frame(unsigned char chnl_id, struct st_data_s *st_gdata)\n{\n\tpr_debug(\" %s(prot:%d) \", __func__, chnl_id);\n\n\tif (unlikely\n\t    (st_gdata == NULL || st_gdata->rx_skb == NULL\n\t     || st_gdata->is_registered[chnl_id] == false)) {\n\t\tpr_err(\"chnl_id %d not registered, no data to send?\",\n\t\t\t   chnl_id);\n\t\tkfree_skb(st_gdata->rx_skb);\n\t\treturn;\n\t}\n\t/*\n\t * this cannot fail\n\t * this shouldn't take long\n\t * - should be just skb_queue_tail for the\n\t *   protocol stack driver\n\t */\n\tif (likely(st_gdata->list[chnl_id]->recv != NULL)) {\n\t\tif (unlikely\n\t\t\t(st_gdata->list[chnl_id]->recv\n\t\t\t(st_gdata->list[chnl_id]->priv_data, st_gdata->rx_skb)\n\t\t\t     != 0)) {\n\t\t\tpr_err(\" proto stack %d's ->recv failed\", chnl_id);\n\t\t\tkfree_skb(st_gdata->rx_skb);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tpr_err(\" proto stack %d's ->recv null\", chnl_id);\n\t\tkfree_skb(st_gdata->rx_skb);\n\t}\n\treturn;\n}"
    },
    {
        "var_name": "card",
        "function_name": "mmc_sdio_hw_reset",
        "location": {
            "file_path": "drivers/mmc/core/sdio.c",
            "region": {
                "startLine": 1164,
                "startColumn": 3,
                "endColumn": 7
            },
            "context": {
                "startLine": 1162,
                "endLine": 1166,
                "snippet": {
                    "text": "mmc_card_set_removed(card);"
                }
            }
        },
        "function_code": "static int mmc_sdio_hw_reset(struct mmc_host *host)\n{\n\tstruct mmc_card *card = host->card;\n\n\t/*\n\t * In case the card is shared among multiple func drivers, reset the\n\t * card through a rescan work. In this way it will be removed and\n\t * re-detected, thus all func drivers becomes informed about it.\n\t */\n\tif (atomic_read(&card->sdio_funcs_probed) > 1) {\n\t\tif (mmc_card_removed(card))\n\t\t\treturn 1;\n\t\thost->rescan_entered = 0;\n\t\tmmc_card_set_removed(card);\n\t\t_mmc_detect_change(host, 0, false);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * A single func driver has been probed, then let's skip the heavy\n\t * hotplug dance above and execute the reset immediately.\n\t */\n\tmmc_power_cycle(host, card->ocr);\n\treturn mmc_sdio_reinit_card(host);\n}"
    },
    {
        "var_name": "slot",
        "function_name": "mmc_omap_release_slot",
        "location": {
            "file_path": "drivers/mmc/host/omap.c",
            "region": {
                "startLine": 265,
                "startColumn": 31,
                "endColumn": 35
            },
            "context": {
                "startLine": 263,
                "endLine": 267,
                "snippet": {
                    "text": "struct mmc_omap_host *host = slot->host;"
                }
            }
        },
        "function_code": "static void mmc_omap_release_slot(struct mmc_omap_slot *slot, int clk_enabled)\n{\n\tstruct mmc_omap_host *host = slot->host;\n\tunsigned long flags;\n\tint i;\n\n\tBUG_ON(slot == NULL || host->mmc == NULL);\n\n\tif (clk_enabled)\n\t\t/* Keeps clock running for at least 8 cycles on valid freq */\n\t\tmod_timer(&host->clk_timer, jiffies  + HZ/10);\n\telse {\n\t\tdel_timer(&host->clk_timer);\n\t\tmmc_omap_fclk_offdelay(slot);\n\t\tmmc_omap_fclk_enable(host, 0);\n\t}\n\n\tspin_lock_irqsave(&host->slot_lock, flags);\n\t/* Check for any pending requests */\n\tfor (i = 0; i < host->nr_slots; i++) {\n\t\tstruct mmc_omap_slot *new_slot;\n\n\t\tif (host->slots[i] == NULL || host->slots[i]->mrq == NULL)\n\t\t\tcontinue;\n\n\t\tBUG_ON(host->next_slot != NULL);\n\t\tnew_slot = host->slots[i];\n\t\t/* The current slot should not have a request in queue */\n\t\tBUG_ON(new_slot == host->current_slot);\n\n\t\thost->next_slot = new_slot;\n\t\thost->mmc = new_slot->mmc;\n\t\tspin_unlock_irqrestore(&host->slot_lock, flags);\n\t\tqueue_work(host->mmc_omap_wq, &host->slot_release_work);\n\t\treturn;\n\t}\n\n\thost->mmc = NULL;\n\twake_up(&host->slot_wq);\n\tspin_unlock_irqrestore(&host->slot_lock, flags);\n}"
    },
    {
        "var_name": "mrq",
        "function_name": "owl_mmc_finish_request",
        "location": {
            "file_path": "drivers/mmc/host/owl-mmc.c",
            "region": {
                "startLine": 158,
                "startColumn": 26,
                "endColumn": 29
            },
            "context": {
                "startLine": 156,
                "endLine": 160,
                "snippet": {
                    "text": "struct mmc_data *data = mrq->data;"
                }
            }
        },
        "function_code": "static void owl_mmc_finish_request(struct owl_mmc_host *owl_host)\n{\n\tstruct mmc_request *mrq = owl_host->mrq;\n\tstruct mmc_data *data = mrq->data;\n\n\t/* Should never be NULL */\n\tWARN_ON(!mrq);\n\n\towl_host->mrq = NULL;\n\n\tif (data)\n\t\tdma_unmap_sg(owl_host->dma->device->dev, data->sg, data->sg_len,\n\t\t\t     owl_host->dma_dir);\n\n\t/* Finally finish request */\n\tmmc_request_done(owl_host->mmc, mrq);\n}"
    },
    {
        "var_name": "cmd",
        "function_name": "sdhci_target_timeout",
        "location": {
            "file_path": "drivers/mmc/host/sdhci.c",
            "region": {
                "startLine": 911,
                "startColumn": 20,
                "endColumn": 23
            },
            "context": {
                "startLine": 909,
                "endLine": 913,
                "snippet": {
                    "text": "target_timeout = cmd->busy_timeout * 1000;"
                }
            }
        },
        "function_code": "static unsigned int sdhci_target_timeout(struct sdhci_host *host,\n\t\t\t\t\t struct mmc_command *cmd,\n\t\t\t\t\t struct mmc_data *data)\n{\n\tunsigned int target_timeout;\n\n\t/* timeout in us */\n\tif (!data) {\n\t\ttarget_timeout = cmd->busy_timeout * 1000;\n\t} else {\n\t\ttarget_timeout = DIV_ROUND_UP(data->timeout_ns, 1000);\n\t\tif (host->clock && data->timeout_clks) {\n\t\t\tunsigned long long val;\n\n\t\t\t/*\n\t\t\t * data->timeout_clks is in units of clock cycles.\n\t\t\t * host->clock is in Hz.  target_timeout is in us.\n\t\t\t * Hence, us = 1000000 * cycles / Hz.  Round up.\n\t\t\t */\n\t\t\tval = 1000000ULL * data->timeout_clks;\n\t\t\tif (do_div(val, host->clock))\n\t\t\t\ttarget_timeout++;\n\t\t\ttarget_timeout += val;\n\t\t}\n\t}\n\n\treturn target_timeout;\n}"
    },
    {
        "var_name": "cmd",
        "function_name": "sdhci_calc_sw_timeout",
        "location": {
            "file_path": "drivers/mmc/host/sdhci.c",
            "region": {
                "startLine": 935,
                "startColumn": 26,
                "endColumn": 29
            },
            "context": {
                "startLine": 933,
                "endLine": 937,
                "snippet": {
                    "text": "struct mmc_data *data = cmd->data;"
                }
            }
        },
        "function_code": "static void sdhci_calc_sw_timeout(struct sdhci_host *host,\n\t\t\t\t  struct mmc_command *cmd)\n{\n\tstruct mmc_data *data = cmd->data;\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct mmc_ios *ios = &mmc->ios;\n\tunsigned char bus_width = 1 << ios->bus_width;\n\tunsigned int blksz;\n\tunsigned int freq;\n\tu64 target_timeout;\n\tu64 transfer_time;\n\n\ttarget_timeout = sdhci_target_timeout(host, cmd, data);\n\ttarget_timeout *= NSEC_PER_USEC;\n\n\tif (data) {\n\t\tblksz = data->blksz;\n\t\tfreq = mmc->actual_clock ? : host->clock;\n\t\ttransfer_time = (u64)blksz * NSEC_PER_SEC * (8 / bus_width);\n\t\tdo_div(transfer_time, freq);\n\t\t/* multiply by '2' to account for any unknowns */\n\t\ttransfer_time = transfer_time * 2;\n\t\t/* calculate timeout for the entire data */\n\t\thost->data_timeout = data->blocks * target_timeout +\n\t\t\t\t     transfer_time;\n\t} else {\n\t\thost->data_timeout = target_timeout;\n\t}\n\n\tif (host->data_timeout)\n\t\thost->data_timeout += MMC_CMD_TRANSFER_TIME;\n}"
    },
    {
        "var_name": "addr",
        "function_name": "gpmi_chain_command",
        "location": {
            "file_path": "drivers/mtd/nand/raw/gpmi-nand/gpmi-nand.c",
            "region": {
                "startLine": 2359,
                "startColumn": 32,
                "endColumn": 36
            },
            "context": {
                "startLine": 2357,
                "endLine": 2361,
                "snippet": {
                    "text": "memcpy(&transfer->cmdbuf[1], addr, naddr);"
                }
            }
        },
        "function_code": "static struct dma_async_tx_descriptor *gpmi_chain_command(\n\tstruct gpmi_nand_data *this, u8 cmd, const u8 *addr, int naddr)\n{\n\tstruct dma_chan *channel = get_dma_chan(this);\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct gpmi_transfer *transfer;\n\tint chip = this->nand.cur_cs;\n\tu32 pio[3];\n\n\t/* [1] send out the PIO words */\n\tpio[0] = BF_GPMI_CTRL0_COMMAND_MODE(BV_GPMI_CTRL0_COMMAND_MODE__WRITE)\n\t\t| BM_GPMI_CTRL0_WORD_LENGTH\n\t\t| BF_GPMI_CTRL0_CS(chip, this)\n\t\t| BF_GPMI_CTRL0_LOCK_CS(LOCK_CS_ENABLE, this)\n\t\t| BF_GPMI_CTRL0_ADDRESS(BV_GPMI_CTRL0_ADDRESS__NAND_CLE)\n\t\t| BM_GPMI_CTRL0_ADDRESS_INCREMENT\n\t\t| BF_GPMI_CTRL0_XFER_COUNT(naddr + 1);\n\tpio[1] = 0;\n\tpio[2] = 0;\n\tdesc = mxs_dmaengine_prep_pio(channel, pio, ARRAY_SIZE(pio),\n\t\t\t\t      DMA_TRANS_NONE, 0);\n\tif (!desc)\n\t\treturn NULL;\n\n\ttransfer = get_next_transfer(this);\n\tif (!transfer)\n\t\treturn NULL;\n\n\ttransfer->cmdbuf[0] = cmd;\n\tif (naddr)\n\t\tmemcpy(&transfer->cmdbuf[1], addr, naddr);\n\n\tsg_init_one(&transfer->sgl, transfer->cmdbuf, naddr + 1);\n\tdma_map_sg(this->dev, &transfer->sgl, 1, DMA_TO_DEVICE);\n\n\ttransfer->direction = DMA_TO_DEVICE;\n\n\tdesc = dmaengine_prep_slave_sg(channel, &transfer->sgl, 1, DMA_MEM_TO_DEV,\n\t\t\t\t       MXS_DMA_CTRL_WAIT4END);\n\treturn desc;\n}"
    },
    {
        "var_name": "extraoob",
        "function_name": "nand_check_erased_ecc_chunk",
        "location": {
            "file_path": "drivers/mtd/nand/raw/nand_base.c",
            "region": {
                "startLine": 2904,
                "startColumn": 10,
                "endColumn": 18
            },
            "context": {
                "startLine": 2902,
                "endLine": 2906,
                "snippet": {
                    "text": "memset(extraoob, 0xff, extraooblen);"
                }
            }
        },
        "function_code": "int nand_check_erased_ecc_chunk(void *data, int datalen,\n\t\t\t\tvoid *ecc, int ecclen,\n\t\t\t\tvoid *extraoob, int extraooblen,\n\t\t\t\tint bitflips_threshold)\n{\n\tint data_bitflips = 0, ecc_bitflips = 0, extraoob_bitflips = 0;\n\n\tdata_bitflips = nand_check_erased_buf(data, datalen,\n\t\t\t\t\t      bitflips_threshold);\n\tif (data_bitflips < 0)\n\t\treturn data_bitflips;\n\n\tbitflips_threshold -= data_bitflips;\n\n\tecc_bitflips = nand_check_erased_buf(ecc, ecclen, bitflips_threshold);\n\tif (ecc_bitflips < 0)\n\t\treturn ecc_bitflips;\n\n\tbitflips_threshold -= ecc_bitflips;\n\n\textraoob_bitflips = nand_check_erased_buf(extraoob, extraooblen,\n\t\t\t\t\t\t  bitflips_threshold);\n\tif (extraoob_bitflips < 0)\n\t\treturn extraoob_bitflips;\n\n\tif (data_bitflips)\n\t\tmemset(data, 0xff, datalen);\n\n\tif (ecc_bitflips)\n\t\tmemset(ecc, 0xff, ecclen);\n\n\tif (extraoob_bitflips)\n\t\tmemset(extraoob, 0xff, extraooblen);\n\n\treturn data_bitflips + ecc_bitflips + extraoob_bitflips;\n}"
    },
    {
        "var_name": "set",
        "function_name": "s3c2410_nand_init_chip",
        "location": {
            "file_path": "drivers/mtd/nand/raw/s3c2410.c",
            "region": {
                "startLine": 795,
                "startColumn": 28,
                "endColumn": 31
            },
            "context": {
                "startLine": 793,
                "endLine": 797,
                "snippet": {
                    "text": "nand_set_flash_node(chip, set->of_node);"
                }
            }
        },
        "function_code": "static void s3c2410_nand_init_chip(struct s3c2410_nand_info *info,\n\t\t\t\t   struct s3c2410_nand_mtd *nmtd,\n\t\t\t\t   struct s3c2410_nand_set *set)\n{\n\tstruct device_node *np = info->device->of_node;\n\tstruct nand_chip *chip = &nmtd->chip;\n\tvoid __iomem *regs = info->regs;\n\n\tnand_set_flash_node(chip, set->of_node);\n\n\tchip->legacy.write_buf    = s3c2410_nand_write_buf;\n\tchip->legacy.read_buf     = s3c2410_nand_read_buf;\n\tchip->legacy.select_chip  = s3c2410_nand_select_chip;\n\tchip->legacy.chip_delay   = 50;\n\tnand_set_controller_data(chip, nmtd);\n\tchip->options\t   = set->options;\n\tchip->controller   = &info->controller;\n\n\t/*\n\t * let's keep behavior unchanged for legacy boards booting via pdata and\n\t * auto-detect timings only when booting with a device tree.\n\t */\n\tif (!np)\n\t\tchip->options |= NAND_KEEP_TIMINGS;\n\n\tswitch (info->cpu_type) {\n\tcase TYPE_S3C2410:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2410_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2410_NFCONF;\n\t\tinfo->sel_bit\t= S3C2410_NFCONF_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2410_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2410_nand_devready;\n\t\tbreak;\n\n\tcase TYPE_S3C2440:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2440_NFCONT_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2440_nand_devready;\n\t\tchip->legacy.read_buf  = s3c2440_nand_read_buf;\n\t\tchip->legacy.write_buf\t= s3c2440_nand_write_buf;\n\t\tbreak;\n\n\tcase TYPE_S3C2412:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2412_NFCONT_nFCE0;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2412_nand_devready;\n\n\t\tif (readl(regs + S3C2410_NFCONF) & S3C2412_NFCONF_NANDBOOT)\n\t\t\tdev_info(info->device, \"System booted from NAND\\n\");\n\n\t\tbreak;\n\t}\n\n\tchip->legacy.IO_ADDR_R = chip->legacy.IO_ADDR_W;\n\n\tnmtd->info\t   = info;\n\tnmtd->set\t   = set;\n\n\tchip->ecc.engine_type = info->platform->engine_type;\n\n\t/*\n\t * If you use u-boot BBT creation code, specifying this flag will\n\t * let the kernel fish out the BBT from the NAND.\n\t */\n\tif (set->flash_bbt)\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n}"
    },
    {
        "var_name": "set",
        "function_name": "s3c2410_nand_init_chip",
        "location": {
            "file_path": "drivers/mtd/nand/raw/s3c2410.c",
            "region": {
                "startLine": 802,
                "startColumn": 21,
                "endColumn": 24
            },
            "context": {
                "startLine": 800,
                "endLine": 804,
                "snippet": {
                    "text": "chip->options\t   = set->options;"
                }
            }
        },
        "function_code": "static void s3c2410_nand_init_chip(struct s3c2410_nand_info *info,\n\t\t\t\t   struct s3c2410_nand_mtd *nmtd,\n\t\t\t\t   struct s3c2410_nand_set *set)\n{\n\tstruct device_node *np = info->device->of_node;\n\tstruct nand_chip *chip = &nmtd->chip;\n\tvoid __iomem *regs = info->regs;\n\n\tnand_set_flash_node(chip, set->of_node);\n\n\tchip->legacy.write_buf    = s3c2410_nand_write_buf;\n\tchip->legacy.read_buf     = s3c2410_nand_read_buf;\n\tchip->legacy.select_chip  = s3c2410_nand_select_chip;\n\tchip->legacy.chip_delay   = 50;\n\tnand_set_controller_data(chip, nmtd);\n\tchip->options\t   = set->options;\n\tchip->controller   = &info->controller;\n\n\t/*\n\t * let's keep behavior unchanged for legacy boards booting via pdata and\n\t * auto-detect timings only when booting with a device tree.\n\t */\n\tif (!np)\n\t\tchip->options |= NAND_KEEP_TIMINGS;\n\n\tswitch (info->cpu_type) {\n\tcase TYPE_S3C2410:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2410_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2410_NFCONF;\n\t\tinfo->sel_bit\t= S3C2410_NFCONF_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2410_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2410_nand_devready;\n\t\tbreak;\n\n\tcase TYPE_S3C2440:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2440_NFCONT_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2440_nand_devready;\n\t\tchip->legacy.read_buf  = s3c2440_nand_read_buf;\n\t\tchip->legacy.write_buf\t= s3c2440_nand_write_buf;\n\t\tbreak;\n\n\tcase TYPE_S3C2412:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2412_NFCONT_nFCE0;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2412_nand_devready;\n\n\t\tif (readl(regs + S3C2410_NFCONF) & S3C2412_NFCONF_NANDBOOT)\n\t\t\tdev_info(info->device, \"System booted from NAND\\n\");\n\n\t\tbreak;\n\t}\n\n\tchip->legacy.IO_ADDR_R = chip->legacy.IO_ADDR_W;\n\n\tnmtd->info\t   = info;\n\tnmtd->set\t   = set;\n\n\tchip->ecc.engine_type = info->platform->engine_type;\n\n\t/*\n\t * If you use u-boot BBT creation code, specifying this flag will\n\t * let the kernel fish out the BBT from the NAND.\n\t */\n\tif (set->flash_bbt)\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n}"
    },
    {
        "var_name": "set",
        "function_name": "s3c2410_nand_init_chip",
        "location": {
            "file_path": "drivers/mtd/nand/raw/s3c2410.c",
            "region": {
                "startLine": 855,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 853,
                "endLine": 857,
                "snippet": {
                    "text": "if (set->flash_bbt)"
                }
            }
        },
        "function_code": "static void s3c2410_nand_init_chip(struct s3c2410_nand_info *info,\n\t\t\t\t   struct s3c2410_nand_mtd *nmtd,\n\t\t\t\t   struct s3c2410_nand_set *set)\n{\n\tstruct device_node *np = info->device->of_node;\n\tstruct nand_chip *chip = &nmtd->chip;\n\tvoid __iomem *regs = info->regs;\n\n\tnand_set_flash_node(chip, set->of_node);\n\n\tchip->legacy.write_buf    = s3c2410_nand_write_buf;\n\tchip->legacy.read_buf     = s3c2410_nand_read_buf;\n\tchip->legacy.select_chip  = s3c2410_nand_select_chip;\n\tchip->legacy.chip_delay   = 50;\n\tnand_set_controller_data(chip, nmtd);\n\tchip->options\t   = set->options;\n\tchip->controller   = &info->controller;\n\n\t/*\n\t * let's keep behavior unchanged for legacy boards booting via pdata and\n\t * auto-detect timings only when booting with a device tree.\n\t */\n\tif (!np)\n\t\tchip->options |= NAND_KEEP_TIMINGS;\n\n\tswitch (info->cpu_type) {\n\tcase TYPE_S3C2410:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2410_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2410_NFCONF;\n\t\tinfo->sel_bit\t= S3C2410_NFCONF_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2410_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2410_nand_devready;\n\t\tbreak;\n\n\tcase TYPE_S3C2440:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2440_NFCONT_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2440_nand_devready;\n\t\tchip->legacy.read_buf  = s3c2440_nand_read_buf;\n\t\tchip->legacy.write_buf\t= s3c2440_nand_write_buf;\n\t\tbreak;\n\n\tcase TYPE_S3C2412:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2412_NFCONT_nFCE0;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2412_nand_devready;\n\n\t\tif (readl(regs + S3C2410_NFCONF) & S3C2412_NFCONF_NANDBOOT)\n\t\t\tdev_info(info->device, \"System booted from NAND\\n\");\n\n\t\tbreak;\n\t}\n\n\tchip->legacy.IO_ADDR_R = chip->legacy.IO_ADDR_W;\n\n\tnmtd->info\t   = info;\n\tnmtd->set\t   = set;\n\n\tchip->ecc.engine_type = info->platform->engine_type;\n\n\t/*\n\t * If you use u-boot BBT creation code, specifying this flag will\n\t * let the kernel fish out the BBT from the NAND.\n\t */\n\tif (set->flash_bbt)\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n}"
    },
    {
        "var_name": "buf",
        "function_name": "try_recover_peb",
        "location": {
            "file_path": "drivers/mtd/ubi/eba.c",
            "region": {
                "startLine": 845,
                "startColumn": 32,
                "endColumn": 35
            },
            "context": {
                "startLine": 843,
                "endLine": 847,
                "snippet": {
                    "text": "memcpy(ubi->peb_buf + offset, buf, len);"
                }
            }
        },
        "function_code": "static int try_recover_peb(struct ubi_volume *vol, int pnum, int lnum,\n\t\t\t   const void *buf, int offset, int len,\n\t\t\t   struct ubi_vid_io_buf *vidb, bool *retry)\n{\n\tstruct ubi_device *ubi = vol->ubi;\n\tstruct ubi_vid_hdr *vid_hdr;\n\tint new_pnum, err, vol_id = vol->vol_id, data_size;\n\tuint32_t crc;\n\n\t*retry = false;\n\n\tnew_pnum = ubi_wl_get_peb(ubi);\n\tif (new_pnum < 0) {\n\t\terr = new_pnum;\n\t\tgoto out_put;\n\t}\n\n\tubi_msg(ubi, \"recover PEB %d, move data to PEB %d\",\n\t\tpnum, new_pnum);\n\n\terr = ubi_io_read_vid_hdr(ubi, pnum, vidb, 1);\n\tif (err && err != UBI_IO_BITFLIPS) {\n\t\tif (err > 0)\n\t\t\terr = -EIO;\n\t\tgoto out_put;\n\t}\n\n\tvid_hdr = ubi_get_vid_hdr(vidb);\n\tubi_assert(vid_hdr->vol_type == UBI_VID_DYNAMIC);\n\n\tmutex_lock(&ubi->buf_mutex);\n\tmemset(ubi->peb_buf + offset, 0xFF, len);\n\n\t/* Read everything before the area where the write failure happened */\n\tif (offset > 0) {\n\t\terr = ubi_io_read_data(ubi, ubi->peb_buf, pnum, 0, offset);\n\t\tif (err && err != UBI_IO_BITFLIPS)\n\t\t\tgoto out_unlock;\n\t}\n\n\t*retry = true;\n\n\tmemcpy(ubi->peb_buf + offset, buf, len);\n\n\tdata_size = offset + len;\n\tcrc = crc32(UBI_CRC32_INIT, ubi->peb_buf, data_size);\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tvid_hdr->copy_flag = 1;\n\tvid_hdr->data_size = cpu_to_be32(data_size);\n\tvid_hdr->data_crc = cpu_to_be32(crc);\n\terr = ubi_io_write_vid_hdr(ubi, new_pnum, vidb);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ubi_io_write_data(ubi, ubi->peb_buf, new_pnum, 0, data_size);\n\nout_unlock:\n\tmutex_unlock(&ubi->buf_mutex);\n\n\tif (!err)\n\t\tvol->eba_tbl->entries[lnum].pnum = new_pnum;\n\nout_put:\n\tup_read(&ubi->fm_eba_sem);\n\n\tif (!err) {\n\t\tubi_wl_put_peb(ubi, vol_id, lnum, pnum, 1);\n\t\tubi_msg(ubi, \"data was successfully recovered\");\n\t} else if (new_pnum >= 0) {\n\t\t/*\n\t\t * Bad luck? This physical eraseblock is bad too? Crud. Let's\n\t\t * try to get another one.\n\t\t */\n\t\tubi_wl_put_peb(ubi, vol_id, lnum, new_pnum, 1);\n\t\tubi_warn(ubi, \"failed to write to PEB %d\", new_pnum);\n\t}\n\n\treturn err;\n}"
    },
    {
        "var_name": "lp",
        "function_name": "arcnet_interrupt",
        "location": {
            "file_path": "drivers/net/arcnet/arcnet.c",
            "region": {
                "startLine": 870,
                "startColumn": 6,
                "endColumn": 8
            },
            "context": {
                "startLine": 868,
                "endLine": 872,
                "snippet": {
                    "text": "if (lp->reset_in_progress)"
                }
            }
        },
        "function_code": "irqreturn_t arcnet_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct arcnet_local *lp;\n\tint recbuf, status, diagstatus, didsomething, boguscount;\n\tunsigned long flags;\n\tint retval = IRQ_NONE;\n\n\tarc_printk(D_DURING, dev, \"\\n\");\n\n\tarc_printk(D_DURING, dev, \"in arcnet_interrupt\\n\");\n\n\tlp = netdev_priv(dev);\n\tBUG_ON(!lp);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\n\tif (lp->reset_in_progress)\n\t\tgoto out;\n\n\t/* RESET flag was enabled - if device is not running, we must\n\t * clear it right away (but nothing else).\n\t */\n\tif (!netif_running(dev)) {\n\t\tif (lp->hw.status(dev) & RESETflag)\n\t\t\tlp->hw.command(dev, CFLAGScmd | RESETclear);\n\t\tlp->hw.intmask(dev, 0);\n\t\tspin_unlock_irqrestore(&lp->lock, flags);\n\t\treturn retval;\n\t}\n\n\tarc_printk(D_DURING, dev, \"in arcnet_inthandler (status=%Xh, intmask=%Xh)\\n\",\n\t\t   lp->hw.status(dev), lp->intmask);\n\n\tboguscount = 5;\n\tdo {\n\t\tstatus = lp->hw.status(dev);\n\t\tdiagstatus = (status >> 8) & 0xFF;\n\n\t\tarc_printk(D_DEBUG, dev, \"%s: %d: %s: status=%x\\n\",\n\t\t\t   __FILE__, __LINE__, __func__, status);\n\t\tdidsomething = 0;\n\n\t\t/* RESET flag was enabled - card is resetting and if RX is\n\t\t * disabled, it's NOT because we just got a packet.\n\t\t *\n\t\t * The card is in an undefined state.\n\t\t * Clear it out and start over.\n\t\t */\n\t\tif (status & RESETflag) {\n\t\t\tarc_printk(D_NORMAL, dev, \"spurious reset (status=%Xh)\\n\",\n\t\t\t\t   status);\n\n\t\t\tlp->reset_in_progress = 1;\n\t\t\tnetif_stop_queue(dev);\n\t\t\tnetif_carrier_off(dev);\n\t\t\tschedule_work(&lp->reset_work);\n\n\t\t\t/* get out of the interrupt handler! */\n\t\t\tgoto out;\n\t\t}\n\t\t/* RX is inhibited - we must have received something.\n\t\t * Prepare to receive into the next buffer.\n\t\t *\n\t\t * We don't actually copy the received packet from the card\n\t\t * until after the transmit handler runs (and possibly\n\t\t * launches the next tx); this should improve latency slightly\n\t\t * if we get both types of interrupts at once.\n\t\t */\n\t\trecbuf = -1;\n\t\tif (status & lp->intmask & NORXflag) {\n\t\t\trecbuf = lp->cur_rx;\n\t\t\tarc_printk(D_DURING, dev, \"Buffer #%d: receive irq (status=%Xh)\\n\",\n\t\t\t\t   recbuf, status);\n\n\t\t\tlp->cur_rx = get_arcbuf(dev);\n\t\t\tif (lp->cur_rx != -1) {\n\t\t\t\tarc_printk(D_DURING, dev, \"enabling receive to buffer #%d\\n\",\n\t\t\t\t\t   lp->cur_rx);\n\t\t\t\tlp->hw.command(dev, RXcmd | (lp->cur_rx << 3) | RXbcasts);\n\t\t\t}\n\t\t\tdidsomething++;\n\t\t}\n\n\t\tif ((diagstatus & EXCNAKflag)) {\n\t\t\tarc_printk(D_DURING, dev, \"EXCNAK IRQ (diagstat=%Xh)\\n\",\n\t\t\t\t   diagstatus);\n\n\t\t\tlp->hw.command(dev, NOTXcmd);      /* disable transmit */\n\t\t\tlp->excnak_pending = 1;\n\n\t\t\tlp->hw.command(dev, EXCNAKclear);\n\t\t\tlp->intmask &= ~(EXCNAKflag);\n\t\t\tdidsomething++;\n\t\t}\n\n\t\t/* a transmit finished, and we're interested in it. */\n\t\tif ((status & lp->intmask & TXFREEflag) || lp->timed_out) {\n\t\t\tint ackstatus;\n\t\t\tlp->intmask &= ~(TXFREEflag | EXCNAKflag);\n\n\t\t\tif (status & TXACKflag)\n\t\t\t\tackstatus = 2;\n\t\t\telse if (lp->excnak_pending)\n\t\t\t\tackstatus = 1;\n\t\t\telse\n\t\t\t\tackstatus = 0;\n\n\t\t\tarc_printk(D_DURING, dev, \"TX IRQ (stat=%Xh)\\n\",\n\t\t\t\t   status);\n\n\t\t\tif (lp->cur_tx != -1 && !lp->timed_out) {\n\t\t\t\tif (!(status & TXACKflag)) {\n\t\t\t\t\tif (lp->lasttrans_dest != 0) {\n\t\t\t\t\t\tarc_printk(D_EXTRA, dev,\n\t\t\t\t\t\t\t   \"transmit was not acknowledged! (status=%Xh, dest=%02Xh)\\n\",\n\t\t\t\t\t\t\t   status,\n\t\t\t\t\t\t\t   lp->lasttrans_dest);\n\t\t\t\t\t\tdev->stats.tx_errors++;\n\t\t\t\t\t\tdev->stats.tx_carrier_errors++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarc_printk(D_DURING, dev,\n\t\t\t\t\t\t\t   \"broadcast was not acknowledged; that's normal (status=%Xh, dest=%02Xh)\\n\",\n\t\t\t\t\t\t\t   status,\n\t\t\t\t\t\t\t   lp->lasttrans_dest);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lp->outgoing.proto &&\n\t\t\t\t    lp->outgoing.proto->ack_tx) {\n\t\t\t\t\tlp->outgoing.proto\n\t\t\t\t\t\t->ack_tx(dev, ackstatus);\n\t\t\t\t}\n\t\t\t\tlp->reply_status = ackstatus;\n\t\t\t\ttasklet_hi_schedule(&lp->reply_tasklet);\n\t\t\t}\n\t\t\tif (lp->cur_tx != -1)\n\t\t\t\trelease_arcbuf(dev, lp->cur_tx);\n\n\t\t\tlp->cur_tx = -1;\n\t\t\tlp->timed_out = 0;\n\t\t\tdidsomething++;\n\n\t\t\t/* send another packet if there is one */\n\t\t\tgo_tx(dev);\n\n\t\t\t/* continue a split packet, if any */\n\t\t\tif (lp->outgoing.proto &&\n\t\t\t    lp->outgoing.proto->continue_tx) {\n\t\t\t\tint txbuf = get_arcbuf(dev);\n\n\t\t\t\tif (txbuf != -1) {\n\t\t\t\t\tif (lp->outgoing.proto->continue_tx(dev, txbuf)) {\n\t\t\t\t\t\t/* that was the last segment */\n\t\t\t\t\t\tdev->stats.tx_bytes += lp->outgoing.skb->len;\n\t\t\t\t\t\tif (!lp->outgoing.proto->ack_tx) {\n\t\t\t\t\t\t\tdev_kfree_skb_irq(lp->outgoing.skb);\n\t\t\t\t\t\t\tlp->outgoing.proto = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlp->next_tx = txbuf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* inform upper layers of idleness, if necessary */\n\t\t\tif (lp->cur_tx == -1)\n\t\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\t/* now process the received packet, if any */\n\t\tif (recbuf != -1) {\n\t\t\tif (BUGLVL(D_RX))\n\t\t\t\tarcnet_dump_packet(dev, recbuf, \"rx irq\", 0);\n\n\t\t\tarcnet_rx(dev, recbuf);\n\t\t\trelease_arcbuf(dev, recbuf);\n\n\t\t\tdidsomething++;\n\t\t}\n\t\tif (status & lp->intmask & RECONflag) {\n\t\t\tlp->hw.command(dev, CFLAGScmd | CONFIGclear);\n\t\t\tdev->stats.tx_carrier_errors++;\n\n\t\t\tarc_printk(D_RECON, dev, \"Network reconfiguration detected (status=%Xh)\\n\",\n\t\t\t\t   status);\n\t\t\tif (netif_carrier_ok(dev)) {\n\t\t\t\tnetif_carrier_off(dev);\n\t\t\t\tnetdev_info(dev, \"link down\\n\");\n\t\t\t}\n\t\t\tmod_timer(&lp->timer, jiffies + msecs_to_jiffies(1000));\n\n\t\t\tarcnet_led_event(dev, ARCNET_LED_EVENT_RECON);\n\t\t\t/* MYRECON bit is at bit 7 of diagstatus */\n\t\t\tif (diagstatus & 0x80)\n\t\t\t\tarc_printk(D_RECON, dev, \"Put out that recon myself\\n\");\n\n\t\t\t/* is the RECON info empty or old? */\n\t\t\tif (!lp->first_recon || !lp->last_recon ||\n\t\t\t    time_after(jiffies, lp->last_recon + HZ * 10)) {\n\t\t\t\tif (lp->network_down)\n\t\t\t\t\tarc_printk(D_NORMAL, dev, \"reconfiguration detected: cabling restored?\\n\");\n\t\t\t\tlp->first_recon = lp->last_recon = jiffies;\n\t\t\t\tlp->num_recons = lp->network_down = 0;\n\n\t\t\t\tarc_printk(D_DURING, dev, \"recon: clearing counters.\\n\");\n\t\t\t} else {\t/* add to current RECON counter */\n\t\t\t\tlp->last_recon = jiffies;\n\t\t\t\tlp->num_recons++;\n\n\t\t\t\tarc_printk(D_DURING, dev, \"recon: counter=%d, time=%lds, net=%d\\n\",\n\t\t\t\t\t   lp->num_recons,\n\t\t\t\t\t   (lp->last_recon - lp->first_recon) / HZ,\n\t\t\t\t\t   lp->network_down);\n\n\t\t\t\t/* if network is marked up;\n\t\t\t\t * and first_recon and last_recon are 60+ apart;\n\t\t\t\t * and the average no. of recons counted is\n\t\t\t\t *    > RECON_THRESHOLD/min;\n\t\t\t\t * then print a warning message.\n\t\t\t\t */\n\t\t\t\tif (!lp->network_down &&\n\t\t\t\t    (lp->last_recon - lp->first_recon) <= HZ * 60 &&\n\t\t\t\t    lp->num_recons >= RECON_THRESHOLD) {\n\t\t\t\t\tlp->network_down = 1;\n\t\t\t\t\tarc_printk(D_NORMAL, dev, \"many reconfigurations detected: cabling problem?\\n\");\n\t\t\t\t} else if (!lp->network_down &&\n\t\t\t\t\t   lp->last_recon - lp->first_recon > HZ * 60) {\n\t\t\t\t\t/* reset counters if we've gone for\n\t\t\t\t\t *  over a minute.\n\t\t\t\t\t */\n\t\t\t\t\tlp->first_recon = lp->last_recon;\n\t\t\t\t\tlp->num_recons = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (lp->network_down &&\n\t\t\t   time_after(jiffies, lp->last_recon + HZ * 10)) {\n\t\t\tif (lp->network_down)\n\t\t\t\tarc_printk(D_NORMAL, dev, \"cabling restored?\\n\");\n\t\t\tlp->first_recon = lp->last_recon = 0;\n\t\t\tlp->num_recons = lp->network_down = 0;\n\n\t\t\tarc_printk(D_DURING, dev, \"not recon: clearing counters anyway.\\n\");\n\t\t\tnetif_carrier_on(dev);\n\t\t}\n\n\t\tif (didsomething)\n\t\t\tretval |= IRQ_HANDLED;\n\t} while (--boguscount && didsomething);\n\n\tarc_printk(D_DURING, dev, \"arcnet_interrupt complete (status=%Xh, count=%d)\\n\",\n\t\t   lp->hw.status(dev), boguscount);\n\tarc_printk(D_DURING, dev, \"\\n\");\n\n\tlp->hw.intmask(dev, 0);\n\tudelay(1);\n\tlp->hw.intmask(dev, lp->intmask);\n\nout:\n\tspin_unlock_irqrestore(&lp->lock, flags);\n\treturn retval;\n}"
    },
    {
        "var_name": "hprio",
        "function_name": "bond_choose_primary_or_current",
        "location": {
            "file_path": "drivers/net/bonding/bond_main.c",
            "region": {
                "startLine": 1054,
                "startColumn": 23,
                "endColumn": 28
            },
            "context": {
                "startLine": 1052,
                "endLine": 1056,
                "snippet": {
                    "text": "if (slave->prio > hprio->prio)"
                }
            }
        },
        "function_code": "static struct slave *bond_choose_primary_or_current(struct bonding *bond)\n{\n\tstruct slave *prim = rtnl_dereference(bond->primary_slave);\n\tstruct slave *curr = rtnl_dereference(bond->curr_active_slave);\n\tstruct slave *slave, *hprio = NULL;\n\tstruct list_head *iter;\n\n\tif (!prim || prim->link != BOND_LINK_UP) {\n\t\tbond_for_each_slave(bond, slave, iter) {\n\t\t\tif (slave->link == BOND_LINK_UP) {\n\t\t\t\thprio = hprio ?: slave;\n\t\t\t\tif (slave->prio > hprio->prio)\n\t\t\t\t\thprio = slave;\n\t\t\t}\n\t\t}\n\n\t\tif (hprio && hprio != curr) {\n\t\t\tprim = hprio;\n\t\t\tgoto link_reselect;\n\t\t}\n\n\t\tif (!curr || curr->link != BOND_LINK_UP)\n\t\t\treturn NULL;\n\t\treturn curr;\n\t}\n\n\tif (bond->force_primary) {\n\t\tbond->force_primary = false;\n\t\treturn prim;\n\t}\n\nlink_reselect:\n\tif (!curr || curr->link != BOND_LINK_UP)\n\t\treturn prim;\n\n\t/* At this point, prim and curr are both up */\n\tswitch (bond->params.primary_reselect) {\n\tcase BOND_PRI_RESELECT_ALWAYS:\n\t\treturn prim;\n\tcase BOND_PRI_RESELECT_BETTER:\n\t\tif (prim->speed < curr->speed)\n\t\t\treturn curr;\n\t\tif (prim->speed == curr->speed && prim->duplex <= curr->duplex)\n\t\t\treturn curr;\n\t\treturn prim;\n\tcase BOND_PRI_RESELECT_FAILURE:\n\t\treturn curr;\n\tdefault:\n\t\tnetdev_err(bond->dev, \"impossible primary_reselect %d\\n\",\n\t\t\t   bond->params.primary_reselect);\n\t\treturn curr;\n\t}\n}"
    },
    {
        "var_name": "slaves",
        "function_name": "bond_xdp_xmit_3ad_xor_slave_get",
        "location": {
            "file_path": "drivers/net/bonding/bond_main.c",
            "region": {
                "startLine": 5170,
                "startColumn": 9,
                "endColumn": 15
            },
            "context": {
                "startLine": 5168,
                "endLine": 5172,
                "snippet": {
                    "text": "return slaves->arr[hash % count];"
                }
            }
        },
        "function_code": "static struct slave *bond_xdp_xmit_3ad_xor_slave_get(struct bonding *bond,\n\t\t\t\t\t\t     struct xdp_buff *xdp)\n{\n\tstruct bond_up_slave *slaves;\n\tunsigned int count;\n\tu32 hash;\n\n\thash = bond_xmit_hash_xdp(bond, xdp);\n\tslaves = rcu_dereference(bond->usable_slaves);\n\tcount = slaves ? READ_ONCE(slaves->count) : 0;\n\tif (unlikely(!count))\n\t\treturn NULL;\n\n\treturn slaves->arr[hash % count];\n}"
    },
    {
        "var_name": "slaves",
        "function_name": "__bond_sk_get_lower_dev",
        "location": {
            "file_path": "drivers/net/bonding/bond_main.c",
            "region": {
                "startLine": 5386,
                "startColumn": 10,
                "endColumn": 16
            },
            "context": {
                "startLine": 5384,
                "endLine": 5388,
                "snippet": {
                    "text": "slave = slaves->arr[hash % count];"
                }
            }
        },
        "function_code": "static struct net_device *__bond_sk_get_lower_dev(struct bonding *bond,\n\t\t\t\t\t\t  struct sock *sk)\n{\n\tstruct bond_up_slave *slaves;\n\tstruct slave *slave;\n\tunsigned int count;\n\tu32 hash;\n\n\tslaves = rcu_dereference(bond->usable_slaves);\n\tcount = slaves ? READ_ONCE(slaves->count) : 0;\n\tif (unlikely(!count))\n\t\treturn NULL;\n\n\thash = bond_sk_hash_l34(sk);\n\tslave = slaves->arr[hash % count];\n\n\treturn slave->dev;\n}"
    },
    {
        "var_name": "ser",
        "function_name": "handle_tx",
        "location": {
            "file_path": "drivers/net/caif/caif_serial.c",
            "region": {
                "startLine": 214,
                "startColumn": 8,
                "endColumn": 11
            },
            "context": {
                "startLine": 212,
                "endLine": 216,
                "snippet": {
                    "text": "tty = ser->tty;"
                }
            }
        },
        "function_code": "static int handle_tx(struct ser_device *ser)\n{\n\tstruct tty_struct *tty;\n\tstruct sk_buff *skb;\n\tint tty_wr, len, room;\n\n\ttty = ser->tty;\n\tser->tx_started = true;\n\n\t/* Enter critical section */\n\tif (test_and_set_bit(CAIF_SENDING, &ser->state))\n\t\treturn 0;\n\n\t/* skb_peek is safe because handle_tx is called after skb_queue_tail */\n\twhile ((skb = skb_peek(&ser->head)) != NULL) {\n\n\t\t/* Make sure you don't write too much */\n\t\tlen = skb->len;\n\t\troom = tty_write_room(tty);\n\t\tif (!room)\n\t\t\tbreak;\n\t\tif (room > ser_write_chunk)\n\t\t\troom = ser_write_chunk;\n\t\tif (len > room)\n\t\t\tlen = room;\n\n\t\t/* Write to tty or loopback */\n\t\tif (!ser_loop) {\n\t\t\ttty_wr = tty->ops->write(tty, skb->data, len);\n\t\t\tupdate_tty_status(ser);\n\t\t} else {\n\t\t\ttty_wr = len;\n\t\t\tldisc_receive(tty, skb->data, NULL, len);\n\t\t}\n\t\tser->dev->stats.tx_packets++;\n\t\tser->dev->stats.tx_bytes += tty_wr;\n\n\t\t/* Error on TTY ?! */\n\t\tif (tty_wr < 0)\n\t\t\tgoto error;\n\t\t/* Reduce buffer written, and discard if empty */\n\t\tskb_pull(skb, tty_wr);\n\t\tif (skb->len == 0) {\n\t\t\tstruct sk_buff *tmp = skb_dequeue(&ser->head);\n\t\t\tWARN_ON(tmp != skb);\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t}\n\t/* Send flow off if queue is empty */\n\tif (ser->head.qlen <= SEND_QUEUE_LOW &&\n\t\ttest_and_clear_bit(CAIF_FLOW_OFF_SENT, &ser->state) &&\n\t\tser->common.flowctrl != NULL)\n\t\t\t\tser->common.flowctrl(ser->dev, ON);\n\tclear_bit(CAIF_SENDING, &ser->state);\n\treturn 0;\nerror:\n\tclear_bit(CAIF_SENDING, &ser->state);\n\treturn tty_wr;\n}"
    },
    {
        "var_name": "ser",
        "function_name": "handle_tx",
        "location": {
            "file_path": "drivers/net/caif/caif_serial.c",
            "region": {
                "startLine": 215,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 213,
                "endLine": 217,
                "snippet": {
                    "text": "ser->tx_started = true;"
                }
            }
        },
        "function_code": "static int handle_tx(struct ser_device *ser)\n{\n\tstruct tty_struct *tty;\n\tstruct sk_buff *skb;\n\tint tty_wr, len, room;\n\n\ttty = ser->tty;\n\tser->tx_started = true;\n\n\t/* Enter critical section */\n\tif (test_and_set_bit(CAIF_SENDING, &ser->state))\n\t\treturn 0;\n\n\t/* skb_peek is safe because handle_tx is called after skb_queue_tail */\n\twhile ((skb = skb_peek(&ser->head)) != NULL) {\n\n\t\t/* Make sure you don't write too much */\n\t\tlen = skb->len;\n\t\troom = tty_write_room(tty);\n\t\tif (!room)\n\t\t\tbreak;\n\t\tif (room > ser_write_chunk)\n\t\t\troom = ser_write_chunk;\n\t\tif (len > room)\n\t\t\tlen = room;\n\n\t\t/* Write to tty or loopback */\n\t\tif (!ser_loop) {\n\t\t\ttty_wr = tty->ops->write(tty, skb->data, len);\n\t\t\tupdate_tty_status(ser);\n\t\t} else {\n\t\t\ttty_wr = len;\n\t\t\tldisc_receive(tty, skb->data, NULL, len);\n\t\t}\n\t\tser->dev->stats.tx_packets++;\n\t\tser->dev->stats.tx_bytes += tty_wr;\n\n\t\t/* Error on TTY ?! */\n\t\tif (tty_wr < 0)\n\t\t\tgoto error;\n\t\t/* Reduce buffer written, and discard if empty */\n\t\tskb_pull(skb, tty_wr);\n\t\tif (skb->len == 0) {\n\t\t\tstruct sk_buff *tmp = skb_dequeue(&ser->head);\n\t\t\tWARN_ON(tmp != skb);\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t}\n\t/* Send flow off if queue is empty */\n\tif (ser->head.qlen <= SEND_QUEUE_LOW &&\n\t\ttest_and_clear_bit(CAIF_FLOW_OFF_SENT, &ser->state) &&\n\t\tser->common.flowctrl != NULL)\n\t\t\t\tser->common.flowctrl(ser->dev, ON);\n\tclear_bit(CAIF_SENDING, &ser->state);\n\treturn 0;\nerror:\n\tclear_bit(CAIF_SENDING, &ser->state);\n\treturn tty_wr;\n}"
    },
    {
        "var_name": "ser",
        "function_name": "ldisc_tx_wakeup",
        "location": {
            "file_path": "drivers/net/caif/caif_serial.c",
            "region": {
                "startLine": 292,
                "startColumn": 10,
                "endColumn": 13
            },
            "context": {
                "startLine": 290,
                "endLine": 294,
                "snippet": {
                    "text": "WARN_ON(ser->tty != tty);"
                }
            }
        },
        "function_code": "static void ldisc_tx_wakeup(struct tty_struct *tty)\n{\n\tstruct ser_device *ser;\n\n\tser = tty->disc_data;\n\tBUG_ON(ser == NULL);\n\tWARN_ON(ser->tty != tty);\n\thandle_tx(ser);\n}"
    },
    {
        "var_name": "pdat",
        "function_name": "softingcs_probe_config",
        "location": {
            "file_path": "drivers/net/can/softing/softing_cs.c",
            "region": {
                "startLine": 196,
                "startColumn": 6,
                "endColumn": 10
            },
            "context": {
                "startLine": 194,
                "endLine": 198,
                "snippet": {
                    "text": "if (pdat->generation < 2) {"
                }
            }
        },
        "function_code": "static int softingcs_probe_config(struct pcmcia_device *pcmcia, void *priv_data)\n{\n\tstruct softing_platform_data *pdat = priv_data;\n\tstruct resource *pres;\n\tint memspeed = 0;\n\n\tWARN_ON(!pdat);\n\tpres = pcmcia->resource[PCMCIA_IOMEM_0];\n\tif (resource_size(pres) < 0x1000)\n\t\treturn -ERANGE;\n\n\tpres->flags |= WIN_MEMORY_TYPE_CM | WIN_ENABLE;\n\tif (pdat->generation < 2) {\n\t\tpres->flags |= WIN_USE_WAIT | WIN_DATA_WIDTH_8;\n\t\tmemspeed = 3;\n\t} else {\n\t\tpres->flags |= WIN_DATA_WIDTH_16;\n\t}\n\treturn pcmcia_request_window(pcmcia, pres, memspeed);\n}"
    },
    {
        "var_name": "context",
        "function_name": "ems_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/ems_usb.c",
            "region": {
                "startLine": 501,
                "startColumn": 8,
                "endColumn": 15
            },
            "context": {
                "startLine": 499,
                "endLine": 503,
                "snippet": {
                    "text": "dev = context->dev;"
                }
            }
        },
        "function_code": "static void ems_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct ems_tx_urb_context *context = urb->context;\n\tstruct ems_usb *dev;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\tnetif_trans_update(netdev);\n\n\t/* transmission complete interrupt */\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index,\n\t\t\t\t\t\t   NULL);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n}"
    },
    {
        "var_name": "context",
        "function_name": "ems_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/ems_usb.c",
            "region": {
                "startLine": 520,
                "startColumn": 53,
                "endColumn": 60
            },
            "context": {
                "startLine": 518,
                "endLine": 522,
                "snippet": {
                    "text": "netdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index,"
                }
            }
        },
        "function_code": "static void ems_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct ems_tx_urb_context *context = urb->context;\n\tstruct ems_usb *dev;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\tnetif_trans_update(netdev);\n\n\t/* transmission complete interrupt */\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index,\n\t\t\t\t\t\t   NULL);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n}"
    },
    {
        "var_name": "context",
        "function_name": "ems_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/ems_usb.c",
            "region": {
                "startLine": 524,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 522,
                "endLine": 526,
                "snippet": {
                    "text": "context->echo_index = MAX_TX_URBS;"
                }
            }
        },
        "function_code": "static void ems_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct ems_tx_urb_context *context = urb->context;\n\tstruct ems_usb *dev;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\tnetif_trans_update(netdev);\n\n\t/* transmission complete interrupt */\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index,\n\t\t\t\t\t\t   NULL);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n}"
    },
    {
        "var_name": "context",
        "function_name": "esd_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/esd_usb.c",
            "region": {
                "startLine": 564,
                "startColumn": 9,
                "endColumn": 16
            },
            "context": {
                "startLine": 562,
                "endLine": 566,
                "snippet": {
                    "text": "priv = context->priv;"
                }
            }
        },
        "function_code": "static void esd_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct esd_tx_urb_context *context = urb->context;\n\tstruct esd_usb_net_priv *priv;\n\tstruct net_device *netdev;\n\tsize_t size = sizeof(union esd_usb_msg);\n\n\tWARN_ON(!context);\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, size,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\tnetif_trans_update(netdev);\n}"
    },
    {
        "var_name": "parent",
        "function_name": "gs_usb_receive_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/gs_usb.c",
            "region": {
                "startLine": 599,
                "startColumn": 8,
                "endColumn": 14
            },
            "context": {
                "startLine": 597,
                "endLine": 601,
                "snippet": {
                    "text": "dev = parent->canch[hf->channel];"
                }
            }
        },
        "function_code": "static void gs_usb_receive_bulk_callback(struct urb *urb)\n{\n\tstruct gs_usb *parent = urb->context;\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct net_device_stats *stats;\n\tstruct gs_host_frame *hf = urb->transfer_buffer;\n\tstruct gs_tx_context *txc;\n\tstruct can_frame *cf;\n\tstruct canfd_frame *cfd;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(!parent);\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* do not resubmit aborted urbs. eg: when device goes down */\n\t\treturn;\n\t}\n\n\t/* device reports out of range channel id */\n\tif (hf->channel >= GS_MAX_INTF)\n\t\tgoto device_detach;\n\n\tdev = parent->canch[hf->channel];\n\n\tnetdev = dev->netdev;\n\tstats = &netdev->stats;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (!netif_running(netdev))\n\t\tgoto resubmit_urb;\n\n\tif (hf->echo_id == -1) { /* normal rx */\n\t\tif (hf->flags & GS_CAN_FLAG_FD) {\n\t\t\tskb = alloc_canfd_skb(netdev, &cfd);\n\t\t\tif (!skb)\n\t\t\t\treturn;\n\n\t\t\tcfd->can_id = le32_to_cpu(hf->can_id);\n\t\t\tcfd->len = can_fd_dlc2len(hf->can_dlc);\n\t\t\tif (hf->flags & GS_CAN_FLAG_BRS)\n\t\t\t\tcfd->flags |= CANFD_BRS;\n\t\t\tif (hf->flags & GS_CAN_FLAG_ESI)\n\t\t\t\tcfd->flags |= CANFD_ESI;\n\n\t\t\tmemcpy(cfd->data, hf->canfd->data, cfd->len);\n\t\t} else {\n\t\t\tskb = alloc_can_skb(netdev, &cf);\n\t\t\tif (!skb)\n\t\t\t\treturn;\n\n\t\t\tcf->can_id = le32_to_cpu(hf->can_id);\n\t\t\tcan_frame_set_cc_len(cf, hf->can_dlc, dev->can.ctrlmode);\n\n\t\t\tmemcpy(cf->data, hf->classic_can->data, 8);\n\n\t\t\t/* ERROR frames tell us information about the controller */\n\t\t\tif (le32_to_cpu(hf->can_id) & CAN_ERR_FLAG)\n\t\t\t\tgs_update_state(dev, cf);\n\t\t}\n\n\t\tgs_usb_rx_offload(dev, skb, hf);\n\t} else { /* echo_id == hf->echo_id */\n\t\tif (hf->echo_id >= GS_MAX_TX_URBS) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected out of range echo id %u\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\ttxc = gs_get_tx_context(dev, hf->echo_id);\n\n\t\t/* bad devices send bad echo_ids. */\n\t\tif (!txc) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected unused echo id %u\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tskb = dev->can.echo_skb[hf->echo_id];\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += gs_usb_get_echo_skb(dev, skb, hf);\n\t\tgs_free_tx_context(txc);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\tif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\n\t\tskb = alloc_can_err_skb(netdev, &cf);\n\t\tif (!skb)\n\t\t\tgoto resubmit_urb;\n\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->len = CAN_ERR_DLC;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\t\tgs_usb_rx_offload(dev, skb, hf);\n\t}\n\n\tcan_rx_offload_irq_finish(&dev->offload);\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, parent->udev,\n\t\t\t  usb_rcvbulkpipe(parent->udev, GS_USB_ENDPOINT_IN),\n\t\t\t  hf, dev->parent->hf_size_rx,\n\t\t\t  gs_usb_receive_bulk_callback, parent);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t/* USB failure take down all interfaces */\n\tif (rc == -ENODEV) {\ndevice_detach:\n\t\tfor (rc = 0; rc < GS_MAX_INTF; rc++) {\n\t\t\tif (parent->canch[rc])\n\t\t\t\tnetif_device_detach(parent->canch[rc]->netdev);\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "parent",
        "function_name": "gs_usb_receive_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/gs_usb.c",
            "region": {
                "startLine": 686,
                "startColumn": 25,
                "endColumn": 31
            },
            "context": {
                "startLine": 684,
                "endLine": 688,
                "snippet": {
                    "text": "usb_fill_bulk_urb(urb, parent->udev,"
                }
            }
        },
        "function_code": "static void gs_usb_receive_bulk_callback(struct urb *urb)\n{\n\tstruct gs_usb *parent = urb->context;\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct net_device_stats *stats;\n\tstruct gs_host_frame *hf = urb->transfer_buffer;\n\tstruct gs_tx_context *txc;\n\tstruct can_frame *cf;\n\tstruct canfd_frame *cfd;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(!parent);\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* do not resubmit aborted urbs. eg: when device goes down */\n\t\treturn;\n\t}\n\n\t/* device reports out of range channel id */\n\tif (hf->channel >= GS_MAX_INTF)\n\t\tgoto device_detach;\n\n\tdev = parent->canch[hf->channel];\n\n\tnetdev = dev->netdev;\n\tstats = &netdev->stats;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (!netif_running(netdev))\n\t\tgoto resubmit_urb;\n\n\tif (hf->echo_id == -1) { /* normal rx */\n\t\tif (hf->flags & GS_CAN_FLAG_FD) {\n\t\t\tskb = alloc_canfd_skb(netdev, &cfd);\n\t\t\tif (!skb)\n\t\t\t\treturn;\n\n\t\t\tcfd->can_id = le32_to_cpu(hf->can_id);\n\t\t\tcfd->len = can_fd_dlc2len(hf->can_dlc);\n\t\t\tif (hf->flags & GS_CAN_FLAG_BRS)\n\t\t\t\tcfd->flags |= CANFD_BRS;\n\t\t\tif (hf->flags & GS_CAN_FLAG_ESI)\n\t\t\t\tcfd->flags |= CANFD_ESI;\n\n\t\t\tmemcpy(cfd->data, hf->canfd->data, cfd->len);\n\t\t} else {\n\t\t\tskb = alloc_can_skb(netdev, &cf);\n\t\t\tif (!skb)\n\t\t\t\treturn;\n\n\t\t\tcf->can_id = le32_to_cpu(hf->can_id);\n\t\t\tcan_frame_set_cc_len(cf, hf->can_dlc, dev->can.ctrlmode);\n\n\t\t\tmemcpy(cf->data, hf->classic_can->data, 8);\n\n\t\t\t/* ERROR frames tell us information about the controller */\n\t\t\tif (le32_to_cpu(hf->can_id) & CAN_ERR_FLAG)\n\t\t\t\tgs_update_state(dev, cf);\n\t\t}\n\n\t\tgs_usb_rx_offload(dev, skb, hf);\n\t} else { /* echo_id == hf->echo_id */\n\t\tif (hf->echo_id >= GS_MAX_TX_URBS) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected out of range echo id %u\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\ttxc = gs_get_tx_context(dev, hf->echo_id);\n\n\t\t/* bad devices send bad echo_ids. */\n\t\tif (!txc) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected unused echo id %u\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tskb = dev->can.echo_skb[hf->echo_id];\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += gs_usb_get_echo_skb(dev, skb, hf);\n\t\tgs_free_tx_context(txc);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\tif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\n\t\tskb = alloc_can_err_skb(netdev, &cf);\n\t\tif (!skb)\n\t\t\tgoto resubmit_urb;\n\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->len = CAN_ERR_DLC;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\t\tgs_usb_rx_offload(dev, skb, hf);\n\t}\n\n\tcan_rx_offload_irq_finish(&dev->offload);\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, parent->udev,\n\t\t\t  usb_rcvbulkpipe(parent->udev, GS_USB_ENDPOINT_IN),\n\t\t\t  hf, dev->parent->hf_size_rx,\n\t\t\t  gs_usb_receive_bulk_callback, parent);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t/* USB failure take down all interfaces */\n\tif (rc == -ENODEV) {\ndevice_detach:\n\t\tfor (rc = 0; rc < GS_MAX_INTF; rc++) {\n\t\t\tif (parent->canch[rc])\n\t\t\t\tnetif_device_detach(parent->canch[rc]->netdev);\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "parent",
        "function_name": "gs_usb_receive_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/gs_usb.c",
            "region": {
                "startLine": 687,
                "startColumn": 22,
                "endColumn": 28
            },
            "context": {
                "startLine": 685,
                "endLine": 689,
                "snippet": {
                    "text": "usb_rcvbulkpipe(parent->udev, GS_USB_ENDPOINT_IN),"
                }
            }
        },
        "function_code": "static void gs_usb_receive_bulk_callback(struct urb *urb)\n{\n\tstruct gs_usb *parent = urb->context;\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct net_device_stats *stats;\n\tstruct gs_host_frame *hf = urb->transfer_buffer;\n\tstruct gs_tx_context *txc;\n\tstruct can_frame *cf;\n\tstruct canfd_frame *cfd;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(!parent);\n\n\tswitch (urb->status) {\n\tcase 0: /* success */\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t/* do not resubmit aborted urbs. eg: when device goes down */\n\t\treturn;\n\t}\n\n\t/* device reports out of range channel id */\n\tif (hf->channel >= GS_MAX_INTF)\n\t\tgoto device_detach;\n\n\tdev = parent->canch[hf->channel];\n\n\tnetdev = dev->netdev;\n\tstats = &netdev->stats;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (!netif_running(netdev))\n\t\tgoto resubmit_urb;\n\n\tif (hf->echo_id == -1) { /* normal rx */\n\t\tif (hf->flags & GS_CAN_FLAG_FD) {\n\t\t\tskb = alloc_canfd_skb(netdev, &cfd);\n\t\t\tif (!skb)\n\t\t\t\treturn;\n\n\t\t\tcfd->can_id = le32_to_cpu(hf->can_id);\n\t\t\tcfd->len = can_fd_dlc2len(hf->can_dlc);\n\t\t\tif (hf->flags & GS_CAN_FLAG_BRS)\n\t\t\t\tcfd->flags |= CANFD_BRS;\n\t\t\tif (hf->flags & GS_CAN_FLAG_ESI)\n\t\t\t\tcfd->flags |= CANFD_ESI;\n\n\t\t\tmemcpy(cfd->data, hf->canfd->data, cfd->len);\n\t\t} else {\n\t\t\tskb = alloc_can_skb(netdev, &cf);\n\t\t\tif (!skb)\n\t\t\t\treturn;\n\n\t\t\tcf->can_id = le32_to_cpu(hf->can_id);\n\t\t\tcan_frame_set_cc_len(cf, hf->can_dlc, dev->can.ctrlmode);\n\n\t\t\tmemcpy(cf->data, hf->classic_can->data, 8);\n\n\t\t\t/* ERROR frames tell us information about the controller */\n\t\t\tif (le32_to_cpu(hf->can_id) & CAN_ERR_FLAG)\n\t\t\t\tgs_update_state(dev, cf);\n\t\t}\n\n\t\tgs_usb_rx_offload(dev, skb, hf);\n\t} else { /* echo_id == hf->echo_id */\n\t\tif (hf->echo_id >= GS_MAX_TX_URBS) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected out of range echo id %u\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\ttxc = gs_get_tx_context(dev, hf->echo_id);\n\n\t\t/* bad devices send bad echo_ids. */\n\t\tif (!txc) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected unused echo id %u\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tskb = dev->can.echo_skb[hf->echo_id];\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += gs_usb_get_echo_skb(dev, skb, hf);\n\t\tgs_free_tx_context(txc);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\tif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\n\t\tskb = alloc_can_err_skb(netdev, &cf);\n\t\tif (!skb)\n\t\t\tgoto resubmit_urb;\n\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->len = CAN_ERR_DLC;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\t\tgs_usb_rx_offload(dev, skb, hf);\n\t}\n\n\tcan_rx_offload_irq_finish(&dev->offload);\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, parent->udev,\n\t\t\t  usb_rcvbulkpipe(parent->udev, GS_USB_ENDPOINT_IN),\n\t\t\t  hf, dev->parent->hf_size_rx,\n\t\t\t  gs_usb_receive_bulk_callback, parent);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t/* USB failure take down all interfaces */\n\tif (rc == -ENODEV) {\ndevice_detach:\n\t\tfor (rc = 0; rc < GS_MAX_INTF; rc++) {\n\t\t\tif (parent->canch[rc])\n\t\t\t\tnetif_device_detach(parent->canch[rc]->netdev);\n\t\t}\n\t}\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "mcba_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/mcba_usb.c",
            "region": {
                "startLine": 226,
                "startColumn": 11,
                "endColumn": 14
            },
            "context": {
                "startLine": 224,
                "endLine": 228,
                "snippet": {
                    "text": "netdev = ctx->priv->netdev;"
                }
            }
        },
        "function_code": "static void mcba_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct mcba_usb_ctx *ctx = urb->context;\n\tstruct net_device *netdev;\n\n\tWARN_ON(!ctx);\n\n\tnetdev = ctx->priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tif (ctx->can) {\n\t\tif (!netif_device_present(netdev))\n\t\t\treturn;\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, ctx->ndx,\n\t\t\t\t\t\t\t   NULL);\n\t}\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\t/* Release the context */\n\tmcba_usb_free_ctx(ctx);\n}"
    },
    {
        "var_name": "ctx",
        "function_name": "mcba_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/mcba_usb.c",
            "region": {
                "startLine": 232,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 230,
                "endLine": 234,
                "snippet": {
                    "text": "if (ctx->can) {"
                }
            }
        },
        "function_code": "static void mcba_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct mcba_usb_ctx *ctx = urb->context;\n\tstruct net_device *netdev;\n\n\tWARN_ON(!ctx);\n\n\tnetdev = ctx->priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tif (ctx->can) {\n\t\tif (!netif_device_present(netdev))\n\t\t\treturn;\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, ctx->ndx,\n\t\t\t\t\t\t\t   NULL);\n\t}\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\t/* Release the context */\n\tmcba_usb_free_ctx(ctx);\n}"
    },
    {
        "var_name": "context",
        "function_name": "peak_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/peak_usb/pcan_usb_core.c",
            "region": {
                "startLine": 307,
                "startColumn": 8,
                "endColumn": 15
            },
            "context": {
                "startLine": 305,
                "endLine": 309,
                "snippet": {
                    "text": "dev = context->dev;"
                }
            }
        },
        "function_code": "static void peak_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct peak_tx_urb_context *context = urb->context;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tint tx_bytes;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\t/* check tx status */\n\tswitch (urb->status) {\n\tcase 0:\n\t\t/* prevent tx timeout */\n\t\tnetif_trans_update(netdev);\n\t\tbreak;\n\n\tcase -EPROTO:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tbreak;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"Tx urb aborted (%d)\\n\",\n\t\t\t\t   urb->status);\n\t\tbreak;\n\t}\n\n\t/* should always release echo skb and corresponding context */\n\ttx_bytes = can_get_echo_skb(netdev, context->echo_index, NULL);\n\tcontext->echo_index = PCAN_USB_MAX_TX_URBS;\n\n\tif (!urb->status) {\n\t\t/* transmission complete */\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += tx_bytes;\n\n\t\t/* do wakeup tx queue in case of success only */\n\t\tnetif_wake_queue(netdev);\n\t}\n}"
    },
    {
        "var_name": "context",
        "function_name": "peak_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/peak_usb/pcan_usb_core.c",
            "region": {
                "startLine": 336,
                "startColumn": 38,
                "endColumn": 45
            },
            "context": {
                "startLine": 334,
                "endLine": 338,
                "snippet": {
                    "text": "tx_bytes = can_get_echo_skb(netdev, context->echo_index, NULL);"
                }
            }
        },
        "function_code": "static void peak_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct peak_tx_urb_context *context = urb->context;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tint tx_bytes;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\t/* check tx status */\n\tswitch (urb->status) {\n\tcase 0:\n\t\t/* prevent tx timeout */\n\t\tnetif_trans_update(netdev);\n\t\tbreak;\n\n\tcase -EPROTO:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tbreak;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"Tx urb aborted (%d)\\n\",\n\t\t\t\t   urb->status);\n\t\tbreak;\n\t}\n\n\t/* should always release echo skb and corresponding context */\n\ttx_bytes = can_get_echo_skb(netdev, context->echo_index, NULL);\n\tcontext->echo_index = PCAN_USB_MAX_TX_URBS;\n\n\tif (!urb->status) {\n\t\t/* transmission complete */\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += tx_bytes;\n\n\t\t/* do wakeup tx queue in case of success only */\n\t\tnetif_wake_queue(netdev);\n\t}\n}"
    },
    {
        "var_name": "context",
        "function_name": "peak_usb_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/peak_usb/pcan_usb_core.c",
            "region": {
                "startLine": 337,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 335,
                "endLine": 339,
                "snippet": {
                    "text": "context->echo_index = PCAN_USB_MAX_TX_URBS;"
                }
            }
        },
        "function_code": "static void peak_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct peak_tx_urb_context *context = urb->context;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tint tx_bytes;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\t/* check tx status */\n\tswitch (urb->status) {\n\tcase 0:\n\t\t/* prevent tx timeout */\n\t\tnetif_trans_update(netdev);\n\t\tbreak;\n\n\tcase -EPROTO:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tbreak;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"Tx urb aborted (%d)\\n\",\n\t\t\t\t   urb->status);\n\t\tbreak;\n\t}\n\n\t/* should always release echo skb and corresponding context */\n\ttx_bytes = can_get_echo_skb(netdev, context->echo_index, NULL);\n\tcontext->echo_index = PCAN_USB_MAX_TX_URBS;\n\n\tif (!urb->status) {\n\t\t/* transmission complete */\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += tx_bytes;\n\n\t\t/* do wakeup tx queue in case of success only */\n\t\tnetif_wake_queue(netdev);\n\t}\n}"
    },
    {
        "var_name": "context",
        "function_name": "usb_8dev_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/usb_8dev.c",
            "region": {
                "startLine": 566,
                "startColumn": 9,
                "endColumn": 16
            },
            "context": {
                "startLine": 564,
                "endLine": 568,
                "snippet": {
                    "text": "priv = context->priv;"
                }
            }
        },
        "function_code": "static void usb_8dev_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_tx_urb_context *context = urb->context;\n\tstruct usb_8dev_priv *priv;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index, NULL);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n\tnetif_wake_queue(netdev);\n}"
    },
    {
        "var_name": "context",
        "function_name": "usb_8dev_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/usb_8dev.c",
            "region": {
                "startLine": 583,
                "startColumn": 53,
                "endColumn": 60
            },
            "context": {
                "startLine": 581,
                "endLine": 585,
                "snippet": {
                    "text": "netdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index, NULL);"
                }
            }
        },
        "function_code": "static void usb_8dev_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_tx_urb_context *context = urb->context;\n\tstruct usb_8dev_priv *priv;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index, NULL);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n\tnetif_wake_queue(netdev);\n}"
    },
    {
        "var_name": "context",
        "function_name": "usb_8dev_write_bulk_callback",
        "location": {
            "file_path": "drivers/net/can/usb/usb_8dev.c",
            "region": {
                "startLine": 586,
                "startColumn": 2,
                "endColumn": 9
            },
            "context": {
                "startLine": 584,
                "endLine": 588,
                "snippet": {
                    "text": "context->echo_index = MAX_TX_URBS;"
                }
            }
        },
        "function_code": "static void usb_8dev_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_tx_urb_context *context = urb->context;\n\tstruct usb_8dev_priv *priv;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\t/* free up our allocated buffer */\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index, NULL);\n\n\t/* Release context */\n\tcontext->echo_index = MAX_TX_URBS;\n\n\tnetif_wake_queue(netdev);\n}"
    },
    {
        "var_name": "dev",
        "function_name": "ne2k_pci_remove_one",
        "location": {
            "file_path": "drivers/net/ethernet/8390/ne2k-pci.c",
            "region": {
                "startLine": 701,
                "startColumn": 17,
                "endColumn": 20
            },
            "context": {
                "startLine": 699,
                "endLine": 703,
                "snippet": {
                    "text": "release_region(dev->base_addr, NE_IO_EXTENT);"
                }
            }
        },
        "function_code": "static void ne2k_pci_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tBUG_ON(!dev);\n\tunregister_netdev(dev);\n\trelease_region(dev->base_addr, NE_IO_EXTENT);\n\tfree_netdev(dev);\n\tpci_disable_device(pdev);\n}"
    },
    {
        "var_name": "skb",
        "function_name": "greth_rx",
        "location": {
            "file_path": "drivers/net/ethernet/aeroflex/greth.c",
            "region": {
                "startLine": 809,
                "startColumn": 5,
                "endColumn": 8
            },
            "context": {
                "startLine": 807,
                "endLine": 811,
                "snippet": {
                    "text": "skb->protocol = eth_type_trans(skb, dev);"
                }
            }
        },
        "function_code": "static int greth_rx(struct net_device *dev, int limit)\n{\n\tstruct greth_private *greth;\n\tstruct greth_bd *bdp;\n\tstruct sk_buff *skb;\n\tint pkt_len;\n\tint bad, count;\n\tu32 status, dma_addr;\n\tunsigned long flags;\n\n\tgreth = netdev_priv(dev);\n\n\tfor (count = 0; count < limit; ++count) {\n\n\t\tbdp = greth->rx_bd_base + greth->rx_cur;\n\t\tGRETH_REGSAVE(greth->regs->status, GRETH_INT_RE | GRETH_INT_RX);\n\t\tmb();\n\t\tstatus = greth_read_bd(&bdp->stat);\n\n\t\tif (unlikely(status & GRETH_BD_EN)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdma_addr = greth_read_bd(&bdp->addr);\n\t\tbad = 0;\n\n\t\t/* Check status for errors. */\n\t\tif (unlikely(status & GRETH_RXBD_STATUS)) {\n\t\t\tif (status & GRETH_RXBD_ERR_FT) {\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t\tif (status & (GRETH_RXBD_ERR_AE | GRETH_RXBD_ERR_OE)) {\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t\tif (status & GRETH_RXBD_ERR_CRC) {\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\t\tif (unlikely(bad)) {\n\t\t\tdev->stats.rx_errors++;\n\n\t\t} else {\n\n\t\t\tpkt_len = status & GRETH_BD_LEN;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + NET_IP_ALIGN);\n\n\t\t\tif (unlikely(skb == NULL)) {\n\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tdev_warn(&dev->dev, \"low on memory - \" \"packet dropped\\n\");\n\n\t\t\t\tdev->stats.rx_dropped++;\n\n\t\t\t} else {\n\t\t\t\tskb_reserve(skb, NET_IP_ALIGN);\n\n\t\t\t\tdma_sync_single_for_cpu(greth->dev,\n\t\t\t\t\t\t\tdma_addr,\n\t\t\t\t\t\t\tpkt_len,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\t\tif (netif_msg_pktdata(greth))\n\t\t\t\t\tgreth_print_rx_packet(phys_to_virt(dma_addr), pkt_len);\n\n\t\t\t\tskb_put_data(skb, phys_to_virt(dma_addr),\n\t\t\t\t\t     pkt_len);\n\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t}\n\t\t}\n\n\t\tstatus = GRETH_BD_EN | GRETH_BD_IE;\n\t\tif (greth->rx_cur == GRETH_RXBD_NUM_MASK) {\n\t\t\tstatus |= GRETH_BD_WR;\n\t\t}\n\n\t\twmb();\n\t\tgreth_write_bd(&bdp->stat, status);\n\n\t\tdma_sync_single_for_device(greth->dev, dma_addr, MAX_FRAME_SIZE, DMA_FROM_DEVICE);\n\n\t\tspin_lock_irqsave(&greth->devlock, flags); /* save from XMIT */\n\t\tgreth_enable_rx(greth);\n\t\tspin_unlock_irqrestore(&greth->devlock, flags);\n\n\t\tgreth->rx_cur = NEXT_RX(greth->rx_cur);\n\t}\n\n\treturn count;\n}"
    },
    {
        "var_name": "phydev",
        "function_name": "au1000_adjust_link",
        "location": {
            "file_path": "drivers/net/ethernet/amd/au1000_eth.c",
            "region": {
                "startLine": 405,
                "startColumn": 6,
                "endColumn": 12
            },
            "context": {
                "startLine": 403,
                "endLine": 407,
                "snippet": {
                    "text": "if (phydev->link && (aup->old_speed != phydev->speed)) {"
                }
            }
        },
        "function_code": "static void\nau1000_adjust_link(struct net_device *dev)\n{\n\tstruct au1000_private *aup = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tunsigned long flags;\n\tu32 reg;\n\n\tint status_change = 0;\n\n\tBUG_ON(!phydev);\n\n\tspin_lock_irqsave(&aup->lock, flags);\n\n\tif (phydev->link && (aup->old_speed != phydev->speed)) {\n\t\t/* speed changed */\n\n\t\tswitch (phydev->speed) {\n\t\tcase SPEED_10:\n\t\tcase SPEED_100:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_warn(dev, \"Speed (%d) is not 10/100 ???\\n\",\n\t\t\t\t\t\t\tphydev->speed);\n\t\t\tbreak;\n\t\t}\n\n\t\taup->old_speed = phydev->speed;\n\n\t\tstatus_change = 1;\n\t}\n\n\tif (phydev->link && (aup->old_duplex != phydev->duplex)) {\n\t\t/* duplex mode changed */\n\n\t\t/* switching duplex mode requires to disable rx and tx! */\n\t\tau1000_hard_stop(dev);\n\n\t\treg = readl(&aup->mac->control);\n\t\tif (DUPLEX_FULL == phydev->duplex) {\n\t\t\treg |= MAC_FULL_DUPLEX;\n\t\t\treg &= ~MAC_DISABLE_RX_OWN;\n\t\t} else {\n\t\t\treg &= ~MAC_FULL_DUPLEX;\n\t\t\treg |= MAC_DISABLE_RX_OWN;\n\t\t}\n\t\twritel(reg, &aup->mac->control);\n\t\twmb(); /* drain writebuffer */\n\t\tmdelay(1);\n\n\t\tau1000_enable_rx_tx(dev);\n\t\taup->old_duplex = phydev->duplex;\n\n\t\tstatus_change = 1;\n\t}\n\n\tif (phydev->link != aup->old_link) {\n\t\t/* link state changed */\n\n\t\tif (!phydev->link) {\n\t\t\t/* link went down */\n\t\t\taup->old_speed = 0;\n\t\t\taup->old_duplex = -1;\n\t\t}\n\n\t\taup->old_link = phydev->link;\n\t\tstatus_change = 1;\n\t}\n\n\tspin_unlock_irqrestore(&aup->lock, flags);\n\n\tif (status_change) {\n\t\tif (phydev->link)\n\t\t\tnetdev_info(dev, \"link up (%d/%s)\\n\",\n\t\t\t       phydev->speed,\n\t\t\t       DUPLEX_FULL == phydev->duplex ? \"Full\" : \"Half\");\n\t\telse\n\t\t\tnetdev_info(dev, \"link down\\n\");\n\t}\n}"
    },
    {
        "var_name": "skb",
        "function_name": "lance_rx",
        "location": {
            "file_path": "drivers/net/ethernet/amd/sun3lance.c",
            "region": {
                "startLine": 834,
                "startColumn": 5,
                "endColumn": 8
            },
            "context": {
                "startLine": 832,
                "endLine": 836,
                "snippet": {
                    "text": "skb->protocol = eth_type_trans( skb, dev );"
                }
            }
        },
        "function_code": "static int lance_rx( struct net_device *dev )\n{\n\tstruct lance_private *lp = netdev_priv(dev);\n\tint entry = lp->new_rx;\n\n\t/* If we own the next entry, it's a new packet. Send it up. */\n\twhile( (MEM->rx_head[entry].flag & RMD1_OWN) == RMD1_OWN_HOST ) {\n\t\tstruct lance_rx_head *head = &(MEM->rx_head[entry]);\n\t\tint status = head->flag;\n\n\t\tif (status != (RMD1_ENP|RMD1_STP)) {  /* There was an error. */\n\t\t\t/* There is a tricky error noted by John Murphy,\n\t\t\t   <murf@perftech.com> to Russ Nelson: Even with\n\t\t\t   full-sized buffers it's possible for a jabber packet to use two\n\t\t\t   buffers, with only the last correctly noting the error. */\n\t\t\tif (status & RMD1_ENP)\t/* Only count a general error at the */\n\t\t\t\tdev->stats.rx_errors++; /* end of a packet.*/\n\t\t\tif (status & RMD1_FRAM) dev->stats.rx_frame_errors++;\n\t\t\tif (status & RMD1_OFLO) dev->stats.rx_over_errors++;\n\t\t\tif (status & RMD1_CRC) dev->stats.rx_crc_errors++;\n\t\t\tif (status & RMD1_BUFF) dev->stats.rx_fifo_errors++;\n\t\t\thead->flag &= (RMD1_ENP|RMD1_STP);\n\t\t} else {\n\t\t\t/* Malloc up new buffer, compatible with net-3. */\n//\t\t\tshort pkt_len = head->msg_length;// & 0xfff;\n\t\t\tshort pkt_len = (head->msg_length & 0xfff) - 4;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (pkt_len < 60) {\n\t\t\t\tprintk( \"%s: Runt packet!\\n\", dev->name );\n\t\t\t\tdev->stats.rx_errors++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tskb = netdev_alloc_skb(dev, pkt_len + 2);\n\t\t\t\tif (!skb) {\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t\thead->msg_length = 0;\n\t\t\t\t\thead->flag |= RMD1_OWN_CHIP;\n\t\t\t\t\tlp->new_rx = (lp->new_rx+1) &\n\t\t\t\t\t     RX_RING_MOD_MASK;\n\t\t\t\t}\n\n#if 0\n\t\t\t\tif (lance_debug >= 3) {\n\t\t\t\t\tu_char *data = PKTBUF_ADDR(head);\n\t\t\t\t\tprintk(\"%s: RX pkt %d type 0x%04x\"\n\t\t\t\t\t       \" from %pM to %pM\",\n\t\t\t\t\t       dev->name, lp->new_tx, ((u_short *)data)[6],\n\t\t\t\t\t       &data[6], data);\n\n\t\t\t\t\tprintk(\" data %02x %02x %02x %02x %02x %02x %02x %02x \"\n\t\t\t\t\t       \"len %d at %08x\\n\",\n\t\t\t\t\t       data[15], data[16], data[17], data[18],\n\t\t\t\t\t       data[19], data[20], data[21], data[22],\n\t\t\t\t\t       pkt_len, data);\n\t\t\t\t}\n#endif\n\t\t\t\tif (lance_debug >= 3) {\n\t\t\t\t\tu_char *data = PKTBUF_ADDR(head);\n\t\t\t\t\tprintk( \"%s: RX pkt %d type 0x%04x len %d\\n \", dev->name, entry, ((u_short *)data)[6], pkt_len);\n\t\t\t\t}\n\n\n\t\t\t\tskb_reserve( skb, 2 );\t/* 16 byte align */\n\t\t\t\tskb_put( skb, pkt_len );\t/* Make room */\n\t\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\t\t PKTBUF_ADDR(head),\n\t\t\t\t\t\t pkt_len);\n\n\t\t\t\tskb->protocol = eth_type_trans( skb, dev );\n\t\t\t\tnetif_rx( skb );\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t}\n\t\t}\n\n//\t\thead->buf_length = -PKT_BUF_SZ | 0xf000;\n\t\thead->msg_length = 0;\n\t\thead->flag = RMD1_OWN_CHIP;\n\n\t\tentry = lp->new_rx = (lp->new_rx +1) & RX_RING_MOD_MASK;\n\t}\n\n\t/* From lance.c (Donald Becker): */\n\t/* We should check that at least two ring entries are free.\n\t   If not, we should free one and mark stats->rx_dropped++. */\n\n\treturn 0;\n}"
    },
    {
        "var_name": "dev",
        "function_name": "mace_remove",
        "location": {
            "file_path": "drivers/net/ethernet/apple/mace.c",
            "region": {
                "startLine": 288,
                "startColumn": 11,
                "endColumn": 14
            },
            "context": {
                "startLine": 286,
                "endLine": 290,
                "snippet": {
                    "text": "free_irq(dev->irq, dev);"
                }
            }
        },
        "function_code": "static void mace_remove(struct macio_dev *mdev)\n{\n\tstruct net_device *dev = macio_get_drvdata(mdev);\n\tstruct mace_data *mp;\n\n\tBUG_ON(dev == NULL);\n\n\tmacio_set_drvdata(mdev, NULL);\n\n\tmp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\n\tfree_irq(dev->irq, dev);\n\tfree_irq(mp->tx_dma_intr, dev);\n\tfree_irq(mp->rx_dma_intr, dev);\n\n\tiounmap(mp->rx_dma);\n\tiounmap(mp->tx_dma);\n\tiounmap(mp->mace);\n\n\tfree_netdev(dev);\n\n\tmacio_release_resources(mdev);\n}"
    },
    {
        "var_name": "rule",
        "function_name": "aq_update_table_filters",
        "location": {
            "file_path": "drivers/net/ethernet/aquantia/atlantic/aq_filters.c",
            "region": {
                "startLine": 640,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 638,
                "endLine": 642,
                "snippet": {
                    "text": "if (rule->aq_fsp.location >= index)"
                }
            }
        },
        "function_code": "static int aq_update_table_filters(struct aq_nic_s *aq_nic,\n\t\t\t\t   struct aq_rx_filter *aq_rx_fltr, u16 index,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct aq_rx_filter *rule = NULL, *parent = NULL;\n\tstruct hlist_node *aq_node2;\n\tint err = -EINVAL;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\tif (rule->aq_fsp.location >= index)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\tif (rule && rule->aq_fsp.location == index) {\n\t\terr = aq_add_del_rule(aq_nic, rule, false);\n\t\thlist_del(&rule->aq_node);\n\t\tkfree(rule);\n\t\t--rx_fltrs->active_filters;\n\t}\n\n\tif (unlikely(!aq_rx_fltr))\n\t\treturn err;\n\n\tINIT_HLIST_NODE(&aq_rx_fltr->aq_node);\n\n\tif (parent)\n\t\thlist_add_behind(&aq_rx_fltr->aq_node, &parent->aq_node);\n\telse\n\t\thlist_add_head(&aq_rx_fltr->aq_node, &rx_fltrs->filter_list);\n\n\t++rx_fltrs->active_filters;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "rule",
        "function_name": "aq_del_rxnfc_rule",
        "location": {
            "file_path": "drivers/net/ethernet/aquantia/atlantic/aq_filters.c",
            "region": {
                "startLine": 727,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 725,
                "endLine": 729,
                "snippet": {
                    "text": "if (rule->aq_fsp.location == cmd->fs.location)"
                }
            }
        },
        "function_code": "int aq_del_rxnfc_rule(struct aq_nic_s *aq_nic, const struct ethtool_rxnfc *cmd)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct aq_rx_filter *rule = NULL;\n\tstruct hlist_node *aq_node2;\n\tint err = -EINVAL;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\tif (rule->aq_fsp.location == cmd->fs.location)\n\t\t\tbreak;\n\t}\n\n\tif (rule && rule->aq_fsp.location == cmd->fs.location) {\n\t\terr = aq_add_del_rule(aq_nic, rule, false);\n\t\thlist_del(&rule->aq_node);\n\t\tkfree(rule);\n\t\t--rx_fltrs->active_filters;\n\t}\n\treturn err;\n}"
    },
    {
        "var_name": "rule",
        "function_name": "aq_get_rxnfc_rule",
        "location": {
            "file_path": "drivers/net/ethernet/aquantia/atlantic/aq_filters.c",
            "region": {
                "startLine": 750,
                "startColumn": 24,
                "endColumn": 28
            },
            "context": {
                "startLine": 748,
                "endLine": 752,
                "snippet": {
                    "text": "if (fsp->location <= rule->aq_fsp.location)"
                }
            }
        },
        "function_code": "int aq_get_rxnfc_rule(struct aq_nic_s *aq_nic, struct ethtool_rxnfc *cmd)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct aq_rx_filter *rule = NULL;\n\tstruct hlist_node *aq_node2;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node)\n\t\tif (fsp->location <= rule->aq_fsp.location)\n\t\t\tbreak;\n\n\tif (unlikely(!rule || fsp->location != rule->aq_fsp.location))\n\t\treturn -EINVAL;\n\n\tmemcpy(fsp, &rule->aq_fsp, sizeof(*fsp));\n\n\treturn 0;\n}"
    },
    {
        "var_name": "skb",
        "function_name": "b44_tx",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/b44.c",
            "region": {
                "startLine": 608,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 606,
                "endLine": 610,
                "snippet": {
                    "text": "skb->len,"
                }
            }
        },
        "function_code": "static void b44_tx(struct b44 *bp)\n{\n\tu32 cur, cons;\n\tunsigned bytes_compl = 0, pkts_compl = 0;\n\n\tcur  = br32(bp, B44_DMATX_STAT) & DMATX_STAT_CDMASK;\n\tcur /= sizeof(struct dma_desc);\n\n\t/* XXX needs updating when NETIF_F_SG is supported */\n\tfor (cons = bp->tx_cons; cons != cur; cons = NEXT_TX(cons)) {\n\t\tstruct ring_info *rp = &bp->tx_buffers[cons];\n\t\tstruct sk_buff *skb = rp->skb;\n\n\t\tBUG_ON(skb == NULL);\n\n\t\tdma_unmap_single(bp->sdev->dma_dev,\n\t\t\t\t rp->mapping,\n\t\t\t\t skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\trp->skb = NULL;\n\n\t\tbytes_compl += skb->len;\n\t\tpkts_compl++;\n\n\t\tdev_consume_skb_irq(skb);\n\t}\n\n\tnetdev_completed_queue(bp->dev, pkts_compl, bytes_compl);\n\tbp->tx_cons = cons;\n\tif (netif_queue_stopped(bp->dev) &&\n\t    TX_BUFFS_AVAIL(bp) > B44_TX_WAKEUP_THRESH)\n\t\tnetif_wake_queue(bp->dev);\n\n\tbw32(bp, B44_GPTIMER, 0);\n}"
    },
    {
        "var_name": "skb",
        "function_name": "b44_tx",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/b44.c",
            "region": {
                "startLine": 612,
                "startColumn": 18,
                "endColumn": 21
            },
            "context": {
                "startLine": 610,
                "endLine": 614,
                "snippet": {
                    "text": "bytes_compl += skb->len;"
                }
            }
        },
        "function_code": "static void b44_tx(struct b44 *bp)\n{\n\tu32 cur, cons;\n\tunsigned bytes_compl = 0, pkts_compl = 0;\n\n\tcur  = br32(bp, B44_DMATX_STAT) & DMATX_STAT_CDMASK;\n\tcur /= sizeof(struct dma_desc);\n\n\t/* XXX needs updating when NETIF_F_SG is supported */\n\tfor (cons = bp->tx_cons; cons != cur; cons = NEXT_TX(cons)) {\n\t\tstruct ring_info *rp = &bp->tx_buffers[cons];\n\t\tstruct sk_buff *skb = rp->skb;\n\n\t\tBUG_ON(skb == NULL);\n\n\t\tdma_unmap_single(bp->sdev->dma_dev,\n\t\t\t\t rp->mapping,\n\t\t\t\t skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\trp->skb = NULL;\n\n\t\tbytes_compl += skb->len;\n\t\tpkts_compl++;\n\n\t\tdev_consume_skb_irq(skb);\n\t}\n\n\tnetdev_completed_queue(bp->dev, pkts_compl, bytes_compl);\n\tbp->tx_cons = cons;\n\tif (netif_queue_stopped(bp->dev) &&\n\t    TX_BUFFS_AVAIL(bp) > B44_TX_WAKEUP_THRESH)\n\t\tnetif_wake_queue(bp->dev);\n\n\tbw32(bp, B44_GPTIMER, 0);\n}"
    },
    {
        "var_name": "phydev",
        "function_name": "b44_adjust_link",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/b44.c",
            "region": {
                "startLine": 2201,
                "startColumn": 22,
                "endColumn": 28
            },
            "context": {
                "startLine": 2199,
                "endLine": 2203,
                "snippet": {
                    "text": "if (bp->old_link != phydev->link) {"
                }
            }
        },
        "function_code": "static void b44_adjust_link(struct net_device *dev)\n{\n\tstruct b44 *bp = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tbool status_changed = false;\n\n\tBUG_ON(!phydev);\n\n\tif (bp->old_link != phydev->link) {\n\t\tstatus_changed = true;\n\t\tbp->old_link = phydev->link;\n\t}\n\n\t/* reflect duplex change */\n\tif (phydev->link) {\n\t\tif ((phydev->duplex == DUPLEX_HALF) &&\n\t\t    (bp->flags & B44_FLAG_FULL_DUPLEX)) {\n\t\t\tstatus_changed = true;\n\t\t\tbp->flags &= ~B44_FLAG_FULL_DUPLEX;\n\t\t} else if ((phydev->duplex == DUPLEX_FULL) &&\n\t\t\t   !(bp->flags & B44_FLAG_FULL_DUPLEX)) {\n\t\t\tstatus_changed = true;\n\t\t\tbp->flags |= B44_FLAG_FULL_DUPLEX;\n\t\t}\n\t}\n\n\tif (status_changed) {\n\t\tu32 val = br32(bp, B44_TX_CTRL);\n\t\tif (bp->flags & B44_FLAG_FULL_DUPLEX)\n\t\t\tval |= TX_CTRL_DUPLEX;\n\t\telse\n\t\t\tval &= ~TX_CTRL_DUPLEX;\n\t\tbw32(bp, B44_TX_CTRL, val);\n\t\tphy_print_status(phydev);\n\t}\n}"
    },
    {
        "var_name": "mac",
        "function_name": "bnx2x_set_mac_one",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c",
            "region": {
                "startLine": 8445,
                "startColumn": 43,
                "endColumn": 46
            },
            "context": {
                "startLine": 8443,
                "endLine": 8447,
                "snippet": {
                    "text": "memcpy(ramrod_param.user_req.u.mac.mac, mac, ETH_ALEN);"
                }
            }
        },
        "function_code": "int bnx2x_set_mac_one(struct bnx2x *bp, const u8 *mac,\n\t\t      struct bnx2x_vlan_mac_obj *obj, bool set,\n\t\t      int mac_type, unsigned long *ramrod_flags)\n{\n\tint rc;\n\tstruct bnx2x_vlan_mac_ramrod_params ramrod_param;\n\n\tmemset(&ramrod_param, 0, sizeof(ramrod_param));\n\n\t/* Fill general parameters */\n\tramrod_param.vlan_mac_obj = obj;\n\tramrod_param.ramrod_flags = *ramrod_flags;\n\n\t/* Fill a user request section if needed */\n\tif (!test_bit(RAMROD_CONT, ramrod_flags)) {\n\t\tmemcpy(ramrod_param.user_req.u.mac.mac, mac, ETH_ALEN);\n\n\t\t__set_bit(mac_type, &ramrod_param.user_req.vlan_mac_flags);\n\n\t\t/* Set the command: ADD or DEL */\n\t\tif (set)\n\t\t\tramrod_param.user_req.cmd = BNX2X_VLAN_MAC_ADD;\n\t\telse\n\t\t\tramrod_param.user_req.cmd = BNX2X_VLAN_MAC_DEL;\n\t}\n\n\trc = bnx2x_config_vlan_mac(bp, &ramrod_param);\n\n\tif (rc == -EEXIST) {\n\t\tDP(BNX2X_MSG_SP, \"Failed to schedule ADD operations: %d\\n\", rc);\n\t\t/* do not treat adding same MAC as error */\n\t\trc = 0;\n\t} else if (rc < 0)\n\t\tBNX2X_ERR(\"%s MAC failed\\n\", (set ? \"Set\" : \"Del\"));\n\n\treturn rc;\n}"
    },
    {
        "var_name": "mp",
        "function_name": "bnx2x_get_cam_offset_mac",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c",
            "region": {
                "startLine": 333,
                "startColumn": 9,
                "endColumn": 11
            },
            "context": {
                "startLine": 331,
                "endLine": 335,
                "snippet": {
                    "text": "return mp->get_entry(mp, offset);"
                }
            }
        },
        "function_code": "static bool bnx2x_get_cam_offset_mac(struct bnx2x_vlan_mac_obj *o, int *offset)\n{\n\tstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\n\n\tWARN_ON(!mp);\n\n\treturn mp->get_entry(mp, offset);\n}"
    },
    {
        "var_name": "mp",
        "function_name": "bnx2x_get_credit_mac",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c",
            "region": {
                "startLine": 342,
                "startColumn": 9,
                "endColumn": 11
            },
            "context": {
                "startLine": 340,
                "endLine": 344,
                "snippet": {
                    "text": "return mp->get(mp, 1);"
                }
            }
        },
        "function_code": "static bool bnx2x_get_credit_mac(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_credit_pool_obj *mp = o->macs_pool;\n\n\tWARN_ON(!mp);\n\n\treturn mp->get(mp, 1);\n}"
    },
    {
        "var_name": "vp",
        "function_name": "bnx2x_get_cam_offset_vlan",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c",
            "region": {
                "startLine": 351,
                "startColumn": 9,
                "endColumn": 11
            },
            "context": {
                "startLine": 349,
                "endLine": 353,
                "snippet": {
                    "text": "return vp->get_entry(vp, offset);"
                }
            }
        },
        "function_code": "static bool bnx2x_get_cam_offset_vlan(struct bnx2x_vlan_mac_obj *o, int *offset)\n{\n\tstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\n\n\tWARN_ON(!vp);\n\n\treturn vp->get_entry(vp, offset);\n}"
    },
    {
        "var_name": "vp",
        "function_name": "bnx2x_get_credit_vlan",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c",
            "region": {
                "startLine": 360,
                "startColumn": 9,
                "endColumn": 11
            },
            "context": {
                "startLine": 358,
                "endLine": 362,
                "snippet": {
                    "text": "return vp->get(vp, 1);"
                }
            }
        },
        "function_code": "static bool bnx2x_get_credit_vlan(struct bnx2x_vlan_mac_obj *o)\n{\n\tstruct bnx2x_credit_pool_obj *vp = o->vlans_pool;\n\n\tWARN_ON(!vp);\n\n\treturn vp->get(vp, 1);\n}"
    },
    {
        "var_name": "mcasts",
        "function_name": "bnx2x_vf_mcast",
        "location": {
            "file_path": "drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.c",
            "region": {
                "startLine": 565,
                "startColumn": 16,
                "endColumn": 22
            },
            "context": {
                "startLine": 563,
                "endLine": 567,
                "snippet": {
                    "text": "mc[i].mac = mcasts[i];"
                }
            }
        },
        "function_code": "int bnx2x_vf_mcast(struct bnx2x *bp, struct bnx2x_virtf *vf,\n\t\t   bnx2x_mac_addr_t *mcasts, int mc_num, bool drv_only)\n{\n\tstruct bnx2x_mcast_list_elem *mc = NULL;\n\tstruct bnx2x_mcast_ramrod_params mcast;\n\tint rc, i;\n\n\tDP(BNX2X_MSG_IOV, \"vf[%d]\\n\", vf->abs_vfid);\n\n\t/* Prepare Multicast command */\n\tmemset(&mcast, 0, sizeof(struct bnx2x_mcast_ramrod_params));\n\tmcast.mcast_obj = &vf->mcast_obj;\n\tif (drv_only)\n\t\tset_bit(RAMROD_DRV_CLR_ONLY, &mcast.ramrod_flags);\n\telse\n\t\tset_bit(RAMROD_COMP_WAIT, &mcast.ramrod_flags);\n\tif (mc_num) {\n\t\tmc = kcalloc(mc_num, sizeof(struct bnx2x_mcast_list_elem),\n\t\t\t     GFP_KERNEL);\n\t\tif (!mc) {\n\t\t\tBNX2X_ERR(\"Cannot Configure multicasts due to lack of memory\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tif (mc_num) {\n\t\tINIT_LIST_HEAD(&mcast.mcast_list);\n\t\tfor (i = 0; i < mc_num; i++) {\n\t\t\tmc[i].mac = mcasts[i];\n\t\t\tlist_add_tail(&mc[i].link,\n\t\t\t\t      &mcast.mcast_list);\n\t\t}\n\n\t\t/* add new mcasts */\n\t\tmcast.mcast_list_len = mc_num;\n\t\trc = bnx2x_config_mcast(bp, &mcast, BNX2X_MCAST_CMD_SET);\n\t\tif (rc)\n\t\t\tBNX2X_ERR(\"Failed to set multicasts\\n\");\n\t} else {\n\t\t/* clear existing mcasts */\n\t\trc = bnx2x_config_mcast(bp, &mcast, BNX2X_MCAST_CMD_DEL);\n\t\tif (rc)\n\t\t\tBNX2X_ERR(\"Failed to remove multicasts\\n\");\n\t}\n\n\tkfree(mc);\n\n\treturn rc;\n}"
    },
    {
        "var_name": "rxp",
        "function_name": "bna_bfi_rx_enet_start",
        "location": {
            "file_path": "drivers/net/ethernet/brocade/bna/bna_tx_rx.c",
            "region": {
                "startLine": 1630,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 1628,
                "endLine": 1632,
                "snippet": {
                    "text": "GET_RXQS(rxp, q0, q1);"
                }
            }
        },
        "function_code": "static void\nbna_bfi_rx_enet_start(struct bna_rx *rx)\n{\n\tstruct bfi_enet_rx_cfg_req *cfg_req = &rx->bfi_enet_cmd.cfg_req;\n\tstruct bna_rxp *rxp = NULL;\n\tstruct bna_rxq *q0 = NULL, *q1 = NULL;\n\tint i;\n\n\tbfi_msgq_mhdr_set(cfg_req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_RX_CFG_SET_REQ, 0, rx->rid);\n\tcfg_req->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_rx_cfg_req)));\n\n\tcfg_req->rx_cfg.frame_size = bna_enet_mtu_get(&rx->bna->enet);\n\tcfg_req->num_queue_sets = rx->num_paths;\n\tfor (i = 0; i < rx->num_paths; i++) {\n\t\trxp = rxp ? list_next_entry(rxp, qe)\n\t\t\t: list_first_entry(&rx->rxp_q, struct bna_rxp, qe);\n\t\tGET_RXQS(rxp, q0, q1);\n\t\tswitch (rxp->type) {\n\t\tcase BNA_RXP_SLR:\n\t\tcase BNA_RXP_HDS:\n\t\t\t/* Small RxQ */\n\t\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].qs.q,\n\t\t\t\t\t\t&q1->qpt);\n\t\t\tcfg_req->q_cfg[i].qs.rx_buffer_size =\n\t\t\t\thtons((u16)q1->buffer_size);\n\t\t\tfallthrough;\n\n\t\tcase BNA_RXP_SINGLE:\n\t\t\t/* Large/Single RxQ */\n\t\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].ql.q,\n\t\t\t\t\t\t&q0->qpt);\n\t\t\tif (q0->multi_buffer)\n\t\t\t\t/* multi-buffer is enabled by allocating\n\t\t\t\t * a new rx with new set of resources.\n\t\t\t\t * q0->buffer_size should be initialized to\n\t\t\t\t * fragment size.\n\t\t\t\t */\n\t\t\t\tcfg_req->rx_cfg.multi_buffer =\n\t\t\t\t\tBNA_STATUS_T_ENABLED;\n\t\t\telse\n\t\t\t\tq0->buffer_size =\n\t\t\t\t\tbna_enet_mtu_get(&rx->bna->enet);\n\t\t\tcfg_req->q_cfg[i].ql.rx_buffer_size =\n\t\t\t\thtons((u16)q0->buffer_size);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG_ON(1);\n\t\t}\n\n\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].cq.q,\n\t\t\t\t\t&rxp->cq.qpt);\n\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_lo =\n\t\t\trxp->cq.ib.ib_seg_host_addr.lsb;\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_hi =\n\t\t\trxp->cq.ib.ib_seg_host_addr.msb;\n\t\tcfg_req->q_cfg[i].ib.intr.msix_index =\n\t\t\thtons((u16)rxp->cq.ib.intr_vector);\n\t}\n\n\tcfg_req->ib_cfg.int_pkt_dma = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.int_enabled = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_pkt_enabled = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.continuous_coalescing = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.msix = (rxp->cq.ib.intr_type == BNA_INTR_T_MSIX)\n\t\t\t\t? BNA_STATUS_T_ENABLED :\n\t\t\t\tBNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.coalescing_timeout =\n\t\t\thtonl((u32)rxp->cq.ib.coalescing_timeo);\n\tcfg_req->ib_cfg.inter_pkt_timeout =\n\t\t\thtonl((u32)rxp->cq.ib.interpkt_timeo);\n\tcfg_req->ib_cfg.inter_pkt_count = (u8)rxp->cq.ib.interpkt_count;\n\n\tswitch (rxp->type) {\n\tcase BNA_RXP_SLR:\n\t\tcfg_req->rx_cfg.rxq_type = BFI_ENET_RXQ_LARGE_SMALL;\n\t\tbreak;\n\n\tcase BNA_RXP_HDS:\n\t\tcfg_req->rx_cfg.rxq_type = BFI_ENET_RXQ_HDS;\n\t\tcfg_req->rx_cfg.hds.type = rx->hds_cfg.hdr_type;\n\t\tcfg_req->rx_cfg.hds.force_offset = rx->hds_cfg.forced_offset;\n\t\tcfg_req->rx_cfg.hds.max_header_size = rx->hds_cfg.forced_offset;\n\t\tbreak;\n\n\tcase BNA_RXP_SINGLE:\n\t\tcfg_req->rx_cfg.rxq_type = BFI_ENET_RXQ_SINGLE;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n\tcfg_req->rx_cfg.strip_vlan = rx->rxf.vlan_strip_status;\n\n\tbfa_msgq_cmd_set(&rx->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_rx_cfg_req), &cfg_req->mh);\n\tbfa_msgq_cmd_post(&rx->bna->msgq, &rx->msgq_cmd);\n}"
    },
    {
        "var_name": "txq",
        "function_name": "bna_bfi_tx_enet_start",
        "location": {
            "file_path": "drivers/net/ethernet/brocade/bna/bna_tx_rx.c",
            "region": {
                "startLine": 3102,
                "startColumn": 34,
                "endColumn": 37
            },
            "context": {
                "startLine": 3100,
                "endLine": 3104,
                "snippet": {
                    "text": "cfg_req->q_cfg[i].q.priority = txq->priority;"
                }
            }
        },
        "function_code": "static void\nbna_bfi_tx_enet_start(struct bna_tx *tx)\n{\n\tstruct bfi_enet_tx_cfg_req *cfg_req = &tx->bfi_enet_cmd.cfg_req;\n\tstruct bna_txq *txq = NULL;\n\tint i;\n\n\tbfi_msgq_mhdr_set(cfg_req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_TX_CFG_SET_REQ, 0, tx->rid);\n\tcfg_req->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_tx_cfg_req)));\n\n\tcfg_req->num_queues = tx->num_txq;\n\tfor (i = 0; i < tx->num_txq; i++) {\n\t\ttxq = txq ? list_next_entry(txq, qe)\n\t\t\t: list_first_entry(&tx->txq_q, struct bna_txq, qe);\n\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].q.q, &txq->qpt);\n\t\tcfg_req->q_cfg[i].q.priority = txq->priority;\n\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_lo =\n\t\t\ttxq->ib.ib_seg_host_addr.lsb;\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_hi =\n\t\t\ttxq->ib.ib_seg_host_addr.msb;\n\t\tcfg_req->q_cfg[i].ib.intr.msix_index =\n\t\t\thtons((u16)txq->ib.intr_vector);\n\t}\n\n\tcfg_req->ib_cfg.int_pkt_dma = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_enabled = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_pkt_enabled = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.continuous_coalescing = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.msix = (txq->ib.intr_type == BNA_INTR_T_MSIX)\n\t\t\t\t? BNA_STATUS_T_ENABLED : BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.coalescing_timeout =\n\t\t\thtonl((u32)txq->ib.coalescing_timeo);\n\tcfg_req->ib_cfg.inter_pkt_timeout =\n\t\t\thtonl((u32)txq->ib.interpkt_timeo);\n\tcfg_req->ib_cfg.inter_pkt_count = (u8)txq->ib.interpkt_count;\n\n\tcfg_req->tx_cfg.vlan_mode = BFI_ENET_TX_VLAN_WI;\n\tcfg_req->tx_cfg.vlan_id = htons((u16)tx->txf_vlan_id);\n\tcfg_req->tx_cfg.admit_tagged_frame = BNA_STATUS_T_ENABLED;\n\tcfg_req->tx_cfg.apply_vlan_filter = BNA_STATUS_T_DISABLED;\n\n\tbfa_msgq_cmd_set(&tx->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_tx_cfg_req), &cfg_req->mh);\n\tbfa_msgq_cmd_post(&tx->bna->msgq, &tx->msgq_cmd);\n}"
    },
    {
        "var_name": "txq",
        "function_name": "bna_bfi_tx_enet_start",
        "location": {
            "file_path": "drivers/net/ethernet/brocade/bna/bna_tx_rx.c",
            "region": {
                "startLine": 3105,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 3103,
                "endLine": 3107,
                "snippet": {
                    "text": "txq->ib.ib_seg_host_addr.lsb;"
                }
            }
        },
        "function_code": "static void\nbna_bfi_tx_enet_start(struct bna_tx *tx)\n{\n\tstruct bfi_enet_tx_cfg_req *cfg_req = &tx->bfi_enet_cmd.cfg_req;\n\tstruct bna_txq *txq = NULL;\n\tint i;\n\n\tbfi_msgq_mhdr_set(cfg_req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_TX_CFG_SET_REQ, 0, tx->rid);\n\tcfg_req->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_tx_cfg_req)));\n\n\tcfg_req->num_queues = tx->num_txq;\n\tfor (i = 0; i < tx->num_txq; i++) {\n\t\ttxq = txq ? list_next_entry(txq, qe)\n\t\t\t: list_first_entry(&tx->txq_q, struct bna_txq, qe);\n\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].q.q, &txq->qpt);\n\t\tcfg_req->q_cfg[i].q.priority = txq->priority;\n\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_lo =\n\t\t\ttxq->ib.ib_seg_host_addr.lsb;\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_hi =\n\t\t\ttxq->ib.ib_seg_host_addr.msb;\n\t\tcfg_req->q_cfg[i].ib.intr.msix_index =\n\t\t\thtons((u16)txq->ib.intr_vector);\n\t}\n\n\tcfg_req->ib_cfg.int_pkt_dma = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_enabled = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_pkt_enabled = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.continuous_coalescing = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.msix = (txq->ib.intr_type == BNA_INTR_T_MSIX)\n\t\t\t\t? BNA_STATUS_T_ENABLED : BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.coalescing_timeout =\n\t\t\thtonl((u32)txq->ib.coalescing_timeo);\n\tcfg_req->ib_cfg.inter_pkt_timeout =\n\t\t\thtonl((u32)txq->ib.interpkt_timeo);\n\tcfg_req->ib_cfg.inter_pkt_count = (u8)txq->ib.interpkt_count;\n\n\tcfg_req->tx_cfg.vlan_mode = BFI_ENET_TX_VLAN_WI;\n\tcfg_req->tx_cfg.vlan_id = htons((u16)tx->txf_vlan_id);\n\tcfg_req->tx_cfg.admit_tagged_frame = BNA_STATUS_T_ENABLED;\n\tcfg_req->tx_cfg.apply_vlan_filter = BNA_STATUS_T_DISABLED;\n\n\tbfa_msgq_cmd_set(&tx->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_tx_cfg_req), &cfg_req->mh);\n\tbfa_msgq_cmd_post(&tx->bna->msgq, &tx->msgq_cmd);\n}"
    },
    {
        "var_name": "txq",
        "function_name": "bna_bfi_tx_enet_start",
        "location": {
            "file_path": "drivers/net/ethernet/brocade/bna/bna_tx_rx.c",
            "region": {
                "startLine": 3107,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 3105,
                "endLine": 3109,
                "snippet": {
                    "text": "txq->ib.ib_seg_host_addr.msb;"
                }
            }
        },
        "function_code": "static void\nbna_bfi_tx_enet_start(struct bna_tx *tx)\n{\n\tstruct bfi_enet_tx_cfg_req *cfg_req = &tx->bfi_enet_cmd.cfg_req;\n\tstruct bna_txq *txq = NULL;\n\tint i;\n\n\tbfi_msgq_mhdr_set(cfg_req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_TX_CFG_SET_REQ, 0, tx->rid);\n\tcfg_req->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_tx_cfg_req)));\n\n\tcfg_req->num_queues = tx->num_txq;\n\tfor (i = 0; i < tx->num_txq; i++) {\n\t\ttxq = txq ? list_next_entry(txq, qe)\n\t\t\t: list_first_entry(&tx->txq_q, struct bna_txq, qe);\n\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].q.q, &txq->qpt);\n\t\tcfg_req->q_cfg[i].q.priority = txq->priority;\n\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_lo =\n\t\t\ttxq->ib.ib_seg_host_addr.lsb;\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_hi =\n\t\t\ttxq->ib.ib_seg_host_addr.msb;\n\t\tcfg_req->q_cfg[i].ib.intr.msix_index =\n\t\t\thtons((u16)txq->ib.intr_vector);\n\t}\n\n\tcfg_req->ib_cfg.int_pkt_dma = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_enabled = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_pkt_enabled = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.continuous_coalescing = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.msix = (txq->ib.intr_type == BNA_INTR_T_MSIX)\n\t\t\t\t? BNA_STATUS_T_ENABLED : BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.coalescing_timeout =\n\t\t\thtonl((u32)txq->ib.coalescing_timeo);\n\tcfg_req->ib_cfg.inter_pkt_timeout =\n\t\t\thtonl((u32)txq->ib.interpkt_timeo);\n\tcfg_req->ib_cfg.inter_pkt_count = (u8)txq->ib.interpkt_count;\n\n\tcfg_req->tx_cfg.vlan_mode = BFI_ENET_TX_VLAN_WI;\n\tcfg_req->tx_cfg.vlan_id = htons((u16)tx->txf_vlan_id);\n\tcfg_req->tx_cfg.admit_tagged_frame = BNA_STATUS_T_ENABLED;\n\tcfg_req->tx_cfg.apply_vlan_filter = BNA_STATUS_T_DISABLED;\n\n\tbfa_msgq_cmd_set(&tx->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_tx_cfg_req), &cfg_req->mh);\n\tbfa_msgq_cmd_post(&tx->bna->msgq, &tx->msgq_cmd);\n}"
    },
    {
        "var_name": "txq",
        "function_name": "bna_bfi_tx_enet_start",
        "location": {
            "file_path": "drivers/net/ethernet/brocade/bna/bna_tx_rx.c",
            "region": {
                "startLine": 3109,
                "startColumn": 15,
                "endColumn": 18
            },
            "context": {
                "startLine": 3107,
                "endLine": 3111,
                "snippet": {
                    "text": "htons((u16)txq->ib.intr_vector);"
                }
            }
        },
        "function_code": "static void\nbna_bfi_tx_enet_start(struct bna_tx *tx)\n{\n\tstruct bfi_enet_tx_cfg_req *cfg_req = &tx->bfi_enet_cmd.cfg_req;\n\tstruct bna_txq *txq = NULL;\n\tint i;\n\n\tbfi_msgq_mhdr_set(cfg_req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_TX_CFG_SET_REQ, 0, tx->rid);\n\tcfg_req->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_tx_cfg_req)));\n\n\tcfg_req->num_queues = tx->num_txq;\n\tfor (i = 0; i < tx->num_txq; i++) {\n\t\ttxq = txq ? list_next_entry(txq, qe)\n\t\t\t: list_first_entry(&tx->txq_q, struct bna_txq, qe);\n\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].q.q, &txq->qpt);\n\t\tcfg_req->q_cfg[i].q.priority = txq->priority;\n\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_lo =\n\t\t\ttxq->ib.ib_seg_host_addr.lsb;\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_hi =\n\t\t\ttxq->ib.ib_seg_host_addr.msb;\n\t\tcfg_req->q_cfg[i].ib.intr.msix_index =\n\t\t\thtons((u16)txq->ib.intr_vector);\n\t}\n\n\tcfg_req->ib_cfg.int_pkt_dma = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_enabled = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_pkt_enabled = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.continuous_coalescing = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.msix = (txq->ib.intr_type == BNA_INTR_T_MSIX)\n\t\t\t\t? BNA_STATUS_T_ENABLED : BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.coalescing_timeout =\n\t\t\thtonl((u32)txq->ib.coalescing_timeo);\n\tcfg_req->ib_cfg.inter_pkt_timeout =\n\t\t\thtonl((u32)txq->ib.interpkt_timeo);\n\tcfg_req->ib_cfg.inter_pkt_count = (u8)txq->ib.interpkt_count;\n\n\tcfg_req->tx_cfg.vlan_mode = BFI_ENET_TX_VLAN_WI;\n\tcfg_req->tx_cfg.vlan_id = htons((u16)tx->txf_vlan_id);\n\tcfg_req->tx_cfg.admit_tagged_frame = BNA_STATUS_T_ENABLED;\n\tcfg_req->tx_cfg.apply_vlan_filter = BNA_STATUS_T_DISABLED;\n\n\tbfa_msgq_cmd_set(&tx->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_tx_cfg_req), &cfg_req->mh);\n\tbfa_msgq_cmd_post(&tx->bna->msgq, &tx->msgq_cmd);\n}"
    },
    {
        "var_name": "txq",
        "function_name": "bna_bfi_tx_enet_start",
        "location": {
            "file_path": "drivers/net/ethernet/brocade/bna/bna_tx_rx.c",
            "region": {
                "startLine": 3116,
                "startColumn": 26,
                "endColumn": 29
            },
            "context": {
                "startLine": 3114,
                "endLine": 3118,
                "snippet": {
                    "text": "cfg_req->ib_cfg.msix = (txq->ib.intr_type == BNA_INTR_T_MSIX)"
                }
            }
        },
        "function_code": "static void\nbna_bfi_tx_enet_start(struct bna_tx *tx)\n{\n\tstruct bfi_enet_tx_cfg_req *cfg_req = &tx->bfi_enet_cmd.cfg_req;\n\tstruct bna_txq *txq = NULL;\n\tint i;\n\n\tbfi_msgq_mhdr_set(cfg_req->mh, BFI_MC_ENET,\n\t\tBFI_ENET_H2I_TX_CFG_SET_REQ, 0, tx->rid);\n\tcfg_req->mh.num_entries = htons(\n\t\tbfi_msgq_num_cmd_entries(sizeof(struct bfi_enet_tx_cfg_req)));\n\n\tcfg_req->num_queues = tx->num_txq;\n\tfor (i = 0; i < tx->num_txq; i++) {\n\t\ttxq = txq ? list_next_entry(txq, qe)\n\t\t\t: list_first_entry(&tx->txq_q, struct bna_txq, qe);\n\t\tbfi_enet_datapath_q_init(&cfg_req->q_cfg[i].q.q, &txq->qpt);\n\t\tcfg_req->q_cfg[i].q.priority = txq->priority;\n\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_lo =\n\t\t\ttxq->ib.ib_seg_host_addr.lsb;\n\t\tcfg_req->q_cfg[i].ib.index_addr.a32.addr_hi =\n\t\t\ttxq->ib.ib_seg_host_addr.msb;\n\t\tcfg_req->q_cfg[i].ib.intr.msix_index =\n\t\t\thtons((u16)txq->ib.intr_vector);\n\t}\n\n\tcfg_req->ib_cfg.int_pkt_dma = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_enabled = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.int_pkt_enabled = BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.continuous_coalescing = BNA_STATUS_T_ENABLED;\n\tcfg_req->ib_cfg.msix = (txq->ib.intr_type == BNA_INTR_T_MSIX)\n\t\t\t\t? BNA_STATUS_T_ENABLED : BNA_STATUS_T_DISABLED;\n\tcfg_req->ib_cfg.coalescing_timeout =\n\t\t\thtonl((u32)txq->ib.coalescing_timeo);\n\tcfg_req->ib_cfg.inter_pkt_timeout =\n\t\t\thtonl((u32)txq->ib.interpkt_timeo);\n\tcfg_req->ib_cfg.inter_pkt_count = (u8)txq->ib.interpkt_count;\n\n\tcfg_req->tx_cfg.vlan_mode = BFI_ENET_TX_VLAN_WI;\n\tcfg_req->tx_cfg.vlan_id = htons((u16)tx->txf_vlan_id);\n\tcfg_req->tx_cfg.admit_tagged_frame = BNA_STATUS_T_ENABLED;\n\tcfg_req->tx_cfg.apply_vlan_filter = BNA_STATUS_T_DISABLED;\n\n\tbfa_msgq_cmd_set(&tx->msgq_cmd, NULL, NULL,\n\t\tsizeof(struct bfi_enet_tx_cfg_req), &cfg_req->mh);\n\tbfa_msgq_cmd_post(&tx->bna->msgq, &tx->msgq_cmd);\n}"
    },
    {
        "var_name": "macb_config",
        "function_name": "macb_probe",
        "location": {
            "file_path": "drivers/net/ethernet/cadence/macb_main.c",
            "region": {
                "startLine": 5050,
                "startColumn": 11,
                "endColumn": 22
            },
            "context": {
                "startLine": 5048,
                "endLine": 5052,
                "snippet": {
                    "text": "else if (macb_config->max_tx_length)"
                }
            }
        },
        "function_code": "static int macb_probe(struct platform_device *pdev)\n{\n\tconst struct macb_config *macb_config = &default_gem_config;\n\tint (*clk_init)(struct platform_device *, struct clk **,\n\t\t\tstruct clk **, struct clk **,  struct clk **,\n\t\t\tstruct clk **) = macb_config->clk_init;\n\tint (*init)(struct platform_device *) = macb_config->init;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clk *pclk, *hclk = NULL, *tx_clk = NULL, *rx_clk = NULL;\n\tstruct clk *tsu_clk = NULL;\n\tunsigned int queue_mask, num_queues;\n\tbool native_io;\n\tphy_interface_t interface;\n\tstruct net_device *dev;\n\tstruct resource *regs;\n\tu32 wtrmrk_rst_val;\n\tvoid __iomem *mem;\n\tstruct macb *bp;\n\tint err, val;\n\n\tmem = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tif (np) {\n\t\tconst struct of_device_id *match;\n\n\t\tmatch = of_match_node(macb_dt_ids, np);\n\t\tif (match && match->data) {\n\t\t\tmacb_config = match->data;\n\t\t\tclk_init = macb_config->clk_init;\n\t\t\tinit = macb_config->init;\n\t\t}\n\t}\n\n\terr = clk_init(pdev, &pclk, &hclk, &tx_clk, &rx_clk, &tsu_clk);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, MACB_PM_TIMEOUT);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tnative_io = hw_is_native_io(mem);\n\n\tmacb_probe_queues(mem, native_io, &queue_mask, &num_queues);\n\tdev = alloc_etherdev_mq(sizeof(*bp), num_queues);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_disable_clocks;\n\t}\n\n\tdev->base_addr = regs->start;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tbp = netdev_priv(dev);\n\tbp->pdev = pdev;\n\tbp->dev = dev;\n\tbp->regs = mem;\n\tbp->native_io = native_io;\n\tif (native_io) {\n\t\tbp->macb_reg_readl = hw_readl_native;\n\t\tbp->macb_reg_writel = hw_writel_native;\n\t} else {\n\t\tbp->macb_reg_readl = hw_readl;\n\t\tbp->macb_reg_writel = hw_writel;\n\t}\n\tbp->num_queues = num_queues;\n\tbp->queue_mask = queue_mask;\n\tif (macb_config)\n\t\tbp->dma_burst_length = macb_config->dma_burst_length;\n\tbp->pclk = pclk;\n\tbp->hclk = hclk;\n\tbp->tx_clk = tx_clk;\n\tbp->rx_clk = rx_clk;\n\tbp->tsu_clk = tsu_clk;\n\tif (macb_config)\n\t\tbp->jumbo_max_len = macb_config->jumbo_max_len;\n\n\tif (!hw_is_gem(bp->regs, bp->native_io))\n\t\tbp->max_tx_length = MACB_MAX_TX_LEN;\n\telse if (macb_config->max_tx_length)\n\t\tbp->max_tx_length = macb_config->max_tx_length;\n\telse\n\t\tbp->max_tx_length = GEM_MAX_TX_LEN;\n\n\tbp->wol = 0;\n\tif (of_property_read_bool(np, \"magic-packet\"))\n\t\tbp->wol |= MACB_WOL_HAS_MAGIC_PACKET;\n\tdevice_set_wakeup_capable(&pdev->dev, bp->wol & MACB_WOL_HAS_MAGIC_PACKET);\n\n\tbp->usrio = macb_config->usrio;\n\n\t/* By default we set to partial store and forward mode for zynqmp.\n\t * Disable if not set in devicetree.\n\t */\n\tif (GEM_BFEXT(PBUF_CUTTHRU, gem_readl(bp, DCFG6))) {\n\t\terr = of_property_read_u32(bp->pdev->dev.of_node,\n\t\t\t\t\t   \"cdns,rx-watermark\",\n\t\t\t\t\t   &bp->rx_watermark);\n\n\t\tif (!err) {\n\t\t\t/* Disable partial store and forward in case of error or\n\t\t\t * invalid watermark value\n\t\t\t */\n\t\t\twtrmrk_rst_val = (1 << (GEM_BFEXT(RX_PBUF_ADDR, gem_readl(bp, DCFG2)))) - 1;\n\t\t\tif (bp->rx_watermark > wtrmrk_rst_val || !bp->rx_watermark) {\n\t\t\t\tdev_info(&bp->pdev->dev, \"Invalid watermark value\\n\");\n\t\t\t\tbp->rx_watermark = 0;\n\t\t\t}\n\t\t}\n\t}\n\tspin_lock_init(&bp->lock);\n\n\t/* setup capabilities */\n\tmacb_configure_caps(bp, macb_config);\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\tif (GEM_BFEXT(DAW64, gem_readl(bp, DCFG6))) {\n\t\tdma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(44));\n\t\tbp->hw_dma_cap |= HW_DMA_CAP_64B;\n\t}\n#endif\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev->irq = platform_get_irq(pdev, 0);\n\tif (dev->irq < 0) {\n\t\terr = dev->irq;\n\t\tgoto err_out_free_netdev;\n\t}\n\n\t/* MTU range: 68 - 1500 or 10240 */\n\tdev->min_mtu = GEM_MTU_MIN_SIZE;\n\tif ((bp->caps & MACB_CAPS_JUMBO) && bp->jumbo_max_len)\n\t\tdev->max_mtu = bp->jumbo_max_len - ETH_HLEN - ETH_FCS_LEN;\n\telse\n\t\tdev->max_mtu = ETH_DATA_LEN;\n\n\tif (bp->caps & MACB_CAPS_BD_RD_PREFETCH) {\n\t\tval = GEM_BFEXT(RXBD_RDBUFF, gem_readl(bp, DCFG10));\n\t\tif (val)\n\t\t\tbp->rx_bd_rd_prefetch = (2 << (val - 1)) *\n\t\t\t\t\t\tmacb_dma_desc_get_size(bp);\n\n\t\tval = GEM_BFEXT(TXBD_RDBUFF, gem_readl(bp, DCFG10));\n\t\tif (val)\n\t\t\tbp->tx_bd_rd_prefetch = (2 << (val - 1)) *\n\t\t\t\t\t\tmacb_dma_desc_get_size(bp);\n\t}\n\n\tbp->rx_intr_mask = MACB_RX_INT_FLAGS;\n\tif (bp->caps & MACB_CAPS_NEEDS_RSTONUBR)\n\t\tbp->rx_intr_mask |= MACB_BIT(RXUBR);\n\n\terr = of_get_ethdev_address(np, bp->dev);\n\tif (err == -EPROBE_DEFER)\n\t\tgoto err_out_free_netdev;\n\telse if (err)\n\t\tmacb_get_hwaddr(bp);\n\n\terr = of_get_phy_mode(np, &interface);\n\tif (err)\n\t\t/* not found in DT, MII by default */\n\t\tbp->phy_interface = PHY_INTERFACE_MODE_MII;\n\telse\n\t\tbp->phy_interface = interface;\n\n\t/* IP specific init */\n\terr = init(pdev);\n\tif (err)\n\t\tgoto err_out_free_netdev;\n\n\terr = macb_mii_init(bp);\n\tif (err)\n\t\tgoto err_out_phy_exit;\n\n\tnetif_carrier_off(dev);\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device, aborting.\\n\");\n\t\tgoto err_out_unregister_mdio;\n\t}\n\n\ttasklet_setup(&bp->hresp_err_tasklet, macb_hresp_error_task);\n\n\tnetdev_info(dev, \"Cadence %s rev 0x%08x at 0x%08lx irq %d (%pM)\\n\",\n\t\t    macb_is_gem(bp) ? \"GEM\" : \"MACB\", macb_readl(bp, MID),\n\t\t    dev->base_addr, dev->irq, dev->dev_addr);\n\n\tpm_runtime_mark_last_busy(&bp->pdev->dev);\n\tpm_runtime_put_autosuspend(&bp->pdev->dev);\n\n\treturn 0;\n\nerr_out_unregister_mdio:\n\tmdiobus_unregister(bp->mii_bus);\n\tmdiobus_free(bp->mii_bus);\n\nerr_out_phy_exit:\n\tphy_exit(bp->sgmii_phy);\n\nerr_out_free_netdev:\n\tfree_netdev(dev);\n\nerr_disable_clocks:\n\tmacb_clks_disable(pclk, hclk, tx_clk, rx_clk, tsu_clk);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\n\treturn err;\n}"
    },
    {
        "var_name": "iph",
        "function_name": "dpaa_enable_tx_csum",
        "location": {
            "file_path": "drivers/net/ethernet/freescale/dpaa/dpaa_eth.c",
            "region": {
                "startLine": 1498,
                "startColumn": 14,
                "endColumn": 17
            },
            "context": {
                "startLine": 1496,
                "endLine": 1500,
                "snippet": {
                    "text": "l4_proto = iph->protocol;"
                }
            }
        },
        "function_code": "static int dpaa_enable_tx_csum(struct dpaa_priv *priv,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct qm_fd *fd,\n\t\t\t       void *parse_results)\n{\n\tstruct fman_prs_result *parse_result;\n\tu16 ethertype = ntohs(skb->protocol);\n\tstruct ipv6hdr *ipv6h = NULL;\n\tstruct iphdr *iph;\n\tint retval = 0;\n\tu8 l4_proto;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\n\t/* Note: L3 csum seems to be already computed in sw, but we can't choose\n\t * L4 alone from the FM configuration anyway.\n\t */\n\n\t/* Fill in some fields of the Parse Results array, so the FMan\n\t * can find them as if they came from the FMan Parser.\n\t */\n\tparse_result = (struct fman_prs_result *)parse_results;\n\n\t/* If we're dealing with VLAN, get the real Ethernet type */\n\tif (ethertype == ETH_P_8021Q)\n\t\tethertype = ntohs(skb_vlan_eth_hdr(skb)->h_vlan_encapsulated_proto);\n\n\t/* Fill in the relevant L3 parse result fields\n\t * and read the L4 protocol type\n\t */\n\tswitch (ethertype) {\n\tcase ETH_P_IP:\n\t\tparse_result->l3r = cpu_to_be16(FM_L3_PARSE_RESULT_IPV4);\n\t\tiph = ip_hdr(skb);\n\t\tWARN_ON(!iph);\n\t\tl4_proto = iph->protocol;\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tparse_result->l3r = cpu_to_be16(FM_L3_PARSE_RESULT_IPV6);\n\t\tipv6h = ipv6_hdr(skb);\n\t\tWARN_ON(!ipv6h);\n\t\tl4_proto = ipv6h->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\t/* We shouldn't even be here */\n\t\tif (net_ratelimit())\n\t\t\tnetif_alert(priv, tx_err, priv->net_dev,\n\t\t\t\t    \"Can't compute HW csum for L3 proto 0x%x\\n\",\n\t\t\t\t    ntohs(skb->protocol));\n\t\tretval = -EIO;\n\t\tgoto return_error;\n\t}\n\n\t/* Fill in the relevant L4 parse result fields */\n\tswitch (l4_proto) {\n\tcase IPPROTO_UDP:\n\t\tparse_result->l4r = FM_L4_PARSE_RESULT_UDP;\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tparse_result->l4r = FM_L4_PARSE_RESULT_TCP;\n\t\tbreak;\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetif_alert(priv, tx_err, priv->net_dev,\n\t\t\t\t    \"Can't compute HW csum for L4 proto 0x%x\\n\",\n\t\t\t\t    l4_proto);\n\t\tretval = -EIO;\n\t\tgoto return_error;\n\t}\n\n\t/* At index 0 is IPOffset_1 as defined in the Parse Results */\n\tparse_result->ip_off[0] = (u8)skb_network_offset(skb);\n\tparse_result->l4_off = (u8)skb_transport_offset(skb);\n\n\t/* Enable L3 (and L4, if TCP or UDP) HW checksum. */\n\tfd->cmd |= cpu_to_be32(FM_FD_CMD_RPD | FM_FD_CMD_DTC);\n\n\t/* On P1023 and similar platforms fd->cmd interpretation could\n\t * be disabled by setting CONTEXT_A bit ICMD; currently this bit\n\t * is not set so we do not need to check; in the future, if/when\n\t * using context_a we need to check this bit\n\t */\n\nreturn_error:\n\treturn retval;\n}"
    },
    {
        "var_name": "ipv6h",
        "function_name": "dpaa_enable_tx_csum",
        "location": {
            "file_path": "drivers/net/ethernet/freescale/dpaa/dpaa_eth.c",
            "region": {
                "startLine": 1504,
                "startColumn": 14,
                "endColumn": 19
            },
            "context": {
                "startLine": 1502,
                "endLine": 1506,
                "snippet": {
                    "text": "l4_proto = ipv6h->nexthdr;"
                }
            }
        },
        "function_code": "static int dpaa_enable_tx_csum(struct dpaa_priv *priv,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct qm_fd *fd,\n\t\t\t       void *parse_results)\n{\n\tstruct fman_prs_result *parse_result;\n\tu16 ethertype = ntohs(skb->protocol);\n\tstruct ipv6hdr *ipv6h = NULL;\n\tstruct iphdr *iph;\n\tint retval = 0;\n\tu8 l4_proto;\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn 0;\n\n\t/* Note: L3 csum seems to be already computed in sw, but we can't choose\n\t * L4 alone from the FM configuration anyway.\n\t */\n\n\t/* Fill in some fields of the Parse Results array, so the FMan\n\t * can find them as if they came from the FMan Parser.\n\t */\n\tparse_result = (struct fman_prs_result *)parse_results;\n\n\t/* If we're dealing with VLAN, get the real Ethernet type */\n\tif (ethertype == ETH_P_8021Q)\n\t\tethertype = ntohs(skb_vlan_eth_hdr(skb)->h_vlan_encapsulated_proto);\n\n\t/* Fill in the relevant L3 parse result fields\n\t * and read the L4 protocol type\n\t */\n\tswitch (ethertype) {\n\tcase ETH_P_IP:\n\t\tparse_result->l3r = cpu_to_be16(FM_L3_PARSE_RESULT_IPV4);\n\t\tiph = ip_hdr(skb);\n\t\tWARN_ON(!iph);\n\t\tl4_proto = iph->protocol;\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tparse_result->l3r = cpu_to_be16(FM_L3_PARSE_RESULT_IPV6);\n\t\tipv6h = ipv6_hdr(skb);\n\t\tWARN_ON(!ipv6h);\n\t\tl4_proto = ipv6h->nexthdr;\n\t\tbreak;\n\tdefault:\n\t\t/* We shouldn't even be here */\n\t\tif (net_ratelimit())\n\t\t\tnetif_alert(priv, tx_err, priv->net_dev,\n\t\t\t\t    \"Can't compute HW csum for L3 proto 0x%x\\n\",\n\t\t\t\t    ntohs(skb->protocol));\n\t\tretval = -EIO;\n\t\tgoto return_error;\n\t}\n\n\t/* Fill in the relevant L4 parse result fields */\n\tswitch (l4_proto) {\n\tcase IPPROTO_UDP:\n\t\tparse_result->l4r = FM_L4_PARSE_RESULT_UDP;\n\t\tbreak;\n\tcase IPPROTO_TCP:\n\t\tparse_result->l4r = FM_L4_PARSE_RESULT_TCP;\n\t\tbreak;\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetif_alert(priv, tx_err, priv->net_dev,\n\t\t\t\t    \"Can't compute HW csum for L4 proto 0x%x\\n\",\n\t\t\t\t    l4_proto);\n\t\tretval = -EIO;\n\t\tgoto return_error;\n\t}\n\n\t/* At index 0 is IPOffset_1 as defined in the Parse Results */\n\tparse_result->ip_off[0] = (u8)skb_network_offset(skb);\n\tparse_result->l4_off = (u8)skb_transport_offset(skb);\n\n\t/* Enable L3 (and L4, if TCP or UDP) HW checksum. */\n\tfd->cmd |= cpu_to_be32(FM_FD_CMD_RPD | FM_FD_CMD_DTC);\n\n\t/* On P1023 and similar platforms fd->cmd interpretation could\n\t * be disabled by setting CONTEXT_A bit ICMD; currently this bit\n\t * is not set so we do not need to check; in the future, if/when\n\t * using context_a we need to check this bit\n\t */\n\nreturn_error:\n\treturn retval;\n}"
    },
    {
        "var_name": "rule",
        "function_name": "hclge_get_fd_rule",
        "location": {
            "file_path": "drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c",
            "region": {
                "startLine": 6828,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 6826,
                "endLine": 6830,
                "snippet": {
                    "text": "if (rule->location == location)"
                }
            }
        },
        "function_code": "static struct hclge_fd_rule *hclge_get_fd_rule(struct hclge_dev *hdev,\n\t\t\t\t\t       u16 location)\n{\n\tstruct hclge_fd_rule *rule = NULL;\n\tstruct hlist_node *node2;\n\n\thlist_for_each_entry_safe(rule, node2, &hdev->fd_rule_list, rule_node) {\n\t\tif (rule->location == location)\n\t\t\treturn rule;\n\t\telse if (rule->location > location)\n\t\t\treturn NULL;\n\t}\n\n\treturn NULL;\n}"
    },
    {
        "var_name": "dev",
        "function_name": "rgmii_detach",
        "location": {
            "file_path": "drivers/net/ethernet/ibm/emac/rgmii.c",
            "region": {
                "startLine": 181,
                "startColumn": 6,
                "endColumn": 9
            },
            "context": {
                "startLine": 179,
                "endLine": 183,
                "snippet": {
                    "text": "p = dev->base;"
                }
            }
        },
        "function_code": "void rgmii_detach(struct platform_device *ofdev, int input)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct rgmii_regs __iomem *p;\n\n\tBUG_ON(!dev || dev->users == 0);\n\tp = dev->base;\n\n\tmutex_lock(&dev->lock);\n\n\tRGMII_DBG(dev, \"detach(%d)\" NL, input);\n\n\t/* Disable this input */\n\tout_be32(&p->fer, in_be32(&p->fer) & ~RGMII_FER_MASK(input));\n\n\t--dev->users;\n\n\tmutex_unlock(&dev->lock);\n}"
    },
    {
        "var_name": "dev",
        "function_name": "rgmii_detach",
        "location": {
            "file_path": "drivers/net/ethernet/ibm/emac/rgmii.c",
            "region": {
                "startLine": 190,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 188,
                "endLine": 192,
                "snippet": {
                    "text": "--dev->users;"
                }
            }
        },
        "function_code": "void rgmii_detach(struct platform_device *ofdev, int input)\n{\n\tstruct rgmii_instance *dev = platform_get_drvdata(ofdev);\n\tstruct rgmii_regs __iomem *p;\n\n\tBUG_ON(!dev || dev->users == 0);\n\tp = dev->base;\n\n\tmutex_lock(&dev->lock);\n\n\tRGMII_DBG(dev, \"detach(%d)\" NL, input);\n\n\t/* Disable this input */\n\tout_be32(&p->fer, in_be32(&p->fer) & ~RGMII_FER_MASK(input));\n\n\t--dev->users;\n\n\tmutex_unlock(&dev->lock);\n}"
    },
    {
        "var_name": "dev",
        "function_name": "zmii_detach",
        "location": {
            "file_path": "drivers/net/ethernet/ibm/emac/zmii.c",
            "region": {
                "startLine": 205,
                "startColumn": 47,
                "endColumn": 50
            },
            "context": {
                "startLine": 203,
                "endLine": 207,
                "snippet": {
                    "text": "in_be32(&dev->base->fer) & ~zmii_mode_mask(dev->mode, input));"
                }
            }
        },
        "function_code": "void zmii_detach(struct platform_device *ofdev, int input)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\n\tBUG_ON(!dev || dev->users == 0);\n\n\tmutex_lock(&dev->lock);\n\n\tZMII_DBG(dev, \"detach(%d)\" NL, input);\n\n\t/* Disable this input */\n\tout_be32(&dev->base->fer,\n\t\t in_be32(&dev->base->fer) & ~zmii_mode_mask(dev->mode, input));\n\n\t--dev->users;\n\n\tmutex_unlock(&dev->lock);\n}"
    },
    {
        "var_name": "dev",
        "function_name": "zmii_detach",
        "location": {
            "file_path": "drivers/net/ethernet/ibm/emac/zmii.c",
            "region": {
                "startLine": 207,
                "startColumn": 4,
                "endColumn": 7
            },
            "context": {
                "startLine": 205,
                "endLine": 209,
                "snippet": {
                    "text": "--dev->users;"
                }
            }
        },
        "function_code": "void zmii_detach(struct platform_device *ofdev, int input)\n{\n\tstruct zmii_instance *dev = platform_get_drvdata(ofdev);\n\n\tBUG_ON(!dev || dev->users == 0);\n\n\tmutex_lock(&dev->lock);\n\n\tZMII_DBG(dev, \"detach(%d)\" NL, input);\n\n\t/* Disable this input */\n\tout_be32(&dev->base->fer,\n\t\t in_be32(&dev->base->fer) & ~zmii_mode_mask(dev->mode, input));\n\n\t--dev->users;\n\n\tmutex_unlock(&dev->lock);\n}"
    },
    {
        "var_name": "rule",
        "function_name": "i40e_get_ethtool_fdir_entry",
        "location": {
            "file_path": "drivers/net/ethernet/intel/i40e/i40e_ethtool.c",
            "region": {
                "startLine": 3378,
                "startColumn": 24,
                "endColumn": 28
            },
            "context": {
                "startLine": 3376,
                "endLine": 3380,
                "snippet": {
                    "text": "if (fsp->location <= rule->fd_id)"
                }
            }
        },
        "function_code": "static int i40e_get_ethtool_fdir_entry(struct i40e_pf *pf,\n\t\t\t\t       struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct i40e_rx_flow_userdef userdef = {0};\n\tstruct i40e_fdir_filter *rule = NULL;\n\tstruct hlist_node *node2;\n\tu64 input_set;\n\tu16 index;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\tif (fsp->location <= rule->fd_id)\n\t\t\tbreak;\n\t}\n\n\tif (!rule || fsp->location != rule->fd_id)\n\t\treturn -EINVAL;\n\n\tfsp->flow_type = rule->flow_type;\n\tif (fsp->flow_type == IP_USER_FLOW) {\n\t\tfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\n\t\tfsp->h_u.usr_ip4_spec.proto = 0;\n\t\tfsp->m_u.usr_ip4_spec.proto = 0;\n\t}\n\n\tif (fsp->flow_type == IPV6_USER_FLOW ||\n\t    fsp->flow_type == UDP_V6_FLOW ||\n\t    fsp->flow_type == TCP_V6_FLOW ||\n\t    fsp->flow_type == SCTP_V6_FLOW) {\n\t\t/* Reverse the src and dest notion, since the HW views them\n\t\t * from Tx perspective where as the user expects it from\n\t\t * Rx filter view.\n\t\t */\n\t\tfsp->h_u.tcp_ip6_spec.psrc = rule->dst_port;\n\t\tfsp->h_u.tcp_ip6_spec.pdst = rule->src_port;\n\t\tmemcpy(fsp->h_u.tcp_ip6_spec.ip6dst, rule->src_ip6,\n\t\t       sizeof(__be32) * 4);\n\t\tmemcpy(fsp->h_u.tcp_ip6_spec.ip6src, rule->dst_ip6,\n\t\t       sizeof(__be32) * 4);\n\t} else {\n\t\t/* Reverse the src and dest notion, since the HW views them\n\t\t * from Tx perspective where as the user expects it from\n\t\t * Rx filter view.\n\t\t */\n\t\tfsp->h_u.tcp_ip4_spec.psrc = rule->dst_port;\n\t\tfsp->h_u.tcp_ip4_spec.pdst = rule->src_port;\n\t\tfsp->h_u.tcp_ip4_spec.ip4src = rule->dst_ip;\n\t\tfsp->h_u.tcp_ip4_spec.ip4dst = rule->src_ip;\n\t}\n\n\tswitch (rule->flow_type) {\n\tcase SCTP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_SCTP;\n\t\tbreak;\n\tcase TCP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_TCP;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_UDP;\n\t\tbreak;\n\tcase SCTP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_SCTP;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_TCP;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_UDP;\n\t\tbreak;\n\tcase IP_USER_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV4_OTHER;\n\t\tbreak;\n\tcase IPV6_USER_FLOW:\n\t\tindex = I40E_FILTER_PCTYPE_NONF_IPV6_OTHER;\n\t\tbreak;\n\tdefault:\n\t\t/* If we have stored a filter with a flow type not listed here\n\t\t * it is almost certainly a driver bug. WARN(), and then\n\t\t * assign the input_set as if all fields are enabled to avoid\n\t\t * reading unassigned memory.\n\t\t */\n\t\tWARN(1, \"Missing input set index for flow_type %d\\n\",\n\t\t     rule->flow_type);\n\t\tinput_set = 0xFFFFFFFFFFFFFFFFULL;\n\t\tgoto no_input_set;\n\t}\n\n\tinput_set = i40e_read_fd_input_set(pf, index);\n\nno_input_set:\n\tif (input_set & I40E_L3_V6_SRC_MASK) {\n\t\tfsp->m_u.tcp_ip6_spec.ip6src[0] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6src[1] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6src[2] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6src[3] = htonl(0xFFFFFFFF);\n\t}\n\n\tif (input_set & I40E_L3_V6_DST_MASK) {\n\t\tfsp->m_u.tcp_ip6_spec.ip6dst[0] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6dst[1] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6dst[2] = htonl(0xFFFFFFFF);\n\t\tfsp->m_u.tcp_ip6_spec.ip6dst[3] = htonl(0xFFFFFFFF);\n\t}\n\n\tif (input_set & I40E_L3_SRC_MASK)\n\t\tfsp->m_u.tcp_ip4_spec.ip4src = htonl(0xFFFFFFFF);\n\n\tif (input_set & I40E_L3_DST_MASK)\n\t\tfsp->m_u.tcp_ip4_spec.ip4dst = htonl(0xFFFFFFFF);\n\n\tif (input_set & I40E_L4_SRC_MASK)\n\t\tfsp->m_u.tcp_ip4_spec.psrc = htons(0xFFFF);\n\n\tif (input_set & I40E_L4_DST_MASK)\n\t\tfsp->m_u.tcp_ip4_spec.pdst = htons(0xFFFF);\n\n\tif (rule->dest_ctl == I40E_FILTER_PROGRAM_DESC_DEST_DROP_PACKET)\n\t\tfsp->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\tfsp->ring_cookie = rule->q_index;\n\n\tif (rule->vlan_tag) {\n\t\tfsp->h_ext.vlan_etype = rule->vlan_etype;\n\t\tfsp->m_ext.vlan_etype = htons(0xFFFF);\n\t\tfsp->h_ext.vlan_tci = rule->vlan_tag;\n\t\tfsp->m_ext.vlan_tci = htons(0xFFFF);\n\t\tfsp->flow_type |= FLOW_EXT;\n\t}\n\n\tif (rule->dest_vsi != pf->vsi[pf->lan_vsi]->id) {\n\t\tstruct i40e_vsi *vsi;\n\n\t\tvsi = i40e_find_vsi_from_id(pf, rule->dest_vsi);\n\t\tif (vsi && vsi->type == I40E_VSI_SRIOV) {\n\t\t\t/* VFs are zero-indexed by the driver, but ethtool\n\t\t\t * expects them to be one-indexed, so add one here\n\t\t\t */\n\t\t\tu64 ring_vf = vsi->vf_id + 1;\n\n\t\t\tring_vf <<= ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF;\n\t\t\tfsp->ring_cookie |= ring_vf;\n\t\t}\n\t}\n\n\tif (rule->flex_filter) {\n\t\tuserdef.flex_filter = true;\n\t\tuserdef.flex_word = be16_to_cpu(rule->flex_word);\n\t\tuserdef.flex_offset = rule->flex_offset;\n\t}\n\n\ti40e_fill_rx_flow_user_data(fsp, &userdef);\n\n\treturn 0;\n}"
    },
    {
        "var_name": "rule",
        "function_name": "i40e_update_ethtool_fdir_entry",
        "location": {
            "file_path": "drivers/net/ethernet/intel/i40e/i40e_ethtool.c",
            "region": {
                "startLine": 3767,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 3765,
                "endLine": 3769,
                "snippet": {
                    "text": "if (rule->fd_id >= sw_idx)"
                }
            }
        },
        "function_code": "static int i40e_update_ethtool_fdir_entry(struct i40e_vsi *vsi,\n\t\t\t\t\t  struct i40e_fdir_filter *input,\n\t\t\t\t\t  u16 sw_idx,\n\t\t\t\t\t  struct ethtool_rxnfc *cmd)\n{\n\tstruct i40e_fdir_filter *rule, *parent;\n\tstruct i40e_pf *pf = vsi->back;\n\tstruct hlist_node *node2;\n\tint err = -EINVAL;\n\n\tparent = NULL;\n\trule = NULL;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &pf->fdir_filter_list, fdir_node) {\n\t\t/* hash found, or no matching entry */\n\t\tif (rule->fd_id >= sw_idx)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\t/* if there is an old rule occupying our place remove it */\n\tif (rule && (rule->fd_id == sw_idx)) {\n\t\t/* Remove this rule, since we're either deleting it, or\n\t\t * replacing it.\n\t\t */\n\t\terr = i40e_add_del_fdir(vsi, rule, false);\n\t\thlist_del(&rule->fdir_node);\n\t\tkfree(rule);\n\t\tpf->fdir_pf_active_filters--;\n\t}\n\n\t/* If we weren't given an input, this is a delete, so just return the\n\t * error code indicating if there was an entry at the requested slot\n\t */\n\tif (!input)\n\t\treturn err;\n\n\t/* Otherwise, install the new rule as requested */\n\tINIT_HLIST_NODE(&input->fdir_node);\n\n\t/* add filter to the list */\n\tif (parent)\n\t\thlist_add_behind(&input->fdir_node, &parent->fdir_node);\n\telse\n\t\thlist_add_head(&input->fdir_node,\n\t\t\t       &pf->fdir_filter_list);\n\n\t/* update counts */\n\tpf->fdir_pf_active_filters++;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "entry",
        "function_name": "__i40e_reprogram_flex_pit",
        "location": {
            "file_path": "drivers/net/ethernet/intel/i40e/i40e_ethtool.c",
            "region": {
                "startLine": 4073,
                "startColumn": 17,
                "endColumn": 22
            },
            "context": {
                "startLine": 4071,
                "endLine": 4075,
                "snippet": {
                    "text": "u16 offset = entry->src_offset + j;"
                }
            }
        },
        "function_code": "static void __i40e_reprogram_flex_pit(struct i40e_pf *pf,\n\t\t\t\t      struct list_head *flex_pit_list,\n\t\t\t\t      int flex_pit_start)\n{\n\tstruct i40e_flex_pit *entry = NULL;\n\tu16 last_offset = 0;\n\tint i = 0, j = 0;\n\n\t/* First, loop over the list of flex PIT entries, and reprogram the\n\t * registers.\n\t */\n\tlist_for_each_entry(entry, flex_pit_list, list) {\n\t\t/* We have to be careful when programming values for the\n\t\t * largest SRC_OFFSET value. It is possible that adding\n\t\t * additional empty values at the end would overflow the space\n\t\t * for the SRC_OFFSET in the FLX_PIT register. To avoid this,\n\t\t * we check here and add the empty values prior to adding the\n\t\t * largest value.\n\t\t *\n\t\t * To determine this, we will use a loop from i+1 to 3, which\n\t\t * will determine whether the unused entries would have valid\n\t\t * SRC_OFFSET. Note that there cannot be extra entries past\n\t\t * this value, because the only valid values would have been\n\t\t * larger than I40E_MAX_FLEX_SRC_OFFSET, and thus would not\n\t\t * have been added to the list in the first place.\n\t\t */\n\t\tfor (j = i + 1; j < 3; j++) {\n\t\t\tu16 offset = entry->src_offset + j;\n\t\t\tint index = flex_pit_start + i;\n\t\t\tu32 value = I40E_FLEX_PREP_VAL(I40E_FLEX_DEST_UNUSED,\n\t\t\t\t\t\t       1,\n\t\t\t\t\t\t       offset - 3);\n\n\t\t\tif (offset > I40E_MAX_FLEX_SRC_OFFSET) {\n\t\t\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t\t\t  I40E_PRTQF_FLX_PIT(index),\n\t\t\t\t\t\t  value);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/* Now, we can program the actual value into the table */\n\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t  I40E_PRTQF_FLX_PIT(flex_pit_start + i),\n\t\t\t\t  I40E_FLEX_PREP_VAL(entry->pit_index + 50,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     entry->src_offset));\n\t\ti++;\n\t}\n\n\t/* In order to program the last entries in the table, we need to\n\t * determine the valid offset. If the list is empty, we'll just start\n\t * with 0. Otherwise, we'll start with the last item offset and add 1.\n\t * This ensures that all entries have valid sizes. If we don't do this\n\t * correctly, the hardware will disable flexible field parsing.\n\t */\n\tif (!list_empty(flex_pit_list))\n\t\tlast_offset = list_prev_entry(entry, list)->src_offset + 1;\n\n\tfor (; i < 3; i++, last_offset++) {\n\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t  I40E_PRTQF_FLX_PIT(flex_pit_start + i),\n\t\t\t\t  I40E_FLEX_PREP_VAL(I40E_FLEX_DEST_UNUSED,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     last_offset));\n\t}\n}"
    },
    {
        "var_name": "entry",
        "function_name": "__i40e_reprogram_flex_pit",
        "location": {
            "file_path": "drivers/net/ethernet/intel/i40e/i40e_ethtool.c",
            "region": {
                "startLine": 4090,
                "startColumn": 7,
                "endColumn": 12
            },
            "context": {
                "startLine": 4088,
                "endLine": 4092,
                "snippet": {
                    "text": "I40E_FLEX_PREP_VAL(entry->pit_index + 50,"
                }
            }
        },
        "function_code": "static void __i40e_reprogram_flex_pit(struct i40e_pf *pf,\n\t\t\t\t      struct list_head *flex_pit_list,\n\t\t\t\t      int flex_pit_start)\n{\n\tstruct i40e_flex_pit *entry = NULL;\n\tu16 last_offset = 0;\n\tint i = 0, j = 0;\n\n\t/* First, loop over the list of flex PIT entries, and reprogram the\n\t * registers.\n\t */\n\tlist_for_each_entry(entry, flex_pit_list, list) {\n\t\t/* We have to be careful when programming values for the\n\t\t * largest SRC_OFFSET value. It is possible that adding\n\t\t * additional empty values at the end would overflow the space\n\t\t * for the SRC_OFFSET in the FLX_PIT register. To avoid this,\n\t\t * we check here and add the empty values prior to adding the\n\t\t * largest value.\n\t\t *\n\t\t * To determine this, we will use a loop from i+1 to 3, which\n\t\t * will determine whether the unused entries would have valid\n\t\t * SRC_OFFSET. Note that there cannot be extra entries past\n\t\t * this value, because the only valid values would have been\n\t\t * larger than I40E_MAX_FLEX_SRC_OFFSET, and thus would not\n\t\t * have been added to the list in the first place.\n\t\t */\n\t\tfor (j = i + 1; j < 3; j++) {\n\t\t\tu16 offset = entry->src_offset + j;\n\t\t\tint index = flex_pit_start + i;\n\t\t\tu32 value = I40E_FLEX_PREP_VAL(I40E_FLEX_DEST_UNUSED,\n\t\t\t\t\t\t       1,\n\t\t\t\t\t\t       offset - 3);\n\n\t\t\tif (offset > I40E_MAX_FLEX_SRC_OFFSET) {\n\t\t\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t\t\t  I40E_PRTQF_FLX_PIT(index),\n\t\t\t\t\t\t  value);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\t/* Now, we can program the actual value into the table */\n\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t  I40E_PRTQF_FLX_PIT(flex_pit_start + i),\n\t\t\t\t  I40E_FLEX_PREP_VAL(entry->pit_index + 50,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     entry->src_offset));\n\t\ti++;\n\t}\n\n\t/* In order to program the last entries in the table, we need to\n\t * determine the valid offset. If the list is empty, we'll just start\n\t * with 0. Otherwise, we'll start with the last item offset and add 1.\n\t * This ensures that all entries have valid sizes. If we don't do this\n\t * correctly, the hardware will disable flexible field parsing.\n\t */\n\tif (!list_empty(flex_pit_list))\n\t\tlast_offset = list_prev_entry(entry, list)->src_offset + 1;\n\n\tfor (; i < 3; i++, last_offset++) {\n\t\ti40e_write_rx_ctl(&pf->hw,\n\t\t\t\t  I40E_PRTQF_FLX_PIT(flex_pit_start + i),\n\t\t\t\t  I40E_FLEX_PREP_VAL(I40E_FLEX_DEST_UNUSED,\n\t\t\t\t\t\t     1,\n\t\t\t\t\t\t     last_offset));\n\t}\n}"
    },
    {
        "var_name": "rule",
        "function_name": "igb_get_ethtool_nfc_entry",
        "location": {
            "file_path": "drivers/net/ethernet/intel/igb/igb_ethtool.c",
            "region": {
                "startLine": 2446,
                "startColumn": 24,
                "endColumn": 28
            },
            "context": {
                "startLine": 2444,
                "endLine": 2448,
                "snippet": {
                    "text": "if (fsp->location <= rule->sw_idx)"
                }
            }
        },
        "function_code": "static int igb_get_ethtool_nfc_entry(struct igb_adapter *adapter,\n\t\t\t\t     struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp = &cmd->fs;\n\tstruct igb_nfc_filter *rule = NULL;\n\n\t/* report total rule count */\n\tcmd->data = IGB_MAX_RXNFC_FILTERS;\n\n\thlist_for_each_entry(rule, &adapter->nfc_filter_list, nfc_node) {\n\t\tif (fsp->location <= rule->sw_idx)\n\t\t\tbreak;\n\t}\n\n\tif (!rule || fsp->location != rule->sw_idx)\n\t\treturn -EINVAL;\n\n\tif (rule->filter.match_flags) {\n\t\tfsp->flow_type = ETHER_FLOW;\n\t\tfsp->ring_cookie = rule->action;\n\t\tif (rule->filter.match_flags & IGB_FILTER_FLAG_ETHER_TYPE) {\n\t\t\tfsp->h_u.ether_spec.h_proto = rule->filter.etype;\n\t\t\tfsp->m_u.ether_spec.h_proto = ETHER_TYPE_FULL_MASK;\n\t\t}\n\t\tif (rule->filter.match_flags & IGB_FILTER_FLAG_VLAN_TCI) {\n\t\t\tfsp->flow_type |= FLOW_EXT;\n\t\t\tfsp->h_ext.vlan_tci = rule->filter.vlan_tci;\n\t\t\tfsp->m_ext.vlan_tci = htons(VLAN_PRIO_MASK);\n\t\t}\n\t\tif (rule->filter.match_flags & IGB_FILTER_FLAG_DST_MAC_ADDR) {\n\t\t\tether_addr_copy(fsp->h_u.ether_spec.h_dest,\n\t\t\t\t\trule->filter.dst_addr);\n\t\t\t/* As we only support matching by the full\n\t\t\t * mask, return the mask to userspace\n\t\t\t */\n\t\t\teth_broadcast_addr(fsp->m_u.ether_spec.h_dest);\n\t\t}\n\t\tif (rule->filter.match_flags & IGB_FILTER_FLAG_SRC_MAC_ADDR) {\n\t\t\tether_addr_copy(fsp->h_u.ether_spec.h_source,\n\t\t\t\t\trule->filter.src_addr);\n\t\t\t/* As we only support matching by the full\n\t\t\t * mask, return the mask to userspace\n\t\t\t */\n\t\t\teth_broadcast_addr(fsp->m_u.ether_spec.h_source);\n\t\t}\n\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}"
    },
    {
        "var_name": "rule",
        "function_name": "igb_update_ethtool_nfc_entry",
        "location": {
            "file_path": "drivers/net/ethernet/intel/igb/igb_ethtool.c",
            "region": {
                "startLine": 2861,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 2859,
                "endLine": 2863,
                "snippet": {
                    "text": "if (rule->sw_idx >= sw_idx)"
                }
            }
        },
        "function_code": "static int igb_update_ethtool_nfc_entry(struct igb_adapter *adapter,\n\t\t\t\t\tstruct igb_nfc_filter *input,\n\t\t\t\t\tu16 sw_idx)\n{\n\tstruct igb_nfc_filter *rule, *parent;\n\tint err = -EINVAL;\n\n\tparent = NULL;\n\trule = NULL;\n\n\thlist_for_each_entry(rule, &adapter->nfc_filter_list, nfc_node) {\n\t\t/* hash found, or no matching entry */\n\t\tif (rule->sw_idx >= sw_idx)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\t/* if there is an old rule occupying our place remove it */\n\tif (rule && (rule->sw_idx == sw_idx)) {\n\t\tif (!input)\n\t\t\terr = igb_erase_filter(adapter, rule);\n\n\t\thlist_del(&rule->nfc_node);\n\t\tkfree(rule);\n\t\tadapter->nfc_filter_count--;\n\t}\n\n\t/* If no input this was a delete, err should be 0 if a rule was\n\t * successfully found and removed from the list else -EINVAL\n\t */\n\tif (!input)\n\t\treturn err;\n\n\t/* initialize node */\n\tINIT_HLIST_NODE(&input->nfc_node);\n\n\t/* add filter to the list */\n\tif (parent)\n\t\thlist_add_behind(&input->nfc_node, &parent->nfc_node);\n\telse\n\t\thlist_add_head(&input->nfc_node, &adapter->nfc_filter_list);\n\n\t/* update counts */\n\tadapter->nfc_filter_count++;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "filter",
        "function_name": "igb_delete_clsflower",
        "location": {
            "file_path": "drivers/net/ethernet/intel/igb/igb_main.c",
            "region": {
                "startLine": 2762,
                "startColumn": 7,
                "endColumn": 13
            },
            "context": {
                "startLine": 2760,
                "endLine": 2764,
                "snippet": {
                    "text": "if (filter->cookie == cls_flower->cookie)"
                }
            }
        },
        "function_code": "static int igb_delete_clsflower(struct igb_adapter *adapter,\n\t\t\t\tstruct flow_cls_offload *cls_flower)\n{\n\tstruct igb_nfc_filter *filter;\n\tint err;\n\n\tspin_lock(&adapter->nfc_lock);\n\n\thlist_for_each_entry(filter, &adapter->cls_flower_list, nfc_node)\n\t\tif (filter->cookie == cls_flower->cookie)\n\t\t\tbreak;\n\n\tif (!filter) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\terr = igb_erase_filter(adapter, filter);\n\tif (err < 0)\n\t\tgoto out;\n\n\thlist_del(&filter->nfc_node);\n\tkfree(filter);\n\nout:\n\tspin_unlock(&adapter->nfc_lock);\n\n\treturn err;\n}"
    },
    {
        "var_name": "rule",
        "function_name": "ixgbe_get_ethtool_fdir_entry",
        "location": {
            "file_path": "drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c",
            "region": {
                "startLine": 2548,
                "startColumn": 24,
                "endColumn": 28
            },
            "context": {
                "startLine": 2546,
                "endLine": 2550,
                "snippet": {
                    "text": "if (fsp->location <= rule->sw_idx)"
                }
            }
        },
        "function_code": "static int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\n\t\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tunion ixgbe_atr_input *mask = &adapter->fdir_mask;\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct hlist_node *node2;\n\tstruct ixgbe_fdir_filter *rule = NULL;\n\n\t/* report total rule count */\n\tcmd->data = (1024 << adapter->fdir_pballoc) - 2;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &adapter->fdir_filter_list, fdir_node) {\n\t\tif (fsp->location <= rule->sw_idx)\n\t\t\tbreak;\n\t}\n\n\tif (!rule || fsp->location != rule->sw_idx)\n\t\treturn -EINVAL;\n\n\t/* fill out the flow spec entry */\n\n\t/* set flow type field */\n\tswitch (rule->filter.formatted.flow_type) {\n\tcase IXGBE_ATR_FLOW_TYPE_TCPV4:\n\t\tfsp->flow_type = TCP_V4_FLOW;\n\t\tbreak;\n\tcase IXGBE_ATR_FLOW_TYPE_UDPV4:\n\t\tfsp->flow_type = UDP_V4_FLOW;\n\t\tbreak;\n\tcase IXGBE_ATR_FLOW_TYPE_SCTPV4:\n\t\tfsp->flow_type = SCTP_V4_FLOW;\n\t\tbreak;\n\tcase IXGBE_ATR_FLOW_TYPE_IPV4:\n\t\tfsp->flow_type = IP_USER_FLOW;\n\t\tfsp->h_u.usr_ip4_spec.ip_ver = ETH_RX_NFC_IP4;\n\t\tfsp->h_u.usr_ip4_spec.proto = 0;\n\t\tfsp->m_u.usr_ip4_spec.proto = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfsp->h_u.tcp_ip4_spec.psrc = rule->filter.formatted.src_port;\n\tfsp->m_u.tcp_ip4_spec.psrc = mask->formatted.src_port;\n\tfsp->h_u.tcp_ip4_spec.pdst = rule->filter.formatted.dst_port;\n\tfsp->m_u.tcp_ip4_spec.pdst = mask->formatted.dst_port;\n\tfsp->h_u.tcp_ip4_spec.ip4src = rule->filter.formatted.src_ip[0];\n\tfsp->m_u.tcp_ip4_spec.ip4src = mask->formatted.src_ip[0];\n\tfsp->h_u.tcp_ip4_spec.ip4dst = rule->filter.formatted.dst_ip[0];\n\tfsp->m_u.tcp_ip4_spec.ip4dst = mask->formatted.dst_ip[0];\n\tfsp->h_ext.vlan_tci = rule->filter.formatted.vlan_id;\n\tfsp->m_ext.vlan_tci = mask->formatted.vlan_id;\n\tfsp->h_ext.vlan_etype = rule->filter.formatted.flex_bytes;\n\tfsp->m_ext.vlan_etype = mask->formatted.flex_bytes;\n\tfsp->h_ext.data[1] = htonl(rule->filter.formatted.vm_pool);\n\tfsp->m_ext.data[1] = htonl(mask->formatted.vm_pool);\n\tfsp->flow_type |= FLOW_EXT;\n\n\t/* record action */\n\tif (rule->action == IXGBE_FDIR_DROP_QUEUE)\n\t\tfsp->ring_cookie = RX_CLS_FLOW_DISC;\n\telse\n\t\tfsp->ring_cookie = rule->action;\n\n\treturn 0;\n}"
    },
    {
        "var_name": "rule",
        "function_name": "ixgbe_update_ethtool_fdir_entry",
        "location": {
            "file_path": "drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c",
            "region": {
                "startLine": 2724,
                "startColumn": 7,
                "endColumn": 11
            },
            "context": {
                "startLine": 2722,
                "endLine": 2726,
                "snippet": {
                    "text": "if (rule->sw_idx >= sw_idx)"
                }
            }
        },
        "function_code": "int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,\n\t\t\t\t    struct ixgbe_fdir_filter *input,\n\t\t\t\t    u16 sw_idx)\n{\n\tstruct ixgbe_hw *hw = &adapter->hw;\n\tstruct hlist_node *node2;\n\tstruct ixgbe_fdir_filter *rule, *parent;\n\tint err = -EINVAL;\n\n\tparent = NULL;\n\trule = NULL;\n\n\thlist_for_each_entry_safe(rule, node2,\n\t\t\t\t  &adapter->fdir_filter_list, fdir_node) {\n\t\t/* hash found, or no matching entry */\n\t\tif (rule->sw_idx >= sw_idx)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\t/* if there is an old rule occupying our place remove it */\n\tif (rule && (rule->sw_idx == sw_idx)) {\n\t\tif (!input || (rule->filter.formatted.bkt_hash !=\n\t\t\t       input->filter.formatted.bkt_hash)) {\n\t\t\terr = ixgbe_fdir_erase_perfect_filter_82599(hw,\n\t\t\t\t\t\t\t\t&rule->filter,\n\t\t\t\t\t\t\t\tsw_idx);\n\t\t}\n\n\t\thlist_del(&rule->fdir_node);\n\t\tkfree(rule);\n\t\tadapter->fdir_filter_count--;\n\t}\n\n\t/*\n\t * If no input this was a delete, err should be 0 if a rule was\n\t * successfully found and removed from the list else -EINVAL\n\t */\n\tif (!input)\n\t\treturn err;\n\n\t/* initialize node and set software index */\n\tINIT_HLIST_NODE(&input->fdir_node);\n\n\t/* add filter to the list */\n\tif (parent)\n\t\thlist_add_behind(&input->fdir_node, &parent->fdir_node);\n\telse\n\t\thlist_add_head(&input->fdir_node,\n\t\t\t       &adapter->fdir_filter_list);\n\n\t/* update counts */\n\tadapter->fdir_filter_count++;\n\n\treturn 0;\n}"
    },
    {
        "var_name": null,
        "function_name": "vgic_put_irq",
        "location": {
            "file_path": "arch/arm64/kvm/vgic/vgic.c",
            "region": {
                "startLine": 119,
                "startColumn": 6,
                "endColumn": 6
            },
            "context": {
                "startLine": 117,
                "endLine": 121,
                "snippet": {
                    "text": "if (irq->intid < VGIC_MIN_LPI)"
                }
            }
        },
        "function_code": "void vgic_put_irq(struct kvm *kvm, struct vgic_irq *irq)\n{\n\tstruct vgic_dist *dist = &kvm->arch.vgic;\n\tunsigned long flags;\n\n\tif (irq->intid < VGIC_MIN_LPI)\n\t\treturn;\n\n\tif (!kref_put(&irq->refcount, vgic_irq_release))\n\t\treturn;\n\n\txa_lock_irqsave(&dist->lpi_xa, flags);\n\t__xa_erase(&dist->lpi_xa, irq->intid);\n\txa_unlock_irqrestore(&dist->lpi_xa, flags);\n\n\tatomic_dec(&dist->lpi_count);\n\tkfree_rcu(irq, rcu);\n}"
    },
    {
        "var_name": null,
        "function_name": "kvm_vgic_unmap_irq",
        "location": {
            "file_path": "arch/arm64/kvm/vgic/vgic.c",
            "region": {
                "startLine": 491,
                "startColumn": 2,
                "endColumn": 2
            },
            "context": {
                "startLine": 489,
                "endLine": 493,
                "snippet": {
                    "text": "irq->hw = false;"
                }
            }
        },
        "function_code": "static inline void kvm_vgic_unmap_irq(struct vgic_irq *irq)\n{\n\tirq->hw = false;\n\tirq->hwintid = 0;\n\tirq->ops = NULL;\n}"
    },
    {
        "var_name": null,
        "function_name": "show_stacktrace",
        "location": {
            "file_path": "arch/loongarch/kernel/traps.c",
            "region": {
                "startLine": 107,
                "startColumn": 39,
                "endColumn": 39
            },
            "context": {
                "startLine": 105,
                "endLine": 109,
                "snippet": {
                    "text": "unsigned long *sp = (unsigned long *)regs->regs[3];"
                }
            }
        },
        "function_code": "static void show_stacktrace(struct task_struct *task,\n\tconst struct pt_regs *regs, const char *loglvl, bool user)\n{\n\tint i;\n\tconst int field = 2 * sizeof(unsigned long);\n\tunsigned long stackdata;\n\tunsigned long *sp = (unsigned long *)regs->regs[3];\n\n\tprintk(\"%sStack :\", loglvl);\n\ti = 0;\n\twhile ((unsigned long) sp & (PAGE_SIZE - 1)) {\n\t\tif (i && ((i % (64 / field)) == 0)) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tprintk(\"%s       \", loglvl);\n\t\t}\n\t\tif (i > 39) {\n\t\t\tpr_cont(\" ...\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (__get_addr(&stackdata, sp++, user)) {\n\t\t\tpr_cont(\" (Bad stack address)\");\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_cont(\" %0*lx\", field, stackdata);\n\t\ti++;\n\t}\n\tpr_cont(\"\\n\");\n\tshow_backtrace(task, regs, loglvl, user);\n}"
    },
    {
        "var_name": null,
        "function_name": "__show_regs",
        "location": {
            "file_path": "arch/loongarch/kernel/traps.c",
            "region": {
                "startLine": 329,
                "startColumn": 50,
                "endColumn": 50
            },
            "context": {
                "startLine": 327,
                "endLine": 331,
                "snippet": {
                    "text": "unsigned int exccode = FIELD_GET(CSR_ESTAT_EXC, regs->csr_estat);"
                }
            }
        },
        "function_code": "static void __show_regs(const struct pt_regs *regs)\n{\n\tconst int field = 2 * sizeof(unsigned long);\n\tunsigned int exccode = FIELD_GET(CSR_ESTAT_EXC, regs->csr_estat);\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\t/* Print saved GPRs except $zero (substituting with PC/ERA) */\n#define GPR_FIELD(x) field, regs->regs[x]\n\tprintk(\"pc %0*lx ra %0*lx tp %0*lx sp %0*lx\\n\",\n\t       field, regs->csr_era, GPR_FIELD(1), GPR_FIELD(2), GPR_FIELD(3));\n\tprintk(\"a0 %0*lx a1 %0*lx a2 %0*lx a3 %0*lx\\n\",\n\t       GPR_FIELD(4), GPR_FIELD(5), GPR_FIELD(6), GPR_FIELD(7));\n\tprintk(\"a4 %0*lx a5 %0*lx a6 %0*lx a7 %0*lx\\n\",\n\t       GPR_FIELD(8), GPR_FIELD(9), GPR_FIELD(10), GPR_FIELD(11));\n\tprintk(\"t0 %0*lx t1 %0*lx t2 %0*lx t3 %0*lx\\n\",\n\t       GPR_FIELD(12), GPR_FIELD(13), GPR_FIELD(14), GPR_FIELD(15));\n\tprintk(\"t4 %0*lx t5 %0*lx t6 %0*lx t7 %0*lx\\n\",\n\t       GPR_FIELD(16), GPR_FIELD(17), GPR_FIELD(18), GPR_FIELD(19));\n\tprintk(\"t8 %0*lx u0 %0*lx s9 %0*lx s0 %0*lx\\n\",\n\t       GPR_FIELD(20), GPR_FIELD(21), GPR_FIELD(22), GPR_FIELD(23));\n\tprintk(\"s1 %0*lx s2 %0*lx s3 %0*lx s4 %0*lx\\n\",\n\t       GPR_FIELD(24), GPR_FIELD(25), GPR_FIELD(26), GPR_FIELD(27));\n\tprintk(\"s5 %0*lx s6 %0*lx s7 %0*lx s8 %0*lx\\n\",\n\t       GPR_FIELD(28), GPR_FIELD(29), GPR_FIELD(30), GPR_FIELD(31));\n\n\t/* The slot for $zero is reused as the syscall restart flag */\n\tif (regs->regs[0])\n\t\tprintk(\"syscall restart flag: %0*lx\\n\", GPR_FIELD(0));\n\n\tif (user_mode(regs)) {\n\t\tprintk(\"   ra: %0*lx\\n\", GPR_FIELD(1));\n\t\tprintk(\"  ERA: %0*lx\\n\", field, regs->csr_era);\n\t} else {\n\t\tprintk(\"   ra: %0*lx %pS\\n\", GPR_FIELD(1), (void *) regs->regs[1]);\n\t\tprintk(\"  ERA: %0*lx %pS\\n\", field, regs->csr_era, (void *) regs->csr_era);\n\t}\n#undef GPR_FIELD\n\n\t/* Print saved important CSRs */\n\tprint_crmd(regs->csr_crmd);\n\tprint_prmd(regs->csr_prmd);\n\tprint_euen(regs->csr_euen);\n\tprint_ecfg(regs->csr_ecfg);\n\tprint_estat(regs->csr_estat);\n\n\tif (exccode >= EXCCODE_TLBL && exccode <= EXCCODE_ALE)\n\t\tprintk(\" BADV: %0*lx\\n\", field, regs->csr_badvaddr);\n\n\tprintk(\" PRID: %08x (%s, %s)\\n\", read_cpucfg(LOONGARCH_CPUCFG0),\n\t       cpu_family_string(), cpu_full_name_string());\n}"
    },
    {
        "var_name": null,
        "function_name": "show_backtrace",
        "location": {
            "file_path": "arch/mips/kernel/traps.c",
            "region": {
                "startLine": 154,
                "startColumn": 21,
                "endColumn": 21
            },
            "context": {
                "startLine": 152,
                "endLine": 156,
                "snippet": {
                    "text": "unsigned long sp = regs->regs[29];"
                }
            }
        },
        "function_code": "static void show_backtrace(struct task_struct *task, const struct pt_regs *regs,\n\t\t\t   const char *loglvl, bool user)\n{\n\tunsigned long sp = regs->regs[29];\n\tunsigned long ra = regs->regs[31];\n\tunsigned long pc = regs->cp0_epc;\n\n\tif (!task)\n\t\ttask = current;\n\n\tif (raw_show_trace || user_mode(regs) || !__kernel_text_address(pc)) {\n\t\tshow_raw_backtrace(sp, loglvl, user);\n\t\treturn;\n\t}\n\tprintk(\"%sCall Trace:\\n\", loglvl);\n\tdo {\n\t\tprint_ip_sym(loglvl, pc);\n\t\tpc = unwind_stack(task, &sp, pc, &ra);\n\t} while (pc);\n\tpr_cont(\"\\n\");\n}"
    },
    {
        "var_name": null,
        "function_name": "show_stacktrace",
        "location": {
            "file_path": "arch/mips/kernel/traps.c",
            "region": {
                "startLine": 183,
                "startColumn": 39,
                "endColumn": 39
            },
            "context": {
                "startLine": 181,
                "endLine": 185,
                "snippet": {
                    "text": "unsigned long *sp = (unsigned long *)regs->regs[29];"
                }
            }
        },
        "function_code": "static void show_stacktrace(struct task_struct *task,\n\tconst struct pt_regs *regs, const char *loglvl, bool user)\n{\n\tconst int field = 2 * sizeof(unsigned long);\n\tunsigned long stackdata;\n\tint i;\n\tunsigned long *sp = (unsigned long *)regs->regs[29];\n\n\tprintk(\"%sStack :\", loglvl);\n\ti = 0;\n\twhile ((unsigned long) sp & (PAGE_SIZE - 1)) {\n\t\tif (i && ((i % (64 / field)) == 0)) {\n\t\t\tpr_cont(\"\\n\");\n\t\t\tprintk(\"%s       \", loglvl);\n\t\t}\n\t\tif (i > 39) {\n\t\t\tpr_cont(\" ...\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (__get_addr(&stackdata, sp++, user)) {\n\t\t\tpr_cont(\" (Bad stack address)\");\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_cont(\" %0*lx\", field, stackdata);\n\t\ti++;\n\t}\n\tpr_cont(\"\\n\");\n\tshow_backtrace(task, regs, loglvl, user);\n}"
    },
    {
        "var_name": null,
        "function_name": "__show_regs",
        "location": {
            "file_path": "arch/mips/kernel/traps.c",
            "region": {
                "startLine": 267,
                "startColumn": 23,
                "endColumn": 23
            },
            "context": {
                "startLine": 265,
                "endLine": 269,
                "snippet": {
                    "text": "unsigned int cause = regs->cp0_cause;"
                }
            }
        },
        "function_code": "static void __show_regs(const struct pt_regs *regs)\n{\n\tconst int field = 2 * sizeof(unsigned long);\n\tunsigned int cause = regs->cp0_cause;\n\tunsigned int exccode;\n\tint i;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\t/*\n\t * Saved main processor registers\n\t */\n\tfor (i = 0; i < 32; ) {\n\t\tif ((i % 4) == 0)\n\t\t\tprintk(\"$%2d   :\", i);\n\t\tif (i == 0)\n\t\t\tpr_cont(\" %0*lx\", field, 0UL);\n\t\telse if (i == 26 || i == 27)\n\t\t\tpr_cont(\" %*s\", field, \"\");\n\t\telse\n\t\t\tpr_cont(\" %0*lx\", field, regs->regs[i]);\n\n\t\ti++;\n\t\tif ((i % 4) == 0)\n\t\t\tpr_cont(\"\\n\");\n\t}\n\n#ifdef CONFIG_CPU_HAS_SMARTMIPS\n\tprintk(\"Acx    : %0*lx\\n\", field, regs->acx);\n#endif\n\tif (MIPS_ISA_REV < 6) {\n\t\tprintk(\"Hi    : %0*lx\\n\", field, regs->hi);\n\t\tprintk(\"Lo    : %0*lx\\n\", field, regs->lo);\n\t}\n\n\t/*\n\t * Saved cp0 registers\n\t */\n\tprintk(\"epc   : %0*lx %pS\\n\", field, regs->cp0_epc,\n\t       (void *) regs->cp0_epc);\n\tprintk(\"ra    : %0*lx %pS\\n\", field, regs->regs[31],\n\t       (void *) regs->regs[31]);\n\n\tprintk(\"Status: %08x\t\", (uint32_t) regs->cp0_status);\n\n\tif (cpu_has_3kex) {\n\t\tif (regs->cp0_status & ST0_KUO)\n\t\t\tpr_cont(\"KUo \");\n\t\tif (regs->cp0_status & ST0_IEO)\n\t\t\tpr_cont(\"IEo \");\n\t\tif (regs->cp0_status & ST0_KUP)\n\t\t\tpr_cont(\"KUp \");\n\t\tif (regs->cp0_status & ST0_IEP)\n\t\t\tpr_cont(\"IEp \");\n\t\tif (regs->cp0_status & ST0_KUC)\n\t\t\tpr_cont(\"KUc \");\n\t\tif (regs->cp0_status & ST0_IEC)\n\t\t\tpr_cont(\"IEc \");\n\t} else if (cpu_has_4kex) {\n\t\tif (regs->cp0_status & ST0_KX)\n\t\t\tpr_cont(\"KX \");\n\t\tif (regs->cp0_status & ST0_SX)\n\t\t\tpr_cont(\"SX \");\n\t\tif (regs->cp0_status & ST0_UX)\n\t\t\tpr_cont(\"UX \");\n\t\tswitch (regs->cp0_status & ST0_KSU) {\n\t\tcase KSU_USER:\n\t\t\tpr_cont(\"USER \");\n\t\t\tbreak;\n\t\tcase KSU_SUPERVISOR:\n\t\t\tpr_cont(\"SUPERVISOR \");\n\t\t\tbreak;\n\t\tcase KSU_KERNEL:\n\t\t\tpr_cont(\"KERNEL \");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_cont(\"BAD_MODE \");\n\t\t\tbreak;\n\t\t}\n\t\tif (regs->cp0_status & ST0_ERL)\n\t\t\tpr_cont(\"ERL \");\n\t\tif (regs->cp0_status & ST0_EXL)\n\t\t\tpr_cont(\"EXL \");\n\t\tif (regs->cp0_status & ST0_IE)\n\t\t\tpr_cont(\"IE \");\n\t}\n\tpr_cont(\"\\n\");\n\n\texccode = (cause & CAUSEF_EXCCODE) >> CAUSEB_EXCCODE;\n\tprintk(\"Cause : %08x (ExcCode %02x)\\n\", cause, exccode);\n\n\tif (1 <= exccode && exccode <= 5)\n\t\tprintk(\"BadVA : %0*lx\\n\", field, regs->cp0_badvaddr);\n\n\tprintk(\"PrId  : %08x (%s)\\n\", read_c0_prid(),\n\t       cpu_name_string());\n}"
    },
    {
        "var_name": null,
        "function_name": "cell_iommu_setup_stab",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 308,
                "startColumn": 14,
                "endColumn": 14
            },
            "context": {
                "startLine": 306,
                "endLine": 310,
                "snippet": {
                    "text": "__func__, iommu->nid, segments);"
                }
            }
        },
        "function_code": "static void __init cell_iommu_setup_stab(struct cbe_iommu *iommu,\n\t\t\t\tunsigned long dbase, unsigned long dsize,\n\t\t\t\tunsigned long fbase, unsigned long fsize)\n{\n\tstruct page *page;\n\tunsigned long segments, stab_size;\n\n\tsegments = max(dbase + dsize, fbase + fsize) >> IO_SEGMENT_SHIFT;\n\n\tpr_debug(\"%s: iommu[%d]: segments: %lu\\n\",\n\t\t\t__func__, iommu->nid, segments);\n\n\t/* set up the segment table */\n\tstab_size = segments * sizeof(unsigned long);\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, get_order(stab_size));\n\tBUG_ON(!page);\n\tiommu->stab = page_address(page);\n\tmemset(iommu->stab, 0, stab_size);\n}"
    },
    {
        "var_name": null,
        "function_name": "cell_iommu_alloc_ptab",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 336,
                "startColumn": 4,
                "endColumn": 4
            },
            "context": {
                "startLine": 334,
                "endLine": 338,
                "snippet": {
                    "text": "iommu->nid, ptab_size, get_order(ptab_size));"
                }
            }
        },
        "function_code": "static unsigned long *__init cell_iommu_alloc_ptab(struct cbe_iommu *iommu,\n\t\tunsigned long base, unsigned long size, unsigned long gap_base,\n\t\tunsigned long gap_size, unsigned long page_shift)\n{\n\tstruct page *page;\n\tint i;\n\tunsigned long reg, segments, pages_per_segment, ptab_size,\n\t\t      n_pte_pages, start_seg, *ptab;\n\n\tstart_seg = base >> IO_SEGMENT_SHIFT;\n\tsegments  = size >> IO_SEGMENT_SHIFT;\n\tpages_per_segment = 1ull << IO_PAGENO_BITS(page_shift);\n\t/* PTEs for each segment must start on a 4K boundary */\n\tpages_per_segment = max(pages_per_segment,\n\t\t\t\t(1 << 12) / sizeof(unsigned long));\n\n\tptab_size = segments * pages_per_segment * sizeof(unsigned long);\n\tpr_debug(\"%s: iommu[%d]: ptab_size: %lu, order: %d\\n\", __func__,\n\t\t\tiommu->nid, ptab_size, get_order(ptab_size));\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, get_order(ptab_size));\n\tBUG_ON(!page);\n\n\tptab = page_address(page);\n\tmemset(ptab, 0, ptab_size);\n\n\t/* number of 4K pages needed for a page table */\n\tn_pte_pages = (pages_per_segment * sizeof(unsigned long)) >> 12;\n\n\tpr_debug(\"%s: iommu[%d]: stab at %p, ptab at %p, n_pte_pages: %lu\\n\",\n\t\t\t__func__, iommu->nid, iommu->stab, ptab,\n\t\t\tn_pte_pages);\n\n\t/* initialise the STEs */\n\treg = IOSTE_V | ((n_pte_pages - 1) << 5);\n\n\tswitch (page_shift) {\n\tcase 12: reg |= IOSTE_PS_4K;  break;\n\tcase 16: reg |= IOSTE_PS_64K; break;\n\tcase 20: reg |= IOSTE_PS_1M;  break;\n\tcase 24: reg |= IOSTE_PS_16M; break;\n\tdefault: BUG();\n\t}\n\n\tgap_base = gap_base >> IO_SEGMENT_SHIFT;\n\tgap_size = gap_size >> IO_SEGMENT_SHIFT;\n\n\tpr_debug(\"Setting up IOMMU stab:\\n\");\n\tfor (i = start_seg; i < (start_seg + segments); i++) {\n\t\tif (i >= gap_base && i < (gap_base + gap_size)) {\n\t\t\tpr_debug(\"\\toverlap at %d, skipping\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tiommu->stab[i] = reg | (__pa(ptab) + (n_pte_pages << 12) *\n\t\t\t\t\t(i - start_seg));\n\t\tpr_debug(\"\\t[%d] 0x%016lx\\n\", i, iommu->stab[i]);\n\t}\n\n\treturn ptab;\n}"
    },
    {
        "var_name": null,
        "function_name": "cell_iommu_enable_hardware",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 384,
                "startColumn": 26,
                "endColumn": 26
            },
            "context": {
                "startLine": 382,
                "endLine": 386,
                "snippet": {
                    "text": "if (cell_iommu_find_ioc(iommu->nid, &xlate_base))"
                }
            }
        },
        "function_code": "static void __init cell_iommu_enable_hardware(struct cbe_iommu *iommu)\n{\n\tint ret;\n\tunsigned long reg, xlate_base;\n\tunsigned int virq;\n\n\tif (cell_iommu_find_ioc(iommu->nid, &xlate_base))\n\t\tpanic(\"%s: missing IOC register mappings for node %d\\n\",\n\t\t      __func__, iommu->nid);\n\n\tiommu->xlate_regs = ioremap(xlate_base, IOC_Reg_Size);\n\tiommu->cmd_regs = iommu->xlate_regs + IOC_IOCmd_Offset;\n\n\t/* ensure that the STEs have updated */\n\tmb();\n\n\t/* setup interrupts for the iommu. */\n\treg = in_be64(iommu->xlate_regs + IOC_IO_ExcpStat);\n\tout_be64(iommu->xlate_regs + IOC_IO_ExcpStat,\n\t\t\treg & ~IOC_IO_ExcpStat_V);\n\tout_be64(iommu->xlate_regs + IOC_IO_ExcpMask,\n\t\t\tIOC_IO_ExcpMask_PFE | IOC_IO_ExcpMask_SFE);\n\n\tvirq = irq_create_mapping(NULL,\n\t\t\tIIC_IRQ_IOEX_ATI | (iommu->nid << IIC_IRQ_NODE_SHIFT));\n\tBUG_ON(!virq);\n\n\tret = request_irq(virq, ioc_interrupt, 0, iommu->name, iommu);\n\tBUG_ON(ret);\n\n\t/* set the IOC segment table origin register (and turn on the iommu) */\n\treg = IOC_IOST_Origin_E | __pa(iommu->stab) | IOC_IOST_Origin_HW;\n\tout_be64(iommu->xlate_regs + IOC_IOST_Origin, reg);\n\tin_be64(iommu->xlate_regs + IOC_IOST_Origin);\n\n\t/* turn on IO translation */\n\treg = in_be64(iommu->cmd_regs + IOC_IOCmd_Cfg) | IOC_IOCmd_Cfg_TE;\n\tout_be64(iommu->cmd_regs + IOC_IOCmd_Cfg, reg);\n}"
    },
    {
        "var_name": null,
        "function_name": "cell_iommu_setup_window",
        "location": {
            "file_path": "arch/powerpc/platforms/cell/iommu.c",
            "region": {
                "startLine": 474,
                "startColumn": 53,
                "endColumn": 53
            },
            "context": {
                "startLine": 472,
                "endLine": 476,
                "snippet": {
                    "text": "window = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);"
                }
            }
        },
        "function_code": "static struct iommu_window * __init\ncell_iommu_setup_window(struct cbe_iommu *iommu, struct device_node *np,\n\t\t\tunsigned long offset, unsigned long size,\n\t\t\tunsigned long pte_offset)\n{\n\tstruct iommu_window *window;\n\tstruct page *page;\n\tu32 ioid;\n\n\tioid = cell_iommu_get_ioid(np);\n\n\twindow = kzalloc_node(sizeof(*window), GFP_KERNEL, iommu->nid);\n\tBUG_ON(window == NULL);\n\n\twindow->offset = offset;\n\twindow->size = size;\n\twindow->ioid = ioid;\n\twindow->iommu = iommu;\n\n\twindow->table.it_blocksize = 16;\n\twindow->table.it_base = (unsigned long)iommu->ptab;\n\twindow->table.it_index = iommu->nid;\n\twindow->table.it_page_shift = IOMMU_PAGE_SHIFT_4K;\n\twindow->table.it_offset =\n\t\t(offset >> window->table.it_page_shift) + pte_offset;\n\twindow->table.it_size = size >> window->table.it_page_shift;\n\twindow->table.it_ops = &cell_iommu_ops;\n\n\tif (!iommu_init_table(&window->table, iommu->nid, 0, 0))\n\t\tpanic(\"Failed to initialize iommu table\");\n\n\tpr_debug(\"\\tioid      %d\\n\", window->ioid);\n\tpr_debug(\"\\tblocksize %ld\\n\", window->table.it_blocksize);\n\tpr_debug(\"\\tbase      0x%016lx\\n\", window->table.it_base);\n\tpr_debug(\"\\toffset    0x%lx\\n\", window->table.it_offset);\n\tpr_debug(\"\\tsize      %ld\\n\", window->table.it_size);\n\n\tlist_add(&window->list, &iommu->windows);\n\n\tif (offset != 0)\n\t\treturn window;\n\n\t/* We need to map and reserve the first IOMMU page since it's used\n\t * by the spider workaround. In theory, we only need to do that when\n\t * running on spider but it doesn't really matter.\n\t *\n\t * This code also assumes that we have a window that starts at 0,\n\t * which is the case on all spider based blades.\n\t */\n\tpage = alloc_pages_node(iommu->nid, GFP_KERNEL, 0);\n\tBUG_ON(!page);\n\tiommu->pad_page = page_address(page);\n\tclear_page(iommu->pad_page);\n\n\t__set_bit(0, window->table.it_map);\n\ttce_build_cell(&window->table, window->table.it_offset, 1,\n\t\t       (unsigned long)iommu->pad_page, DMA_TO_DEVICE, 0);\n\n\treturn window;\n}"
    },
    {
        "var_name": null,
        "function_name": "bfq_bio_bfqg",
        "location": {
            "file_path": "block/bfq-cgroup.c",
            "region": {
                "startLine": 1472,
                "startColumn": 9,
                "endColumn": 9
            },
            "context": {
                "startLine": 1470,
                "endLine": 1474,
                "snippet": {
                    "text": "return bfqd->root_group;"
                }
            }
        },
        "function_code": "\nstruct bfq_group *bfq_bio_bfqg(struct bfq_data *bfqd, struct bio *bio)\n{\n\treturn bfqd->root_group;"
    },
    {
        "var_name": null,
        "function_name": "bfqq_group",
        "location": {
            "file_path": "block/bfq-cgroup.c",
            "region": {
                "startLine": 1477,
                "startColumn": 9,
                "endColumn": 9
            },
            "context": {
                "startLine": 1475,
                "endLine": 1479,
                "snippet": {
                    "text": "return bfqq->bfqd->root_group;"
                }
            }
        },
        "function_code": "\nstruct bfq_group *bfqq_group(struct bfq_queue *bfqq)\n{\n\treturn bfqq->bfqd->root_group;"
    },
    {
        "var_name": null,
        "function_name": "bfqq_group",
        "location": {
            "file_path": "block/bfq-cgroup.c",
            "region": {
                "startLine": 305,
                "startColumn": 36,
                "endColumn": 36
            },
            "context": {
                "startLine": 303,
                "endLine": 307,
                "snippet": {
                    "text": "struct bfq_entity *group_entity = bfqq->entity.parent;"
                }
            }
        },
        "function_code": "\nstruct bfq_group *bfqq_group(struct bfq_queue *bfqq)\n{\n\tstruct bfq_entity *group_entity = bfqq->entity.parent;\n\n\treturn group_entity ? container_of(group_entity, struct bfq_group,\n\t\t\t\t\t   entity) :\n\t\t\t      bfqq->bfqd->root_group;"
    },
    {
        "var_name": null,
        "function_name": "regmap_get_reg_endian",
        "location": {
            "file_path": "drivers/base/regmap/regmap.c",
            "region": {
                "startLine": 607,
                "startColumn": 11,
                "endColumn": 11
            },
            "context": {
                "startLine": 605,
                "endLine": 609,
                "snippet": {
                    "text": "endian = config->reg_format_endian;"
                }
            }
        },
        "function_code": "static enum regmap_endian regmap_get_reg_endian(const struct regmap_bus *bus,\n\t\t\t\t\tconst struct regmap_config *config)\n{\n\tenum regmap_endian endian;\n\n\t/* Retrieve the endianness specification from the regmap config */\n\tendian = config->reg_format_endian;\n\n\t/* If the regmap config specified a non-default value, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* Retrieve the endianness specification from the bus config */\n\tif (bus && bus->reg_format_endian_default)\n\t\tendian = bus->reg_format_endian_default;\n\n\t/* If the bus specified a non-default value, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* Use this if no other value was found */\n\treturn REGMAP_ENDIAN_BIG;\n}"
    },
    {
        "var_name": null,
        "function_name": "regmap_get_val_endian",
        "location": {
            "file_path": "drivers/base/regmap/regmap.c",
            "region": {
                "startLine": 633,
                "startColumn": 11,
                "endColumn": 11
            },
            "context": {
                "startLine": 631,
                "endLine": 635,
                "snippet": {
                    "text": "endian = config->val_format_endian;"
                }
            }
        },
        "function_code": "enum regmap_endian regmap_get_val_endian(struct device *dev,\n\t\t\t\t\t const struct regmap_bus *bus,\n\t\t\t\t\t const struct regmap_config *config)\n{\n\tstruct fwnode_handle *fwnode = dev ? dev_fwnode(dev) : NULL;\n\tenum regmap_endian endian;\n\n\t/* Retrieve the endianness specification from the regmap config */\n\tendian = config->val_format_endian;\n\n\t/* If the regmap config specified a non-default value, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* If the firmware node exist try to get endianness from it */\n\tif (fwnode_property_read_bool(fwnode, \"big-endian\"))\n\t\tendian = REGMAP_ENDIAN_BIG;\n\telse if (fwnode_property_read_bool(fwnode, \"little-endian\"))\n\t\tendian = REGMAP_ENDIAN_LITTLE;\n\telse if (fwnode_property_read_bool(fwnode, \"native-endian\"))\n\t\tendian = REGMAP_ENDIAN_NATIVE;\n\n\t/* If the endianness was specified in fwnode, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* Retrieve the endianness specification from the bus config */\n\tif (bus && bus->val_format_endian_default)\n\t\tendian = bus->val_format_endian_default;\n\n\t/* If the bus specified a non-default value, use that */\n\tif (endian != REGMAP_ENDIAN_DEFAULT)\n\t\treturn endian;\n\n\t/* Use this if no other value was found */\n\treturn REGMAP_ENDIAN_BIG;\n}"
    },
    {
        "var_name": null,
        "function_name": "pkt_bio_finished",
        "location": {
            "file_path": "drivers/block/pktcdvd.c",
            "region": {
                "startLine": 534,
                "startColumn": 36,
                "endColumn": 36
            },
            "context": {
                "startLine": 532,
                "endLine": 536,
                "snippet": {
                    "text": "struct device *ddev = disk_to_dev(pd->disk);"
                }
            }
        },
        "function_code": "static void pkt_bio_finished(struct pktcdvd_device *pd)\n{\n\tstruct device *ddev = disk_to_dev(pd->disk);\n\n\tBUG_ON(atomic_read(&pd->cdrw.pending_bios) <= 0);\n\tif (atomic_dec_and_test(&pd->cdrw.pending_bios)) {\n\t\tdev_dbg(ddev, \"queue empty\\n\");\n\t\tatomic_set(&pd->iosched.attention, 1);\n\t\twake_up(&pd->wqueue);\n\t}\n}"
    },
    {
        "var_name": null,
        "function_name": "ppc440spe_dma_put_desc",
        "location": {
            "file_path": "drivers/dma/ppc4xx/adma.c",
            "region": {
                "startLine": 1080,
                "startColumn": 9,
                "endColumn": 9
            },
            "context": {
                "startLine": 1078,
                "endLine": 1082,
                "snippet": {
                    "text": "pcdb = desc->phys;"
                }
            }
        },
        "function_code": "static void ppc440spe_dma_put_desc(struct ppc440spe_adma_chan *chan,\n\t\tstruct ppc440spe_adma_desc_slot *desc)\n{\n\tu32 pcdb;\n\tstruct dma_regs *dma_reg = chan->device->dma_reg;\n\n\tpcdb = desc->phys;\n\tif (!test_bit(PPC440SPE_DESC_INT, &desc->flags))\n\t\tpcdb |= DMA_CDB_NO_INT;\n\n\tchan_last_sub[chan->device->id] = desc;\n\n\tADMA_LL_DBG(print_cb(chan, desc->hw_desc));\n\n\tiowrite32(pcdb, &dma_reg->cpfpl);\n}"
    },
    {
        "var_name": null,
        "function_name": "amdgpu_vm_bo_update",
        "location": {
            "file_path": "drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c",
            "region": {
                "startLine": 1120,
                "startColumn": 25,
                "endColumn": 25
            },
            "context": {
                "startLine": 1118,
                "endLine": 1122,
                "snippet": {
                    "text": "struct amdgpu_bo *bo = bo_va->base.bo;"
                }
            }
        },
        "function_code": "int amdgpu_vm_bo_update(struct amdgpu_device *adev, struct amdgpu_bo_va *bo_va,\n\t\t\tbool clear)\n{\n\tstruct amdgpu_bo *bo = bo_va->base.bo;\n\tstruct amdgpu_vm *vm = bo_va->base.vm;\n\tstruct amdgpu_bo_va_mapping *mapping;\n\tdma_addr_t *pages_addr = NULL;\n\tstruct ttm_resource *mem;\n\tstruct dma_fence **last_update;\n\tbool flush_tlb = clear;\n\tbool uncached;\n\tstruct dma_resv *resv;\n\tuint64_t vram_base;\n\tuint64_t flags;\n\tint r;\n\n\tif (clear || !bo) {\n\t\tmem = NULL;\n\t\tresv = vm->root.bo->tbo.base.resv;\n\t} else {\n\t\tstruct drm_gem_object *obj = &bo->tbo.base;\n\n\t\tresv = bo->tbo.base.resv;\n\t\tif (obj->import_attach && bo_va->is_xgmi) {\n\t\t\tstruct dma_buf *dma_buf = obj->import_attach->dmabuf;\n\t\t\tstruct drm_gem_object *gobj = dma_buf->priv;\n\t\t\tstruct amdgpu_bo *abo = gem_to_amdgpu_bo(gobj);\n\n\t\t\tif (abo->tbo.resource &&\n\t\t\t    abo->tbo.resource->mem_type == TTM_PL_VRAM)\n\t\t\t\tbo = gem_to_amdgpu_bo(gobj);\n\t\t}\n\t\tmem = bo->tbo.resource;\n\t\tif (mem && (mem->mem_type == TTM_PL_TT ||\n\t\t\t    mem->mem_type == AMDGPU_PL_PREEMPT))\n\t\t\tpages_addr = bo->tbo.ttm->dma_address;\n\t}\n\n\tif (bo) {\n\t\tstruct amdgpu_device *bo_adev;\n\n\t\tflags = amdgpu_ttm_tt_pte_flags(adev, bo->tbo.ttm, mem);\n\n\t\tif (amdgpu_bo_encrypted(bo))\n\t\t\tflags |= AMDGPU_PTE_TMZ;\n\n\t\tbo_adev = amdgpu_ttm_adev(bo->tbo.bdev);\n\t\tvram_base = bo_adev->vm_manager.vram_base_offset;\n\t\tuncached = (bo->flags & AMDGPU_GEM_CREATE_UNCACHED) != 0;\n\t} else {\n\t\tflags = 0x0;\n\t\tvram_base = 0;\n\t\tuncached = false;\n\t}\n\n\tif (clear || (bo && bo->tbo.base.resv ==\n\t\t      vm->root.bo->tbo.base.resv))\n\t\tlast_update = &vm->last_update;\n\telse\n\t\tlast_update = &bo_va->last_pt_update;\n\n\tif (!clear && bo_va->base.moved) {\n\t\tflush_tlb = true;\n\t\tlist_splice_init(&bo_va->valids, &bo_va->invalids);\n\n\t} else if (bo_va->cleared != clear) {\n\t\tlist_splice_init(&bo_va->valids, &bo_va->invalids);\n\t}\n\n\tlist_for_each_entry(mapping, &bo_va->invalids, list) {\n\t\tuint64_t update_flags = flags;\n\n\t\t/* normally,bo_va->flags only contians READABLE and WIRTEABLE bit go here\n\t\t * but in case of something, we filter the flags in first place\n\t\t */\n\t\tif (!(mapping->flags & AMDGPU_PTE_READABLE))\n\t\t\tupdate_flags &= ~AMDGPU_PTE_READABLE;\n\t\tif (!(mapping->flags & AMDGPU_PTE_WRITEABLE))\n\t\t\tupdate_flags &= ~AMDGPU_PTE_WRITEABLE;\n\n\t\t/* Apply ASIC specific mapping flags */\n\t\tamdgpu_gmc_get_vm_pte(adev, mapping, &update_flags);\n\n\t\ttrace_amdgpu_vm_bo_update(mapping);\n\n\t\tr = amdgpu_vm_update_range(adev, vm, false, false, flush_tlb,\n\t\t\t\t\t   !uncached, resv, mapping->start, mapping->last,\n\t\t\t\t\t   update_flags, mapping->offset,\n\t\t\t\t\t   vram_base, mem, pages_addr,\n\t\t\t\t\t   last_update);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\t/* If the BO is not in its preferred location add it back to\n\t * the evicted list so that it gets validated again on the\n\t * next command submission.\n\t */\n\tif (bo && bo->tbo.base.resv == vm->root.bo->tbo.base.resv) {\n\t\tuint32_t mem_type = bo->tbo.resource->mem_type;\n\n\t\tif (!(bo->preferred_domains &\n\t\t      amdgpu_mem_type_to_domain(mem_type)))\n\t\t\tamdgpu_vm_bo_evicted(&bo_va->base);\n\t\telse\n\t\t\tamdgpu_vm_bo_idle(&bo_va->base);\n\t} else {\n\t\tamdgpu_vm_bo_done(&bo_va->base);\n\t}\n\n\tlist_splice_init(&bo_va->invalids, &bo_va->valids);\n\tbo_va->cleared = clear;\n\tbo_va->base.moved = false;\n\n\tif (trace_amdgpu_vm_bo_mapping_enabled()) {\n\t\tlist_for_each_entry(mapping, &bo_va->valids, list)\n\t\t\ttrace_amdgpu_vm_bo_mapping(mapping);\n\t}\n\n\treturn 0;\n}"
    },
    {
        "var_name": null,
        "function_name": "__drm_3dlut_to_dc_3dlut",
        "location": {
            "file_path": "drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_color.c",
            "region": {
                "startLine": 721,
                "startColumn": 36,
                "endColumn": 36
            },
            "context": {
                "startLine": 719,
                "endLine": 723,
                "snippet": {
                    "text": "__to_dc_lut3d_color(&lut0[lut_i], lut[i], bit_depth);"
                }
            }
        },
        "function_code": "static void __drm_3dlut_to_dc_3dlut(const struct drm_color_lut *lut,\n\t\t\t\t    uint32_t lut3d_size,\n\t\t\t\t    struct tetrahedral_params *params,\n\t\t\t\t    bool use_tetrahedral_9,\n\t\t\t\t    int bit_depth)\n{\n\tstruct dc_rgb *lut0;\n\tstruct dc_rgb *lut1;\n\tstruct dc_rgb *lut2;\n\tstruct dc_rgb *lut3;\n\tint lut_i, i;\n\n\n\tif (use_tetrahedral_9) {\n\t\tlut0 = params->tetrahedral_9.lut0;\n\t\tlut1 = params->tetrahedral_9.lut1;\n\t\tlut2 = params->tetrahedral_9.lut2;\n\t\tlut3 = params->tetrahedral_9.lut3;\n\t} else {\n\t\tlut0 = params->tetrahedral_17.lut0;\n\t\tlut1 = params->tetrahedral_17.lut1;\n\t\tlut2 = params->tetrahedral_17.lut2;\n\t\tlut3 = params->tetrahedral_17.lut3;\n\t}\n\n\tfor (lut_i = 0, i = 0; i < lut3d_size - 4; lut_i++, i += 4) {\n\t\t/*\n\t\t * We should consider the 3D LUT RGB values are distributed\n\t\t * along four arrays lut0-3 where the first sizes 1229 and the\n\t\t * other 1228. The bit depth supported for 3dlut channel is\n\t\t * 12-bit, but DC also supports 10-bit.\n\t\t *\n\t\t * TODO: improve color pipeline API to enable the userspace set\n\t\t * bit depth and 3D LUT size/stride, as specified by VA-API.\n\t\t */\n\t\t__to_dc_lut3d_color(&lut0[lut_i], lut[i], bit_depth);\n\t\t__to_dc_lut3d_color(&lut1[lut_i], lut[i + 1], bit_depth);\n\t\t__to_dc_lut3d_color(&lut2[lut_i], lut[i + 2], bit_depth);\n\t\t__to_dc_lut3d_color(&lut3[lut_i], lut[i + 3], bit_depth);\n\t}\n\t/* lut0 has 1229 points (lut_size/4 + 1) */\n\t__to_dc_lut3d_color(&lut0[lut_i], lut[i], bit_depth);\n}"
    },
    {
        "var_name": null,
        "function_name": "guc_context_policy_init_v69",
        "location": {
            "file_path": "drivers/gpu/drm/i915/gt/uc/intel_guc_submission.c",
            "region": {
                "startLine": 2697,
                "startColumn": 2,
                "endColumn": 2
            },
            "context": {
                "startLine": 2695,
                "endLine": 2699,
                "snippet": {
                    "text": "desc->policy_flags = 0;"
                }
            }
        },
        "function_code": "static void guc_context_policy_init_v69(struct intel_engine_cs *engine,\n\t\t\t\t\tstruct guc_lrc_desc_v69 *desc)\n{\n\tdesc->policy_flags = 0;\n\n\tif (engine->flags & I915_ENGINE_WANT_FORCED_PREEMPTION)\n\t\tdesc->policy_flags |= CONTEXT_POLICY_FLAG_PREEMPT_TO_IDLE_V69;\n\n\t/* NB: For both of these, zero means disabled. */\n\tGEM_BUG_ON(overflows_type(engine->props.timeslice_duration_ms * 1000,\n\t\t\t\t  desc->execution_quantum));\n\tGEM_BUG_ON(overflows_type(engine->props.preempt_timeout_ms * 1000,\n\t\t\t\t  desc->preemption_timeout));\n\tdesc->execution_quantum = engine->props.timeslice_duration_ms * 1000;\n\tdesc->preemption_timeout = engine->props.preempt_timeout_ms * 1000;\n}"
    },
    {
        "var_name": null,
        "function_name": "_dpu_plane_get_kms",
        "location": {
            "file_path": "drivers/gpu/drm/msm/disp/dpu1/dpu_plane.c",
            "region": {
                "startLine": 100,
                "startColumn": 33,
                "endColumn": 33
            },
            "context": {
                "startLine": 98,
                "endLine": 102,
                "snippet": {
                    "text": "struct msm_drm_private *priv = plane->dev->dev_private;"
                }
            }
        },
        "function_code": "static struct dpu_kms *_dpu_plane_get_kms(struct drm_plane *plane)\n{\n\tstruct msm_drm_private *priv = plane->dev->dev_private;\n\n\treturn to_dpu_kms(priv->kms);\n}"
    },
    {
        "var_name": null,
        "function_name": "xe_vm_obj",
        "location": {
            "file_path": "drivers/gpu/drm/xe/xe_vm.c",
            "region": {
                "startLine": 44,
                "startColumn": 9,
                "endColumn": 9
            },
            "context": {
                "startLine": 42,
                "endLine": 46,
                "snippet": {
                    "text": "return vm->gpuvm.r_obj;"
                }
            }
        },
        "function_code": "static struct drm_gem_object *xe_vm_obj(struct xe_vm *vm)\n{\n\treturn vm->gpuvm.r_obj;\n}"
    },
    {
        "var_name": null,
        "function_name": "tpdm_datasets_setup",
        "location": {
            "file_path": "drivers/hwtracing/coresight/coresight-tpdm.c",
            "region": {
                "startLine": 529,
                "startColumn": 23,
                "endColumn": 23
            },
            "context": {
                "startLine": 527,
                "endLine": 531,
                "snippet": {
                    "text": "pidr = readl_relaxed(drvdata->base + CORESIGHT_PERIPHIDR0);"
                }
            }
        },
        "function_code": "static int tpdm_datasets_setup(struct tpdm_drvdata *drvdata)\n{\n\tu32 pidr;\n\n\t/*  Get the datasets present on the TPDM. */\n\tpidr = readl_relaxed(drvdata->base + CORESIGHT_PERIPHIDR0);\n\tdrvdata->datasets |= pidr & GENMASK(TPDM_DATASETS - 1, 0);\n\n\tif (tpdm_has_dsb_dataset(drvdata) && (!drvdata->dsb)) {\n\t\tdrvdata->dsb = devm_kzalloc(drvdata->dev,\n\t\t\t\t\t\tsizeof(*drvdata->dsb), GFP_KERNEL);\n\t\tif (!drvdata->dsb)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (tpdm_has_cmb_dataset(drvdata) && (!drvdata->cmb)) {\n\t\tdrvdata->cmb = devm_kzalloc(drvdata->dev,\n\t\t\t\t\t\tsizeof(*drvdata->cmb), GFP_KERNEL);\n\t\tif (!drvdata->cmb)\n\t\t\treturn -ENOMEM;\n\t}\n\ttpdm_reset_datasets(drvdata);\n\n\treturn 0;\n}"
    },
    {
        "var_name": null,
        "function_name": "siw_rx_data",
        "location": {
            "file_path": "drivers/infiniband/sw/siw/siw_qp_rx.c",
            "region": {
                "startLine": 413,
                "startColumn": 6,
                "endColumn": 6
            },
            "context": {
                "startLine": 411,
                "endLine": 415,
                "snippet": {
                    "text": "if (mem_p->mem_obj == NULL)"
                }
            }
        },
        "function_code": "static int siw_rx_data(struct siw_mem *mem_p, struct siw_rx_stream *srx,\n\t\t       unsigned int *pbl_idx, u64 addr, int bytes)\n{\n\tint rv;\n\n\tif (mem_p->mem_obj == NULL)\n\t\trv = siw_rx_kva(srx, ib_virt_dma_to_ptr(addr), bytes);\n\telse if (!mem_p->is_pbl)\n\t\trv = siw_rx_umem(srx, mem_p->umem, addr, bytes);\n\telse\n\t\trv = siw_rx_pbl(srx, pbl_idx, mem_p, addr, bytes);\n\treturn rv;\n}"
    },
    {
        "var_name": null,
        "function_name": "isert_device_put",
        "location": {
            "file_path": "drivers/infiniband/ulp/isert/ib_isert.c",
            "region": {
                "startLine": 254,
                "startColumn": 2,
                "endColumn": 2
            },
            "context": {
                "startLine": 252,
                "endLine": 256,
                "snippet": {
                    "text": "device->refcount--;"
                }
            }
        },
        "function_code": "static void\nisert_device_put(struct isert_device *device)\n{\n\tmutex_lock(&device_list_mutex);\n\tdevice->refcount--;\n\tisert_info(\"device %p refcount %d\\n\", device, device->refcount);\n\tif (!device->refcount) {\n\t\tisert_free_device_ib_res(device);\n\t\tlist_del(&device->dev_node);\n\t\tkfree(device);\n\t}\n\tmutex_unlock(&device_list_mutex);\n}"
    },
    {
        "var_name": null,
        "function_name": "input_print_modalias_parts",
        "location": {
            "file_path": "drivers/input/input.c",
            "region": {
                "startLine": 1395,
                "startColumn": 17,
                "endColumn": 17
            },
            "context": {
                "startLine": 1393,
                "endLine": 1397,
                "snippet": {
                    "text": "len = snprintf(buf, max(size, 0),"
                }
            }
        },
        "function_code": "static int input_print_modalias_parts(char *buf, int size, int full_len,\n\t\t\t\t      const struct input_dev *id)\n{\n\tint len, klen, remainder, space;\n\n\tlen = snprintf(buf, max(size, 0),\n\t\t       \"input:b%04Xv%04Xp%04Xe%04X-\",\n\t\t       id->id.bustype, id->id.vendor,\n\t\t       id->id.product, id->id.version);\n\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'e', id->evbit, 0, EV_MAX);\n\n\t/*\n\t * Calculate the remaining space in the buffer making sure we\n\t * have place for the terminating 0.\n\t */\n\tspace = max(size - (len + 1), 0);\n\n\tklen = input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'k', id->keybit, KEY_MIN_INTERESTING, KEY_MAX);\n\tlen += klen;\n\n\t/*\n\t * If we have more data than we can fit in the buffer, check\n\t * if we can trim key data to fit in the rest. We will indicate\n\t * that key data is incomplete by adding \"+\" sign at the end, like\n\t * this: * \"k1,2,3,45,+,\".\n\t *\n\t * Note that we shortest key info (if present) is \"k+,\" so we\n\t * can only try to trim if key data is longer than that.\n\t */\n\tif (full_len && size < full_len + 1 && klen > 3) {\n\t\tremainder = full_len - len;\n\t\t/*\n\t\t * We can only trim if we have space for the remainder\n\t\t * and also for at least \"k+,\" which is 3 more characters.\n\t\t */\n\t\tif (remainder <= space - 3) {\n\t\t\t/*\n\t\t\t * We are guaranteed to have 'k' in the buffer, so\n\t\t\t * we need at least 3 additional bytes for storing\n\t\t\t * \"+,\" in addition to the remainder.\n\t\t\t */\n\t\t\tfor (int i = size - 1 - remainder - 3; i >= 0; i--) {\n\t\t\t\tif (buf[i] == 'k' || buf[i] == ',') {\n\t\t\t\t\tstrcpy(buf + i + 1, \"+,\");\n\t\t\t\t\tlen = i + 3; /* Not counting '\\0' */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'r', id->relbit, 0, REL_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'a', id->absbit, 0, ABS_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'm', id->mscbit, 0, MSC_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'l', id->ledbit, 0, LED_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t's', id->sndbit, 0, SND_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'f', id->ffbit, 0, FF_MAX);\n\tlen += input_print_modalias_bits(buf + len, size - len,\n\t\t\t\t'w', id->swbit, 0, SW_MAX);\n\n\treturn len;\n}"
    },
    {
        "var_name": null,
        "function_name": "sprd_iommu_write",
        "location": {
            "file_path": "drivers/iommu/sprd-iommu.c",
            "region": {
                "startLine": 94,
                "startColumn": 22,
                "endColumn": 22
            },
            "context": {
                "startLine": 92,
                "endLine": 96,
                "snippet": {
                    "text": "writel_relaxed(val, sdev->base + reg);"
                }
            }
        },
        "function_code": "static inline void\nsprd_iommu_write(struct sprd_iommu_device *sdev, unsigned int reg, u32 val)\n{\n\twritel_relaxed(val, sdev->base + reg);\n}"
    },
    {
        "var_name": null,
        "function_name": "sprd_iommu_read",
        "location": {
            "file_path": "drivers/iommu/sprd-iommu.c",
            "region": {
                "startLine": 100,
                "startColumn": 23,
                "endColumn": 23
            },
            "context": {
                "startLine": 98,
                "endLine": 102,
                "snippet": {
                    "text": "return readl_relaxed(sdev->base + reg);"
                }
            }
        },
        "function_code": "static inline u32\nsprd_iommu_read(struct sprd_iommu_device *sdev, unsigned int reg)\n{\n\treturn readl_relaxed(sdev->base + reg);\n}"
    },
    {
        "var_name": null,
        "function_name": "sprd_iommu_hw_en",
        "location": {
            "file_path": "drivers/iommu/sprd-iommu.c",
            "region": {
                "startLine": 215,
                "startColumn": 6,
                "endColumn": 6
            },
            "context": {
                "startLine": 213,
                "endLine": 217,
                "snippet": {
                    "text": "if (sdev->ver == SPRD_IOMMU_EX)"
                }
            }
        },
        "function_code": "static void sprd_iommu_hw_en(struct sprd_iommu_device *sdev, bool en)\n{\n\tunsigned int reg_cfg;\n\tu32 mask, val;\n\n\tif (sdev->ver == SPRD_IOMMU_EX)\n\t\treg_cfg = SPRD_EX_CFG;\n\telse\n\t\treg_cfg = SPRD_VAU_CFG;\n\n\tmask = SPRD_IOMMU_EN | SPRD_IOMMU_GATE_EN;\n\tval = en ? mask : 0;\n\tsprd_iommu_update_bits(sdev, reg_cfg, mask, 0, val);\n}"
    },
    {
        "var_name": null,
        "function_name": "ngene_command_i2c_read",
        "location": {
            "file_path": "drivers/media/pci/ngene/ngene-i2c.c",
            "region": {
                "startLine": 39,
                "startColumn": 31,
                "endColumn": 31
            },
            "context": {
                "startLine": 37,
                "endLine": 41,
                "snippet": {
                    "text": "memcpy(com.cmd.I2CRead.Data, out, outlen);"
                }
            }
        },
        "function_code": "static int ngene_command_i2c_read(struct ngene *dev, u8 adr,\n\t\t\t   u8 *out, u8 outlen, u8 *in, u8 inlen, int flag)\n{\n\tstruct ngene_command com;\n\n\tcom.cmd.hdr.Opcode = CMD_I2C_READ;\n\tcom.cmd.hdr.Length = outlen + 3;\n\tcom.cmd.I2CRead.Device = adr << 1;\n\tmemcpy(com.cmd.I2CRead.Data, out, outlen);\n\tcom.cmd.I2CRead.Data[outlen] = inlen;\n\tcom.cmd.I2CRead.Data[outlen + 1] = 0;\n\tcom.in_len = outlen + 3;\n\tcom.out_len = inlen + 1;\n\n\tif (ngene_command(dev, &com) < 0)\n\t\treturn -EIO;\n\n\tif ((com.cmd.raw8[0] >> 1) != adr)\n\t\treturn -EIO;\n\n\tif (flag)\n\t\tmemcpy(in, com.cmd.raw8, inlen + 1);\n\telse\n\t\tmemcpy(in, com.cmd.raw8 + 1, inlen);\n\treturn 0;\n}"
    },
    {
        "var_name": null,
        "function_name": "ctrl_to_dec_ctx",
        "location": {
            "file_path": "drivers/media/platform/mediatek/vcodec/decoder/mtk_vcodec_dec_drv.h",
            "region": {
                "startLine": 317,
                "startColumn": 22,
                "endColumn": 22
            },
            "context": {
                "startLine": 315,
                "endLine": 319,
                "snippet": {
                    "text": "return container_of(ctrl->handler, struct mtk_vcodec_dec_ctx, ctrl_hdl);"
                }
            }
        },
        "function_code": "static inline struct mtk_vcodec_dec_ctx *ctrl_to_dec_ctx(struct v4l2_ctrl *ctrl)\n{\n\treturn container_of(ctrl->handler, struct mtk_vcodec_dec_ctx, ctrl_hdl);\n}"
    },
    {
        "var_name": null,
        "function_name": "entity_to_fimc_mdev",
        "location": {
            "file_path": "drivers/media/platform/samsung/exynos4-is/media-dev.h",
            "region": {
                "startLine": 157,
                "startColumn": 9,
                "endColumn": 9
            },
            "context": {
                "startLine": 155,
                "endLine": 159,
                "snippet": {
                    "text": "return me->graph_obj.mdev == NULL ? NULL :"
                }
            }
        },
        "function_code": "static inline struct fimc_md *entity_to_fimc_mdev(struct media_entity *me)\n{\n\treturn me->graph_obj.mdev == NULL ? NULL :\n\t\tcontainer_of(me->graph_obj.mdev, struct fimc_md, media_dev);\n}"
    },
    {
        "var_name": null,
        "function_name": "fimc_pipeline_s_power",
        "location": {
            "file_path": "drivers/media/platform/samsung/exynos4-is/media-dev.c",
            "region": {
                "startLine": 164,
                "startColumn": 6,
                "endColumn": 6
            },
            "context": {
                "startLine": 162,
                "endLine": 166,
                "snippet": {
                    "text": "if (p->subdevs[IDX_SENSOR] == NULL)"
                }
            }
        },
        "function_code": "static int fimc_pipeline_s_power(struct fimc_pipeline *p, bool on)\n{\n\tstatic const u8 seq[2][IDX_MAX - 1] = {\n\t\t{ IDX_IS_ISP, IDX_SENSOR, IDX_CSIS, IDX_FLITE },\n\t\t{ IDX_CSIS, IDX_FLITE, IDX_SENSOR, IDX_IS_ISP },\n\t};\n\tint i, ret = 0;\n\n\tif (p->subdevs[IDX_SENSOR] == NULL)\n\t\treturn -ENXIO;\n\n\tfor (i = 0; i < IDX_MAX - 1; i++) {\n\t\tunsigned int idx = seq[on][i];\n\n\t\tret = __subdev_set_power(p->subdevs[idx], on);\n\n\n\t\tif (ret < 0 && ret != -ENXIO)\n\t\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tfor (; i >= 0; i--) {\n\t\tunsigned int idx = seq[on][i];\n\t\t__subdev_set_power(p->subdevs[idx], !on);\n\t}\n\treturn ret;\n}"
    },
    {
        "var_name": null,
        "function_name": "sdhci_calc_sw_timeout",
        "location": {
            "file_path": "drivers/mmc/host/sdhci.c",
            "region": {
                "startLine": 935,
                "startColumn": 26,
                "endColumn": 26
            },
            "context": {
                "startLine": 933,
                "endLine": 937,
                "snippet": {
                    "text": "struct mmc_data *data = cmd->data;"
                }
            }
        },
        "function_code": "static void sdhci_calc_sw_timeout(struct sdhci_host *host,\n\t\t\t\t  struct mmc_command *cmd)\n{\n\tstruct mmc_data *data = cmd->data;\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct mmc_ios *ios = &mmc->ios;\n\tunsigned char bus_width = 1 << ios->bus_width;\n\tunsigned int blksz;\n\tunsigned int freq;\n\tu64 target_timeout;\n\tu64 transfer_time;\n\n\ttarget_timeout = sdhci_target_timeout(host, cmd, data);\n\ttarget_timeout *= NSEC_PER_USEC;\n\n\tif (data) {\n\t\tblksz = data->blksz;\n\t\tfreq = mmc->actual_clock ? : host->clock;\n\t\ttransfer_time = (u64)blksz * NSEC_PER_SEC * (8 / bus_width);\n\t\tdo_div(transfer_time, freq);\n\t\t/* multiply by '2' to account for any unknowns */\n\t\ttransfer_time = transfer_time * 2;\n\t\t/* calculate timeout for the entire data */\n\t\thost->data_timeout = data->blocks * target_timeout +\n\t\t\t\t     transfer_time;\n\t} else {\n\t\thost->data_timeout = target_timeout;\n\t}\n\n\tif (host->data_timeout)\n\t\thost->data_timeout += MMC_CMD_TRANSFER_TIME;\n}"
    },
    {
        "var_name": null,
        "function_name": "s3c2410_nand_init_chip",
        "location": {
            "file_path": "drivers/mtd/nand/raw/s3c2410.c",
            "region": {
                "startLine": 795,
                "startColumn": 28,
                "endColumn": 28
            },
            "context": {
                "startLine": 793,
                "endLine": 797,
                "snippet": {
                    "text": "nand_set_flash_node(chip, set->of_node);"
                }
            }
        },
        "function_code": "static void s3c2410_nand_init_chip(struct s3c2410_nand_info *info,\n\t\t\t\t   struct s3c2410_nand_mtd *nmtd,\n\t\t\t\t   struct s3c2410_nand_set *set)\n{\n\tstruct device_node *np = info->device->of_node;\n\tstruct nand_chip *chip = &nmtd->chip;\n\tvoid __iomem *regs = info->regs;\n\n\tnand_set_flash_node(chip, set->of_node);\n\n\tchip->legacy.write_buf    = s3c2410_nand_write_buf;\n\tchip->legacy.read_buf     = s3c2410_nand_read_buf;\n\tchip->legacy.select_chip  = s3c2410_nand_select_chip;\n\tchip->legacy.chip_delay   = 50;\n\tnand_set_controller_data(chip, nmtd);\n\tchip->options\t   = set->options;\n\tchip->controller   = &info->controller;\n\n\t/*\n\t * let's keep behavior unchanged for legacy boards booting via pdata and\n\t * auto-detect timings only when booting with a device tree.\n\t */\n\tif (!np)\n\t\tchip->options |= NAND_KEEP_TIMINGS;\n\n\tswitch (info->cpu_type) {\n\tcase TYPE_S3C2410:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2410_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2410_NFCONF;\n\t\tinfo->sel_bit\t= S3C2410_NFCONF_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2410_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2410_nand_devready;\n\t\tbreak;\n\n\tcase TYPE_S3C2440:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2440_NFCONT_nFCE;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2440_nand_devready;\n\t\tchip->legacy.read_buf  = s3c2440_nand_read_buf;\n\t\tchip->legacy.write_buf\t= s3c2440_nand_write_buf;\n\t\tbreak;\n\n\tcase TYPE_S3C2412:\n\t\tchip->legacy.IO_ADDR_W = regs + S3C2440_NFDATA;\n\t\tinfo->sel_reg   = regs + S3C2440_NFCONT;\n\t\tinfo->sel_bit\t= S3C2412_NFCONT_nFCE0;\n\t\tchip->legacy.cmd_ctrl  = s3c2440_nand_hwcontrol;\n\t\tchip->legacy.dev_ready = s3c2412_nand_devready;\n\n\t\tif (readl(regs + S3C2410_NFCONF) & S3C2412_NFCONF_NANDBOOT)\n\t\t\tdev_info(info->device, \"System booted from NAND\\n\");\n\n\t\tbreak;\n\t}\n\n\tchip->legacy.IO_ADDR_R = chip->legacy.IO_ADDR_W;\n\n\tnmtd->info\t   = info;\n\tnmtd->set\t   = set;\n\n\tchip->ecc.engine_type = info->platform->engine_type;\n\n\t/*\n\t * If you use u-boot BBT creation code, specifying this flag will\n\t * let the kernel fish out the BBT from the NAND.\n\t */\n\tif (set->flash_bbt)\n\t\tchip->bbt_options |= NAND_BBT_USE_FLASH;\n}"
    },
    {
        "var_name": null,
        "function_name": "try_recover_peb",
        "location": {
            "file_path": "drivers/mtd/ubi/eba.c",
            "region": {
                "startLine": 845,
                "startColumn": 32,
                "endColumn": 32
            },
            "context": {
                "startLine": 843,
                "endLine": 847,
                "snippet": {
                    "text": "memcpy(ubi->peb_buf + offset, buf, len);"
                }
            }
        },
        "function_code": "static int try_recover_peb(struct ubi_volume *vol, int pnum, int lnum,\n\t\t\t   const void *buf, int offset, int len,\n\t\t\t   struct ubi_vid_io_buf *vidb, bool *retry)\n{\n\tstruct ubi_device *ubi = vol->ubi;\n\tstruct ubi_vid_hdr *vid_hdr;\n\tint new_pnum, err, vol_id = vol->vol_id, data_size;\n\tuint32_t crc;\n\n\t*retry = false;\n\n\tnew_pnum = ubi_wl_get_peb(ubi);\n\tif (new_pnum < 0) {\n\t\terr = new_pnum;\n\t\tgoto out_put;\n\t}\n\n\tubi_msg(ubi, \"recover PEB %d, move data to PEB %d\",\n\t\tpnum, new_pnum);\n\n\terr = ubi_io_read_vid_hdr(ubi, pnum, vidb, 1);\n\tif (err && err != UBI_IO_BITFLIPS) {\n\t\tif (err > 0)\n\t\t\terr = -EIO;\n\t\tgoto out_put;\n\t}\n\n\tvid_hdr = ubi_get_vid_hdr(vidb);\n\tubi_assert(vid_hdr->vol_type == UBI_VID_DYNAMIC);\n\n\tmutex_lock(&ubi->buf_mutex);\n\tmemset(ubi->peb_buf + offset, 0xFF, len);\n\n\t/* Read everything before the area where the write failure happened */\n\tif (offset > 0) {\n\t\terr = ubi_io_read_data(ubi, ubi->peb_buf, pnum, 0, offset);\n\t\tif (err && err != UBI_IO_BITFLIPS)\n\t\t\tgoto out_unlock;\n\t}\n\n\t*retry = true;\n\n\tmemcpy(ubi->peb_buf + offset, buf, len);\n\n\tdata_size = offset + len;\n\tcrc = crc32(UBI_CRC32_INIT, ubi->peb_buf, data_size);\n\tvid_hdr->sqnum = cpu_to_be64(ubi_next_sqnum(ubi));\n\tvid_hdr->copy_flag = 1;\n\tvid_hdr->data_size = cpu_to_be32(data_size);\n\tvid_hdr->data_crc = cpu_to_be32(crc);\n\terr = ubi_io_write_vid_hdr(ubi, new_pnum, vidb);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = ubi_io_write_data(ubi, ubi->peb_buf, new_pnum, 0, data_size);\n\nout_unlock:\n\tmutex_unlock(&ubi->buf_mutex);\n\n\tif (!err)\n\t\tvol->eba_tbl->entries[lnum].pnum = new_pnum;\n\nout_put:\n\tup_read(&ubi->fm_eba_sem);\n\n\tif (!err) {\n\t\tubi_wl_put_peb(ubi, vol_id, lnum, pnum, 1);\n\t\tubi_msg(ubi, \"data was successfully recovered\");\n\t} else if (new_pnum >= 0) {\n\t\t/*\n\t\t * Bad luck? This physical eraseblock is bad too? Crud. Let's\n\t\t * try to get another one.\n\t\t */\n\t\tubi_wl_put_peb(ubi, vol_id, lnum, new_pnum, 1);\n\t\tubi_warn(ubi, \"failed to write to PEB %d\", new_pnum);\n\t}\n\n\treturn err;\n}"
    },
    {
        "var_name": null,
        "function_name": "handle_tx",
        "location": {
            "file_path": "drivers/net/caif/caif_serial.c",
            "region": {
                "startLine": 214,
                "startColumn": 8,
                "endColumn": 8
            },
            "context": {
                "startLine": 212,
                "endLine": 216,
                "snippet": {
                    "text": "tty = ser->tty;"
                }
            }
        },
        "function_code": "static int handle_tx(struct ser_device *ser)\n{\n\tstruct tty_struct *tty;\n\tstruct sk_buff *skb;\n\tint tty_wr, len, room;\n\n\ttty = ser->tty;\n\tser->tx_started = true;\n\n\t/* Enter critical section */\n\tif (test_and_set_bit(CAIF_SENDING, &ser->state))\n\t\treturn 0;\n\n\t/* skb_peek is safe because handle_tx is called after skb_queue_tail */\n\twhile ((skb = skb_peek(&ser->head)) != NULL) {\n\n\t\t/* Make sure you don't write too much */\n\t\tlen = skb->len;\n\t\troom = tty_write_room(tty);\n\t\tif (!room)\n\t\t\tbreak;\n\t\tif (room > ser_write_chunk)\n\t\t\troom = ser_write_chunk;\n\t\tif (len > room)\n\t\t\tlen = room;\n\n\t\t/* Write to tty or loopback */\n\t\tif (!ser_loop) {\n\t\t\ttty_wr = tty->ops->write(tty, skb->data, len);\n\t\t\tupdate_tty_status(ser);\n\t\t} else {\n\t\t\ttty_wr = len;\n\t\t\tldisc_receive(tty, skb->data, NULL, len);\n\t\t}\n\t\tser->dev->stats.tx_packets++;\n\t\tser->dev->stats.tx_bytes += tty_wr;\n\n\t\t/* Error on TTY ?! */\n\t\tif (tty_wr < 0)\n\t\t\tgoto error;\n\t\t/* Reduce buffer written, and discard if empty */\n\t\tskb_pull(skb, tty_wr);\n\t\tif (skb->len == 0) {\n\t\t\tstruct sk_buff *tmp = skb_dequeue(&ser->head);\n\t\t\tWARN_ON(tmp != skb);\n\t\t\tdev_consume_skb_any(skb);\n\t\t}\n\t}\n\t/* Send flow off if queue is empty */\n\tif (ser->head.qlen <= SEND_QUEUE_LOW &&\n\t\ttest_and_clear_bit(CAIF_FLOW_OFF_SENT, &ser->state) &&\n\t\tser->common.flowctrl != NULL)\n\t\t\t\tser->common.flowctrl(ser->dev, ON);\n\tclear_bit(CAIF_SENDING, &ser->state);\n\treturn 0;\nerror:\n\tclear_bit(CAIF_SENDING, &ser->state);\n\treturn tty_wr;\n}"
    },
    {
        "var_name": null,
        "function_name": "t3_l2t_get",
        "location": {
            "file_path": "drivers/net/ethernet/chelsio/cxgb3/l2t.c",
            "region": {
                "startLine": 327,
                "startColumn": 6,
                "endColumn": 6
            },
            "context": {
                "startLine": 325,
                "endLine": 329,
                "snippet": {
                    "text": "d = L2DATA(cdev);"
                }
            }
        },
        "function_code": "struct l2t_entry *t3_l2t_get(struct t3cdev *cdev, struct dst_entry *dst,\n\t\t\t     struct net_device *dev, const void *daddr)\n{\n\tstruct l2t_entry *e = NULL;\n\tstruct neighbour *neigh;\n\tstruct port_info *p;\n\tstruct l2t_data *d;\n\tint hash;\n\tu32 addr;\n\tint ifidx;\n\tint smt_idx;\n\n\trcu_read_lock();\n\tneigh = dst_neigh_lookup(dst, daddr);\n\tif (!neigh)\n\t\tgoto done_rcu;\n\n\taddr = *(u32 *) neigh->primary_key;\n\tifidx = neigh->dev->ifindex;\n\n\tif (!dev)\n\t\tdev = neigh->dev;\n\tp = netdev_priv(dev);\n\tsmt_idx = p->port_id;\n\n\td = L2DATA(cdev);\n\tif (!d)\n\t\tgoto done_rcu;\n\n\thash = arp_hash(addr, ifidx, d);\n\n\twrite_lock_bh(&d->lock);\n\tfor (e = d->l2tab[hash].first; e; e = e->next)\n\t\tif (e->addr == addr && e->ifindex == ifidx &&\n\t\t    e->smt_idx == smt_idx) {\n\t\t\tl2t_hold(d, e);\n\t\t\tif (atomic_read(&e->refcnt) == 1)\n\t\t\t\treuse_entry(e, neigh);\n\t\t\tgoto done_unlock;\n\t\t}\n\n\t/* Need to allocate a new entry */\n\te = alloc_l2e(d);\n\tif (e) {\n\t\tspin_lock(&e->lock);\t/* avoid race with t3_l2t_free */\n\t\te->next = d->l2tab[hash].first;\n\t\td->l2tab[hash].first = e;\n\t\te->state = L2T_STATE_RESOLVING;\n\t\te->addr = addr;\n\t\te->ifindex = ifidx;\n\t\te->smt_idx = smt_idx;\n\t\tatomic_set(&e->refcnt, 1);\n\t\tneigh_replace(e, neigh);\n\t\tif (is_vlan_dev(neigh->dev))\n\t\t\te->vlan = vlan_dev_vlan_id(neigh->dev);\n\t\telse\n\t\t\te->vlan = VLAN_NONE;\n\t\tspin_unlock(&e->lock);\n\t}\ndone_unlock:\n\twrite_unlock_bh(&d->lock);\ndone_rcu:\n\tif (neigh)\n\t\tneigh_release(neigh);\n\trcu_read_unlock();\n\treturn e;\n}"
    },
    {
        "var_name": null,
        "function_name": "t3_l2t_update",
        "location": {
            "file_path": "drivers/net/ethernet/chelsio/cxgb3/l2t.c",
            "region": {
                "startLine": 403,
                "startColumn": 23,
                "endColumn": 23
            },
            "context": {
                "startLine": 401,
                "endLine": 405,
                "snippet": {
                    "text": "struct l2t_data *d = L2DATA(dev);"
                }
            }
        },
        "function_code": "void t3_l2t_update(struct t3cdev *dev, struct neighbour *neigh)\n{\n\tstruct sk_buff_head arpq;\n\tstruct l2t_entry *e;\n\tstruct l2t_data *d = L2DATA(dev);\n\tu32 addr = *(u32 *) neigh->primary_key;\n\tint ifidx = neigh->dev->ifindex;\n\tint hash = arp_hash(addr, ifidx, d);\n\n\tread_lock_bh(&d->lock);\n\tfor (e = d->l2tab[hash].first; e; e = e->next)\n\t\tif (e->addr == addr && e->ifindex == ifidx) {\n\t\t\tspin_lock(&e->lock);\n\t\t\tgoto found;\n\t\t}\n\tread_unlock_bh(&d->lock);\n\treturn;\n\nfound:\n\t__skb_queue_head_init(&arpq);\n\n\tread_unlock(&d->lock);\n\tif (atomic_read(&e->refcnt)) {\n\t\tif (neigh != e->neigh)\n\t\t\tneigh_replace(e, neigh);\n\n\t\tif (e->state == L2T_STATE_RESOLVING) {\n\t\t\tif (neigh->nud_state & NUD_FAILED) {\n\t\t\t\tskb_queue_splice_init(&e->arpq, &arpq);\n\t\t\t} else if (neigh->nud_state & (NUD_CONNECTED|NUD_STALE))\n\t\t\t\tsetup_l2e_send_pending(dev, NULL, e);\n\t\t} else {\n\t\t\te->state = neigh->nud_state & NUD_CONNECTED ?\n\t\t\t    L2T_STATE_VALID : L2T_STATE_STALE;\n\t\t\tif (!ether_addr_equal(e->dmac, neigh->ha))\n\t\t\t\tsetup_l2e_send_pending(dev, NULL, e);\n\t\t}\n\t}\n\tspin_unlock_bh(&e->lock);\n\n\tif (!skb_queue_empty(&arpq))\n\t\thandle_failed_resolution(dev, &arpq);\n}"
    },
    {
        "var_name": null,
        "function_name": "cmdq_set_sge_completion",
        "location": {
            "file_path": "drivers/net/ethernet/huawei/hinic/hinic_hw_cmdq.c",
            "region": {
                "startLine": 174,
                "startColumn": 32,
                "endColumn": 32
            },
            "context": {
                "startLine": 172,
                "endLine": 176,
                "snippet": {
                    "text": "hinic_set_sge(&sge_resp->sge, buf_out->dma_addr, buf_out->size);"
                }
            }
        },
        "function_code": "static void cmdq_set_sge_completion(struct hinic_cmdq_completion *completion,\n\t\t\t\t    struct hinic_cmdq_buf *buf_out)\n{\n\tstruct hinic_sge_resp *sge_resp = &completion->sge_resp;\n\n\thinic_set_sge(&sge_resp->sge, buf_out->dma_addr, buf_out->size);\n}"
    },
    {
        "var_name": null,
        "function_name": "igb_hash_mc_addr",
        "location": {
            "file_path": "drivers/net/ethernet/intel/igb/e1000_mac.c",
            "region": {
                "startLine": 480,
                "startColumn": 30,
                "endColumn": 30
            },
            "context": {
                "startLine": 478,
                "endLine": 482,
                "snippet": {
                    "text": "hash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |"
                }
            }
        },
        "function_code": "static u32 igb_hash_mc_addr(struct e1000_hw *hw, u8 *mc_addr)\n{\n\tu32 hash_value, hash_mask;\n\tu8 bit_shift = 1;\n\n\t/* Register count multiplied by bits per register */\n\thash_mask = (hw->mac.mta_reg_count * 32) - 1;\n\n\t/* For a mc_filter_type of 0, bit_shift is the number of left-shifts\n\t * where 0xFF would still fall within the hash mask.\n\t */\n\twhile (hash_mask >> bit_shift != 0xFF && bit_shift < 4)\n\t\tbit_shift++;\n\n\t/* The portion of the address that is used for the hash table\n\t * is determined by the mc_filter_type setting.\n\t * The algorithm is such that there is a total of 8 bits of shifting.\n\t * The bit_shift for a mc_filter_type of 0 represents the number of\n\t * left-shifts where the MSB of mc_addr[5] would still fall within\n\t * the hash_mask.  Case 0 does this exactly.  Since there are a total\n\t * of 8 bits of shifting, then mc_addr[4] will shift right the\n\t * remaining number of bits. Thus 8 - bit_shift.  The rest of the\n\t * cases are a variation of this algorithm...essentially raising the\n\t * number of bits to shift mc_addr[5] left, while still keeping the\n\t * 8-bit shifting total.\n\t *\n\t * For example, given the following Destination MAC Address and an\n\t * mta register count of 128 (thus a 4096-bit vector and 0xFFF mask),\n\t * we can see that the bit_shift for case 0 is 4.  These are the hash\n\t * values resulting from each mc_filter_type...\n\t * [0] [1] [2] [3] [4] [5]\n\t * 01  AA  00  12  34  56\n\t * LSB                 MSB\n\t *\n\t * case 0: hash_value = ((0x34 >> 4) | (0x56 << 4)) & 0xFFF = 0x563\n\t * case 1: hash_value = ((0x34 >> 3) | (0x56 << 5)) & 0xFFF = 0xAC6\n\t * case 2: hash_value = ((0x34 >> 2) | (0x56 << 6)) & 0xFFF = 0x163\n\t * case 3: hash_value = ((0x34 >> 0) | (0x56 << 8)) & 0xFFF = 0x634\n\t */\n\tswitch (hw->mac.mc_filter_type) {\n\tdefault:\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tbit_shift += 1;\n\t\tbreak;\n\tcase 2:\n\t\tbit_shift += 2;\n\t\tbreak;\n\tcase 3:\n\t\tbit_shift += 4;\n\t\tbreak;\n\t}\n\n\thash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |\n\t\t\t\t  (((u16) mc_addr[5]) << bit_shift)));\n\n\treturn hash_value;\n}"
    },
    {
        "var_name": null,
        "function_name": "igc_hash_mc_addr",
        "location": {
            "file_path": "drivers/net/ethernet/intel/igc/igc_mac.c",
            "region": {
                "startLine": 842,
                "startColumn": 30,
                "endColumn": 30
            },
            "context": {
                "startLine": 840,
                "endLine": 844,
                "snippet": {
                    "text": "hash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |"
                }
            }
        },
        "function_code": "static u32 igc_hash_mc_addr(struct igc_hw *hw, u8 *mc_addr)\n{\n\tu32 hash_value, hash_mask;\n\tu8 bit_shift = 0;\n\n\t/* Register count multiplied by bits per register */\n\thash_mask = (hw->mac.mta_reg_count * 32) - 1;\n\n\t/* For a mc_filter_type of 0, bit_shift is the number of left-shifts\n\t * where 0xFF would still fall within the hash mask.\n\t */\n\twhile (hash_mask >> bit_shift != 0xFF)\n\t\tbit_shift++;\n\n\t/* The portion of the address that is used for the hash table\n\t * is determined by the mc_filter_type setting.\n\t * The algorithm is such that there is a total of 8 bits of shifting.\n\t * The bit_shift for a mc_filter_type of 0 represents the number of\n\t * left-shifts where the MSB of mc_addr[5] would still fall within\n\t * the hash_mask.  Case 0 does this exactly.  Since there are a total\n\t * of 8 bits of shifting, then mc_addr[4] will shift right the\n\t * remaining number of bits. Thus 8 - bit_shift.  The rest of the\n\t * cases are a variation of this algorithm...essentially raising the\n\t * number of bits to shift mc_addr[5] left, while still keeping the\n\t * 8-bit shifting total.\n\t *\n\t * For example, given the following Destination MAC Address and an\n\t * MTA register count of 128 (thus a 4096-bit vector and 0xFFF mask),\n\t * we can see that the bit_shift for case 0 is 4.  These are the hash\n\t * values resulting from each mc_filter_type...\n\t * [0] [1] [2] [3] [4] [5]\n\t * 01  AA  00  12  34  56\n\t * LSB                 MSB\n\t *\n\t * case 0: hash_value = ((0x34 >> 4) | (0x56 << 4)) & 0xFFF = 0x563\n\t * case 1: hash_value = ((0x34 >> 3) | (0x56 << 5)) & 0xFFF = 0xAC6\n\t * case 2: hash_value = ((0x34 >> 2) | (0x56 << 6)) & 0xFFF = 0x163\n\t * case 3: hash_value = ((0x34 >> 0) | (0x56 << 8)) & 0xFFF = 0x634\n\t */\n\tswitch (hw->mac.mc_filter_type) {\n\tdefault:\n\tcase 0:\n\t\tbreak;\n\tcase 1:\n\t\tbit_shift += 1;\n\t\tbreak;\n\tcase 2:\n\t\tbit_shift += 2;\n\t\tbreak;\n\tcase 3:\n\t\tbit_shift += 4;\n\t\tbreak;\n\t}\n\n\thash_value = hash_mask & (((mc_addr[4] >> (8 - bit_shift)) |\n\t\t\t\t  (((u16)mc_addr[5]) << bit_shift)));\n\n\treturn hash_value;\n}"
    }
]