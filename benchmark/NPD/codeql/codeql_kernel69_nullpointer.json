[
    {
        "var_name": "skb_prev",
        "function_name": "__ip_append_data",
        "location": {
            "file_path": "net/ipv4/ip_output.c",
            "region": {
                "startLine": 1156,
                "startColumn": 31,
                "endColumn": 39
            },
            "context": {
                "startLine": 1154,
                "endLine": 1158,
                "snippet": {
                    "text": "\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,"
                }
            }
        },
        "function_code": "static int __ip_append_data(struct sock *sk,\n\t\t\t    struct flowi4 *fl4,\n\t\t\t    struct sk_buff_head *queue,\n\t\t\t    struct inet_cork *cork,\n\t\t\t    struct page_frag *pfrag,\n\t\t\t    int getfrag(void *from, char *to, int offset,\n\t\t\t\t\tint len, int odd, struct sk_buff *skb),\n\t\t\t    void *from, int length, int transhdrlen,\n\t\t\t    unsigned int flags)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ubuf_info *uarg = NULL;\n\tstruct sk_buff *skb;\n\tstruct ip_options *opt = cork->opt;\n\tint hh_len;\n\tint exthdrlen;\n\tint mtu;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\tbool zc = false;\n\tunsigned int maxfraglen, fragheaderlen, maxnonfragsize;\n\tint csummode = CHECKSUM_NONE;\n\tstruct rtable *rt = dst_rtable(cork->dst);\n\tbool paged, hold_tskey, extra_uref = false;\n\tunsigned int wmem_alloc_delta = 0;\n\tu32 tskey = 0;\n\n\tskb = skb_peek_tail(queue);\n\n\texthdrlen = !skb ? rt->dst.header_len : 0;\n\tmtu = cork->gso_size ? IP_MAX_MTU : cork->fragsize;\n\tpaged = !!cork->gso_size;\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct iphdr) + (opt ? opt->optlen : 0);\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen;\n\tmaxnonfragsize = ip_sk_ignore_df(sk) ? IP_MAX_MTU : mtu;\n\n\tif (cork->length + length > maxnonfragsize - fragheaderlen) {\n\t\tip_local_error(sk, EMSGSIZE, fl4->daddr, inet->inet_dport,\n\t\t\t       mtu - (opt ? opt->optlen : 0));\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/*\n\t * transhdrlen > 0 means that this is the first fragment and we wish\n\t * it won't be fragmented in the future.\n\t */\n\tif (transhdrlen &&\n\t    length + fragheaderlen <= mtu &&\n\t    rt->dst.dev->features & (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM) &&\n\t    (!(flags & MSG_MORE) || cork->gso_size) &&\n\t    (!exthdrlen || (rt->dst.dev->features & NETIF_F_HW_ESP_TX_CSUM)))\n\t\tcsummode = CHECKSUM_PARTIAL;\n\n\tif ((flags & MSG_ZEROCOPY) && length) {\n\t\tstruct msghdr *msg = from;\n\n\t\tif (getfrag == ip_generic_getfrag && msg->msg_ubuf) {\n\t\t\tif (skb_zcopy(skb) && msg->msg_ubuf != skb_zcopy(skb))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Leave uarg NULL if can't zerocopy, callers should\n\t\t\t * be able to handle it.\n\t\t\t */\n\t\t\tif ((rt->dst.dev->features & NETIF_F_SG) &&\n\t\t\t    csummode == CHECKSUM_PARTIAL) {\n\t\t\t\tpaged = true;\n\t\t\t\tzc = true;\n\t\t\t\tuarg = msg->msg_ubuf;\n\t\t\t}\n\t\t} else if (sock_flag(sk, SOCK_ZEROCOPY)) {\n\t\t\tuarg = msg_zerocopy_realloc(sk, length, skb_zcopy(skb));\n\t\t\tif (!uarg)\n\t\t\t\treturn -ENOBUFS;\n\t\t\textra_uref = !skb_zcopy(skb);\t/* only ref on new uarg */\n\t\t\tif (rt->dst.dev->features & NETIF_F_SG &&\n\t\t\t    csummode == CHECKSUM_PARTIAL) {\n\t\t\t\tpaged = true;\n\t\t\t\tzc = true;\n\t\t\t} else {\n\t\t\t\tuarg_to_msgzc(uarg)->zerocopy = 0;\n\t\t\t\tskb_zcopy_set(skb, uarg, &extra_uref);\n\t\t\t}\n\t\t}\n\t} else if ((flags & MSG_SPLICE_PAGES) && length) {\n\t\tif (inet_test_bit(HDRINCL, sk))\n\t\t\treturn -EPERM;\n\t\tif (rt->dst.dev->features & NETIF_F_SG &&\n\t\t    getfrag == ip_generic_getfrag)\n\t\t\t/* We need an empty buffer to attach stuff to */\n\t\t\tpaged = true;\n\t\telse\n\t\t\tflags &= ~MSG_SPLICE_PAGES;\n\t}\n\n\tcork->length += length;\n\n\thold_tskey = cork->tx_flags & SKBTX_ANY_TSTAMP &&\n\t\t     READ_ONCE(sk->sk_tsflags) & SOF_TIMESTAMPING_OPT_ID;\n\tif (hold_tskey)\n\t\ttskey = atomic_inc_return(&sk->sk_tskey) - 1;\n\n\t/* So, what's going on in the loop below?\n\t *\n\t * We use calculated fragment length to generate chained skb,\n\t * each of segments is IP fragment ready for sending to network after\n\t * adding appropriate IP header.\n\t */\n\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = mtu - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen, alloc_extra;\n\t\t\tunsigned int pagedlen;\n\t\t\tstruct sk_buff *skb_prev;\nalloc_new_skb:\n\t\t\tskb_prev = skb;\n\t\t\tif (skb_prev)\n\t\t\t\tfraggap = skb_prev->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\t\t\tif (datalen > mtu - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen;\n\t\t\tfraglen = datalen + fragheaderlen;\n\t\t\tpagedlen = 0;\n\n\t\t\talloc_extra = hh_len + 15;\n\t\t\talloc_extra += exthdrlen;\n\n\t\t\t/* The last fragment gets additional space at tail.\n\t\t\t * Note, with MSG_MORE we overallocate on fragments,\n\t\t\t * because we have no idea what fragment will be\n\t\t\t * the last.\n\t\t\t */\n\t\t\tif (datalen == length + fraggap)\n\t\t\t\talloc_extra += rt->dst.trailer_len;\n\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse if (!paged &&\n\t\t\t\t (fraglen + alloc_extra < SKB_MAX_ALLOC ||\n\t\t\t\t  !(rt->dst.dev->features & NETIF_F_SG)))\n\t\t\t\talloclen = fraglen;\n\t\t\telse {\n\t\t\t\talloclen = fragheaderlen + transhdrlen;\n\t\t\t\tpagedlen = datalen - transhdrlen;\n\t\t\t}\n\n\t\t\talloclen += alloc_extra;\n\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk, alloclen,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (refcount_read(&sk->sk_wmem_alloc) + wmem_alloc_delta <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = alloc_skb(alloclen,\n\t\t\t\t\t\t\tsk->sk_allocation);\n\t\t\t\tif (unlikely(!skb))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->ip_summed = csummode;\n\t\t\tskb->csum = 0;\n\t\t\tskb_reserve(skb, hh_len);\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes.\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen + exthdrlen - pagedlen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tdata += fragheaderlen + exthdrlen;\n\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\n\t\t\tcopy = datalen - transhdrlen - fraggap - pagedlen;\n\t\t\t/* [!] NOTE: copy will be negative if pagedlen>0\n\t\t\t * because then the equation reduces to -fraggap.\n\t\t\t */\n\t\t\tif (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (flags & MSG_SPLICE_PAGES) {\n\t\t\t\tcopy = 0;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= copy + transhdrlen;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tcsummode = CHECKSUM_NONE;\n\n\t\t\t/* only the initial fragment is time stamped */\n\t\t\tskb_shinfo(skb)->tx_flags = cork->tx_flags;\n\t\t\tcork->tx_flags = 0;\n\t\t\tskb_shinfo(skb)->tskey = tskey;\n\t\t\ttskey = 0;\n\t\t\tskb_zcopy_set(skb, uarg, &extra_uref);\n\n\t\t\tif ((flags & MSG_CONFIRM) && !skb_prev)\n\t\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue.\n\t\t\t */\n\t\t\tif (!skb->destructor) {\n\t\t\t\tskb->destructor = sock_wfree;\n\t\t\t\tskb->sk = sk;\n\t\t\t\twmem_alloc_delta += skb->truesize;\n\t\t\t}\n\t\t\t__skb_queue_tail(queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG) &&\n\t\t    skb_tailroom(skb) >= copy) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else if (flags & MSG_SPLICE_PAGES) {\n\t\t\tstruct msghdr *msg = from;\n\n\t\t\terr = -EIO;\n\t\t\tif (WARN_ON_ONCE(copy > msg->msg_iter.count))\n\t\t\t\tgoto error;\n\n\t\t\terr = skb_splice_from_iter(skb, &msg->msg_iter, copy,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t\tcopy = err;\n\t\t\twmem_alloc_delta += copy;\n\t\t} else if (!zc) {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tskb_zcopy_downgrade_managed(skb);\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb_len_add(skb, copy);\n\t\t\twmem_alloc_delta += copy;\n\t\t} else {\n\t\t\terr = skb_zerocopy_iter_dgram(skb, from, copy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\tif (wmem_alloc_delta)\n\t\trefcount_add(wmem_alloc_delta, &sk->sk_wmem_alloc);\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tnet_zcopy_put_abort(uarg, extra_uref);\n\tcork->length -= length;\n\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTDISCARDS);\n\trefcount_add(wmem_alloc_delta, &sk->sk_wmem_alloc);\n\tif (hold_tskey)\n\t\tatomic_dec(&sk->sk_tskey);\n\treturn err;\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,",
                "condition": [
                    "if (fraggap)",
                    "goto alloc_new_skb"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (skb_prev)",
                "condition": [
                    "while (length > 0)",
                    "if (copy <= 0)"
                ],
                "content": "\t\t\tif (skb_prev)\n\t\t\t\tfraggap = skb_prev->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "return -EMSGSIZE;",
                "condition": [
                    "if (cork->length + length > maxnonfragsize - fragheaderlen)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if ((flags & MSG_ZEROCOPY) && length)",
                    "if (getfrag == ip_generic_getfrag && msg->msg_ubuf)",
                    "if (skb_zcopy(skb) && msg->msg_ubuf != skb_zcopy(skb))"
                ]
            },
            {
                "text": "return -ENOBUFS;",
                "condition": [
                    "if ((flags & MSG_ZEROCOPY) && length)",
                    "if (sock_flag(sk, SOCK_ZEROCOPY))",
                    "if (!uarg)"
                ]
            },
            {
                "text": "return -EPERM;",
                "condition": [
                    "if ((flags & MSG_SPLICE_PAGES) && length)",
                    "if (inet_test_bit(HDRINCL, sk))"
                ]
            },
            {
                "text": "goto error;",
                "condition": [
                    "while (length > 0)",
                    "if (copy <= 0)",
                    "if (!skb)"
                ]
            }
        ],
        "index": 0
    },
    {
        "var_name": "tun_info",
        "function_name": "ip_tunnel_xmit",
        "location": {
            "file_path": "net/ipv4/ip_tunnel.c",
            "region": {
                "startLine": 785,
                "startColumn": 28,
                "endColumn": 36
            },
            "context": {
                "startLine": 783,
                "endLine": 787,
                "snippet": {
                    "text": "\t\t\trt = dst_cache_get_ip4(&tun_info->dst_cache,"
                }
            }
        },
        "function_code": "void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t    const struct iphdr *tnl_params, u8 protocol)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_info *tun_info = NULL;\n\tconst struct iphdr *inner_iph;\n\tunsigned int max_headroom;\t/* The extra header space needed */\n\tstruct rtable *rt = NULL;\t\t/* Route to the other host */\n\t__be16 payload_protocol;\n\tbool use_cache = false;\n\tstruct flowi4 fl4;\n\tbool md = false;\n\tbool connected;\n\tu8 tos, ttl;\n\t__be32 dst;\n\t__be16 df;\n\n\tinner_iph = (const struct iphdr *)skb_inner_network_header(skb);\n\tconnected = (tunnel->parms.iph.daddr != 0);\n\tpayload_protocol = skb_protocol(skb, true);\n\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\n\tdst = tnl_params->daddr;\n\tif (dst == 0) {\n\t\t/* NBMA tunnel */\n\n\t\tif (!skb_dst(skb)) {\n\t\t\tDEV_STATS_INC(dev, tx_fifo_errors);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\ttun_info = skb_tunnel_info(skb);\n\t\tif (tun_info && (tun_info->mode & IP_TUNNEL_INFO_TX) &&\n\t\t    ip_tunnel_info_af(tun_info) == AF_INET &&\n\t\t    tun_info->key.u.ipv4.dst) {\n\t\t\tdst = tun_info->key.u.ipv4.dst;\n\t\t\tmd = true;\n\t\t\tconnected = true;\n\t\t} else if (payload_protocol == htons(ETH_P_IP)) {\n\t\t\trt = skb_rtable(skb);\n\t\t\tdst = rt_nexthop(rt, inner_iph->daddr);\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (payload_protocol == htons(ETH_P_IPV6)) {\n\t\t\tconst struct in6_addr *addr6;\n\t\t\tstruct neighbour *neigh;\n\t\t\tbool do_tx_error_icmp;\n\t\t\tint addr_type;\n\n\t\t\tneigh = dst_neigh_lookup(skb_dst(skb),\n\t\t\t\t\t\t &ipv6_hdr(skb)->daddr);\n\t\t\tif (!neigh)\n\t\t\t\tgoto tx_error;\n\n\t\t\taddr6 = (const struct in6_addr *)&neigh->primary_key;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\t\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\t\t\t\taddr_type = ipv6_addr_type(addr6);\n\t\t\t}\n\n\t\t\tif ((addr_type & IPV6_ADDR_COMPATv4) == 0)\n\t\t\t\tdo_tx_error_icmp = true;\n\t\t\telse {\n\t\t\t\tdo_tx_error_icmp = false;\n\t\t\t\tdst = addr6->s6_addr32[3];\n\t\t\t}\n\t\t\tneigh_release(neigh);\n\t\t\tif (do_tx_error_icmp)\n\t\t\t\tgoto tx_error_icmp;\n\t\t}\n#endif\n\t\telse\n\t\t\tgoto tx_error;\n\n\t\tif (!md)\n\t\t\tconnected = false;\n\t}\n\n\ttos = tnl_params->tos;\n\tif (tos & 0x1) {\n\t\ttos &= ~0x1;\n\t\tif (payload_protocol == htons(ETH_P_IP)) {\n\t\t\ttos = inner_iph->tos;\n\t\t\tconnected = false;\n\t\t} else if (payload_protocol == htons(ETH_P_IPV6)) {\n\t\t\ttos = ipv6_get_dsfield((const struct ipv6hdr *)inner_iph);\n\t\t\tconnected = false;\n\t\t}\n\t}\n\n\tip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,\n\t\t\t    tunnel->parms.o_key, RT_TOS(tos),\n\t\t\t    dev_net(dev), READ_ONCE(tunnel->parms.link),\n\t\t\t    tunnel->fwmark, skb_get_hash(skb), 0);\n\n\tif (ip_tunnel_encap(skb, &tunnel->encap, &protocol, &fl4) < 0)\n\t\tgoto tx_error;\n\n\tif (connected && md) {\n\t\tuse_cache = ip_tunnel_dst_cache_usable(skb, tun_info);\n\t\tif (use_cache)\n\t\t\trt = dst_cache_get_ip4(&tun_info->dst_cache,\n\t\t\t\t\t       &fl4.saddr);\n\t} else {\n\t\trt = connected ? dst_cache_get_ip4(&tunnel->dst_cache,\n\t\t\t\t\t\t&fl4.saddr) : NULL;\n\t}\n\n\tif (!rt) {\n\t\trt = ip_route_output_key(tunnel->net, &fl4);\n\n\t\tif (IS_ERR(rt)) {\n\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\tgoto tx_error;\n\t\t}\n\t\tif (use_cache)\n\t\t\tdst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,\n\t\t\t\t\t  fl4.saddr);\n\t\telse if (!md && connected)\n\t\t\tdst_cache_set_ip4(&tunnel->dst_cache, &rt->dst,\n\t\t\t\t\t  fl4.saddr);\n\t}\n\n\tif (rt->dst.dev == dev) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tgoto tx_error;\n\t}\n\n\tdf = tnl_params->frag_off;\n\tif (payload_protocol == htons(ETH_P_IP) && !tunnel->ignore_df)\n\t\tdf |= (inner_iph->frag_off & htons(IP_DF));\n\n\tif (tnl_update_pmtu(dev, skb, rt, df, inner_iph, 0, 0, false)) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_error;\n\t}\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\ttos = ip_tunnel_ecn_encap(tos, inner_iph, skb);\n\tttl = tnl_params->ttl;\n\tif (ttl == 0) {\n\t\tif (payload_protocol == htons(ETH_P_IP))\n\t\t\tttl = inner_iph->ttl;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (payload_protocol == htons(ETH_P_IPV6))\n\t\t\tttl = ((const struct ipv6hdr *)inner_iph)->hop_limit;\n#endif\n\t\telse\n\t\t\tttl = ip4_dst_hoplimit(&rt->dst);\n\t}\n\n\tmax_headroom = LL_RESERVED_SPACE(rt->dst.dev) + sizeof(struct iphdr)\n\t\t\t+ rt->dst.header_len + ip_encap_hlen(&tunnel->encap);\n\n\tif (skb_cow_head(skb, max_headroom)) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, tx_dropped);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tip_tunnel_adj_headroom(dev, max_headroom);\n\n\tiptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, protocol, tos, ttl,\n\t\t      df, !net_eq(tunnel->net, dev_net(dev)));\n\treturn;\n\n#if IS_ENABLED(CONFIG_IPV6)\ntx_error_icmp:\n\tdst_link_failure(skb);\n#endif\ntx_error:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\trt = dst_cache_get_ip4(&tun_info->dst_cache,",
                "condition": [
                    "if (connected && md)",
                    "if (use_cache)"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct ip_tunnel_info *tun_info = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (dst == 0)",
                    "if (!skb_dst(skb))"
                ]
            },
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (dst == 0)",
                    "if (payload_protocol == htons(ETH_P_IPV6))",
                    "if (!neigh)"
                ]
            },
            {
                "text": "goto tx_error_icmp;",
                "condition": [
                    "if (dst == 0)",
                    "if (payload_protocol == htons(ETH_P_IPV6))",
                    "if (do_tx_error_icmp)"
                ]
            },
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (dst == 0)",
                    "if(!(tun_info && (tun_info->mode & IP_TUNNEL_INFO_TX) && ip_tunnel_info_af(tun_info) == AF_INET && tun_info->key.u.ipv4.dst) && !(payload_protocol == htons(ETH_P_IP)) && !(payload_protocol == htons(ETH_P_IPV6)))"
                ]
            },
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (ip_tunnel_encap(skb, &tunnel->encap, &protocol, &fl4) < 0)"
                ]
            }
        ],
        "index": 1
    },
    {
        "var_name": "tun_info",
        "function_name": "ip_tunnel_xmit",
        "location": {
            "file_path": "net/ipv4/ip_tunnel.c",
            "region": {
                "startLine": 800,
                "startColumn": 23,
                "endColumn": 31
            },
            "context": {
                "startLine": 798,
                "endLine": 802,
                "snippet": {
                    "text": "\t\t\tdst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,"
                }
            }
        },
        "function_code": "void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t    const struct iphdr *tnl_params, u8 protocol)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tstruct ip_tunnel_info *tun_info = NULL;\n\tconst struct iphdr *inner_iph;\n\tunsigned int max_headroom;\t/* The extra header space needed */\n\tstruct rtable *rt = NULL;\t\t/* Route to the other host */\n\t__be16 payload_protocol;\n\tbool use_cache = false;\n\tstruct flowi4 fl4;\n\tbool md = false;\n\tbool connected;\n\tu8 tos, ttl;\n\t__be32 dst;\n\t__be16 df;\n\n\tinner_iph = (const struct iphdr *)skb_inner_network_header(skb);\n\tconnected = (tunnel->parms.iph.daddr != 0);\n\tpayload_protocol = skb_protocol(skb, true);\n\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\n\tdst = tnl_params->daddr;\n\tif (dst == 0) {\n\t\t/* NBMA tunnel */\n\n\t\tif (!skb_dst(skb)) {\n\t\t\tDEV_STATS_INC(dev, tx_fifo_errors);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\ttun_info = skb_tunnel_info(skb);\n\t\tif (tun_info && (tun_info->mode & IP_TUNNEL_INFO_TX) &&\n\t\t    ip_tunnel_info_af(tun_info) == AF_INET &&\n\t\t    tun_info->key.u.ipv4.dst) {\n\t\t\tdst = tun_info->key.u.ipv4.dst;\n\t\t\tmd = true;\n\t\t\tconnected = true;\n\t\t} else if (payload_protocol == htons(ETH_P_IP)) {\n\t\t\trt = skb_rtable(skb);\n\t\t\tdst = rt_nexthop(rt, inner_iph->daddr);\n\t\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (payload_protocol == htons(ETH_P_IPV6)) {\n\t\t\tconst struct in6_addr *addr6;\n\t\t\tstruct neighbour *neigh;\n\t\t\tbool do_tx_error_icmp;\n\t\t\tint addr_type;\n\n\t\t\tneigh = dst_neigh_lookup(skb_dst(skb),\n\t\t\t\t\t\t &ipv6_hdr(skb)->daddr);\n\t\t\tif (!neigh)\n\t\t\t\tgoto tx_error;\n\n\t\t\taddr6 = (const struct in6_addr *)&neigh->primary_key;\n\t\t\taddr_type = ipv6_addr_type(addr6);\n\n\t\t\tif (addr_type == IPV6_ADDR_ANY) {\n\t\t\t\taddr6 = &ipv6_hdr(skb)->daddr;\n\t\t\t\taddr_type = ipv6_addr_type(addr6);\n\t\t\t}\n\n\t\t\tif ((addr_type & IPV6_ADDR_COMPATv4) == 0)\n\t\t\t\tdo_tx_error_icmp = true;\n\t\t\telse {\n\t\t\t\tdo_tx_error_icmp = false;\n\t\t\t\tdst = addr6->s6_addr32[3];\n\t\t\t}\n\t\t\tneigh_release(neigh);\n\t\t\tif (do_tx_error_icmp)\n\t\t\t\tgoto tx_error_icmp;\n\t\t}\n#endif\n\t\telse\n\t\t\tgoto tx_error;\n\n\t\tif (!md)\n\t\t\tconnected = false;\n\t}\n\n\ttos = tnl_params->tos;\n\tif (tos & 0x1) {\n\t\ttos &= ~0x1;\n\t\tif (payload_protocol == htons(ETH_P_IP)) {\n\t\t\ttos = inner_iph->tos;\n\t\t\tconnected = false;\n\t\t} else if (payload_protocol == htons(ETH_P_IPV6)) {\n\t\t\ttos = ipv6_get_dsfield((const struct ipv6hdr *)inner_iph);\n\t\t\tconnected = false;\n\t\t}\n\t}\n\n\tip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,\n\t\t\t    tunnel->parms.o_key, RT_TOS(tos),\n\t\t\t    dev_net(dev), READ_ONCE(tunnel->parms.link),\n\t\t\t    tunnel->fwmark, skb_get_hash(skb), 0);\n\n\tif (ip_tunnel_encap(skb, &tunnel->encap, &protocol, &fl4) < 0)\n\t\tgoto tx_error;\n\n\tif (connected && md) {\n\t\tuse_cache = ip_tunnel_dst_cache_usable(skb, tun_info);\n\t\tif (use_cache)\n\t\t\trt = dst_cache_get_ip4(&tun_info->dst_cache,\n\t\t\t\t\t       &fl4.saddr);\n\t} else {\n\t\trt = connected ? dst_cache_get_ip4(&tunnel->dst_cache,\n\t\t\t\t\t\t&fl4.saddr) : NULL;\n\t}\n\n\tif (!rt) {\n\t\trt = ip_route_output_key(tunnel->net, &fl4);\n\n\t\tif (IS_ERR(rt)) {\n\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\tgoto tx_error;\n\t\t}\n\t\tif (use_cache)\n\t\t\tdst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,\n\t\t\t\t\t  fl4.saddr);\n\t\telse if (!md && connected)\n\t\t\tdst_cache_set_ip4(&tunnel->dst_cache, &rt->dst,\n\t\t\t\t\t  fl4.saddr);\n\t}\n\n\tif (rt->dst.dev == dev) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tgoto tx_error;\n\t}\n\n\tdf = tnl_params->frag_off;\n\tif (payload_protocol == htons(ETH_P_IP) && !tunnel->ignore_df)\n\t\tdf |= (inner_iph->frag_off & htons(IP_DF));\n\n\tif (tnl_update_pmtu(dev, skb, rt, df, inner_iph, 0, 0, false)) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_error;\n\t}\n\n\tif (tunnel->err_count > 0) {\n\t\tif (time_before(jiffies,\n\t\t\t\ttunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\n\t\t\ttunnel->err_count--;\n\n\t\t\tdst_link_failure(skb);\n\t\t} else\n\t\t\ttunnel->err_count = 0;\n\t}\n\n\ttos = ip_tunnel_ecn_encap(tos, inner_iph, skb);\n\tttl = tnl_params->ttl;\n\tif (ttl == 0) {\n\t\tif (payload_protocol == htons(ETH_P_IP))\n\t\t\tttl = inner_iph->ttl;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (payload_protocol == htons(ETH_P_IPV6))\n\t\t\tttl = ((const struct ipv6hdr *)inner_iph)->hop_limit;\n#endif\n\t\telse\n\t\t\tttl = ip4_dst_hoplimit(&rt->dst);\n\t}\n\n\tmax_headroom = LL_RESERVED_SPACE(rt->dst.dev) + sizeof(struct iphdr)\n\t\t\t+ rt->dst.header_len + ip_encap_hlen(&tunnel->encap);\n\n\tif (skb_cow_head(skb, max_headroom)) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, tx_dropped);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tip_tunnel_adj_headroom(dev, max_headroom);\n\n\tiptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, protocol, tos, ttl,\n\t\t      df, !net_eq(tunnel->net, dev_net(dev)));\n\treturn;\n\n#if IS_ENABLED(CONFIG_IPV6)\ntx_error_icmp:\n\tdst_link_failure(skb);\n#endif\ntx_error:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\tdst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,",
                "condition": [
                    "if (!rt)",
                    "if (use_cache)"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct ip_tunnel_info *tun_info = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (dst == 0)",
                    "if (!skb_dst(skb))"
                ]
            },
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (dst == 0)",
                    "if (payload_protocol == htons(ETH_P_IPV6))",
                    "if (!neigh)"
                ]
            },
            {
                "text": "goto tx_error_icmp;",
                "condition": [
                    "if (dst == 0)",
                    "if (payload_protocol == htons(ETH_P_IPV6))",
                    "if (do_tx_error_icmp)"
                ]
            },
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (dst == 0)",
                    "if(!(tun_info && (tun_info->mode & IP_TUNNEL_INFO_TX) && ip_tunnel_info_af(tun_info) == AF_INET && tun_info->key.u.ipv4.dst) && !(payload_protocol == htons(ETH_P_IP)) && !(payload_protocol == htons(ETH_P_IPV6)))"
                ]
            },
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (ip_tunnel_encap(skb, &tunnel->encap, &protocol, &fl4) < 0)"
                ]
            },
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (!rt)",
                    "if (IS_ERR(rt))"
                ]
            }
        ],
        "index": 2
    },
    {
        "var_name": "tun_info",
        "function_name": "ip_md_tunnel_xmit",
        "location": {
            "file_path": "net/ipv4/ip_tunnel.c",
            "region": {
                "startLine": 601,
                "startColumn": 9,
                "endColumn": 17
            },
            "context": {
                "startLine": 599,
                "endLine": 603,
                "snippet": {
                    "text": "\tkey = &tun_info->key;"
                }
            }
        },
        "function_code": "void ip_md_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,\n\t\t       u8 proto, int tunnel_hlen)\n{\n\tstruct ip_tunnel *tunnel = netdev_priv(dev);\n\tu32 headroom = sizeof(struct iphdr);\n\tstruct ip_tunnel_info *tun_info;\n\tconst struct ip_tunnel_key *key;\n\tconst struct iphdr *inner_iph;\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\t__be16 df = 0;\n\tu8 tos, ttl;\n\tbool use_cache;\n\n\ttun_info = skb_tunnel_info(skb);\n\tif (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) ||\n\t\t     ip_tunnel_info_af(tun_info) != AF_INET))\n\t\tgoto tx_error;\n\tkey = &tun_info->key;\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tinner_iph = (const struct iphdr *)skb_inner_network_header(skb);\n\ttos = key->tos;\n\tif (tos == 1) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\ttos = inner_iph->tos;\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\ttos = ipv6_get_dsfield((const struct ipv6hdr *)inner_iph);\n\t}\n\tip_tunnel_init_flow(&fl4, proto, key->u.ipv4.dst, key->u.ipv4.src,\n\t\t\t    tunnel_id_to_key32(key->tun_id), RT_TOS(tos),\n\t\t\t    dev_net(dev), 0, skb->mark, skb_get_hash(skb),\n\t\t\t    key->flow_flags);\n\n\tif (!tunnel_hlen)\n\t\ttunnel_hlen = ip_encap_hlen(&tun_info->encap);\n\n\tif (ip_tunnel_encap(skb, &tun_info->encap, &proto, &fl4) < 0)\n\t\tgoto tx_error;\n\n\tuse_cache = ip_tunnel_dst_cache_usable(skb, tun_info);\n\tif (use_cache)\n\t\trt = dst_cache_get_ip4(&tun_info->dst_cache, &fl4.saddr);\n\tif (!rt) {\n\t\trt = ip_route_output_key(tunnel->net, &fl4);\n\t\tif (IS_ERR(rt)) {\n\t\t\tDEV_STATS_INC(dev, tx_carrier_errors);\n\t\t\tgoto tx_error;\n\t\t}\n\t\tif (use_cache)\n\t\t\tdst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,\n\t\t\t\t\t  fl4.saddr);\n\t}\n\tif (rt->dst.dev == dev) {\n\t\tip_rt_put(rt);\n\t\tDEV_STATS_INC(dev, collisions);\n\t\tgoto tx_error;\n\t}\n\n\tif (key->tun_flags & TUNNEL_DONT_FRAGMENT)\n\t\tdf = htons(IP_DF);\n\tif (tnl_update_pmtu(dev, skb, rt, df, inner_iph, tunnel_hlen,\n\t\t\t    key->u.ipv4.dst, true)) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_error;\n\t}\n\n\ttos = ip_tunnel_ecn_encap(tos, inner_iph, skb);\n\tttl = key->ttl;\n\tif (ttl == 0) {\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tttl = inner_iph->ttl;\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tttl = ((const struct ipv6hdr *)inner_iph)->hop_limit;\n\t\telse\n\t\t\tttl = ip4_dst_hoplimit(&rt->dst);\n\t}\n\n\theadroom += LL_RESERVED_SPACE(rt->dst.dev) + rt->dst.header_len;\n\tif (skb_cow_head(skb, headroom)) {\n\t\tip_rt_put(rt);\n\t\tgoto tx_dropped;\n\t}\n\n\tip_tunnel_adj_headroom(dev, headroom);\n\n\tiptunnel_xmit(NULL, rt, skb, fl4.saddr, fl4.daddr, proto, tos, ttl,\n\t\t      df, !net_eq(tunnel->net, dev_net(dev)));\n\treturn;\ntx_error:\n\tDEV_STATS_INC(dev, tx_errors);\n\tgoto kfree;\ntx_dropped:\n\tDEV_STATS_INC(dev, tx_dropped);\nkfree:\n\tkfree_skb(skb);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkey = &tun_info->key;",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto tx_error;",
                "condition": [
                    "if (unlikely(!tun_info || !(tun_info->mode & IP_TUNNEL_INFO_TX) || ip_tunnel_info_af(tun_info) != AF_INET))"
                ]
            }
        ],
        "index": 3
    },
    {
        "var_name": "skb",
        "function_name": "ipmr_rtm_getroute",
        "location": {
            "file_path": "net/ipv4/ipmr.c",
            "region": {
                "startLine": 2586,
                "startColumn": 12,
                "endColumn": 15
            },
            "context": {
                "startLine": 2584,
                "endLine": 2588,
                "snippet": {
                    "text": "\tkfree_skb(skb);"
                }
            }
        },
        "function_code": "static int ipmr_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct nlattr *tb[RTA_MAX + 1];\n\tstruct sk_buff *skb = NULL;\n\tstruct mfc_cache *cache;\n\tstruct mr_table *mrt;\n\t__be32 src, grp;\n\tu32 tableid;\n\tint err;\n\n\terr = ipmr_rtm_valid_getroute_req(in_skb, nlh, tb, extack);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tsrc = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;\n\tgrp = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;\n\ttableid = tb[RTA_TABLE] ? nla_get_u32(tb[RTA_TABLE]) : 0;\n\n\tmrt = ipmr_get_table(net, tableid ? tableid : RT_TABLE_DEFAULT);\n\tif (!mrt) {\n\t\terr = -ENOENT;\n\t\tgoto errout_free;\n\t}\n\n\t/* entries are added/deleted only under RTNL */\n\trcu_read_lock();\n\tcache = ipmr_cache_find(mrt, src, grp);\n\trcu_read_unlock();\n\tif (!cache) {\n\t\terr = -ENOENT;\n\t\tgoto errout_free;\n\t}\n\n\tskb = nlmsg_new(mroute_msgsize(false, mrt->maxvif), GFP_KERNEL);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto errout_free;\n\t}\n\n\terr = ipmr_fill_mroute(mrt, skb, NETLINK_CB(in_skb).portid,\n\t\t\t       nlh->nlmsg_seq, cache,\n\t\t\t       RTM_NEWROUTE, 0);\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\n\nerrout:\n\treturn err;\n\nerrout_free:\n\tkfree_skb(skb);\n\tgoto errout;\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree_skb(skb);",
                "condition": [
                    "goto errout_free"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct sk_buff *skb = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto errout;",
                "condition": [
                    "if (err < 0)"
                ]
            }
        ],
        "index": 4
    },
    {
        "var_name": "skb",
        "function_name": "igmpmsg_netlink_event",
        "location": {
            "file_path": "net/ipv4/ipmr.c",
            "region": {
                "startLine": 2474,
                "startColumn": 12,
                "endColumn": 15
            },
            "context": {
                "startLine": 2472,
                "endLine": 2476,
                "snippet": {
                    "text": "\tkfree_skb(skb);"
                }
            }
        },
        "function_code": "static void igmpmsg_netlink_event(const struct mr_table *mrt, struct sk_buff *pkt)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct nlmsghdr *nlh;\n\tstruct rtgenmsg *rtgenm;\n\tstruct igmpmsg *msg;\n\tstruct sk_buff *skb;\n\tstruct nlattr *nla;\n\tint payloadlen;\n\n\tpayloadlen = pkt->len - sizeof(struct igmpmsg);\n\tmsg = (struct igmpmsg *)skb_network_header(pkt);\n\n\tskb = nlmsg_new(igmpmsg_netlink_msgsize(payloadlen), GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\tnlh = nlmsg_put(skb, 0, 0, RTM_NEWCACHEREPORT,\n\t\t\tsizeof(struct rtgenmsg), 0);\n\tif (!nlh)\n\t\tgoto errout;\n\trtgenm = nlmsg_data(nlh);\n\trtgenm->rtgen_family = RTNL_FAMILY_IPMR;\n\tif (nla_put_u8(skb, IPMRA_CREPORT_MSGTYPE, msg->im_msgtype) ||\n\t    nla_put_u32(skb, IPMRA_CREPORT_VIF_ID, msg->im_vif | (msg->im_vif_hi << 8)) ||\n\t    nla_put_in_addr(skb, IPMRA_CREPORT_SRC_ADDR,\n\t\t\t    msg->im_src.s_addr) ||\n\t    nla_put_in_addr(skb, IPMRA_CREPORT_DST_ADDR,\n\t\t\t    msg->im_dst.s_addr) ||\n\t    nla_put_u32(skb, IPMRA_CREPORT_TABLE, mrt->id))\n\t\tgoto nla_put_failure;\n\n\tnla = nla_reserve(skb, IPMRA_CREPORT_PKT, payloadlen);\n\tif (!nla || skb_copy_bits(pkt, sizeof(struct igmpmsg),\n\t\t\t\t  nla_data(nla), payloadlen))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_MROUTE_R, NULL, GFP_ATOMIC);\n\treturn;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\nerrout:\n\tkfree_skb(skb);\n\trtnl_set_sk_err(net, RTNLGRP_IPV4_MROUTE_R, -ENOBUFS);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree_skb(skb);",
                "condition": [
                    "goto errout"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto nla_put_failure;",
                "condition": [
                    "if (nla_put_u8(skb, IPMRA_CREPORT_MSGTYPE, msg->im_msgtype) || nla_put_u32(skb, IPMRA_CREPORT_VIF_ID, msg->im_vif | (msg->im_vif_hi << 8)) || nla_put_in_addr(skb, IPMRA_CREPORT_SRC_ADDR, msg->im_src.s_addr) || nla_put_in_addr(skb, IPMRA_CREPORT_DST_ADDR, msg->im_dst.s_addr) || nla_put_u32(skb, IPMRA_CREPORT_TABLE, mrt->id))"
                ]
            },
            {
                "text": "goto nla_put_failure;",
                "condition": [
                    "if (!nla || skb_copy_bits(pkt, sizeof(struct igmpmsg), nla_data(nla), payloadlen))"
                ]
            }
        ],
        "index": 5
    },
    {
        "var_name": "skb",
        "function_name": "mroute_netlink_event",
        "location": {
            "file_path": "net/ipv4/ipmr.c",
            "region": {
                "startLine": 2408,
                "startColumn": 12,
                "endColumn": 15
            },
            "context": {
                "startLine": 2406,
                "endLine": 2410,
                "snippet": {
                    "text": "\tkfree_skb(skb);"
                }
            }
        },
        "function_code": "static void mroute_netlink_event(struct mr_table *mrt, struct mfc_cache *mfc,\n\t\t\t\t int cmd)\n{\n\tstruct net *net = read_pnet(&mrt->net);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(mroute_msgsize(mfc->_c.mfc_parent >= MAXVIFS,\n\t\t\t\t       mrt->maxvif),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = ipmr_fill_mroute(mrt, skb, 0, 0, mfc, cmd, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV4_MROUTE, NULL, GFP_ATOMIC);\n\treturn;\n\nerrout:\n\tkfree_skb(skb);\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV4_MROUTE, err);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree_skb(skb);",
                "condition": [
                    "goto errout"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [],
        "index": 6
    },
    {
        "var_name": "nhe",
        "function_name": "nexthop_create_group",
        "location": {
            "file_path": "net/ipv4/nexthop.c",
            "region": {
                "startLine": 2698,
                "startColumn": 20,
                "endColumn": 23
            },
            "context": {
                "startLine": 2696,
                "endLine": 2700,
                "snippet": {
                    "text": "\t\tif (!nexthop_get(nhe)) {"
                }
            }
        },
        "function_code": "static struct nexthop *nexthop_create_group(struct net *net,\n\t\t\t\t\t    struct nh_config *cfg)\n{\n\tstruct nlattr *grps_attr = cfg->nh_grp;\n\tstruct nexthop_grp *entry = nla_data(grps_attr);\n\tu16 num_nh = nla_len(grps_attr) / sizeof(*entry);\n\tstruct nh_group *nhg;\n\tstruct nexthop *nh;\n\tint err;\n\tint i;\n\n\tif (WARN_ON(!num_nh))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnh = nexthop_alloc();\n\tif (!nh)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnh->is_group = 1;\n\n\tnhg = nexthop_grp_alloc(num_nh);\n\tif (!nhg) {\n\t\tkfree(nh);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* spare group used for removals */\n\tnhg->spare = nexthop_grp_alloc(num_nh);\n\tif (!nhg->spare) {\n\t\tkfree(nhg);\n\t\tkfree(nh);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnhg->spare->spare = nhg;\n\n\tfor (i = 0; i < nhg->num_nh; ++i) {\n\t\tstruct nexthop *nhe;\n\t\tstruct nh_info *nhi;\n\n\t\tnhe = nexthop_find_by_id(net, entry[i].id);\n\t\tif (!nexthop_get(nhe)) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto out_no_nh;\n\t\t}\n\n\t\tnhi = rtnl_dereference(nhe->nh_info);\n\t\tif (nhi->family == AF_INET)\n\t\t\tnhg->has_v4 = true;\n\n\t\tnhg->nh_entries[i].stats =\n\t\t\tnetdev_alloc_pcpu_stats(struct nh_grp_entry_stats);\n\t\tif (!nhg->nh_entries[i].stats) {\n\t\t\terr = -ENOMEM;\n\t\t\tnexthop_put(nhe);\n\t\t\tgoto out_no_nh;\n\t\t}\n\t\tnhg->nh_entries[i].nh = nhe;\n\t\tnhg->nh_entries[i].weight = entry[i].weight + 1;\n\t\tlist_add(&nhg->nh_entries[i].nh_list, &nhe->grp_list);\n\t\tnhg->nh_entries[i].nh_parent = nh;\n\t}\n\n\tif (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_MPATH) {\n\t\tnhg->hash_threshold = 1;\n\t\tnhg->is_multipath = true;\n\t} else if (cfg->nh_grp_type == NEXTHOP_GRP_TYPE_RES) {\n\t\tstruct nh_res_table *res_table;\n\n\t\tres_table = nexthop_res_table_alloc(net, cfg->nh_id, cfg);\n\t\tif (!res_table) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_no_nh;\n\t\t}\n\n\t\trcu_assign_pointer(nhg->spare->res_table, res_table);\n\t\trcu_assign_pointer(nhg->res_table, res_table);\n\t\tnhg->resilient = true;\n\t\tnhg->is_multipath = true;\n\t}\n\n\tWARN_ON_ONCE(nhg->hash_threshold + nhg->resilient != 1);\n\n\tif (nhg->hash_threshold)\n\t\tnh_hthr_group_rebalance(nhg);\n\n\tif (cfg->nh_fdb)\n\t\tnhg->fdb_nh = 1;\n\n\tif (cfg->nh_hw_stats)\n\t\tnhg->hw_stats = true;\n\n\trcu_assign_pointer(nh->nh_grp, nhg);\n\n\treturn nh;\n\nout_no_nh:\n\tfor (i--; i >= 0; --i) {\n\t\tlist_del(&nhg->nh_entries[i].nh_list);\n\t\tfree_percpu(nhg->nh_entries[i].stats);\n\t\tnexthop_put(nhg->nh_entries[i].nh);\n\t}\n\n\tkfree(nhg->spare);\n\tkfree(nhg);\n\tkfree(nh);\n\n\treturn ERR_PTR(err);\n}",
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\tif (!nexthop_get(nhe)) {",
                "condition": [
                    "for (i = 0; i < nhg->num_nh; ++i)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return ERR_PTR(-EINVAL);",
                "condition": [
                    "if (WARN_ON(!num_nh))"
                ]
            },
            {
                "text": "return ERR_PTR(-ENOMEM);",
                "condition": [
                    "if (!nh)"
                ]
            },
            {
                "text": "return ERR_PTR(-ENOMEM);",
                "condition": [
                    "if (!nhg)"
                ]
            },
            {
                "text": "return ERR_PTR(-ENOMEM);",
                "condition": [
                    "if (!nhg->spare)"
                ]
            }
        ],
        "index": 7
    },
    {
        "var_name": "dev_out",
        "function_name": "ip_route_output_key_hash_rcu",
        "location": {
            "file_path": "net/ipv4/route.c",
            "region": {
                "startLine": 2808,
                "startColumn": 45,
                "endColumn": 52
            },
            "context": {
                "startLine": 2806,
                "endLine": 2810,
                "snippet": {
                    "text": "\trth = __mkroute_output(res, fl4, orig_oif, dev_out, flags);"
                }
            }
        },
        "function_code": "struct rtable *ip_route_output_key_hash_rcu(struct net *net, struct flowi4 *fl4,\n\t\t\t\t\t    struct fib_result *res,\n\t\t\t\t\t    const struct sk_buff *skb)\n{\n\tstruct net_device *dev_out = NULL;\n\tint orig_oif = fl4->flowi4_oif;\n\tunsigned int flags = 0;\n\tstruct rtable *rth;\n\tint err;\n\n\tif (fl4->saddr) {\n\t\tif (ipv4_is_multicast(fl4->saddr) ||\n\t\t    ipv4_is_lbcast(fl4->saddr) ||\n\t\t    ipv4_is_zeronet(fl4->saddr)) {\n\t\t\trth = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\n\t\trth = ERR_PTR(-ENETUNREACH);\n\n\t\t/* I removed check for oif == dev_out->oif here.\n\t\t * It was wrong for two reasons:\n\t\t * 1. ip_dev_find(net, saddr) can return wrong iface, if saddr\n\t\t *    is assigned to multiple interfaces.\n\t\t * 2. Moreover, we are allowed to send packets with saddr\n\t\t *    of another iface. --ANK\n\t\t */\n\n\t\tif (fl4->flowi4_oif == 0 &&\n\t\t    (ipv4_is_multicast(fl4->daddr) ||\n\t\t     ipv4_is_lbcast(fl4->daddr))) {\n\t\t\t/* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */\n\t\t\tdev_out = __ip_dev_find(net, fl4->saddr, false);\n\t\t\tif (!dev_out)\n\t\t\t\tgoto out;\n\n\t\t\t/* Special hack: user can direct multicasts\n\t\t\t * and limited broadcast via necessary interface\n\t\t\t * without fiddling with IP_MULTICAST_IF or IP_PKTINFO.\n\t\t\t * This hack is not just for fun, it allows\n\t\t\t * vic,vat and friends to work.\n\t\t\t * They bind socket to loopback, set ttl to zero\n\t\t\t * and expect that it will work.\n\t\t\t * From the viewpoint of routing cache they are broken,\n\t\t\t * because we are not allowed to build multicast path\n\t\t\t * with loopback source addr (look, routing cache\n\t\t\t * cannot know, that ttl is zero, so that packet\n\t\t\t * will not leave this host and route is valid).\n\t\t\t * Luckily, this hack is good workaround.\n\t\t\t */\n\n\t\t\tfl4->flowi4_oif = dev_out->ifindex;\n\t\t\tgoto make_route;\n\t\t}\n\n\t\tif (!(fl4->flowi4_flags & FLOWI_FLAG_ANYSRC)) {\n\t\t\t/* It is equivalent to inet_addr_type(saddr) == RTN_LOCAL */\n\t\t\tif (!__ip_dev_find(net, fl4->saddr, false))\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\n\tif (fl4->flowi4_oif) {\n\t\tdev_out = dev_get_by_index_rcu(net, fl4->flowi4_oif);\n\t\trth = ERR_PTR(-ENODEV);\n\t\tif (!dev_out)\n\t\t\tgoto out;\n\n\t\t/* RACE: Check return value of inet_select_addr instead. */\n\t\tif (!(dev_out->flags & IFF_UP) || !__in_dev_get_rcu(dev_out)) {\n\t\t\trth = ERR_PTR(-ENETUNREACH);\n\t\t\tgoto out;\n\t\t}\n\t\tif (ipv4_is_local_multicast(fl4->daddr) ||\n\t\t    ipv4_is_lbcast(fl4->daddr) ||\n\t\t    fl4->flowi4_proto == IPPROTO_IGMP) {\n\t\t\tif (!fl4->saddr)\n\t\t\t\tfl4->saddr = inet_select_addr(dev_out, 0,\n\t\t\t\t\t\t\t      RT_SCOPE_LINK);\n\t\t\tgoto make_route;\n\t\t}\n\t\tif (!fl4->saddr) {\n\t\t\tif (ipv4_is_multicast(fl4->daddr))\n\t\t\t\tfl4->saddr = inet_select_addr(dev_out, 0,\n\t\t\t\t\t\t\t      fl4->flowi4_scope);\n\t\t\telse if (!fl4->daddr)\n\t\t\t\tfl4->saddr = inet_select_addr(dev_out, 0,\n\t\t\t\t\t\t\t      RT_SCOPE_HOST);\n\t\t}\n\t}\n\n\tif (!fl4->daddr) {\n\t\tfl4->daddr = fl4->saddr;\n\t\tif (!fl4->daddr)\n\t\t\tfl4->daddr = fl4->saddr = htonl(INADDR_LOOPBACK);\n\t\tdev_out = net->loopback_dev;\n\t\tfl4->flowi4_oif = LOOPBACK_IFINDEX;\n\t\tres->type = RTN_LOCAL;\n\t\tflags |= RTCF_LOCAL;\n\t\tgoto make_route;\n\t}\n\n\terr = fib_lookup(net, fl4, res, 0);\n\tif (err) {\n\t\tres->fi = NULL;\n\t\tres->table = NULL;\n\t\tif (fl4->flowi4_oif &&\n\t\t    (ipv4_is_multicast(fl4->daddr) || !fl4->flowi4_l3mdev)) {\n\t\t\t/* Apparently, routing tables are wrong. Assume,\n\t\t\t * that the destination is on link.\n\t\t\t *\n\t\t\t * WHY? DW.\n\t\t\t * Because we are allowed to send to iface\n\t\t\t * even if it has NO routes and NO assigned\n\t\t\t * addresses. When oif is specified, routing\n\t\t\t * tables are looked up with only one purpose:\n\t\t\t * to catch if destination is gatewayed, rather than\n\t\t\t * direct. Moreover, if MSG_DONTROUTE is set,\n\t\t\t * we send packet, ignoring both routing tables\n\t\t\t * and ifaddr state. --ANK\n\t\t\t *\n\t\t\t *\n\t\t\t * We could make it even if oif is unknown,\n\t\t\t * likely IPv6, but we do not.\n\t\t\t */\n\n\t\t\tif (fl4->saddr == 0)\n\t\t\t\tfl4->saddr = inet_select_addr(dev_out, 0,\n\t\t\t\t\t\t\t      RT_SCOPE_LINK);\n\t\t\tres->type = RTN_UNICAST;\n\t\t\tgoto make_route;\n\t\t}\n\t\trth = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\tif (res->type == RTN_LOCAL) {\n\t\tif (!fl4->saddr) {\n\t\t\tif (res->fi->fib_prefsrc)\n\t\t\t\tfl4->saddr = res->fi->fib_prefsrc;\n\t\t\telse\n\t\t\t\tfl4->saddr = fl4->daddr;\n\t\t}\n\n\t\t/* L3 master device is the loopback for that domain */\n\t\tdev_out = l3mdev_master_dev_rcu(FIB_RES_DEV(*res)) ? :\n\t\t\tnet->loopback_dev;\n\n\t\t/* make sure orig_oif points to fib result device even\n\t\t * though packet rx/tx happens over loopback or l3mdev\n\t\t */\n\t\torig_oif = FIB_RES_OIF(*res);\n\n\t\tfl4->flowi4_oif = dev_out->ifindex;\n\t\tflags |= RTCF_LOCAL;\n\t\tgoto make_route;\n\t}\n\n\tfib_select_path(net, res, fl4, skb);\n\n\tdev_out = FIB_RES_DEV(*res);\n\nmake_route:\n\trth = __mkroute_output(res, fl4, orig_oif, dev_out, flags);\n\nout:\n\treturn rth;\n}",
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\trth = __mkroute_output(res, fl4, orig_oif, dev_out, flags);",
                "condition": [
                    "goto make_route"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct net_device *dev_out = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto out;",
                "condition": [
                    "if (fl4->saddr)",
                    "if (ipv4_is_multicast(fl4->saddr) || ipv4_is_lbcast(fl4->saddr) || ipv4_is_zeronet(fl4->saddr))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (fl4->saddr)",
                    "if (fl4->flowi4_oif == 0 && (ipv4_is_multicast(fl4->daddr) || ipv4_is_lbcast(fl4->daddr)))",
                    "if (!dev_out)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (fl4->saddr)",
                    "if (!(fl4->flowi4_flags & FLOWI_FLAG_ANYSRC))",
                    "if (!__ip_dev_find(net, fl4->saddr, false))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (fl4->flowi4_oif)",
                    "if (!dev_out)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (fl4->flowi4_oif)",
                    "if (!(dev_out->flags & IFF_UP) || !__in_dev_get_rcu(dev_out))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (err)"
                ]
            }
        ],
        "index": 11
    },
    {
        "var_name": "skb",
        "function_name": "tcp_sendmsg_locked",
        "location": {
            "file_path": "net/ipv4/tcp.c",
            "region": {
                "startLine": 1248,
                "startColumn": 37,
                "endColumn": 40
            },
            "context": {
                "startLine": 1246,
                "endLine": 1250,
                "snippet": {
                    "text": "\t\t\tif (tcp_downgrade_zcopy_pure(sk, skb))"
                }
            }
        },
        "function_code": "int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct ubuf_info *uarg = NULL;\n\tstruct sk_buff *skb;\n\tstruct sockcm_cookie sockc;\n\tint flags, err, copied = 0;\n\tint mss_now = 0, size_goal, copied_syn = 0;\n\tint process_backlog = 0;\n\tint zc = 0;\n\tlong timeo;\n\n\tflags = msg->msg_flags;\n\n\tif ((flags & MSG_ZEROCOPY) && size) {\n\t\tif (msg->msg_ubuf) {\n\t\t\tuarg = msg->msg_ubuf;\n\t\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\t\tzc = MSG_ZEROCOPY;\n\t\t} else if (sock_flag(sk, SOCK_ZEROCOPY)) {\n\t\t\tskb = tcp_write_queue_tail(sk);\n\t\t\tuarg = msg_zerocopy_realloc(sk, size, skb_zcopy(skb));\n\t\t\tif (!uarg) {\n\t\t\t\terr = -ENOBUFS;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\t\tzc = MSG_ZEROCOPY;\n\t\t\telse\n\t\t\t\tuarg_to_msgzc(uarg)->zerocopy = 0;\n\t\t}\n\t} else if (unlikely(msg->msg_flags & MSG_SPLICE_PAGES) && size) {\n\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\tzc = MSG_SPLICE_PAGES;\n\t}\n\n\tif (unlikely(flags & MSG_FASTOPEN ||\n\t\t     inet_test_bit(DEFER_CONNECT, sk)) &&\n\t    !tp->repair) {\n\t\terr = tcp_sendmsg_fastopen(sk, msg, &copied_syn, size, uarg);\n\t\tif (err == -EINPROGRESS && copied_syn > 0)\n\t\t\tgoto out;\n\t\telse if (err)\n\t\t\tgoto out_err;\n\t}\n\n\ttimeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);\n\n\ttcp_rate_check_app_limited(sk);  /* is sending application-limited? */\n\n\t/* Wait for a connection to finish. One exception is TCP Fast Open\n\t * (passive side) where data is allowed to be sent before a connection\n\t * is fully established.\n\t */\n\tif (((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &&\n\t    !tcp_passive_fastopen(sk)) {\n\t\terr = sk_stream_wait_connect(sk, &timeo);\n\t\tif (err != 0)\n\t\t\tgoto do_error;\n\t}\n\n\tif (unlikely(tp->repair)) {\n\t\tif (tp->repair_queue == TCP_RECV_QUEUE) {\n\t\t\tcopied = tcp_send_rcvq(sk, msg, size);\n\t\t\tgoto out_nopush;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (tp->repair_queue == TCP_NO_QUEUE)\n\t\t\tgoto out_err;\n\n\t\t/* 'common' sending to sendq */\n\t}\n\n\tsockcm_init(&sockc, sk);\n\tif (msg->msg_controllen) {\n\t\terr = sock_cmsg_send(sk, msg, &sockc);\n\t\tif (unlikely(err)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t/* This should be in poll */\n\tsk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\t/* Ok commence sending. */\n\tcopied = 0;\n\nrestart:\n\tmss_now = tcp_send_mss(sk, &size_goal, flags);\n\n\terr = -EPIPE;\n\tif (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))\n\t\tgoto do_error;\n\n\twhile (msg_data_left(msg)) {\n\t\tssize_t copy = 0;\n\n\t\tskb = tcp_write_queue_tail(sk);\n\t\tif (skb)\n\t\t\tcopy = size_goal - skb->len;\n\n\t\tif (copy <= 0 || !tcp_skb_can_collapse_to(skb)) {\n\t\t\tbool first_skb;\n\nnew_segment:\n\t\t\tif (!sk_stream_memory_free(sk))\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tif (unlikely(process_backlog >= 16)) {\n\t\t\t\tprocess_backlog = 0;\n\t\t\t\tif (sk_flush_backlog(sk))\n\t\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tfirst_skb = tcp_rtx_and_write_queues_empty(sk);\n\t\t\tskb = tcp_stream_alloc_skb(sk, sk->sk_allocation,\n\t\t\t\t\t\t   first_skb);\n\t\t\tif (!skb)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tprocess_backlog++;\n\n#ifdef CONFIG_SKB_DECRYPTED\n\t\t\tskb->decrypted = !!(flags & MSG_SENDPAGE_DECRYPTED);\n#endif\n\t\t\ttcp_skb_entail(sk, skb);\n\t\t\tcopy = size_goal;\n\n\t\t\t/* All packets are restored as if they have\n\t\t\t * already been sent. skb_mstamp_ns isn't set to\n\t\t\t * avoid wrong rtt estimation.\n\t\t\t */\n\t\t\tif (tp->repair)\n\t\t\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_REPAIRED;\n\t\t}\n\n\t\t/* Try to append data to the end of skb. */\n\t\tif (copy > msg_data_left(msg))\n\t\t\tcopy = msg_data_left(msg);\n\n\t\tif (zc == 0) {\n\t\t\tbool merge = true;\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\tif (i >= READ_ONCE(sysctl_max_skb_frags)) {\n\t\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\t\tgoto new_segment;\n\t\t\t\t}\n\t\t\t\tmerge = false;\n\t\t\t}\n\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\n\t\t\tif (unlikely(skb_zcopy_pure(skb) || skb_zcopy_managed(skb))) {\n\t\t\t\tif (tcp_downgrade_zcopy_pure(sk, skb))\n\t\t\t\t\tgoto wait_for_space;\n\t\t\t\tskb_zcopy_downgrade_managed(skb);\n\t\t\t}\n\n\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\tif (!copy)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\terr = skb_copy_to_page_nocache(sk, &msg->msg_iter, skb,\n\t\t\t\t\t\t       pfrag->page,\n\t\t\t\t\t\t       pfrag->offset,\n\t\t\t\t\t\t       copy);\n\t\t\tif (err)\n\t\t\t\tgoto do_error;\n\n\t\t\t/* Update the skb. */\n\t\t\tif (merge) {\n\t\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\t} else {\n\t\t\t\tskb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t   pfrag->offset, copy);\n\t\t\t\tpage_ref_inc(pfrag->page);\n\t\t\t}\n\t\t\tpfrag->offset += copy;\n\t\t} else if (zc == MSG_ZEROCOPY)  {\n\t\t\t/* First append to a fragless skb builds initial\n\t\t\t * pure zerocopy skb\n\t\t\t */\n\t\t\tif (!skb->len)\n\t\t\t\tskb_shinfo(skb)->flags |= SKBFL_PURE_ZEROCOPY;\n\n\t\t\tif (!skb_zcopy_pure(skb)) {\n\t\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\t\tif (!copy)\n\t\t\t\t\tgoto wait_for_space;\n\t\t\t}\n\n\t\t\terr = skb_zerocopy_iter_stream(sk, skb, msg, copy, uarg);\n\t\t\tif (err == -EMSGSIZE || err == -EEXIST) {\n\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\tgoto new_segment;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tgoto do_error;\n\t\t\tcopy = err;\n\t\t} else if (zc == MSG_SPLICE_PAGES) {\n\t\t\t/* Splice in data if we can; copy if we can't. */\n\t\t\tif (tcp_downgrade_zcopy_pure(sk, skb))\n\t\t\t\tgoto wait_for_space;\n\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\tif (!copy)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\terr = skb_splice_from_iter(skb, &msg->msg_iter, copy,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (err < 0) {\n\t\t\t\tif (err == -EMSGSIZE) {\n\t\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\t\tgoto new_segment;\n\t\t\t\t}\n\t\t\t\tgoto do_error;\n\t\t\t}\n\t\t\tcopy = err;\n\n\t\t\tif (!(flags & MSG_NO_SHARED_FRAGS))\n\t\t\t\tskb_shinfo(skb)->flags |= SKBFL_SHARED_FRAG;\n\n\t\t\tsk_wmem_queued_add(sk, copy);\n\t\t\tsk_mem_charge(sk, copy);\n\t\t}\n\n\t\tif (!copied)\n\t\t\tTCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_PSH;\n\n\t\tWRITE_ONCE(tp->write_seq, tp->write_seq + copy);\n\t\tTCP_SKB_CB(skb)->end_seq += copy;\n\t\ttcp_skb_pcount_set(skb, 0);\n\n\t\tcopied += copy;\n\t\tif (!msg_data_left(msg)) {\n\t\t\tif (unlikely(flags & MSG_EOR))\n\t\t\t\tTCP_SKB_CB(skb)->eor = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (skb->len < size_goal || (flags & MSG_OOB) || unlikely(tp->repair))\n\t\t\tcontinue;\n\n\t\tif (forced_push(tp)) {\n\t\t\ttcp_mark_push(tp, skb);\n\t\t\t__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);\n\t\t} else if (skb == tcp_send_head(sk))\n\t\t\ttcp_push_one(sk, mss_now);\n\t\tcontinue;\n\nwait_for_space:\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\ttcp_remove_empty_skb(sk);\n\t\tif (copied)\n\t\t\ttcp_push(sk, flags & ~MSG_MORE, mss_now,\n\t\t\t\t TCP_NAGLE_PUSH, size_goal);\n\n\t\terr = sk_stream_wait_memory(sk, &timeo);\n\t\tif (err != 0)\n\t\t\tgoto do_error;\n\n\t\tmss_now = tcp_send_mss(sk, &size_goal, flags);\n\t}\n\nout:\n\tif (copied) {\n\t\ttcp_tx_timestamp(sk, sockc.tsflags);\n\t\ttcp_push(sk, flags, mss_now, tp->nonagle, size_goal);\n\t}\nout_nopush:\n\t/* msg->msg_ubuf is pinned by the caller so we don't take extra refs */\n\tif (uarg && !msg->msg_ubuf)\n\t\tnet_zcopy_put(uarg);\n\treturn copied + copied_syn;\n\ndo_error:\n\ttcp_remove_empty_skb(sk);\n\n\tif (copied + copied_syn)\n\t\tgoto out;\nout_err:\n\t/* msg->msg_ubuf is pinned by the caller so we don't take extra refs */\n\tif (uarg && !msg->msg_ubuf)\n\t\tnet_zcopy_put_abort(uarg, true);\n\terr = sk_stream_error(sk, flags, err);\n\t/* make sure we wake any epoll edge trigger waiter */\n\tif (unlikely(tcp_rtx_and_write_queues_empty(sk) && err == -EAGAIN)) {\n\t\tsk->sk_write_space(sk);\n\t\ttcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);\n\t}\n\treturn err;\n}",
        "function_list": [
            "tcp_write_queue_tail"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\t\tif (tcp_downgrade_zcopy_pure(sk, skb))",
                "condition": [
                    "goto new_segment",
                    "if (zc == MSG_SPLICE_PAGES)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (skb)",
                "condition": [
                    "while (msg_data_left(msg))"
                ],
                "content": "\t\tif (skb)\n\t\t\tcopy = size_goal - skb->len;\n"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "goto out_err;",
                "condition": [
                    "if ((flags & MSG_ZEROCOPY) && size)",
                    "if (sock_flag(sk, SOCK_ZEROCOPY))",
                    "if (!uarg)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (unlikely(flags & MSG_FASTOPEN || inet_test_bit(DEFER_CONNECT, sk)) && !tp->repair)",
                    "if (err == -EINPROGRESS && copied_syn > 0)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (unlikely(flags & MSG_FASTOPEN || inet_test_bit(DEFER_CONNECT, sk)) && !tp->repair)",
                    "if (err)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "if (((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) && !tcp_passive_fastopen(sk))",
                    "if (err != 0)"
                ]
            },
            {
                "text": "goto out_nopush;",
                "condition": [
                    "if (unlikely(tp->repair))",
                    "if (tp->repair_queue == TCP_RECV_QUEUE)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (unlikely(tp->repair))",
                    "if (tp->repair_queue == TCP_NO_QUEUE)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (msg->msg_controllen)",
                    "if (unlikely(err))"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "if (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (!sk_stream_memory_free(sk))"
                ]
            },
            {
                "text": "goto restart;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (unlikely(process_backlog >= 16))",
                    "if (sk_flush_backlog(sk))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (!skb)"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (!sk_page_frag_refill(sk, pfrag))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (unlikely(skb_zcopy_pure(skb) || skb_zcopy_managed(skb)))",
                    "if (tcp_downgrade_zcopy_pure(sk, skb))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (!copy)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (err)"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_ZEROCOPY)",
                    "if (!skb_zcopy_pure(skb))",
                    "if (!copy)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_ZEROCOPY)",
                    "if (err < 0)"
                ]
            }
        ],
        "index": 21
    },
    {
        "var_name": "skb",
        "function_name": "tcp_sendmsg_locked",
        "location": {
            "file_path": "net/ipv4/tcp.c",
            "region": {
                "startLine": 1273,
                "startColumn": 15,
                "endColumn": 18
            },
            "context": {
                "startLine": 1271,
                "endLine": 1275,
                "snippet": {
                    "text": "\t\t\tTCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_PSH;"
                }
            }
        },
        "function_code": "int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct ubuf_info *uarg = NULL;\n\tstruct sk_buff *skb;\n\tstruct sockcm_cookie sockc;\n\tint flags, err, copied = 0;\n\tint mss_now = 0, size_goal, copied_syn = 0;\n\tint process_backlog = 0;\n\tint zc = 0;\n\tlong timeo;\n\n\tflags = msg->msg_flags;\n\n\tif ((flags & MSG_ZEROCOPY) && size) {\n\t\tif (msg->msg_ubuf) {\n\t\t\tuarg = msg->msg_ubuf;\n\t\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\t\tzc = MSG_ZEROCOPY;\n\t\t} else if (sock_flag(sk, SOCK_ZEROCOPY)) {\n\t\t\tskb = tcp_write_queue_tail(sk);\n\t\t\tuarg = msg_zerocopy_realloc(sk, size, skb_zcopy(skb));\n\t\t\tif (!uarg) {\n\t\t\t\terr = -ENOBUFS;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\t\tzc = MSG_ZEROCOPY;\n\t\t\telse\n\t\t\t\tuarg_to_msgzc(uarg)->zerocopy = 0;\n\t\t}\n\t} else if (unlikely(msg->msg_flags & MSG_SPLICE_PAGES) && size) {\n\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\tzc = MSG_SPLICE_PAGES;\n\t}\n\n\tif (unlikely(flags & MSG_FASTOPEN ||\n\t\t     inet_test_bit(DEFER_CONNECT, sk)) &&\n\t    !tp->repair) {\n\t\terr = tcp_sendmsg_fastopen(sk, msg, &copied_syn, size, uarg);\n\t\tif (err == -EINPROGRESS && copied_syn > 0)\n\t\t\tgoto out;\n\t\telse if (err)\n\t\t\tgoto out_err;\n\t}\n\n\ttimeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);\n\n\ttcp_rate_check_app_limited(sk);  /* is sending application-limited? */\n\n\t/* Wait for a connection to finish. One exception is TCP Fast Open\n\t * (passive side) where data is allowed to be sent before a connection\n\t * is fully established.\n\t */\n\tif (((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &&\n\t    !tcp_passive_fastopen(sk)) {\n\t\terr = sk_stream_wait_connect(sk, &timeo);\n\t\tif (err != 0)\n\t\t\tgoto do_error;\n\t}\n\n\tif (unlikely(tp->repair)) {\n\t\tif (tp->repair_queue == TCP_RECV_QUEUE) {\n\t\t\tcopied = tcp_send_rcvq(sk, msg, size);\n\t\t\tgoto out_nopush;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (tp->repair_queue == TCP_NO_QUEUE)\n\t\t\tgoto out_err;\n\n\t\t/* 'common' sending to sendq */\n\t}\n\n\tsockcm_init(&sockc, sk);\n\tif (msg->msg_controllen) {\n\t\terr = sock_cmsg_send(sk, msg, &sockc);\n\t\tif (unlikely(err)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t/* This should be in poll */\n\tsk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\t/* Ok commence sending. */\n\tcopied = 0;\n\nrestart:\n\tmss_now = tcp_send_mss(sk, &size_goal, flags);\n\n\terr = -EPIPE;\n\tif (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))\n\t\tgoto do_error;\n\n\twhile (msg_data_left(msg)) {\n\t\tssize_t copy = 0;\n\n\t\tskb = tcp_write_queue_tail(sk);\n\t\tif (skb)\n\t\t\tcopy = size_goal - skb->len;\n\n\t\tif (copy <= 0 || !tcp_skb_can_collapse_to(skb)) {\n\t\t\tbool first_skb;\n\nnew_segment:\n\t\t\tif (!sk_stream_memory_free(sk))\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tif (unlikely(process_backlog >= 16)) {\n\t\t\t\tprocess_backlog = 0;\n\t\t\t\tif (sk_flush_backlog(sk))\n\t\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tfirst_skb = tcp_rtx_and_write_queues_empty(sk);\n\t\t\tskb = tcp_stream_alloc_skb(sk, sk->sk_allocation,\n\t\t\t\t\t\t   first_skb);\n\t\t\tif (!skb)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tprocess_backlog++;\n\n#ifdef CONFIG_SKB_DECRYPTED\n\t\t\tskb->decrypted = !!(flags & MSG_SENDPAGE_DECRYPTED);\n#endif\n\t\t\ttcp_skb_entail(sk, skb);\n\t\t\tcopy = size_goal;\n\n\t\t\t/* All packets are restored as if they have\n\t\t\t * already been sent. skb_mstamp_ns isn't set to\n\t\t\t * avoid wrong rtt estimation.\n\t\t\t */\n\t\t\tif (tp->repair)\n\t\t\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_REPAIRED;\n\t\t}\n\n\t\t/* Try to append data to the end of skb. */\n\t\tif (copy > msg_data_left(msg))\n\t\t\tcopy = msg_data_left(msg);\n\n\t\tif (zc == 0) {\n\t\t\tbool merge = true;\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\tif (i >= READ_ONCE(sysctl_max_skb_frags)) {\n\t\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\t\tgoto new_segment;\n\t\t\t\t}\n\t\t\t\tmerge = false;\n\t\t\t}\n\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\n\t\t\tif (unlikely(skb_zcopy_pure(skb) || skb_zcopy_managed(skb))) {\n\t\t\t\tif (tcp_downgrade_zcopy_pure(sk, skb))\n\t\t\t\t\tgoto wait_for_space;\n\t\t\t\tskb_zcopy_downgrade_managed(skb);\n\t\t\t}\n\n\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\tif (!copy)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\terr = skb_copy_to_page_nocache(sk, &msg->msg_iter, skb,\n\t\t\t\t\t\t       pfrag->page,\n\t\t\t\t\t\t       pfrag->offset,\n\t\t\t\t\t\t       copy);\n\t\t\tif (err)\n\t\t\t\tgoto do_error;\n\n\t\t\t/* Update the skb. */\n\t\t\tif (merge) {\n\t\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\t} else {\n\t\t\t\tskb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t   pfrag->offset, copy);\n\t\t\t\tpage_ref_inc(pfrag->page);\n\t\t\t}\n\t\t\tpfrag->offset += copy;\n\t\t} else if (zc == MSG_ZEROCOPY)  {\n\t\t\t/* First append to a fragless skb builds initial\n\t\t\t * pure zerocopy skb\n\t\t\t */\n\t\t\tif (!skb->len)\n\t\t\t\tskb_shinfo(skb)->flags |= SKBFL_PURE_ZEROCOPY;\n\n\t\t\tif (!skb_zcopy_pure(skb)) {\n\t\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\t\tif (!copy)\n\t\t\t\t\tgoto wait_for_space;\n\t\t\t}\n\n\t\t\terr = skb_zerocopy_iter_stream(sk, skb, msg, copy, uarg);\n\t\t\tif (err == -EMSGSIZE || err == -EEXIST) {\n\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\tgoto new_segment;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tgoto do_error;\n\t\t\tcopy = err;\n\t\t} else if (zc == MSG_SPLICE_PAGES) {\n\t\t\t/* Splice in data if we can; copy if we can't. */\n\t\t\tif (tcp_downgrade_zcopy_pure(sk, skb))\n\t\t\t\tgoto wait_for_space;\n\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\tif (!copy)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\terr = skb_splice_from_iter(skb, &msg->msg_iter, copy,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (err < 0) {\n\t\t\t\tif (err == -EMSGSIZE) {\n\t\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\t\tgoto new_segment;\n\t\t\t\t}\n\t\t\t\tgoto do_error;\n\t\t\t}\n\t\t\tcopy = err;\n\n\t\t\tif (!(flags & MSG_NO_SHARED_FRAGS))\n\t\t\t\tskb_shinfo(skb)->flags |= SKBFL_SHARED_FRAG;\n\n\t\t\tsk_wmem_queued_add(sk, copy);\n\t\t\tsk_mem_charge(sk, copy);\n\t\t}\n\n\t\tif (!copied)\n\t\t\tTCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_PSH;\n\n\t\tWRITE_ONCE(tp->write_seq, tp->write_seq + copy);\n\t\tTCP_SKB_CB(skb)->end_seq += copy;\n\t\ttcp_skb_pcount_set(skb, 0);\n\n\t\tcopied += copy;\n\t\tif (!msg_data_left(msg)) {\n\t\t\tif (unlikely(flags & MSG_EOR))\n\t\t\t\tTCP_SKB_CB(skb)->eor = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (skb->len < size_goal || (flags & MSG_OOB) || unlikely(tp->repair))\n\t\t\tcontinue;\n\n\t\tif (forced_push(tp)) {\n\t\t\ttcp_mark_push(tp, skb);\n\t\t\t__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);\n\t\t} else if (skb == tcp_send_head(sk))\n\t\t\ttcp_push_one(sk, mss_now);\n\t\tcontinue;\n\nwait_for_space:\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\ttcp_remove_empty_skb(sk);\n\t\tif (copied)\n\t\t\ttcp_push(sk, flags & ~MSG_MORE, mss_now,\n\t\t\t\t TCP_NAGLE_PUSH, size_goal);\n\n\t\terr = sk_stream_wait_memory(sk, &timeo);\n\t\tif (err != 0)\n\t\t\tgoto do_error;\n\n\t\tmss_now = tcp_send_mss(sk, &size_goal, flags);\n\t}\n\nout:\n\tif (copied) {\n\t\ttcp_tx_timestamp(sk, sockc.tsflags);\n\t\ttcp_push(sk, flags, mss_now, tp->nonagle, size_goal);\n\t}\nout_nopush:\n\t/* msg->msg_ubuf is pinned by the caller so we don't take extra refs */\n\tif (uarg && !msg->msg_ubuf)\n\t\tnet_zcopy_put(uarg);\n\treturn copied + copied_syn;\n\ndo_error:\n\ttcp_remove_empty_skb(sk);\n\n\tif (copied + copied_syn)\n\t\tgoto out;\nout_err:\n\t/* msg->msg_ubuf is pinned by the caller so we don't take extra refs */\n\tif (uarg && !msg->msg_ubuf)\n\t\tnet_zcopy_put_abort(uarg, true);\n\terr = sk_stream_error(sk, flags, err);\n\t/* make sure we wake any epoll edge trigger waiter */\n\tif (unlikely(tcp_rtx_and_write_queues_empty(sk) && err == -EAGAIN)) {\n\t\tsk->sk_write_space(sk);\n\t\ttcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);\n\t}\n\treturn err;\n}",
        "function_list": [
            "tcp_write_queue_tail"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\t\tTCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_PSH;",
                "condition": [
                    "goto new_segment",
                    "if (!copied)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (skb)",
                "condition": [
                    "while (msg_data_left(msg))"
                ],
                "content": "\t\tif (skb)\n\t\t\tcopy = size_goal - skb->len;\n"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "goto out_err;",
                "condition": [
                    "if ((flags & MSG_ZEROCOPY) && size)",
                    "if (sock_flag(sk, SOCK_ZEROCOPY))",
                    "if (!uarg)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (unlikely(flags & MSG_FASTOPEN || inet_test_bit(DEFER_CONNECT, sk)) && !tp->repair)",
                    "if (err == -EINPROGRESS && copied_syn > 0)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (unlikely(flags & MSG_FASTOPEN || inet_test_bit(DEFER_CONNECT, sk)) && !tp->repair)",
                    "if (err)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "if (((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) && !tcp_passive_fastopen(sk))",
                    "if (err != 0)"
                ]
            },
            {
                "text": "goto out_nopush;",
                "condition": [
                    "if (unlikely(tp->repair))",
                    "if (tp->repair_queue == TCP_RECV_QUEUE)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (unlikely(tp->repair))",
                    "if (tp->repair_queue == TCP_NO_QUEUE)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (msg->msg_controllen)",
                    "if (unlikely(err))"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "if (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (!sk_stream_memory_free(sk))"
                ]
            },
            {
                "text": "goto restart;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (unlikely(process_backlog >= 16))",
                    "if (sk_flush_backlog(sk))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (!skb)"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (!sk_page_frag_refill(sk, pfrag))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (unlikely(skb_zcopy_pure(skb) || skb_zcopy_managed(skb)))",
                    "if (tcp_downgrade_zcopy_pure(sk, skb))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (!copy)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (err)"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_ZEROCOPY)",
                    "if (!skb_zcopy_pure(skb))",
                    "if (!copy)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_ZEROCOPY)",
                    "if (err < 0)"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_SPLICE_PAGES)",
                    "if (tcp_downgrade_zcopy_pure(sk, skb))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_SPLICE_PAGES)",
                    "if (!copy)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_SPLICE_PAGES)",
                    "if (err < 0)"
                ]
            }
        ],
        "index": 22
    },
    {
        "var_name": "skb",
        "function_name": "tcp_sendmsg_locked",
        "location": {
            "file_path": "net/ipv4/tcp.c",
            "region": {
                "startLine": 1276,
                "startColumn": 14,
                "endColumn": 17
            },
            "context": {
                "startLine": 1274,
                "endLine": 1278,
                "snippet": {
                    "text": "\t\tTCP_SKB_CB(skb)->end_seq += copy;"
                }
            }
        },
        "function_code": "int tcp_sendmsg_locked(struct sock *sk, struct msghdr *msg, size_t size)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct ubuf_info *uarg = NULL;\n\tstruct sk_buff *skb;\n\tstruct sockcm_cookie sockc;\n\tint flags, err, copied = 0;\n\tint mss_now = 0, size_goal, copied_syn = 0;\n\tint process_backlog = 0;\n\tint zc = 0;\n\tlong timeo;\n\n\tflags = msg->msg_flags;\n\n\tif ((flags & MSG_ZEROCOPY) && size) {\n\t\tif (msg->msg_ubuf) {\n\t\t\tuarg = msg->msg_ubuf;\n\t\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\t\tzc = MSG_ZEROCOPY;\n\t\t} else if (sock_flag(sk, SOCK_ZEROCOPY)) {\n\t\t\tskb = tcp_write_queue_tail(sk);\n\t\t\tuarg = msg_zerocopy_realloc(sk, size, skb_zcopy(skb));\n\t\t\tif (!uarg) {\n\t\t\t\terr = -ENOBUFS;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\t\tzc = MSG_ZEROCOPY;\n\t\t\telse\n\t\t\t\tuarg_to_msgzc(uarg)->zerocopy = 0;\n\t\t}\n\t} else if (unlikely(msg->msg_flags & MSG_SPLICE_PAGES) && size) {\n\t\tif (sk->sk_route_caps & NETIF_F_SG)\n\t\t\tzc = MSG_SPLICE_PAGES;\n\t}\n\n\tif (unlikely(flags & MSG_FASTOPEN ||\n\t\t     inet_test_bit(DEFER_CONNECT, sk)) &&\n\t    !tp->repair) {\n\t\terr = tcp_sendmsg_fastopen(sk, msg, &copied_syn, size, uarg);\n\t\tif (err == -EINPROGRESS && copied_syn > 0)\n\t\t\tgoto out;\n\t\telse if (err)\n\t\t\tgoto out_err;\n\t}\n\n\ttimeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);\n\n\ttcp_rate_check_app_limited(sk);  /* is sending application-limited? */\n\n\t/* Wait for a connection to finish. One exception is TCP Fast Open\n\t * (passive side) where data is allowed to be sent before a connection\n\t * is fully established.\n\t */\n\tif (((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) &&\n\t    !tcp_passive_fastopen(sk)) {\n\t\terr = sk_stream_wait_connect(sk, &timeo);\n\t\tif (err != 0)\n\t\t\tgoto do_error;\n\t}\n\n\tif (unlikely(tp->repair)) {\n\t\tif (tp->repair_queue == TCP_RECV_QUEUE) {\n\t\t\tcopied = tcp_send_rcvq(sk, msg, size);\n\t\t\tgoto out_nopush;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (tp->repair_queue == TCP_NO_QUEUE)\n\t\t\tgoto out_err;\n\n\t\t/* 'common' sending to sendq */\n\t}\n\n\tsockcm_init(&sockc, sk);\n\tif (msg->msg_controllen) {\n\t\terr = sock_cmsg_send(sk, msg, &sockc);\n\t\tif (unlikely(err)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t/* This should be in poll */\n\tsk_clear_bit(SOCKWQ_ASYNC_NOSPACE, sk);\n\n\t/* Ok commence sending. */\n\tcopied = 0;\n\nrestart:\n\tmss_now = tcp_send_mss(sk, &size_goal, flags);\n\n\terr = -EPIPE;\n\tif (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))\n\t\tgoto do_error;\n\n\twhile (msg_data_left(msg)) {\n\t\tssize_t copy = 0;\n\n\t\tskb = tcp_write_queue_tail(sk);\n\t\tif (skb)\n\t\t\tcopy = size_goal - skb->len;\n\n\t\tif (copy <= 0 || !tcp_skb_can_collapse_to(skb)) {\n\t\t\tbool first_skb;\n\nnew_segment:\n\t\t\tif (!sk_stream_memory_free(sk))\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tif (unlikely(process_backlog >= 16)) {\n\t\t\t\tprocess_backlog = 0;\n\t\t\t\tif (sk_flush_backlog(sk))\n\t\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tfirst_skb = tcp_rtx_and_write_queues_empty(sk);\n\t\t\tskb = tcp_stream_alloc_skb(sk, sk->sk_allocation,\n\t\t\t\t\t\t   first_skb);\n\t\t\tif (!skb)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tprocess_backlog++;\n\n#ifdef CONFIG_SKB_DECRYPTED\n\t\t\tskb->decrypted = !!(flags & MSG_SENDPAGE_DECRYPTED);\n#endif\n\t\t\ttcp_skb_entail(sk, skb);\n\t\t\tcopy = size_goal;\n\n\t\t\t/* All packets are restored as if they have\n\t\t\t * already been sent. skb_mstamp_ns isn't set to\n\t\t\t * avoid wrong rtt estimation.\n\t\t\t */\n\t\t\tif (tp->repair)\n\t\t\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_REPAIRED;\n\t\t}\n\n\t\t/* Try to append data to the end of skb. */\n\t\tif (copy > msg_data_left(msg))\n\t\t\tcopy = msg_data_left(msg);\n\n\t\tif (zc == 0) {\n\t\t\tbool merge = true;\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\t\t\tstruct page_frag *pfrag = sk_page_frag(sk);\n\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto wait_for_space;\n\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\tif (i >= READ_ONCE(sysctl_max_skb_frags)) {\n\t\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\t\tgoto new_segment;\n\t\t\t\t}\n\t\t\t\tmerge = false;\n\t\t\t}\n\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\n\t\t\tif (unlikely(skb_zcopy_pure(skb) || skb_zcopy_managed(skb))) {\n\t\t\t\tif (tcp_downgrade_zcopy_pure(sk, skb))\n\t\t\t\t\tgoto wait_for_space;\n\t\t\t\tskb_zcopy_downgrade_managed(skb);\n\t\t\t}\n\n\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\tif (!copy)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\terr = skb_copy_to_page_nocache(sk, &msg->msg_iter, skb,\n\t\t\t\t\t\t       pfrag->page,\n\t\t\t\t\t\t       pfrag->offset,\n\t\t\t\t\t\t       copy);\n\t\t\tif (err)\n\t\t\t\tgoto do_error;\n\n\t\t\t/* Update the skb. */\n\t\t\tif (merge) {\n\t\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\t} else {\n\t\t\t\tskb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t   pfrag->offset, copy);\n\t\t\t\tpage_ref_inc(pfrag->page);\n\t\t\t}\n\t\t\tpfrag->offset += copy;\n\t\t} else if (zc == MSG_ZEROCOPY)  {\n\t\t\t/* First append to a fragless skb builds initial\n\t\t\t * pure zerocopy skb\n\t\t\t */\n\t\t\tif (!skb->len)\n\t\t\t\tskb_shinfo(skb)->flags |= SKBFL_PURE_ZEROCOPY;\n\n\t\t\tif (!skb_zcopy_pure(skb)) {\n\t\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\t\tif (!copy)\n\t\t\t\t\tgoto wait_for_space;\n\t\t\t}\n\n\t\t\terr = skb_zerocopy_iter_stream(sk, skb, msg, copy, uarg);\n\t\t\tif (err == -EMSGSIZE || err == -EEXIST) {\n\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\tgoto new_segment;\n\t\t\t}\n\t\t\tif (err < 0)\n\t\t\t\tgoto do_error;\n\t\t\tcopy = err;\n\t\t} else if (zc == MSG_SPLICE_PAGES) {\n\t\t\t/* Splice in data if we can; copy if we can't. */\n\t\t\tif (tcp_downgrade_zcopy_pure(sk, skb))\n\t\t\t\tgoto wait_for_space;\n\t\t\tcopy = tcp_wmem_schedule(sk, copy);\n\t\t\tif (!copy)\n\t\t\t\tgoto wait_for_space;\n\n\t\t\terr = skb_splice_from_iter(skb, &msg->msg_iter, copy,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (err < 0) {\n\t\t\t\tif (err == -EMSGSIZE) {\n\t\t\t\t\ttcp_mark_push(tp, skb);\n\t\t\t\t\tgoto new_segment;\n\t\t\t\t}\n\t\t\t\tgoto do_error;\n\t\t\t}\n\t\t\tcopy = err;\n\n\t\t\tif (!(flags & MSG_NO_SHARED_FRAGS))\n\t\t\t\tskb_shinfo(skb)->flags |= SKBFL_SHARED_FRAG;\n\n\t\t\tsk_wmem_queued_add(sk, copy);\n\t\t\tsk_mem_charge(sk, copy);\n\t\t}\n\n\t\tif (!copied)\n\t\t\tTCP_SKB_CB(skb)->tcp_flags &= ~TCPHDR_PSH;\n\n\t\tWRITE_ONCE(tp->write_seq, tp->write_seq + copy);\n\t\tTCP_SKB_CB(skb)->end_seq += copy;\n\t\ttcp_skb_pcount_set(skb, 0);\n\n\t\tcopied += copy;\n\t\tif (!msg_data_left(msg)) {\n\t\t\tif (unlikely(flags & MSG_EOR))\n\t\t\t\tTCP_SKB_CB(skb)->eor = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (skb->len < size_goal || (flags & MSG_OOB) || unlikely(tp->repair))\n\t\t\tcontinue;\n\n\t\tif (forced_push(tp)) {\n\t\t\ttcp_mark_push(tp, skb);\n\t\t\t__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);\n\t\t} else if (skb == tcp_send_head(sk))\n\t\t\ttcp_push_one(sk, mss_now);\n\t\tcontinue;\n\nwait_for_space:\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\ttcp_remove_empty_skb(sk);\n\t\tif (copied)\n\t\t\ttcp_push(sk, flags & ~MSG_MORE, mss_now,\n\t\t\t\t TCP_NAGLE_PUSH, size_goal);\n\n\t\terr = sk_stream_wait_memory(sk, &timeo);\n\t\tif (err != 0)\n\t\t\tgoto do_error;\n\n\t\tmss_now = tcp_send_mss(sk, &size_goal, flags);\n\t}\n\nout:\n\tif (copied) {\n\t\ttcp_tx_timestamp(sk, sockc.tsflags);\n\t\ttcp_push(sk, flags, mss_now, tp->nonagle, size_goal);\n\t}\nout_nopush:\n\t/* msg->msg_ubuf is pinned by the caller so we don't take extra refs */\n\tif (uarg && !msg->msg_ubuf)\n\t\tnet_zcopy_put(uarg);\n\treturn copied + copied_syn;\n\ndo_error:\n\ttcp_remove_empty_skb(sk);\n\n\tif (copied + copied_syn)\n\t\tgoto out;\nout_err:\n\t/* msg->msg_ubuf is pinned by the caller so we don't take extra refs */\n\tif (uarg && !msg->msg_ubuf)\n\t\tnet_zcopy_put_abort(uarg, true);\n\terr = sk_stream_error(sk, flags, err);\n\t/* make sure we wake any epoll edge trigger waiter */\n\tif (unlikely(tcp_rtx_and_write_queues_empty(sk) && err == -EAGAIN)) {\n\t\tsk->sk_write_space(sk);\n\t\ttcp_chrono_stop(sk, TCP_CHRONO_SNDBUF_LIMITED);\n\t}\n\treturn err;\n}",
        "function_list": [
            "tcp_write_queue_tail"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\tTCP_SKB_CB(skb)->end_seq += copy;",
                "condition": [
                    "goto new_segment"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (skb)",
                "condition": [
                    "while (msg_data_left(msg))"
                ],
                "content": "\t\tif (skb)\n\t\t\tcopy = size_goal - skb->len;\n"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "goto out_err;",
                "condition": [
                    "if ((flags & MSG_ZEROCOPY) && size)",
                    "if (sock_flag(sk, SOCK_ZEROCOPY))",
                    "if (!uarg)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (unlikely(flags & MSG_FASTOPEN || inet_test_bit(DEFER_CONNECT, sk)) && !tp->repair)",
                    "if (err == -EINPROGRESS && copied_syn > 0)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (unlikely(flags & MSG_FASTOPEN || inet_test_bit(DEFER_CONNECT, sk)) && !tp->repair)",
                    "if (err)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "if (((1 << sk->sk_state) & ~(TCPF_ESTABLISHED | TCPF_CLOSE_WAIT)) && !tcp_passive_fastopen(sk))",
                    "if (err != 0)"
                ]
            },
            {
                "text": "goto out_nopush;",
                "condition": [
                    "if (unlikely(tp->repair))",
                    "if (tp->repair_queue == TCP_RECV_QUEUE)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (unlikely(tp->repair))",
                    "if (tp->repair_queue == TCP_NO_QUEUE)"
                ]
            },
            {
                "text": "goto out_err;",
                "condition": [
                    "if (msg->msg_controllen)",
                    "if (unlikely(err))"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "if (sk->sk_err || (sk->sk_shutdown & SEND_SHUTDOWN))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (!sk_stream_memory_free(sk))"
                ]
            },
            {
                "text": "goto restart;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (unlikely(process_backlog >= 16))",
                    "if (sk_flush_backlog(sk))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (copy <= 0 || !tcp_skb_can_collapse_to(skb))",
                    "if (!skb)"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (!sk_page_frag_refill(sk, pfrag))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (unlikely(skb_zcopy_pure(skb) || skb_zcopy_managed(skb)))",
                    "if (tcp_downgrade_zcopy_pure(sk, skb))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (!copy)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == 0)",
                    "if (err)"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_ZEROCOPY)",
                    "if (!skb_zcopy_pure(skb))",
                    "if (!copy)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_ZEROCOPY)",
                    "if (err < 0)"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_SPLICE_PAGES)",
                    "if (tcp_downgrade_zcopy_pure(sk, skb))"
                ]
            },
            {
                "text": "goto wait_for_space;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_SPLICE_PAGES)",
                    "if (!copy)"
                ]
            },
            {
                "text": "goto do_error;",
                "condition": [
                    "while (msg_data_left(msg))",
                    "if (zc == MSG_SPLICE_PAGES)",
                    "if (err < 0)"
                ]
            }
        ],
        "index": 23
    },
    {
        "var_name": "saved_clone",
        "function_name": "tcp_set_allowed_congestion_control",
        "location": {
            "file_path": "net/ipv4/tcp_cong.c",
            "region": {
                "startLine": 400,
                "startColumn": 8,
                "endColumn": 19
            },
            "context": {
                "startLine": 398,
                "endLine": 402,
                "snippet": {
                    "text": "\tkfree(saved_clone);"
                }
            }
        },
        "function_code": "int tcp_set_allowed_congestion_control(char *val)\n{\n\tstruct tcp_congestion_ops *ca;\n\tchar *saved_clone, *clone, *name;\n\tint ret = 0;\n\n\tsaved_clone = clone = kstrdup(val, GFP_USER);\n\tif (!clone)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&tcp_cong_list_lock);\n\t/* pass 1 check for bad entries */\n\twhile ((name = strsep(&clone, \" \")) && *name) {\n\t\tca = tcp_ca_find(name);\n\t\tif (!ca) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* pass 2 clear old values */\n\tlist_for_each_entry_rcu(ca, &tcp_cong_list, list)\n\t\tca->flags &= ~TCP_CONG_NON_RESTRICTED;\n\n\t/* pass 3 mark as allowed */\n\twhile ((name = strsep(&val, \" \")) && *name) {\n\t\tca = tcp_ca_find(name);\n\t\tWARN_ON(!ca);\n\t\tif (ca)\n\t\t\tca->flags |= TCP_CONG_NON_RESTRICTED;\n\t}\nout:\n\tspin_unlock(&tcp_cong_list_lock);\n\tkfree(saved_clone);\n\n\treturn ret;\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree(saved_clone);",
                "condition": [
                    "goto out"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -ENOMEM;",
                "condition": [
                    "if (!clone)"
                ]
            }
        ],
        "index": 24
    },
    {
        "var_name": "skb",
        "function_name": "tcp_mtu_probe",
        "location": {
            "file_path": "net/ipv4/tcp_output.c",
            "region": {
                "startLine": 2499,
                "startColumn": 37,
                "endColumn": 40
            },
            "context": {
                "startLine": 2497,
                "endLine": 2501,
                "snippet": {
                    "text": "\tTCP_SKB_CB(nskb)->seq = TCP_SKB_CB(skb)->seq;"
                }
            }
        },
        "function_code": "static int tcp_mtu_probe(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *skb, *nskb, *next;\n\tstruct net *net = sock_net(sk);\n\tint probe_size;\n\tint size_needed;\n\tint copy, len;\n\tint mss_now;\n\tint interval;\n\n\t/* Not currently probing/verifying,\n\t * not in recovery,\n\t * have enough cwnd, and\n\t * not SACKing (the variable headers throw things off)\n\t */\n\tif (likely(!icsk->icsk_mtup.enabled ||\n\t\t   icsk->icsk_mtup.probe_size ||\n\t\t   inet_csk(sk)->icsk_ca_state != TCP_CA_Open ||\n\t\t   tcp_snd_cwnd(tp) < 11 ||\n\t\t   tp->rx_opt.num_sacks || tp->rx_opt.dsack))\n\t\treturn -1;\n\n\t/* Use binary search for probe_size between tcp_mss_base,\n\t * and current mss_clamp. if (search_high - search_low)\n\t * smaller than a threshold, backoff from probing.\n\t */\n\tmss_now = tcp_current_mss(sk);\n\tprobe_size = tcp_mtu_to_mss(sk, (icsk->icsk_mtup.search_high +\n\t\t\t\t    icsk->icsk_mtup.search_low) >> 1);\n\tsize_needed = probe_size + (tp->reordering + 1) * tp->mss_cache;\n\tinterval = icsk->icsk_mtup.search_high - icsk->icsk_mtup.search_low;\n\t/* When misfortune happens, we are reprobing actively,\n\t * and then reprobe timer has expired. We stick with current\n\t * probing process by not resetting search range to its orignal.\n\t */\n\tif (probe_size > tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_high) ||\n\t    interval < READ_ONCE(net->ipv4.sysctl_tcp_probe_threshold)) {\n\t\t/* Check whether enough time has elaplased for\n\t\t * another round of probing.\n\t\t */\n\t\ttcp_mtu_check_reprobe(sk);\n\t\treturn -1;\n\t}\n\n\t/* Have enough data in the send queue to probe? */\n\tif (tp->write_seq - tp->snd_nxt < size_needed)\n\t\treturn -1;\n\n\tif (tp->snd_wnd < size_needed)\n\t\treturn -1;\n\tif (after(tp->snd_nxt + size_needed, tcp_wnd_end(tp)))\n\t\treturn 0;\n\n\t/* Do we need to wait to drain cwnd? With none in flight, don't stall */\n\tif (tcp_packets_in_flight(tp) + 2 > tcp_snd_cwnd(tp)) {\n\t\tif (!tcp_packets_in_flight(tp))\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tif (!tcp_can_coalesce_send_queue_head(sk, probe_size))\n\t\treturn -1;\n\n\t/* We're allowed to probe.  Build it now. */\n\tnskb = tcp_stream_alloc_skb(sk, GFP_ATOMIC, false);\n\tif (!nskb)\n\t\treturn -1;\n\n\t/* build the payload, and be prepared to abort if this fails. */\n\tif (tcp_clone_payload(sk, nskb, probe_size)) {\n\t\ttcp_skb_tsorted_anchor_cleanup(nskb);\n\t\tconsume_skb(nskb);\n\t\treturn -1;\n\t}\n\tsk_wmem_queued_add(sk, nskb->truesize);\n\tsk_mem_charge(sk, nskb->truesize);\n\n\tskb = tcp_send_head(sk);\n\tskb_copy_decrypted(nskb, skb);\n\tmptcp_skb_ext_copy(nskb, skb);\n\n\tTCP_SKB_CB(nskb)->seq = TCP_SKB_CB(skb)->seq;\n\tTCP_SKB_CB(nskb)->end_seq = TCP_SKB_CB(skb)->seq + probe_size;\n\tTCP_SKB_CB(nskb)->tcp_flags = TCPHDR_ACK;\n\n\ttcp_insert_write_queue_before(nskb, skb, sk);\n\ttcp_highest_sack_replace(sk, skb, nskb);\n\n\tlen = 0;\n\ttcp_for_write_queue_from_safe(skb, next, sk) {\n\t\tcopy = min_t(int, skb->len, probe_size - len);\n\n\t\tif (skb->len <= copy) {\n\t\t\t/* We've eaten all the data from this skb.\n\t\t\t * Throw it away. */\n\t\t\tTCP_SKB_CB(nskb)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags;\n\t\t\t/* If this is the last SKB we copy and eor is set\n\t\t\t * we need to propagate it to the new skb.\n\t\t\t */\n\t\t\tTCP_SKB_CB(nskb)->eor = TCP_SKB_CB(skb)->eor;\n\t\t\ttcp_skb_collapse_tstamp(nskb, skb);\n\t\t\ttcp_unlink_write_queue(skb, sk);\n\t\t\ttcp_wmem_free_skb(sk, skb);\n\t\t} else {\n\t\t\tTCP_SKB_CB(nskb)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags &\n\t\t\t\t\t\t   ~(TCPHDR_FIN|TCPHDR_PSH);\n\t\t\t__pskb_trim_head(skb, copy);\n\t\t\ttcp_set_skb_tso_segs(skb, mss_now);\n\t\t\tTCP_SKB_CB(skb)->seq += copy;\n\t\t}\n\n\t\tlen += copy;\n\n\t\tif (len >= probe_size)\n\t\t\tbreak;\n\t}\n\ttcp_init_tso_segs(nskb, nskb->len);\n\n\t/* We're ready to send.  If this fails, the probe will\n\t * be resegmented into mss-sized pieces by tcp_write_xmit().\n\t */\n\tif (!tcp_transmit_skb(sk, nskb, 1, GFP_ATOMIC)) {\n\t\t/* Decrement cwnd here because we are sending\n\t\t * effectively two packets. */\n\t\ttcp_snd_cwnd_set(tp, tcp_snd_cwnd(tp) - 1);\n\t\ttcp_event_new_data_sent(sk, nskb);\n\n\t\ticsk->icsk_mtup.probe_size = tcp_mss_to_mtu(sk, nskb->len);\n\t\ttp->mtu_probe.probe_seq_start = TCP_SKB_CB(nskb)->seq;\n\t\ttp->mtu_probe.probe_seq_end = TCP_SKB_CB(nskb)->end_seq;\n\n\t\treturn 1;\n\t}\n\n\treturn -1;\n}",
        "function_list": [
            "tcp_send_head",
            "skb_peek"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\tTCP_SKB_CB(nskb)->seq = TCP_SKB_CB(skb)->seq;",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -1;",
                "condition": [
                    "if (likely(!icsk->icsk_mtup.enabled || icsk->icsk_mtup.probe_size || inet_csk(sk)->icsk_ca_state != TCP_CA_Open || tcp_snd_cwnd(tp) < 11 || tp->rx_opt.num_sacks || tp->rx_opt.dsack))"
                ]
            },
            {
                "text": "return -1;",
                "condition": [
                    "if (probe_size > tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_high) || interval < READ_ONCE(net->ipv4.sysctl_tcp_probe_threshold))"
                ]
            },
            {
                "text": "return -1;",
                "condition": [
                    "if (tp->write_seq - tp->snd_nxt < size_needed)"
                ]
            },
            {
                "text": "return -1;",
                "condition": [
                    "if (tp->snd_wnd < size_needed)"
                ]
            },
            {
                "text": "return 0;",
                "condition": [
                    "if (after(tp->snd_nxt + size_needed, tcp_wnd_end(tp)))"
                ]
            },
            {
                "text": "return -1;",
                "condition": [
                    "if (tcp_packets_in_flight(tp) + 2 > tcp_snd_cwnd(tp))",
                    "if (!tcp_packets_in_flight(tp))"
                ]
            },
            {
                "text": "return 0;",
                "condition": [
                    "if (tcp_packets_in_flight(tp) + 2 > tcp_snd_cwnd(tp))",
                    "if(!(!tcp_packets_in_flight(tp)))"
                ]
            },
            {
                "text": "return -1;",
                "condition": [
                    "if (!tcp_can_coalesce_send_queue_head(sk, probe_size))"
                ]
            },
            {
                "text": "return -1;",
                "condition": [
                    "if (!nskb)"
                ]
            },
            {
                "text": "return -1;",
                "condition": [
                    "if (tcp_clone_payload(sk, nskb, probe_size))"
                ]
            }
        ],
        "index": 27
    },
    {
        "var_name": "skb",
        "function_name": "udp_sendmsg",
        "location": {
            "file_path": "net/ipv4/udp.c",
            "region": {
                "startLine": 1268,
                "startColumn": 23,
                "endColumn": 26
            },
            "context": {
                "startLine": 1266,
                "endLine": 1270,
                "snippet": {
                    "text": "\t\t\terr = udp_send_skb(skb, fl4, &cork);"
                }
            }
        },
        "function_code": "int udp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct udp_sock *up = udp_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);\n\tstruct flowi4 fl4_stack;\n\tstruct flowi4 *fl4;\n\tint ulen = len;\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = NULL;\n\tint free = 0;\n\tint connected = 0;\n\t__be32 daddr, faddr, saddr;\n\tu8 tos, scope;\n\t__be16 dport;\n\tint err, is_udplite = IS_UDPLITE(sk);\n\tint corkreq = udp_test_bit(CORK, sk) || msg->msg_flags & MSG_MORE;\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\tstruct sk_buff *skb;\n\tstruct ip_options_data opt_copy;\n\tint uc_index;\n\n\tif (len > 0xFFFF)\n\t\treturn -EMSGSIZE;\n\n\t/*\n\t *\tCheck the flags.\n\t */\n\n\tif (msg->msg_flags & MSG_OOB) /* Mirror BSD error message compatibility */\n\t\treturn -EOPNOTSUPP;\n\n\tgetfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;\n\n\tfl4 = &inet->cork.fl.u.ip4;\n\tif (READ_ONCE(up->pending)) {\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\t/*\n\t *\tGet and verify the address.\n\t */\n\tif (usin) {\n\t\tif (msg->msg_namelen < sizeof(*usin))\n\t\t\treturn -EINVAL;\n\t\tif (usin->sin_family != AF_INET) {\n\t\t\tif (usin->sin_family != AF_UNSPEC)\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t}\n\n\t\tdaddr = usin->sin_addr.s_addr;\n\t\tdport = usin->sin_port;\n\t\tif (dport == 0)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = inet->inet_daddr;\n\t\tdport = inet->inet_dport;\n\t\t/* Open fast path for connected socket.\n\t\t   Route will not be used, if at least one option is set.\n\t\t */\n\t\tconnected = 1;\n\t}\n\n\tipcm_init_sk(&ipc, inet);\n\tipc.gso_size = READ_ONCE(up->gso_size);\n\n\tif (msg->msg_controllen) {\n\t\terr = udp_cmsg_send(sk, msg, &ipc.gso_size);\n\t\tif (err > 0) {\n\t\t\terr = ip_cmsg_send(sk, msg, &ipc,\n\t\t\t\t\t   sk->sk_family == AF_INET6);\n\t\t\tconnected = 0;\n\t\t}\n\t\tif (unlikely(err < 0)) {\n\t\t\tkfree(ipc.opt);\n\t\t\treturn err;\n\t\t}\n\t\tif (ipc.opt)\n\t\t\tfree = 1;\n\t}\n\tif (!ipc.opt) {\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\trcu_read_lock();\n\t\tinet_opt = rcu_dereference(inet->inet_opt);\n\t\tif (inet_opt) {\n\t\t\tmemcpy(&opt_copy, inet_opt,\n\t\t\t       sizeof(*inet_opt) + inet_opt->opt.optlen);\n\t\t\tipc.opt = &opt_copy.opt;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (cgroup_bpf_enabled(CGROUP_UDP4_SENDMSG) && !connected) {\n\t\terr = BPF_CGROUP_RUN_PROG_UDP4_SENDMSG_LOCK(sk,\n\t\t\t\t\t    (struct sockaddr *)usin,\n\t\t\t\t\t    &msg->msg_namelen,\n\t\t\t\t\t    &ipc.addr);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tif (usin) {\n\t\t\tif (usin->sin_port == 0) {\n\t\t\t\t/* BPF program set invalid port. Reject it. */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tdaddr = usin->sin_addr.s_addr;\n\t\t\tdport = usin->sin_port;\n\t\t}\n\t}\n\n\tsaddr = ipc.addr;\n\tipc.addr = faddr = daddr;\n\n\tif (ipc.opt && ipc.opt->opt.srr) {\n\t\tif (!daddr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t\tfaddr = ipc.opt->opt.faddr;\n\t\tconnected = 0;\n\t}\n\ttos = get_rttos(&ipc, inet);\n\tscope = ip_sendmsg_scope(inet, &ipc, msg);\n\tif (scope == RT_SCOPE_LINK)\n\t\tconnected = 0;\n\n\tuc_index = READ_ONCE(inet->uc_index);\n\tif (ipv4_is_multicast(daddr)) {\n\t\tif (!ipc.oif || netif_index_is_l3_master(sock_net(sk), ipc.oif))\n\t\t\tipc.oif = READ_ONCE(inet->mc_index);\n\t\tif (!saddr)\n\t\t\tsaddr = READ_ONCE(inet->mc_addr);\n\t\tconnected = 0;\n\t} else if (!ipc.oif) {\n\t\tipc.oif = uc_index;\n\t} else if (ipv4_is_lbcast(daddr) && uc_index) {\n\t\t/* oif is set, packet is to local broadcast and\n\t\t * uc_index is set. oif is most likely set\n\t\t * by sk_bound_dev_if. If uc_index != oif check if the\n\t\t * oif is an L3 master and uc_index is an L3 slave.\n\t\t * If so, we want to allow the send using the uc_index.\n\t\t */\n\t\tif (ipc.oif != uc_index &&\n\t\t    ipc.oif == l3mdev_master_ifindex_by_index(sock_net(sk),\n\t\t\t\t\t\t\t      uc_index)) {\n\t\t\tipc.oif = uc_index;\n\t\t}\n\t}\n\n\tif (connected)\n\t\trt = dst_rtable(sk_dst_check(sk, 0));\n\n\tif (!rt) {\n\t\tstruct net *net = sock_net(sk);\n\t\t__u8 flow_flags = inet_sk_flowi_flags(sk);\n\n\t\tfl4 = &fl4_stack;\n\n\t\tflowi4_init_output(fl4, ipc.oif, ipc.sockc.mark, tos, scope,\n\t\t\t\t   sk->sk_protocol, flow_flags, faddr, saddr,\n\t\t\t\t   dport, inet->inet_sport, sk->sk_uid);\n\n\t\tsecurity_sk_classify_flow(sk, flowi4_to_flowi_common(fl4));\n\t\trt = ip_route_output_flow(net, fl4, sk);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tif (err == -ENETUNREACH)\n\t\t\t\tIP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -EACCES;\n\t\tif ((rt->rt_flags & RTCF_BROADCAST) &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST))\n\t\t\tgoto out;\n\t\tif (connected)\n\t\t\tsk_dst_set(sk, dst_clone(&rt->dst));\n\t}\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\tsaddr = fl4->saddr;\n\tif (!ipc.addr)\n\t\tdaddr = ipc.addr = fl4->daddr;\n\n\t/* Lockless fast path for the non-corking case. */\n\tif (!corkreq) {\n\t\tstruct inet_cork cork;\n\n\t\tskb = ip_make_skb(sk, fl4, getfrag, msg, ulen,\n\t\t\t\t  sizeof(struct udphdr), &ipc, &rt,\n\t\t\t\t  &cork, msg->msg_flags);\n\t\terr = PTR_ERR(skb);\n\t\tif (!IS_ERR_OR_NULL(skb))\n\t\t\terr = udp_send_skb(skb, fl4, &cork);\n\t\tgoto out;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tnet_dbg_ratelimited(\"socket already corked\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\t/*\n\t *\tNow cork the socket to pend data.\n\t */\n\tfl4 = &inet->cork.fl.u.ip4;\n\tfl4->daddr = daddr;\n\tfl4->saddr = saddr;\n\tfl4->fl4_dport = dport;\n\tfl4->fl4_sport = inet->inet_sport;\n\tWRITE_ONCE(up->pending, AF_INET);\n\ndo_append_data:\n\tup->len += ulen;\n\terr = ip_append_data(sk, fl4, getfrag, msg, ulen,\n\t\t\t     sizeof(struct udphdr), &ipc, &rt,\n\t\t\t     corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tWRITE_ONCE(up->pending, 0);\n\trelease_sock(sk);\n\nout:\n\tip_rt_put(rt);\nout_free:\n\tif (free)\n\t\tkfree(ipc.opt);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP_INC_STATS(sock_net(sk),\n\t\t\t      UDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(&rt->dst, &fl4->daddr);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}",
        "function_list": [
            "IS_ERR_OR_NULL"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\terr = udp_send_skb(skb, fl4, &cork);",
                "condition": [
                    "goto back_from_confirm",
                    "if (!corkreq)",
                    "if (!IS_ERR_OR_NULL(skb))"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -EMSGSIZE;",
                "condition": [
                    "if (len > 0xFFFF)"
                ]
            },
            {
                "text": "return -EOPNOTSUPP;",
                "condition": [
                    "if (msg->msg_flags & MSG_OOB) /* Mirror BSD error message compatibility */"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (READ_ONCE(up->pending))",
                    "if (likely(up->pending))",
                    "if (unlikely(up->pending != AF_INET))"
                ]
            },
            {
                "text": "goto do_append_data;",
                "condition": [
                    "if (READ_ONCE(up->pending))",
                    "if (likely(up->pending))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (usin)",
                    "if (msg->msg_namelen < sizeof(*usin))"
                ]
            },
            {
                "text": "return -EAFNOSUPPORT;",
                "condition": [
                    "if (usin)",
                    "if (usin->sin_family != AF_INET)",
                    "if (usin->sin_family != AF_UNSPEC)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (usin)",
                    "if (dport == 0)"
                ]
            },
            {
                "text": "return -EDESTADDRREQ;",
                "condition": [
                    "if(!(usin))",
                    "if (sk->sk_state != TCP_ESTABLISHED)"
                ]
            },
            {
                "text": "return err;",
                "condition": [
                    "if (msg->msg_controllen)",
                    "if (unlikely(err < 0))"
                ]
            },
            {
                "text": "goto out_free;",
                "condition": [
                    "if (cgroup_bpf_enabled(CGROUP_UDP4_SENDMSG) && !connected)",
                    "if (err)"
                ]
            },
            {
                "text": "goto out_free;",
                "condition": [
                    "if (cgroup_bpf_enabled(CGROUP_UDP4_SENDMSG) && !connected)",
                    "if (usin)",
                    "if (usin->sin_port == 0)"
                ]
            },
            {
                "text": "goto out_free;",
                "condition": [
                    "if (ipc.opt && ipc.opt->opt.srr)",
                    "if (!daddr)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!rt)",
                    "if (IS_ERR(rt))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!rt)",
                    "if ((rt->rt_flags & RTCF_BROADCAST) && !sock_flag(sk, SOCK_BROADCAST))"
                ]
            },
            {
                "text": "goto do_confirm;",
                "condition": [
                    "if (msg->msg_flags&MSG_CONFIRM)"
                ]
            }
        ],
        "index": 29
    },
    {
        "var_name": "uh",
        "function_name": "udp_gro_receive_segment",
        "location": {
            "file_path": "net/ipv4/udp_offload.c",
            "region": {
                "startLine": 477,
                "startColumn": 7,
                "endColumn": 9
            },
            "context": {
                "startLine": 475,
                "endLine": 479,
                "snippet": {
                    "text": "\tif (!uh->check) {"
                }
            }
        },
        "function_code": "static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct udphdr *uh = udp_gro_udphdr(skb);\n\tstruct sk_buff *pp = NULL;\n\tstruct udphdr *uh2;\n\tstruct sk_buff *p;\n\tunsigned int ulen;\n\tint ret = 0;\n\tint flush;\n\n\t/* requires non zero csum, for symmetry with GSO */\n\tif (!uh->check) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\t/* Do not deal with padded or malicious packets, sorry ! */\n\tulen = ntohs(uh->len);\n\tif (ulen <= sizeof(*uh) || ulen != skb_gro_len(skb)) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\t/* pull encapsulating udp header */\n\tskb_gro_pull(skb, sizeof(struct udphdr));\n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tuh2 = udp_hdr(p);\n\n\t\t/* Match ports only, as csum is always non zero */\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (NAPI_GRO_CB(skb)->is_flist != NAPI_GRO_CB(p)->is_flist) {\n\t\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\t\treturn p;\n\t\t}\n\n\t\tflush = NAPI_GRO_CB(p)->flush;\n\n\t\tif (NAPI_GRO_CB(p)->flush_id != 1 ||\n\t\t    NAPI_GRO_CB(p)->count != 1 ||\n\t\t    !NAPI_GRO_CB(p)->is_atomic)\n\t\t\tflush |= NAPI_GRO_CB(p)->flush_id;\n\t\telse\n\t\t\tNAPI_GRO_CB(p)->is_atomic = false;\n\n\t\t/* Terminate the flow on len mismatch or if it grow \"too much\".\n\t\t * Under small packet flood GRO count could elsewhere grow a lot\n\t\t * leading to excessive truesize values.\n\t\t * On len mismatch merge the first packet shorter than gso_size,\n\t\t * otherwise complete the GRO packet.\n\t\t */\n\t\tif (ulen > ntohs(uh2->len) || flush) {\n\t\t\tpp = p;\n\t\t} else {\n\t\t\tif (NAPI_GRO_CB(skb)->is_flist) {\n\t\t\t\tif (!pskb_may_pull(skb, skb_gro_offset(skb))) {\n\t\t\t\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tif ((skb->ip_summed != p->ip_summed) ||\n\t\t\t\t    (skb->csum_level != p->csum_level)) {\n\t\t\t\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tret = skb_gro_receive_list(p, skb);\n\t\t\t} else {\n\t\t\t\tskb_gro_postpull_rcsum(skb, uh,\n\t\t\t\t\t\t       sizeof(struct udphdr));\n\n\t\t\t\tret = skb_gro_receive(p, skb);\n\t\t\t}\n\t\t}\n\n\t\tif (ret || ulen != ntohs(uh2->len) ||\n\t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n\t\t\tpp = p;\n\n\t\treturn pp;\n\t}\n\n\t/* mismatch, but we never need to flush */\n\treturn NULL;\n}",
        "function_list": [
            "udp_gro_udphdr",
            "skb_gro_header",
            "skb_gro_header_slow"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\tif (!uh->check) {",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [],
        "index": 31
    },
    {
        "var_name": "idev",
        "function_name": "inet6_validate_link_af",
        "location": {
            "file_path": "net/ipv6/addrconf.c",
            "region": {
                "startLine": 6007,
                "startColumn": 35,
                "endColumn": 39
            },
            "context": {
                "startLine": 6005,
                "endLine": 6009,
                "snippet": {
                    "text": "\t\tif (dev && check_stable_privacy(idev, dev_net(dev), mode) < 0)"
                }
            }
        },
        "function_code": "static int inet6_validate_link_af(const struct net_device *dev,\n\t\t\t\t  const struct nlattr *nla,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[IFLA_INET6_MAX + 1];\n\tstruct inet6_dev *idev = NULL;\n\tint err;\n\n\tif (dev) {\n\t\tidev = __in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\treturn -EAFNOSUPPORT;\n\t}\n\n\terr = nla_parse_nested_deprecated(tb, IFLA_INET6_MAX, nla,\n\t\t\t\t\t  inet6_af_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IFLA_INET6_TOKEN] && !tb[IFLA_INET6_ADDR_GEN_MODE])\n\t\treturn -EINVAL;\n\n\tif (tb[IFLA_INET6_ADDR_GEN_MODE]) {\n\t\tu8 mode = nla_get_u8(tb[IFLA_INET6_ADDR_GEN_MODE]);\n\n\t\tif (check_addr_gen_mode(mode) < 0)\n\t\t\treturn -EINVAL;\n\t\tif (dev && check_stable_privacy(idev, dev_net(dev), mode) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\tif (dev && check_stable_privacy(idev, dev_net(dev), mode) < 0)",
                "condition": [
                    "if (tb[IFLA_INET6_ADDR_GEN_MODE])",
                    "if (dev)"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct inet6_dev *idev = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -EAFNOSUPPORT;",
                "condition": [
                    "if (dev)",
                    "if (!idev)"
                ]
            },
            {
                "text": "return err;",
                "condition": [
                    "if (err)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (!tb[IFLA_INET6_TOKEN] && !tb[IFLA_INET6_ADDR_GEN_MODE])"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (tb[IFLA_INET6_ADDR_GEN_MODE])",
                    "if (check_addr_gen_mode(mode) < 0)"
                ]
            }
        ],
        "index": 34
    },
    {
        "var_name": "fib6_nh",
        "function_name": "ipv6_route_native_seq_show",
        "location": {
            "file_path": "net/ipv6/ip6_fib.c",
            "region": {
                "startLine": 2556,
                "startColumn": 6,
                "endColumn": 13
            },
            "context": {
                "startLine": 2554,
                "endLine": 2558,
                "snippet": {
                    "text": "\tif (fib6_nh->fib_nh_gw_family) {"
                }
            }
        },
        "function_code": "static int ipv6_route_native_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct fib6_info *rt = v;\n\tstruct ipv6_route_iter *iter = seq->private;\n\tstruct fib6_nh *fib6_nh = rt->fib6_nh;\n\tunsigned int flags = rt->fib6_flags;\n\tconst struct net_device *dev;\n\n\tif (rt->nh)\n\t\tfib6_nh = nexthop_fib6_nh(rt->nh);\n\n\tseq_printf(seq, \"%pi6 %02x \", &rt->fib6_dst.addr, rt->fib6_dst.plen);\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tseq_printf(seq, \"%pi6 %02x \", &rt->fib6_src.addr, rt->fib6_src.plen);\n#else\n\tseq_puts(seq, \"00000000000000000000000000000000 00 \");\n#endif\n\tif (fib6_nh->fib_nh_gw_family) {\n\t\tflags |= RTF_GATEWAY;\n\t\tseq_printf(seq, \"%pi6\", &fib6_nh->fib_nh_gw6);\n\t} else {\n\t\tseq_puts(seq, \"00000000000000000000000000000000\");\n\t}\n\n\tdev = fib6_nh->fib_nh_dev;\n\tseq_printf(seq, \" %08x %08x %08x %08x %8s\\n\",\n\t\t   rt->fib6_metric, refcount_read(&rt->fib6_ref), 0,\n\t\t   flags, dev ? dev->name : \"\");\n\titer->w.leaf = NULL;\n\treturn 0;\n}",
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\tif (fib6_nh->fib_nh_gw_family) {",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [],
        "index": 36
    },
    {
        "var_name": "new_leaf",
        "function_name": "fib6_purge_rt",
        "location": {
            "file_path": "net/ipv6/ip6_fib.c",
            "region": {
                "startLine": 1059,
                "startColumn": 20,
                "endColumn": 28
            },
            "context": {
                "startLine": 1057,
                "endLine": 1061,
                "snippet": {
                    "text": "\t\t\t\tfib6_info_hold(new_leaf);"
                }
            }
        },
        "function_code": "static void fib6_purge_rt(struct fib6_info *rt, struct fib6_node *fn,\n\t\t\t  struct net *net)\n{\n\tstruct fib6_table *table = rt->fib6_table;\n\n\t/* Flush all cached dst in exception table */\n\trt6_flush_exceptions(rt);\n\tfib6_drop_pcpu_from(rt, table);\n\n\tif (rt->nh && !list_empty(&rt->nh_list))\n\t\tlist_del_init(&rt->nh_list);\n\n\tif (refcount_read(&rt->fib6_ref) != 1) {\n\t\t/* This route is used as dummy address holder in some split\n\t\t * nodes. It is not leaked, but it still holds other resources,\n\t\t * which must be released in time. So, scan ascendant nodes\n\t\t * and replace dummy references to this route with references\n\t\t * to still alive ones.\n\t\t */\n\t\twhile (fn) {\n\t\t\tstruct fib6_info *leaf = rcu_dereference_protected(fn->leaf,\n\t\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t\tstruct fib6_info *new_leaf;\n\t\t\tif (!(fn->fn_flags & RTN_RTINFO) && leaf == rt) {\n\t\t\t\tnew_leaf = fib6_find_prefix(net, table, fn);\n\t\t\t\tfib6_info_hold(new_leaf);\n\n\t\t\t\trcu_assign_pointer(fn->leaf, new_leaf);\n\t\t\t\tfib6_info_release(rt);\n\t\t\t}\n\t\t\tfn = rcu_dereference_protected(fn->parent,\n\t\t\t\t    lockdep_is_held(&table->tb6_lock));\n\t\t}\n\t}\n\n\tfib6_clean_expires(rt);\n\tfib6_remove_gc_list(rt);\n}",
        "function_list": [
            "fib6_find_prefix"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\t\t\tfib6_info_hold(new_leaf);",
                "condition": [
                    "if (refcount_read(&rt->fib6_ref) != 1)",
                    "while (fn)",
                    "if (!(fn->fn_flags & RTN_RTINFO) && leaf == rt)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [],
        "index": 37
    },
    {
        "var_name": "skb_in",
        "function_name": "icmpv6_ndo_send",
        "location": {
            "file_path": "net/ipv6/ip6_icmp.c",
            "region": {
                "startLine": 77,
                "startColumn": 16,
                "endColumn": 22
            },
            "context": {
                "startLine": 75,
                "endLine": 79,
                "snippet": {
                    "text": "\t__icmpv6_send(skb_in, type, code, info, &parm);"
                }
            }
        },
        "function_code": "void icmpv6_ndo_send(struct sk_buff *skb_in, u8 type, u8 code, __u32 info)\n{\n\tstruct inet6_skb_parm parm = { 0 };\n\tstruct sk_buff *cloned_skb = NULL;\n\tenum ip_conntrack_info ctinfo;\n\tstruct in6_addr orig_ip;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb_in, &ctinfo);\n\tif (!ct || !(ct->status & IPS_SRC_NAT)) {\n\t\t__icmpv6_send(skb_in, type, code, info, &parm);\n\t\treturn;\n\t}\n\n\tif (skb_shared(skb_in))\n\t\tskb_in = cloned_skb = skb_clone(skb_in, GFP_ATOMIC);\n\n\tif (unlikely(!skb_in || skb_network_header(skb_in) < skb_in->head ||\n\t    (skb_network_header(skb_in) + sizeof(struct ipv6hdr)) >\n\t    skb_tail_pointer(skb_in) || skb_ensure_writable(skb_in,\n\t    skb_network_offset(skb_in) + sizeof(struct ipv6hdr))))\n\t\tgoto out;\n\n\torig_ip = ipv6_hdr(skb_in)->saddr;\n\tipv6_hdr(skb_in)->saddr = ct->tuplehash[0].tuple.src.u3.in6;\n\t__icmpv6_send(skb_in, type, code, info, &parm);\n\tipv6_hdr(skb_in)->saddr = orig_ip;\nout:\n\tconsume_skb(cloned_skb);\n}",
        "result": 0,
        "explain": "unlikely(!ptr||...) goto",
        "bug_line_constraints": [
            {
                "text": "\t__icmpv6_send(skb_in, type, code, info, &parm);",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (!ct || !(ct->status & IPS_SRC_NAT))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (unlikely(!skb_in || skb_network_header(skb_in) < skb_in->head || (skb_network_header(skb_in) + sizeof(struct ipv6hdr)) > skb_tail_pointer(skb_in) || skb_ensure_writable(skb_in, skb_network_offset(skb_in) + sizeof(struct ipv6hdr))))"
                ]
            }
        ],
        "index": 38
    },
    {
        "var_name": "cloned_skb",
        "function_name": "icmpv6_ndo_send",
        "location": {
            "file_path": "net/ipv6/ip6_icmp.c",
            "region": {
                "startLine": 80,
                "startColumn": 14,
                "endColumn": 24
            },
            "context": {
                "startLine": 78,
                "endLine": 82,
                "snippet": {
                    "text": "\tconsume_skb(cloned_skb);"
                }
            }
        },
        "function_code": "void icmpv6_ndo_send(struct sk_buff *skb_in, u8 type, u8 code, __u32 info)\n{\n\tstruct inet6_skb_parm parm = { 0 };\n\tstruct sk_buff *cloned_skb = NULL;\n\tenum ip_conntrack_info ctinfo;\n\tstruct in6_addr orig_ip;\n\tstruct nf_conn *ct;\n\n\tct = nf_ct_get(skb_in, &ctinfo);\n\tif (!ct || !(ct->status & IPS_SRC_NAT)) {\n\t\t__icmpv6_send(skb_in, type, code, info, &parm);\n\t\treturn;\n\t}\n\n\tif (skb_shared(skb_in))\n\t\tskb_in = cloned_skb = skb_clone(skb_in, GFP_ATOMIC);\n\n\tif (unlikely(!skb_in || skb_network_header(skb_in) < skb_in->head ||\n\t    (skb_network_header(skb_in) + sizeof(struct ipv6hdr)) >\n\t    skb_tail_pointer(skb_in) || skb_ensure_writable(skb_in,\n\t    skb_network_offset(skb_in) + sizeof(struct ipv6hdr))))\n\t\tgoto out;\n\n\torig_ip = ipv6_hdr(skb_in)->saddr;\n\tipv6_hdr(skb_in)->saddr = ct->tuplehash[0].tuple.src.u3.in6;\n\t__icmpv6_send(skb_in, type, code, info, &parm);\n\tipv6_hdr(skb_in)->saddr = orig_ip;\nout:\n\tconsume_skb(cloned_skb);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tconsume_skb(cloned_skb);",
                "condition": [
                    "goto out"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct sk_buff *cloned_skb = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (!ct || !(ct->status & IPS_SRC_NAT))"
                ]
            }
        ],
        "index": 39
    },
    {
        "var_name": "curr_net",
        "function_name": "ipv6_list_rcv",
        "location": {
            "file_path": "net/ipv6/ip6_input.c",
            "region": {
                "startLine": 345,
                "startColumn": 41,
                "endColumn": 49
            },
            "context": {
                "startLine": 343,
                "endLine": 347,
                "snippet": {
                    "text": "\t\t\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);"
                }
            }
        },
        "function_code": "void ipv6_list_rcv(struct list_head *head, struct packet_type *pt,\n\t\t   struct net_device *orig_dev)\n{\n\tstruct net_device *curr_dev = NULL;\n\tstruct net *curr_net = NULL;\n\tstruct sk_buff *skb, *next;\n\tstruct list_head sublist;\n\n\tINIT_LIST_HEAD(&sublist);\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tstruct net_device *dev = skb->dev;\n\t\tstruct net *net = dev_net(dev);\n\n\t\tskb_list_del_init(skb);\n\t\tskb = ip6_rcv_core(skb, dev, net);\n\t\tif (skb == NULL)\n\t\t\tcontinue;\n\n\t\tif (curr_dev != dev || curr_net != net) {\n\t\t\t/* dispatch old sublist */\n\t\t\tif (!list_empty(&sublist))\n\t\t\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);\n\t\t\t/* start new sublist */\n\t\t\tINIT_LIST_HEAD(&sublist);\n\t\t\tcurr_dev = dev;\n\t\t\tcurr_net = net;\n\t\t}\n\t\tlist_add_tail(&skb->list, &sublist);\n\t}\n\t/* dispatch final sublist */\n\tif (!list_empty(&sublist))\n\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);\n}",
        "result": 0,
        "explain": "for{if(){}}",
        "bug_line_constraints": [
            {
                "text": "\t\t\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);",
                "condition": [
                    "if (!list_empty(&sublist))",
                    "if (curr_dev != dev || curr_net != net)"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct net *curr_net = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [
            {
                "text": "if (curr_dev != dev || curr_net != net)",
                "condition": [
                    "list_for_each_entry_safe(skb, next, head, list)"
                ],
                "content": "\t\tif (curr_dev != dev || curr_net != net) {\n\t\t\t/* dispatch old sublist */\n\t\t\tif (!list_empty(&sublist))\n\t\t\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);\n\t\t\t/* start new sublist */\n\t\t\tINIT_LIST_HEAD(&sublist);\n\t\t\tcurr_dev = dev;\n\t\t\tcurr_net = net;\n\t\t}"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "continue;",
                "condition": [
                    "list_for_each_entry_safe(skb, next, head, list)",
                    "if (skb == NULL)"
                ]
            }
        ],
        "index": 40
    },
    {
        "var_name": "curr_net",
        "function_name": "ipv6_list_rcv",
        "location": {
            "file_path": "net/ipv6/ip6_input.c",
            "region": {
                "startLine": 355,
                "startColumn": 39,
                "endColumn": 47
            },
            "context": {
                "startLine": 353,
                "endLine": 357,
                "snippet": {
                    "text": "\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);"
                }
            }
        },
        "function_code": "void ipv6_list_rcv(struct list_head *head, struct packet_type *pt,\n\t\t   struct net_device *orig_dev)\n{\n\tstruct net_device *curr_dev = NULL;\n\tstruct net *curr_net = NULL;\n\tstruct sk_buff *skb, *next;\n\tstruct list_head sublist;\n\n\tINIT_LIST_HEAD(&sublist);\n\tlist_for_each_entry_safe(skb, next, head, list) {\n\t\tstruct net_device *dev = skb->dev;\n\t\tstruct net *net = dev_net(dev);\n\n\t\tskb_list_del_init(skb);\n\t\tskb = ip6_rcv_core(skb, dev, net);\n\t\tif (skb == NULL)\n\t\t\tcontinue;\n\n\t\tif (curr_dev != dev || curr_net != net) {\n\t\t\t/* dispatch old sublist */\n\t\t\tif (!list_empty(&sublist))\n\t\t\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);\n\t\t\t/* start new sublist */\n\t\t\tINIT_LIST_HEAD(&sublist);\n\t\t\tcurr_dev = dev;\n\t\t\tcurr_net = net;\n\t\t}\n\t\tlist_add_tail(&skb->list, &sublist);\n\t}\n\t/* dispatch final sublist */\n\tif (!list_empty(&sublist))\n\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);",
                "condition": [
                    "if (!list_empty(&sublist))"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct net *curr_net = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [
            {
                "text": "if (curr_dev != dev || curr_net != net)",
                "condition": [
                    "list_for_each_entry_safe(skb, next, head, list)"
                ],
                "content": "\t\tif (curr_dev != dev || curr_net != net) {\n\t\t\t/* dispatch old sublist */\n\t\t\tif (!list_empty(&sublist))\n\t\t\t\tip6_sublist_rcv(&sublist, curr_dev, curr_net);\n\t\t\t/* start new sublist */\n\t\t\tINIT_LIST_HEAD(&sublist);\n\t\t\tcurr_dev = dev;\n\t\t\tcurr_net = net;\n\t\t}"
            }
        ],
        "early_jump_constraints": [],
        "index": 41
    },
    {
        "var_name": "skb_prev",
        "function_name": "__ip6_append_data",
        "location": {
            "file_path": "net/ipv6/ip6_output.c",
            "region": {
                "startLine": 1677,
                "startColumn": 31,
                "endColumn": 39
            },
            "context": {
                "startLine": 1675,
                "endLine": 1679,
                "snippet": {
                    "text": "\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,"
                }
            }
        },
        "function_code": "static int __ip6_append_data(struct sock *sk,\n\t\t\t     struct sk_buff_head *queue,\n\t\t\t     struct inet_cork_full *cork_full,\n\t\t\t     struct inet6_cork *v6_cork,\n\t\t\t     struct page_frag *pfrag,\n\t\t\t     int getfrag(void *from, char *to, int offset,\n\t\t\t\t\t int len, int odd, struct sk_buff *skb),\n\t\t\t     void *from, size_t length, int transhdrlen,\n\t\t\t     unsigned int flags, struct ipcm6_cookie *ipc6)\n{\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tstruct inet_cork *cork = &cork_full->base;\n\tstruct flowi6 *fl6 = &cork_full->fl.u.ip6;\n\tunsigned int maxfraglen, fragheaderlen, mtu, orig_mtu, pmtu;\n\tstruct ubuf_info *uarg = NULL;\n\tint exthdrlen = 0;\n\tint dst_exthdrlen = 0;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\tbool zc = false;\n\tu32 tskey = 0;\n\tstruct rt6_info *rt = dst_rt6_info(cork->dst);\n\tbool paged, hold_tskey, extra_uref = false;\n\tstruct ipv6_txoptions *opt = v6_cork->opt;\n\tint csummode = CHECKSUM_NONE;\n\tunsigned int maxnonfragsize, headersize;\n\tunsigned int wmem_alloc_delta = 0;\n\n\tskb = skb_peek_tail(queue);\n\tif (!skb) {\n\t\texthdrlen = opt ? opt->opt_flen : 0;\n\t\tdst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;\n\t}\n\n\tpaged = !!cork->gso_size;\n\tmtu = cork->gso_size ? IP6_MAX_MTU : cork->fragsize;\n\torig_mtu = mtu;\n\n\thh_len = LL_RESERVED_SPACE(rt->dst.dev);\n\n\tfragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +\n\t\t\t(opt ? opt->opt_nflen : 0);\n\n\theadersize = sizeof(struct ipv6hdr) +\n\t\t     (opt ? opt->opt_flen + opt->opt_nflen : 0) +\n\t\t     rt->rt6i_nfheader_len;\n\n\tif (mtu <= fragheaderlen ||\n\t    ((mtu - fragheaderlen) & ~7) + fragheaderlen <= sizeof(struct frag_hdr))\n\t\tgoto emsgsize;\n\n\tmaxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen -\n\t\t     sizeof(struct frag_hdr);\n\n\t/* as per RFC 7112 section 5, the entire IPv6 Header Chain must fit\n\t * the first fragment\n\t */\n\tif (headersize + transhdrlen > mtu)\n\t\tgoto emsgsize;\n\n\tif (cork->length + length > mtu - headersize && ipc6->dontfrag &&\n\t    (sk->sk_protocol == IPPROTO_UDP ||\n\t     sk->sk_protocol == IPPROTO_ICMPV6 ||\n\t     sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu - headersize +\n\t\t\t\tsizeof(struct ipv6hdr));\n\t\tgoto emsgsize;\n\t}\n\n\tif (ip6_sk_ignore_df(sk))\n\t\tmaxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;\n\telse\n\t\tmaxnonfragsize = mtu;\n\n\tif (cork->length + length > maxnonfragsize - headersize) {\nemsgsize:\n\t\tpmtu = max_t(int, mtu - headersize + sizeof(struct ipv6hdr), 0);\n\t\tipv6_local_error(sk, EMSGSIZE, fl6, pmtu);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/* CHECKSUM_PARTIAL only with no extension headers and when\n\t * we are not going to fragment\n\t */\n\tif (transhdrlen && sk->sk_protocol == IPPROTO_UDP &&\n\t    headersize == sizeof(struct ipv6hdr) &&\n\t    length <= mtu - headersize &&\n\t    (!(flags & MSG_MORE) || cork->gso_size) &&\n\t    rt->dst.dev->features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))\n\t\tcsummode = CHECKSUM_PARTIAL;\n\n\tif ((flags & MSG_ZEROCOPY) && length) {\n\t\tstruct msghdr *msg = from;\n\n\t\tif (getfrag == ip_generic_getfrag && msg->msg_ubuf) {\n\t\t\tif (skb_zcopy(skb) && msg->msg_ubuf != skb_zcopy(skb))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Leave uarg NULL if can't zerocopy, callers should\n\t\t\t * be able to handle it.\n\t\t\t */\n\t\t\tif ((rt->dst.dev->features & NETIF_F_SG) &&\n\t\t\t    csummode == CHECKSUM_PARTIAL) {\n\t\t\t\tpaged = true;\n\t\t\t\tzc = true;\n\t\t\t\tuarg = msg->msg_ubuf;\n\t\t\t}\n\t\t} else if (sock_flag(sk, SOCK_ZEROCOPY)) {\n\t\t\tuarg = msg_zerocopy_realloc(sk, length, skb_zcopy(skb));\n\t\t\tif (!uarg)\n\t\t\t\treturn -ENOBUFS;\n\t\t\textra_uref = !skb_zcopy(skb);\t/* only ref on new uarg */\n\t\t\tif (rt->dst.dev->features & NETIF_F_SG &&\n\t\t\t    csummode == CHECKSUM_PARTIAL) {\n\t\t\t\tpaged = true;\n\t\t\t\tzc = true;\n\t\t\t} else {\n\t\t\t\tuarg_to_msgzc(uarg)->zerocopy = 0;\n\t\t\t\tskb_zcopy_set(skb, uarg, &extra_uref);\n\t\t\t}\n\t\t}\n\t} else if ((flags & MSG_SPLICE_PAGES) && length) {\n\t\tif (inet_test_bit(HDRINCL, sk))\n\t\t\treturn -EPERM;\n\t\tif (rt->dst.dev->features & NETIF_F_SG &&\n\t\t    getfrag == ip_generic_getfrag)\n\t\t\t/* We need an empty buffer to attach stuff to */\n\t\t\tpaged = true;\n\t\telse\n\t\t\tflags &= ~MSG_SPLICE_PAGES;\n\t}\n\n\thold_tskey = cork->tx_flags & SKBTX_ANY_TSTAMP &&\n\t\t     READ_ONCE(sk->sk_tsflags) & SOF_TIMESTAMPING_OPT_ID;\n\tif (hold_tskey)\n\t\ttskey = atomic_inc_return(&sk->sk_tskey) - 1;\n\n\t/*\n\t * Let's try using as much space as possible.\n\t * Use MTU if total length of the message fits into the MTU.\n\t * Otherwise, we need to reserve fragment header and\n\t * fragment alignment (= 8-15 octects, in total).\n\t *\n\t * Note that we may need to \"move\" the data from the tail\n\t * of the buffer to the new fragment when we split\n\t * the message.\n\t *\n\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\n\tcork->length += length;\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen, alloc_extra;\n\t\t\tunsigned int pagedlen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (!skb || !skb_prev)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    orig_mtu);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\t\t\tpagedlen = 0;\n\n\t\t\talloc_extra = hh_len;\n\t\t\talloc_extra += dst_exthdrlen;\n\t\t\talloc_extra += rt->dst.trailer_len;\n\n\t\t\t/* We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloc_extra += sizeof(struct frag_hdr);\n\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse if (!paged &&\n\t\t\t\t (fraglen + alloc_extra < SKB_MAX_ALLOC ||\n\t\t\t\t  !(rt->dst.dev->features & NETIF_F_SG)))\n\t\t\t\talloclen = fraglen;\n\t\t\telse {\n\t\t\t\talloclen = fragheaderlen + transhdrlen;\n\t\t\t\tpagedlen = datalen - transhdrlen;\n\t\t\t}\n\t\t\talloclen += alloc_extra;\n\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\n\t\t\tfraglen = datalen + fragheaderlen;\n\n\t\t\tcopy = datalen - transhdrlen - fraggap - pagedlen;\n\t\t\t/* [!] NOTE: copy may be negative if pagedlen>0\n\t\t\t * because then the equation may reduces to -fraggap.\n\t\t\t */\n\t\t\tif (copy < 0 && !(flags & MSG_SPLICE_PAGES)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk, alloclen,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (refcount_read(&sk->sk_wmem_alloc) + wmem_alloc_delta <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = alloc_skb(alloclen,\n\t\t\t\t\t\t\tsk->sk_allocation);\n\t\t\t\tif (unlikely(!skb))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t}\n\t\t\tif (!skb)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = csummode;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +\n\t\t\t\t    dst_exthdrlen);\n\n\t\t\t/*\n\t\t\t *\tFind where to start putting bytes\n\t\t\t */\n\t\t\tdata = skb_put(skb, fraglen - pagedlen);\n\t\t\tskb_set_network_header(skb, exthdrlen);\n\t\t\tdata += fragheaderlen;\n\t\t\tskb->transport_header = (skb->network_header +\n\t\t\t\t\t\t fragheaderlen);\n\t\t\tif (fraggap) {\n\t\t\t\tskb->csum = skb_copy_and_csum_bits(\n\t\t\t\t\tskb_prev, maxfraglen,\n\t\t\t\t\tdata + transhdrlen, fraggap);\n\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,\n\t\t\t\t\t\t\t  skb->csum);\n\t\t\t\tdata += fraggap;\n\t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n\t\t\t}\n\t\t\tif (copy > 0 &&\n\t\t\t    getfrag(from, data + transhdrlen, offset,\n\t\t\t\t    copy, fraggap, skb) < 0) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tgoto error;\n\t\t\t} else if (flags & MSG_SPLICE_PAGES) {\n\t\t\t\tcopy = 0;\n\t\t\t}\n\n\t\t\toffset += copy;\n\t\t\tlength -= copy + transhdrlen;\n\t\t\ttranshdrlen = 0;\n\t\t\texthdrlen = 0;\n\t\t\tdst_exthdrlen = 0;\n\n\t\t\t/* Only the initial fragment is time stamped */\n\t\t\tskb_shinfo(skb)->tx_flags = cork->tx_flags;\n\t\t\tcork->tx_flags = 0;\n\t\t\tskb_shinfo(skb)->tskey = tskey;\n\t\t\ttskey = 0;\n\t\t\tskb_zcopy_set(skb, uarg, &extra_uref);\n\n\t\t\tif ((flags & MSG_CONFIRM) && !skb_prev)\n\t\t\t\tskb_set_dst_pending_confirm(skb, 1);\n\n\t\t\t/*\n\t\t\t * Put the packet on the pending queue\n\t\t\t */\n\t\t\tif (!skb->destructor) {\n\t\t\t\tskb->destructor = sock_wfree;\n\t\t\t\tskb->sk = sk;\n\t\t\t\twmem_alloc_delta += skb->truesize;\n\t\t\t}\n\t\t\t__skb_queue_tail(queue, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (copy > length)\n\t\t\tcopy = length;\n\n\t\tif (!(rt->dst.dev->features&NETIF_F_SG) &&\n\t\t    skb_tailroom(skb) >= copy) {\n\t\t\tunsigned int off;\n\n\t\t\toff = skb->len;\n\t\t\tif (getfrag(from, skb_put(skb, copy),\n\t\t\t\t\t\toffset, copy, off, skb) < 0) {\n\t\t\t\t__skb_trim(skb, off);\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t} else if (flags & MSG_SPLICE_PAGES) {\n\t\t\tstruct msghdr *msg = from;\n\n\t\t\terr = -EIO;\n\t\t\tif (WARN_ON_ONCE(copy > msg->msg_iter.count))\n\t\t\t\tgoto error;\n\n\t\t\terr = skb_splice_from_iter(skb, &msg->msg_iter, copy,\n\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t\tcopy = err;\n\t\t\twmem_alloc_delta += copy;\n\t\t} else if (!zc) {\n\t\t\tint i = skb_shinfo(skb)->nr_frags;\n\n\t\t\terr = -ENOMEM;\n\t\t\tif (!sk_page_frag_refill(sk, pfrag))\n\t\t\t\tgoto error;\n\n\t\t\tskb_zcopy_downgrade_managed(skb);\n\t\t\tif (!skb_can_coalesce(skb, i, pfrag->page,\n\t\t\t\t\t      pfrag->offset)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tif (i == MAX_SKB_FRAGS)\n\t\t\t\t\tgoto error;\n\n\t\t\t\t__skb_fill_page_desc(skb, i, pfrag->page,\n\t\t\t\t\t\t     pfrag->offset, 0);\n\t\t\t\tskb_shinfo(skb)->nr_frags = ++i;\n\t\t\t\tget_page(pfrag->page);\n\t\t\t}\n\t\t\tcopy = min_t(int, copy, pfrag->size - pfrag->offset);\n\t\t\tif (getfrag(from,\n\t\t\t\t    page_address(pfrag->page) + pfrag->offset,\n\t\t\t\t    offset, copy, skb->len, skb) < 0)\n\t\t\t\tgoto error_efault;\n\n\t\t\tpfrag->offset += copy;\n\t\t\tskb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);\n\t\t\tskb->len += copy;\n\t\t\tskb->data_len += copy;\n\t\t\tskb->truesize += copy;\n\t\t\twmem_alloc_delta += copy;\n\t\t} else {\n\t\t\terr = skb_zerocopy_iter_dgram(skb, from, copy);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t\toffset += copy;\n\t\tlength -= copy;\n\t}\n\n\tif (wmem_alloc_delta)\n\t\trefcount_add(wmem_alloc_delta, &sk->sk_wmem_alloc);\n\treturn 0;\n\nerror_efault:\n\terr = -EFAULT;\nerror:\n\tnet_zcopy_put_abort(uarg, extra_uref);\n\tcork->length -= length;\n\tIP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);\n\trefcount_add(wmem_alloc_delta, &sk->sk_wmem_alloc);\n\tif (hold_tskey)\n\t\tatomic_dec(&sk->sk_tskey);\n\treturn err;\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\t\tskb_prev->csum = csum_sub(skb_prev->csum,",
                "condition": [
                    "goto alloc_new_skb",
                    "if (fraggap)"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct sk_buff *skb, *skb_prev = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [
            {
                "text": "if (!skb || !skb_prev)",
                "condition": [
                    "while (length > 0)",
                    "if (copy <= 0)"
                ],
                "content": "\t\t\tif (!skb || !skb_prev)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    orig_mtu);\n"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "goto emsgsize;",
                "condition": [
                    "if (mtu <= fragheaderlen || ((mtu - fragheaderlen) & ~7) + fragheaderlen <= sizeof(struct frag_hdr))"
                ]
            },
            {
                "text": "goto emsgsize;",
                "condition": [
                    "if (headersize + transhdrlen > mtu)"
                ]
            },
            {
                "text": "goto emsgsize;",
                "condition": [
                    "if (cork->length + length > mtu - headersize && ipc6->dontfrag && (sk->sk_protocol == IPPROTO_UDP || sk->sk_protocol == IPPROTO_ICMPV6 || sk->sk_protocol == IPPROTO_RAW))"
                ]
            },
            {
                "text": "return -EMSGSIZE;",
                "condition": [
                    "if (cork->length + length > maxnonfragsize - headersize)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if ((flags & MSG_ZEROCOPY) && length)",
                    "if (getfrag == ip_generic_getfrag && msg->msg_ubuf)",
                    "if (skb_zcopy(skb) && msg->msg_ubuf != skb_zcopy(skb))"
                ]
            },
            {
                "text": "return -ENOBUFS;",
                "condition": [
                    "if ((flags & MSG_ZEROCOPY) && length)",
                    "if (sock_flag(sk, SOCK_ZEROCOPY))",
                    "if (!uarg)"
                ]
            },
            {
                "text": "return -EPERM;",
                "condition": [
                    "if ((flags & MSG_SPLICE_PAGES) && length)",
                    "if (inet_test_bit(HDRINCL, sk))"
                ]
            },
            {
                "text": "goto error;",
                "condition": [
                    "while (length > 0)",
                    "if (copy <= 0)",
                    "if (copy < 0 && !(flags & MSG_SPLICE_PAGES))"
                ]
            },
            {
                "text": "goto error;",
                "condition": [
                    "while (length > 0)",
                    "if (copy <= 0)",
                    "if (!skb)"
                ]
            }
        ],
        "index": 42
    },
    {
        "var_name": "neigh",
        "function_name": "ip6_finish_output2",
        "location": {
            "file_path": "net/ipv6/ip6_output.c",
            "region": {
                "startLine": 136,
                "startColumn": 26,
                "endColumn": 31
            },
            "context": {
                "startLine": 134,
                "endLine": 138,
                "snippet": {
                    "text": "\tsock_confirm_neigh(skb, neigh);"
                }
            }
        },
        "function_code": "static int ip6_finish_output2(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct net_device *dev = dst->dev;\n\tstruct inet6_dev *idev = ip6_dst_idev(dst);\n\tunsigned int hh_len = LL_RESERVED_SPACE(dev);\n\tconst struct in6_addr *daddr, *nexthop;\n\tstruct ipv6hdr *hdr;\n\tstruct neighbour *neigh;\n\tint ret;\n\n\t/* Be paranoid, rather than too clever. */\n\tif (unlikely(hh_len > skb_headroom(skb)) && dev->header_ops) {\n\t\tskb = skb_expand_head(skb, hh_len);\n\t\tif (!skb) {\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\thdr = ipv6_hdr(skb);\n\tdaddr = &hdr->daddr;\n\tif (ipv6_addr_is_multicast(daddr)) {\n\t\tif (!(dev->flags & IFF_LOOPBACK) && sk_mc_loop(sk) &&\n\t\t    ((mroute6_is_socket(net, skb) &&\n\t\t     !(IP6CB(skb)->flags & IP6SKB_FORWARDED)) ||\n\t\t     ipv6_chk_mcast_addr(dev, daddr, &hdr->saddr))) {\n\t\t\tstruct sk_buff *newskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t/* Do not check for IFF_ALLMULTI; multicast routing\n\t\t\t   is not supported in any case.\n\t\t\t */\n\t\t\tif (newskb)\n\t\t\t\tNF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING,\n\t\t\t\t\tnet, sk, newskb, NULL, newskb->dev,\n\t\t\t\t\tdev_loopback_xmit);\n\n\t\t\tif (hdr->hop_limit == 0) {\n\t\t\t\tIP6_INC_STATS(net, idev,\n\t\t\t\t\t      IPSTATS_MIB_OUTDISCARDS);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, skb->len);\n\t\tif (IPV6_ADDR_MC_SCOPE(daddr) <= IPV6_ADDR_SCOPE_NODELOCAL &&\n\t\t    !(dev->flags & IFF_LOOPBACK)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (lwtunnel_xmit_redirect(dst->lwtstate)) {\n\t\tint res = lwtunnel_xmit(skb);\n\n\t\tif (res != LWTUNNEL_XMIT_CONTINUE)\n\t\t\treturn res;\n\t}\n\n\tIP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUT, skb->len);\n\n\trcu_read_lock();\n\tnexthop = rt6_nexthop(dst_rt6_info(dst), daddr);\n\tneigh = __ipv6_neigh_lookup_noref(dev, nexthop);\n\n\tif (unlikely(IS_ERR_OR_NULL(neigh))) {\n\t\tif (unlikely(!neigh))\n\t\t\tneigh = __neigh_create(&nd_tbl, nexthop, dev, false);\n\t\tif (IS_ERR(neigh)) {\n\t\t\trcu_read_unlock();\n\t\t\tIP6_INC_STATS(net, idev, IPSTATS_MIB_OUTNOROUTES);\n\t\t\tkfree_skb_reason(skb, SKB_DROP_REASON_NEIGH_CREATEFAIL);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tsock_confirm_neigh(skb, neigh);\n\tret = neigh_output(neigh, skb, false);\n\trcu_read_unlock();\n\treturn ret;\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tsock_confirm_neigh(skb, neigh);",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -ENOMEM;",
                "condition": [
                    "if (unlikely(hh_len > skb_headroom(skb)) && dev->header_ops)",
                    "if (!skb)"
                ]
            },
            {
                "text": "return 0;",
                "condition": [
                    "if (ipv6_addr_is_multicast(daddr))",
                    "if (!(dev->flags & IFF_LOOPBACK) && sk_mc_loop(sk) && ((mroute6_is_socket(net, skb) && !(IP6CB(skb)->flags & IP6SKB_FORWARDED)) || ipv6_chk_mcast_addr(dev, daddr, &hdr->saddr)))",
                    "if (hdr->hop_limit == 0)"
                ]
            },
            {
                "text": "return 0;",
                "condition": [
                    "if (ipv6_addr_is_multicast(daddr))",
                    "if (IPV6_ADDR_MC_SCOPE(daddr) <= IPV6_ADDR_SCOPE_NODELOCAL && !(dev->flags & IFF_LOOPBACK))"
                ]
            },
            {
                "text": "return res;",
                "condition": [
                    "if (lwtunnel_xmit_redirect(dst->lwtstate))",
                    "if (res != LWTUNNEL_XMIT_CONTINUE)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (unlikely(IS_ERR_OR_NULL(neigh)))",
                    "if (IS_ERR(neigh))"
                ]
            }
        ],
        "index": 43
    },
    {
        "var_name": "new",
        "function_name": "ipv6_set_opt_hdr",
        "location": {
            "file_path": "net/ipv6/ipv6_sockglue.c",
            "region": {
                "startLine": 355,
                "startColumn": 8,
                "endColumn": 11
            },
            "context": {
                "startLine": 353,
                "endLine": 357,
                "snippet": {
                    "text": "\tkfree(new);"
                }
            }
        },
        "function_code": "static int ipv6_set_opt_hdr(struct sock *sk, int optname, sockptr_t optval,\n\t\tint optlen)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct ipv6_opt_hdr *new = NULL;\n\tstruct net *net = sock_net(sk);\n\tstruct ipv6_txoptions *opt;\n\tint err;\n\n\t/* hop-by-hop / destination options are privileged option */\n\tif (optname != IPV6_RTHDR && !sockopt_ns_capable(net->user_ns, CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\t/* remove any sticky options header with a zero option\n\t * length, per RFC3542.\n\t */\n\tif (optlen > 0) {\n\t\tif (sockptr_is_null(optval))\n\t\t\treturn -EINVAL;\n\t\tif (optlen < sizeof(struct ipv6_opt_hdr) ||\n\t\t    optlen & 0x7 ||\n\t\t    optlen > 8 * 255)\n\t\t\treturn -EINVAL;\n\n\t\tnew = memdup_sockptr(optval, optlen);\n\t\tif (IS_ERR(new))\n\t\t\treturn PTR_ERR(new);\n\t\tif (unlikely(ipv6_optlen(new) > optlen)) {\n\t\t\tkfree(new);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\topt = rcu_dereference_protected(np->opt, lockdep_sock_is_held(sk));\n\topt = ipv6_renew_options(sk, opt, optname, new);\n\tkfree(new);\n\tif (IS_ERR(opt))\n\t\treturn PTR_ERR(opt);\n\n\t/* routing header option needs extra check */\n\terr = -EINVAL;\n\tif (optname == IPV6_RTHDR && opt && opt->srcrt) {\n\t\tstruct ipv6_rt_hdr *rthdr = opt->srcrt;\n\t\tswitch (rthdr->type) {\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\tcase IPV6_SRCRT_TYPE_2:\n\t\t\tif (rthdr->hdrlen != 2 || rthdr->segments_left != 1)\n\t\t\t\tgoto sticky_done;\n\t\t\tbreak;\n#endif\n\t\tcase IPV6_SRCRT_TYPE_4:\n\t\t{\n\t\t\tstruct ipv6_sr_hdr *srh =\n\t\t\t\t(struct ipv6_sr_hdr *)opt->srcrt;\n\n\t\t\tif (!seg6_validate_srh(srh, optlen, false))\n\t\t\t\tgoto sticky_done;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tgoto sticky_done;\n\t\t}\n\t}\n\n\terr = 0;\n\topt = ipv6_update_options(sk, opt);\nsticky_done:\n\tif (opt) {\n\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\ttxopt_put(opt);\n\t}\n\treturn err;\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree(new);",
                "condition": []
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct ipv6_opt_hdr *new = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -EPERM;",
                "condition": [
                    "if (optname != IPV6_RTHDR && !sockopt_ns_capable(net->user_ns, CAP_NET_RAW))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (optlen > 0)",
                    "if (sockptr_is_null(optval))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (optlen > 0)",
                    "if (optlen < sizeof(struct ipv6_opt_hdr) || optlen & 0x7 || optlen > 8 * 255)"
                ]
            },
            {
                "text": "return PTR_ERR(new);",
                "condition": [
                    "if (optlen > 0)",
                    "if (IS_ERR(new))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (optlen > 0)",
                    "if (unlikely(ipv6_optlen(new) > optlen))"
                ]
            }
        ],
        "index": 44
    },
    {
        "var_name": "skb",
        "function_name": "igmp6_event_report",
        "location": {
            "file_path": "net/ipv6/mcast.c",
            "region": {
                "startLine": 1558,
                "startColumn": 12,
                "endColumn": 15
            },
            "context": {
                "startLine": 1556,
                "endLine": 1560,
                "snippet": {
                    "text": "\tkfree_skb(skb);"
                }
            }
        },
        "function_code": "void igmp6_event_report(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev || idev->dead)\n\t\tgoto out;\n\n\tspin_lock_bh(&idev->mc_report_lock);\n\tif (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_report_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_report_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t\tskb = NULL;\n\t}\n\tspin_unlock_bh(&idev->mc_report_lock);\nout:\n\tkfree_skb(skb);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree_skb(skb);",
                "condition": [
                    "goto out"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "skb = NULL;",
                "condition": [
                    "if (skb_queue_len(&idev->mc_report_queue) < MLD_MAX_SKBS)"
                ]
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [],
        "index": 45
    },
    {
        "var_name": "mlh2",
        "function_name": "__mld_query_work",
        "location": {
            "file_path": "net/ipv6/mcast.c",
            "region": {
                "startLine": 1495,
                "startColumn": 34,
                "endColumn": 38
            },
            "context": {
                "startLine": 1493,
                "endLine": 1497,
                "snippet": {
                    "text": "\t\t\t    mld_marksources(ma, ntohs(mlh2->mld2q_nsrcs), mlh2->mld2q_srcs))"
                }
            }
        },
        "function_code": "static void __mld_query_work(struct sk_buff *skb)\n{\n\tstruct mld2_query *mlh2 = NULL;\n\tconst struct in6_addr *group;\n\tunsigned long max_delay;\n\tstruct inet6_dev *idev;\n\tstruct ifmcaddr6 *ma;\n\tstruct mld_msg *mld;\n\tint group_type;\n\tint mark = 0;\n\tint len, err;\n\n\tif (!pskb_may_pull(skb, sizeof(struct in6_addr)))\n\t\tgoto kfree_skb;\n\n\t/* compute payload length excluding extension headers */\n\tlen = ntohs(ipv6_hdr(skb)->payload_len) + sizeof(struct ipv6hdr);\n\tlen -= skb_network_header_len(skb);\n\n\t/* RFC3810 6.2\n\t * Upon reception of an MLD message that contains a Query, the node\n\t * checks if the source address of the message is a valid link-local\n\t * address, if the Hop Limit is set to 1, and if the Router Alert\n\t * option is present in the Hop-By-Hop Options header of the IPv6\n\t * packet.  If any of these checks fails, the packet is dropped.\n\t */\n\tif (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL) ||\n\t    ipv6_hdr(skb)->hop_limit != 1 ||\n\t    !(IP6CB(skb)->flags & IP6SKB_ROUTERALERT) ||\n\t    IP6CB(skb)->ra != htons(IPV6_OPT_ROUTERALERT_MLD))\n\t\tgoto kfree_skb;\n\n\tidev = in6_dev_get(skb->dev);\n\tif (!idev)\n\t\tgoto kfree_skb;\n\n\tmld = (struct mld_msg *)icmp6_hdr(skb);\n\tgroup = &mld->mld_mca;\n\tgroup_type = ipv6_addr_type(group);\n\n\tif (group_type != IPV6_ADDR_ANY &&\n\t    !(group_type&IPV6_ADDR_MULTICAST))\n\t\tgoto out;\n\n\tif (len < MLD_V1_QUERY_LEN) {\n\t\tgoto out;\n\t} else if (len == MLD_V1_QUERY_LEN || mld_in_v1_mode(idev)) {\n\t\terr = mld_process_v1(idev, mld, &max_delay,\n\t\t\t\t     len == MLD_V1_QUERY_LEN);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t} else if (len >= MLD_V2_QUERY_LEN_MIN) {\n\t\tint srcs_offset = sizeof(struct mld2_query) -\n\t\t\t\t  sizeof(struct icmp6hdr);\n\n\t\tif (!pskb_may_pull(skb, srcs_offset))\n\t\t\tgoto out;\n\n\t\tmlh2 = (struct mld2_query *)skb_transport_header(skb);\n\n\t\tmld_process_v2(idev, mlh2, &max_delay);\n\n\t\tif (group_type == IPV6_ADDR_ANY) { /* general query */\n\t\t\tif (mlh2->mld2q_nsrcs)\n\t\t\t\tgoto out; /* no sources allowed */\n\n\t\t\tmld_gq_start_work(idev);\n\t\t\tgoto out;\n\t\t}\n\t\t/* mark sources to include, if group & source-specific */\n\t\tif (mlh2->mld2q_nsrcs != 0) {\n\t\t\tif (!pskb_may_pull(skb, srcs_offset +\n\t\t\t    ntohs(mlh2->mld2q_nsrcs) * sizeof(struct in6_addr)))\n\t\t\t\tgoto out;\n\n\t\t\tmlh2 = (struct mld2_query *)skb_transport_header(skb);\n\t\t\tmark = 1;\n\t\t}\n\t} else {\n\t\tgoto out;\n\t}\n\n\tif (group_type == IPV6_ADDR_ANY) {\n\t\tfor_each_mc_mclock(idev, ma) {\n\t\t\tigmp6_group_queried(ma, max_delay);\n\t\t}\n\t} else {\n\t\tfor_each_mc_mclock(idev, ma) {\n\t\t\tif (!ipv6_addr_equal(group, &ma->mca_addr))\n\t\t\t\tcontinue;\n\t\t\tif (ma->mca_flags & MAF_TIMER_RUNNING) {\n\t\t\t\t/* gsquery <- gsquery && mark */\n\t\t\t\tif (!mark)\n\t\t\t\t\tma->mca_flags &= ~MAF_GSQUERY;\n\t\t\t} else {\n\t\t\t\t/* gsquery <- mark */\n\t\t\t\tif (mark)\n\t\t\t\t\tma->mca_flags |= MAF_GSQUERY;\n\t\t\t\telse\n\t\t\t\t\tma->mca_flags &= ~MAF_GSQUERY;\n\t\t\t}\n\t\t\tif (!(ma->mca_flags & MAF_GSQUERY) ||\n\t\t\t    mld_marksources(ma, ntohs(mlh2->mld2q_nsrcs), mlh2->mld2q_srcs))\n\t\t\t\tigmp6_group_queried(ma, max_delay);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tin6_dev_put(idev);\nkfree_skb:\n\tconsume_skb(skb);\n}",
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\t\t    mld_marksources(ma, ntohs(mlh2->mld2q_nsrcs), mlh2->mld2q_srcs))",
                "condition": [
                    "if(!(group_type == IPV6_ADDR_ANY))",
                    "for_each_mc_mclock(idev, ma)"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct mld2_query *mlh2 = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto kfree_skb;",
                "condition": [
                    "if (!pskb_may_pull(skb, sizeof(struct in6_addr)))"
                ]
            },
            {
                "text": "goto kfree_skb;",
                "condition": [
                    "if (!(ipv6_addr_type(&ipv6_hdr(skb)->saddr) & IPV6_ADDR_LINKLOCAL) || ipv6_hdr(skb)->hop_limit != 1 || !(IP6CB(skb)->flags & IP6SKB_ROUTERALERT) || IP6CB(skb)->ra != htons(IPV6_OPT_ROUTERALERT_MLD))"
                ]
            },
            {
                "text": "goto kfree_skb;",
                "condition": [
                    "if (!idev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (group_type != IPV6_ADDR_ANY && !(group_type&IPV6_ADDR_MULTICAST))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (len < MLD_V1_QUERY_LEN)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (len == MLD_V1_QUERY_LEN || mld_in_v1_mode(idev))",
                    "if (err < 0)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (len >= MLD_V2_QUERY_LEN_MIN)",
                    "if (!pskb_may_pull(skb, srcs_offset))"
                ]
            },
            {
                "text": "goto out; /* no sources allowed */",
                "condition": [
                    "if (len >= MLD_V2_QUERY_LEN_MIN)",
                    "if (group_type == IPV6_ADDR_ANY) { /* general query */",
                    "if (mlh2->mld2q_nsrcs)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (len >= MLD_V2_QUERY_LEN_MIN)",
                    "if (group_type == IPV6_ADDR_ANY) { /* general query */"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (len >= MLD_V2_QUERY_LEN_MIN)",
                    "if (mlh2->mld2q_nsrcs != 0)",
                    "if (!pskb_may_pull(skb, srcs_offset + ntohs(mlh2->mld2q_nsrcs) * sizeof(struct in6_addr)))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if(!(len < MLD_V1_QUERY_LEN) && !(len == MLD_V1_QUERY_LEN || mld_in_v1_mode(idev)) && !(len >= MLD_V2_QUERY_LEN_MIN))"
                ]
            },
            {
                "text": "continue;",
                "condition": [
                    "if(!(group_type == IPV6_ADDR_ANY))",
                    "for_each_mc_mclock(idev, ma)",
                    "if (!ipv6_addr_equal(group, &ma->mca_addr))"
                ]
            }
        ],
        "index": 46
    },
    {
        "var_name": "skb",
        "function_name": "igmp6_event_query",
        "location": {
            "file_path": "net/ipv6/mcast.c",
            "region": {
                "startLine": 1390,
                "startColumn": 12,
                "endColumn": 15
            },
            "context": {
                "startLine": 1388,
                "endLine": 1392,
                "snippet": {
                    "text": "\tkfree_skb(skb);"
                }
            }
        },
        "function_code": "void igmp6_event_query(struct sk_buff *skb)\n{\n\tstruct inet6_dev *idev = __in6_dev_get(skb->dev);\n\n\tif (!idev || idev->dead)\n\t\tgoto out;\n\n\tspin_lock_bh(&idev->mc_query_lock);\n\tif (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS) {\n\t\t__skb_queue_tail(&idev->mc_query_queue, skb);\n\t\tif (!mod_delayed_work(mld_wq, &idev->mc_query_work, 0))\n\t\t\tin6_dev_hold(idev);\n\t\tskb = NULL;\n\t}\n\tspin_unlock_bh(&idev->mc_query_lock);\nout:\n\tkfree_skb(skb);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree_skb(skb);",
                "condition": [
                    "goto out"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "skb = NULL;",
                "condition": [
                    "if (skb_queue_len(&idev->mc_query_queue) < MLD_MAX_SKBS)"
                ]
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [],
        "index": 47
    },
    {
        "var_name": "idev",
        "function_name": "ndisc_recv_ns",
        "location": {
            "file_path": "net/ipv6/ndisc.c",
            "region": {
                "startLine": 969,
                "startColumn": 15,
                "endColumn": 19
            },
            "context": {
                "startLine": 967,
                "endLine": 971,
                "snippet": {
                    "text": "\t\tin6_dev_put(idev);"
                }
            }
        },
        "function_code": "static enum skb_drop_reason ndisc_recv_ns(struct sk_buff *skb)\n{\n\tstruct nd_msg *msg = (struct nd_msg *)skb_transport_header(skb);\n\tconst struct in6_addr *saddr = &ipv6_hdr(skb)->saddr;\n\tconst struct in6_addr *daddr = &ipv6_hdr(skb)->daddr;\n\tu8 *lladdr = NULL;\n\tu32 ndoptlen = skb_tail_pointer(skb) - (skb_transport_header(skb) +\n\t\t\t\t    offsetof(struct nd_msg, opt));\n\tstruct ndisc_options ndopts;\n\tstruct net_device *dev = skb->dev;\n\tstruct inet6_ifaddr *ifp;\n\tstruct inet6_dev *idev = NULL;\n\tstruct neighbour *neigh;\n\tint dad = ipv6_addr_any(saddr);\n\tint is_router = -1;\n\tSKB_DR(reason);\n\tu64 nonce = 0;\n\tbool inc;\n\n\tif (skb->len < sizeof(struct nd_msg))\n\t\treturn SKB_DROP_REASON_PKT_TOO_SMALL;\n\n\tif (ipv6_addr_is_multicast(&msg->target)) {\n\t\tND_PRINTK(2, warn, \"NS: multicast target address\\n\");\n\t\treturn reason;\n\t}\n\n\t/*\n\t * RFC2461 7.1.1:\n\t * DAD has to be destined for solicited node multicast address.\n\t */\n\tif (dad && !ipv6_addr_is_solict_mult(daddr)) {\n\t\tND_PRINTK(2, warn, \"NS: bad DAD packet (wrong destination)\\n\");\n\t\treturn reason;\n\t}\n\n\tif (!ndisc_parse_options(dev, msg->opt, ndoptlen, &ndopts))\n\t\treturn SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS;\n\n\tif (ndopts.nd_opts_src_lladdr) {\n\t\tlladdr = ndisc_opt_addr_data(ndopts.nd_opts_src_lladdr, dev);\n\t\tif (!lladdr) {\n\t\t\tND_PRINTK(2, warn,\n\t\t\t\t  \"NS: invalid link-layer address length\\n\");\n\t\t\treturn reason;\n\t\t}\n\n\t\t/* RFC2461 7.1.1:\n\t\t *\tIf the IP source address is the unspecified address,\n\t\t *\tthere MUST NOT be source link-layer address option\n\t\t *\tin the message.\n\t\t */\n\t\tif (dad) {\n\t\t\tND_PRINTK(2, warn,\n\t\t\t\t  \"NS: bad DAD packet (link-layer address option)\\n\");\n\t\t\treturn reason;\n\t\t}\n\t}\n\tif (ndopts.nd_opts_nonce && ndopts.nd_opts_nonce->nd_opt_len == 1)\n\t\tmemcpy(&nonce, (u8 *)(ndopts.nd_opts_nonce + 1), 6);\n\n\tinc = ipv6_addr_is_multicast(daddr);\n\n\tifp = ipv6_get_ifaddr(dev_net(dev), &msg->target, dev, 1);\n\tif (ifp) {\nhave_ifp:\n\t\tif (ifp->flags & (IFA_F_TENTATIVE|IFA_F_OPTIMISTIC)) {\n\t\t\tif (dad) {\n\t\t\t\tif (nonce != 0 && ifp->dad_nonce == nonce) {\n\t\t\t\t\tu8 *np = (u8 *)&nonce;\n\t\t\t\t\t/* Matching nonce if looped back */\n\t\t\t\t\tND_PRINTK(2, notice,\n\t\t\t\t\t\t  \"%s: IPv6 DAD loopback for address %pI6c nonce %pM ignored\\n\",\n\t\t\t\t\t\t  ifp->idev->dev->name,\n\t\t\t\t\t\t  &ifp->addr, np);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * We are colliding with another node\n\t\t\t\t * who is doing DAD\n\t\t\t\t * so fail our DAD process\n\t\t\t\t */\n\t\t\t\taddrconf_dad_failure(skb, ifp);\n\t\t\t\treturn reason;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * This is not a dad solicitation.\n\t\t\t\t * If we are an optimistic node,\n\t\t\t\t * we should respond.\n\t\t\t\t * Otherwise, we should ignore it.\n\t\t\t\t */\n\t\t\t\tif (!(ifp->flags & IFA_F_OPTIMISTIC))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tidev = ifp->idev;\n\t} else {\n\t\tstruct net *net = dev_net(dev);\n\n\t\t/* perhaps an address on the master device */\n\t\tif (netif_is_l3_slave(dev)) {\n\t\t\tstruct net_device *mdev;\n\n\t\t\tmdev = netdev_master_upper_dev_get_rcu(dev);\n\t\t\tif (mdev) {\n\t\t\t\tifp = ipv6_get_ifaddr(net, &msg->target, mdev, 1);\n\t\t\t\tif (ifp)\n\t\t\t\t\tgoto have_ifp;\n\t\t\t}\n\t\t}\n\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev) {\n\t\t\t/* XXX: count this drop? */\n\t\t\treturn reason;\n\t\t}\n\n\t\tif (ipv6_chk_acast_addr(net, dev, &msg->target) ||\n\t\t    (READ_ONCE(idev->cnf.forwarding) &&\n\t\t     (READ_ONCE(net->ipv6.devconf_all->proxy_ndp) ||\n\t\t      READ_ONCE(idev->cnf.proxy_ndp)) &&\n\t\t     (is_router = pndisc_is_router(&msg->target, dev)) >= 0)) {\n\t\t\tif (!(NEIGH_CB(skb)->flags & LOCALLY_ENQUEUED) &&\n\t\t\t    skb->pkt_type != PACKET_HOST &&\n\t\t\t    inc &&\n\t\t\t    NEIGH_VAR(idev->nd_parms, PROXY_DELAY) != 0) {\n\t\t\t\t/*\n\t\t\t\t * for anycast or proxy,\n\t\t\t\t * sender should delay its response\n\t\t\t\t * by a random time between 0 and\n\t\t\t\t * MAX_ANYCAST_DELAY_TIME seconds.\n\t\t\t\t * (RFC2461) -- yoshfuji\n\t\t\t\t */\n\t\t\t\tstruct sk_buff *n = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (n)\n\t\t\t\t\tpneigh_enqueue(&nd_tbl, idev->nd_parms, n);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tSKB_DR_SET(reason, IPV6_NDISC_NS_OTHERHOST);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (is_router < 0)\n\t\tis_router = READ_ONCE(idev->cnf.forwarding);\n\n\tif (dad) {\n\t\tndisc_send_na(dev, &in6addr_linklocal_allnodes, &msg->target,\n\t\t\t      !!is_router, false, (ifp != NULL), true);\n\t\tgoto out;\n\t}\n\n\tif (inc)\n\t\tNEIGH_CACHE_STAT_INC(&nd_tbl, rcv_probes_mcast);\n\telse\n\t\tNEIGH_CACHE_STAT_INC(&nd_tbl, rcv_probes_ucast);\n\n\t/*\n\t *\tupdate / create cache entry\n\t *\tfor the source address\n\t */\n\tneigh = __neigh_lookup(&nd_tbl, saddr, dev,\n\t\t\t       !inc || lladdr || !dev->addr_len);\n\tif (neigh)\n\t\tndisc_update(dev, neigh, lladdr, NUD_STALE,\n\t\t\t     NEIGH_UPDATE_F_WEAK_OVERRIDE|\n\t\t\t     NEIGH_UPDATE_F_OVERRIDE,\n\t\t\t     NDISC_NEIGHBOUR_SOLICITATION, &ndopts);\n\tif (neigh || !dev->header_ops) {\n\t\tndisc_send_na(dev, saddr, &msg->target, !!is_router,\n\t\t\t      true, (ifp != NULL && inc), inc);\n\t\tif (neigh)\n\t\t\tneigh_release(neigh);\n\t\treason = SKB_CONSUMED;\n\t}\n\nout:\n\tif (ifp)\n\t\tin6_ifa_put(ifp);\n\telse\n\t\tin6_dev_put(idev);\n\treturn reason;\n}",
        "result": 0,
        "explain": "ifif ifpifelseifif ifpifififelseidevreturn",
        "bug_line_constraints": [
            {
                "text": "\t\tin6_dev_put(idev);",
                "condition": [
                    "goto out",
                    "if(!(ifp))"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct inet6_dev *idev = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return SKB_DROP_REASON_PKT_TOO_SMALL;",
                "condition": [
                    "if (skb->len < sizeof(struct nd_msg))"
                ]
            },
            {
                "text": "return reason;",
                "condition": [
                    "if (ipv6_addr_is_multicast(&msg->target))"
                ]
            },
            {
                "text": "return reason;",
                "condition": [
                    "if (dad && !ipv6_addr_is_solict_mult(daddr))"
                ]
            },
            {
                "text": "return SKB_DROP_REASON_IPV6_NDISC_BAD_OPTIONS;",
                "condition": [
                    "if (!ndisc_parse_options(dev, msg->opt, ndoptlen, &ndopts))"
                ]
            },
            {
                "text": "return reason;",
                "condition": [
                    "if (ndopts.nd_opts_src_lladdr)",
                    "if (!lladdr)"
                ]
            },
            {
                "text": "return reason;",
                "condition": [
                    "if (ndopts.nd_opts_src_lladdr)",
                    "if (dad)"
                ]
            },
            {
                "text": "return reason;",
                "condition": [
                    "if (ifp)",
                    "if (ifp->flags & (IFA_F_TENTATIVE|IFA_F_OPTIMISTIC))",
                    "if (dad)"
                ]
            },
            {
                "text": "goto have_ifp;",
                "condition": [
                    "if(!(ifp))",
                    "if (netif_is_l3_slave(dev))",
                    "if (mdev)",
                    "if (ifp)"
                ]
            },
            {
                "text": "return reason;",
                "condition": [
                    "if(!(ifp))",
                    "if (!idev)"
                ]
            }
        ],
        "index": 48
    },
    {
        "var_name": "skb",
        "function_name": "rawv6_push_pending_frames",
        "location": {
            "file_path": "net/ipv6/raw.c",
            "region": {
                "startLine": 585,
                "startColumn": 24,
                "endColumn": 27
            },
            "context": {
                "startLine": 583,
                "endLine": 587,
                "snippet": {
                    "text": "\tBUG_ON(skb_store_bits(skb, offset, &csum, 2));"
                }
            }
        },
        "function_code": "static int rawv6_push_pending_frames(struct sock *sk, struct flowi6 *fl6,\n\t\t\t\t     struct raw6_sock *rp)\n{\n\tstruct ipv6_txoptions *opt;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tint offset;\n\tint len;\n\tint total_len;\n\t__wsum tmp_csum;\n\t__sum16 csum;\n\n\tif (!rp->checksum)\n\t\tgoto send;\n\n\tskb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\tgoto out;\n\n\toffset = rp->offset;\n\ttotal_len = inet_sk(sk)->cork.base.length;\n\topt = inet6_sk(sk)->cork.opt;\n\ttotal_len -= opt ? opt->opt_flen : 0;\n\n\tif (offset >= total_len - 1) {\n\t\terr = -EINVAL;\n\t\tip6_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\n\t/* should be check HW csum miyazawa */\n\tif (skb_queue_len(&sk->sk_write_queue) == 1) {\n\t\t/*\n\t\t * Only one fragment on the socket.\n\t\t */\n\t\ttmp_csum = skb->csum;\n\t} else {\n\t\tstruct sk_buff *csum_skb = NULL;\n\t\ttmp_csum = 0;\n\n\t\tskb_queue_walk(&sk->sk_write_queue, skb) {\n\t\t\ttmp_csum = csum_add(tmp_csum, skb->csum);\n\n\t\t\tif (csum_skb)\n\t\t\t\tcontinue;\n\n\t\t\tlen = skb->len - skb_transport_offset(skb);\n\t\t\tif (offset >= len) {\n\t\t\t\toffset -= len;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcsum_skb = skb;\n\t\t}\n\n\t\tskb = csum_skb;\n\t}\n\n\toffset += skb_transport_offset(skb);\n\terr = skb_copy_bits(skb, offset, &csum, 2);\n\tif (err < 0) {\n\t\tip6_flush_pending_frames(sk);\n\t\tgoto out;\n\t}\n\n\t/* in case cksum was not initialized */\n\tif (unlikely(csum))\n\t\ttmp_csum = csum_sub(tmp_csum, csum_unfold(csum));\n\n\tcsum = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t       total_len, fl6->flowi6_proto, tmp_csum);\n\n\tif (csum == 0 && fl6->flowi6_proto == IPPROTO_UDP)\n\t\tcsum = CSUM_MANGLED_0;\n\n\tBUG_ON(skb_store_bits(skb, offset, &csum, 2));\n\nsend:\n\terr = ip6_push_pending_frames(sk);\nout:\n\treturn err;\n}",
        "result": 0,
        "explain": "if(!ptr||...) goto",
        "bug_line_constraints": [
            {
                "text": "\tBUG_ON(skb_store_bits(skb, offset, &csum, 2));",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto send;",
                "condition": [
                    "if (!rp->checksum)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!skb)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (offset >= total_len - 1)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (err < 0)"
                ]
            }
        ],
        "index": 49
    },
    {
        "var_name": "rt_notif",
        "function_name": "ip6_route_multipath_add",
        "location": {
            "file_path": "net/ipv6/route.c",
            "region": {
                "startLine": 5389,
                "startColumn": 7,
                "endColumn": 15
            },
            "context": {
                "startLine": 5387,
                "endLine": 5391,
                "snippet": {
                    "text": "\t\tif (rt_notif->fib6_nsiblings != nhn - 1)"
                }
            }
        },
        "function_code": "static int ip6_route_multipath_add(struct fib6_config *cfg,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct fib6_info *rt_notif = NULL, *rt_last = NULL;\n\tstruct nl_info *info = &cfg->fc_nlinfo;\n\tstruct fib6_config r_cfg;\n\tstruct rtnexthop *rtnh;\n\tstruct fib6_info *rt;\n\tstruct rt6_nh *err_nh;\n\tstruct rt6_nh *nh, *nh_safe;\n\t__u16 nlflags;\n\tint remaining;\n\tint attrlen;\n\tint err = 1;\n\tint nhn = 0;\n\tint replace = (cfg->fc_nlinfo.nlh &&\n\t\t       (cfg->fc_nlinfo.nlh->nlmsg_flags & NLM_F_REPLACE));\n\tLIST_HEAD(rt6_nh_list);\n\n\tnlflags = replace ? NLM_F_REPLACE : NLM_F_CREATE;\n\tif (info->nlh && info->nlh->nlmsg_flags & NLM_F_APPEND)\n\t\tnlflags |= NLM_F_APPEND;\n\n\tremaining = cfg->fc_mp_len;\n\trtnh = (struct rtnexthop *)cfg->fc_mp;\n\n\t/* Parse a Multipath Entry and build a list (rt6_nh_list) of\n\t * fib6_info structs per nexthop\n\t */\n\twhile (rtnh_ok(rtnh, remaining)) {\n\t\tmemcpy(&r_cfg, cfg, sizeof(*cfg));\n\t\tif (rtnh->rtnh_ifindex)\n\t\t\tr_cfg.fc_ifindex = rtnh->rtnh_ifindex;\n\n\t\tattrlen = rtnh_attrlen(rtnh);\n\t\tif (attrlen > 0) {\n\t\t\tstruct nlattr *nla, *attrs = rtnh_attrs(rtnh);\n\n\t\t\tnla = nla_find(attrs, attrlen, RTA_GATEWAY);\n\t\t\tif (nla) {\n\t\t\t\terr = fib6_gw_from_attr(&r_cfg.fc_gateway, nla,\n\t\t\t\t\t\t\textack);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto cleanup;\n\n\t\t\t\tr_cfg.fc_flags |= RTF_GATEWAY;\n\t\t\t}\n\t\t\tr_cfg.fc_encap = nla_find(attrs, attrlen, RTA_ENCAP);\n\n\t\t\t/* RTA_ENCAP_TYPE length checked in\n\t\t\t * lwtunnel_valid_encap_type_attr\n\t\t\t */\n\t\t\tnla = nla_find(attrs, attrlen, RTA_ENCAP_TYPE);\n\t\t\tif (nla)\n\t\t\t\tr_cfg.fc_encap_type = nla_get_u16(nla);\n\t\t}\n\n\t\tr_cfg.fc_flags |= (rtnh->rtnh_flags & RTNH_F_ONLINK);\n\t\trt = ip6_route_info_create(&r_cfg, GFP_KERNEL, extack);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\trt = NULL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tif (!rt6_qualify_for_ecmp(rt)) {\n\t\t\terr = -EINVAL;\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Device only routes can not be added for IPv6 using the multipath API.\");\n\t\t\tfib6_info_release(rt);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\trt->fib6_nh->fib_nh_weight = rtnh->rtnh_hops + 1;\n\n\t\terr = ip6_route_info_append(info->nl_net, &rt6_nh_list,\n\t\t\t\t\t    rt, &r_cfg);\n\t\tif (err) {\n\t\t\tfib6_info_release(rt);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\trtnh = rtnh_next(rtnh, &remaining);\n\t}\n\n\tif (list_empty(&rt6_nh_list)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Invalid nexthop configuration - no valid nexthops\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* for add and replace send one notification with all nexthops.\n\t * Skip the notification in fib6_add_rt2node and send one with\n\t * the full route when done\n\t */\n\tinfo->skip_notify = 1;\n\n\t/* For add and replace, send one notification with all nexthops. For\n\t * append, send one notification with all appended nexthops.\n\t */\n\tinfo->skip_notify_kernel = 1;\n\n\terr_nh = NULL;\n\tlist_for_each_entry(nh, &rt6_nh_list, next) {\n\t\terr = __ip6_ins_rt(nh->fib6_info, info, extack);\n\n\t\tif (err) {\n\t\t\tif (replace && nhn)\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"multipath route replace failed (check consistency of installed routes)\");\n\t\t\terr_nh = nh;\n\t\t\tgoto add_errout;\n\t\t}\n\t\t/* save reference to last route successfully inserted */\n\t\trt_last = nh->fib6_info;\n\n\t\t/* save reference to first route for notification */\n\t\tif (!rt_notif)\n\t\t\trt_notif = nh->fib6_info;\n\n\t\t/* Because each route is added like a single route we remove\n\t\t * these flags after the first nexthop: if there is a collision,\n\t\t * we have already failed to add the first nexthop:\n\t\t * fib6_add_rt2node() has rejected it; when replacing, old\n\t\t * nexthops have been replaced by first new, the rest should\n\t\t * be added to it.\n\t\t */\n\t\tif (cfg->fc_nlinfo.nlh) {\n\t\t\tcfg->fc_nlinfo.nlh->nlmsg_flags &= ~(NLM_F_EXCL |\n\t\t\t\t\t\t\t     NLM_F_REPLACE);\n\t\t\tcfg->fc_nlinfo.nlh->nlmsg_flags |= NLM_F_CREATE;\n\t\t}\n\t\tnhn++;\n\t}\n\n\t/* An in-kernel notification should only be sent in case the new\n\t * multipath route is added as the first route in the node, or if\n\t * it was appended to it. We pass 'rt_notif' since it is the first\n\t * sibling and might allow us to skip some checks in the replace case.\n\t */\n\tif (ip6_route_mpath_should_notify(rt_notif)) {\n\t\tenum fib_event_type fib_event;\n\n\t\tif (rt_notif->fib6_nsiblings != nhn - 1)\n\t\t\tfib_event = FIB_EVENT_ENTRY_APPEND;\n\t\telse\n\t\t\tfib_event = FIB_EVENT_ENTRY_REPLACE;\n\n\t\terr = call_fib6_multipath_entry_notifiers(info->nl_net,\n\t\t\t\t\t\t\t  fib_event, rt_notif,\n\t\t\t\t\t\t\t  nhn - 1, extack);\n\t\tif (err) {\n\t\t\t/* Delete all the siblings that were just added */\n\t\t\terr_nh = NULL;\n\t\t\tgoto add_errout;\n\t\t}\n\t}\n\n\t/* success ... tell user about new route */\n\tip6_route_mpath_notify(rt_notif, rt_last, info, nlflags);\n\tgoto cleanup;\n\nadd_errout:\n\t/* send notification for routes that were added so that\n\t * the delete notifications sent by ip6_route_del are\n\t * coherent\n\t */\n\tif (rt_notif)\n\t\tip6_route_mpath_notify(rt_notif, rt_last, info, nlflags);\n\n\t/* Delete routes that were already added */\n\tlist_for_each_entry(nh, &rt6_nh_list, next) {\n\t\tif (err_nh == nh)\n\t\t\tbreak;\n\t\tip6_route_del(&nh->r_cfg, extack);\n\t}\n\ncleanup:\n\tlist_for_each_entry_safe(nh, nh_safe, &rt6_nh_list, next) {\n\t\tfib6_info_release(nh->fib6_info);\n\t\tlist_del(&nh->next);\n\t\tkfree(nh);\n\t}\n\n\treturn err;\n}",
        "function_list": [
            "ip6_route_mpath_should_notify"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\tif (rt_notif->fib6_nsiblings != nhn - 1)",
                "condition": [
                    "if (ip6_route_mpath_should_notify(rt_notif))"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct fib6_info *rt_notif = NULL, *rt_last = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [
            {
                "text": "if (!rt_notif)",
                "condition": [
                    "list_for_each_entry(nh, &rt6_nh_list, next)"
                ],
                "content": "\t\tif (!rt_notif)\n\t\t\trt_notif = nh->fib6_info;\n"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "goto cleanup;",
                "condition": [
                    "while (rtnh_ok(rtnh, remaining))",
                    "if (attrlen > 0)",
                    "if (nla)",
                    "if (err)"
                ]
            },
            {
                "text": "goto cleanup;",
                "condition": [
                    "while (rtnh_ok(rtnh, remaining))",
                    "if (IS_ERR(rt))"
                ]
            },
            {
                "text": "goto cleanup;",
                "condition": [
                    "while (rtnh_ok(rtnh, remaining))",
                    "if (!rt6_qualify_for_ecmp(rt))"
                ]
            },
            {
                "text": "goto cleanup;",
                "condition": [
                    "while (rtnh_ok(rtnh, remaining))",
                    "if (err)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (list_empty(&rt6_nh_list))"
                ]
            },
            {
                "text": "goto add_errout;",
                "condition": [
                    "list_for_each_entry(nh, &rt6_nh_list, next)",
                    "if (err)"
                ]
            }
        ],
        "index": 51
    },
    {
        "var_name": "first",
        "function_name": "rt6_multipath_rebalance",
        "location": {
            "file_path": "net/ipv6/route.c",
            "region": {
                "startLine": 4764,
                "startColumn": 32,
                "endColumn": 37
            },
            "context": {
                "startLine": 4762,
                "endLine": 4766,
                "snippet": {
                    "text": "\trt6_multipath_upper_bound_set(first, total);"
                }
            }
        },
        "function_code": "void rt6_multipath_rebalance(struct fib6_info *rt)\n{\n\tstruct fib6_info *first;\n\tint total;\n\n\t/* In case the entire multipath route was marked for flushing,\n\t * then there is no need to rebalance upon the removal of every\n\t * sibling route.\n\t */\n\tif (!rt->fib6_nsiblings || rt->should_flush)\n\t\treturn;\n\n\t/* During lookup routes are evaluated in order, so we need to\n\t * make sure upper bounds are assigned from the first sibling\n\t * onwards.\n\t */\n\tfirst = rt6_multipath_first_sibling(rt);\n\tif (WARN_ON_ONCE(!first))\n\t\treturn;\n\n\ttotal = rt6_multipath_total_weight(first);\n\trt6_multipath_upper_bound_set(first, total);\n}",
        "function_list": [
            "WARN_ON_ONCE",
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\trt6_multipath_upper_bound_set(first, total);",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (!rt->fib6_nsiblings || rt->should_flush)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!first))"
                ]
            }
        ],
        "index": 52
    },
    {
        "var_name": "fib6_nh",
        "function_name": "ip6_route_info_create",
        "location": {
            "file_path": "net/ipv6/route.c",
            "region": {
                "startLine": 3825,
                "startColumn": 28,
                "endColumn": 35
            },
            "context": {
                "startLine": 3823,
                "endLine": 3827,
                "snippet": {
                    "text": "\t\tstruct net_device *dev = fib6_nh->fib_nh_dev;"
                }
            }
        },
        "function_code": "static struct fib6_info *ip6_route_info_create(struct fib6_config *cfg,\n\t\t\t\t\t      gfp_t gfp_flags,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct net *net = cfg->fc_nlinfo.nl_net;\n\tstruct fib6_info *rt = NULL;\n\tstruct nexthop *nh = NULL;\n\tstruct fib6_table *table;\n\tstruct fib6_nh *fib6_nh;\n\tint err = -EINVAL;\n\tint addr_type;\n\n\t/* RTF_PCPU is an internal flag; can not be set by userspace */\n\tif (cfg->fc_flags & RTF_PCPU) {\n\t\tNL_SET_ERR_MSG(extack, \"Userspace can not set RTF_PCPU\");\n\t\tgoto out;\n\t}\n\n\t/* RTF_CACHE is an internal flag; can not be set by userspace */\n\tif (cfg->fc_flags & RTF_CACHE) {\n\t\tNL_SET_ERR_MSG(extack, \"Userspace can not set RTF_CACHE\");\n\t\tgoto out;\n\t}\n\n\tif (cfg->fc_type > RTN_MAX) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid route type\");\n\t\tgoto out;\n\t}\n\n\tif (cfg->fc_dst_len > 128) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid prefix length\");\n\t\tgoto out;\n\t}\n\tif (cfg->fc_src_len > 128) {\n\t\tNL_SET_ERR_MSG(extack, \"Invalid source address length\");\n\t\tgoto out;\n\t}\n#ifndef CONFIG_IPV6_SUBTREES\n\tif (cfg->fc_src_len) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Specifying source address requires IPV6_SUBTREES to be enabled\");\n\t\tgoto out;\n\t}\n#endif\n\tif (cfg->fc_nh_id) {\n\t\tnh = nexthop_find_by_id(net, cfg->fc_nh_id);\n\t\tif (!nh) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop id does not exist\");\n\t\t\tgoto out;\n\t\t}\n\t\terr = fib6_check_nexthop(nh, cfg, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -ENOBUFS;\n\tif (cfg->fc_nlinfo.nlh &&\n\t    !(cfg->fc_nlinfo.nlh->nlmsg_flags & NLM_F_CREATE)) {\n\t\ttable = fib6_get_table(net, cfg->fc_table);\n\t\tif (!table) {\n\t\t\tpr_warn(\"NLM_F_CREATE should be specified when creating new route\\n\");\n\t\t\ttable = fib6_new_table(net, cfg->fc_table);\n\t\t}\n\t} else {\n\t\ttable = fib6_new_table(net, cfg->fc_table);\n\t}\n\n\tif (!table)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\trt = fib6_info_alloc(gfp_flags, !nh);\n\tif (!rt)\n\t\tgoto out;\n\n\trt->fib6_metrics = ip_fib_metrics_init(net, cfg->fc_mx, cfg->fc_mx_len,\n\t\t\t\t\t       extack);\n\tif (IS_ERR(rt->fib6_metrics)) {\n\t\terr = PTR_ERR(rt->fib6_metrics);\n\t\t/* Do not leave garbage there. */\n\t\trt->fib6_metrics = (struct dst_metrics *)&dst_default_metrics;\n\t\tgoto out_free;\n\t}\n\n\tif (cfg->fc_flags & RTF_ADDRCONF)\n\t\trt->dst_nocount = true;\n\n\tif (cfg->fc_flags & RTF_EXPIRES)\n\t\tfib6_set_expires(rt, jiffies +\n\t\t\t\tclock_t_to_jiffies(cfg->fc_expires));\n\n\tif (cfg->fc_protocol == RTPROT_UNSPEC)\n\t\tcfg->fc_protocol = RTPROT_BOOT;\n\trt->fib6_protocol = cfg->fc_protocol;\n\n\trt->fib6_table = table;\n\trt->fib6_metric = cfg->fc_metric;\n\trt->fib6_type = cfg->fc_type ? : RTN_UNICAST;\n\trt->fib6_flags = cfg->fc_flags & ~RTF_GATEWAY;\n\n\tipv6_addr_prefix(&rt->fib6_dst.addr, &cfg->fc_dst, cfg->fc_dst_len);\n\trt->fib6_dst.plen = cfg->fc_dst_len;\n\n#ifdef CONFIG_IPV6_SUBTREES\n\tipv6_addr_prefix(&rt->fib6_src.addr, &cfg->fc_src, cfg->fc_src_len);\n\trt->fib6_src.plen = cfg->fc_src_len;\n#endif\n\tif (nh) {\n\t\tif (rt->fib6_src.plen) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthops can not be used with source routing\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (!nexthop_get(nh)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop has been deleted\");\n\t\t\tgoto out_free;\n\t\t}\n\t\trt->nh = nh;\n\t\tfib6_nh = nexthop_fib6_nh(rt->nh);\n\t} else {\n\t\terr = fib6_nh_init(net, rt->fib6_nh, cfg, gfp_flags, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfib6_nh = rt->fib6_nh;\n\n\t\t/* We cannot add true routes via loopback here, they would\n\t\t * result in kernel looping; promote them to reject routes\n\t\t */\n\t\taddr_type = ipv6_addr_type(&cfg->fc_dst);\n\t\tif (fib6_is_reject(cfg->fc_flags, rt->fib6_nh->fib_nh_dev,\n\t\t\t\t   addr_type))\n\t\t\trt->fib6_flags = RTF_REJECT | RTF_NONEXTHOP;\n\t}\n\n\tif (!ipv6_addr_any(&cfg->fc_prefsrc)) {\n\t\tstruct net_device *dev = fib6_nh->fib_nh_dev;\n\n\t\tif (!ipv6_chk_addr(net, &cfg->fc_prefsrc, dev, 0)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid source address\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trt->fib6_prefsrc.addr = cfg->fc_prefsrc;\n\t\trt->fib6_prefsrc.plen = 128;\n\t} else\n\t\trt->fib6_prefsrc.plen = 0;\n\n\treturn rt;\nout:\n\tfib6_info_release(rt);\n\treturn ERR_PTR(err);\nout_free:\n\tip_fib_metrics_put(rt->fib6_metrics);\n\tkfree(rt);\n\treturn ERR_PTR(err);\n}",
        "function_list": [
            "nexthop_fib6_nh"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\tstruct net_device *dev = fib6_nh->fib_nh_dev;",
                "condition": [
                    "if (!ipv6_addr_any(&cfg->fc_prefsrc))"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_flags & RTF_PCPU)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_flags & RTF_CACHE)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_type > RTN_MAX)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_dst_len > 128)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_src_len > 128)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_src_len)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_nh_id)",
                    "if (!nh)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_nh_id)",
                    "if (err)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!table)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!rt)"
                ]
            },
            {
                "text": "goto out_free;",
                "condition": [
                    "if (IS_ERR(rt->fib6_metrics))"
                ]
            },
            {
                "text": "goto out_free;",
                "condition": [
                    "if (nh)",
                    "if (rt->fib6_src.plen)"
                ]
            },
            {
                "text": "goto out_free;",
                "condition": [
                    "if (nh)",
                    "if (!nexthop_get(nh))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if(!(nh))",
                    "if (err)"
                ]
            }
        ],
        "index": 53
    },
    {
        "var_name": "idev",
        "function_name": "fib6_nh_init",
        "location": {
            "file_path": "net/ipv6/route.c",
            "region": {
                "startLine": 3606,
                "startColumn": 6,
                "endColumn": 10
            },
            "context": {
                "startLine": 3604,
                "endLine": 3608,
                "snippet": {
                    "text": "\tif (idev->cnf.disable_ipv6) {"
                }
            }
        },
        "function_code": "int fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,\n\t\t struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t struct netlink_ext_ack *extack)\n{\n\tnetdevice_tracker *dev_tracker = &fib6_nh->fib_nh_dev_tracker;\n\tstruct net_device *dev = NULL;\n\tstruct inet6_dev *idev = NULL;\n\tint addr_type;\n\tint err;\n\n\tfib6_nh->fib_nh_family = AF_INET6;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tfib6_nh->last_probe = jiffies;\n#endif\n\tif (cfg->fc_is_fdb) {\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t\treturn 0;\n\t}\n\n\terr = -ENODEV;\n\tif (cfg->fc_ifindex) {\n\t\tdev = netdev_get_by_index(net, cfg->fc_ifindex,\n\t\t\t\t\t  dev_tracker, gfp_flags);\n\t\tif (!dev)\n\t\t\tgoto out;\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\tgoto out;\n\t}\n\n\tif (cfg->fc_flags & RTNH_F_ONLINK) {\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop device required for onlink\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(dev->flags & IFF_UP)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\t\terr = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_ONLINK;\n\t}\n\n\tfib6_nh->fib_nh_weight = 1;\n\n\t/* We cannot add true routes via loopback here,\n\t * they would result in kernel looping; promote them to reject routes\n\t */\n\taddr_type = ipv6_addr_type(&cfg->fc_dst);\n\tif (fib6_is_reject(cfg->fc_flags, dev, addr_type)) {\n\t\t/* hold loopback dev/idev if we haven't done so. */\n\t\tif (dev != net->loopback_dev) {\n\t\t\tif (dev) {\n\t\t\t\tnetdev_put(dev, dev_tracker);\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t\tdev = net->loopback_dev;\n\t\t\tnetdev_hold(dev, dev_tracker, gfp_flags);\n\t\t\tidev = in6_dev_get(dev);\n\t\t\tif (!idev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tgoto pcpu_alloc;\n\t}\n\n\tif (cfg->fc_flags & RTF_GATEWAY) {\n\t\terr = ip6_validate_gw(net, cfg, &dev, dev_tracker,\n\t\t\t\t      &idev, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t}\n\n\terr = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tif (idev->cnf.disable_ipv6) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 is disabled on nexthop device\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!(dev->flags & IFF_UP) && !cfg->fc_ignore_dev_down) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\terr = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tif (!(cfg->fc_flags & (RTF_LOCAL | RTF_ANYCAST)) &&\n\t    !netif_carrier_ok(dev))\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\n\terr = fib_nh_common_init(net, &fib6_nh->nh_common, cfg->fc_encap,\n\t\t\t\t cfg->fc_encap_type, cfg, gfp_flags, extack);\n\tif (err)\n\t\tgoto out;\n\npcpu_alloc:\n\tfib6_nh->rt6i_pcpu = alloc_percpu_gfp(struct rt6_info *, gfp_flags);\n\tif (!fib6_nh->rt6i_pcpu) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfib6_nh->fib_nh_dev = dev;\n\tfib6_nh->fib_nh_oif = dev->ifindex;\n\terr = 0;\nout:\n\tif (idev)\n\t\tin6_dev_put(idev);\n\n\tif (err) {\n\t\tlwtstate_put(fib6_nh->fib_nh_lws);\n\t\tfib6_nh->fib_nh_lws = NULL;\n\t\tnetdev_put(dev, dev_tracker);\n\t}\n\n\treturn err;\n}",
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\tif (idev->cnf.disable_ipv6) {",
                "condition": []
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct inet6_dev *idev = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return 0;",
                "condition": [
                    "if (cfg->fc_is_fdb)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_ifindex)",
                    "if (!dev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_ifindex)",
                    "if (!idev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_flags & RTNH_F_ONLINK)",
                    "if (!dev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_flags & RTNH_F_ONLINK)",
                    "if (!(dev->flags & IFF_UP))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (fib6_is_reject(cfg->fc_flags, dev, addr_type))",
                    "if (dev != net->loopback_dev)",
                    "if (!idev)"
                ]
            },
            {
                "text": "goto pcpu_alloc;",
                "condition": [
                    "if (fib6_is_reject(cfg->fc_flags, dev, addr_type))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_flags & RTF_GATEWAY)",
                    "if (err)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!dev)"
                ]
            }
        ],
        "index": 55
    },
    {
        "var_name": "dev",
        "function_name": "fib6_nh_init",
        "location": {
            "file_path": "net/ipv6/route.c",
            "region": {
                "startLine": 3635,
                "startColumn": 24,
                "endColumn": 27
            },
            "context": {
                "startLine": 3633,
                "endLine": 3637,
                "snippet": {
                    "text": "\tfib6_nh->fib_nh_oif = dev->ifindex;"
                }
            }
        },
        "function_code": "int fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,\n\t\t struct fib6_config *cfg, gfp_t gfp_flags,\n\t\t struct netlink_ext_ack *extack)\n{\n\tnetdevice_tracker *dev_tracker = &fib6_nh->fib_nh_dev_tracker;\n\tstruct net_device *dev = NULL;\n\tstruct inet6_dev *idev = NULL;\n\tint addr_type;\n\tint err;\n\n\tfib6_nh->fib_nh_family = AF_INET6;\n#ifdef CONFIG_IPV6_ROUTER_PREF\n\tfib6_nh->last_probe = jiffies;\n#endif\n\tif (cfg->fc_is_fdb) {\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t\treturn 0;\n\t}\n\n\terr = -ENODEV;\n\tif (cfg->fc_ifindex) {\n\t\tdev = netdev_get_by_index(net, cfg->fc_ifindex,\n\t\t\t\t\t  dev_tracker, gfp_flags);\n\t\tif (!dev)\n\t\t\tgoto out;\n\t\tidev = in6_dev_get(dev);\n\t\tif (!idev)\n\t\t\tgoto out;\n\t}\n\n\tif (cfg->fc_flags & RTNH_F_ONLINK) {\n\t\tif (!dev) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Nexthop device required for onlink\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(dev->flags & IFF_UP)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\t\terr = -ENETDOWN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_ONLINK;\n\t}\n\n\tfib6_nh->fib_nh_weight = 1;\n\n\t/* We cannot add true routes via loopback here,\n\t * they would result in kernel looping; promote them to reject routes\n\t */\n\taddr_type = ipv6_addr_type(&cfg->fc_dst);\n\tif (fib6_is_reject(cfg->fc_flags, dev, addr_type)) {\n\t\t/* hold loopback dev/idev if we haven't done so. */\n\t\tif (dev != net->loopback_dev) {\n\t\t\tif (dev) {\n\t\t\t\tnetdev_put(dev, dev_tracker);\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}\n\t\t\tdev = net->loopback_dev;\n\t\t\tnetdev_hold(dev, dev_tracker, gfp_flags);\n\t\t\tidev = in6_dev_get(dev);\n\t\t\tif (!idev) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tgoto pcpu_alloc;\n\t}\n\n\tif (cfg->fc_flags & RTF_GATEWAY) {\n\t\terr = ip6_validate_gw(net, cfg, &dev, dev_tracker,\n\t\t\t\t      &idev, extack);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tfib6_nh->fib_nh_gw6 = cfg->fc_gateway;\n\t\tfib6_nh->fib_nh_gw_family = AF_INET6;\n\t}\n\n\terr = -ENODEV;\n\tif (!dev)\n\t\tgoto out;\n\n\tif (idev->cnf.disable_ipv6) {\n\t\tNL_SET_ERR_MSG(extack, \"IPv6 is disabled on nexthop device\");\n\t\terr = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!(dev->flags & IFF_UP) && !cfg->fc_ignore_dev_down) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop device is not up\");\n\t\terr = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tif (!(cfg->fc_flags & (RTF_LOCAL | RTF_ANYCAST)) &&\n\t    !netif_carrier_ok(dev))\n\t\tfib6_nh->fib_nh_flags |= RTNH_F_LINKDOWN;\n\n\terr = fib_nh_common_init(net, &fib6_nh->nh_common, cfg->fc_encap,\n\t\t\t\t cfg->fc_encap_type, cfg, gfp_flags, extack);\n\tif (err)\n\t\tgoto out;\n\npcpu_alloc:\n\tfib6_nh->rt6i_pcpu = alloc_percpu_gfp(struct rt6_info *, gfp_flags);\n\tif (!fib6_nh->rt6i_pcpu) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfib6_nh->fib_nh_dev = dev;\n\tfib6_nh->fib_nh_oif = dev->ifindex;\n\terr = 0;\nout:\n\tif (idev)\n\t\tin6_dev_put(idev);\n\n\tif (err) {\n\t\tlwtstate_put(fib6_nh->fib_nh_lws);\n\t\tfib6_nh->fib_nh_lws = NULL;\n\t\tnetdev_put(dev, dev_tracker);\n\t}\n\n\treturn err;\n}",
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\tfib6_nh->fib_nh_oif = dev->ifindex;",
                "condition": [
                    "goto pcpu_alloc"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct net_device *dev = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [
            {
                "text": "if (dev)",
                "condition": [
                    "if (fib6_is_reject(cfg->fc_flags, dev, addr_type))",
                    "if (dev != net->loopback_dev)"
                ],
                "content": "\t\t\tif (dev) {\n\t\t\t\tnetdev_put(dev, dev_tracker);\n\t\t\t\tin6_dev_put(idev);\n\t\t\t}"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "return 0;",
                "condition": [
                    "if (cfg->fc_is_fdb)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_ifindex)",
                    "if (!dev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_ifindex)",
                    "if (!idev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_flags & RTNH_F_ONLINK)",
                    "if (!dev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_flags & RTNH_F_ONLINK)",
                    "if (!(dev->flags & IFF_UP))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (fib6_is_reject(cfg->fc_flags, dev, addr_type))",
                    "if (dev != net->loopback_dev)",
                    "if (!idev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (cfg->fc_flags & RTF_GATEWAY)",
                    "if (err)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!dev)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (idev->cnf.disable_ipv6)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!(dev->flags & IFF_UP) && !cfg->fc_ignore_dev_down)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (err)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!fib6_nh->rt6i_pcpu)"
                ]
            }
        ],
        "index": 56
    },
    {
        "var_name": "nh",
        "function_name": "rt6_device_match",
        "location": {
            "file_path": "net/ipv6/route.c",
            "region": {
                "startLine": 543,
                "startColumn": 9,
                "endColumn": 11
            },
            "context": {
                "startLine": 541,
                "endLine": 545,
                "snippet": {
                    "text": "\t\tif (!(nh->fib_nh_flags & RTNH_F_DEAD))"
                }
            }
        },
        "function_code": "static void rt6_device_match(struct net *net, struct fib6_result *res,\n\t\t\t     const struct in6_addr *saddr, int oif, int flags)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct fib6_info *spf6i;\n\tstruct fib6_nh *nh;\n\n\tif (!oif && ipv6_addr_any(saddr)) {\n\t\tif (unlikely(f6i->nh)) {\n\t\t\tnh = nexthop_fib6_nh(f6i->nh);\n\t\t\tif (nexthop_is_blackhole(f6i->nh))\n\t\t\t\tgoto out_blackhole;\n\t\t} else {\n\t\t\tnh = f6i->fib6_nh;\n\t\t}\n\t\tif (!(nh->fib_nh_flags & RTNH_F_DEAD))\n\t\t\tgoto out;\n\t}\n\n\tfor (spf6i = f6i; spf6i; spf6i = rcu_dereference(spf6i->fib6_next)) {\n\t\tbool matched = false;\n\n\t\tif (unlikely(spf6i->nh)) {\n\t\t\tnh = rt6_nh_dev_match(net, spf6i->nh, res, saddr,\n\t\t\t\t\t      oif, flags);\n\t\t\tif (nh)\n\t\t\t\tmatched = true;\n\t\t} else {\n\t\t\tnh = spf6i->fib6_nh;\n\t\t\tif (__rt6_device_match(net, nh, saddr, oif, flags))\n\t\t\t\tmatched = true;\n\t\t}\n\t\tif (matched) {\n\t\t\tres->f6i = spf6i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (oif && flags & RT6_LOOKUP_F_IFACE) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tnh = res->f6i->fib6_nh;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(f6i->nh)) {\n\t\tnh = nexthop_fib6_nh(f6i->nh);\n\t\tif (nexthop_is_blackhole(f6i->nh))\n\t\t\tgoto out_blackhole;\n\t} else {\n\t\tnh = f6i->fib6_nh;\n\t}\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tnh = res->f6i->fib6_nh;\n\t}\nout:\n\tres->nh = nh;\n\tres->fib6_type = res->f6i->fib6_type;\n\tres->fib6_flags = res->f6i->fib6_flags;\n\treturn;\n\nout_blackhole:\n\tres->fib6_flags |= RTF_REJECT;\n\tres->fib6_type = RTN_BLACKHOLE;\n\tres->nh = nh;\n}",
        "function_list": [
            "nexthop_fib6_nh"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\tif (!(nh->fib_nh_flags & RTNH_F_DEAD))",
                "condition": [
                    "if (!oif && ipv6_addr_any(saddr))"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto out_blackhole;",
                "condition": [
                    "if (!oif && ipv6_addr_any(saddr))",
                    "if (unlikely(f6i->nh))",
                    "if (nexthop_is_blackhole(f6i->nh))"
                ]
            }
        ],
        "index": 57
    },
    {
        "var_name": "nh",
        "function_name": "rt6_device_match",
        "location": {
            "file_path": "net/ipv6/route.c",
            "region": {
                "startLine": 580,
                "startColumn": 6,
                "endColumn": 8
            },
            "context": {
                "startLine": 578,
                "endLine": 582,
                "snippet": {
                    "text": "\tif (nh->fib_nh_flags & RTNH_F_DEAD) {"
                }
            }
        },
        "function_code": "static void rt6_device_match(struct net *net, struct fib6_result *res,\n\t\t\t     const struct in6_addr *saddr, int oif, int flags)\n{\n\tstruct fib6_info *f6i = res->f6i;\n\tstruct fib6_info *spf6i;\n\tstruct fib6_nh *nh;\n\n\tif (!oif && ipv6_addr_any(saddr)) {\n\t\tif (unlikely(f6i->nh)) {\n\t\t\tnh = nexthop_fib6_nh(f6i->nh);\n\t\t\tif (nexthop_is_blackhole(f6i->nh))\n\t\t\t\tgoto out_blackhole;\n\t\t} else {\n\t\t\tnh = f6i->fib6_nh;\n\t\t}\n\t\tif (!(nh->fib_nh_flags & RTNH_F_DEAD))\n\t\t\tgoto out;\n\t}\n\n\tfor (spf6i = f6i; spf6i; spf6i = rcu_dereference(spf6i->fib6_next)) {\n\t\tbool matched = false;\n\n\t\tif (unlikely(spf6i->nh)) {\n\t\t\tnh = rt6_nh_dev_match(net, spf6i->nh, res, saddr,\n\t\t\t\t\t      oif, flags);\n\t\t\tif (nh)\n\t\t\t\tmatched = true;\n\t\t} else {\n\t\t\tnh = spf6i->fib6_nh;\n\t\t\tif (__rt6_device_match(net, nh, saddr, oif, flags))\n\t\t\t\tmatched = true;\n\t\t}\n\t\tif (matched) {\n\t\t\tres->f6i = spf6i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (oif && flags & RT6_LOOKUP_F_IFACE) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tnh = res->f6i->fib6_nh;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(f6i->nh)) {\n\t\tnh = nexthop_fib6_nh(f6i->nh);\n\t\tif (nexthop_is_blackhole(f6i->nh))\n\t\t\tgoto out_blackhole;\n\t} else {\n\t\tnh = f6i->fib6_nh;\n\t}\n\n\tif (nh->fib_nh_flags & RTNH_F_DEAD) {\n\t\tres->f6i = net->ipv6.fib6_null_entry;\n\t\tnh = res->f6i->fib6_nh;\n\t}\nout:\n\tres->nh = nh;\n\tres->fib6_type = res->f6i->fib6_type;\n\tres->fib6_flags = res->f6i->fib6_flags;\n\treturn;\n\nout_blackhole:\n\tres->fib6_flags |= RTF_REJECT;\n\tres->fib6_type = RTN_BLACKHOLE;\n\tres->nh = nh;\n}",
        "function_list": [
            "nexthop_fib6_nh"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\tif (nh->fib_nh_flags & RTNH_F_DEAD) {",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (nh)",
                "condition": [
                    "for (spf6i = f6i; spf6i; spf6i = rcu_dereference(spf6i->fib6_next))",
                    "if (unlikely(spf6i->nh))"
                ],
                "content": "\t\t\tif (nh)\n\t\t\t\tmatched = true;"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "goto out_blackhole;",
                "condition": [
                    "if (!oif && ipv6_addr_any(saddr))",
                    "if (unlikely(f6i->nh))",
                    "if (nexthop_is_blackhole(f6i->nh))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (!oif && ipv6_addr_any(saddr))",
                    "if (!(nh->fib_nh_flags & RTNH_F_DEAD))"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "for (spf6i = f6i; spf6i; spf6i = rcu_dereference(spf6i->fib6_next))",
                    "if (matched)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (oif && flags & RT6_LOOKUP_F_IFACE)"
                ]
            },
            {
                "text": "goto out_blackhole;",
                "condition": [
                    "if (unlikely(f6i->nh))",
                    "if (nexthop_is_blackhole(f6i->nh))"
                ]
            }
        ],
        "index": 58
    },
    {
        "var_name": "skb",
        "function_name": "udpv6_sendmsg",
        "location": {
            "file_path": "net/ipv6/udp.c",
            "region": {
                "startLine": 1589,
                "startColumn": 26,
                "endColumn": 29
            },
            "context": {
                "startLine": 1587,
                "endLine": 1591,
                "snippet": {
                    "text": "\t\t\terr = udp_v6_send_skb(skb, fl6, &cork.base);"
                }
            }
        },
        "function_code": "int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct inet_cork_full cork;\n\tstruct flowi6 *fl6 = &cork.fl.u.ip6;\n\tstruct dst_entry *dst;\n\tstruct ipcm6_cookie ipc6;\n\tint addr_len = msg->msg_namelen;\n\tbool connected = false;\n\tint ulen = len;\n\tint corkreq = udp_test_bit(CORK, sk) || msg->msg_flags & MSG_MORE;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tint (*getfrag)(void *, char *, int, int, int, struct sk_buff *);\n\n\tipcm6_init(&ipc6);\n\tipc6.gso_size = READ_ONCE(up->gso_size);\n\tipc6.sockc.tsflags = READ_ONCE(sk->sk_tsflags);\n\tipc6.sockc.mark = READ_ONCE(sk->sk_mark);\n\n\t/* destination address check */\n\tif (sin6) {\n\t\tif (addr_len < offsetof(struct sockaddr, sa_data))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (sin6->sin6_family) {\n\t\tcase AF_INET6:\n\t\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\t\treturn -EINVAL;\n\t\t\tdaddr = &sin6->sin6_addr;\n\t\t\tif (ipv6_addr_any(daddr) &&\n\t\t\t    ipv6_addr_v4mapped(&np->saddr))\n\t\t\t\tipv6_addr_set_v4mapped(htonl(INADDR_LOOPBACK),\n\t\t\t\t\t\t       daddr);\n\t\t\tbreak;\n\t\tcase AF_INET:\n\t\t\tgoto do_udp_sendmsg;\n\t\tcase AF_UNSPEC:\n\t\t\tmsg->msg_name = sin6 = NULL;\n\t\t\tmsg->msg_namelen = addr_len = 0;\n\t\t\tdaddr = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (!READ_ONCE(up->pending)) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t} else\n\t\tdaddr = NULL;\n\n\tif (daddr) {\n\t\tif (ipv6_addr_v4mapped(daddr)) {\n\t\t\tstruct sockaddr_in sin;\n\t\t\tsin.sin_family = AF_INET;\n\t\t\tsin.sin_port = sin6 ? sin6->sin6_port : inet->inet_dport;\n\t\t\tsin.sin_addr.s_addr = daddr->s6_addr32[3];\n\t\t\tmsg->msg_name = &sin;\n\t\t\tmsg->msg_namelen = sizeof(sin);\ndo_udp_sendmsg:\n\t\t\terr = ipv6_only_sock(sk) ?\n\t\t\t\t-ENETUNREACH : udp_sendmsg(sk, msg, len);\n\t\t\tmsg->msg_name = sin6;\n\t\t\tmsg->msg_namelen = addr_len;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* Rough check on arithmetic overflow,\n\t   better check is made in ip6_append_data().\n\t   */\n\tif (len > INT_MAX - sizeof(struct udphdr))\n\t\treturn -EMSGSIZE;\n\n\tgetfrag  =  is_udplite ?  udplite_getfrag : ip_generic_getfrag;\n\tif (READ_ONCE(up->pending)) {\n\t\tif (READ_ONCE(up->pending) == AF_INET)\n\t\t\treturn udp_sendmsg(sk, msg, len);\n\t\t/*\n\t\t * There are pending frames.\n\t\t * The socket lock must be held while it's corked.\n\t\t */\n\t\tlock_sock(sk);\n\t\tif (likely(up->pending)) {\n\t\t\tif (unlikely(up->pending != AF_INET6)) {\n\t\t\t\trelease_sock(sk);\n\t\t\t\treturn -EAFNOSUPPORT;\n\t\t\t}\n\t\t\tdst = NULL;\n\t\t\tgoto do_append_data;\n\t\t}\n\t\trelease_sock(sk);\n\t}\n\tulen += sizeof(struct udphdr);\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\n\tif (sin6) {\n\t\tif (sin6->sin6_port == 0)\n\t\t\treturn -EINVAL;\n\n\t\tfl6->fl6_dport = sin6->sin6_port;\n\t\tdaddr = &sin6->sin6_addr;\n\n\t\tif (inet6_test_bit(SNDFLOW, sk)) {\n\t\t\tfl6->flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;\n\t\t\tif (fl6->flowlabel & IPV6_FLOWLABEL_MASK) {\n\t\t\t\tflowlabel = fl6_sock_lookup(sk, fl6->flowlabel);\n\t\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Otherwise it will be difficult to maintain\n\t\t * sk->sk_dst_cache.\n\t\t */\n\t\tif (sk->sk_state == TCP_ESTABLISHED &&\n\t\t    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))\n\t\t\tdaddr = &sk->sk_v6_daddr;\n\n\t\tif (addr_len >= sizeof(struct sockaddr_in6) &&\n\t\t    sin6->sin6_scope_id &&\n\t\t    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))\n\t\t\tfl6->flowi6_oif = sin6->sin6_scope_id;\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -EDESTADDRREQ;\n\n\t\tfl6->fl6_dport = inet->inet_dport;\n\t\tdaddr = &sk->sk_v6_daddr;\n\t\tfl6->flowlabel = np->flow_label;\n\t\tconnected = true;\n\t}\n\n\tif (!fl6->flowi6_oif)\n\t\tfl6->flowi6_oif = READ_ONCE(sk->sk_bound_dev_if);\n\n\tif (!fl6->flowi6_oif)\n\t\tfl6->flowi6_oif = np->sticky_pktinfo.ipi6_ifindex;\n\n\tfl6->flowi6_uid = sk->sk_uid;\n\n\tif (msg->msg_controllen) {\n\t\topt = &opt_space;\n\t\tmemset(opt, 0, sizeof(struct ipv6_txoptions));\n\t\topt->tot_len = sizeof(*opt);\n\t\tipc6.opt = opt;\n\n\t\terr = udp_cmsg_send(sk, msg, &ipc6.gso_size);\n\t\tif (err > 0) {\n\t\t\terr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, fl6,\n\t\t\t\t\t\t    &ipc6);\n\t\t\tconnected = false;\n\t\t}\n\t\tif (err < 0) {\n\t\t\tfl6_sock_release(flowlabel);\n\t\t\treturn err;\n\t\t}\n\t\tif ((fl6->flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6->flowlabel);\n\t\t\tif (IS_ERR(flowlabel))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t}\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\tipc6.opt = opt;\n\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->flowi6_mark = ipc6.sockc.mark;\n\tfl6->daddr = *daddr;\n\tif (ipv6_addr_any(&fl6->saddr) && !ipv6_addr_any(&np->saddr))\n\t\tfl6->saddr = np->saddr;\n\tfl6->fl6_sport = inet->inet_sport;\n\n\tif (cgroup_bpf_enabled(CGROUP_UDP6_SENDMSG) && !connected) {\n\t\terr = BPF_CGROUP_RUN_PROG_UDP6_SENDMSG_LOCK(sk,\n\t\t\t\t\t   (struct sockaddr *)sin6,\n\t\t\t\t\t   &addr_len,\n\t\t\t\t\t   &fl6->saddr);\n\t\tif (err)\n\t\t\tgoto out_no_dst;\n\t\tif (sin6) {\n\t\t\tif (ipv6_addr_v4mapped(&sin6->sin6_addr)) {\n\t\t\t\t/* BPF program rewrote IPv6-only by IPv4-mapped\n\t\t\t\t * IPv6. It's currently unsupported.\n\t\t\t\t */\n\t\t\t\terr = -ENOTSUPP;\n\t\t\t\tgoto out_no_dst;\n\t\t\t}\n\t\t\tif (sin6->sin6_port == 0) {\n\t\t\t\t/* BPF program set invalid port. Reject it. */\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out_no_dst;\n\t\t\t}\n\t\t\tfl6->fl6_dport = sin6->sin6_port;\n\t\t\tfl6->daddr = sin6->sin6_addr;\n\t\t}\n\t}\n\n\tif (ipv6_addr_any(&fl6->daddr))\n\t\tfl6->daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\n\tfinal_p = fl6_update_dst(fl6, opt, &final);\n\tif (final_p)\n\t\tconnected = false;\n\n\tif (!fl6->flowi6_oif && ipv6_addr_is_multicast(&fl6->daddr)) {\n\t\tfl6->flowi6_oif = READ_ONCE(np->mcast_oif);\n\t\tconnected = false;\n\t} else if (!fl6->flowi6_oif)\n\t\tfl6->flowi6_oif = READ_ONCE(np->ucast_oif);\n\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi_common(fl6));\n\n\tif (ipc6.tclass < 0)\n\t\tipc6.tclass = np->tclass;\n\n\tfl6->flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6->flowlabel);\n\n\tdst = ip6_sk_dst_lookup_flow(sk, fl6, final_p, connected);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto out;\n\t}\n\n\tif (ipc6.hlimit < 0)\n\t\tipc6.hlimit = ip6_sk_dst_hoplimit(np, fl6, dst);\n\n\tif (msg->msg_flags&MSG_CONFIRM)\n\t\tgoto do_confirm;\nback_from_confirm:\n\n\t/* Lockless fast path for the non-corking case */\n\tif (!corkreq) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = ip6_make_skb(sk, getfrag, msg, ulen,\n\t\t\t\t   sizeof(struct udphdr), &ipc6,\n\t\t\t\t   dst_rt6_info(dst),\n\t\t\t\t   msg->msg_flags, &cork);\n\t\terr = PTR_ERR(skb);\n\t\tif (!IS_ERR_OR_NULL(skb))\n\t\t\terr = udp_v6_send_skb(skb, fl6, &cork.base);\n\t\t/* ip6_make_skb steals dst reference */\n\t\tgoto out_no_dst;\n\t}\n\n\tlock_sock(sk);\n\tif (unlikely(up->pending)) {\n\t\t/* The socket is already corked while preparing it. */\n\t\t/* ... which is an evident application bug. --ANK */\n\t\trelease_sock(sk);\n\n\t\tnet_dbg_ratelimited(\"udp cork app bug 2\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tWRITE_ONCE(up->pending, AF_INET6);\n\ndo_append_data:\n\tif (ipc6.dontfrag < 0)\n\t\tipc6.dontfrag = inet6_test_bit(DONTFRAG, sk);\n\tup->len += ulen;\n\terr = ip6_append_data(sk, getfrag, msg, ulen, sizeof(struct udphdr),\n\t\t\t      &ipc6, fl6, dst_rt6_info(dst),\n\t\t\t      corkreq ? msg->msg_flags|MSG_MORE : msg->msg_flags);\n\tif (err)\n\t\tudp_v6_flush_pending_frames(sk);\n\telse if (!corkreq)\n\t\terr = udp_v6_push_pending_frames(sk);\n\telse if (unlikely(skb_queue_empty(&sk->sk_write_queue)))\n\t\tWRITE_ONCE(up->pending, 0);\n\n\tif (err > 0)\n\t\terr = inet6_test_bit(RECVERR6, sk) ? net_xmit_errno(err) : 0;\n\trelease_sock(sk);\n\nout:\n\tdst_release(dst);\nout_no_dst:\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {\n\t\tUDP6_INC_STATS(sock_net(sk),\n\t\t\t       UDP_MIB_SNDBUFERRORS, is_udplite);\n\t}\n\treturn err;\n\ndo_confirm:\n\tif (msg->msg_flags & MSG_PROBE)\n\t\tdst_confirm_neigh(dst, &fl6->daddr);\n\tif (!(msg->msg_flags&MSG_PROBE) || len)\n\t\tgoto back_from_confirm;\n\terr = 0;\n\tgoto out;\n}",
        "function_list": [
            "IS_ERR_OR_NULL"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\terr = udp_v6_send_skb(skb, fl6, &cork.base);",
                "condition": [
                    "goto back_from_confirm",
                    "if (!corkreq)",
                    "if (!IS_ERR_OR_NULL(skb))"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (sin6)",
                    "if (addr_len < offsetof(struct sockaddr, sa_data))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (sin6)",
                    "if(sin6->sin6_family == AF_INET6)",
                    "if (addr_len < SIN6_LEN_RFC2133)"
                ]
            },
            {
                "text": "goto do_udp_sendmsg;",
                "condition": [
                    "if (sin6)",
                    "if(sin6->sin6_family == AF_INET)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (sin6)",
                    "if(sin6->sin6_family != AF_UNSPEC && sin6->sin6_family != AF_INET && sin6->sin6_family != AF_INET6)"
                ]
            },
            {
                "text": "return -EDESTADDRREQ;",
                "condition": [
                    "if (!READ_ONCE(up->pending))",
                    "if (sk->sk_state != TCP_ESTABLISHED)"
                ]
            },
            {
                "text": "return err;",
                "condition": []
            },
            {
                "text": "return -EMSGSIZE;",
                "condition": [
                    "if (len > INT_MAX - sizeof(struct udphdr))"
                ]
            },
            {
                "text": "return udp_sendmsg(sk, msg, len);",
                "condition": [
                    "if (READ_ONCE(up->pending))",
                    "if (READ_ONCE(up->pending) == AF_INET)"
                ]
            },
            {
                "text": "return -EAFNOSUPPORT;",
                "condition": [
                    "if (READ_ONCE(up->pending))",
                    "if (likely(up->pending))",
                    "if (unlikely(up->pending != AF_INET6))"
                ]
            },
            {
                "text": "goto do_append_data;",
                "condition": [
                    "if (READ_ONCE(up->pending))",
                    "if (likely(up->pending))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (sin6)",
                    "if (sin6->sin6_port == 0)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (sin6)",
                    "if (inet6_test_bit(SNDFLOW, sk))",
                    "if (fl6->flowlabel & IPV6_FLOWLABEL_MASK)",
                    "if (IS_ERR(flowlabel))"
                ]
            },
            {
                "text": "return -EDESTADDRREQ;",
                "condition": [
                    "if(!(sin6))",
                    "if (sk->sk_state != TCP_ESTABLISHED)"
                ]
            },
            {
                "text": "return err;",
                "condition": [
                    "if (msg->msg_controllen)",
                    "if (err < 0)"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (msg->msg_controllen)",
                    "if ((fl6->flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel)",
                    "if (IS_ERR(flowlabel))"
                ]
            },
            {
                "text": "goto out_no_dst;",
                "condition": [
                    "if (cgroup_bpf_enabled(CGROUP_UDP6_SENDMSG) && !connected)",
                    "if (err)"
                ]
            },
            {
                "text": "goto out_no_dst;",
                "condition": [
                    "if (cgroup_bpf_enabled(CGROUP_UDP6_SENDMSG) && !connected)",
                    "if (sin6)",
                    "if (ipv6_addr_v4mapped(&sin6->sin6_addr))"
                ]
            },
            {
                "text": "goto out_no_dst;",
                "condition": [
                    "if (cgroup_bpf_enabled(CGROUP_UDP6_SENDMSG) && !connected)",
                    "if (sin6)",
                    "if (sin6->sin6_port == 0)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "if (IS_ERR(dst))"
                ]
            },
            {
                "text": "goto do_confirm;",
                "condition": [
                    "if (msg->msg_flags&MSG_CONFIRM)"
                ]
            }
        ],
        "index": 59
    },
    {
        "var_name": "elems",
        "function_name": "ieee80211_process_addba_request",
        "location": {
            "file_path": "net/mac80211/agg-rx.c",
            "region": {
                "startLine": 480,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 478,
                "endLine": 482,
                "snippet": {
                    "text": "\tkfree(elems);"
                }
            }
        },
        "function_code": "void ieee80211_process_addba_request(struct ieee80211_local *local,\n\t\t\t\t     struct sta_info *sta,\n\t\t\t\t     struct ieee80211_mgmt *mgmt,\n\t\t\t\t     size_t len)\n{\n\tu16 capab, tid, timeout, ba_policy, buf_size, start_seq_num;\n\tstruct ieee802_11_elems *elems = NULL;\n\tu8 dialog_token;\n\tint ies_len;\n\n\t/* extract session parameters from addba request frame */\n\tdialog_token = mgmt->u.action.u.addba_req.dialog_token;\n\ttimeout = le16_to_cpu(mgmt->u.action.u.addba_req.timeout);\n\tstart_seq_num =\n\t\tle16_to_cpu(mgmt->u.action.u.addba_req.start_seq_num) >> 4;\n\n\tcapab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\n\tba_policy = (capab & IEEE80211_ADDBA_PARAM_POLICY_MASK) >> 1;\n\ttid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;\n\tbuf_size = (capab & IEEE80211_ADDBA_PARAM_BUF_SIZE_MASK) >> 6;\n\n\ties_len = len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t u.action.u.addba_req.variable);\n\tif (ies_len) {\n\t\telems = ieee802_11_parse_elems(mgmt->u.action.u.addba_req.variable,\n\t\t\t\t\t       ies_len, true, NULL);\n\t\tif (!elems || elems->parse_error)\n\t\t\tgoto free;\n\t}\n\n\tif (sta->sta.deflink.eht_cap.has_eht && elems && elems->addba_ext_ie) {\n\t\tu8 buf_size_1k = u8_get_bits(elems->addba_ext_ie->data,\n\t\t\t\t\t     IEEE80211_ADDBA_EXT_BUF_SIZE_MASK);\n\n\t\tbuf_size |= buf_size_1k << IEEE80211_ADDBA_EXT_BUF_SIZE_SHIFT;\n\t}\n\n\t__ieee80211_start_rx_ba_session(sta, dialog_token, timeout,\n\t\t\t\t\tstart_seq_num, ba_policy, tid,\n\t\t\t\t\tbuf_size, true, false,\n\t\t\t\t\telems ? elems->addba_ext_ie : NULL);\nfree:\n\tkfree(elems);\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree(elems);",
                "condition": [
                    "goto free"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct ieee802_11_elems *elems = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [
            {
                "text": "if (sta->sta.deflink.eht_cap.has_eht && elems && elems->addba_ext_ie)",
                "condition": [],
                "content": "\tif (sta->sta.deflink.eht_cap.has_eht && elems && elems->addba_ext_ie) {\n\t\tu8 buf_size_1k = u8_get_bits(elems->addba_ext_ie->data,\n\t\t\t\t\t     IEEE80211_ADDBA_EXT_BUF_SIZE_MASK);\n\n\t\tbuf_size |= buf_size_1k << IEEE80211_ADDBA_EXT_BUF_SIZE_SHIFT;\n\t}\n"
            }
        ],
        "early_jump_constraints": [],
        "index": 63
    },
    {
        "var_name": "func",
        "function_name": "ieee80211_nan_func_match",
        "location": {
            "file_path": "net/mac80211/cfg.c",
            "region": {
                "startLine": 4469,
                "startColumn": 18,
                "endColumn": 22
            },
            "context": {
                "startLine": 4467,
                "endLine": 4471,
                "snippet": {
                    "text": "\tmatch->cookie = func->cookie;"
                }
            }
        },
        "function_code": "void ieee80211_nan_func_match(struct ieee80211_vif *vif,\n\t\t\t      struct cfg80211_nan_match_params *match,\n\t\t\t      gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct cfg80211_nan_func *func;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_NAN))\n\t\treturn;\n\n\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\tfunc = idr_find(&sdata->u.nan.function_inst_ids,  match->inst_id);\n\tif (WARN_ON(!func)) {\n\t\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\t\treturn;\n\t}\n\tmatch->cookie = func->cookie;\n\n\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\n\tcfg80211_nan_match(ieee80211_vif_to_wdev(vif), match, gfp);\n}",
        "function_list": [
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tmatch->cookie = func->cookie;",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON(vif->type != NL80211_IFTYPE_NAN))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON(!func))"
                ]
            }
        ],
        "index": 64
    },
    {
        "var_name": "func",
        "function_name": "ieee80211_nan_func_terminated",
        "location": {
            "file_path": "net/mac80211/cfg.c",
            "region": {
                "startLine": 4440,
                "startColumn": 11,
                "endColumn": 15
            },
            "context": {
                "startLine": 4438,
                "endLine": 4442,
                "snippet": {
                    "text": "\tcookie = func->cookie;"
                }
            }
        },
        "function_code": "void ieee80211_nan_func_terminated(struct ieee80211_vif *vif,\n\t\t\t\t   u8 inst_id,\n\t\t\t\t   enum nl80211_nan_func_term_reason reason,\n\t\t\t\t   gfp_t gfp)\n{\n\tstruct ieee80211_sub_if_data *sdata = vif_to_sdata(vif);\n\tstruct cfg80211_nan_func *func;\n\tu64 cookie;\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_NAN))\n\t\treturn;\n\n\tspin_lock_bh(&sdata->u.nan.func_lock);\n\n\tfunc = idr_find(&sdata->u.nan.function_inst_ids, inst_id);\n\tif (WARN_ON(!func)) {\n\t\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\t\treturn;\n\t}\n\n\tcookie = func->cookie;\n\tidr_remove(&sdata->u.nan.function_inst_ids, inst_id);\n\n\tspin_unlock_bh(&sdata->u.nan.func_lock);\n\n\tcfg80211_free_nan_func(func);\n\n\tcfg80211_nan_func_terminated(ieee80211_vif_to_wdev(vif), inst_id,\n\t\t\t\t     reason, cookie, gfp);\n}",
        "function_list": [
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tcookie = func->cookie;",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON(vif->type != NL80211_IFTYPE_NAN))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON(!func))"
                ]
            }
        ],
        "index": 65
    },
    {
        "var_name": "old_ctx",
        "function_name": "ieee80211_chsw_switch_vifs",
        "location": {
            "file_path": "net/mac80211/chan.c",
            "region": {
                "startLine": 1373,
                "startColumn": 27,
                "endColumn": 34
            },
            "context": {
                "startLine": 1371,
                "endLine": 1375,
                "snippet": {
                    "text": "\t\t\tvif_chsw[i].old_ctx = &old_ctx->conf;"
                }
            }
        },
        "function_code": "static int ieee80211_chsw_switch_vifs(struct ieee80211_local *local,\n\t\t\t\t      int n_vifs)\n{\n\tstruct ieee80211_vif_chanctx_switch *vif_chsw;\n\tstruct ieee80211_link_data *link;\n\tstruct ieee80211_chanctx *ctx, *old_ctx;\n\tint i, err;\n\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\tvif_chsw = kcalloc(n_vifs, sizeof(vif_chsw[0]), GFP_KERNEL);\n\tif (!vif_chsw)\n\t\treturn -ENOMEM;\n\n\ti = 0;\n\tlist_for_each_entry(ctx, &local->chanctx_list, list) {\n\t\tif (ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!ctx->replace_ctx)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(link, &ctx->reserved_links,\n\t\t\t\t    reserved_chanctx_list) {\n\t\t\tif (!ieee80211_link_has_in_place_reservation(link))\n\t\t\t\tcontinue;\n\n\t\t\told_ctx = ieee80211_link_get_chanctx(link);\n\t\t\tvif_chsw[i].vif = &link->sdata->vif;\n\t\t\tvif_chsw[i].old_ctx = &old_ctx->conf;\n\t\t\tvif_chsw[i].new_ctx = &ctx->conf;\n\t\t\tvif_chsw[i].link_conf = link->conf;\n\n\t\t\ti++;\n\t\t}\n\t}\n\n\terr = drv_switch_vif_chanctx(local, vif_chsw, n_vifs,\n\t\t\t\t     CHANCTX_SWMODE_SWAP_CONTEXTS);\n\nout:\n\tkfree(vif_chsw);\n\treturn err;\n}",
        "function_list": [
            "ieee80211_link_get_chanctx"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\t\tvif_chsw[i].old_ctx = &old_ctx->conf;",
                "condition": [
                    "list_for_each_entry(ctx, &local->chanctx_list, list)",
                    "list_for_each_entry(link, &ctx->reserved_links, reserved_chanctx_list)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -ENOMEM;",
                "condition": [
                    "if (!vif_chsw)"
                ]
            },
            {
                "text": "continue;",
                "condition": [
                    "list_for_each_entry(ctx, &local->chanctx_list, list)",
                    "if (ctx->replace_state != IEEE80211_CHANCTX_REPLACES_OTHER)"
                ]
            },
            {
                "text": "goto out;",
                "condition": [
                    "list_for_each_entry(ctx, &local->chanctx_list, list)",
                    "if (WARN_ON(!ctx->replace_ctx))"
                ]
            },
            {
                "text": "continue;",
                "condition": [
                    "list_for_each_entry(ctx, &local->chanctx_list, list)",
                    "list_for_each_entry(link, &ctx->reserved_links, reserved_chanctx_list)",
                    "if (!ieee80211_link_has_in_place_reservation(link))"
                ]
            }
        ],
        "index": 67
    },
    {
        "var_name": "old_ctx",
        "function_name": "ieee80211_link_use_reserved_reassign",
        "location": {
            "file_path": "net/mac80211/chan.c",
            "region": {
                "startLine": 1224,
                "startColumn": 44,
                "endColumn": 51
            },
            "context": {
                "startLine": 1222,
                "endLine": 1226,
                "snippet": {
                    "text": "\t_ieee80211_change_chanctx(local, new_ctx, old_ctx, chanreq, link);"
                }
            }
        },
        "function_code": "static int\nieee80211_link_use_reserved_reassign(struct ieee80211_link_data *link)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_bss_conf *link_conf = link->conf;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_vif_chanctx_switch vif_chsw[1] = {};\n\tstruct ieee80211_chanctx *old_ctx, *new_ctx;\n\tconst struct ieee80211_chan_req *chanreq;\n\tstruct ieee80211_chan_req tmp;\n\tu64 changed = 0;\n\tint err;\n\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\tnew_ctx = link->reserved_chanctx;\n\told_ctx = ieee80211_link_get_chanctx(link);\n\n\tif (WARN_ON(!link->reserved_ready))\n\t\treturn -EBUSY;\n\n\tif (WARN_ON(!new_ctx))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!old_ctx))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(new_ctx->replace_state ==\n\t\t    IEEE80211_CHANCTX_REPLACES_OTHER))\n\t\treturn -EINVAL;\n\n\tchanreq = ieee80211_chanctx_non_reserved_chandef(local, new_ctx,\n\t\t\t\t\t\t\t &link->reserved,\n\t\t\t\t\t\t\t &tmp);\n\tif (WARN_ON(!chanreq))\n\t\treturn -EINVAL;\n\n\tif (link_conf->chanreq.oper.width != link->reserved.oper.width)\n\t\tchanged = BSS_CHANGED_BANDWIDTH;\n\n\tieee80211_link_update_chanreq(link, &link->reserved);\n\n\t_ieee80211_change_chanctx(local, new_ctx, old_ctx, chanreq, link);\n\n\tvif_chsw[0].vif = &sdata->vif;\n\tvif_chsw[0].old_ctx = &old_ctx->conf;\n\tvif_chsw[0].new_ctx = &new_ctx->conf;\n\tvif_chsw[0].link_conf = link->conf;\n\n\tlist_del(&link->reserved_chanctx_list);\n\tlink->reserved_chanctx = NULL;\n\n\terr = drv_switch_vif_chanctx(local, vif_chsw, 1,\n\t\t\t\t     CHANCTX_SWMODE_REASSIGN_VIF);\n\tif (err) {\n\t\tif (ieee80211_chanctx_refcount(local, new_ctx) == 0)\n\t\t\tieee80211_free_chanctx(local, new_ctx);\n\n\t\tgoto out;\n\t}\n\n\tlist_move(&link->assigned_chanctx_list, &new_ctx->assigned_links);\n\trcu_assign_pointer(link_conf->chanctx_conf, &new_ctx->conf);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t__ieee80211_link_copy_chanctx_to_vlans(link, false);\n\n\tieee80211_check_fast_xmit_iface(sdata);\n\n\tif (ieee80211_chanctx_refcount(local, old_ctx) == 0)\n\t\tieee80211_free_chanctx(local, old_ctx);\n\n\tieee80211_recalc_chanctx_min_def(local, new_ctx, NULL);\n\tieee80211_recalc_smps_chanctx(local, new_ctx);\n\tieee80211_recalc_radar_chanctx(local, new_ctx);\n\n\tif (changed)\n\t\tieee80211_link_info_change_notify(sdata, link, changed);\n\nout:\n\tieee80211_link_chanctx_reservation_complete(link);\n\treturn err;\n}",
        "function_list": [
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t_ieee80211_change_chanctx(local, new_ctx, old_ctx, chanreq, link);",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -EBUSY;",
                "condition": [
                    "if (WARN_ON(!link->reserved_ready))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (WARN_ON(!new_ctx))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (WARN_ON(!old_ctx))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (WARN_ON(new_ctx->replace_state == IEEE80211_CHANCTX_REPLACES_OTHER))"
                ]
            },
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (WARN_ON(!chanreq))"
                ]
            }
        ],
        "index": 68
    },
    {
        "var_name": "elems",
        "function_name": "ieee80211_ibss_rx_queued_mgmt",
        "location": {
            "file_path": "net/mac80211/ibss.c",
            "region": {
                "startLine": 1633,
                "startColumn": 10,
                "endColumn": 15
            },
            "context": {
                "startLine": 1631,
                "endLine": 1635,
                "snippet": {
                    "text": "\t\t\tkfree(elems);"
                }
            }
        },
        "function_code": "void ieee80211_ibss_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee80211_mgmt *mgmt;\n\tu16 fc;\n\tstruct ieee802_11_elems *elems;\n\tint ies_len;\n\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\tfc = le16_to_cpu(mgmt->frame_control);\n\n\tif (!sdata->u.ibss.ssid_len)\n\t\treturn; /* not ready to merge yet */\n\n\tswitch (fc & IEEE80211_FCTL_STYPE) {\n\tcase IEEE80211_STYPE_PROBE_REQ:\n\t\tieee80211_rx_mgmt_probe_req(sdata, skb);\n\t\tbreak;\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\tcase IEEE80211_STYPE_BEACON:\n\t\tieee80211_rx_mgmt_probe_beacon(sdata, mgmt, skb->len,\n\t\t\t\t\t       rx_status);\n\t\tbreak;\n\tcase IEEE80211_STYPE_AUTH:\n\t\tieee80211_rx_mgmt_auth_ibss(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\tieee80211_rx_mgmt_deauth_ibss(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ACTION:\n\t\tswitch (mgmt->u.action.category) {\n\t\tcase WLAN_CATEGORY_SPECTRUM_MGMT:\n\t\t\ties_len = skb->len -\n\t\t\t\t  offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t   u.action.u.chan_switch.variable);\n\n\t\t\tif (ies_len < 0)\n\t\t\t\tbreak;\n\n\t\t\telems = ieee802_11_parse_elems(\n\t\t\t\tmgmt->u.action.u.chan_switch.variable,\n\t\t\t\ties_len, true, NULL);\n\n\t\t\tif (elems && !elems->parse_error)\n\t\t\t\tieee80211_rx_mgmt_spectrum_mgmt(sdata, mgmt,\n\t\t\t\t\t\t\t\tskb->len,\n\t\t\t\t\t\t\t\trx_status,\n\t\t\t\t\t\t\t\telems);\n\t\t\tkfree(elems);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\tkfree(elems);",
                "condition": [
                    "if(fc & IEEE80211_FCTL_STYPE == IEEE80211_STYPE_ACTION)",
                    "if(mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (elems && !elems->parse_error)",
                "condition": [
                    "if(fc & IEEE80211_FCTL_STYPE == IEEE80211_STYPE_ACTION)",
                    "if(mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)"
                ],
                "content": "\t\t\tif (elems && !elems->parse_error)\n\t\t\t\tieee80211_rx_mgmt_spectrum_mgmt(sdata, mgmt,\n\t\t\t\t\t\t\t\tskb->len,\n\t\t\t\t\t\t\t\trx_status,\n\t\t\t\t\t\t\t\telems);"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "return; /* not ready to merge yet */",
                "condition": [
                    "if (!sdata->u.ibss.ssid_len)"
                ]
            }
        ],
        "index": 69
    },
    {
        "var_name": "elems",
        "function_name": "ieee80211_sta_rx_queued_mgmt",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 6914,
                "startColumn": 10,
                "endColumn": 15
            },
            "context": {
                "startLine": 6912,
                "endLine": 6916,
                "snippet": {
                    "text": "\t\t\tkfree(elems);"
                }
            }
        },
        "function_code": "void ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_link_data *link = &sdata->deflink;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee80211_mgmt *mgmt;\n\tu16 fc;\n\tint ies_len;\n\n\tlockdep_assert_wiphy(sdata->local->hw.wiphy);\n\n\trx_status = (struct ieee80211_rx_status *) skb->cb;\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\tfc = le16_to_cpu(mgmt->frame_control);\n\n\tif (rx_status->link_valid) {\n\t\tlink = sdata_dereference(sdata->link[rx_status->link_id],\n\t\t\t\t\t sdata);\n\t\tif (!link)\n\t\t\treturn;\n\t}\n\n\tswitch (fc & IEEE80211_FCTL_STYPE) {\n\tcase IEEE80211_STYPE_BEACON:\n\t\tieee80211_rx_mgmt_beacon(link, (void *)mgmt,\n\t\t\t\t\t skb->len, rx_status);\n\t\tbreak;\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\t\tieee80211_rx_mgmt_probe_resp(link, skb);\n\t\tbreak;\n\tcase IEEE80211_STYPE_AUTH:\n\t\tieee80211_rx_mgmt_auth(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\tieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DISASSOC:\n\t\tieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ASSOC_RESP:\n\tcase IEEE80211_STYPE_REASSOC_RESP:\n\t\tieee80211_rx_mgmt_assoc_resp(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ACTION:\n\t\tif (!sdata->u.mgd.associated ||\n\t\t    !ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr))\n\t\t\tbreak;\n\n\t\tif (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {\n\t\t\tstruct ieee802_11_elems *elems;\n\n\t\t\ties_len = skb->len -\n\t\t\t\t  offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t   u.action.u.chan_switch.variable);\n\n\t\t\tif (ies_len < 0)\n\t\t\t\tbreak;\n\n\t\t\t/* CSA IE cannot be overridden, no need for BSSID */\n\t\t\telems = ieee802_11_parse_elems(\n\t\t\t\t\tmgmt->u.action.u.chan_switch.variable,\n\t\t\t\t\ties_len, true, NULL);\n\n\t\t\tif (elems && !elems->parse_error)\n\t\t\t\tieee80211_sta_process_chanswitch(link,\n\t\t\t\t\t\t\t\t rx_status->mactime,\n\t\t\t\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t\t\t\t elems, false);\n\t\t\tkfree(elems);\n\t\t} else if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {\n\t\t\tstruct ieee802_11_elems *elems;\n\n\t\t\ties_len = skb->len -\n\t\t\t\t  offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t   u.action.u.ext_chan_switch.variable);\n\n\t\t\tif (ies_len < 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * extended CSA IE can't be overridden, no need for\n\t\t\t * BSSID\n\t\t\t */\n\t\t\telems = ieee802_11_parse_elems(\n\t\t\t\t\tmgmt->u.action.u.ext_chan_switch.variable,\n\t\t\t\t\ties_len, true, NULL);\n\n\t\t\tif (elems && !elems->parse_error) {\n\t\t\t\t/* for the handling code pretend it was an IE */\n\t\t\t\telems->ext_chansw_ie =\n\t\t\t\t\t&mgmt->u.action.u.ext_chan_switch.data;\n\n\t\t\t\tieee80211_sta_process_chanswitch(link,\n\t\t\t\t\t\t\t\t rx_status->mactime,\n\t\t\t\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t\t\t\t elems, false);\n\t\t\t}\n\n\t\t\tkfree(elems);\n\t\t}\n\t\tbreak;\n\t}\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\tkfree(elems);",
                "condition": [
                    "if(fc & IEEE80211_FCTL_STYPE == IEEE80211_STYPE_ACTION)",
                    "if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (elems && !elems->parse_error)",
                "condition": [
                    "if(fc & IEEE80211_FCTL_STYPE == IEEE80211_STYPE_ACTION)",
                    "if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)"
                ],
                "content": "\t\t\tif (elems && !elems->parse_error)\n\t\t\t\tieee80211_sta_process_chanswitch(link,\n\t\t\t\t\t\t\t\t rx_status->mactime,\n\t\t\t\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t\t\t\t elems, false);"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (rx_status->link_valid)",
                    "if (!link)"
                ]
            },
            {
                "text": "break;",
                "condition": [
                    "if(fc & IEEE80211_FCTL_STYPE == IEEE80211_STYPE_ACTION)",
                    "if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)",
                    "if (ies_len < 0)"
                ]
            }
        ],
        "index": 71
    },
    {
        "var_name": "elems",
        "function_name": "ieee80211_sta_rx_queued_mgmt",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 6944,
                "startColumn": 10,
                "endColumn": 15
            },
            "context": {
                "startLine": 6942,
                "endLine": 6946,
                "snippet": {
                    "text": "\t\t\tkfree(elems);"
                }
            }
        },
        "function_code": "void ieee80211_sta_rx_queued_mgmt(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_link_data *link = &sdata->deflink;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee80211_mgmt *mgmt;\n\tu16 fc;\n\tint ies_len;\n\n\tlockdep_assert_wiphy(sdata->local->hw.wiphy);\n\n\trx_status = (struct ieee80211_rx_status *) skb->cb;\n\tmgmt = (struct ieee80211_mgmt *) skb->data;\n\tfc = le16_to_cpu(mgmt->frame_control);\n\n\tif (rx_status->link_valid) {\n\t\tlink = sdata_dereference(sdata->link[rx_status->link_id],\n\t\t\t\t\t sdata);\n\t\tif (!link)\n\t\t\treturn;\n\t}\n\n\tswitch (fc & IEEE80211_FCTL_STYPE) {\n\tcase IEEE80211_STYPE_BEACON:\n\t\tieee80211_rx_mgmt_beacon(link, (void *)mgmt,\n\t\t\t\t\t skb->len, rx_status);\n\t\tbreak;\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\t\tieee80211_rx_mgmt_probe_resp(link, skb);\n\t\tbreak;\n\tcase IEEE80211_STYPE_AUTH:\n\t\tieee80211_rx_mgmt_auth(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\tieee80211_rx_mgmt_deauth(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_DISASSOC:\n\t\tieee80211_rx_mgmt_disassoc(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ASSOC_RESP:\n\tcase IEEE80211_STYPE_REASSOC_RESP:\n\t\tieee80211_rx_mgmt_assoc_resp(sdata, mgmt, skb->len);\n\t\tbreak;\n\tcase IEEE80211_STYPE_ACTION:\n\t\tif (!sdata->u.mgd.associated ||\n\t\t    !ether_addr_equal(mgmt->bssid, sdata->vif.cfg.ap_addr))\n\t\t\tbreak;\n\n\t\tif (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT) {\n\t\t\tstruct ieee802_11_elems *elems;\n\n\t\t\ties_len = skb->len -\n\t\t\t\t  offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t   u.action.u.chan_switch.variable);\n\n\t\t\tif (ies_len < 0)\n\t\t\t\tbreak;\n\n\t\t\t/* CSA IE cannot be overridden, no need for BSSID */\n\t\t\telems = ieee802_11_parse_elems(\n\t\t\t\t\tmgmt->u.action.u.chan_switch.variable,\n\t\t\t\t\ties_len, true, NULL);\n\n\t\t\tif (elems && !elems->parse_error)\n\t\t\t\tieee80211_sta_process_chanswitch(link,\n\t\t\t\t\t\t\t\t rx_status->mactime,\n\t\t\t\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t\t\t\t elems, false);\n\t\t\tkfree(elems);\n\t\t} else if (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC) {\n\t\t\tstruct ieee802_11_elems *elems;\n\n\t\t\ties_len = skb->len -\n\t\t\t\t  offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t   u.action.u.ext_chan_switch.variable);\n\n\t\t\tif (ies_len < 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * extended CSA IE can't be overridden, no need for\n\t\t\t * BSSID\n\t\t\t */\n\t\t\telems = ieee802_11_parse_elems(\n\t\t\t\t\tmgmt->u.action.u.ext_chan_switch.variable,\n\t\t\t\t\ties_len, true, NULL);\n\n\t\t\tif (elems && !elems->parse_error) {\n\t\t\t\t/* for the handling code pretend it was an IE */\n\t\t\t\telems->ext_chansw_ie =\n\t\t\t\t\t&mgmt->u.action.u.ext_chan_switch.data;\n\n\t\t\t\tieee80211_sta_process_chanswitch(link,\n\t\t\t\t\t\t\t\t rx_status->mactime,\n\t\t\t\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t\t\t\t elems, false);\n\t\t\t}\n\n\t\t\tkfree(elems);\n\t\t}\n\t\tbreak;\n\t}\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\tkfree(elems);",
                "condition": [
                    "if(fc & IEEE80211_FCTL_STYPE == IEEE80211_STYPE_ACTION)",
                    "if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (elems && !elems->parse_error)",
                "condition": [
                    "if(fc & IEEE80211_FCTL_STYPE == IEEE80211_STYPE_ACTION)",
                    "if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)"
                ],
                "content": "\t\t\tif (elems && !elems->parse_error)\n\t\t\t\tieee80211_sta_process_chanswitch(link,\n\t\t\t\t\t\t\t\t rx_status->mactime,\n\t\t\t\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t\t\t\t elems, false);"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (rx_status->link_valid)",
                    "if (!link)"
                ]
            },
            {
                "text": "break;",
                "condition": [
                    "if(fc & IEEE80211_FCTL_STYPE == IEEE80211_STYPE_ACTION)",
                    "if (mgmt->u.action.category == WLAN_CATEGORY_SPECTRUM_MGMT)",
                    "if (ies_len < 0)"
                ]
            }
        ],
        "index": 72
    },
    {
        "var_name": "elems",
        "function_name": "ieee80211_process_neg_ttlm_req",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 6750,
                "startColumn": 51,
                "endColumn": 56
            },
            "context": {
                "startLine": 6748,
                "endLine": 6752,
                "snippet": {
                    "text": "\tBUILD_BUG_ON(ARRAY_SIZE(direction) != ARRAY_SIZE(elems->ttlm));"
                }
            }
        },
        "function_code": "void ieee80211_process_neg_ttlm_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tu8 dialog_token, direction[IEEE80211_TTLM_MAX_CNT] = {}, i;\n\tsize_t ies_len;\n\tenum ieee80211_neg_ttlm_res ttlm_res = NEG_TTLM_RES_ACCEPT;\n\tstruct ieee802_11_elems *elems = NULL;\n\tstruct ieee80211_neg_ttlm neg_ttlm = {};\n\n\tBUILD_BUG_ON(ARRAY_SIZE(direction) != ARRAY_SIZE(elems->ttlm));\n\n\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\treturn;\n\n\tdialog_token = mgmt->u.action.u.ttlm_req.dialog_token;\n\ties_len  = len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t  u.action.u.ttlm_req.variable);\n\telems = ieee802_11_parse_elems(mgmt->u.action.u.ttlm_req.variable,\n\t\t\t\t       ies_len, true, NULL);\n\tif (!elems) {\n\t\tttlm_res = NEG_TTLM_RES_REJECT;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < elems->ttlm_num; i++) {\n\t\tif (ieee80211_parse_neg_ttlm(sdata, elems->ttlm[i],\n\t\t\t\t\t     &neg_ttlm, &direction[i]) ||\n\t\t    (direction[i] == IEEE80211_TTLM_DIRECTION_BOTH &&\n\t\t     elems->ttlm_num != 1)) {\n\t\t\tttlm_res = NEG_TTLM_RES_REJECT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!elems->ttlm_num ||\n\t    (elems->ttlm_num == 2 && direction[0] == direction[1])) {\n\t\tttlm_res = NEG_TTLM_RES_REJECT;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < IEEE80211_TTLM_NUM_TIDS; i++) {\n\t\tif ((neg_ttlm.downlink[i] &&\n\t\t     (neg_ttlm.downlink[i] & ~sdata->vif.valid_links)) ||\n\t\t    (neg_ttlm.uplink[i] &&\n\t\t     (neg_ttlm.uplink[i] & ~sdata->vif.valid_links))) {\n\t\t\tttlm_res = NEG_TTLM_RES_REJECT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tttlm_res = drv_can_neg_ttlm(sdata->local, sdata, &neg_ttlm);\n\n\tif (ttlm_res != NEG_TTLM_RES_ACCEPT)\n\t\tgoto out;\n\n\tieee80211_apply_neg_ttlm(sdata, neg_ttlm);\nout:\n\tkfree(elems);\n\tieee80211_send_neg_ttlm_res(sdata, ttlm_res, dialog_token, &neg_ttlm);\n}",
        "function_list": [
            "ARRAY_SIZE",
            "__must_be_array",
            "__same_type"
        ],
        "result": 1,
        "explain": "sizeof",
        "bug_line_constraints": [
            {
                "text": "\tBUILD_BUG_ON(ARRAY_SIZE(direction) != ARRAY_SIZE(elems->ttlm));",
                "condition": []
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct ieee802_11_elems *elems = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [],
        "index": 73
    },
    {
        "var_name": "elems",
        "function_name": "ieee80211_process_neg_ttlm_req",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 6798,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 6796,
                "endLine": 6800,
                "snippet": {
                    "text": "\tkfree(elems);"
                }
            }
        },
        "function_code": "void ieee80211_process_neg_ttlm_req(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt, size_t len)\n{\n\tu8 dialog_token, direction[IEEE80211_TTLM_MAX_CNT] = {}, i;\n\tsize_t ies_len;\n\tenum ieee80211_neg_ttlm_res ttlm_res = NEG_TTLM_RES_ACCEPT;\n\tstruct ieee802_11_elems *elems = NULL;\n\tstruct ieee80211_neg_ttlm neg_ttlm = {};\n\n\tBUILD_BUG_ON(ARRAY_SIZE(direction) != ARRAY_SIZE(elems->ttlm));\n\n\tif (!ieee80211_vif_is_mld(&sdata->vif))\n\t\treturn;\n\n\tdialog_token = mgmt->u.action.u.ttlm_req.dialog_token;\n\ties_len  = len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t  u.action.u.ttlm_req.variable);\n\telems = ieee802_11_parse_elems(mgmt->u.action.u.ttlm_req.variable,\n\t\t\t\t       ies_len, true, NULL);\n\tif (!elems) {\n\t\tttlm_res = NEG_TTLM_RES_REJECT;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < elems->ttlm_num; i++) {\n\t\tif (ieee80211_parse_neg_ttlm(sdata, elems->ttlm[i],\n\t\t\t\t\t     &neg_ttlm, &direction[i]) ||\n\t\t    (direction[i] == IEEE80211_TTLM_DIRECTION_BOTH &&\n\t\t     elems->ttlm_num != 1)) {\n\t\t\tttlm_res = NEG_TTLM_RES_REJECT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!elems->ttlm_num ||\n\t    (elems->ttlm_num == 2 && direction[0] == direction[1])) {\n\t\tttlm_res = NEG_TTLM_RES_REJECT;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < IEEE80211_TTLM_NUM_TIDS; i++) {\n\t\tif ((neg_ttlm.downlink[i] &&\n\t\t     (neg_ttlm.downlink[i] & ~sdata->vif.valid_links)) ||\n\t\t    (neg_ttlm.uplink[i] &&\n\t\t     (neg_ttlm.uplink[i] & ~sdata->vif.valid_links))) {\n\t\t\tttlm_res = NEG_TTLM_RES_REJECT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tttlm_res = drv_can_neg_ttlm(sdata->local, sdata, &neg_ttlm);\n\n\tif (ttlm_res != NEG_TTLM_RES_ACCEPT)\n\t\tgoto out;\n\n\tieee80211_apply_neg_ttlm(sdata, neg_ttlm);\nout:\n\tkfree(elems);\n\tieee80211_send_neg_ttlm_res(sdata, ttlm_res, dialog_token, &neg_ttlm);\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree(elems);",
                "condition": [
                    "goto out"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct ieee802_11_elems *elems = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (!ieee80211_vif_is_mld(&sdata->vif))"
                ]
            }
        ],
        "index": 74
    },
    {
        "var_name": "bssid",
        "function_name": "ieee80211_rx_mgmt_beacon",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 6213,
                "startColumn": 30,
                "endColumn": 35
            },
            "context": {
                "startLine": 6211,
                "endLine": 6215,
                "snippet": {
                    "text": "\t    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {"
                }
            }
        },
        "function_code": "static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n\t\t\t\t     struct ieee80211_hdr *hdr, size_t len,\n\t\t\t\t     struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;\n\tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n\tstruct ieee80211_mgmt *mgmt = (void *) hdr;\n\tsize_t baselen;\n\tstruct ieee802_11_elems *elems;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tstruct link_sta_info *link_sta;\n\tstruct sta_info *sta;\n\tu64 changed = 0;\n\tbool erp_valid;\n\tu8 erp_value = 0;\n\tu32 ncrc = 0;\n\tu8 *bssid, *variable = mgmt->u.beacon.variable;\n\tu8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.mode = link->u.mgd.conn.mode,\n\t\t.link_id = -1,\n\t\t.from_ap = true,\n\t};\n\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\t/* Process beacon from the current BSS */\n\tbssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n\t\tstruct ieee80211_ext *ext = (void *) mgmt;\n\n\t\tif (ieee80211_is_s1g_short_beacon(ext->frame_control))\n\t\t\tvariable = ext->u.s1g_short_beacon.variable;\n\t\telse\n\t\t\tvariable = ext->u.s1g_beacon.variable;\n\t}\n\n\tbaselen = (u8 *) variable - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\tparse_params.start = variable;\n\tparse_params.len = len - baselen;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(link->conf->chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (ieee80211_rx_status_to_khz(rx_status) !=\n\t    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tchan = chanctx_conf->def.chan;\n\trcu_read_unlock();\n\n\tif (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&\n\t    !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) &&\n\t    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {\n\t\tparse_params.bss = ifmgd->assoc_data->link[0].bss;\n\t\telems = ieee802_11_parse_elems_full(&parse_params);\n\t\tif (!elems)\n\t\t\treturn;\n\n\t\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\t\tif (elems->dtim_period)\n\t\t\tlink->u.mgd.dtim_period = elems->dtim_period;\n\t\tlink->u.mgd.have_beacon = true;\n\t\tifmgd->assoc_data->need_beacon = false;\n\t\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&\n\t\t    !ieee80211_is_s1g_beacon(hdr->frame_control)) {\n\t\t\tlink->conf->sync_tsf =\n\t\t\t\tle64_to_cpu(mgmt->u.beacon.timestamp);\n\t\t\tlink->conf->sync_device_ts =\n\t\t\t\trx_status->device_timestamp;\n\t\t\tlink->conf->sync_dtim_count = elems->dtim_count;\n\t\t}\n\n\t\tif (elems->mbssid_config_ie)\n\t\t\tbss_conf->profile_periodicity =\n\t\t\t\telems->mbssid_config_ie->profile_periodicity;\n\t\telse\n\t\t\tbss_conf->profile_periodicity = 0;\n\n\t\tif (elems->ext_capab_len >= 11 &&\n\t\t    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))\n\t\t\tbss_conf->ema_ap = true;\n\t\telse\n\t\t\tbss_conf->ema_ap = false;\n\n\t\t/* continue assoc process */\n\t\tifmgd->assoc_data->timeout = jiffies;\n\t\tifmgd->assoc_data->timeout_started = true;\n\t\trun_again(sdata, ifmgd->assoc_data->timeout);\n\t\tkfree(elems);\n\t\treturn;\n\t}\n\n\tif (!ifmgd->associated ||\n\t    !ieee80211_rx_our_beacon(bssid, link->conf->bss))\n\t\treturn;\n\tbssid = link->u.mgd.bssid;\n\n\tif (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))\n\t\tieee80211_handle_beacon_sig(link, ifmgd, bss_conf,\n\t\t\t\t\t    local, rx_status);\n\n\tif (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {\n\t\tmlme_dbg_ratelimited(sdata,\n\t\t\t\t     \"cancelling AP probe due to a received beacon\\n\");\n\t\tieee80211_reset_ap_probe(sdata);\n\t}\n\n\t/*\n\t * Push the beacon loss detection into the future since\n\t * we are processing a beacon from the AP just now.\n\t */\n\tieee80211_sta_reset_beacon_monitor(sdata);\n\n\t/* TODO: CRC urrently not calculated on S1G Beacon Compatibility\n\t * element (which carries the beacon interval). Don't forget to add a\n\t * bit to care_about_ies[] above if mac80211 is interested in a\n\t * changing S1G element.\n\t */\n\tif (!ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\tncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);\n\tparse_params.bss = link->conf->bss;\n\tparse_params.filter = care_about_ies;\n\tparse_params.crc = ncrc;\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems)\n\t\treturn;\n\tncrc = elems->crc;\n\n\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&\n\t    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {\n\t\tif (local->hw.conf.dynamic_ps_timeout > 0) {\n\t\t\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\t\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\n\t\t\t\tieee80211_hw_config(local,\n\t\t\t\t\t\t    IEEE80211_CONF_CHANGE_PS);\n\t\t\t}\n\t\t\tieee80211_send_nullfunc(local, sdata, false);\n\t\t} else if (!local->pspolling && sdata->u.mgd.powersave) {\n\t\t\tlocal->pspolling = true;\n\n\t\t\t/*\n\t\t\t * Here is assumed that the driver will be\n\t\t\t * able to send ps-poll frame and receive a\n\t\t\t * response even though power save mode is\n\t\t\t * enabled, but some drivers might require\n\t\t\t * to disable power save here. This needs\n\t\t\t * to be investigated.\n\t\t\t */\n\t\t\tieee80211_send_pspoll(local, sdata);\n\t\t}\n\t}\n\n\tif (sdata->vif.p2p ||\n\t    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {\n\t\tstruct ieee80211_p2p_noa_attr noa = {};\n\t\tint ret;\n\n\t\tret = cfg80211_get_p2p_attr(variable,\n\t\t\t\t\t    len - baselen,\n\t\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t\t    (u8 *) &noa, sizeof(noa));\n\t\tif (ret >= 2) {\n\t\t\tif (link->u.mgd.p2p_noa_index != noa.index) {\n\t\t\t\t/* valid noa_attr and index changed */\n\t\t\t\tlink->u.mgd.p2p_noa_index = noa.index;\n\t\t\t\tmemcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));\n\t\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\t\t/*\n\t\t\t\t * make sure we update all information, the CRC\n\t\t\t\t * mechanism doesn't look at P2P attributes.\n\t\t\t\t */\n\t\t\t\tlink->u.mgd.beacon_crc_valid = false;\n\t\t\t}\n\t\t} else if (link->u.mgd.p2p_noa_index != -1) {\n\t\t\t/* noa_attr not found and we had valid noa_attr before */\n\t\t\tlink->u.mgd.p2p_noa_index = -1;\n\t\t\tmemset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));\n\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\tlink->u.mgd.beacon_crc_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * Update beacon timing and dtim count on every beacon appearance. This\n\t * will allow the driver to use the most updated values. Do it before\n\t * comparing this one with last received beacon.\n\t * IMPORTANT: These parameters would possibly be out of sync by the time\n\t * the driver will use them. The synchronized view is currently\n\t * guaranteed only in certain callbacks.\n\t */\n\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&\n\t    !ieee80211_is_s1g_beacon(hdr->frame_control)) {\n\t\tlink->conf->sync_tsf =\n\t\t\tle64_to_cpu(mgmt->u.beacon.timestamp);\n\t\tlink->conf->sync_device_ts =\n\t\t\trx_status->device_timestamp;\n\t\tlink->conf->sync_dtim_count = elems->dtim_count;\n\t}\n\n\tif ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||\n\t    ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n\t\tgoto free;\n\tlink->u.mgd.beacon_crc = ncrc;\n\tlink->u.mgd.beacon_crc_valid = true;\n\n\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\tieee80211_sta_process_chanswitch(link, rx_status->mactime,\n\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t elems, true);\n\n\tif (!link->u.mgd.disable_wmm_tracking &&\n\t    ieee80211_sta_wmm_params(local, link, elems->wmm_param,\n\t\t\t\t     elems->wmm_param_len,\n\t\t\t\t     elems->mu_edca_param_set))\n\t\tchanged |= BSS_CHANGED_QOS;\n\n\t/*\n\t * If we haven't had a beacon before, tell the driver about the\n\t * DTIM period (and beacon timing if desired) now.\n\t */\n\tif (!link->u.mgd.have_beacon) {\n\t\t/* a few bogus AP send dtim_period = 0 or no TIM IE */\n\t\tbss_conf->dtim_period = elems->dtim_period ?: 1;\n\n\t\tchanged |= BSS_CHANGED_BEACON_INFO;\n\t\tlink->u.mgd.have_beacon = true;\n\n\t\tieee80211_recalc_ps(local);\n\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\tif (elems->erp_info) {\n\t\terp_valid = true;\n\t\terp_value = elems->erp_info[0];\n\t} else {\n\t\terp_valid = false;\n\t}\n\n\tif (!ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\tchanged |= ieee80211_handle_bss_capability(link,\n\t\t\t\tle16_to_cpu(mgmt->u.beacon.capab_info),\n\t\t\t\terp_valid, erp_value);\n\n\tsta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\tif (WARN_ON(!sta)) {\n\t\tgoto free;\n\t}\n\tlink_sta = rcu_dereference_protected(sta->link[link->link_id],\n\t\t\t\t\t     lockdep_is_held(&local->hw.wiphy->mtx));\n\tif (WARN_ON(!link_sta)) {\n\t\tgoto free;\n\t}\n\n\tif (WARN_ON(!link->conf->chanreq.oper.chan))\n\t\tgoto free;\n\n\tsband = local->hw.wiphy->bands[link->conf->chanreq.oper.chan->band];\n\n\tchanged |= ieee80211_recalc_twt_req(sdata, sband, link, link_sta, elems);\n\n\tif (ieee80211_config_bw(link, elems, true, &changed)) {\n\t\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t       WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t       true, deauth_buf);\n\t\tieee80211_report_disconnect(sdata, deauth_buf,\n\t\t\t\t\t    sizeof(deauth_buf), true,\n\t\t\t\t\t    WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t    false);\n\t\tgoto free;\n\t}\n\n\tif (elems->opmode_notif)\n\t\tieee80211_vht_handle_opmode(sdata, link_sta,\n\t\t\t\t\t    *elems->opmode_notif,\n\t\t\t\t\t    rx_status->band);\n\n\tchanged |= ieee80211_handle_pwr_constr(link, chan, mgmt,\n\t\t\t\t\t       elems->country_elem,\n\t\t\t\t\t       elems->country_elem_len,\n\t\t\t\t\t       elems->pwr_constr_elem,\n\t\t\t\t\t       elems->cisco_dtpc_elem);\n\n\tieee80211_ml_reconfiguration(sdata, elems);\n\tieee80211_process_adv_ttlm(sdata, elems,\n\t\t\t\t      le64_to_cpu(mgmt->u.beacon.timestamp));\n\n\tieee80211_link_info_change_notify(sdata, link, changed);\nfree:\n\tkfree(elems);\n}",
        "function_list": [
            "ieee80211_get_bssid"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {",
                "condition": [
                    "if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon && !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (baselen > len)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (!chanctx_conf)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (ieee80211_rx_status_to_khz(rx_status) != ieee80211_channel_to_khz(chanctx_conf->def.chan))"
                ]
            }
        ],
        "index": 75
    },
    {
        "var_name": "bssid",
        "function_name": "ieee80211_rx_mgmt_beacon",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 6255,
                "startColumn": 31,
                "endColumn": 36
            },
            "context": {
                "startLine": 6253,
                "endLine": 6257,
                "snippet": {
                    "text": "\t    !ieee80211_rx_our_beacon(bssid, link->conf->bss))"
                }
            }
        },
        "function_code": "static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n\t\t\t\t     struct ieee80211_hdr *hdr, size_t len,\n\t\t\t\t     struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;\n\tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n\tstruct ieee80211_mgmt *mgmt = (void *) hdr;\n\tsize_t baselen;\n\tstruct ieee802_11_elems *elems;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tstruct link_sta_info *link_sta;\n\tstruct sta_info *sta;\n\tu64 changed = 0;\n\tbool erp_valid;\n\tu8 erp_value = 0;\n\tu32 ncrc = 0;\n\tu8 *bssid, *variable = mgmt->u.beacon.variable;\n\tu8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.mode = link->u.mgd.conn.mode,\n\t\t.link_id = -1,\n\t\t.from_ap = true,\n\t};\n\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\t/* Process beacon from the current BSS */\n\tbssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n\t\tstruct ieee80211_ext *ext = (void *) mgmt;\n\n\t\tif (ieee80211_is_s1g_short_beacon(ext->frame_control))\n\t\t\tvariable = ext->u.s1g_short_beacon.variable;\n\t\telse\n\t\t\tvariable = ext->u.s1g_beacon.variable;\n\t}\n\n\tbaselen = (u8 *) variable - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\tparse_params.start = variable;\n\tparse_params.len = len - baselen;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(link->conf->chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (ieee80211_rx_status_to_khz(rx_status) !=\n\t    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tchan = chanctx_conf->def.chan;\n\trcu_read_unlock();\n\n\tif (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&\n\t    !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) &&\n\t    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {\n\t\tparse_params.bss = ifmgd->assoc_data->link[0].bss;\n\t\telems = ieee802_11_parse_elems_full(&parse_params);\n\t\tif (!elems)\n\t\t\treturn;\n\n\t\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\t\tif (elems->dtim_period)\n\t\t\tlink->u.mgd.dtim_period = elems->dtim_period;\n\t\tlink->u.mgd.have_beacon = true;\n\t\tifmgd->assoc_data->need_beacon = false;\n\t\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&\n\t\t    !ieee80211_is_s1g_beacon(hdr->frame_control)) {\n\t\t\tlink->conf->sync_tsf =\n\t\t\t\tle64_to_cpu(mgmt->u.beacon.timestamp);\n\t\t\tlink->conf->sync_device_ts =\n\t\t\t\trx_status->device_timestamp;\n\t\t\tlink->conf->sync_dtim_count = elems->dtim_count;\n\t\t}\n\n\t\tif (elems->mbssid_config_ie)\n\t\t\tbss_conf->profile_periodicity =\n\t\t\t\telems->mbssid_config_ie->profile_periodicity;\n\t\telse\n\t\t\tbss_conf->profile_periodicity = 0;\n\n\t\tif (elems->ext_capab_len >= 11 &&\n\t\t    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))\n\t\t\tbss_conf->ema_ap = true;\n\t\telse\n\t\t\tbss_conf->ema_ap = false;\n\n\t\t/* continue assoc process */\n\t\tifmgd->assoc_data->timeout = jiffies;\n\t\tifmgd->assoc_data->timeout_started = true;\n\t\trun_again(sdata, ifmgd->assoc_data->timeout);\n\t\tkfree(elems);\n\t\treturn;\n\t}\n\n\tif (!ifmgd->associated ||\n\t    !ieee80211_rx_our_beacon(bssid, link->conf->bss))\n\t\treturn;\n\tbssid = link->u.mgd.bssid;\n\n\tif (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))\n\t\tieee80211_handle_beacon_sig(link, ifmgd, bss_conf,\n\t\t\t\t\t    local, rx_status);\n\n\tif (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {\n\t\tmlme_dbg_ratelimited(sdata,\n\t\t\t\t     \"cancelling AP probe due to a received beacon\\n\");\n\t\tieee80211_reset_ap_probe(sdata);\n\t}\n\n\t/*\n\t * Push the beacon loss detection into the future since\n\t * we are processing a beacon from the AP just now.\n\t */\n\tieee80211_sta_reset_beacon_monitor(sdata);\n\n\t/* TODO: CRC urrently not calculated on S1G Beacon Compatibility\n\t * element (which carries the beacon interval). Don't forget to add a\n\t * bit to care_about_ies[] above if mac80211 is interested in a\n\t * changing S1G element.\n\t */\n\tif (!ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\tncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);\n\tparse_params.bss = link->conf->bss;\n\tparse_params.filter = care_about_ies;\n\tparse_params.crc = ncrc;\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems)\n\t\treturn;\n\tncrc = elems->crc;\n\n\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&\n\t    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {\n\t\tif (local->hw.conf.dynamic_ps_timeout > 0) {\n\t\t\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\t\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\n\t\t\t\tieee80211_hw_config(local,\n\t\t\t\t\t\t    IEEE80211_CONF_CHANGE_PS);\n\t\t\t}\n\t\t\tieee80211_send_nullfunc(local, sdata, false);\n\t\t} else if (!local->pspolling && sdata->u.mgd.powersave) {\n\t\t\tlocal->pspolling = true;\n\n\t\t\t/*\n\t\t\t * Here is assumed that the driver will be\n\t\t\t * able to send ps-poll frame and receive a\n\t\t\t * response even though power save mode is\n\t\t\t * enabled, but some drivers might require\n\t\t\t * to disable power save here. This needs\n\t\t\t * to be investigated.\n\t\t\t */\n\t\t\tieee80211_send_pspoll(local, sdata);\n\t\t}\n\t}\n\n\tif (sdata->vif.p2p ||\n\t    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {\n\t\tstruct ieee80211_p2p_noa_attr noa = {};\n\t\tint ret;\n\n\t\tret = cfg80211_get_p2p_attr(variable,\n\t\t\t\t\t    len - baselen,\n\t\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t\t    (u8 *) &noa, sizeof(noa));\n\t\tif (ret >= 2) {\n\t\t\tif (link->u.mgd.p2p_noa_index != noa.index) {\n\t\t\t\t/* valid noa_attr and index changed */\n\t\t\t\tlink->u.mgd.p2p_noa_index = noa.index;\n\t\t\t\tmemcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));\n\t\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\t\t/*\n\t\t\t\t * make sure we update all information, the CRC\n\t\t\t\t * mechanism doesn't look at P2P attributes.\n\t\t\t\t */\n\t\t\t\tlink->u.mgd.beacon_crc_valid = false;\n\t\t\t}\n\t\t} else if (link->u.mgd.p2p_noa_index != -1) {\n\t\t\t/* noa_attr not found and we had valid noa_attr before */\n\t\t\tlink->u.mgd.p2p_noa_index = -1;\n\t\t\tmemset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));\n\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\tlink->u.mgd.beacon_crc_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * Update beacon timing and dtim count on every beacon appearance. This\n\t * will allow the driver to use the most updated values. Do it before\n\t * comparing this one with last received beacon.\n\t * IMPORTANT: These parameters would possibly be out of sync by the time\n\t * the driver will use them. The synchronized view is currently\n\t * guaranteed only in certain callbacks.\n\t */\n\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&\n\t    !ieee80211_is_s1g_beacon(hdr->frame_control)) {\n\t\tlink->conf->sync_tsf =\n\t\t\tle64_to_cpu(mgmt->u.beacon.timestamp);\n\t\tlink->conf->sync_device_ts =\n\t\t\trx_status->device_timestamp;\n\t\tlink->conf->sync_dtim_count = elems->dtim_count;\n\t}\n\n\tif ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||\n\t    ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n\t\tgoto free;\n\tlink->u.mgd.beacon_crc = ncrc;\n\tlink->u.mgd.beacon_crc_valid = true;\n\n\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\tieee80211_sta_process_chanswitch(link, rx_status->mactime,\n\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t elems, true);\n\n\tif (!link->u.mgd.disable_wmm_tracking &&\n\t    ieee80211_sta_wmm_params(local, link, elems->wmm_param,\n\t\t\t\t     elems->wmm_param_len,\n\t\t\t\t     elems->mu_edca_param_set))\n\t\tchanged |= BSS_CHANGED_QOS;\n\n\t/*\n\t * If we haven't had a beacon before, tell the driver about the\n\t * DTIM period (and beacon timing if desired) now.\n\t */\n\tif (!link->u.mgd.have_beacon) {\n\t\t/* a few bogus AP send dtim_period = 0 or no TIM IE */\n\t\tbss_conf->dtim_period = elems->dtim_period ?: 1;\n\n\t\tchanged |= BSS_CHANGED_BEACON_INFO;\n\t\tlink->u.mgd.have_beacon = true;\n\n\t\tieee80211_recalc_ps(local);\n\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\tif (elems->erp_info) {\n\t\terp_valid = true;\n\t\terp_value = elems->erp_info[0];\n\t} else {\n\t\terp_valid = false;\n\t}\n\n\tif (!ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\tchanged |= ieee80211_handle_bss_capability(link,\n\t\t\t\tle16_to_cpu(mgmt->u.beacon.capab_info),\n\t\t\t\terp_valid, erp_value);\n\n\tsta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\tif (WARN_ON(!sta)) {\n\t\tgoto free;\n\t}\n\tlink_sta = rcu_dereference_protected(sta->link[link->link_id],\n\t\t\t\t\t     lockdep_is_held(&local->hw.wiphy->mtx));\n\tif (WARN_ON(!link_sta)) {\n\t\tgoto free;\n\t}\n\n\tif (WARN_ON(!link->conf->chanreq.oper.chan))\n\t\tgoto free;\n\n\tsband = local->hw.wiphy->bands[link->conf->chanreq.oper.chan->band];\n\n\tchanged |= ieee80211_recalc_twt_req(sdata, sband, link, link_sta, elems);\n\n\tif (ieee80211_config_bw(link, elems, true, &changed)) {\n\t\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t       WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t       true, deauth_buf);\n\t\tieee80211_report_disconnect(sdata, deauth_buf,\n\t\t\t\t\t    sizeof(deauth_buf), true,\n\t\t\t\t\t    WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t    false);\n\t\tgoto free;\n\t}\n\n\tif (elems->opmode_notif)\n\t\tieee80211_vht_handle_opmode(sdata, link_sta,\n\t\t\t\t\t    *elems->opmode_notif,\n\t\t\t\t\t    rx_status->band);\n\n\tchanged |= ieee80211_handle_pwr_constr(link, chan, mgmt,\n\t\t\t\t\t       elems->country_elem,\n\t\t\t\t\t       elems->country_elem_len,\n\t\t\t\t\t       elems->pwr_constr_elem,\n\t\t\t\t\t       elems->cisco_dtpc_elem);\n\n\tieee80211_ml_reconfiguration(sdata, elems);\n\tieee80211_process_adv_ttlm(sdata, elems,\n\t\t\t\t      le64_to_cpu(mgmt->u.beacon.timestamp));\n\n\tieee80211_link_info_change_notify(sdata, link, changed);\nfree:\n\tkfree(elems);\n}",
        "function_list": [
            "ieee80211_get_bssid"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t    !ieee80211_rx_our_beacon(bssid, link->conf->bss))",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (baselen > len)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (!chanctx_conf)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (ieee80211_rx_status_to_khz(rx_status) != ieee80211_channel_to_khz(chanctx_conf->def.chan))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon && !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) && ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss))",
                    "if (!elems)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon && !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) && ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss))"
                ]
            }
        ],
        "index": 76
    },
    {
        "var_name": "sta",
        "function_name": "ieee80211_rx_mgmt_beacon",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 6411,
                "startColumn": 39,
                "endColumn": 42
            },
            "context": {
                "startLine": 6409,
                "endLine": 6413,
                "snippet": {
                    "text": "\tlink_sta = rcu_dereference_protected(sta->link[link->link_id],"
                }
            }
        },
        "function_code": "static void ieee80211_rx_mgmt_beacon(struct ieee80211_link_data *link,\n\t\t\t\t     struct ieee80211_hdr *hdr, size_t len,\n\t\t\t\t     struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_bss_conf *bss_conf = &sdata->vif.bss_conf;\n\tstruct ieee80211_vif_cfg *vif_cfg = &sdata->vif.cfg;\n\tstruct ieee80211_mgmt *mgmt = (void *) hdr;\n\tsize_t baselen;\n\tstruct ieee802_11_elems *elems;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tstruct link_sta_info *link_sta;\n\tstruct sta_info *sta;\n\tu64 changed = 0;\n\tbool erp_valid;\n\tu8 erp_value = 0;\n\tu32 ncrc = 0;\n\tu8 *bssid, *variable = mgmt->u.beacon.variable;\n\tu8 deauth_buf[IEEE80211_DEAUTH_FRAME_LEN];\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.mode = link->u.mgd.conn.mode,\n\t\t.link_id = -1,\n\t\t.from_ap = true,\n\t};\n\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\t/* Process beacon from the current BSS */\n\tbssid = ieee80211_get_bssid(hdr, len, sdata->vif.type);\n\tif (ieee80211_is_s1g_beacon(mgmt->frame_control)) {\n\t\tstruct ieee80211_ext *ext = (void *) mgmt;\n\n\t\tif (ieee80211_is_s1g_short_beacon(ext->frame_control))\n\t\t\tvariable = ext->u.s1g_short_beacon.variable;\n\t\telse\n\t\t\tvariable = ext->u.s1g_beacon.variable;\n\t}\n\n\tbaselen = (u8 *) variable - (u8 *) mgmt;\n\tif (baselen > len)\n\t\treturn;\n\n\tparse_params.start = variable;\n\tparse_params.len = len - baselen;\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(link->conf->chanctx_conf);\n\tif (!chanctx_conf) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (ieee80211_rx_status_to_khz(rx_status) !=\n\t    ieee80211_channel_to_khz(chanctx_conf->def.chan)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tchan = chanctx_conf->def.chan;\n\trcu_read_unlock();\n\n\tif (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon &&\n\t    !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) &&\n\t    ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss)) {\n\t\tparse_params.bss = ifmgd->assoc_data->link[0].bss;\n\t\telems = ieee802_11_parse_elems_full(&parse_params);\n\t\tif (!elems)\n\t\t\treturn;\n\n\t\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\t\tif (elems->dtim_period)\n\t\t\tlink->u.mgd.dtim_period = elems->dtim_period;\n\t\tlink->u.mgd.have_beacon = true;\n\t\tifmgd->assoc_data->need_beacon = false;\n\t\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&\n\t\t    !ieee80211_is_s1g_beacon(hdr->frame_control)) {\n\t\t\tlink->conf->sync_tsf =\n\t\t\t\tle64_to_cpu(mgmt->u.beacon.timestamp);\n\t\t\tlink->conf->sync_device_ts =\n\t\t\t\trx_status->device_timestamp;\n\t\t\tlink->conf->sync_dtim_count = elems->dtim_count;\n\t\t}\n\n\t\tif (elems->mbssid_config_ie)\n\t\t\tbss_conf->profile_periodicity =\n\t\t\t\telems->mbssid_config_ie->profile_periodicity;\n\t\telse\n\t\t\tbss_conf->profile_periodicity = 0;\n\n\t\tif (elems->ext_capab_len >= 11 &&\n\t\t    (elems->ext_capab[10] & WLAN_EXT_CAPA11_EMA_SUPPORT))\n\t\t\tbss_conf->ema_ap = true;\n\t\telse\n\t\t\tbss_conf->ema_ap = false;\n\n\t\t/* continue assoc process */\n\t\tifmgd->assoc_data->timeout = jiffies;\n\t\tifmgd->assoc_data->timeout_started = true;\n\t\trun_again(sdata, ifmgd->assoc_data->timeout);\n\t\tkfree(elems);\n\t\treturn;\n\t}\n\n\tif (!ifmgd->associated ||\n\t    !ieee80211_rx_our_beacon(bssid, link->conf->bss))\n\t\treturn;\n\tbssid = link->u.mgd.bssid;\n\n\tif (!(rx_status->flag & RX_FLAG_NO_SIGNAL_VAL))\n\t\tieee80211_handle_beacon_sig(link, ifmgd, bss_conf,\n\t\t\t\t\t    local, rx_status);\n\n\tif (ifmgd->flags & IEEE80211_STA_CONNECTION_POLL) {\n\t\tmlme_dbg_ratelimited(sdata,\n\t\t\t\t     \"cancelling AP probe due to a received beacon\\n\");\n\t\tieee80211_reset_ap_probe(sdata);\n\t}\n\n\t/*\n\t * Push the beacon loss detection into the future since\n\t * we are processing a beacon from the AP just now.\n\t */\n\tieee80211_sta_reset_beacon_monitor(sdata);\n\n\t/* TODO: CRC urrently not calculated on S1G Beacon Compatibility\n\t * element (which carries the beacon interval). Don't forget to add a\n\t * bit to care_about_ies[] above if mac80211 is interested in a\n\t * changing S1G element.\n\t */\n\tif (!ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\tncrc = crc32_be(0, (void *)&mgmt->u.beacon.beacon_int, 4);\n\tparse_params.bss = link->conf->bss;\n\tparse_params.filter = care_about_ies;\n\tparse_params.crc = ncrc;\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems)\n\t\treturn;\n\tncrc = elems->crc;\n\n\tif (ieee80211_hw_check(&local->hw, PS_NULLFUNC_STACK) &&\n\t    ieee80211_check_tim(elems->tim, elems->tim_len, vif_cfg->aid)) {\n\t\tif (local->hw.conf.dynamic_ps_timeout > 0) {\n\t\t\tif (local->hw.conf.flags & IEEE80211_CONF_PS) {\n\t\t\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_PS;\n\t\t\t\tieee80211_hw_config(local,\n\t\t\t\t\t\t    IEEE80211_CONF_CHANGE_PS);\n\t\t\t}\n\t\t\tieee80211_send_nullfunc(local, sdata, false);\n\t\t} else if (!local->pspolling && sdata->u.mgd.powersave) {\n\t\t\tlocal->pspolling = true;\n\n\t\t\t/*\n\t\t\t * Here is assumed that the driver will be\n\t\t\t * able to send ps-poll frame and receive a\n\t\t\t * response even though power save mode is\n\t\t\t * enabled, but some drivers might require\n\t\t\t * to disable power save here. This needs\n\t\t\t * to be investigated.\n\t\t\t */\n\t\t\tieee80211_send_pspoll(local, sdata);\n\t\t}\n\t}\n\n\tif (sdata->vif.p2p ||\n\t    sdata->vif.driver_flags & IEEE80211_VIF_GET_NOA_UPDATE) {\n\t\tstruct ieee80211_p2p_noa_attr noa = {};\n\t\tint ret;\n\n\t\tret = cfg80211_get_p2p_attr(variable,\n\t\t\t\t\t    len - baselen,\n\t\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t\t    (u8 *) &noa, sizeof(noa));\n\t\tif (ret >= 2) {\n\t\t\tif (link->u.mgd.p2p_noa_index != noa.index) {\n\t\t\t\t/* valid noa_attr and index changed */\n\t\t\t\tlink->u.mgd.p2p_noa_index = noa.index;\n\t\t\t\tmemcpy(&bss_conf->p2p_noa_attr, &noa, sizeof(noa));\n\t\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\t\t/*\n\t\t\t\t * make sure we update all information, the CRC\n\t\t\t\t * mechanism doesn't look at P2P attributes.\n\t\t\t\t */\n\t\t\t\tlink->u.mgd.beacon_crc_valid = false;\n\t\t\t}\n\t\t} else if (link->u.mgd.p2p_noa_index != -1) {\n\t\t\t/* noa_attr not found and we had valid noa_attr before */\n\t\t\tlink->u.mgd.p2p_noa_index = -1;\n\t\t\tmemset(&bss_conf->p2p_noa_attr, 0, sizeof(bss_conf->p2p_noa_attr));\n\t\t\tchanged |= BSS_CHANGED_P2P_PS;\n\t\t\tlink->u.mgd.beacon_crc_valid = false;\n\t\t}\n\t}\n\n\t/*\n\t * Update beacon timing and dtim count on every beacon appearance. This\n\t * will allow the driver to use the most updated values. Do it before\n\t * comparing this one with last received beacon.\n\t * IMPORTANT: These parameters would possibly be out of sync by the time\n\t * the driver will use them. The synchronized view is currently\n\t * guaranteed only in certain callbacks.\n\t */\n\tif (ieee80211_hw_check(&local->hw, TIMING_BEACON_ONLY) &&\n\t    !ieee80211_is_s1g_beacon(hdr->frame_control)) {\n\t\tlink->conf->sync_tsf =\n\t\t\tle64_to_cpu(mgmt->u.beacon.timestamp);\n\t\tlink->conf->sync_device_ts =\n\t\t\trx_status->device_timestamp;\n\t\tlink->conf->sync_dtim_count = elems->dtim_count;\n\t}\n\n\tif ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) ||\n\t    ieee80211_is_s1g_short_beacon(mgmt->frame_control))\n\t\tgoto free;\n\tlink->u.mgd.beacon_crc = ncrc;\n\tlink->u.mgd.beacon_crc_valid = true;\n\n\tieee80211_rx_bss_info(link, mgmt, len, rx_status);\n\n\tieee80211_sta_process_chanswitch(link, rx_status->mactime,\n\t\t\t\t\t rx_status->device_timestamp,\n\t\t\t\t\t elems, true);\n\n\tif (!link->u.mgd.disable_wmm_tracking &&\n\t    ieee80211_sta_wmm_params(local, link, elems->wmm_param,\n\t\t\t\t     elems->wmm_param_len,\n\t\t\t\t     elems->mu_edca_param_set))\n\t\tchanged |= BSS_CHANGED_QOS;\n\n\t/*\n\t * If we haven't had a beacon before, tell the driver about the\n\t * DTIM period (and beacon timing if desired) now.\n\t */\n\tif (!link->u.mgd.have_beacon) {\n\t\t/* a few bogus AP send dtim_period = 0 or no TIM IE */\n\t\tbss_conf->dtim_period = elems->dtim_period ?: 1;\n\n\t\tchanged |= BSS_CHANGED_BEACON_INFO;\n\t\tlink->u.mgd.have_beacon = true;\n\n\t\tieee80211_recalc_ps(local);\n\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\tif (elems->erp_info) {\n\t\terp_valid = true;\n\t\terp_value = elems->erp_info[0];\n\t} else {\n\t\terp_valid = false;\n\t}\n\n\tif (!ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\tchanged |= ieee80211_handle_bss_capability(link,\n\t\t\t\tle16_to_cpu(mgmt->u.beacon.capab_info),\n\t\t\t\terp_valid, erp_value);\n\n\tsta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\tif (WARN_ON(!sta)) {\n\t\tgoto free;\n\t}\n\tlink_sta = rcu_dereference_protected(sta->link[link->link_id],\n\t\t\t\t\t     lockdep_is_held(&local->hw.wiphy->mtx));\n\tif (WARN_ON(!link_sta)) {\n\t\tgoto free;\n\t}\n\n\tif (WARN_ON(!link->conf->chanreq.oper.chan))\n\t\tgoto free;\n\n\tsband = local->hw.wiphy->bands[link->conf->chanreq.oper.chan->band];\n\n\tchanged |= ieee80211_recalc_twt_req(sdata, sband, link, link_sta, elems);\n\n\tif (ieee80211_config_bw(link, elems, true, &changed)) {\n\t\tieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t       WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t       true, deauth_buf);\n\t\tieee80211_report_disconnect(sdata, deauth_buf,\n\t\t\t\t\t    sizeof(deauth_buf), true,\n\t\t\t\t\t    WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t    false);\n\t\tgoto free;\n\t}\n\n\tif (elems->opmode_notif)\n\t\tieee80211_vht_handle_opmode(sdata, link_sta,\n\t\t\t\t\t    *elems->opmode_notif,\n\t\t\t\t\t    rx_status->band);\n\n\tchanged |= ieee80211_handle_pwr_constr(link, chan, mgmt,\n\t\t\t\t\t       elems->country_elem,\n\t\t\t\t\t       elems->country_elem_len,\n\t\t\t\t\t       elems->pwr_constr_elem,\n\t\t\t\t\t       elems->cisco_dtpc_elem);\n\n\tieee80211_ml_reconfiguration(sdata, elems);\n\tieee80211_process_adv_ttlm(sdata, elems,\n\t\t\t\t      le64_to_cpu(mgmt->u.beacon.timestamp));\n\n\tieee80211_link_info_change_notify(sdata, link, changed);\nfree:\n\tkfree(elems);\n}",
        "function_list": [
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tlink_sta = rcu_dereference_protected(sta->link[link->link_id],",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (baselen > len)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (!chanctx_conf)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (ieee80211_rx_status_to_khz(rx_status) != ieee80211_channel_to_khz(chanctx_conf->def.chan))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon && !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) && ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss))",
                    "if (!elems)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (ifmgd->assoc_data && ifmgd->assoc_data->need_beacon && !WARN_ON(ieee80211_vif_is_mld(&sdata->vif)) && ieee80211_rx_our_beacon(bssid, ifmgd->assoc_data->link[0].bss))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (!ifmgd->associated || !ieee80211_rx_our_beacon(bssid, link->conf->bss))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (!elems)"
                ]
            },
            {
                "text": "goto free;",
                "condition": [
                    "if ((ncrc == link->u.mgd.beacon_crc && link->u.mgd.beacon_crc_valid) || ieee80211_is_s1g_short_beacon(mgmt->frame_control))"
                ]
            },
            {
                "text": "goto free;",
                "condition": [
                    "if (WARN_ON(!sta))"
                ]
            }
        ],
        "index": 77
    },
    {
        "var_name": "elems",
        "function_name": "ieee80211_rx_mgmt_assoc_resp",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 5531,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 5529,
                "endLine": 5533,
                "snippet": {
                    "text": "\tkfree(elems);"
                }
            }
        },
        "function_code": "static void ieee80211_rx_mgmt_assoc_resp(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t struct ieee80211_mgmt *mgmt,\n\t\t\t\t\t size_t len)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;\n\tu16 capab_info, status_code, aid;\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.bss = NULL,\n\t\t.link_id = -1,\n\t\t.from_ap = true,\n\t};\n\tstruct ieee802_11_elems *elems;\n\tint ac;\n\tconst u8 *elem_start;\n\tunsigned int elem_len;\n\tbool reassoc;\n\tstruct ieee80211_event event = {\n\t\t.type = MLME_EVENT,\n\t\t.u.mlme.data = ASSOC_EVENT,\n\t};\n\tstruct ieee80211_prep_tx_info info = {};\n\tstruct cfg80211_rx_assoc_resp_data resp = {\n\t\t.uapsd_queues = -1,\n\t};\n\tu8 ap_mld_addr[ETH_ALEN] __aligned(2);\n\tunsigned int link_id;\n\n\tlockdep_assert_wiphy(sdata->local->hw.wiphy);\n\n\tif (!assoc_data)\n\t\treturn;\n\n\tparse_params.mode =\n\t\tassoc_data->link[assoc_data->assoc_link_id].conn.mode;\n\n\tif (!ether_addr_equal(assoc_data->ap_addr, mgmt->bssid) ||\n\t    !ether_addr_equal(assoc_data->ap_addr, mgmt->sa))\n\t\treturn;\n\n\t/*\n\t * AssocResp and ReassocResp have identical structure, so process both\n\t * of them in this function.\n\t */\n\n\tif (len < 24 + 6)\n\t\treturn;\n\n\treassoc = ieee80211_is_reassoc_resp(mgmt->frame_control);\n\tcapab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);\n\tstatus_code = le16_to_cpu(mgmt->u.assoc_resp.status_code);\n\tif (assoc_data->s1g)\n\t\telem_start = mgmt->u.s1g_assoc_resp.variable;\n\telse\n\t\telem_start = mgmt->u.assoc_resp.variable;\n\n\t/*\n\t * Note: this may not be perfect, AP might misbehave - if\n\t * anyone needs to rely on perfect complete notification\n\t * with the exact right subtype, then we need to track what\n\t * we actually transmitted.\n\t */\n\tinfo.subtype = reassoc ? IEEE80211_STYPE_REASSOC_REQ :\n\t\t\t\t IEEE80211_STYPE_ASSOC_REQ;\n\n\tif (assoc_data->fils_kek_len &&\n\t    fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)\n\t\treturn;\n\n\telem_len = len - (elem_start - (u8 *)mgmt);\n\tparse_params.start = elem_start;\n\tparse_params.len = elem_len;\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems)\n\t\tgoto notify_driver;\n\n\tif (elems->aid_resp)\n\t\taid = le16_to_cpu(elems->aid_resp->aid);\n\telse if (assoc_data->s1g)\n\t\taid = 0; /* TODO */\n\telse\n\t\taid = le16_to_cpu(mgmt->u.assoc_resp.aid);\n\n\t/*\n\t * The 5 MSB of the AID field are reserved\n\t * (802.11-2016 9.4.1.8 AID field)\n\t */\n\taid &= 0x7ff;\n\n\tsdata_info(sdata,\n\t\t   \"RX %sssocResp from %pM (capab=0x%x status=%d aid=%d)\\n\",\n\t\t   reassoc ? \"Rea\" : \"A\", assoc_data->ap_addr,\n\t\t   capab_info, status_code, (u16)(aid & ~(BIT(15) | BIT(14))));\n\n\tifmgd->broken_ap = false;\n\n\tif (status_code == WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY &&\n\t    elems->timeout_int &&\n\t    elems->timeout_int->type == WLAN_TIMEOUT_ASSOC_COMEBACK) {\n\t\tu32 tu, ms;\n\n\t\tcfg80211_assoc_comeback(sdata->dev, assoc_data->ap_addr,\n\t\t\t\t\tle32_to_cpu(elems->timeout_int->value));\n\n\t\ttu = le32_to_cpu(elems->timeout_int->value);\n\t\tms = tu * 1024 / 1000;\n\t\tsdata_info(sdata,\n\t\t\t   \"%pM rejected association temporarily; comeback duration %u TU (%u ms)\\n\",\n\t\t\t   assoc_data->ap_addr, tu, ms);\n\t\tassoc_data->timeout = jiffies + msecs_to_jiffies(ms);\n\t\tassoc_data->timeout_started = true;\n\t\tassoc_data->comeback = true;\n\t\tif (ms > IEEE80211_ASSOC_TIMEOUT)\n\t\t\trun_again(sdata, assoc_data->timeout);\n\t\tgoto notify_driver;\n\t}\n\n\tif (status_code != WLAN_STATUS_SUCCESS) {\n\t\tsdata_info(sdata, \"%pM denied association (code=%d)\\n\",\n\t\t\t   assoc_data->ap_addr, status_code);\n\t\tevent.u.mlme.status = MLME_DENIED;\n\t\tevent.u.mlme.reason = status_code;\n\t\tdrv_event_callback(sdata->local, sdata, &event);\n\t} else {\n\t\tif (aid == 0 || aid > IEEE80211_MAX_AID) {\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"invalid AID value %d (out of range), turn off PS\\n\",\n\t\t\t\t   aid);\n\t\t\taid = 0;\n\t\t\tifmgd->broken_ap = true;\n\t\t}\n\n\t\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\t\tstruct ieee80211_mle_basic_common_info *common;\n\n\t\t\tif (!elems->ml_basic) {\n\t\t\t\tsdata_info(sdata,\n\t\t\t\t\t   \"MLO association with %pM but no (basic) multi-link element in response!\\n\",\n\t\t\t\t\t   assoc_data->ap_addr);\n\t\t\t\tgoto abandon_assoc;\n\t\t\t}\n\n\t\t\tcommon = (void *)elems->ml_basic->variable;\n\n\t\t\tif (memcmp(assoc_data->ap_addr,\n\t\t\t\t   common->mld_mac_addr, ETH_ALEN)) {\n\t\t\t\tsdata_info(sdata,\n\t\t\t\t\t   \"AP MLD MAC address mismatch: got %pM expected %pM\\n\",\n\t\t\t\t\t   common->mld_mac_addr,\n\t\t\t\t\t   assoc_data->ap_addr);\n\t\t\t\tgoto abandon_assoc;\n\t\t\t}\n\n\t\t\tsdata->vif.cfg.eml_cap =\n\t\t\t\tieee80211_mle_get_eml_cap((const void *)elems->ml_basic);\n\t\t\tsdata->vif.cfg.eml_med_sync_delay =\n\t\t\t\tieee80211_mle_get_eml_med_sync_delay((const void *)elems->ml_basic);\n\t\t\tsdata->vif.cfg.mld_capa_op =\n\t\t\t\tieee80211_mle_get_mld_capa_op((const void *)elems->ml_basic);\n\t\t}\n\n\t\tsdata->vif.cfg.aid = aid;\n\n\t\tif (!ieee80211_assoc_success(sdata, mgmt, elems,\n\t\t\t\t\t     elem_start, elem_len)) {\n\t\t\t/* oops -- internal error -- send timeout for now */\n\t\t\tieee80211_destroy_assoc_data(sdata, ASSOC_TIMEOUT);\n\t\t\tgoto notify_driver;\n\t\t}\n\t\tevent.u.mlme.status = MLME_SUCCESS;\n\t\tdrv_event_callback(sdata->local, sdata, &event);\n\t\tsdata_info(sdata, \"associated\\n\");\n\n\t\tinfo.success = 1;\n\t}\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tstruct ieee80211_link_data *link;\n\n\t\tif (!assoc_data->link[link_id].bss)\n\t\t\tcontinue;\n\n\t\tresp.links[link_id].bss = assoc_data->link[link_id].bss;\n\t\tether_addr_copy(resp.links[link_id].addr,\n\t\t\t\tassoc_data->link[link_id].addr);\n\t\tresp.links[link_id].status = assoc_data->link[link_id].status;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\t/* get uapsd queues configuration - same for all links */\n\t\tresp.uapsd_queues = 0;\n\t\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t\tif (link->tx_conf[ac].uapsd)\n\t\t\t\tresp.uapsd_queues |= ieee80211_ac_to_qos_mask[ac];\n\t}\n\n\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\tether_addr_copy(ap_mld_addr, sdata->vif.cfg.ap_addr);\n\t\tresp.ap_mld_addr = ap_mld_addr;\n\t}\n\n\tieee80211_destroy_assoc_data(sdata,\n\t\t\t\t     status_code == WLAN_STATUS_SUCCESS ?\n\t\t\t\t\tASSOC_SUCCESS :\n\t\t\t\t\tASSOC_REJECTED);\n\n\tresp.buf = (u8 *)mgmt;\n\tresp.len = len;\n\tresp.req_ies = ifmgd->assoc_req_ies;\n\tresp.req_ies_len = ifmgd->assoc_req_ies_len;\n\tcfg80211_rx_assoc_resp(sdata->dev, &resp);\nnotify_driver:\n\tdrv_mgd_complete_tx(sdata->local, sdata, &info);\n\tkfree(elems);\n\treturn;\nabandon_assoc:\n\tieee80211_destroy_assoc_data(sdata, ASSOC_ABANDON);\n\tgoto notify_driver;\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree(elems);",
                "condition": [
                    "goto notify_driver"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (!assoc_data)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (!ether_addr_equal(assoc_data->ap_addr, mgmt->bssid) || !ether_addr_equal(assoc_data->ap_addr, mgmt->sa))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (len < 24 + 6)"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (assoc_data->fils_kek_len && fils_decrypt_assoc_resp(sdata, (u8 *)mgmt, &len, assoc_data) < 0)"
                ]
            },
            {
                "text": "goto abandon_assoc;",
                "condition": [
                    "if(!(status_code != WLAN_STATUS_SUCCESS))",
                    "if (ieee80211_vif_is_mld(&sdata->vif))",
                    "if (!elems->ml_basic)"
                ]
            },
            {
                "text": "goto abandon_assoc;",
                "condition": [
                    "if(!(status_code != WLAN_STATUS_SUCCESS))",
                    "if (ieee80211_vif_is_mld(&sdata->vif))",
                    "if (memcmp(assoc_data->ap_addr, common->mld_mac_addr, ETH_ALEN))"
                ]
            }
        ],
        "index": 78
    },
    {
        "var_name": "sta",
        "function_name": "ieee80211_assoc_success",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 5163,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 5161,
                "endLine": 5165,
                "snippet": {
                    "text": "\tsta->sta.spp_amsdu = assoc_data->spp_amsdu;"
                }
            }
        },
        "function_code": "static bool ieee80211_assoc_success(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    struct ieee80211_mgmt *mgmt,\n\t\t\t\t    struct ieee802_11_elems *elems,\n\t\t\t\t    const u8 *elem_start, unsigned int elem_len)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = ifmgd->assoc_data;\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned int link_id;\n\tstruct sta_info *sta;\n\tu64 changed[IEEE80211_MLD_MAX_NUM_LINKS] = {};\n\tu16 valid_links = 0, dormant_links = 0;\n\tint err;\n\n\tlockdep_assert_wiphy(sdata->local->hw.wiphy);\n\t/*\n\t * station info was already allocated and inserted before\n\t * the association and should be available to us\n\t */\n\tsta = sta_info_get(sdata, assoc_data->ap_addr);\n\tif (WARN_ON(!sta))\n\t\tgoto out_err;\n\n\tsta->sta.spp_amsdu = assoc_data->spp_amsdu;\n\n\tif (ieee80211_vif_is_mld(&sdata->vif)) {\n\t\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\t\tif (!assoc_data->link[link_id].bss)\n\t\t\t\tcontinue;\n\n\t\t\tvalid_links |= BIT(link_id);\n\t\t\tif (assoc_data->link[link_id].disabled)\n\t\t\t\tdormant_links |= BIT(link_id);\n\n\t\t\tif (link_id != assoc_data->assoc_link_id) {\n\t\t\t\terr = ieee80211_sta_allocate_link(sta, link_id);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\tieee80211_vif_set_links(sdata, valid_links, dormant_links);\n\t}\n\n\tfor (link_id = 0; link_id < IEEE80211_MLD_MAX_NUM_LINKS; link_id++) {\n\t\tstruct cfg80211_bss *cbss = assoc_data->link[link_id].bss;\n\t\tstruct ieee80211_link_data *link;\n\t\tstruct link_sta_info *link_sta;\n\n\t\tif (!cbss)\n\t\t\tcontinue;\n\n\t\tlink = sdata_dereference(sdata->link[link_id], sdata);\n\t\tif (WARN_ON(!link))\n\t\t\tgoto out_err;\n\n\t\tif (ieee80211_vif_is_mld(&sdata->vif))\n\t\t\tlink_info(link,\n\t\t\t\t  \"local address %pM, AP link address %pM%s\\n\",\n\t\t\t\t  link->conf->addr,\n\t\t\t\t  assoc_data->link[link_id].bss->bssid,\n\t\t\t\t  link_id == assoc_data->assoc_link_id ?\n\t\t\t\t\t\" (assoc)\" : \"\");\n\n\t\tlink_sta = rcu_dereference_protected(sta->link[link_id],\n\t\t\t\t\t\t     lockdep_is_held(&local->hw.wiphy->mtx));\n\t\tif (WARN_ON(!link_sta))\n\t\t\tgoto out_err;\n\n\t\tif (!link->u.mgd.have_beacon) {\n\t\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\t\trcu_read_lock();\n\t\t\ties = rcu_dereference(cbss->beacon_ies);\n\t\t\tif (ies)\n\t\t\t\tlink->u.mgd.have_beacon = true;\n\t\t\telse\n\t\t\t\ties = rcu_dereference(cbss->ies);\n\t\t\tieee80211_get_dtim(ies,\n\t\t\t\t\t   &link->conf->sync_dtim_count,\n\t\t\t\t\t   &link->u.mgd.dtim_period);\n\t\t\tlink->conf->beacon_int = cbss->beacon_interval;\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tlink->conf->dtim_period = link->u.mgd.dtim_period ?: 1;\n\n\t\tif (link_id != assoc_data->assoc_link_id) {\n\t\t\tlink->u.mgd.conn = assoc_data->link[link_id].conn;\n\n\t\t\terr = ieee80211_prep_channel(sdata, link, link_id, cbss,\n\t\t\t\t\t\t     true, &link->u.mgd.conn);\n\t\t\tif (err) {\n\t\t\t\tlink_info(link, \"prep_channel failed\\n\");\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t}\n\n\t\terr = ieee80211_mgd_setup_link_sta(link, sta, link_sta,\n\t\t\t\t\t\t   assoc_data->link[link_id].bss);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (!ieee80211_assoc_config_link(link, link_sta,\n\t\t\t\t\t\t assoc_data->link[link_id].bss,\n\t\t\t\t\t\t mgmt, elem_start, elem_len,\n\t\t\t\t\t\t &changed[link_id]))\n\t\t\tgoto out_err;\n\n\t\tif (assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS) {\n\t\t\tvalid_links &= ~BIT(link_id);\n\t\t\tieee80211_sta_remove_link(sta, link_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (link_id != assoc_data->assoc_link_id) {\n\t\t\terr = ieee80211_sta_activate_link(sta, link_id);\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\t/* links might have changed due to rejected ones, set them again */\n\tieee80211_vif_set_links(sdata, valid_links, dormant_links);\n\n\trate_control_rate_init(sta);\n\n\tif (ifmgd->flags & IEEE80211_STA_MFP_ENABLED) {\n\t\tset_sta_flag(sta, WLAN_STA_MFP);\n\t\tsta->sta.mfp = true;\n\t} else {\n\t\tsta->sta.mfp = false;\n\t}\n\n\tieee80211_sta_set_max_amsdu_subframes(sta, elems->ext_capab,\n\t\t\t\t\t      elems->ext_capab_len);\n\n\tsta->sta.wme = (elems->wmm_param || elems->s1g_capab) &&\n\t\t       local->hw.queues >= IEEE80211_NUM_ACS;\n\n\terr = sta_info_move_state(sta, IEEE80211_STA_ASSOC);\n\tif (!err && !(ifmgd->flags & IEEE80211_STA_CONTROL_PORT))\n\t\terr = sta_info_move_state(sta, IEEE80211_STA_AUTHORIZED);\n\tif (err) {\n\t\tsdata_info(sdata,\n\t\t\t   \"failed to move station %pM to desired state\\n\",\n\t\t\t   sta->sta.addr);\n\t\tWARN_ON(__sta_info_destroy(sta));\n\t\tgoto out_err;\n\t}\n\n\tif (sdata->wdev.use_4addr)\n\t\tdrv_sta_set_4addr(local, sdata, &sta->sta, true);\n\n\tieee80211_set_associated(sdata, assoc_data, changed);\n\n\t/*\n\t * If we're using 4-addr mode, let the AP know that we're\n\t * doing so, so that it can create the STA VLAN on its side\n\t */\n\tif (ifmgd->use_4addr)\n\t\tieee80211_send_4addr_nullfunc(local, sdata);\n\n\t/*\n\t * Start timer to probe the connection to the AP now.\n\t * Also start the timer that will detect beacon loss.\n\t */\n\tieee80211_sta_reset_beacon_monitor(sdata);\n\tieee80211_sta_reset_conn_monitor(sdata);\n\n\treturn true;\nout_err:\n\teth_zero_addr(sdata->vif.cfg.ap_addr);\n\treturn false;\n}",
        "function_list": [
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tsta->sta.spp_amsdu = assoc_data->spp_amsdu;",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto out_err;",
                "condition": [
                    "if (WARN_ON(!sta))"
                ]
            }
        ],
        "index": 79
    },
    {
        "var_name": "bss_ies",
        "function_name": "ieee80211_assoc_config_link",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 4616,
                "startColumn": 8,
                "endColumn": 15
            },
            "context": {
                "startLine": 4614,
                "endLine": 4618,
                "snippet": {
                    "text": "\tkfree(bss_ies);"
                }
            }
        },
        "function_code": "static bool ieee80211_assoc_config_link(struct ieee80211_link_data *link,\n\t\t\t\t\tstruct link_sta_info *link_sta,\n\t\t\t\t\tstruct cfg80211_bss *cbss,\n\t\t\t\t\tstruct ieee80211_mgmt *mgmt,\n\t\t\t\t\tconst u8 *elem_start,\n\t\t\t\t\tunsigned int elem_len,\n\t\t\t\t\tu64 *changed)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_mgd_assoc_data *assoc_data = sdata->u.mgd.assoc_data;\n\tstruct ieee80211_bss_conf *bss_conf = link->conf;\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned int link_id = link->link_id;\n\tstruct ieee80211_elems_parse_params parse_params = {\n\t\t.mode = link->u.mgd.conn.mode,\n\t\t.start = elem_start,\n\t\t.len = elem_len,\n\t\t.link_id = link_id == assoc_data->assoc_link_id ? -1 : link_id,\n\t\t.from_ap = true,\n\t};\n\tbool is_5ghz = cbss->channel->band == NL80211_BAND_5GHZ;\n\tbool is_6ghz = cbss->channel->band == NL80211_BAND_6GHZ;\n\tbool is_s1g = cbss->channel->band == NL80211_BAND_S1GHZ;\n\tconst struct cfg80211_bss_ies *bss_ies = NULL;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee802_11_elems *elems;\n\tconst __le16 prof_bss_param_ch_present =\n\t\tcpu_to_le16(IEEE80211_MLE_STA_CONTROL_BSS_PARAM_CHANGE_CNT_PRESENT);\n\tu16 capab_info;\n\tbool ret;\n\n\telems = ieee802_11_parse_elems_full(&parse_params);\n\tif (!elems)\n\t\treturn false;\n\n\tif (link_id == assoc_data->assoc_link_id) {\n\t\tcapab_info = le16_to_cpu(mgmt->u.assoc_resp.capab_info);\n\n\t\t/*\n\t\t * we should not get to this flow unless the association was\n\t\t * successful, so set the status directly to success\n\t\t */\n\t\tassoc_data->link[link_id].status = WLAN_STATUS_SUCCESS;\n\t\tif (elems->ml_basic) {\n\t\t\tint bss_param_ch_cnt =\n\t\t\t\tieee80211_mle_get_bss_param_ch_cnt((const void *)elems->ml_basic);\n\n\t\t\tif (bss_param_ch_cnt < 0) {\n\t\t\t\tret = false;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlink->u.mgd.bss_param_ch_cnt = bss_param_ch_cnt;\n\t\t}\n\t} else if (elems->parse_error & IEEE80211_PARSE_ERR_DUP_NEST_ML_BASIC ||\n\t\t   !elems->prof ||\n\t\t   !(elems->prof->control & prof_bss_param_ch_present)) {\n\t\tret = false;\n\t\tgoto out;\n\t} else {\n\t\tconst u8 *ptr = elems->prof->variable +\n\t\t\t\telems->prof->sta_info_len - 1;\n\n\t\t/*\n\t\t * During parsing, we validated that these fields exist,\n\t\t * otherwise elems->prof would have been set to NULL.\n\t\t */\n\t\tcapab_info = get_unaligned_le16(ptr);\n\t\tassoc_data->link[link_id].status = get_unaligned_le16(ptr + 2);\n\t\tlink->u.mgd.bss_param_ch_cnt =\n\t\t\tieee80211_mle_basic_sta_prof_bss_param_ch_cnt(elems->prof);\n\n\t\tif (assoc_data->link[link_id].status != WLAN_STATUS_SUCCESS) {\n\t\t\tlink_info(link, \"association response status code=%u\\n\",\n\t\t\t\t  assoc_data->link[link_id].status);\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!is_s1g && !elems->supp_rates) {\n\t\tsdata_info(sdata, \"no SuppRates element in AssocResp\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tlink->u.mgd.tdls_chan_switch_prohibited =\n\t\telems->ext_capab && elems->ext_capab_len >= 5 &&\n\t\t(elems->ext_capab[4] & WLAN_EXT_CAPA5_TDLS_CH_SW_PROHIBITED);\n\n\t/*\n\t * Some APs are erroneously not including some information in their\n\t * (re)association response frames. Try to recover by using the data\n\t * from the beacon or probe response. This seems to afflict mobile\n\t * 2G/3G/4G wifi routers, reported models include the \"Onda PN51T\",\n\t * \"Vodafone PocketWiFi 2\", \"ZTE MF60\" and a similar T-Mobile device.\n\t */\n\tif (!is_6ghz &&\n\t    ((assoc_data->wmm && !elems->wmm_param) ||\n\t     (link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_HT &&\n\t      (!elems->ht_cap_elem || !elems->ht_operation)) ||\n\t     (link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_VHT &&\n\t      (!elems->vht_cap_elem || !elems->vht_operation)))) {\n\t\tconst struct cfg80211_bss_ies *ies;\n\t\tstruct ieee802_11_elems *bss_elems;\n\n\t\trcu_read_lock();\n\t\ties = rcu_dereference(cbss->ies);\n\t\tif (ies)\n\t\t\tbss_ies = kmemdup(ies, sizeof(*ies) + ies->len,\n\t\t\t\t\t  GFP_ATOMIC);\n\t\trcu_read_unlock();\n\t\tif (!bss_ies) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparse_params.start = bss_ies->data;\n\t\tparse_params.len = bss_ies->len;\n\t\tparse_params.bss = cbss;\n\t\tbss_elems = ieee802_11_parse_elems_full(&parse_params);\n\t\tif (!bss_elems) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (assoc_data->wmm &&\n\t\t    !elems->wmm_param && bss_elems->wmm_param) {\n\t\t\telems->wmm_param = bss_elems->wmm_param;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: WMM param missing from AssocResp\\n\");\n\t\t}\n\n\t\t/*\n\t\t * Also check if we requested HT/VHT, otherwise the AP doesn't\n\t\t * have to include the IEs in the (re)association response.\n\t\t */\n\t\tif (!elems->ht_cap_elem && bss_elems->ht_cap_elem &&\n\t\t    link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_HT) {\n\t\t\telems->ht_cap_elem = bss_elems->ht_cap_elem;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: HT capability missing from AssocResp\\n\");\n\t\t}\n\t\tif (!elems->ht_operation && bss_elems->ht_operation &&\n\t\t    link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_HT) {\n\t\t\telems->ht_operation = bss_elems->ht_operation;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: HT operation missing from AssocResp\\n\");\n\t\t}\n\t\tif (!elems->vht_cap_elem && bss_elems->vht_cap_elem &&\n\t\t    link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_VHT) {\n\t\t\telems->vht_cap_elem = bss_elems->vht_cap_elem;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: VHT capa missing from AssocResp\\n\");\n\t\t}\n\t\tif (!elems->vht_operation && bss_elems->vht_operation &&\n\t\t    link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_VHT) {\n\t\t\telems->vht_operation = bss_elems->vht_operation;\n\t\t\tsdata_info(sdata,\n\t\t\t\t   \"AP bug: VHT operation missing from AssocResp\\n\");\n\t\t}\n\n\t\tkfree(bss_elems);\n\t}\n\n\t/*\n\t * We previously checked these in the beacon/probe response, so\n\t * they should be present here. This is just a safety net.\n\t * Note that the ieee80211_config_bw() below would also check\n\t * for this (and more), but this has better error reporting.\n\t */\n\tif (!is_6ghz && link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_HT &&\n\t    (!elems->wmm_param || !elems->ht_cap_elem || !elems->ht_operation)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"HT AP is missing WMM params or HT capability/operation\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (is_5ghz && link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_VHT &&\n\t    (!elems->vht_cap_elem || !elems->vht_operation)) {\n\t\tsdata_info(sdata,\n\t\t\t   \"VHT AP is missing VHT capability/operation\\n\");\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\t/* check/update if AP changed anything in assoc response vs. scan */\n\tif (ieee80211_config_bw(link, elems,\n\t\t\t\tlink_id == assoc_data->assoc_link_id,\n\t\t\t\tchanged)) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(!link->conf->chanreq.oper.chan)) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\tsband = local->hw.wiphy->bands[link->conf->chanreq.oper.chan->band];\n\n\t/* Set up internal HT/VHT capabilities */\n\tif (elems->ht_cap_elem && link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_HT)\n\t\tieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,\n\t\t\t\t\t\t  elems->ht_cap_elem,\n\t\t\t\t\t\t  link_sta);\n\n\tif (elems->vht_cap_elem &&\n\t    link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_VHT) {\n\t\tconst struct ieee80211_vht_cap *bss_vht_cap = NULL;\n\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\t/*\n\t\t * Cisco AP module 9115 with FW 17.3 has a bug and sends a\n\t\t * too large maximum MPDU length in the association response\n\t\t * (indicating 12k) that it cannot actually process ...\n\t\t * Work around that.\n\t\t */\n\t\trcu_read_lock();\n\t\ties = rcu_dereference(cbss->ies);\n\t\tif (ies) {\n\t\t\tconst struct element *elem;\n\n\t\t\telem = cfg80211_find_elem(WLAN_EID_VHT_CAPABILITY,\n\t\t\t\t\t\t  ies->data, ies->len);\n\t\t\tif (elem && elem->datalen >= sizeof(*bss_vht_cap))\n\t\t\t\tbss_vht_cap = (const void *)elem->data;\n\t\t}\n\n\t\tieee80211_vht_cap_ie_to_sta_vht_cap(sdata, sband,\n\t\t\t\t\t\t    elems->vht_cap_elem,\n\t\t\t\t\t\t    bss_vht_cap, link_sta);\n\t\trcu_read_unlock();\n\t}\n\n\tif (elems->he_operation &&\n\t    link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_HE &&\n\t    elems->he_cap) {\n\t\tconst struct ieee80211_he_6ghz_oper *he_6ghz_oper;\n\n\t\tieee80211_he_cap_ie_to_sta_he_cap(sdata, sband,\n\t\t\t\t\t\t  elems->he_cap,\n\t\t\t\t\t\t  elems->he_cap_len,\n\t\t\t\t\t\t  elems->he_6ghz_capa,\n\t\t\t\t\t\t  link_sta);\n\n\t\the_6ghz_oper = ieee80211_he_6ghz_oper(elems->he_operation);\n\n\t\tif (is_6ghz && he_6ghz_oper) {\n\t\t\tswitch (u8_get_bits(he_6ghz_oper->control,\n\t\t\t\t\t    IEEE80211_HE_6GHZ_OPER_CTRL_REG_INFO)) {\n\t\t\tcase IEEE80211_6GHZ_CTRL_REG_LPI_AP:\n\t\t\t\tbss_conf->power_type = IEEE80211_REG_LPI_AP;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_6GHZ_CTRL_REG_SP_AP:\n\t\t\t\tbss_conf->power_type = IEEE80211_REG_SP_AP;\n\t\t\t\tbreak;\n\t\t\tcase IEEE80211_6GHZ_CTRL_REG_VLP_AP:\n\t\t\t\tbss_conf->power_type = IEEE80211_REG_VLP_AP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbss_conf->power_type = IEEE80211_REG_UNSET_AP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (is_6ghz) {\n\t\t\tlink_info(link,\n\t\t\t\t  \"HE 6 GHz operation missing (on %d MHz), expect issues\\n\",\n\t\t\t\t  bss_conf->chanreq.oper.chan->center_freq);\n\t\t}\n\n\t\tbss_conf->he_support = link_sta->pub->he_cap.has_he;\n\t\tif (elems->rsnx && elems->rsnx_len &&\n\t\t    (elems->rsnx[0] & WLAN_RSNX_CAPA_PROTECTED_TWT) &&\n\t\t    wiphy_ext_feature_isset(local->hw.wiphy,\n\t\t\t\t\t    NL80211_EXT_FEATURE_PROTECTED_TWT))\n\t\t\tbss_conf->twt_protected = true;\n\t\telse\n\t\t\tbss_conf->twt_protected = false;\n\n\t\t*changed |= ieee80211_recalc_twt_req(sdata, sband, link,\n\t\t\t\t\t\t     link_sta, elems);\n\n\t\tif (elems->eht_operation && elems->eht_cap &&\n\t\t    link->u.mgd.conn.mode >= IEEE80211_CONN_MODE_EHT) {\n\t\t\tieee80211_eht_cap_ie_to_sta_eht_cap(sdata, sband,\n\t\t\t\t\t\t\t    elems->he_cap,\n\t\t\t\t\t\t\t    elems->he_cap_len,\n\t\t\t\t\t\t\t    elems->eht_cap,\n\t\t\t\t\t\t\t    elems->eht_cap_len,\n\t\t\t\t\t\t\t    link_sta);\n\n\t\t\tbss_conf->eht_support = link_sta->pub->eht_cap.has_eht;\n\t\t} else {\n\t\t\tbss_conf->eht_support = false;\n\t\t}\n\t} else {\n\t\tbss_conf->he_support = false;\n\t\tbss_conf->twt_requester = false;\n\t\tbss_conf->twt_protected = false;\n\t\tbss_conf->eht_support = false;\n\t}\n\n\tbss_conf->twt_broadcast =\n\t\tieee80211_twt_bcast_support(sdata, bss_conf, sband, link_sta);\n\n\tif (bss_conf->he_support) {\n\t\tbss_conf->he_bss_color.color =\n\t\t\tle32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_BSS_COLOR_MASK);\n\t\tbss_conf->he_bss_color.partial =\n\t\t\tle32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_PARTIAL_BSS_COLOR);\n\t\tbss_conf->he_bss_color.enabled =\n\t\t\t!le32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t       IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED);\n\n\t\tif (bss_conf->he_bss_color.enabled)\n\t\t\t*changed |= BSS_CHANGED_HE_BSS_COLOR;\n\n\t\tbss_conf->htc_trig_based_pkt_ext =\n\t\t\tle32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_DFLT_PE_DURATION_MASK);\n\t\tbss_conf->frame_time_rts_th =\n\t\t\tle32_get_bits(elems->he_operation->he_oper_params,\n\t\t\t\t      IEEE80211_HE_OPERATION_RTS_THRESHOLD_MASK);\n\n\t\tbss_conf->uora_exists = !!elems->uora_element;\n\t\tif (elems->uora_element)\n\t\t\tbss_conf->uora_ocw_range = elems->uora_element[0];\n\n\t\tieee80211_he_op_ie_to_bss_conf(&sdata->vif, elems->he_operation);\n\t\tieee80211_he_spr_ie_to_bss_conf(&sdata->vif, elems->he_spr);\n\t\t/* TODO: OPEN: what happens if BSS color disable is set? */\n\t}\n\n\tif (cbss->transmitted_bss) {\n\t\tbss_conf->nontransmitted = true;\n\t\tether_addr_copy(bss_conf->transmitter_bssid,\n\t\t\t\tcbss->transmitted_bss->bssid);\n\t\tbss_conf->bssid_indicator = cbss->max_bssid_indicator;\n\t\tbss_conf->bssid_index = cbss->bssid_index;\n\t}\n\n\t/*\n\t * Some APs, e.g. Netgear WNDR3700, report invalid HT operation data\n\t * in their association response, so ignore that data for our own\n\t * configuration. If it changed since the last beacon, we'll get the\n\t * next beacon and update then.\n\t */\n\n\t/*\n\t * If an operating mode notification IE is present, override the\n\t * NSS calculation (that would be done in rate_control_rate_init())\n\t * and use the # of streams from that element.\n\t */\n\tif (elems->opmode_notif &&\n\t    !(*elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_TYPE_BF)) {\n\t\tu8 nss;\n\n\t\tnss = *elems->opmode_notif & IEEE80211_OPMODE_NOTIF_RX_NSS_MASK;\n\t\tnss >>= IEEE80211_OPMODE_NOTIF_RX_NSS_SHIFT;\n\t\tnss += 1;\n\t\tlink_sta->pub->rx_nss = nss;\n\t}\n\n\t/*\n\t * Always handle WMM once after association regardless\n\t * of the first value the AP uses. Setting -1 here has\n\t * that effect because the AP values is an unsigned\n\t * 4-bit value.\n\t */\n\tlink->u.mgd.wmm_last_param_set = -1;\n\tlink->u.mgd.mu_edca_last_param_set = -1;\n\n\tif (link->u.mgd.disable_wmm_tracking) {\n\t\tieee80211_set_wmm_default(link, false, false);\n\t} else if (!ieee80211_sta_wmm_params(local, link, elems->wmm_param,\n\t\t\t\t\t     elems->wmm_param_len,\n\t\t\t\t\t     elems->mu_edca_param_set)) {\n\t\t/* still enable QoS since we might have HT/VHT */\n\t\tieee80211_set_wmm_default(link, false, true);\n\t\t/* disable WMM tracking in this case to disable\n\t\t * tracking WMM parameter changes in the beacon if\n\t\t * the parameters weren't actually valid. Doing so\n\t\t * avoids changing parameters very strangely when\n\t\t * the AP is going back and forth between valid and\n\t\t * invalid parameters.\n\t\t */\n\t\tlink->u.mgd.disable_wmm_tracking = true;\n\t}\n\n\tif (elems->max_idle_period_ie) {\n\t\tbss_conf->max_idle_period =\n\t\t\tle16_to_cpu(elems->max_idle_period_ie->max_idle_period);\n\t\tbss_conf->protected_keep_alive =\n\t\t\t!!(elems->max_idle_period_ie->idle_options &\n\t\t\t   WLAN_IDLE_OPTIONS_PROTECTED_KEEP_ALIVE);\n\t\t*changed |= BSS_CHANGED_KEEP_ALIVE;\n\t} else {\n\t\tbss_conf->max_idle_period = 0;\n\t\tbss_conf->protected_keep_alive = false;\n\t}\n\n\t/* set assoc capability (AID was already set earlier),\n\t * ieee80211_set_associated() will tell the driver */\n\tbss_conf->assoc_capability = capab_info;\n\n\tret = true;\nout:\n\tkfree(elems);\n\tkfree(bss_ies);\n\treturn ret;\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree(bss_ies);",
                "condition": [
                    "goto out"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "const struct cfg80211_bss_ies *bss_ies = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return false;",
                "condition": [
                    "if (!elems)"
                ]
            }
        ],
        "index": 80
    },
    {
        "var_name": "sta",
        "function_name": "ieee80211_mgd_probe_ap_send",
        "location": {
            "file_path": "net/mac80211/mlme.c",
            "region": {
                "startLine": 3428,
                "startColumn": 28,
                "endColumn": 31
            },
            "context": {
                "startLine": 3426,
                "endLine": 3430,
                "snippet": {
                    "text": "\t\t\tieee80211_check_fast_rx(sta);"
                }
            }
        },
        "function_code": "static void ieee80211_mgd_probe_ap_send(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_if_managed *ifmgd = &sdata->u.mgd;\n\tu8 *dst = sdata->vif.cfg.ap_addr;\n\tu8 unicast_limit = max(1, max_probe_tries - 3);\n\tstruct sta_info *sta;\n\n\tlockdep_assert_wiphy(sdata->local->hw.wiphy);\n\n\tif (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))\n\t\treturn;\n\n\t/*\n\t * Try sending broadcast probe requests for the last three\n\t * probe requests after the first ones failed since some\n\t * buggy APs only support broadcast probe requests.\n\t */\n\tif (ifmgd->probe_send_count >= unicast_limit)\n\t\tdst = NULL;\n\n\t/*\n\t * When the hardware reports an accurate Tx ACK status, it's\n\t * better to send a nullfunc frame instead of a probe request,\n\t * as it will kick us off the AP quickly if we aren't associated\n\t * anymore. The timeout will be reset if the frame is ACKed by\n\t * the AP.\n\t */\n\tifmgd->probe_send_count++;\n\n\tif (dst) {\n\t\tsta = sta_info_get(sdata, dst);\n\t\tif (!WARN_ON(!sta))\n\t\t\tieee80211_check_fast_rx(sta);\n\t}\n\n\tif (ieee80211_hw_check(&sdata->local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\tifmgd->nullfunc_failed = false;\n\t\tieee80211_send_nullfunc(sdata->local, sdata, false);\n\t} else {\n\t\tieee80211_mlme_send_probe_req(sdata, sdata->vif.addr, dst,\n\t\t\t\t\t      sdata->vif.cfg.ssid,\n\t\t\t\t\t      sdata->vif.cfg.ssid_len,\n\t\t\t\t\t      sdata->deflink.conf->bss->channel);\n\t}\n\n\tifmgd->probe_timeout = jiffies + msecs_to_jiffies(probe_wait_ms);\n\trun_again(sdata, ifmgd->probe_timeout);\n}",
        "function_list": [
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\t\tieee80211_check_fast_rx(sta);",
                "condition": [
                    "if (dst)",
                    "if (!WARN_ON(!sta))"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON(ieee80211_vif_is_mld(&sdata->vif)))"
                ]
            }
        ],
        "index": 81
    },
    {
        "var_name": "bssid",
        "function_name": "ieee80211_rx_h_sta_process",
        "location": {
            "file_path": "net/mac80211/rx.c",
            "region": {
                "startLine": 1761,
                "startColumn": 24,
                "endColumn": 29
            },
            "context": {
                "startLine": 1759,
                "endLine": 1763,
                "snippet": {
                    "text": "\t\tif (ether_addr_equal(bssid, rx->sdata->u.ibss.bssid) &&"
                }
            }
        },
        "function_code": "static ieee80211_rx_result debug_noinline\nieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)\n{\n\tstruct sta_info *sta = rx->sta;\n\tstruct link_sta_info *link_sta = rx->link_sta;\n\tstruct sk_buff *skb = rx->skb;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tint i;\n\n\tif (!sta || !link_sta)\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * Update last_rx only for IBSS packets which are for the current\n\t * BSSID and for station already AUTHORIZED to avoid keeping the\n\t * current IBSS network alive in cases where other STAs start\n\t * using different BSSID. This will also give the station another\n\t * chance to restart the authentication/authorization in case\n\t * something went wrong the first time.\n\t */\n\tif (rx->sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tu8 *bssid = ieee80211_get_bssid(hdr, rx->skb->len,\n\t\t\t\t\t\tNL80211_IFTYPE_ADHOC);\n\t\tif (ether_addr_equal(bssid, rx->sdata->u.ibss.bssid) &&\n\t\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\t\tlink_sta->rx_stats.last_rx = jiffies;\n\t\t\tif (ieee80211_is_data_present(hdr->frame_control) &&\n\t\t\t    !is_multicast_ether_addr(hdr->addr1))\n\t\t\t\tlink_sta->rx_stats.last_rate =\n\t\t\t\t\tsta_stats_encode_rate(status);\n\t\t}\n\t} else if (rx->sdata->vif.type == NL80211_IFTYPE_OCB) {\n\t\tlink_sta->rx_stats.last_rx = jiffies;\n\t} else if (!ieee80211_is_s1g_beacon(hdr->frame_control) &&\n\t\t   !is_multicast_ether_addr(hdr->addr1)) {\n\t\t/*\n\t\t * Mesh beacons will update last_rx when if they are found to\n\t\t * match the current local configuration when processed.\n\t\t */\n\t\tlink_sta->rx_stats.last_rx = jiffies;\n\t\tif (ieee80211_is_data_present(hdr->frame_control))\n\t\t\tlink_sta->rx_stats.last_rate = sta_stats_encode_rate(status);\n\t}\n\n\tlink_sta->rx_stats.fragments++;\n\n\tu64_stats_update_begin(&link_sta->rx_stats.syncp);\n\tlink_sta->rx_stats.bytes += rx->skb->len;\n\tu64_stats_update_end(&link_sta->rx_stats.syncp);\n\n\tif (!(status->flag & RX_FLAG_NO_SIGNAL_VAL)) {\n\t\tlink_sta->rx_stats.last_signal = status->signal;\n\t\tewma_signal_add(&link_sta->rx_stats_avg.signal,\n\t\t\t\t-status->signal);\n\t}\n\n\tif (status->chains) {\n\t\tlink_sta->rx_stats.chains = status->chains;\n\t\tfor (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {\n\t\t\tint signal = status->chain_signal[i];\n\n\t\t\tif (!(status->chains & BIT(i)))\n\t\t\t\tcontinue;\n\n\t\t\tlink_sta->rx_stats.chain_signal_last[i] = signal;\n\t\t\tewma_signal_add(&link_sta->rx_stats_avg.chain_signal[i],\n\t\t\t\t\t-signal);\n\t\t}\n\t}\n\n\tif (ieee80211_is_s1g_beacon(hdr->frame_control))\n\t\treturn RX_CONTINUE;\n\n\t/*\n\t * Change STA power saving mode only at the end of a frame\n\t * exchange sequence, and only for a data or management\n\t * frame as specified in IEEE 802.11-2016 11.2.3.2\n\t */\n\tif (!ieee80211_hw_check(&sta->local->hw, AP_LINK_PS) &&\n\t    !ieee80211_has_morefrags(hdr->frame_control) &&\n\t    !is_multicast_ether_addr(hdr->addr1) &&\n\t    (ieee80211_is_mgmt(hdr->frame_control) ||\n\t     ieee80211_is_data(hdr->frame_control)) &&\n\t    !(status->rx_flags & IEEE80211_RX_DEFERRED_RELEASE) &&\n\t    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN)) {\n\t\tif (test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\t\tif (!ieee80211_has_pm(hdr->frame_control))\n\t\t\t\tsta_ps_end(sta);\n\t\t} else {\n\t\t\tif (ieee80211_has_pm(hdr->frame_control))\n\t\t\t\tsta_ps_start(sta);\n\t\t}\n\t}\n\n\t/* mesh power save support */\n\tif (ieee80211_vif_is_mesh(&rx->sdata->vif))\n\t\tieee80211_mps_rx_h_sta_process(sta, hdr);\n\n\t/*\n\t * Drop (qos-)data::nullfunc frames silently, since they\n\t * are used only to control station power saving mode.\n\t */\n\tif (ieee80211_is_any_nullfunc(hdr->frame_control)) {\n\t\tI802_DEBUG_INC(rx->local->rx_handlers_drop_nullfunc);\n\n\t\t/*\n\t\t * If we receive a 4-addr nullfunc frame from a STA\n\t\t * that was not moved to a 4-addr STA vlan yet send\n\t\t * the event to userspace and for older hostapd drop\n\t\t * the frame to the monitor interface.\n\t\t */\n\t\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t\t    (rx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t\t     (rx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t      !rx->sdata->u.vlan.sta))) {\n\t\t\tif (!test_and_set_sta_flag(sta, WLAN_STA_4ADDR_EVENT))\n\t\t\t\tcfg80211_rx_unexpected_4addr_frame(\n\t\t\t\t\trx->sdata->dev, sta->sta.addr,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\treturn RX_DROP_M_UNEXPECTED_4ADDR_FRAME;\n\t\t}\n\t\t/*\n\t\t * Update counter and free packet here to avoid\n\t\t * counting this as a dropped packed.\n\t\t */\n\t\tlink_sta->rx_stats.packets++;\n\t\tdev_kfree_skb(rx->skb);\n\t\treturn RX_QUEUED;\n\t}\n\n\treturn RX_CONTINUE;\n} /* ieee80211_rx_h_sta_process */",
        "function_list": [
            "ieee80211_get_bssid"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\tif (ether_addr_equal(bssid, rx->sdata->u.ibss.bssid) &&",
                "condition": [
                    "if (rx->sdata->vif.type == NL80211_IFTYPE_ADHOC)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return RX_CONTINUE;",
                "condition": [
                    "if (!sta || !link_sta)"
                ]
            }
        ],
        "index": 84
    },
    {
        "var_name": "monskb",
        "function_name": "ieee80211_rx_monitor",
        "location": {
            "file_path": "net/mac80211/rx.c",
            "region": {
                "startLine": 876,
                "startColumn": 16,
                "endColumn": 22
            },
            "context": {
                "startLine": 874,
                "endLine": 878,
                "snippet": {
                    "text": "\tdev_kfree_skb(monskb);"
                }
            }
        },
        "function_code": "static struct sk_buff *\nieee80211_rx_monitor(struct ieee80211_local *local, struct sk_buff *origskb,\n\t\t     struct ieee80211_rate *rate)\n{\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(origskb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct sk_buff *monskb = NULL;\n\tint present_fcs_len = 0;\n\tunsigned int rtap_space = 0;\n\tstruct ieee80211_sub_if_data *monitor_sdata =\n\t\trcu_dereference(local->monitor_sdata);\n\tbool only_monitor = false;\n\tunsigned int min_head_len;\n\n\tif (WARN_ON_ONCE(status->flag & RX_FLAG_RADIOTAP_TLV_AT_END &&\n\t\t\t !skb_mac_header_was_set(origskb))) {\n\t\t/* with this skb no way to know where frame payload starts */\n\t\tdev_kfree_skb(origskb);\n\t\treturn NULL;\n\t}\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_he);\n\n\tif (status->flag & RX_FLAG_RADIOTAP_HE_MU)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_he_mu);\n\n\tif (status->flag & RX_FLAG_RADIOTAP_LSIG)\n\t\trtap_space += sizeof(struct ieee80211_radiotap_lsig);\n\n\tif (status->flag & RX_FLAG_RADIOTAP_TLV_AT_END)\n\t\trtap_space += skb_mac_header(origskb) - &origskb->data[rtap_space];\n\n\tmin_head_len = rtap_space;\n\n\t/*\n\t * First, we may need to make a copy of the skb because\n\t *  (1) we need to modify it for radiotap (if not present), and\n\t *  (2) the other RX handlers will modify the skb we got.\n\t *\n\t * We don't need to, of course, if we aren't going to return\n\t * the SKB because it has a bad FCS/PLCP checksum.\n\t */\n\n\tif (!(status->flag & RX_FLAG_NO_PSDU)) {\n\t\tif (ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS)) {\n\t\t\tif (unlikely(origskb->len <= FCS_LEN + rtap_space)) {\n\t\t\t\t/* driver bug */\n\t\t\t\tWARN_ON(1);\n\t\t\t\tdev_kfree_skb(origskb);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tpresent_fcs_len = FCS_LEN;\n\t\t}\n\n\t\t/* also consider the hdr->frame_control */\n\t\tmin_head_len += 2;\n\t}\n\n\t/* ensure that the expected data elements are in skb head */\n\tif (!pskb_may_pull(origskb, min_head_len)) {\n\t\tdev_kfree_skb(origskb);\n\t\treturn NULL;\n\t}\n\n\tonly_monitor = should_drop_frame(origskb, present_fcs_len, rtap_space);\n\n\tif (!local->monitors || (status->flag & RX_FLAG_SKIP_MONITOR)) {\n\t\tif (only_monitor) {\n\t\t\tdev_kfree_skb(origskb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn ieee80211_clean_skb(origskb, present_fcs_len,\n\t\t\t\t\t   rtap_space);\n\t}\n\n\tieee80211_handle_mu_mimo_mon(monitor_sdata, origskb, rtap_space);\n\n\tlist_for_each_entry_rcu(sdata, &local->mon_list, u.mntr.list) {\n\t\tbool last_monitor = list_is_last(&sdata->u.mntr.list,\n\t\t\t\t\t\t &local->mon_list);\n\n\t\tif (!monskb)\n\t\t\tmonskb = ieee80211_make_monitor_skb(local, &origskb,\n\t\t\t\t\t\t\t    rate, rtap_space,\n\t\t\t\t\t\t\t    only_monitor &&\n\t\t\t\t\t\t\t    last_monitor);\n\n\t\tif (monskb) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (last_monitor) {\n\t\t\t\tskb = monskb;\n\t\t\t\tmonskb = NULL;\n\t\t\t} else {\n\t\t\t\tskb = skb_clone(monskb, GFP_ATOMIC);\n\t\t\t}\n\n\t\t\tif (skb) {\n\t\t\t\tskb->dev = sdata->dev;\n\t\t\t\tdev_sw_netstats_rx_add(skb->dev, skb->len);\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t}\n\t\t}\n\n\t\tif (last_monitor)\n\t\t\tbreak;\n\t}\n\n\t/* this happens if last_monitor was erroneously false */\n\tdev_kfree_skb(monskb);\n\n\t/* ditto */\n\tif (!origskb)\n\t\treturn NULL;\n\n\treturn ieee80211_clean_skb(origskb, present_fcs_len, rtap_space);\n}",
        "function_list": [
            "dev_kfree_skb",
            "consume_skb"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tdev_kfree_skb(monskb);",
                "condition": []
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct sk_buff *monskb = NULL;",
                "condition": []
            },
            {
                "text": "monskb = NULL;",
                "condition": [
                    "list_for_each_entry_rcu(sdata, &local->mon_list, u.mntr.list)",
                    "if (monskb)",
                    "if (last_monitor)"
                ]
            }
        ],
        "pointer_null_postconditions": [
            {
                "text": "if (!monskb)",
                "condition": [
                    "list_for_each_entry_rcu(sdata, &local->mon_list, u.mntr.list)"
                ],
                "content": "\t\tif (!monskb)\n\t\t\tmonskb = ieee80211_make_monitor_skb(local, &origskb,\n\t\t\t\t\t\t\t    rate, rtap_space,\n\t\t\t\t\t\t\t    only_monitor &&\n\t\t\t\t\t\t\t    last_monitor);\n"
            },
            {
                "text": "if (monskb)",
                "condition": [
                    "list_for_each_entry_rcu(sdata, &local->mon_list, u.mntr.list)"
                ],
                "content": "\t\tif (monskb) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (last_monitor) {\n\t\t\t\tskb = monskb;\n\t\t\t\tmonskb = NULL;\n\t\t\t} else {\n\t\t\t\tskb = skb_clone(monskb, GFP_ATOMIC);\n\t\t\t}\n\n\t\t\tif (skb) {\n\t\t\t\tskb->dev = sdata->dev;\n\t\t\t\tdev_sw_netstats_rx_add(skb->dev, skb->len);\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t}\n\t\t}\n"
            }
        ],
        "early_jump_constraints": [
            {
                "text": "return NULL;",
                "condition": [
                    "if (WARN_ON_ONCE(status->flag & RX_FLAG_RADIOTAP_TLV_AT_END && !skb_mac_header_was_set(origskb)))"
                ]
            },
            {
                "text": "return NULL;",
                "condition": [
                    "if (!(status->flag & RX_FLAG_NO_PSDU))",
                    "if (ieee80211_hw_check(&local->hw, RX_INCLUDES_FCS))",
                    "if (unlikely(origskb->len <= FCS_LEN + rtap_space))"
                ]
            },
            {
                "text": "return NULL;",
                "condition": [
                    "if (!pskb_may_pull(origskb, min_head_len))"
                ]
            },
            {
                "text": "return NULL;",
                "condition": [
                    "if (!local->monitors || (status->flag & RX_FLAG_SKIP_MONITOR))",
                    "if (only_monitor)"
                ]
            },
            {
                "text": "return ieee80211_clean_skb(origskb, present_fcs_len,",
                "condition": [
                    "if (!local->monitors || (status->flag & RX_FLAG_SKIP_MONITOR))"
                ]
            }
        ],
        "index": 85
    },
    {
        "var_name": "sinfo",
        "function_name": "__acquires",
        "location": {
            "file_path": "net/mac80211/sta_info.c",
            "region": {
                "startLine": 929,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 927,
                "endLine": 931,
                "snippet": {
                    "text": "\tkfree(sinfo);"
                }
            }
        },
        "function_code": "static int sta_info_insert_finish(struct sta_info *sta) __acquires(RCU)\n{\n\tstruct ieee80211_local *local = sta->local;\n\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\tstruct station_info *sinfo = NULL;\n\tint err = 0;\n\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\t/* check if STA exists already */\n\tif (sta_info_get_bss(sdata, sta->sta.addr)) {\n\t\terr = -EEXIST;\n\t\tgoto out_cleanup;\n\t}\n\n\tsinfo = kzalloc(sizeof(struct station_info), GFP_KERNEL);\n\tif (!sinfo) {\n\t\terr = -ENOMEM;\n\t\tgoto out_cleanup;\n\t}\n\n\tlocal->num_sta++;\n\tlocal->sta_generation++;\n\tsmp_mb();\n\n\t/* simplify things and don't accept BA sessions yet */\n\tset_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\n\t/* make the station visible */\n\terr = sta_info_hash_add(local, sta);\n\tif (err)\n\t\tgoto out_drop_sta;\n\n\tif (sta->sta.valid_links) {\n\t\terr = link_sta_info_hash_add(local, &sta->deflink);\n\t\tif (err) {\n\t\t\tsta_info_hash_del(local, sta);\n\t\t\tgoto out_drop_sta;\n\t\t}\n\t}\n\n\tlist_add_tail_rcu(&sta->list, &local->sta_list);\n\n\t/* update channel context before notifying the driver about state\n\t * change, this enables driver using the updated channel context right away.\n\t */\n\tif (sta->sta_state >= IEEE80211_STA_ASSOC) {\n\t\tieee80211_recalc_min_chandef(sta->sdata, -1);\n\t\tif (!sta->sta.support_p2p_ps)\n\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t}\n\n\t/* notify driver */\n\terr = sta_info_insert_drv_state(local, sdata, sta);\n\tif (err)\n\t\tgoto out_remove;\n\n\tset_sta_flag(sta, WLAN_STA_INSERTED);\n\n\t/* accept BA sessions now */\n\tclear_sta_flag(sta, WLAN_STA_BLOCK_BA);\n\n\tieee80211_sta_debugfs_add(sta);\n\trate_control_add_sta_debugfs(sta);\n\tif (sta->sta.valid_links) {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta->link); i++) {\n\t\t\tstruct link_sta_info *link_sta;\n\n\t\t\tlink_sta = rcu_dereference_protected(sta->link[i],\n\t\t\t\t\t\t\t     lockdep_is_held(&local->hw.wiphy->mtx));\n\n\t\t\tif (!link_sta)\n\t\t\t\tcontinue;\n\n\t\t\tieee80211_link_sta_debugfs_add(link_sta);\n\t\t\tif (sdata->vif.active_links & BIT(i))\n\t\t\t\tieee80211_link_sta_debugfs_drv_add(link_sta);\n\t\t}\n\t} else {\n\t\tieee80211_link_sta_debugfs_add(&sta->deflink);\n\t\tieee80211_link_sta_debugfs_drv_add(&sta->deflink);\n\t}\n\n\tsinfo->generation = local->sta_generation;\n\tcfg80211_new_sta(sdata->dev, sta->sta.addr, sinfo, GFP_KERNEL);\n\tkfree(sinfo);\n\n\tsta_dbg(sdata, \"Inserted STA %pM\\n\", sta->sta.addr);\n\n\t/* move reference to rcu-protected */\n\trcu_read_lock();\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_accept_plinks_update(sdata);\n\n\tieee80211_check_fast_xmit(sta);\n\n\treturn 0;\n out_remove:\n\tif (sta->sta.valid_links)\n\t\tlink_sta_info_hash_del(local, &sta->deflink);\n\tsta_info_hash_del(local, sta);\n\tlist_del_rcu(&sta->list);\n out_drop_sta:\n\tlocal->num_sta--;\n\tsynchronize_net();\n out_cleanup:\n\tcleanup_single_sta(sta);\n\tkfree(sinfo);\n\trcu_read_lock();\n\treturn err;\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree(sinfo);",
                "condition": []
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct station_info *sinfo = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto out_cleanup;",
                "condition": [
                    "if (sta_info_get_bss(sdata, sta->sta.addr))"
                ]
            },
            {
                "text": "goto out_cleanup;",
                "condition": [
                    "if (!sinfo)"
                ]
            },
            {
                "text": "goto out_drop_sta;",
                "condition": [
                    "if (err)"
                ]
            },
            {
                "text": "goto out_drop_sta;",
                "condition": [
                    "if (sta->sta.valid_links)",
                    "if (err)"
                ]
            },
            {
                "text": "goto out_remove;",
                "condition": [
                    "if (err)"
                ]
            }
        ],
        "index": 88
    },
    {
        "var_name": "sta",
        "function_name": "ieee80211_tx_status_ext",
        "location": {
            "file_path": "net/mac80211/status.c",
            "region": {
                "startLine": 1159,
                "startColumn": 41,
                "endColumn": 44
            },
            "context": {
                "startLine": 1157,
                "endLine": 1161,
                "snippet": {
                    "text": "\t\tstruct ieee80211_sub_if_data *sdata = sta->sdata;"
                }
            }
        },
        "function_code": "void ieee80211_tx_status_ext(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_status *status)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tstruct ieee80211_tx_info *info = status->info;\n\tstruct ieee80211_sta *pubsta = status->sta;\n\tstruct sk_buff *skb = status->skb;\n\tstruct sta_info *sta = NULL;\n\tint rates_idx, retry_count;\n\tbool acked, noack_success, ack_signal_valid;\n\tu16 tx_time_est;\n\n\tif (pubsta) {\n\t\tsta = container_of(pubsta, struct sta_info, sta);\n\n\t\tif (status->n_rates)\n\t\t\tsta->deflink.tx_stats.last_rate_info =\n\t\t\t\tstatus->rates[status->n_rates - 1].rate_idx;\n\t}\n\n\tif (skb && (tx_time_est =\n\t\t    ieee80211_info_get_tx_time_est(IEEE80211_SKB_CB(skb))) > 0) {\n\t\t/* Do this here to avoid the expensive lookup of the sta\n\t\t * in ieee80211_report_used_skb().\n\t\t */\n\t\tieee80211_sta_update_pending_airtime(local, sta,\n\t\t\t\t\t\t     skb_get_queue_mapping(skb),\n\t\t\t\t\t\t     tx_time_est,\n\t\t\t\t\t\t     true);\n\t\tieee80211_info_set_tx_time_est(IEEE80211_SKB_CB(skb), 0);\n\t}\n\n\tif (!status->info)\n\t\tgoto free;\n\n\trates_idx = ieee80211_tx_get_rates(hw, info, &retry_count);\n\n\tacked = !!(info->flags & IEEE80211_TX_STAT_ACK);\n\tnoack_success = !!(info->flags & IEEE80211_TX_STAT_NOACK_TRANSMITTED);\n\tack_signal_valid =\n\t\t!!(info->status.flags & IEEE80211_TX_STATUS_ACK_SIGNAL_VALID);\n\n\tif (pubsta) {\n\t\tstruct ieee80211_sub_if_data *sdata = sta->sdata;\n\n\t\tif (!acked && !noack_success)\n\t\t\tsta->deflink.status_stats.retry_failed++;\n\t\tsta->deflink.status_stats.retry_count += retry_count;\n\n\t\tif (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t\t    skb && !(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP))\n\t\t\t\tieee80211_sta_tx_notify(sdata, (void *) skb->data,\n\t\t\t\t\t\t\tacked, info->status.tx_time);\n\n\t\t\tif (acked) {\n\t\t\t\tsta->deflink.status_stats.last_ack = jiffies;\n\n\t\t\t\tif (sta->deflink.status_stats.lost_packets)\n\t\t\t\t\tsta->deflink.status_stats.lost_packets = 0;\n\n\t\t\t\t/* Track when last packet was ACKed */\n\t\t\t\tsta->deflink.status_stats.last_pkt_time = jiffies;\n\n\t\t\t\t/* Reset connection monitor */\n\t\t\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t\t\t    unlikely(sdata->u.mgd.probe_send_count > 0))\n\t\t\t\t\tsdata->u.mgd.probe_send_count = 0;\n\n\t\t\t\tif (ack_signal_valid) {\n\t\t\t\t\tsta->deflink.status_stats.last_ack_signal =\n\t\t\t\t\t\t\t (s8)info->status.ack_signal;\n\t\t\t\t\tsta->deflink.status_stats.ack_signal_filled = true;\n\t\t\t\t\tewma_avg_signal_add(&sta->deflink.status_stats.avg_ack_signal,\n\t\t\t\t\t\t\t    -info->status.ack_signal);\n\t\t\t\t}\n\t\t\t} else if (test_sta_flag(sta, WLAN_STA_PS_STA)) {\n\t\t\t\t/*\n\t\t\t\t * The STA is in power save mode, so assume\n\t\t\t\t * that this TX packet failed because of that.\n\t\t\t\t */\n\t\t\t\tif (skb)\n\t\t\t\t\tieee80211_handle_filtered_frame(local, sta, skb);\n\t\t\t\treturn;\n\t\t\t} else if (noack_success) {\n\t\t\t\t/* nothing to do here, do not account as lost */\n\t\t\t} else {\n\t\t\t\tieee80211_lost_packet(sta, info);\n\t\t\t}\n\t\t}\n\n\t\trate_control_tx_status(local, status);\n\t\tif (ieee80211_vif_is_mesh(&sta->sdata->vif))\n\t\t\tieee80211s_update_metric(local, sta, status);\n\t}\n\n\tif (skb && !(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP))\n\t\treturn __ieee80211_tx_status(hw, status, rates_idx,\n\t\t\t\t\t     retry_count);\n\n\tif (acked || noack_success) {\n\t\tI802_DEBUG_INC(local->dot11TransmittedFrameCount);\n\t\tif (!pubsta)\n\t\t\tI802_DEBUG_INC(local->dot11MulticastTransmittedFrameCount);\n\t\tif (retry_count > 0)\n\t\t\tI802_DEBUG_INC(local->dot11RetryCount);\n\t\tif (retry_count > 1)\n\t\t\tI802_DEBUG_INC(local->dot11MultipleRetryCount);\n\t} else {\n\t\tI802_DEBUG_INC(local->dot11FailedCount);\n\t}\n\nfree:\n\tif (!skb)\n\t\treturn;\n\n\tieee80211_report_used_skb(local, skb, false, status->ack_hwtstamp);\n\tif (status->free_list)\n\t\tlist_add_tail(&skb->list, status->free_list);\n\telse\n\t\tdev_kfree_skb(skb);\n}",
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\tstruct ieee80211_sub_if_data *sdata = sta->sdata;",
                "condition": [
                    "if (pubsta)"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct sta_info *sta = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "goto free;",
                "condition": [
                    "if (!status->info)"
                ]
            }
        ],
        "index": 89
    },
    {
        "var_name": "skb",
        "function_name": "ieee80211_tx_monitor",
        "location": {
            "file_path": "net/mac80211/status.c",
            "region": {
                "startLine": 931,
                "startColumn": 16,
                "endColumn": 19
            },
            "context": {
                "startLine": 929,
                "endLine": 933,
                "snippet": {
                    "text": "\tdev_kfree_skb(skb);"
                }
            }
        },
        "function_code": "void ieee80211_tx_monitor(struct ieee80211_local *local, struct sk_buff *skb,\n\t\t\t  int retry_count, bool send_to_cooked,\n\t\t\t  struct ieee80211_tx_status *status)\n{\n\tstruct sk_buff *skb2;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_sub_if_data *sdata;\n\tstruct net_device *prev_dev = NULL;\n\tint rtap_len;\n\n\t/* send frame to monitor interfaces now */\n\trtap_len = ieee80211_tx_radiotap_len(info, status);\n\tif (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {\n\t\tpr_err(\"ieee80211_tx_status: headroom too small\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tieee80211_add_tx_radiotap_header(local, skb, retry_count,\n\t\t\t\t\t rtap_len, status);\n\n\t/* XXX: is this sufficient for BPF? */\n\tskb_reset_mac_header(skb);\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_802_2);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(sdata, &local->interfaces, list) {\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MONITOR) {\n\t\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\t\tcontinue;\n\n\t\t\tif ((sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES) &&\n\t\t\t    !send_to_cooked)\n\t\t\t\tcontinue;\n\n\t\t\tif (prev_dev) {\n\t\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (skb2) {\n\t\t\t\t\tskb2->dev = prev_dev;\n\t\t\t\t\tnetif_rx(skb2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev_dev = sdata->dev;\n\t\t}\n\t}\n\tif (prev_dev) {\n\t\tskb->dev = prev_dev;\n\t\tnetif_rx(skb);\n\t\tskb = NULL;\n\t}\n\trcu_read_unlock();\n\tdev_kfree_skb(skb);\n}",
        "function_list": [
            "dev_kfree_skb",
            "consume_skb"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tdev_kfree_skb(skb);",
                "condition": []
            }
        ],
        "var_assign_conditions": [
            {
                "text": "skb = NULL;",
                "condition": [
                    "if (prev_dev)"
                ]
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(skb_headroom(skb) < rtap_len))"
                ]
            }
        ],
        "index": 90
    },
    {
        "var_name": "sdata",
        "function_name": "ieee80211_report_used_skb",
        "location": {
            "file_path": "net/mac80211/status.c",
            "region": {
                "startLine": 773,
                "startColumn": 33,
                "endColumn": 38
            },
            "context": {
                "startLine": 771,
                "endLine": 775,
                "snippet": {
                    "text": "\t\t\tieee80211_handle_smps_status(sdata, acked,"
                }
            }
        },
        "function_code": "static void ieee80211_report_used_skb(struct ieee80211_local *local,\n\t\t\t\t      struct sk_buff *skb, bool dropped,\n\t\t\t\t      ktime_t ack_hwtstamp)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tu16 tx_time_est = ieee80211_info_get_tx_time_est(info);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tbool acked = info->flags & IEEE80211_TX_STAT_ACK;\n\n\tif (dropped)\n\t\tacked = false;\n\n\tif (tx_time_est) {\n\t\tstruct sta_info *sta;\n\n\t\trcu_read_lock();\n\n\t\tsta = sta_info_get_by_addrs(local, hdr->addr1, hdr->addr2);\n\t\tieee80211_sta_update_pending_airtime(local, sta,\n\t\t\t\t\t\t     skb_get_queue_mapping(skb),\n\t\t\t\t\t\t     tx_time_est,\n\t\t\t\t\t\t     true);\n\t\trcu_read_unlock();\n\t}\n\n\tif (info->flags & IEEE80211_TX_INTFL_MLME_CONN_TX) {\n\t\tstruct ieee80211_sub_if_data *sdata;\n\n\t\trcu_read_lock();\n\n\t\tsdata = ieee80211_sdata_from_skb(local, skb);\n\n\t\tif (!sdata) {\n\t\t\tskb->dev = NULL;\n\t\t} else if (!dropped) {\n\t\t\t/* Check to see if packet is a TDLS teardown packet */\n\t\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    (ieee80211_get_tdls_action(skb) ==\n\t\t\t     WLAN_TDLS_TEARDOWN)) {\n\t\t\t\tieee80211_tdls_td_tx_handle(local, sdata, skb,\n\t\t\t\t\t\t\t    info->flags);\n\t\t\t} else if (ieee80211_s1g_is_twt_setup(skb)) {\n\t\t\t\tif (!acked) {\n\t\t\t\t\tstruct sk_buff *qskb;\n\n\t\t\t\t\tqskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t\tif (qskb) {\n\t\t\t\t\t\tskb_queue_tail(&sdata->status_queue,\n\t\t\t\t\t\t\t       qskb);\n\t\t\t\t\t\twiphy_work_queue(local->hw.wiphy,\n\t\t\t\t\t\t\t\t &sdata->work);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tieee80211_mgd_conn_tx_status(sdata,\n\t\t\t\t\t\t\t     hdr->frame_control,\n\t\t\t\t\t\t\t     acked);\n\t\t\t}\n\t\t}\n\n\t\trcu_read_unlock();\n\t} else if (info->status_data_idr) {\n\t\tieee80211_report_ack_skb(local, skb, acked, dropped,\n\t\t\t\t\t ack_hwtstamp);\n\t} else if (info->status_data) {\n\t\tstruct ieee80211_sub_if_data *sdata;\n\n\t\trcu_read_lock();\n\n\t\tsdata = ieee80211_sdata_from_skb(local, skb);\n\n\t\tswitch (u16_get_bits(info->status_data,\n\t\t\t\t     IEEE80211_STATUS_TYPE_MASK)) {\n\t\tcase IEEE80211_STATUS_TYPE_SMPS:\n\t\t\tieee80211_handle_smps_status(sdata, acked,\n\t\t\t\t\t\t     info->status_data);\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (!dropped && skb->destructor) {\n\t\tskb->wifi_acked_valid = 1;\n\t\tskb->wifi_acked = acked;\n\t}\n\n\tieee80211_led_tx(local);\n\n\tif (skb_has_frag_list(skb)) {\n\t\tkfree_skb_list(skb_shinfo(skb)->frag_list);\n\t\tskb_shinfo(skb)->frag_list = NULL;\n\t}\n}",
        "function_list": [
            "ieee80211_sdata_from_skb"
        ],
        "result": 1,
        "bug_line_constraints": [
            {
                "text": "\t\t\tieee80211_handle_smps_status(sdata, acked,",
                "condition": [
                    "if (info->status_data)",
                    "if(switch (u16_get_bits(info->status_data, == IEEE80211_STATUS_TYPE_SMPS)"
                ]
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [
            {
                "text": "if (!sdata)",
                "condition": [
                    "if (info->flags & IEEE80211_TX_INTFL_MLME_CONN_TX)"
                ],
                "content": "\t\tif (!sdata) {\n\t\t\tskb->dev = NULL;\n\t\t} else if (!dropped) {\n\t\t\t/* Check to see if packet is a TDLS teardown packet */\n\t\t\tif (ieee80211_is_data(hdr->frame_control) &&\n\t\t\t    (ieee80211_get_tdls_action(skb) ==\n\t\t\t     WLAN_TDLS_TEARDOWN)) {\n\t\t\t\tieee80211_tdls_td_tx_handle(local, sdata, skb,\n\t\t\t\t\t\t\t    info->flags);\n\t\t\t} else if (ieee80211_s1g_is_twt_setup(skb)) {\n\t\t\t\tif (!acked) {\n\t\t\t\t\tstruct sk_buff *qskb;\n\n\t\t\t\t\tqskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t\tif (qskb) {\n\t\t\t\t\t\tskb_queue_tail(&sdata->status_queue,\n\t\t\t\t\t\t\t       qskb);\n\t\t\t\t\t\twiphy_work_queue(local->hw.wiphy,\n\t\t\t\t\t\t\t\t &sdata->work);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tieee80211_mgd_conn_tx_status(sdata,\n\t\t\t\t\t\t\t     hdr->frame_control,\n\t\t\t\t\t\t\t     acked);\n\t\t\t}\n\t\t}\n"
            }
        ],
        "early_jump_constraints": [],
        "index": 91
    },
    {
        "var_name": "elems",
        "function_name": "ieee80211_process_tdls_channel_switch_resp",
        "location": {
            "file_path": "net/mac80211/tdls.c",
            "region": {
                "startLine": 1832,
                "startColumn": 8,
                "endColumn": 13
            },
            "context": {
                "startLine": 1830,
                "endLine": 1834,
                "snippet": {
                    "text": "\tkfree(elems);"
                }
            }
        },
        "function_code": "static int\nieee80211_process_tdls_channel_switch_resp(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee802_11_elems *elems = NULL;\n\tstruct sta_info *sta;\n\tstruct ieee80211_tdls_data *tf = (void *)skb->data;\n\tbool local_initiator;\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tint baselen = offsetof(typeof(*tf), u.chan_switch_resp.variable);\n\tstruct ieee80211_tdls_ch_sw_params params = {};\n\tint ret;\n\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\tparams.action_code = WLAN_TDLS_CHANNEL_SWITCH_RESPONSE;\n\tparams.timestamp = rx_status->device_timestamp;\n\n\tif (skb->len < baselen) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch resp too short: %d\\n\",\n\t\t\t skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tsta = sta_info_get(sdata, tf->sa);\n\tif (!sta || !test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH)) {\n\t\ttdls_dbg(sdata, \"TDLS chan switch from non-peer sta %pM\\n\",\n\t\t\t tf->sa);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.sta = &sta->sta;\n\tparams.status = le16_to_cpu(tf->u.chan_switch_resp.status_code);\n\tif (params.status != 0) {\n\t\tret = 0;\n\t\tgoto call_drv;\n\t}\n\n\telems = ieee802_11_parse_elems(tf->u.chan_switch_resp.variable,\n\t\t\t\t       skb->len - baselen, false, NULL);\n\tif (!elems) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (elems->parse_error) {\n\t\ttdls_dbg(sdata, \"Invalid IEs in TDLS channel switch resp\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!elems->ch_sw_timing || !elems->lnk_id) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch resp - missing IEs\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* validate the initiator is set correctly */\n\tlocal_initiator =\n\t\t!memcmp(elems->lnk_id->init_sta, sdata->vif.addr, ETH_ALEN);\n\tif (local_initiator == sta->sta.tdls_initiator) {\n\t\ttdls_dbg(sdata, \"TDLS chan switch invalid lnk-id initiator\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tparams.switch_time = le16_to_cpu(elems->ch_sw_timing->switch_time);\n\tparams.switch_timeout = le16_to_cpu(elems->ch_sw_timing->switch_timeout);\n\n\tparams.tmpl_skb =\n\t\tieee80211_tdls_ch_sw_resp_tmpl_get(sta, &params.ch_sw_tm_ie);\n\tif (!params.tmpl_skb) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = 0;\ncall_drv:\n\tdrv_tdls_recv_channel_switch(sdata->local, sdata, &params);\n\n\ttdls_dbg(sdata,\n\t\t \"TDLS channel switch response received from %pM status %d\\n\",\n\t\t tf->sa, params.status);\n\nout:\n\tdev_kfree_skb_any(params.tmpl_skb);\n\tkfree(elems);\n\treturn ret;\n}",
        "function_list": [
            "kfree",
            "ZERO_OR_NULL_PTR",
            "ZERO_SIZE_PTR"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tkfree(elems);",
                "condition": [
                    "goto out"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct ieee802_11_elems *elems = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -EINVAL;",
                "condition": [
                    "if (skb->len < baselen)"
                ]
            },
            {
                "text": "goto call_drv;",
                "condition": [
                    "if (params.status != 0)"
                ]
            }
        ],
        "index": 92
    },
    {
        "var_name": "skb",
        "function_name": "ieee80211_tdls_channel_switch",
        "location": {
            "file_path": "net/mac80211/tdls.c",
            "region": {
                "startLine": 1666,
                "startColumn": 20,
                "endColumn": 23
            },
            "context": {
                "startLine": 1664,
                "endLine": 1668,
                "snippet": {
                    "text": "\tdev_kfree_skb_any(skb);"
                }
            }
        },
        "function_code": "int\nieee80211_tdls_channel_switch(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *addr, u8 oper_class,\n\t\t\t      struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tstruct sk_buff *skb = NULL;\n\tu32 ch_sw_tm_ie;\n\tint ret;\n\n\tlockdep_assert_wiphy(local->hw.wiphy);\n\n\tif (chandef->chan->freq_offset)\n\t\t/* this may work, but is untested */\n\t\treturn -EOPNOTSUPP;\n\n\tsta = sta_info_get(sdata, addr);\n\tif (!sta) {\n\t\ttdls_dbg(sdata,\n\t\t\t \"Invalid TDLS peer %pM for channel switch request\\n\",\n\t\t\t addr);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!test_sta_flag(sta, WLAN_STA_TDLS_CHAN_SWITCH)) {\n\t\ttdls_dbg(sdata, \"TDLS channel switch unsupported by %pM\\n\",\n\t\t\t addr);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tskb = ieee80211_tdls_ch_sw_tmpl_get(sta, oper_class, chandef,\n\t\t\t\t\t    &ch_sw_tm_ie);\n\tif (!skb) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = drv_tdls_channel_switch(local, sdata, &sta->sta, oper_class,\n\t\t\t\t      chandef, skb, ch_sw_tm_ie);\n\tif (!ret)\n\t\tset_sta_flag(sta, WLAN_STA_TDLS_OFF_CHANNEL);\n\nout:\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}",
        "function_list": [
            "dev_kfree_skb_any",
            "dev_kfree_skb_any_reason",
            "dev_kfree_skb_irq_reason",
            "kfree_skb_reason",
            "__kfree_skb_reason",
            "__kfree_skb",
            "skb_release_all"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tdev_kfree_skb_any(skb);",
                "condition": [
                    "goto out"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct sk_buff *skb = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return -EOPNOTSUPP;",
                "condition": [
                    "if (chandef->chan->freq_offset)"
                ]
            }
        ],
        "index": 93
    },
    {
        "var_name": "skb",
        "function_name": "ieee80211_tdls_prep_mgmt_packet",
        "location": {
            "file_path": "net/mac80211/tdls.c",
            "region": {
                "startLine": 1131,
                "startColumn": 16,
                "endColumn": 19
            },
            "context": {
                "startLine": 1129,
                "endLine": 1133,
                "snippet": {
                    "text": "\tdev_kfree_skb(skb);"
                }
            }
        },
        "function_code": "static int\nieee80211_tdls_prep_mgmt_packet(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tconst u8 *peer, int link_id,\n\t\t\t\tu8 action_code, u8 dialog_token,\n\t\t\t\tu16 status_code, u32 peer_capability,\n\t\t\t\tbool initiator, const u8 *extra_ies,\n\t\t\t\tsize_t extra_ies_len, u8 oper_class,\n\t\t\t\tstruct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct sk_buff *skb = NULL;\n\tstruct sta_info *sta;\n\tu32 flags = 0;\n\tint ret = 0;\n\n\trcu_read_lock();\n\tsta = sta_info_get(sdata, peer);\n\n\t/* infer the initiator if we can, to support old userspace */\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\t\tif (sta) {\n\t\t\tset_sta_flag(sta, WLAN_STA_TDLS_INITIATOR);\n\t\t\tsta->sta.tdls_initiator = false;\n\t\t}\n\t\tfallthrough;\n\tcase WLAN_TDLS_SETUP_CONFIRM:\n\tcase WLAN_TDLS_DISCOVERY_REQUEST:\n\t\tinitiator = true;\n\t\tbreak;\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\t/*\n\t\t * In some testing scenarios, we send a request and response.\n\t\t * Make the last packet sent take effect for the initiator\n\t\t * value.\n\t\t */\n\t\tif (sta) {\n\t\t\tclear_sta_flag(sta, WLAN_STA_TDLS_INITIATOR);\n\t\t\tsta->sta.tdls_initiator = true;\n\t\t}\n\t\tfallthrough;\n\tcase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\n\t\tinitiator = false;\n\t\tbreak;\n\tcase WLAN_TDLS_TEARDOWN:\n\tcase WLAN_TDLS_CHANNEL_SWITCH_REQUEST:\n\tcase WLAN_TDLS_CHANNEL_SWITCH_RESPONSE:\n\t\t/* any value is ok */\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tif (sta && test_sta_flag(sta, WLAN_STA_TDLS_INITIATOR))\n\t\tinitiator = true;\n\n\trcu_read_unlock();\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tskb = ieee80211_tdls_build_mgmt_packet_data(sdata, peer,\n\t\t\t\t\t\t    link_id, action_code,\n\t\t\t\t\t\t    dialog_token, status_code,\n\t\t\t\t\t\t    initiator, extra_ies,\n\t\t\t\t\t\t    extra_ies_len, oper_class,\n\t\t\t\t\t\t    chandef);\n\tif (!skb) {\n\t\tret = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) {\n\t\tieee80211_tx_skb_tid(sdata, skb, 7, link_id);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * According to 802.11z: Setup req/resp are sent in AC_BK, otherwise\n\t * we should default to AC_VI.\n\t */\n\tswitch (action_code) {\n\tcase WLAN_TDLS_SETUP_REQUEST:\n\tcase WLAN_TDLS_SETUP_RESPONSE:\n\t\tskb->priority = 256 + 2;\n\t\tbreak;\n\tdefault:\n\t\tskb->priority = 256 + 5;\n\t\tbreak;\n\t}\n\n\t/*\n\t * Set the WLAN_TDLS_TEARDOWN flag to indicate a teardown in progress.\n\t * Later, if no ACK is returned from peer, we will re-send the teardown\n\t * packet through the AP.\n\t */\n\tif ((action_code == WLAN_TDLS_TEARDOWN) &&\n\t    ieee80211_hw_check(&sdata->local->hw, REPORTS_TX_ACK_STATUS)) {\n\t\tbool try_resend; /* Should we keep skb for possible resend */\n\n\t\t/* If not sending directly to peer - no point in keeping skb */\n\t\trcu_read_lock();\n\t\tsta = sta_info_get(sdata, peer);\n\t\ttry_resend = sta && test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH);\n\t\trcu_read_unlock();\n\n\t\tspin_lock_bh(&sdata->u.mgd.teardown_lock);\n\t\tif (try_resend && !sdata->u.mgd.teardown_skb) {\n\t\t\t/* Mark it as requiring TX status callback  */\n\t\t\tflags |= IEEE80211_TX_CTL_REQ_TX_STATUS |\n\t\t\t\t IEEE80211_TX_INTFL_MLME_CONN_TX;\n\n\t\t\t/*\n\t\t\t * skb is copied since mac80211 will later set\n\t\t\t * properties that might not be the same as the AP,\n\t\t\t * such as encryption, QoS, addresses, etc.\n\t\t\t *\n\t\t\t * No problem if skb_copy() fails, so no need to check.\n\t\t\t */\n\t\t\tsdata->u.mgd.teardown_skb = skb_copy(skb, GFP_ATOMIC);\n\t\t\tsdata->u.mgd.orig_teardown_skb = skb;\n\t\t}\n\t\tspin_unlock_bh(&sdata->u.mgd.teardown_lock);\n\t}\n\n\t/* disable bottom halves when entering the Tx path */\n\tlocal_bh_disable();\n\t__ieee80211_subif_start_xmit(skb, dev, flags,\n\t\t\t\t     IEEE80211_TX_CTRL_MLO_LINK_UNSPEC, NULL);\n\tlocal_bh_enable();\n\n\treturn ret;\n\nfail:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}",
        "function_list": [
            "dev_kfree_skb",
            "consume_skb"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tdev_kfree_skb(skb);",
                "condition": [
                    "goto fail"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct sk_buff *skb = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return 0;",
                "condition": [
                    "if (action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES)"
                ]
            },
            {
                "text": "return ret;",
                "condition": []
            }
        ],
        "index": 94
    },
    {
        "var_name": "sta",
        "function_name": "ieee80211_tdls_add_setup_cfm_ies",
        "location": {
            "file_path": "net/mac80211/tdls.c",
            "region": {
                "startLine": 614,
                "startColumn": 2,
                "endColumn": 5
            },
            "context": {
                "startLine": 612,
                "endLine": 616,
                "snippet": {
                    "text": "\tsta->tdls_chandef = link->conf->chanreq.oper;"
                }
            }
        },
        "function_code": "static void\nieee80211_tdls_add_setup_cfm_ies(struct ieee80211_link_data *link,\n\t\t\t\t struct sk_buff *skb, const u8 *peer,\n\t\t\t\t bool initiator, const u8 *extra_ies,\n\t\t\t\t size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tsize_t offset = 0, noffset;\n\tstruct sta_info *sta, *ap_sta;\n\tstruct ieee80211_supported_band *sband;\n\tu8 *pos;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (WARN_ON_ONCE(!sband))\n\t\treturn;\n\n\tsta = sta_info_get(sdata, peer);\n\tap_sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\n\tif (WARN_ON_ONCE(!sta || !ap_sta))\n\t\treturn;\n\n\tsta->tdls_chandef = link->conf->chanreq.oper;\n\n\t/* add any custom IEs that go before the QoS IE */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_qos[] = {\n\t\t\tWLAN_EID_RSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_qos,\n\t\t\t\t\t     ARRAY_SIZE(before_qos),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* add the QoS param IE if both the peer and we support it */\n\tif (local->hw.queues >= IEEE80211_NUM_ACS && sta->sta.wme)\n\t\tieee80211_tdls_add_wmm_param_ie(sdata, skb);\n\n\t/* add any custom IEs that go before HT operation */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ht_op[] = {\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ht_op,\n\t\t\t\t\t     ARRAY_SIZE(before_ht_op),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/*\n\t * if HT support is only added in TDLS, we need an HT-operation IE.\n\t * add the IE as required by IEEE802.11-2012 9.23.3.2.\n\t */\n\tif (!ap_sta->sta.deflink.ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {\n\t\tu16 prot = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED |\n\t\t\t   IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t   IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_ht_operation));\n\t\tieee80211_ie_build_ht_oper(pos, &sta->sta.deflink.ht_cap,\n\t\t\t\t\t   &link->conf->chanreq.oper, prot,\n\t\t\t\t\t   true);\n\t}\n\n\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\t/* only include VHT-operation if not on the 2.4GHz band */\n\tif (sband->band != NL80211_BAND_2GHZ &&\n\t    sta->sta.deflink.vht_cap.vht_supported) {\n\t\t/*\n\t\t * if both peers support WIDER_BW, we can expand the chandef to\n\t\t * a wider compatible one, up to 80MHz\n\t\t */\n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW))\n\t\t\tieee80211_tdls_chandef_vht_upgrade(sdata, sta);\n\n\t\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_vht_operation));\n\t\tieee80211_ie_build_vht_oper(pos, &sta->sta.deflink.vht_cap,\n\t\t\t\t\t    &sta->tdls_chandef);\n\t}\n\n\t/* add any remaining IEs */\n\tif (extra_ies_len) {\n\t\tnoffset = extra_ies_len;\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t}\n}",
        "function_list": [
            "WARN_ON_ONCE",
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tsta->tdls_chandef = link->conf->chanreq.oper;",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!sband))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!sta || !ap_sta))"
                ]
            }
        ],
        "index": 95
    },
    {
        "var_name": "ap_sta",
        "function_name": "ieee80211_tdls_add_setup_cfm_ies",
        "location": {
            "file_path": "net/mac80211/tdls.c",
            "region": {
                "startLine": 653,
                "startColumn": 7,
                "endColumn": 13
            },
            "context": {
                "startLine": 651,
                "endLine": 655,
                "snippet": {
                    "text": "\tif (!ap_sta->sta.deflink.ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {"
                }
            }
        },
        "function_code": "static void\nieee80211_tdls_add_setup_cfm_ies(struct ieee80211_link_data *link,\n\t\t\t\t struct sk_buff *skb, const u8 *peer,\n\t\t\t\t bool initiator, const u8 *extra_ies,\n\t\t\t\t size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tsize_t offset = 0, noffset;\n\tstruct sta_info *sta, *ap_sta;\n\tstruct ieee80211_supported_band *sband;\n\tu8 *pos;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (WARN_ON_ONCE(!sband))\n\t\treturn;\n\n\tsta = sta_info_get(sdata, peer);\n\tap_sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\n\tif (WARN_ON_ONCE(!sta || !ap_sta))\n\t\treturn;\n\n\tsta->tdls_chandef = link->conf->chanreq.oper;\n\n\t/* add any custom IEs that go before the QoS IE */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_qos[] = {\n\t\t\tWLAN_EID_RSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_qos,\n\t\t\t\t\t     ARRAY_SIZE(before_qos),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* add the QoS param IE if both the peer and we support it */\n\tif (local->hw.queues >= IEEE80211_NUM_ACS && sta->sta.wme)\n\t\tieee80211_tdls_add_wmm_param_ie(sdata, skb);\n\n\t/* add any custom IEs that go before HT operation */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ht_op[] = {\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ht_op,\n\t\t\t\t\t     ARRAY_SIZE(before_ht_op),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/*\n\t * if HT support is only added in TDLS, we need an HT-operation IE.\n\t * add the IE as required by IEEE802.11-2012 9.23.3.2.\n\t */\n\tif (!ap_sta->sta.deflink.ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {\n\t\tu16 prot = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED |\n\t\t\t   IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t   IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_ht_operation));\n\t\tieee80211_ie_build_ht_oper(pos, &sta->sta.deflink.ht_cap,\n\t\t\t\t\t   &link->conf->chanreq.oper, prot,\n\t\t\t\t\t   true);\n\t}\n\n\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\t/* only include VHT-operation if not on the 2.4GHz band */\n\tif (sband->band != NL80211_BAND_2GHZ &&\n\t    sta->sta.deflink.vht_cap.vht_supported) {\n\t\t/*\n\t\t * if both peers support WIDER_BW, we can expand the chandef to\n\t\t * a wider compatible one, up to 80MHz\n\t\t */\n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW))\n\t\t\tieee80211_tdls_chandef_vht_upgrade(sdata, sta);\n\n\t\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_vht_operation));\n\t\tieee80211_ie_build_vht_oper(pos, &sta->sta.deflink.vht_cap,\n\t\t\t\t\t    &sta->tdls_chandef);\n\t}\n\n\t/* add any remaining IEs */\n\tif (extra_ies_len) {\n\t\tnoffset = extra_ies_len;\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t}\n}",
        "function_list": [
            "WARN_ON_ONCE",
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tif (!ap_sta->sta.deflink.ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!sband))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!sta || !ap_sta))"
                ]
            }
        ],
        "index": 96
    },
    {
        "var_name": "sband",
        "function_name": "ieee80211_tdls_add_setup_cfm_ies",
        "location": {
            "file_path": "net/mac80211/tdls.c",
            "region": {
                "startLine": 667,
                "startColumn": 6,
                "endColumn": 11
            },
            "context": {
                "startLine": 665,
                "endLine": 669,
                "snippet": {
                    "text": "\tif (sband->band != NL80211_BAND_2GHZ &&"
                }
            }
        },
        "function_code": "static void\nieee80211_tdls_add_setup_cfm_ies(struct ieee80211_link_data *link,\n\t\t\t\t struct sk_buff *skb, const u8 *peer,\n\t\t\t\t bool initiator, const u8 *extra_ies,\n\t\t\t\t size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_local *local = sdata->local;\n\tsize_t offset = 0, noffset;\n\tstruct sta_info *sta, *ap_sta;\n\tstruct ieee80211_supported_band *sband;\n\tu8 *pos;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (WARN_ON_ONCE(!sband))\n\t\treturn;\n\n\tsta = sta_info_get(sdata, peer);\n\tap_sta = sta_info_get(sdata, sdata->vif.cfg.ap_addr);\n\n\tif (WARN_ON_ONCE(!sta || !ap_sta))\n\t\treturn;\n\n\tsta->tdls_chandef = link->conf->chanreq.oper;\n\n\t/* add any custom IEs that go before the QoS IE */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_qos[] = {\n\t\t\tWLAN_EID_RSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_qos,\n\t\t\t\t\t     ARRAY_SIZE(before_qos),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* add the QoS param IE if both the peer and we support it */\n\tif (local->hw.queues >= IEEE80211_NUM_ACS && sta->sta.wme)\n\t\tieee80211_tdls_add_wmm_param_ie(sdata, skb);\n\n\t/* add any custom IEs that go before HT operation */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ht_op[] = {\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ht_op,\n\t\t\t\t\t     ARRAY_SIZE(before_ht_op),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/*\n\t * if HT support is only added in TDLS, we need an HT-operation IE.\n\t * add the IE as required by IEEE802.11-2012 9.23.3.2.\n\t */\n\tif (!ap_sta->sta.deflink.ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {\n\t\tu16 prot = IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED |\n\t\t\t   IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT |\n\t\t\t   IEEE80211_HT_OP_MODE_NON_HT_STA_PRSNT;\n\n\t\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_ht_operation));\n\t\tieee80211_ie_build_ht_oper(pos, &sta->sta.deflink.ht_cap,\n\t\t\t\t\t   &link->conf->chanreq.oper, prot,\n\t\t\t\t\t   true);\n\t}\n\n\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\t/* only include VHT-operation if not on the 2.4GHz band */\n\tif (sband->band != NL80211_BAND_2GHZ &&\n\t    sta->sta.deflink.vht_cap.vht_supported) {\n\t\t/*\n\t\t * if both peers support WIDER_BW, we can expand the chandef to\n\t\t * a wider compatible one, up to 80MHz\n\t\t */\n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW))\n\t\t\tieee80211_tdls_chandef_vht_upgrade(sdata, sta);\n\n\t\tpos = skb_put(skb, 2 + sizeof(struct ieee80211_vht_operation));\n\t\tieee80211_ie_build_vht_oper(pos, &sta->sta.deflink.vht_cap,\n\t\t\t\t\t    &sta->tdls_chandef);\n\t}\n\n\t/* add any remaining IEs */\n\tif (extra_ies_len) {\n\t\tnoffset = extra_ies_len;\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t}\n}",
        "function_list": [
            "WARN_ON_ONCE",
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tif (sband->band != NL80211_BAND_2GHZ &&",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!sband))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!sta || !ap_sta))"
                ]
            }
        ],
        "index": 97
    },
    {
        "var_name": "sta",
        "function_name": "ieee80211_tdls_add_setup_start_ies",
        "location": {
            "file_path": "net/mac80211/tdls.c",
            "region": {
                "startLine": 441,
                "startColumn": 3,
                "endColumn": 6
            },
            "context": {
                "startLine": 439,
                "endLine": 443,
                "snippet": {
                    "text": "\t\tsta->tdls_chandef = link->conf->chanreq.oper;"
                }
            }
        },
        "function_code": "static void\nieee80211_tdls_add_setup_start_ies(struct ieee80211_link_data *link,\n\t\t\t\t   struct sk_buff *skb, const u8 *peer,\n\t\t\t\t   u8 action_code, bool initiator,\n\t\t\t\t   const u8 *extra_ies, size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tstruct sta_info *sta = NULL;\n\tsize_t offset = 0, noffset;\n\tu8 *pos;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (WARN_ON_ONCE(!sband))\n\t\treturn;\n\n\tieee80211_put_srates_elem(skb, sband, 0, 0, 0, WLAN_EID_SUPP_RATES);\n\tieee80211_put_srates_elem(skb, sband, 0, 0, 0, WLAN_EID_EXT_SUPP_RATES);\n\tieee80211_tdls_add_supp_channels(sdata, skb);\n\n\t/* add any custom IEs that go before Extended Capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ext_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ext_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_ext_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\tieee80211_tdls_add_ext_capab(link, skb);\n\n\t/* add the QoS element if we support it */\n\tif (local->hw.queues >= IEEE80211_NUM_ACS &&\n\t    action_code != WLAN_PUB_ACTION_TDLS_DISCOVER_RES)\n\t\tieee80211_add_wmm_info_ie(skb_put(skb, 9), 0); /* no U-APSD */\n\n\t/* add any custom IEs that go before HT capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ht_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_EXT_CAPABILITY,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ht_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_ht_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* we should have the peer STA if we're already responding */\n\tif (action_code == WLAN_TDLS_SETUP_RESPONSE) {\n\t\tsta = sta_info_get(sdata, peer);\n\t\tif (WARN_ON_ONCE(!sta))\n\t\t\treturn;\n\n\t\tsta->tdls_chandef = link->conf->chanreq.oper;\n\t}\n\n\tieee80211_tdls_add_oper_classes(link, skb);\n\n\t/*\n\t * with TDLS we can switch channels, and HT-caps are not necessarily\n\t * the same on all bands. The specification limits the setup to a\n\t * single HT-cap, so use the current band for now.\n\t */\n\tmemcpy(&ht_cap, &sband->ht_cap, sizeof(ht_cap));\n\n\tif ((action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) &&\n\t    ht_cap.ht_supported) {\n\t\tieee80211_apply_htcap_overrides(sdata, &ht_cap);\n\n\t\t/* disable SMPS in TDLS initiator */\n\t\tht_cap.cap |= WLAN_HT_CAP_SM_PS_DISABLED\n\t\t\t\t<< IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\tieee80211_ie_build_ht_cap(pos, &ht_cap, ht_cap.cap);\n\t} else if (action_code == WLAN_TDLS_SETUP_RESPONSE &&\n\t\t   ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {\n\t\t/* the peer caps are already intersected with our own */\n\t\tmemcpy(&ht_cap, &sta->sta.deflink.ht_cap, sizeof(ht_cap));\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\tieee80211_ie_build_ht_cap(pos, &ht_cap, ht_cap.cap);\n\t}\n\n\tif (ht_cap.ht_supported &&\n\t    (ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40))\n\t\tieee80211_tdls_add_bss_coex_ie(skb);\n\n\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\t/* add any custom IEs that go before VHT capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_vht_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_EXT_CAPABILITY,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\t\tWLAN_EID_MULTI_BAND,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_vht_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_vht_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* add AID if VHT, HE or EHT capabilities supported */\n\tmemcpy(&vht_cap, &sband->vht_cap, sizeof(vht_cap));\n\the_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\teht_cap = ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);\n\tif ((vht_cap.vht_supported || he_cap || eht_cap) &&\n\t    (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_TDLS_SETUP_RESPONSE))\n\t\tieee80211_tdls_add_aid(sdata, skb);\n\n\t/* build the VHT-cap similarly to the HT-cap */\n\tif ((action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) &&\n\t    vht_cap.vht_supported) {\n\t\tieee80211_apply_vhtcap_overrides(sdata, &vht_cap);\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\n\t\tieee80211_ie_build_vht_cap(pos, &vht_cap, vht_cap.cap);\n\t} else if (action_code == WLAN_TDLS_SETUP_RESPONSE &&\n\t\t   vht_cap.vht_supported && sta->sta.deflink.vht_cap.vht_supported) {\n\t\t/* the peer caps are already intersected with our own */\n\t\tmemcpy(&vht_cap, &sta->sta.deflink.vht_cap, sizeof(vht_cap));\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\n\t\tieee80211_ie_build_vht_cap(pos, &vht_cap, vht_cap.cap);\n\n\t\t/*\n\t\t * if both peers support WIDER_BW, we can expand the chandef to\n\t\t * a wider compatible one, up to 80MHz\n\t\t */\n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW))\n\t\t\tieee80211_tdls_chandef_vht_upgrade(sdata, sta);\n\t}\n\n\t/* add any custom IEs that go before HE capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_he_cap[] = {\n\t\t\tWLAN_EID_EXTENSION,\n\t\t\tWLAN_EID_EXT_FILS_REQ_PARAMS,\n\t\t\tWLAN_EID_AP_CSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_he_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_he_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* build the HE-cap from sband */\n\tif (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t    action_code == WLAN_TDLS_SETUP_RESPONSE ||\n\t    action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) {\n\t\tieee80211_put_he_cap(skb, sdata, sband, NULL);\n\n\t\t/* Build HE 6Ghz capa IE from sband */\n\t\tif (sband->band == NL80211_BAND_6GHZ)\n\t\t\tieee80211_put_he_6ghz_cap(skb, sdata, link->smps_mode);\n\t}\n\n\t/* add any custom IEs that go before EHT capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_he_cap[] = {\n\t\t\tWLAN_EID_EXTENSION,\n\t\t\tWLAN_EID_EXT_FILS_REQ_PARAMS,\n\t\t\tWLAN_EID_AP_CSN,\n\t\t};\n\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_he_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_he_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* build the EHT-cap from sband */\n\tif (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t    action_code == WLAN_TDLS_SETUP_RESPONSE ||\n\t    action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES)\n\t\tieee80211_put_eht_cap(skb, sdata, sband, NULL);\n\n\t/* add any remaining IEs */\n\tif (extra_ies_len) {\n\t\tnoffset = extra_ies_len;\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t}\n\n}",
        "function_list": [
            "WARN_ON_ONCE",
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\t\tsta->tdls_chandef = link->conf->chanreq.oper;",
                "condition": [
                    "if (action_code == WLAN_TDLS_SETUP_RESPONSE)"
                ]
            }
        ],
        "var_assign_conditions": [
            {
                "text": "struct sta_info *sta = NULL;",
                "condition": []
            }
        ],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!sband))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (action_code == WLAN_TDLS_SETUP_RESPONSE)",
                    "if (WARN_ON_ONCE(!sta))"
                ]
            }
        ],
        "index": 98
    },
    {
        "var_name": "sband",
        "function_name": "ieee80211_tdls_add_setup_start_ies",
        "location": {
            "file_path": "net/mac80211/tdls.c",
            "region": {
                "startLine": 451,
                "startColumn": 19,
                "endColumn": 24
            },
            "context": {
                "startLine": 449,
                "endLine": 453,
                "snippet": {
                    "text": "\tmemcpy(&ht_cap, &sband->ht_cap, sizeof(ht_cap));"
                }
            }
        },
        "function_code": "static void\nieee80211_tdls_add_setup_start_ies(struct ieee80211_link_data *link,\n\t\t\t\t   struct sk_buff *skb, const u8 *peer,\n\t\t\t\t   u8 action_code, bool initiator,\n\t\t\t\t   const u8 *extra_ies, size_t extra_ies_len)\n{\n\tstruct ieee80211_sub_if_data *sdata = link->sdata;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\tconst struct ieee80211_sta_eht_cap *eht_cap;\n\tstruct sta_info *sta = NULL;\n\tsize_t offset = 0, noffset;\n\tu8 *pos;\n\n\tsband = ieee80211_get_link_sband(link);\n\tif (WARN_ON_ONCE(!sband))\n\t\treturn;\n\n\tieee80211_put_srates_elem(skb, sband, 0, 0, 0, WLAN_EID_SUPP_RATES);\n\tieee80211_put_srates_elem(skb, sband, 0, 0, 0, WLAN_EID_EXT_SUPP_RATES);\n\tieee80211_tdls_add_supp_channels(sdata, skb);\n\n\t/* add any custom IEs that go before Extended Capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ext_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ext_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_ext_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\tieee80211_tdls_add_ext_capab(link, skb);\n\n\t/* add the QoS element if we support it */\n\tif (local->hw.queues >= IEEE80211_NUM_ACS &&\n\t    action_code != WLAN_PUB_ACTION_TDLS_DISCOVER_RES)\n\t\tieee80211_add_wmm_info_ie(skb_put(skb, 9), 0); /* no U-APSD */\n\n\t/* add any custom IEs that go before HT capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_ht_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_EXT_CAPABILITY,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_ht_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_ht_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* we should have the peer STA if we're already responding */\n\tif (action_code == WLAN_TDLS_SETUP_RESPONSE) {\n\t\tsta = sta_info_get(sdata, peer);\n\t\tif (WARN_ON_ONCE(!sta))\n\t\t\treturn;\n\n\t\tsta->tdls_chandef = link->conf->chanreq.oper;\n\t}\n\n\tieee80211_tdls_add_oper_classes(link, skb);\n\n\t/*\n\t * with TDLS we can switch channels, and HT-caps are not necessarily\n\t * the same on all bands. The specification limits the setup to a\n\t * single HT-cap, so use the current band for now.\n\t */\n\tmemcpy(&ht_cap, &sband->ht_cap, sizeof(ht_cap));\n\n\tif ((action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) &&\n\t    ht_cap.ht_supported) {\n\t\tieee80211_apply_htcap_overrides(sdata, &ht_cap);\n\n\t\t/* disable SMPS in TDLS initiator */\n\t\tht_cap.cap |= WLAN_HT_CAP_SM_PS_DISABLED\n\t\t\t\t<< IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\tieee80211_ie_build_ht_cap(pos, &ht_cap, ht_cap.cap);\n\t} else if (action_code == WLAN_TDLS_SETUP_RESPONSE &&\n\t\t   ht_cap.ht_supported && sta->sta.deflink.ht_cap.ht_supported) {\n\t\t/* the peer caps are already intersected with our own */\n\t\tmemcpy(&ht_cap, &sta->sta.deflink.ht_cap, sizeof(ht_cap));\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\n\t\tieee80211_ie_build_ht_cap(pos, &ht_cap, ht_cap.cap);\n\t}\n\n\tif (ht_cap.ht_supported &&\n\t    (ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40))\n\t\tieee80211_tdls_add_bss_coex_ie(skb);\n\n\tieee80211_tdls_add_link_ie(link, skb, peer, initiator);\n\n\t/* add any custom IEs that go before VHT capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_vht_cap[] = {\n\t\t\tWLAN_EID_SUPP_RATES,\n\t\t\tWLAN_EID_COUNTRY,\n\t\t\tWLAN_EID_EXT_SUPP_RATES,\n\t\t\tWLAN_EID_SUPPORTED_CHANNELS,\n\t\t\tWLAN_EID_RSN,\n\t\t\tWLAN_EID_EXT_CAPABILITY,\n\t\t\tWLAN_EID_QOS_CAPA,\n\t\t\tWLAN_EID_FAST_BSS_TRANSITION,\n\t\t\tWLAN_EID_TIMEOUT_INTERVAL,\n\t\t\tWLAN_EID_SUPPORTED_REGULATORY_CLASSES,\n\t\t\tWLAN_EID_MULTI_BAND,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_vht_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_vht_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* add AID if VHT, HE or EHT capabilities supported */\n\tmemcpy(&vht_cap, &sband->vht_cap, sizeof(vht_cap));\n\the_cap = ieee80211_get_he_iftype_cap_vif(sband, &sdata->vif);\n\teht_cap = ieee80211_get_eht_iftype_cap_vif(sband, &sdata->vif);\n\tif ((vht_cap.vht_supported || he_cap || eht_cap) &&\n\t    (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_TDLS_SETUP_RESPONSE))\n\t\tieee80211_tdls_add_aid(sdata, skb);\n\n\t/* build the VHT-cap similarly to the HT-cap */\n\tif ((action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t     action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) &&\n\t    vht_cap.vht_supported) {\n\t\tieee80211_apply_vhtcap_overrides(sdata, &vht_cap);\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\n\t\tieee80211_ie_build_vht_cap(pos, &vht_cap, vht_cap.cap);\n\t} else if (action_code == WLAN_TDLS_SETUP_RESPONSE &&\n\t\t   vht_cap.vht_supported && sta->sta.deflink.vht_cap.vht_supported) {\n\t\t/* the peer caps are already intersected with our own */\n\t\tmemcpy(&vht_cap, &sta->sta.deflink.vht_cap, sizeof(vht_cap));\n\n\t\tpos = skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\n\t\tieee80211_ie_build_vht_cap(pos, &vht_cap, vht_cap.cap);\n\n\t\t/*\n\t\t * if both peers support WIDER_BW, we can expand the chandef to\n\t\t * a wider compatible one, up to 80MHz\n\t\t */\n\t\tif (test_sta_flag(sta, WLAN_STA_TDLS_WIDER_BW))\n\t\t\tieee80211_tdls_chandef_vht_upgrade(sdata, sta);\n\t}\n\n\t/* add any custom IEs that go before HE capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_he_cap[] = {\n\t\t\tWLAN_EID_EXTENSION,\n\t\t\tWLAN_EID_EXT_FILS_REQ_PARAMS,\n\t\t\tWLAN_EID_AP_CSN,\n\t\t};\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_he_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_he_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* build the HE-cap from sband */\n\tif (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t    action_code == WLAN_TDLS_SETUP_RESPONSE ||\n\t    action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES) {\n\t\tieee80211_put_he_cap(skb, sdata, sband, NULL);\n\n\t\t/* Build HE 6Ghz capa IE from sband */\n\t\tif (sband->band == NL80211_BAND_6GHZ)\n\t\t\tieee80211_put_he_6ghz_cap(skb, sdata, link->smps_mode);\n\t}\n\n\t/* add any custom IEs that go before EHT capabilities */\n\tif (extra_ies_len) {\n\t\tstatic const u8 before_he_cap[] = {\n\t\t\tWLAN_EID_EXTENSION,\n\t\t\tWLAN_EID_EXT_FILS_REQ_PARAMS,\n\t\t\tWLAN_EID_AP_CSN,\n\t\t};\n\n\t\tnoffset = ieee80211_ie_split(extra_ies, extra_ies_len,\n\t\t\t\t\t     before_he_cap,\n\t\t\t\t\t     ARRAY_SIZE(before_he_cap),\n\t\t\t\t\t     offset);\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t\toffset = noffset;\n\t}\n\n\t/* build the EHT-cap from sband */\n\tif (action_code == WLAN_TDLS_SETUP_REQUEST ||\n\t    action_code == WLAN_TDLS_SETUP_RESPONSE ||\n\t    action_code == WLAN_PUB_ACTION_TDLS_DISCOVER_RES)\n\t\tieee80211_put_eht_cap(skb, sdata, sband, NULL);\n\n\t/* add any remaining IEs */\n\tif (extra_ies_len) {\n\t\tnoffset = extra_ies_len;\n\t\tskb_put_data(skb, extra_ies + offset, noffset - offset);\n\t}\n\n}",
        "function_list": [
            "WARN_ON_ONCE",
            "WARN_ON"
        ],
        "result": 0,
        "bug_line_constraints": [
            {
                "text": "\tmemcpy(&ht_cap, &sband->ht_cap, sizeof(ht_cap));",
                "condition": []
            }
        ],
        "var_assign_conditions": [],
        "pointer_null_postconditions": [],
        "early_jump_constraints": [
            {
                "text": "return;",
                "condition": [
                    "if (WARN_ON_ONCE(!sband))"
                ]
            },
            {
                "text": "return;",
                "condition": [
                    "if (action_code == WLAN_TDLS_SETUP_RESPONSE)",
                    "if (WARN_ON_ONCE(!sta))"
                ]
            }
        ],
        "index": 99
    }
]