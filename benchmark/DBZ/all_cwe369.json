[
    {
        "prt": "pck_min",
        "function_call": [
            "bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n\t\t    unsigned long pck_min, unsigned long pck_max,\n\t\t    dispc_div_calc_func func, void *data)\n{\n\tint lckd, lckd_start, lckd_stop;\n\tint pckd, pckd_start, pckd_stop;\n\tunsigned long pck, lck;\n\tunsigned long lck_max;\n\tunsigned long pckd_hw_min, pckd_hw_max;\n\tunsigned int min_fck_per_pck;\n\tunsigned long fck;\n\n#ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n\tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n#else\n\tmin_fck_per_pck = 0;\n#endif\n\n\tpckd_hw_min = dispc->feat->min_pcd;\n\tpckd_hw_max = 255;\n\n\tlck_max = dss_get_max_fck_rate(dispc->dss);\n\n\tpck_min = pck_min ? pck_min : 1;\n\tpck_max = pck_max ? pck_max : ULONG_MAX;\n\n\tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n\tlckd_stop = min(dispc_freq / pck_min, 255ul);\n\n\tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n\t\tlck = dispc_freq / lckd;\n\n\t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n\t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n\n\t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n\t\t\tpck = lck / pckd;\n\n\t\t\t/*\n\t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n\t\t\t * clock, which means we're configuring DISPC fclk here\n\t\t\t * also. Thus we need to use the calculated lck. For\n\t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n\t\t\t */\n\t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n\t\t\t\tfck = dispc_core_clk_rate(dispc);\n\t\t\telse\n\t\t\t\tfck = lck;\n\n\t\t\tif (fck < pck * min_fck_per_pck)\n\t\t\t\tcontinue;\n\n\t\t\tif (func(lckd, pckd, lck, pck, data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        ],
        "source": [
            "      pck_min = pck_min ? pck_min : 1;"
        ],
        "index": 0,
        "location": {
            "file_path": "linux-6.9.6/drivers/gpu/drm/omapdrm/dss/dispc.c",
            "region": {
                "startLine": 3701,
                "startColumn": 29,
                "endColumn": 29
            },
            "context": {
                "startLine": 3699,
                "endLine": 3703,
                "snippet": {
                    "text": "lckd_stop = min(dispc_freq / pck_min, 255ul);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dsi.c",
                        "function_body": "4423 static bool dsi_cm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n4424 \t\tvoid *data)\n4425 {\n4426 \tstruct dsi_clk_calc_ctx *ctx = data;\n4427\n4428 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n4429 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n4430\n4431 \treturn dispc_div_calc(dispc, ctx->req_pck_min, ctx->req_pck_max,\n4432 \t\t\tdsi_cm_calc_dispc_cb, ctx);\n4433 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dpi.c",
                        "function_body": "208 static bool dpi_calc_dss_cb(unsigned long fck, void *data)\n209 {\n210 \tstruct dpi_clk_calc_ctx *ctx = data;\n211\n212 \tctx->fck = fck;\n213\n214 \treturn dispc_div_calc(ctx->dpi->dss->dispc, fck,\n215 \t\t\t      ctx->pck_min, ctx->pck_max,\n216 \t\t\t      dpi_calc_dispc_cb, ctx);\n217 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dpi.c",
                        "function_body": "209 static bool dpi_calc_dss_cb(unsigned long fck, void *data)\n210 {\n211 \tstruct dpi_clk_calc_ctx *ctx = data;\n212\n213 \tctx->fck = fck;\n214\n215 \treturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\n216 \t\t\tdpi_calc_dispc_cb, ctx);\n217 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dpi.c",
                        "function_body": "172 static bool dpi_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n173 \t\tvoid *data)\n174 {\n175 \tstruct dpi_clk_calc_ctx *ctx = data;\n176\n177 \t/*\n178 \t * Odd dividers give us uneven duty cycle, causing problem when level\n179 \t * shifted. So skip all odd dividers when the pixel clock is on the\n180 \t * higher side.\n181 \t */\n182 \tif (m_dispc > 1 && m_dispc % 2 != 0 && ctx->pck_min >= 100000000)\n183 \t\treturn false;\n184\n185 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n186 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n187\n188 \treturn dispc_div_calc(dispc, ctx->pck_min, ctx->pck_max,\n189 \t\t\tdpi_calc_dispc_cb, ctx);\n190 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/sdi.c",
                        "function_body": "59 static bool dpi_calc_dss_cb(unsigned long fck, void *data)\n60 {\n61 \tstruct sdi_clk_calc_ctx *ctx = data;\n62\n63 \tctx->fck = fck;\n64\n65 \treturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\n66 \t\t\tdpi_calc_dispc_cb, ctx);\n67 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dpi.c",
                        "function_body": "178 static bool dpi_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n179 \t\tvoid *data)\n180 {\n181 \tstruct dpi_clk_calc_ctx *ctx = data;\n182\n183 \tctx->pll_cinfo.mX[ctx->clkout_idx] = m_dispc;\n184 \tctx->pll_cinfo.clkout[ctx->clkout_idx] = dispc;\n185\n186 \treturn dispc_div_calc(ctx->dpi->dss->dispc, dispc,\n187 \t\t\t      ctx->pck_min, ctx->pck_max,\n188 \t\t\t      dpi_calc_dispc_cb, ctx);\n189 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dsi.c",
                        "function_body": "3971 static bool dsi_vm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n3972 \t\tvoid *data)\n3973 {\n3974 \tstruct dsi_clk_calc_ctx *ctx = data;\n3975 \tunsigned long pck_max;\n3976\n3977 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n3978 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n3979\n3980 \t/*\n3981 \t * In burst mode we can let the dispc pck be arbitrarily high, but it\n3982 \t * limits our scaling abilities. So for now, don't aim too high.\n3983 \t */\n3984\n3985 \tif (ctx->config->trans_mode == OMAP_DSS_DSI_BURST_MODE)\n3986 \t\tpck_max = ctx->req_pck_max + 10000000;\n3987 \telse\n3988 \t\tpck_max = ctx->req_pck_max;\n3989\n3990 \treturn dispc_div_calc(ctx->dsi->dss->dispc, dispc,\n3991 \t\t\t      ctx->req_pck_min, pck_max,\n3992 \t\t\t      dsi_vm_calc_dispc_cb, ctx);\n3993 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dsi.c",
                        "function_body": "3682 static bool dsi_cm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n3683 \t\tvoid *data)\n3684 {\n3685 \tstruct dsi_clk_calc_ctx *ctx = data;\n3686\n3687 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n3688 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n3689\n3690 \treturn dispc_div_calc(ctx->dsi->dss->dispc, dispc,\n3691 \t\t\t      ctx->req_pck_min, ctx->req_pck_max,\n3692 \t\t\t      dsi_cm_calc_dispc_cb, ctx);\n3693 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/sdi.c",
                        "function_body": "62 static bool dpi_calc_dss_cb(unsigned long fck, void *data)\n63 {\n64 \tstruct sdi_clk_calc_ctx *ctx = data;\n65\n66 \tctx->fck = fck;\n67\n68 \treturn dispc_div_calc(ctx->sdi->dss->dispc, fck,\n69 \t\t\t      ctx->pck_min, ctx->pck_max,\n70 \t\t\t      dpi_calc_dispc_cb, ctx);\n71 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dispc.c",
                        "function_body": "3674 bool dispc_div_calc(struct dispc_device *dispc, unsigned long dispc_freq,\n3675 \t\t    unsigned long pck_min, unsigned long pck_max,\n3676 \t\t    dispc_div_calc_func func, void *data)\n3677 {\n3678 \tint lckd, lckd_start, lckd_stop;\n3679 \tint pckd, pckd_start, pckd_stop;\n3680 \tunsigned long pck, lck;\n3681 \tunsigned long lck_max;\n3682 \tunsigned long pckd_hw_min, pckd_hw_max;\n3683 \tunsigned int min_fck_per_pck;\n3684 \tunsigned long fck;\n3685\n3686 #ifdef CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK\n3687 \tmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\n3688 #else\n3689 \tmin_fck_per_pck = 0;\n3690 #endif\n3691\n3692 \tpckd_hw_min = dispc->feat->min_pcd;\n3693 \tpckd_hw_max = 255;\n3694\n3695 \tlck_max = dss_get_max_fck_rate(dispc->dss);\n3696\n3697 \tpck_min = pck_min ? pck_min : 1;\n3698 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3699\n3700 \tlckd_start = max(DIV_ROUND_UP(dispc_freq, lck_max), 1ul);\n3701 \tlckd_stop = min(dispc_freq / pck_min, 255ul);\n3702\n3703 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3704 \t\tlck = dispc_freq / lckd;\n3705\n3706 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3707 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3708\n3709 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3710 \t\t\tpck = lck / pckd;\n3711\n3712 \t\t\t/*\n3713 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3714 \t\t\t * clock, which means we're configuring DISPC fclk here\n3715 \t\t\t * also. Thus we need to use the calculated lck. For\n3716 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3717 \t\t\t */\n3718 \t\t\tif (dispc_has_feature(dispc, FEAT_CORE_CLK_DIV))\n3719 \t\t\t\tfck = dispc_core_clk_rate(dispc);\n3720 \t\t\telse\n3721 \t\t\t\tfck = lck;\n3722\n3723 \t\t\tif (fck < pck * min_fck_per_pck)\n3724 \t\t\t\tcontinue;\n3725\n3726 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3727 \t\t\t\treturn true;\n3728 \t\t}\n3729 \t}\n3730\n3731 \treturn false;\n3732 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dsi.c",
                        "function_body": "4710 static bool dsi_vm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n4711 \t\tvoid *data)\n4712 {\n4713 \tstruct dsi_clk_calc_ctx *ctx = data;\n4714 \tunsigned long pck_max;\n4715\n4716 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n4717 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n4718\n4719 \t/*\n4720 \t * In burst mode we can let the dispc pck be arbitrarily high, but it\n4721 \t * limits our scaling abilities. So for now, don't aim too high.\n4722 \t */\n4723\n4724 \tif (ctx->config->trans_mode == OMAP_DSS_DSI_BURST_MODE)\n4725 \t\tpck_max = ctx->req_pck_max + 10000000;\n4726 \telse\n4727 \t\tpck_max = ctx->req_pck_max;\n4728\n4729 \treturn dispc_div_calc(dispc, ctx->req_pck_min, pck_max,\n4730 \t\t\tdsi_vm_calc_dispc_cb, ctx);\n4731 }"
                    }
                ]
            }
        ],
        "sink": "lckd_stop = min(dispc_freq / pck_min, 255ul);",
        "final_sink": "lckd_stop = min(dispc_freq / pck_min, 255ul);"
    },
    {
        "prt": "fck_min",
        "function_call": [
            "bool dss_div_calc(struct dss_device *dss, unsigned long pck,\n\t\t  unsigned long fck_min, dss_div_calc_func func, void *data)\n{\n\tint fckd, fckd_start, fckd_stop;\n\tunsigned long fck;\n\tunsigned long fck_hw_max;\n\tunsigned long fckd_hw_max;\n\tunsigned long prate;\n\tunsigned int m;\n\n\tfck_hw_max = dss->feat->fck_freq_max;\n\n\tif (dss->parent_clk == NULL) {\n\t\tunsigned int pckd;\n\n\t\tpckd = fck_hw_max / pck;\n\n\t\tfck = pck * pckd;\n\n\t\tfck = clk_round_rate(dss->dss_clk, fck);\n\n\t\treturn func(fck, data);\n\t}\n\n\tfckd_hw_max = dss->feat->fck_div_max;\n\n\tm = dss->feat->dss_fck_multiplier;\n\tprate = clk_get_rate(dss->parent_clk);\n\n\tfck_min = fck_min ? fck_min : 1;\n\n\tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n\tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n\n\tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n\t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n\n\t\tif (func(fck, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        ],
        "source": [
            "        fck_min = fck_min ? fck_min : 1;"
        ],
        "index": 1,
        "location": {
            "file_path": "linux-6.9.6/drivers/gpu/drm/omapdrm/dss/dss.c",
            "region": {
                "startLine": 630,
                "startColumn": 29,
                "endColumn": 29
            },
            "context": {
                "startLine": 628,
                "endLine": 632,
                "snippet": {
                    "text": "fckd_start = min(prate * m / fck_min, fckd_hw_max);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dss.c",
                        "function_body": "599 bool dss_div_calc(struct dss_device *dss, unsigned long pck,\n600 \t\t  unsigned long fck_min, dss_div_calc_func func, void *data)\n601 {\n602 \tint fckd, fckd_start, fckd_stop;\n603 \tunsigned long fck;\n604 \tunsigned long fck_hw_max;\n605 \tunsigned long fckd_hw_max;\n606 \tunsigned long prate;\n607 \tunsigned int m;\n608\n609 \tfck_hw_max = dss->feat->fck_freq_max;\n610\n611 \tif (dss->parent_clk == NULL) {\n612 \t\tunsigned int pckd;\n613\n614 \t\tpckd = fck_hw_max / pck;\n615\n616 \t\tfck = pck * pckd;\n617\n618 \t\tfck = clk_round_rate(dss->dss_clk, fck);\n619\n620 \t\treturn func(fck, data);\n621 \t}\n622\n623 \tfckd_hw_max = dss->feat->fck_div_max;\n624\n625 \tm = dss->feat->dss_fck_multiplier;\n626 \tprate = clk_get_rate(dss->parent_clk);\n627\n628 \tfck_min = fck_min ? fck_min : 1;\n629\n630 \tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n631 \tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n632\n633 \tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n634 \t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n635\n636 \t\tif (func(fck, data))\n637 \t\t\treturn true;\n638 \t}\n639\n640 \treturn false;\n641 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/sdi.c",
                        "function_body": "73 static int sdi_calc_clock_div(struct sdi_device *sdi, unsigned long pclk,\n74 \t\t\t      unsigned long *fck,\n75 \t\t\t      struct dispc_clock_info *dispc_cinfo)\n76 {\n77 \tint i;\n78 \tstruct sdi_clk_calc_ctx ctx;\n79\n80 \t/*\n81 \t * DSS fclk gives us very few possibilities, so finding a good pixel\n82 \t * clock may not be possible. We try multiple times to find the clock,\n83 \t * each time widening the pixel clock range we look for, up to\n84 \t * +/- 1MHz.\n85 \t */\n86\n87 \tfor (i = 0; i < 10; ++i) {\n88 \t\tbool ok;\n89\n90 \t\tmemset(&ctx, 0, sizeof(ctx));\n91\n92 \t\tctx.sdi = sdi;\n93\n94 \t\tif (pclk > 1000 * i * i * i)\n95 \t\t\tctx.pck_min = max(pclk - 1000 * i * i * i, 0lu);\n96 \t\telse\n97 \t\t\tctx.pck_min = 0;\n98 \t\tctx.pck_max = pclk + 1000 * i * i * i;\n99\n100 \t\tok = dss_div_calc(sdi->dss, pclk, ctx.pck_min,\n101 \t\t\t\t  dpi_calc_dss_cb, &ctx);\n102 \t\tif (ok) {\n103 \t\t\t*fck = ctx.fck;\n104 \t\t\t*dispc_cinfo = ctx.dispc_cinfo;\n105 \t\t\treturn 0;\n106 \t\t}\n107 \t}\n108\n109 \treturn -EINVAL;\n110 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dss.c",
                        "function_body": "599 bool dss_div_calc(struct dss_device *dss, unsigned long pck,\n600 \t\t  unsigned long fck_min, dss_div_calc_func func, void *data)\n601 {\n602 \tint fckd, fckd_start, fckd_stop;\n603 \tunsigned long fck;\n604 \tunsigned long fck_hw_max;\n605 \tunsigned long fckd_hw_max;\n606 \tunsigned long prate;\n607 \tunsigned int m;\n608\n609 \tfck_hw_max = dss->feat->fck_freq_max;\n610\n611 \tif (dss->parent_clk == NULL) {\n612 \t\tunsigned int pckd;\n613\n614 \t\tpckd = fck_hw_max / pck;\n615\n616 \t\tfck = pck * pckd;\n617\n618 \t\tfck = clk_round_rate(dss->dss_clk, fck);\n619\n620 \t\treturn func(fck, data);\n621 \t}\n622\n623 \tfckd_hw_max = dss->feat->fck_div_max;\n624\n625 \tm = dss->feat->dss_fck_multiplier;\n626 \tprate = clk_get_rate(dss->parent_clk);\n627\n628 \tfck_min = fck_min ? fck_min : 1;\n629\n630 \tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n631 \tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n632\n633 \tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n634 \t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n635\n636 \t\tif (func(fck, data))\n637 \t\t\treturn true;\n638 \t}\n639\n640 \treturn false;\n641 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/sdi.c",
                        "function_body": "69 static int sdi_calc_clock_div(unsigned long pclk,\n70 \t\tunsigned long *fck,\n71 \t\tstruct dispc_clock_info *dispc_cinfo)\n72 {\n73 \tint i;\n74 \tstruct sdi_clk_calc_ctx ctx;\n75\n76 \t/*\n77 \t * DSS fclk gives us very few possibilities, so finding a good pixel\n78 \t * clock may not be possible. We try multiple times to find the clock,\n79 \t * each time widening the pixel clock range we look for, up to\n80 \t * +/- 1MHz.\n81 \t */\n82\n83 \tfor (i = 0; i < 10; ++i) {\n84 \t\tbool ok;\n85\n86 \t\tmemset(&ctx, 0, sizeof(ctx));\n87 \t\tif (pclk > 1000 * i * i * i)\n88 \t\t\tctx.pck_min = max(pclk - 1000 * i * i * i, 0lu);\n89 \t\telse\n90 \t\t\tctx.pck_min = 0;\n91 \t\tctx.pck_max = pclk + 1000 * i * i * i;\n92\n93 \t\tok = dss_div_calc(pclk, ctx.pck_min, dpi_calc_dss_cb, &ctx);\n94 \t\tif (ok) {\n95 \t\t\t*fck = ctx.fck;\n96 \t\t\t*dispc_cinfo = ctx.dispc_cinfo;\n97 \t\t\treturn 0;\n98 \t\t}\n99 \t}\n100\n101 \treturn -EINVAL;\n102 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dss.c",
                        "function_body": "599 bool dss_div_calc(struct dss_device *dss, unsigned long pck,\n600 \t\t  unsigned long fck_min, dss_div_calc_func func, void *data)\n601 {\n602 \tint fckd, fckd_start, fckd_stop;\n603 \tunsigned long fck;\n604 \tunsigned long fck_hw_max;\n605 \tunsigned long fckd_hw_max;\n606 \tunsigned long prate;\n607 \tunsigned int m;\n608\n609 \tfck_hw_max = dss->feat->fck_freq_max;\n610\n611 \tif (dss->parent_clk == NULL) {\n612 \t\tunsigned int pckd;\n613\n614 \t\tpckd = fck_hw_max / pck;\n615\n616 \t\tfck = pck * pckd;\n617\n618 \t\tfck = clk_round_rate(dss->dss_clk, fck);\n619\n620 \t\treturn func(fck, data);\n621 \t}\n622\n623 \tfckd_hw_max = dss->feat->fck_div_max;\n624\n625 \tm = dss->feat->dss_fck_multiplier;\n626 \tprate = clk_get_rate(dss->parent_clk);\n627\n628 \tfck_min = fck_min ? fck_min : 1;\n629\n630 \tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n631 \tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n632\n633 \tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n634 \t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n635\n636 \t\tif (func(fck, data))\n637 \t\t\treturn true;\n638 \t}\n639\n640 \treturn false;\n641 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dpi.c",
                        "function_body": "240 static bool dpi_dss_clk_calc(unsigned long pck, struct dpi_clk_calc_ctx *ctx)\n241 {\n242 \tint i;\n243\n244 \t/*\n245 \t * DSS fck gives us very few possibilities, so finding a good pixel\n246 \t * clock may not be possible. We try multiple times to find the clock,\n247 \t * each time widening the pixel clock range we look for, up to\n248 \t * +/- ~15MHz.\n249 \t */\n250\n251 \tfor (i = 0; i < 25; ++i) {\n252 \t\tbool ok;\n253\n254 \t\tmemset(ctx, 0, sizeof(*ctx));\n255 \t\tif (pck > 1000 * i * i * i)\n256 \t\t\tctx->pck_min = max(pck - 1000 * i * i * i, 0lu);\n257 \t\telse\n258 \t\t\tctx->pck_min = 0;\n259 \t\tctx->pck_max = pck + 1000 * i * i * i;\n260\n261 \t\tok = dss_div_calc(pck, ctx->pck_min, dpi_calc_dss_cb, ctx);\n262 \t\tif (ok)\n263 \t\t\treturn ok;\n264 \t}\n265\n266 \treturn false;\n267 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dss.c",
                        "function_body": "599 bool dss_div_calc(struct dss_device *dss, unsigned long pck,\n600 \t\t  unsigned long fck_min, dss_div_calc_func func, void *data)\n601 {\n602 \tint fckd, fckd_start, fckd_stop;\n603 \tunsigned long fck;\n604 \tunsigned long fck_hw_max;\n605 \tunsigned long fckd_hw_max;\n606 \tunsigned long prate;\n607 \tunsigned int m;\n608\n609 \tfck_hw_max = dss->feat->fck_freq_max;\n610\n611 \tif (dss->parent_clk == NULL) {\n612 \t\tunsigned int pckd;\n613\n614 \t\tpckd = fck_hw_max / pck;\n615\n616 \t\tfck = pck * pckd;\n617\n618 \t\tfck = clk_round_rate(dss->dss_clk, fck);\n619\n620 \t\treturn func(fck, data);\n621 \t}\n622\n623 \tfckd_hw_max = dss->feat->fck_div_max;\n624\n625 \tm = dss->feat->dss_fck_multiplier;\n626 \tprate = clk_get_rate(dss->parent_clk);\n627\n628 \tfck_min = fck_min ? fck_min : 1;\n629\n630 \tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n631 \tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n632\n633 \tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n634 \t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n635\n636 \t\tif (func(fck, data))\n637 \t\t\treturn true;\n638 \t}\n639\n640 \treturn false;\n641 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dpi.c",
                        "function_body": "254 static bool dpi_dss_clk_calc(struct dpi_data *dpi, unsigned long pck,\n255 \t\t\t     struct dpi_clk_calc_ctx *ctx)\n256 {\n257 \tint i;\n258\n259 \t/*\n260 \t * DSS fck gives us very few possibilities, so finding a good pixel\n261 \t * clock may not be possible. We try multiple times to find the clock,\n262 \t * each time widening the pixel clock range we look for, up to\n263 \t * +/- ~15MHz.\n264 \t */\n265\n266 \tfor (i = 0; i < 25; ++i) {\n267 \t\tbool ok;\n268\n269 \t\tmemset(ctx, 0, sizeof(*ctx));\n270 \t\tctx->dpi = dpi;\n271 \t\tif (pck > 1000 * i * i * i)\n272 \t\t\tctx->pck_min = max(pck - 1000 * i * i * i, 0lu);\n273 \t\telse\n274 \t\t\tctx->pck_min = 0;\n275 \t\tctx->pck_max = pck + 1000 * i * i * i;\n276\n277 \t\tok = dss_div_calc(dpi->dss, pck, ctx->pck_min,\n278 \t\t\t\t  dpi_calc_dss_cb, ctx);\n279 \t\tif (ok)\n280 \t\t\treturn ok;\n281 \t}\n282\n283 \treturn false;\n284 }"
                    }
                ]
            }
        ],
        "sink": "fckd_start = min(prate * m / fck_min, fckd_hw_max);",
        "final_sink": "fckd_start = min(prate * m / fck_min, fckd_hw_max);"
    },
    {
        "prt": "out_min",
        "function_call": [
            "bool dss_pll_hsdiv_calc_a(const struct dss_pll *pll, unsigned long clkdco,\n\t\tunsigned long out_min, unsigned long out_max,\n\t\tdss_hsdiv_calc_func func, void *data)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tint m, m_start, m_stop;\n\tunsigned long out;\n\n\tout_min = out_min ? out_min : 1;\n\tout_max = out_max ? out_max : ULONG_MAX;\n\n\tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n\n\tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n\n\tfor (m = m_start; m <= m_stop; ++m) {\n\t\tout = clkdco / m;\n\n\t\tif (func(m, out, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        ],
        "source": [
            "        out_min = out_min ? out_min : 1;"
        ],
        "index": 2,
        "location": {
            "file_path": "linux-6.9.6/drivers/gpu/drm/omapdrm/dss/pll.c",
            "region": {
                "startLine": 189,
                "startColumn": 33,
                "endColumn": 33
            },
            "context": {
                "startLine": 187,
                "endLine": 191,
                "snippet": {
                    "text": "m_stop = min((unsigned)(clkdco / out_min), hw->mX_max);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/pll.c",
                        "function_body": "176 bool dss_pll_hsdiv_calc_a(const struct dss_pll *pll, unsigned long clkdco,\n177 \t\tunsigned long out_min, unsigned long out_max,\n178 \t\tdss_hsdiv_calc_func func, void *data)\n179 {\n180 \tconst struct dss_pll_hw *hw = pll->hw;\n181 \tint m, m_start, m_stop;\n182 \tunsigned long out;\n183\n184 \tout_min = out_min ? out_min : 1;\n185 \tout_max = out_max ? out_max : ULONG_MAX;\n186\n187 \tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n188\n189 \tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n190\n191 \tfor (m = m_start; m <= m_stop; ++m) {\n192 \t\tout = clkdco / m;\n193\n194 \t\tif (func(m, out, data))\n195 \t\t\treturn true;\n196 \t}\n197\n198 \treturn false;\n199 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dsi.c",
                        "function_body": "3995 static bool dsi_vm_calc_pll_cb(int n, int m, unsigned long fint,\n3996 \t\tunsigned long clkdco, void *data)\n3997 {\n3998 \tstruct dsi_clk_calc_ctx *ctx = data;\n3999 \tstruct dsi_data *dsi = ctx->dsi;\n4000\n4001 \tctx->dsi_cinfo.n = n;\n4002 \tctx->dsi_cinfo.m = m;\n4003 \tctx->dsi_cinfo.fint = fint;\n4004 \tctx->dsi_cinfo.clkdco = clkdco;\n4005\n4006 \treturn dss_pll_hsdiv_calc_a(ctx->pll, clkdco, ctx->req_pck_min,\n4007 \t\t\tdsi->data->max_fck_freq,\n4008 \t\t\tdsi_vm_calc_hsdiv_cb, ctx);\n4009 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/pll.c",
                        "function_body": "176 bool dss_pll_hsdiv_calc_a(const struct dss_pll *pll, unsigned long clkdco,\n177 \t\tunsigned long out_min, unsigned long out_max,\n178 \t\tdss_hsdiv_calc_func func, void *data)\n179 {\n180 \tconst struct dss_pll_hw *hw = pll->hw;\n181 \tint m, m_start, m_stop;\n182 \tunsigned long out;\n183\n184 \tout_min = out_min ? out_min : 1;\n185 \tout_max = out_max ? out_max : ULONG_MAX;\n186\n187 \tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n188\n189 \tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n190\n191 \tfor (m = m_start; m <= m_stop; ++m) {\n192 \t\tout = clkdco / m;\n193\n194 \t\tif (func(m, out, data))\n195 \t\t\treturn true;\n196 \t}\n197\n198 \treturn false;\n199 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dsi.c",
                        "function_body": "3695 static bool dsi_cm_calc_pll_cb(int n, int m, unsigned long fint,\n3696 \t\tunsigned long clkdco, void *data)\n3697 {\n3698 \tstruct dsi_clk_calc_ctx *ctx = data;\n3699 \tstruct dsi_data *dsi = ctx->dsi;\n3700\n3701 \tctx->dsi_cinfo.n = n;\n3702 \tctx->dsi_cinfo.m = m;\n3703 \tctx->dsi_cinfo.fint = fint;\n3704 \tctx->dsi_cinfo.clkdco = clkdco;\n3705\n3706 \treturn dss_pll_hsdiv_calc_a(ctx->pll, clkdco, ctx->req_pck_min,\n3707 \t\t\tdsi->data->max_fck_freq,\n3708 \t\t\tdsi_cm_calc_hsdiv_cb, ctx);\n3709 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/pll.c",
                        "function_body": "176 bool dss_pll_hsdiv_calc_a(const struct dss_pll *pll, unsigned long clkdco,\n177 \t\tunsigned long out_min, unsigned long out_max,\n178 \t\tdss_hsdiv_calc_func func, void *data)\n179 {\n180 \tconst struct dss_pll_hw *hw = pll->hw;\n181 \tint m, m_start, m_stop;\n182 \tunsigned long out;\n183\n184 \tout_min = out_min ? out_min : 1;\n185 \tout_max = out_max ? out_max : ULONG_MAX;\n186\n187 \tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n188\n189 \tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n190\n191 \tfor (m = m_start; m <= m_stop; ++m) {\n192 \t\tout = clkdco / m;\n193\n194 \t\tif (func(m, out, data))\n195 \t\t\treturn true;\n196 \t}\n197\n198 \treturn false;\n199 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dpi.c",
                        "function_body": "192 static bool dpi_calc_pll_cb(int n, int m, unsigned long fint,\n193 \t\tunsigned long clkdco,\n194 \t\tvoid *data)\n195 {\n196 \tstruct dpi_clk_calc_ctx *ctx = data;\n197\n198 \tctx->pll_cinfo.n = n;\n199 \tctx->pll_cinfo.m = m;\n200 \tctx->pll_cinfo.fint = fint;\n201 \tctx->pll_cinfo.clkdco = clkdco;\n202\n203 \treturn dss_pll_hsdiv_calc_a(ctx->dpi->pll, clkdco,\n204 \t\tctx->pck_min, dss_get_max_fck_rate(ctx->dpi->dss),\n205 \t\tdpi_calc_hsdiv_cb, ctx);\n206 }"
                    }
                ]
            }
        ],
        "sink": "m_stop = min((unsigned)(clkdco / out_min), hw->mX_max);",
        "final_sink": "m_stop = min((unsigned)(clkdco / out_min), hw->mX_max);"
    },
    {
        "prt": "known",
        "function_call": [
            "static int gain_get_scale_fraction(const u64 max, u64 scale, int known,\n\t\t\t\t   int *unknown)\n{\n\tint tot_gain;\n\n\ttot_gain = iio_gts_get_gain(max, scale);\n\tif (tot_gain < 0)\n\t\treturn tot_gain;\n\n\t*unknown = tot_gain / known;\n\n\t/* We require total gain to be exact multiple of known * unknown */\n\tif (!*unknown || *unknown * known != tot_gain)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        ],
        "source": [
            "static int gain_get_scale_fraction(const u64 max, u64 scale, int known,"
        ],
        "index": 3,
        "location": {
            "file_path": "linux-6.9.6/drivers/iio/industrialio-gts-helper.c",
            "region": {
                "startLine": 69,
                "startColumn": 22,
                "endColumn": 22
            },
            "context": {
                "startLine": 67,
                "endLine": 71,
                "snippet": {
                    "text": "*unknown = tot_gain / known;"
                }
            }
        },
        "result": 1,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/drivers/iio/industrialio-gts-helper.c",
                        "function_body": "60 static int gain_get_scale_fraction(const u64 max, u64 scale, int known,\n61 \t\t\t\t   int *unknown)\n62 {\n63 \tint tot_gain;\n64\n65 \ttot_gain = iio_gts_get_gain(max, scale);\n66 \tif (tot_gain < 0)\n67 \t\treturn tot_gain;\n68\n69 \t*unknown = tot_gain / known;\n70\n71 \t/* We require total gain to be exact multiple of known * unknown */\n72 \tif (!*unknown || *unknown * known != tot_gain)\n73 \t\treturn -EINVAL;\n74\n75 \treturn 0;\n76 }"
                    },
                    {
                        "file_path": "/drivers/iio/industrialio-gts-helper.c",
                        "function_body": "854 static int iio_gts_find_gain_for_scale_using_time(struct iio_gts *gts, int time_sel,\n855 \t\t\t\t\t\t  int scale_int, int scale_nano,\n856 \t\t\t\t\t\t  int *gain)\n857 {\n858 \tu64 scale_linear;\n859 \tint ret, mul;\n860\n861 \tret = iio_gts_linearize(scale_int, scale_nano, NANO, &scale_linear);\n862 \tif (ret)\n863 \t\treturn ret;\n864\n865 \tret = iio_gts_get_int_time_gain_multiplier_by_sel(gts, time_sel);\n866 \tif (ret < 0)\n867 \t\treturn ret;\n868\n869 \tmul = ret;\n870\n871 \tret = gain_get_scale_fraction(gts->max_scale, scale_linear, mul, gain);\n872 \tif (ret)\n873 \t\treturn ret;\n874\n875 \tif (!iio_gts_valid_gain(gts, *gain))\n876 \t\treturn -EINVAL;\n877\n878 \treturn 0;\n879 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/drivers/iio/industrialio-gts-helper.c",
                        "function_body": "60 static int gain_get_scale_fraction(const u64 max, u64 scale, int known,\n61 \t\t\t\t   int *unknown)\n62 {\n63 \tint tot_gain;\n64\n65 \ttot_gain = iio_gts_get_gain(max, scale);\n66 \tif (tot_gain < 0)\n67 \t\treturn tot_gain;\n68\n69 \t*unknown = tot_gain / known;\n70\n71 \t/* We require total gain to be exact multiple of known * unknown */\n72 \tif (!*unknown || *unknown * known != tot_gain)\n73 \t\treturn -EINVAL;\n74\n75 \treturn 0;\n76 }"
                    },
                    {
                        "file_path": "/drivers/iio/industrialio-gts-helper.c",
                        "function_body": "1054 int iio_gts_find_new_gain_by_old_gain_time(struct iio_gts *gts, int old_gain,\n1055 \t\t\t\t\t   int old_time, int new_time,\n1056 \t\t\t\t\t   int *new_gain)\n1057 {\n1058 \tconst struct iio_itime_sel_mul *itime_new;\n1059 \tu64 scale;\n1060 \tint ret;\n1061\n1062 \t*new_gain = -1;\n1063\n1064 \titime_new = iio_gts_find_itime_by_time(gts, new_time);\n1065 \tif (!itime_new)\n1066 \t\treturn -EINVAL;\n1067\n1068 \tret = iio_gts_get_scale_linear(gts, old_gain, old_time, &scale);\n1069 \tif (ret)\n1070 \t\treturn ret;\n1071\n1072 \tret = gain_get_scale_fraction(gts->max_scale, scale, itime_new->mul,\n1073 \t\t\t\t      new_gain);\n1074 \tif (ret)\n1075 \t\treturn ret;\n1076\n1077 \tif (!iio_gts_valid_gain(gts, *new_gain))\n1078 \t\treturn -EINVAL;\n1079\n1080 \treturn 0;\n1081 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/drivers/iio/industrialio-gts-helper.c",
                        "function_body": "60 static int gain_get_scale_fraction(const u64 max, u64 scale, int known,\n61 \t\t\t\t   int *unknown)\n62 {\n63 \tint tot_gain;\n64\n65 \ttot_gain = iio_gts_get_gain(max, scale);\n66 \tif (tot_gain < 0)\n67 \t\treturn tot_gain;\n68\n69 \t*unknown = tot_gain / known;\n70\n71 \t/* We require total gain to be exact multiple of known * unknown */\n72 \tif (!*unknown || *unknown * known != tot_gain)\n73 \t\treturn -EINVAL;\n74\n75 \treturn 0;\n76 }"
                    },
                    {
                        "file_path": "/drivers/iio/industrialio-gts-helper.c",
                        "function_body": "997  int iio_gts_find_new_gain_sel_by_old_gain_time(struct iio_gts *gts,\n998  \t\t\t\t\t       int old_gain, int old_time_sel,\n999  \t\t\t\t\t       int new_time_sel, int *new_gain)\n1000 {\n1001 \tconst struct iio_itime_sel_mul *itime_old, *itime_new;\n1002 \tu64 scale;\n1003 \tint ret;\n1004\n1005 \t*new_gain = -1;\n1006\n1007 \titime_old = iio_gts_find_itime_by_sel(gts, old_time_sel);\n1008 \tif (!itime_old)\n1009 \t\treturn -EINVAL;\n1010\n1011 \titime_new = iio_gts_find_itime_by_sel(gts, new_time_sel);\n1012 \tif (!itime_new)\n1013 \t\treturn -EINVAL;\n1014\n1015 \tret = iio_gts_get_scale_linear(gts, old_gain, itime_old->time_us,\n1016 \t\t\t\t       &scale);\n1017 \tif (ret)\n1018 \t\treturn ret;\n1019\n1020 \tret = gain_get_scale_fraction(gts->max_scale, scale, itime_new->mul,\n1021 \t\t\t\t      new_gain);\n1022 \tif (ret)\n1023 \t\treturn ret;\n1024\n1025 \tif (!iio_gts_valid_gain(gts, *new_gain))\n1026 \t\treturn -EINVAL;\n1027\n1028 \treturn 0;\n1029 }"
                    }
                ]
            }
        ],
        "sink": "*unknown = tot_gain / known;",
        "final_sink": "*unknown = tot_gain / known;"
    },
    {
        "prt": "srate",
        "function_call": [
            "static long stb0899_calc_derot_time(long srate)\n{\n\tif (srate > 0)\n\t\treturn (100000 / (srate / 1000));\n\telse\n\t\treturn 0;\n}"
        ],
        "source": [
            "static long stb0899_calc_derot_time(long srate)"
        ],
        "index": 4,
        "location": {
            "file_path": "linux-6.9.6/drivers/media/dvb-frontends/stb0899_algo.c",
            "region": {
                "startLine": 110,
                "startColumn": 18,
                "endColumn": 18
            },
            "context": {
                "startLine": 108,
                "endLine": 112,
                "snippet": {
                    "text": "return (100000 / (srate / 1000));"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/drivers/media/dvb-frontends/stb0899_algo.c",
                        "function_body": "107 static long stb0899_calc_derot_time(long srate)\n108 {\n109 \tif (srate > 0)\n110 \t\treturn (100000 / (srate / 1000));\n111 \telse\n112 \t\treturn 0;\n113 }"
                    },
                    {
                        "file_path": "/drivers/media/dvb-frontends/stb0899_algo.c",
                        "function_body": "489 enum stb0899_status stb0899_dvbs_algo(struct stb0899_state *state)\n490 {\n491 \tstruct stb0899_params *params\t\t= &state->params;\n492 \tstruct stb0899_internal *internal\t= &state->internal;\n493 \tstruct stb0899_config *config\t\t= state->config;\n494\n495 \tu8 bclc, reg;\n496 \tu8 cfr[2];\n497 \tu8 eq_const[10];\n498 \ts32 clnI = 3;\n499 \tu32 bandwidth = 0;\n500\n501 \t/* BETA values rated @ 99MHz\t*/\n502 \ts32 betaTab[5][4] = {\n503 \t       /*  5   10   20   30MBps */\n504 \t\t{ 37,  34,  32,  31 }, /* QPSK 1/2\t*/\n505 \t\t{ 37,  35,  33,  31 }, /* QPSK 2/3\t*/\n506 \t\t{ 37,  35,  33,  31 }, /* QPSK 3/4\t*/\n507 \t\t{ 37,  36,  33,\t 32 }, /* QPSK 5/6\t*/\n508 \t\t{ 37,  36,  33,\t 32 }  /* QPSK 7/8\t*/\n509 \t};\n510\n511 \tinternal->direction = 1;\n512\n513 \tstb0899_set_srate(state, internal->master_clk, params->srate);\n514 \t/* Carrier loop optimization versus symbol rate for acquisition*/\n515 \tif (params->srate <= 5000000) {\n516 \t\tstb0899_write_reg(state, STB0899_ACLC, 0x89);\n517 \t\tbclc = stb0899_read_reg(state, STB0899_BCLC);\n518 \t\tSTB0899_SETFIELD_VAL(BETA, bclc, 0x1c);\n519 \t\tstb0899_write_reg(state, STB0899_BCLC, bclc);\n520 \t\tclnI = 0;\n521 \t} else if (params->srate <= 15000000) {\n522 \t\tstb0899_write_reg(state, STB0899_ACLC, 0xc9);\n523 \t\tbclc = stb0899_read_reg(state, STB0899_BCLC);\n524 \t\tSTB0899_SETFIELD_VAL(BETA, bclc, 0x22);\n525 \t\tstb0899_write_reg(state, STB0899_BCLC, bclc);\n526 \t\tclnI = 1;\n527 \t} else if(params->srate <= 25000000) {\n528 \t\tstb0899_write_reg(state, STB0899_ACLC, 0x89);\n529 \t\tbclc = stb0899_read_reg(state, STB0899_BCLC);\n530 \t\tSTB0899_SETFIELD_VAL(BETA, bclc, 0x27);\n531 \t\tstb0899_write_reg(state, STB0899_BCLC, bclc);\n532 \t\tclnI = 2;\n533 \t} else {\n534 \t\tstb0899_write_reg(state, STB0899_ACLC, 0xc8);\n535 \t\tbclc = stb0899_read_reg(state, STB0899_BCLC);\n536 \t\tSTB0899_SETFIELD_VAL(BETA, bclc, 0x29);\n537 \t\tstb0899_write_reg(state, STB0899_BCLC, bclc);\n538 \t\tclnI = 3;\n539 \t}\n540\n541 \tdprintk(state->verbose, FE_DEBUG, 1, \"Set the timing loop to acquisition\");\n542 \t/* Set the timing loop to acquisition\t*/\n543 \tstb0899_write_reg(state, STB0899_RTC, 0x46);\n544 \tstb0899_write_reg(state, STB0899_CFD, 0xee);\n545\n546 \t/* !! WARNING !!\n547 \t * Do not read any status variables while acquisition,\n548 \t * If any needed, read before the acquisition starts\n549 \t * querying status while acquiring causes the\n550 \t * acquisition to go bad and hence no locks.\n551 \t */\n552 \tdprintk(state->verbose, FE_DEBUG, 1, \"Derot Percent=%d Srate=%d mclk=%d\",\n553 \t\tinternal->derot_percent, params->srate, internal->mclk);\n554\n555 \t/* Initial calculations\t*/\n556 \tinternal->derot_step = internal->derot_percent * (params->srate / 1000L) / internal->mclk; /* DerotStep/1000 * Fsymbol\t*/\n557 \tinternal->t_derot = stb0899_calc_derot_time(params->srate);\n558 \tinternal->t_data = 500;\n559\n560 \tdprintk(state->verbose, FE_DEBUG, 1, \"RESET stream merger\");\n561 \t/* RESET Stream merger\t*/\n562 \treg = stb0899_read_reg(state, STB0899_TSTRES);\n563 \tSTB0899_SETFIELD_VAL(FRESRS, reg, 1);\n564 \tstb0899_write_reg(state, STB0899_TSTRES, reg);\n565\n566 \t/*\n567 \t * Set KDIVIDER to an intermediate value between\n568 \t * 1/2 and 7/8 for acquisition\n569 \t */\n570 \treg = stb0899_read_reg(state, STB0899_DEMAPVIT);\n571 \tSTB0899_SETFIELD_VAL(DEMAPVIT_KDIVIDER, reg, 60);\n572 \tstb0899_write_reg(state, STB0899_DEMAPVIT, reg);\n573\n574 \tstb0899_write_reg(state, STB0899_EQON, 0x01); /* Equalizer OFF while acquiring */\n575 \tstb0899_write_reg(state, STB0899_VITSYNC, 0x19);\n576\n577 \tstb0899_first_subrange(state);\n578 \tdo {\n579 \t\t/* Initialisations */\n580 \t\tcfr[0] = cfr[1] = 0;\n581 \t\tstb0899_write_regs(state, STB0899_CFRM, cfr, 2); /* RESET derotator frequency\t*/\n582\n583 \t\tstb0899_write_reg(state, STB0899_RTF, 0);\n584 \t\treg = stb0899_read_reg(state, STB0899_CFD);\n585 \t\tSTB0899_SETFIELD_VAL(CFD_ON, reg, 1);\n586 \t\tstb0899_write_reg(state, STB0899_CFD, reg);\n587\n588 \t\tinternal->derot_freq = 0;\n589 \t\tinternal->status = NOAGC1;\n590\n591 \t\t/* enable tuner I/O */\n592 \t\tstb0899_i2c_gate_ctrl(&state->frontend, 1);\n593\n594 \t\t/* Move tuner to frequency */\n595 \t\tdprintk(state->verbose, FE_DEBUG, 1, \"Tuner set frequency\");\n596 \t\tif (state->config->tuner_set_frequency)\n597 \t\t\tstate->config->tuner_set_frequency(&state->frontend, internal->freq);\n598\n599 \t\tif (state->config->tuner_get_frequency)\n600 \t\t\tstate->config->tuner_get_frequency(&state->frontend, &internal->freq);\n601\n602 \t\tmsleep(internal->t_agc1 + internal->t_agc2 + internal->t_derot); /* AGC1, AGC2 and timing loop\t*/\n603 \t\tdprintk(state->verbose, FE_DEBUG, 1, \"current derot freq=%d\", internal->derot_freq);\n604 \t\tinternal->status = AGC1OK;\n605\n606 \t\t/* There is signal in the band\t*/\n607 \t\tif (config->tuner_get_bandwidth)\n608 \t\t\tconfig->tuner_get_bandwidth(&state->frontend, &bandwidth);\n609\n610 \t\t/* disable tuner I/O */\n611 \t\tstb0899_i2c_gate_ctrl(&state->frontend, 0);\n612\n613 \t\tif (params->srate <= bandwidth / 2)\n614 \t\t\tstb0899_search_tmg(state); /* For low rates (SCPC)\t*/\n615 \t\telse\n616 \t\t\tstb0899_check_tmg(state); /* For high rates (MCPC)\t*/\n617\n618 \t\tif (internal->status == TIMINGOK) {\n619 \t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n620 \t\t\t\t\"TIMING OK ! Derot freq=%d, mclk=%d\",\n621 \t\t\t\tinternal->derot_freq, internal->mclk);\n622\n623 \t\t\tif (stb0899_search_carrier(state) == CARRIEROK) {\t/* Search for carrier\t*/\n624 \t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n625 \t\t\t\t\t\"CARRIER OK ! Derot freq=%d, mclk=%d\",\n626 \t\t\t\t\tinternal->derot_freq, internal->mclk);\n627\n628 \t\t\t\tif (stb0899_search_data(state) == DATAOK) {\t/* Check for data\t*/\n629 \t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n630 \t\t\t\t\t\t\"DATA OK ! Derot freq=%d, mclk=%d\",\n631 \t\t\t\t\t\tinternal->derot_freq, internal->mclk);\n632\n633 \t\t\t\t\tif (stb0899_check_range(state) == RANGEOK) {\n634 \t\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n635 \t\t\t\t\t\t\t\"RANGE OK ! derot freq=%d, mclk=%d\",\n636 \t\t\t\t\t\t\tinternal->derot_freq, internal->mclk);\n637\n638 \t\t\t\t\t\tinternal->freq = params->freq - ((internal->derot_freq * internal->mclk) / 1000);\n639 \t\t\t\t\t\treg = stb0899_read_reg(state, STB0899_PLPARM);\n640 \t\t\t\t\t\tinternal->fecrate = STB0899_GETFIELD(VITCURPUN, reg);\n641 \t\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n642 \t\t\t\t\t\t\t\"freq=%d, internal resultant freq=%d\",\n643 \t\t\t\t\t\t\tparams->freq, internal->freq);\n644\n645 \t\t\t\t\t\tdprintk(state->verbose, FE_DEBUG, 1,\n646 \t\t\t\t\t\t\t\"internal puncture rate=%d\",\n647 \t\t\t\t\t\t\tinternal->fecrate);\n648 \t\t\t\t\t}\n649 \t\t\t\t}\n650 \t\t\t}\n651 \t\t}\n652 \t\tif (internal->status != RANGEOK)\n653 \t\t\tnext_sub_range(state);\n654\n655 \t} while (internal->sub_range && internal->status != RANGEOK);\n656\n657 \t/* Set the timing loop to tracking\t*/\n658 \tstb0899_write_reg(state, STB0899_RTC, 0x33);\n659 \tstb0899_write_reg(state, STB0899_CFD, 0xf7);\n660 \t/* if locked and range ok, set Kdiv\t*/\n661 \tif (internal->status == RANGEOK) {\n662 \t\tdprintk(state->verbose, FE_DEBUG, 1, \"Locked & Range OK !\");\n663 \t\tstb0899_write_reg(state, STB0899_EQON, 0x41);\t\t/* Equalizer OFF while acquiring\t*/\n664 \t\tstb0899_write_reg(state, STB0899_VITSYNC, 0x39);\t/* SN to b'11 for acquisition\t\t*/\n665\n666 \t\t/*\n667 \t\t * Carrier loop optimization versus\n668 \t\t * symbol Rate/Puncture Rate for Tracking\n669 \t\t */\n670 \t\treg = stb0899_read_reg(state, STB0899_BCLC);\n671 \t\tswitch (internal->fecrate) {\n672 \t\tcase STB0899_FEC_1_2:\t\t/* 13\t*/\n673 \t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 0x1a);\n674 \t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[0][clnI]);\n675 \t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n676 \t\t\tbreak;\n677 \t\tcase STB0899_FEC_2_3:\t\t/* 18\t*/\n678 \t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 44);\n679 \t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[1][clnI]);\n680 \t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n681 \t\t\tbreak;\n682 \t\tcase STB0899_FEC_3_4:\t\t/* 21\t*/\n683 \t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 60);\n684 \t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[2][clnI]);\n685 \t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n686 \t\t\tbreak;\n687 \t\tcase STB0899_FEC_5_6:\t\t/* 24\t*/\n688 \t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 75);\n689 \t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[3][clnI]);\n690 \t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n691 \t\t\tbreak;\n692 \t\tcase STB0899_FEC_6_7:\t\t/* 25\t*/\n693 \t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 88);\n694 \t\t\tstb0899_write_reg(state, STB0899_ACLC, 0x88);\n695 \t\t\tstb0899_write_reg(state, STB0899_BCLC, 0x9a);\n696 \t\t\tbreak;\n697 \t\tcase STB0899_FEC_7_8:\t\t/* 26\t*/\n698 \t\t\tstb0899_write_reg(state, STB0899_DEMAPVIT, 94);\n699 \t\t\tSTB0899_SETFIELD_VAL(BETA, reg, betaTab[4][clnI]);\n700 \t\t\tstb0899_write_reg(state, STB0899_BCLC, reg);\n701 \t\t\tbreak;\n702 \t\tdefault:\n703 \t\t\tdprintk(state->verbose, FE_DEBUG, 1, \"Unsupported Puncture Rate\");\n704 \t\t\tbreak;\n705 \t\t}\n706 \t\t/* release stream merger RESET\t*/\n707 \t\treg = stb0899_read_reg(state, STB0899_TSTRES);\n708 \t\tSTB0899_SETFIELD_VAL(FRESRS, reg, 0);\n709 \t\tstb0899_write_reg(state, STB0899_TSTRES, reg);\n710\n711 \t\t/* disable carrier detector\t*/\n712 \t\treg = stb0899_read_reg(state, STB0899_CFD);\n713 \t\tSTB0899_SETFIELD_VAL(CFD_ON, reg, 0);\n714 \t\tstb0899_write_reg(state, STB0899_CFD, reg);\n715\n716 \t\tstb0899_read_regs(state, STB0899_EQUAI1, eq_const, 10);\n717 \t}\n718\n719 \treturn internal->status;\n720 }"
                    }
                ]
            }
        ],
        "sink": "return (100000 / (srate / 1000));",
        "final_sink": "return (100000 / (srate / 1000));"
    },
    {
        "prt": "rc",
        "function_call": [
            "static int efx_ef10_get_timer_config(struct efx_nic *efx)\n{\n\tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_LEN);\n\tint rc;\n\n\trc = efx_ef10_get_timer_workarounds(efx);\n\tif (rc)\n\t\treturn rc;\n\n\trc = efx_mcdi_rpc_quiet(efx, MC_CMD_GET_EVQ_TMR_PROPERTIES, NULL, 0,\n\t\t\t\toutbuf, sizeof(outbuf), NULL);\n\n\tif (rc == 0) {\n\t\tefx_ef10_process_timer_config(efx, outbuf);\n\t} else if (rc == -ENOSYS || rc == -EPERM) {\n\t\t/* Not available - fall back to Huntington defaults. */\n\t\tunsigned int quantum;\n\n\t\trc = efx_ef10_get_sysclk_freq(efx);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tquantum = 1536000 / rc; /* 1536 cycles */\n\t\tefx->timer_quantum_ns = quantum;\n\t\tefx->timer_max_ns = efx->type->timer_period_max * quantum;\n\t\trc = 0;\n\t} else {\n\t\tefx_mcdi_display_error(efx, MC_CMD_GET_EVQ_TMR_PROPERTIES,\n\t\t\t\t       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_LEN,\n\t\t\t\t       NULL, 0, rc);\n\t}\n\n\treturn rc;\n}"
        ],
        "source": [
            "        rc = efx_ef10_get_sysclk_freq(efx);"
        ],
        "index": 5,
        "location": {
            "file_path": "linux-6.9.6/drivers/net/ethernet/sfc/ef10.c",
            "region": {
                "startLine": 312,
                "startColumn": 21,
                "endColumn": 21
            },
            "context": {
                "startLine": 310,
                "endLine": 314,
                "snippet": {
                    "text": "quantum = 1536000 / rc; /* 1536 cycles */"
                }
            }
        },
        "result": 1,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/drivers/media/dvb-frontends/s921.c",
                        "function_body": "27 #define rc(args...)  do {\t\t\t\t\t\t\\\n28 \tprintk(KERN_ERR  \"s921: \" args);\t\t\t\t\\\n29 } while (0)"
                    },
                    {
                        "file_path": "/drivers/net/ethernet/sfc/ef10.c",
                        "function_body": "290 static int efx_ef10_get_timer_config(struct efx_nic *efx)\n291 {\n292 \tMCDI_DECLARE_BUF(outbuf, MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_LEN);\n293 \tint rc;\n294\n295 \trc = efx_ef10_get_timer_workarounds(efx);\n296 \tif (rc)\n297 \t\treturn rc;\n298\n299 \trc = efx_mcdi_rpc_quiet(efx, MC_CMD_GET_EVQ_TMR_PROPERTIES, NULL, 0,\n300 \t\t\t\toutbuf, sizeof(outbuf), NULL);\n301\n302 \tif (rc == 0) {\n303 \t\tefx_ef10_process_timer_config(efx, outbuf);\n304 \t} else if (rc == -ENOSYS || rc == -EPERM) {\n305 \t\t/* Not available - fall back to Huntington defaults. */\n306 \t\tunsigned int quantum;\n307\n308 \t\trc = efx_ef10_get_sysclk_freq(efx);\n309 \t\tif (rc < 0)\n310 \t\t\treturn rc;\n311\n312 \t\tquantum = 1536000 / rc; /* 1536 cycles */\n313 \t\tefx->timer_quantum_ns = quantum;\n314 \t\tefx->timer_max_ns = efx->type->timer_period_max * quantum;\n315 \t\trc = 0;\n316 \t} else {\n317 \t\tefx_mcdi_display_error(efx, MC_CMD_GET_EVQ_TMR_PROPERTIES,\n318 \t\t\t\t       MC_CMD_GET_EVQ_TMR_PROPERTIES_OUT_LEN,\n319 \t\t\t\t       NULL, 0, rc);\n320 \t}\n321\n322 \treturn rc;\n323 }"
                    },
                    {
                        "file_path": "/drivers/net/ethernet/sfc/ef10.c",
                        "function_body": "525 static int efx_ef10_probe(struct efx_nic *efx)\n526 {\n527 \tstruct efx_ef10_nic_data *nic_data;\n528 \tint i, rc;\n529\n530 \tnic_data = kzalloc(sizeof(*nic_data), GFP_KERNEL);\n531 \tif (!nic_data)\n532 \t\treturn -ENOMEM;\n533 \tefx->nic_data = nic_data;\n534\n535 \t/* we assume later that we can copy from this buffer in dwords */\n536 \tBUILD_BUG_ON(MCDI_CTL_SDU_LEN_MAX_V2 % 4);\n537\n538 \trc = efx_nic_alloc_buffer(efx, &nic_data->mcdi_buf,\n539 \t\t\t\t  8 + MCDI_CTL_SDU_LEN_MAX_V2, GFP_KERNEL);\n540 \tif (rc)\n541 \t\tgoto fail1;\n542\n543 \t/* Get the MC's warm boot count.  In case it's rebooting right\n544 \t * now, be prepared to retry.\n545 \t */\n546 \ti = 0;\n547 \tfor (;;) {\n548 \t\trc = efx_ef10_get_warm_boot_count(efx);\n549 \t\tif (rc >= 0)\n550 \t\t\tbreak;\n551 \t\tif (++i == 5)\n552 \t\t\tgoto fail2;\n553 \t\tssleep(1);\n554 \t}\n555 \tnic_data->warm_boot_count = rc;\n556\n557 \t/* In case we're recovering from a crash (kexec), we want to\n558 \t * cancel any outstanding request by the previous user of this\n559 \t * function.  We send a special message using the least\n560 \t * significant bits of the 'high' (doorbell) register.\n561 \t */\n562 \t_efx_writed(efx, cpu_to_le32(1), ER_DZ_MC_DB_HWRD);\n563\n564 \trc = efx_mcdi_init(efx);\n565 \tif (rc)\n566 \t\tgoto fail2;\n567\n568 \tmutex_init(&nic_data->udp_tunnels_lock);\n569 \tfor (i = 0; i < ARRAY_SIZE(nic_data->udp_tunnels); ++i)\n570 \t\tnic_data->udp_tunnels[i].type =\n571 \t\t\tTUNNEL_ENCAP_UDP_PORT_ENTRY_INVALID;\n572\n573 \t/* Reset (most) configuration for this function */\n574 \trc = efx_mcdi_reset(efx, RESET_TYPE_ALL);\n575 \tif (rc)\n576 \t\tgoto fail3;\n577\n578 \t/* Enable event logging */\n579 \trc = efx_mcdi_log_ctrl(efx, true, false, 0);\n580 \tif (rc)\n581 \t\tgoto fail3;\n582\n583 \trc = device_create_file(&efx->pci_dev->dev,\n584 \t\t\t\t&dev_attr_link_control_flag);\n585 \tif (rc)\n586 \t\tgoto fail3;\n587\n588 \trc = device_create_file(&efx->pci_dev->dev, &dev_attr_primary_flag);\n589 \tif (rc)\n590 \t\tgoto fail4;\n591\n592 \trc = efx_get_pf_index(efx, &nic_data->pf_index);\n593 \tif (rc)\n594 \t\tgoto fail5;\n595\n596 \trc = efx_ef10_init_datapath_caps(efx);\n597 \tif (rc < 0)\n598 \t\tgoto fail5;\n599\n600 \tefx_ef10_read_licensed_features(efx);\n601\n602 \t/* We can have one VI for each vi_stride-byte region.\n603 \t * However, until we use TX option descriptors we need up to four\n604 \t * TX queues per channel for different checksumming combinations.\n605 \t */\n606 \tif (nic_data->datapath_caps &\n607 \t    (1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN))\n608 \t\tefx->tx_queues_per_channel = 4;\n609 \telse\n610 \t\tefx->tx_queues_per_channel = 2;\n611 \tefx->max_vis = efx_ef10_mem_map_size(efx) / efx->vi_stride;\n612 \tif (!efx->max_vis) {\n613 \t\tnetif_err(efx, drv, efx->net_dev, \"error determining max VIs\\n\");\n614 \t\trc = -EIO;\n615 \t\tgoto fail5;\n616 \t}\n617 \tefx->max_channels = min_t(unsigned int, EFX_MAX_CHANNELS,\n618 \t\t\t\t  efx->max_vis / efx->tx_queues_per_channel);\n619 \tefx->max_tx_channels = efx->max_channels;\n620 \tif (WARN_ON(efx->max_channels == 0)) {\n621 \t\trc = -EIO;\n622 \t\tgoto fail5;\n623 \t}\n624\n625 \tefx->rx_packet_len_offset =\n626 \t\tES_DZ_RX_PREFIX_PKTLEN_OFST - ES_DZ_RX_PREFIX_SIZE;\n627\n628 \tif (nic_data->datapath_caps &\n629 \t    (1 << MC_CMD_GET_CAPABILITIES_OUT_RX_INCLUDE_FCS_LBN))\n630 \t\tefx->net_dev->hw_features |= NETIF_F_RXFCS;\n631\n632 \trc = efx_mcdi_port_get_number(efx);\n633 \tif (rc < 0)\n634 \t\tgoto fail5;\n635 \tefx->port_num = rc;\n636\n637 \trc = efx->type->get_mac_address(efx, efx->net_dev->perm_addr);\n638 \tif (rc)\n639 \t\tgoto fail5;\n640\n641 \trc = efx_ef10_get_timer_config(efx);\n642 \tif (rc < 0)\n643 \t\tgoto fail5;\n644\n645 \trc = efx_mcdi_mon_probe(efx);\n646 \tif (rc && rc != -EPERM)\n647 \t\tgoto fail5;\n648\n649 \tefx_ptp_defer_probe_with_channel(efx);\n650\n651 #ifdef CONFIG_SFC_SRIOV\n652 \tif ((efx->pci_dev->physfn) && (!efx->pci_dev->is_physfn)) {\n653 \t\tstruct pci_dev *pci_dev_pf = efx->pci_dev->physfn;\n654 \t\tstruct efx_nic *efx_pf = pci_get_drvdata(pci_dev_pf);\n655\n656 \t\tefx_pf->type->get_mac_address(efx_pf, nic_data->port_id);\n657 \t} else\n658 #endif\n659 \t\tether_addr_copy(nic_data->port_id, efx->net_dev->perm_addr);\n660\n661 \tINIT_LIST_HEAD(&nic_data->vlan_list);\n662 \tmutex_init(&nic_data->vlan_lock);\n663\n664 \t/* Add unspecified VID to support VLAN filtering being disabled */\n665 \trc = efx_ef10_add_vlan(efx, EFX_FILTER_VID_UNSPEC);\n666 \tif (rc)\n667 \t\tgoto fail_add_vid_unspec;\n668\n669 \t/* If VLAN filtering is enabled, we need VID 0 to get untagged\n670 \t * traffic.  It is added automatically if 8021q module is loaded,\n671 \t * but we can't rely on it since module may be not loaded.\n672 \t */\n673 \trc = efx_ef10_add_vlan(efx, 0);\n674 \tif (rc)\n675 \t\tgoto fail_add_vid_0;\n676\n677 \tif (nic_data->datapath_caps &\n678 \t    (1 << MC_CMD_GET_CAPABILITIES_OUT_VXLAN_NVGRE_LBN) &&\n679 \t    efx->mcdi->fn_flags &\n680 \t    (1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_TRUSTED))\n681 \t\tefx->net_dev->udp_tunnel_nic_info = &efx_ef10_udp_tunnels;\n682\n683 \treturn 0;\n684\n685 fail_add_vid_0:\n686 \tefx_ef10_cleanup_vlans(efx);\n687 fail_add_vid_unspec:\n688 \tmutex_destroy(&nic_data->vlan_lock);\n689 \tefx_ptp_remove(efx);\n690 \tefx_mcdi_mon_remove(efx);\n691 fail5:\n692 \tdevice_remove_file(&efx->pci_dev->dev, &dev_attr_primary_flag);\n693 fail4:\n694 \tdevice_remove_file(&efx->pci_dev->dev, &dev_attr_link_control_flag);\n695 fail3:\n696 \tefx_mcdi_detach(efx);\n697\n698 \tmutex_lock(&nic_data->udp_tunnels_lock);\n699 \tmemset(nic_data->udp_tunnels, 0, sizeof(nic_data->udp_tunnels));\n700 \t(void)efx_ef10_set_udp_tnl_ports(efx, true);\n701 \tmutex_unlock(&nic_data->udp_tunnels_lock);\n702 \tmutex_destroy(&nic_data->udp_tunnels_lock);\n703\n704 \tefx_mcdi_fini(efx);\n705 fail2:\n706 \tefx_nic_free_buffer(efx, &nic_data->mcdi_buf);\n707 fail1:\n708 \tkfree(nic_data);\n709 \tefx->nic_data = NULL;\n710 \treturn rc;\n711 }"
                    }
                ]
            }
        ],
        "sink": "quantum = 1536000 / rc; /* 1536 cycles */",
        "final_sink": "quantum = 1536000 / rc; /* 1536 cycles */"
    },
    {
        "prt": "fuart",
        "function_call": [
            "static void byt_set_termios(struct uart_port *p, struct ktermios *termios,\n\t\t\t    const struct ktermios *old)\n{\n\tunsigned int baud = tty_termios_baud_rate(termios);\n\tstruct lpss8250 *lpss = to_lpss8250(p->private_data);\n\tunsigned long fref = lpss->board->freq, fuart = baud * 16;\n\tunsigned long w = BIT(15) - 1;\n\tunsigned long m, n;\n\tu32 reg;\n\n\t/* Gracefully handle the B0 case: fall back to B9600 */\n\tfuart = fuart ? fuart : 9600 * 16;\n\n\t/* Get Fuart closer to Fref */\n\tfuart *= rounddown_pow_of_two(fref / fuart);\n\n\t/*\n\t * For baud rates 0.5M, 1M, 1.5M, 2M, 2.5M, 3M, 3.5M and 4M the\n\t * dividers must be adjusted.\n\t *\n\t * uartclk = (m / n) * 100 MHz, where m <= n\n\t */\n\trational_best_approximation(fuart, fref, w, w, &m, &n);\n\tp->uartclk = fuart;\n\n\t/* Reset the clock */\n\treg = (m << BYT_PRV_CLK_M_VAL_SHIFT) | (n << BYT_PRV_CLK_N_VAL_SHIFT);\n\twritel(reg, p->membase + BYT_PRV_CLK);\n\treg |= BYT_PRV_CLK_EN | BYT_PRV_CLK_UPDATE;\n\twritel(reg, p->membase + BYT_PRV_CLK);\n\n\tdw8250_do_set_termios(p, termios, old);\n}"
        ],
        "source": [
            "        fuart = fuart ? fuart : 9600 * 16;"
        ],
        "index": 6,
        "location": {
            "file_path": "linux-6.9.6/drivers/tty/serial/8250/8250_lpss.c",
            "region": {
                "startLine": 86,
                "startColumn": 37,
                "endColumn": 37
            },
            "context": {
                "startLine": 84,
                "endLine": 88,
                "snippet": {
                    "text": "fuart *= rounddown_pow_of_two(fref / fuart);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/tools/include/linux/log2.h",
                        "function_body": "168 #define rounddown_pow_of_two(n)\t\t\t\\\n169 (\t\t\t\t\t\t\\\n170 \t__builtin_constant_p(n) ? (\t\t\\\n171 \t\t(1UL << ilog2(n))) :\t\t\\\n172 \t__rounddown_pow_of_two(n)\t\t\\\n173  )"
                    },
                    {
                        "file_path": "/include/linux/log2.h",
                        "function_body": "191 #define rounddown_pow_of_two(n)\t\t\t\\\n192 (\t\t\t\t\t\t\\\n193 \t__builtin_constant_p(n) ? (\t\t\\\n194 \t\t(1UL << ilog2(n))) :\t\t\\\n195 \t__rounddown_pow_of_two(n)\t\t\\\n196  )"
                    },
                    {
                        "file_path": "/drivers/tty/serial/8250/8250_lpss.c",
                        "function_body": "72 static void byt_set_termios(struct uart_port *p, struct ktermios *termios,\n73 \t\t\t    const struct ktermios *old)\n74 {\n75 \tunsigned int baud = tty_termios_baud_rate(termios);\n76 \tstruct lpss8250 *lpss = to_lpss8250(p->private_data);\n77 \tunsigned long fref = lpss->board->freq, fuart = baud * 16;\n78 \tunsigned long w = BIT(15) - 1;\n79 \tunsigned long m, n;\n80 \tu32 reg;\n81\n82 \t/* Gracefully handle the B0 case: fall back to B9600 */\n83 \tfuart = fuart ? fuart : 9600 * 16;\n84\n85 \t/* Get Fuart closer to Fref */\n86 \tfuart *= rounddown_pow_of_two(fref / fuart);\n87\n88 \t/*\n89 \t * For baud rates 0.5M, 1M, 1.5M, 2M, 2.5M, 3M, 3.5M and 4M the\n90 \t * dividers must be adjusted.\n91 \t *\n92 \t * uartclk = (m / n) * 100 MHz, where m <= n\n93 \t */\n94 \trational_best_approximation(fuart, fref, w, w, &m, &n);\n95 \tp->uartclk = fuart;\n96\n97 \t/* Reset the clock */\n98 \treg = (m << BYT_PRV_CLK_M_VAL_SHIFT) | (n << BYT_PRV_CLK_N_VAL_SHIFT);\n99 \twritel(reg, p->membase + BYT_PRV_CLK);\n100 \treg |= BYT_PRV_CLK_EN | BYT_PRV_CLK_UPDATE;\n101 \twritel(reg, p->membase + BYT_PRV_CLK);\n102\n103 \tdw8250_do_set_termios(p, termios, old);\n104 }"
                    },
                    {
                        "file_path": "drivers/tty/serial/8250/8250_lpss.c",
                        "function_body": "116 static int byt_serial_setup(struct lpss8250 *lpss, struct uart_port *port)\n117 {\n118 \tstruct dw_dma_slave *param = &lpss->dma_param;\n119 \tstruct pci_dev *pdev = to_pci_dev(port->dev);\n120 \tstruct pci_dev *dma_dev;\n121 \n122 \tswitch (pdev->device) {\n123 \tcase PCI_DEVICE_ID_INTEL_BYT_UART1:\n124 \tcase PCI_DEVICE_ID_INTEL_BSW_UART1:\n125 \tcase PCI_DEVICE_ID_INTEL_BDW_UART1:\n126 \t\tparam->src_id = 3;\n127 \t\tparam->dst_id = 2;\n128 \t\tbreak;\n129 \tcase PCI_DEVICE_ID_INTEL_BYT_UART2:\n130 \tcase PCI_DEVICE_ID_INTEL_BSW_UART2:\n131 \tcase PCI_DEVICE_ID_INTEL_BDW_UART2:\n132 \t\tparam->src_id = 5;\n133 \t\tparam->dst_id = 4;\n134 \t\tbreak;\n135 \tdefault:\n136 \t\treturn -EINVAL;\n137 \t}\n138 \n139 \tdma_dev = pci_get_slot(pdev->bus, PCI_DEVFN(PCI_SLOT(pdev->devfn), 0));\n40 \n141 \tparam->dma_dev = &dma_dev->dev;\n142 \tparam->m_master = 0;\n143 \tparam->p_master = 1;\n144 \n145 \tlpss->dma_maxburst = 16;\n146 \n147 \tport->set_termios = byt_set_termios;\n148 \tport->get_mctrl = byt_get_mctrl;\n149 \n150 \t/* Disable TX counter interrupts */\n151 \twritel(BYT_TX_OVF_INT_MASK, port->membase + BYT_TX_OVF_INT);\n152 \n153 \treturn 0;\n154 }\n"
                    }
                ]
            }
        ],
        "sink": "fuart *= rounddown_pow_of_two(fref / fuart);",
        "final_sink": "fuart *= rounddown_pow_of_two(fref / fuart);"
    },
    {
        "prt": "pck_min",
        "function_call": [
            "bool dispc_div_calc(unsigned long dispc,\n\t\tunsigned long pck_min, unsigned long pck_max,\n\t\tdispc_div_calc_func func, void *data)\n{\n\tint lckd, lckd_start, lckd_stop;\n\tint pckd, pckd_start, pckd_stop;\n\tunsigned long pck, lck;\n\tunsigned long lck_max;\n\tunsigned long pckd_hw_min, pckd_hw_max;\n\tunsigned min_fck_per_pck;\n\tunsigned long fck;\n\n#ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n\tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n#else\n\tmin_fck_per_pck = 0;\n#endif\n\n\tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n\tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n\n\tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n\n\tpck_min = pck_min ? pck_min : 1;\n\tpck_max = pck_max ? pck_max : ULONG_MAX;\n\n\tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n\tlckd_stop = min(dispc / pck_min, 255ul);\n\n\tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n\t\tlck = dispc / lckd;\n\n\t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n\t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n\n\t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n\t\t\tpck = lck / pckd;\n\n\t\t\t/*\n\t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n\t\t\t * clock, which means we're configuring DISPC fclk here\n\t\t\t * also. Thus we need to use the calculated lck. For\n\t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n\t\t\t */\n\t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n\t\t\t\tfck = dispc_core_clk_rate();\n\t\t\telse\n\t\t\t\tfck = lck;\n\n\t\t\tif (fck < pck * min_fck_per_pck)\n\t\t\t\tcontinue;\n\n\t\t\tif (func(lckd, pckd, lck, pck, data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        ],
        "source": [
            "        pck_min = pck_min ? pck_min : 1;"
        ],
        "index": 7,
        "location": {
            "file_path": "linux-6.9.6/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
            "region": {
                "startLine": 3617,
                "startColumn": 24,
                "endColumn": 24
            },
            "context": {
                "startLine": 3615,
                "endLine": 3619,
                "snippet": {
                    "text": "lckd_stop = min(dispc / pck_min, 255ul);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dpi.c",
                        "function_body": "172 static bool dpi_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n173 \t\tvoid *data)\n174 {\n175 \tstruct dpi_clk_calc_ctx *ctx = data;\n176\n177 \t/*\n178 \t * Odd dividers give us uneven duty cycle, causing problem when level\n179 \t * shifted. So skip all odd dividers when the pixel clock is on the\n180 \t * higher side.\n181 \t */\n182 \tif (m_dispc > 1 && m_dispc % 2 != 0 && ctx->pck_min >= 100000000)\n183 \t\treturn false;\n184\n185 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n186 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n187\n188 \treturn dispc_div_calc(dispc, ctx->pck_min, ctx->pck_max,\n189 \t\t\tdpi_calc_dispc_cb, ctx);\n190 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dsi.c",
                        "function_body": "3971 static bool dsi_vm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n3972 \t\tvoid *data)\n3973 {\n3974 \tstruct dsi_clk_calc_ctx *ctx = data;\n3975 \tunsigned long pck_max;\n3976\n3977 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n3978 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n3979\n3980 \t/*\n3981 \t * In burst mode we can let the dispc pck be arbitrarily high, but it\n3982 \t * limits our scaling abilities. So for now, don't aim too high.\n3983 \t */\n3984\n3985 \tif (ctx->config->trans_mode == OMAP_DSS_DSI_BURST_MODE)\n3986 \t\tpck_max = ctx->req_pck_max + 10000000;\n3987 \telse\n3988 \t\tpck_max = ctx->req_pck_max;\n3989\n3990 \treturn dispc_div_calc(ctx->dsi->dss->dispc, dispc,\n3991 \t\t\t      ctx->req_pck_min, pck_max,\n3992 \t\t\t      dsi_vm_calc_dispc_cb, ctx);\n3993 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dsi.c",
                        "function_body": "4423 static bool dsi_cm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n4424 \t\tvoid *data)\n4425 {\n4426 \tstruct dsi_clk_calc_ctx *ctx = data;\n4427\n4428 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n4429 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n4430\n4431 \treturn dispc_div_calc(dispc, ctx->req_pck_min, ctx->req_pck_max,\n4432 \t\t\tdsi_cm_calc_dispc_cb, ctx);\n4433 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/sdi.c",
                        "function_body": "59 static bool dpi_calc_dss_cb(unsigned long fck, void *data)\n60 {\n61 \tstruct sdi_clk_calc_ctx *ctx = data;\n62\n63 \tctx->fck = fck;\n64\n65 \treturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\n66 \t\t\tdpi_calc_dispc_cb, ctx);\n67 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dpi.c",
                        "function_body": "208 static bool dpi_calc_dss_cb(unsigned long fck, void *data)\n209 {\n210 \tstruct dpi_clk_calc_ctx *ctx = data;\n211\n212 \tctx->fck = fck;\n213\n214 \treturn dispc_div_calc(ctx->dpi->dss->dispc, fck,\n215 \t\t\t      ctx->pck_min, ctx->pck_max,\n216 \t\t\t      dpi_calc_dispc_cb, ctx);\n217 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dsi.c",
                        "function_body": "4710 static bool dsi_vm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n4711 \t\tvoid *data)\n4712 {\n4713 \tstruct dsi_clk_calc_ctx *ctx = data;\n4714 \tunsigned long pck_max;\n4715\n4716 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n4717 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n4718\n4719 \t/*\n4720 \t * In burst mode we can let the dispc pck be arbitrarily high, but it\n4721 \t * limits our scaling abilities. So for now, don't aim too high.\n4722 \t */\n4723\n4724 \tif (ctx->config->trans_mode == OMAP_DSS_DSI_BURST_MODE)\n4725 \t\tpck_max = ctx->req_pck_max + 10000000;\n4726 \telse\n4727 \t\tpck_max = ctx->req_pck_max;\n4728\n4729 \treturn dispc_div_calc(dispc, ctx->req_pck_min, pck_max,\n4730 \t\t\tdsi_vm_calc_dispc_cb, ctx);\n4731 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dsi.c",
                        "function_body": "3682 static bool dsi_cm_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n3683 \t\tvoid *data)\n3684 {\n3685 \tstruct dsi_clk_calc_ctx *ctx = data;\n3686\n3687 \tctx->dsi_cinfo.mX[HSDIV_DISPC] = m_dispc;\n3688 \tctx->dsi_cinfo.clkout[HSDIV_DISPC] = dispc;\n3689\n3690 \treturn dispc_div_calc(ctx->dsi->dss->dispc, dispc,\n3691 \t\t\t      ctx->req_pck_min, ctx->req_pck_max,\n3692 \t\t\t      dsi_cm_calc_dispc_cb, ctx);\n3693 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dpi.c",
                        "function_body": "209 static bool dpi_calc_dss_cb(unsigned long fck, void *data)\n210 {\n211 \tstruct dpi_clk_calc_ctx *ctx = data;\n212\n213 \tctx->fck = fck;\n214\n215 \treturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\n216 \t\t\tdpi_calc_dispc_cb, ctx);\n217 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/sdi.c",
                        "function_body": "62 static bool dpi_calc_dss_cb(unsigned long fck, void *data)\n63 {\n64 \tstruct sdi_clk_calc_ctx *ctx = data;\n65\n66 \tctx->fck = fck;\n67\n68 \treturn dispc_div_calc(ctx->sdi->dss->dispc, fck,\n69 \t\t\t      ctx->pck_min, ctx->pck_max,\n70 \t\t\t      dpi_calc_dispc_cb, ctx);\n71 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dispc.c",
                        "function_body": "3590 bool dispc_div_calc(unsigned long dispc,\n3591 \t\tunsigned long pck_min, unsigned long pck_max,\n3592 \t\tdispc_div_calc_func func, void *data)\n3593 {\n3594 \tint lckd, lckd_start, lckd_stop;\n3595 \tint pckd, pckd_start, pckd_stop;\n3596 \tunsigned long pck, lck;\n3597 \tunsigned long lck_max;\n3598 \tunsigned long pckd_hw_min, pckd_hw_max;\n3599 \tunsigned min_fck_per_pck;\n3600 \tunsigned long fck;\n3601\n3602 #ifdef CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK\n3603 \tmin_fck_per_pck = CONFIG_FB_OMAP2_DSS_MIN_FCK_PER_PCK;\n3604 #else\n3605 \tmin_fck_per_pck = 0;\n3606 #endif\n3607\n3608 \tpckd_hw_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\n3609 \tpckd_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\n3610\n3611 \tlck_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n3612\n3613 \tpck_min = pck_min ? pck_min : 1;\n3614 \tpck_max = pck_max ? pck_max : ULONG_MAX;\n3615\n3616 \tlckd_start = max(DIV_ROUND_UP(dispc, lck_max), 1ul);\n3617 \tlckd_stop = min(dispc / pck_min, 255ul);\n3618\n3619 \tfor (lckd = lckd_start; lckd <= lckd_stop; ++lckd) {\n3620 \t\tlck = dispc / lckd;\n3621\n3622 \t\tpckd_start = max(DIV_ROUND_UP(lck, pck_max), pckd_hw_min);\n3623 \t\tpckd_stop = min(lck / pck_min, pckd_hw_max);\n3624\n3625 \t\tfor (pckd = pckd_start; pckd <= pckd_stop; ++pckd) {\n3626 \t\t\tpck = lck / pckd;\n3627\n3628 \t\t\t/*\n3629 \t\t\t * For OMAP2/3 the DISPC fclk is the same as LCD's logic\n3630 \t\t\t * clock, which means we're configuring DISPC fclk here\n3631 \t\t\t * also. Thus we need to use the calculated lck. For\n3632 \t\t\t * OMAP4+ the DISPC fclk is a separate clock.\n3633 \t\t\t */\n3634 \t\t\tif (dss_has_feature(FEAT_CORE_CLK_DIV))\n3635 \t\t\t\tfck = dispc_core_clk_rate();\n3636 \t\t\telse\n3637 \t\t\t\tfck = lck;\n3638\n3639 \t\t\tif (fck < pck * min_fck_per_pck)\n3640 \t\t\t\tcontinue;\n3641\n3642 \t\t\tif (func(lckd, pckd, lck, pck, data))\n3643 \t\t\t\treturn true;\n3644 \t\t}\n3645 \t}\n3646\n3647 \treturn false;\n3648 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dpi.c",
                        "function_body": "178 static bool dpi_calc_hsdiv_cb(int m_dispc, unsigned long dispc,\n179 \t\tvoid *data)\n180 {\n181 \tstruct dpi_clk_calc_ctx *ctx = data;\n182\n183 \tctx->pll_cinfo.mX[ctx->clkout_idx] = m_dispc;\n184 \tctx->pll_cinfo.clkout[ctx->clkout_idx] = dispc;\n185\n186 \treturn dispc_div_calc(ctx->dpi->dss->dispc, dispc,\n187 \t\t\t      ctx->pck_min, ctx->pck_max,\n188 \t\t\t      dpi_calc_dispc_cb, ctx);\n189 }"
                    }
                ]
            }
        ],
        "sink": "lckd_stop = min(dispc / pck_min, 255ul);",
        "final_sink": "lckd_stop = min(dispc / pck_min, 255ul);"
    },
    {
        "prt": "fck_min",
        "function_call": [
            "bool dss_div_calc(unsigned long pck, unsigned long fck_min,\n\t\tdss_div_calc_func func, void *data)\n{\n\tint fckd, fckd_start, fckd_stop;\n\tunsigned long fck;\n\tunsigned long fck_hw_max;\n\tunsigned long fckd_hw_max;\n\tunsigned long prate;\n\tunsigned m;\n\n\tfck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n\n\tif (dss.parent_clk == NULL) {\n\t\tunsigned pckd;\n\n\t\tpckd = fck_hw_max / pck;\n\n\t\tfck = pck * pckd;\n\n\t\tfck = clk_round_rate(dss.dss_clk, fck);\n\n\t\treturn func(fck, data);\n\t}\n\n\tfckd_hw_max = dss.feat->fck_div_max;\n\n\tm = dss.feat->dss_fck_multiplier;\n\tprate = clk_get_rate(dss.parent_clk);\n\n\tfck_min = fck_min ? fck_min : 1;\n\n\tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n\tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n\n\tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n\t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n\n\t\tif (func(fck, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        ],
        "source": [
            "        fck_min = fck_min ? fck_min : 1;"
        ],
        "index": 8,
        "location": {
            "file_path": "linux-6.9.6/drivers/video/fbdev/omap2/omapfb/dss/dss.c",
            "region": {
                "startLine": 541,
                "startColumn": 29,
                "endColumn": 29
            },
            "context": {
                "startLine": 539,
                "endLine": 543,
                "snippet": {
                    "text": "fckd_start = min(prate * m / fck_min, fckd_hw_max);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dss.c",
                        "function_body": "510 bool dss_div_calc(unsigned long pck, unsigned long fck_min,\n511 \t\tdss_div_calc_func func, void *data)\n512 {\n513 \tint fckd, fckd_start, fckd_stop;\n514 \tunsigned long fck;\n515 \tunsigned long fck_hw_max;\n516 \tunsigned long fckd_hw_max;\n517 \tunsigned long prate;\n518 \tunsigned m;\n519\n520 \tfck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n521\n522 \tif (dss.parent_clk == NULL) {\n523 \t\tunsigned pckd;\n524\n525 \t\tpckd = fck_hw_max / pck;\n526\n527 \t\tfck = pck * pckd;\n528\n529 \t\tfck = clk_round_rate(dss.dss_clk, fck);\n530\n531 \t\treturn func(fck, data);\n532 \t}\n533\n534 \tfckd_hw_max = dss.feat->fck_div_max;\n535\n536 \tm = dss.feat->dss_fck_multiplier;\n537 \tprate = clk_get_rate(dss.parent_clk);\n538\n539 \tfck_min = fck_min ? fck_min : 1;\n540\n541 \tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n542 \tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n543\n544 \tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n545 \t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n546\n547 \t\tif (func(fck, data))\n548 \t\t\treturn true;\n549 \t}\n550\n551 \treturn false;\n552 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/sdi.c",
                        "function_body": "69 static int sdi_calc_clock_div(unsigned long pclk,\n70 \t\tunsigned long *fck,\n71 \t\tstruct dispc_clock_info *dispc_cinfo)\n72 {\n73 \tint i;\n74 \tstruct sdi_clk_calc_ctx ctx;\n75\n76 \t/*\n77 \t * DSS fclk gives us very few possibilities, so finding a good pixel\n78 \t * clock may not be possible. We try multiple times to find the clock,\n79 \t * each time widening the pixel clock range we look for, up to\n80 \t * +/- 1MHz.\n81 \t */\n82\n83 \tfor (i = 0; i < 10; ++i) {\n84 \t\tbool ok;\n85\n86 \t\tmemset(&ctx, 0, sizeof(ctx));\n87 \t\tif (pclk > 1000 * i * i * i)\n88 \t\t\tctx.pck_min = max(pclk - 1000 * i * i * i, 0lu);\n89 \t\telse\n90 \t\t\tctx.pck_min = 0;\n91 \t\tctx.pck_max = pclk + 1000 * i * i * i;\n92\n93 \t\tok = dss_div_calc(pclk, ctx.pck_min, dpi_calc_dss_cb, &ctx);\n94 \t\tif (ok) {\n95 \t\t\t*fck = ctx.fck;\n96 \t\t\t*dispc_cinfo = ctx.dispc_cinfo;\n97 \t\t\treturn 0;\n98 \t\t}\n99 \t}\n100\n101 \treturn -EINVAL;\n102 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dss.c",
                        "function_body": "510 bool dss_div_calc(unsigned long pck, unsigned long fck_min,\n511 \t\tdss_div_calc_func func, void *data)\n512 {\n513 \tint fckd, fckd_start, fckd_stop;\n514 \tunsigned long fck;\n515 \tunsigned long fck_hw_max;\n516 \tunsigned long fckd_hw_max;\n517 \tunsigned long prate;\n518 \tunsigned m;\n519\n520 \tfck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n521\n522 \tif (dss.parent_clk == NULL) {\n523 \t\tunsigned pckd;\n524\n525 \t\tpckd = fck_hw_max / pck;\n526\n527 \t\tfck = pck * pckd;\n528\n529 \t\tfck = clk_round_rate(dss.dss_clk, fck);\n530\n531 \t\treturn func(fck, data);\n532 \t}\n533\n534 \tfckd_hw_max = dss.feat->fck_div_max;\n535\n536 \tm = dss.feat->dss_fck_multiplier;\n537 \tprate = clk_get_rate(dss.parent_clk);\n538\n539 \tfck_min = fck_min ? fck_min : 1;\n540\n541 \tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n542 \tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n543\n544 \tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n545 \t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n546\n547 \t\tif (func(fck, data))\n548 \t\t\treturn true;\n549 \t}\n550\n551 \treturn false;\n552 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/dpi.c",
                        "function_body": "254 static bool dpi_dss_clk_calc(struct dpi_data *dpi, unsigned long pck,\n255 \t\t\t     struct dpi_clk_calc_ctx *ctx)\n256 {\n257 \tint i;\n258\n259 \t/*\n260 \t * DSS fck gives us very few possibilities, so finding a good pixel\n261 \t * clock may not be possible. We try multiple times to find the clock,\n262 \t * each time widening the pixel clock range we look for, up to\n263 \t * +/- ~15MHz.\n264 \t */\n265\n266 \tfor (i = 0; i < 25; ++i) {\n267 \t\tbool ok;\n268\n269 \t\tmemset(ctx, 0, sizeof(*ctx));\n270 \t\tctx->dpi = dpi;\n271 \t\tif (pck > 1000 * i * i * i)\n272 \t\t\tctx->pck_min = max(pck - 1000 * i * i * i, 0lu);\n273 \t\telse\n274 \t\t\tctx->pck_min = 0;\n275 \t\tctx->pck_max = pck + 1000 * i * i * i;\n276\n277 \t\tok = dss_div_calc(dpi->dss, pck, ctx->pck_min,\n278 \t\t\t\t  dpi_calc_dss_cb, ctx);\n279 \t\tif (ok)\n280 \t\t\treturn ok;\n281 \t}\n282\n283 \treturn false;\n284 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dss.c",
                        "function_body": "510 bool dss_div_calc(unsigned long pck, unsigned long fck_min,\n511 \t\tdss_div_calc_func func, void *data)\n512 {\n513 \tint fckd, fckd_start, fckd_stop;\n514 \tunsigned long fck;\n515 \tunsigned long fck_hw_max;\n516 \tunsigned long fckd_hw_max;\n517 \tunsigned long prate;\n518 \tunsigned m;\n519\n520 \tfck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n521\n522 \tif (dss.parent_clk == NULL) {\n523 \t\tunsigned pckd;\n524\n525 \t\tpckd = fck_hw_max / pck;\n526\n527 \t\tfck = pck * pckd;\n528\n529 \t\tfck = clk_round_rate(dss.dss_clk, fck);\n530\n531 \t\treturn func(fck, data);\n532 \t}\n533\n534 \tfckd_hw_max = dss.feat->fck_div_max;\n535\n536 \tm = dss.feat->dss_fck_multiplier;\n537 \tprate = clk_get_rate(dss.parent_clk);\n538\n539 \tfck_min = fck_min ? fck_min : 1;\n540\n541 \tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n542 \tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n543\n544 \tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n545 \t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n546\n547 \t\tif (func(fck, data))\n548 \t\t\treturn true;\n549 \t}\n550\n551 \treturn false;\n552 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dpi.c",
                        "function_body": "240 static bool dpi_dss_clk_calc(unsigned long pck, struct dpi_clk_calc_ctx *ctx)\n241 {\n242 \tint i;\n243\n244 \t/*\n245 \t * DSS fck gives us very few possibilities, so finding a good pixel\n246 \t * clock may not be possible. We try multiple times to find the clock,\n247 \t * each time widening the pixel clock range we look for, up to\n248 \t * +/- ~15MHz.\n249 \t */\n250\n251 \tfor (i = 0; i < 25; ++i) {\n252 \t\tbool ok;\n253\n254 \t\tmemset(ctx, 0, sizeof(*ctx));\n255 \t\tif (pck > 1000 * i * i * i)\n256 \t\t\tctx->pck_min = max(pck - 1000 * i * i * i, 0lu);\n257 \t\telse\n258 \t\t\tctx->pck_min = 0;\n259 \t\tctx->pck_max = pck + 1000 * i * i * i;\n260\n261 \t\tok = dss_div_calc(pck, ctx->pck_min, dpi_calc_dss_cb, ctx);\n262 \t\tif (ok)\n263 \t\t\treturn ok;\n264 \t}\n265\n266 \treturn false;\n267 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dss.c",
                        "function_body": "510 bool dss_div_calc(unsigned long pck, unsigned long fck_min,\n511 \t\tdss_div_calc_func func, void *data)\n512 {\n513 \tint fckd, fckd_start, fckd_stop;\n514 \tunsigned long fck;\n515 \tunsigned long fck_hw_max;\n516 \tunsigned long fckd_hw_max;\n517 \tunsigned long prate;\n518 \tunsigned m;\n519\n520 \tfck_hw_max = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\n521\n522 \tif (dss.parent_clk == NULL) {\n523 \t\tunsigned pckd;\n524\n525 \t\tpckd = fck_hw_max / pck;\n526\n527 \t\tfck = pck * pckd;\n528\n529 \t\tfck = clk_round_rate(dss.dss_clk, fck);\n530\n531 \t\treturn func(fck, data);\n532 \t}\n533\n534 \tfckd_hw_max = dss.feat->fck_div_max;\n535\n536 \tm = dss.feat->dss_fck_multiplier;\n537 \tprate = clk_get_rate(dss.parent_clk);\n538\n539 \tfck_min = fck_min ? fck_min : 1;\n540\n541 \tfckd_start = min(prate * m / fck_min, fckd_hw_max);\n542 \tfckd_stop = max(DIV_ROUND_UP(prate * m, fck_hw_max), 1ul);\n543\n544 \tfor (fckd = fckd_start; fckd >= fckd_stop; --fckd) {\n545 \t\tfck = DIV_ROUND_UP(prate, fckd) * m;\n546\n547 \t\tif (func(fck, data))\n548 \t\t\treturn true;\n549 \t}\n550\n551 \treturn false;\n552 }"
                    },
                    {
                        "file_path": "/drivers/gpu/drm/omapdrm/dss/sdi.c",
                        "function_body": "73 static int sdi_calc_clock_div(struct sdi_device *sdi, unsigned long pclk,\n74 \t\t\t      unsigned long *fck,\n75 \t\t\t      struct dispc_clock_info *dispc_cinfo)\n76 {\n77 \tint i;\n78 \tstruct sdi_clk_calc_ctx ctx;\n79\n80 \t/*\n81 \t * DSS fclk gives us very few possibilities, so finding a good pixel\n82 \t * clock may not be possible. We try multiple times to find the clock,\n83 \t * each time widening the pixel clock range we look for, up to\n84 \t * +/- 1MHz.\n85 \t */\n86\n87 \tfor (i = 0; i < 10; ++i) {\n88 \t\tbool ok;\n89\n90 \t\tmemset(&ctx, 0, sizeof(ctx));\n91\n92 \t\tctx.sdi = sdi;\n93\n94 \t\tif (pclk > 1000 * i * i * i)\n95 \t\t\tctx.pck_min = max(pclk - 1000 * i * i * i, 0lu);\n96 \t\telse\n97 \t\t\tctx.pck_min = 0;\n98 \t\tctx.pck_max = pclk + 1000 * i * i * i;\n99\n100 \t\tok = dss_div_calc(sdi->dss, pclk, ctx.pck_min,\n101 \t\t\t\t  dpi_calc_dss_cb, &ctx);\n102 \t\tif (ok) {\n103 \t\t\t*fck = ctx.fck;\n104 \t\t\t*dispc_cinfo = ctx.dispc_cinfo;\n105 \t\t\treturn 0;\n106 \t\t}\n107 \t}\n108\n109 \treturn -EINVAL;\n110 }"
                    }
                ]
            }
        ],
        "sink": "fckd_start = min(prate * m / fck_min, fckd_hw_max);",
        "final_sink": "fckd_start = min(prate * m / fck_min, fckd_hw_max);"
    },
    {
        "prt": "out_min",
        "function_call": [
            "bool dss_pll_hsdiv_calc(const struct dss_pll *pll, unsigned long clkdco,\n\t\tunsigned long out_min, unsigned long out_max,\n\t\tdss_hsdiv_calc_func func, void *data)\n{\n\tconst struct dss_pll_hw *hw = pll->hw;\n\tint m, m_start, m_stop;\n\tunsigned long out;\n\n\tout_min = out_min ? out_min : 1;\n\tout_max = out_max ? out_max : ULONG_MAX;\n\n\tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n\n\tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n\n\tfor (m = m_start; m <= m_stop; ++m) {\n\t\tout = clkdco / m;\n\n\t\tif (func(m, out, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        ],
        "source": [
            "        out_min = out_min ? out_min : 1;"
        ],
        "index": 9,
        "location": {
            "file_path": "linux-6.9.6/drivers/video/fbdev/omap2/omapfb/dss/pll.c",
            "region": {
                "startLine": 134,
                "startColumn": 33,
                "endColumn": 33
            },
            "context": {
                "startLine": 132,
                "endLine": 136,
                "snippet": {
                    "text": "m_stop = min((unsigned)(clkdco / out_min), hw->mX_max);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/pll.c",
                        "function_body": "121 bool dss_pll_hsdiv_calc(const struct dss_pll *pll, unsigned long clkdco,\n122 \t\tunsigned long out_min, unsigned long out_max,\n123 \t\tdss_hsdiv_calc_func func, void *data)\n124 {\n125 \tconst struct dss_pll_hw *hw = pll->hw;\n126 \tint m, m_start, m_stop;\n127 \tunsigned long out;\n128\n129 \tout_min = out_min ? out_min : 1;\n130 \tout_max = out_max ? out_max : ULONG_MAX;\n131\n132 \tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n133\n134 \tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n135\n136 \tfor (m = m_start; m <= m_stop; ++m) {\n137 \t\tout = clkdco / m;\n138\n139 \t\tif (func(m, out, data))\n140 \t\t\treturn true;\n141 \t}\n142\n143 \treturn false;\n144 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dpi.c",
                        "function_body": "193 static bool dpi_calc_pll_cb(int n, int m, unsigned long fint,\n194 \t\tunsigned long clkdco,\n195 \t\tvoid *data)\n196 {\n197 \tstruct dpi_clk_calc_ctx *ctx = data;\n198\n199 \tctx->dsi_cinfo.n = n;\n200 \tctx->dsi_cinfo.m = m;\n201 \tctx->dsi_cinfo.fint = fint;\n202 \tctx->dsi_cinfo.clkdco = clkdco;\n203\n204 \treturn dss_pll_hsdiv_calc(ctx->pll, clkdco,\n205 \t\tctx->pck_min, dss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\n206 \t\tdpi_calc_hsdiv_cb, ctx);\n207 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/pll.c",
                        "function_body": "121 bool dss_pll_hsdiv_calc(const struct dss_pll *pll, unsigned long clkdco,\n122 \t\tunsigned long out_min, unsigned long out_max,\n123 \t\tdss_hsdiv_calc_func func, void *data)\n124 {\n125 \tconst struct dss_pll_hw *hw = pll->hw;\n126 \tint m, m_start, m_stop;\n127 \tunsigned long out;\n128\n129 \tout_min = out_min ? out_min : 1;\n130 \tout_max = out_max ? out_max : ULONG_MAX;\n131\n132 \tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n133\n134 \tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n135\n136 \tfor (m = m_start; m <= m_stop; ++m) {\n137 \t\tout = clkdco / m;\n138\n139 \t\tif (func(m, out, data))\n140 \t\t\treturn true;\n141 \t}\n142\n143 \treturn false;\n144 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dsi.c",
                        "function_body": "4733 static bool dsi_vm_calc_pll_cb(int n, int m, unsigned long fint,\n4734 \t\tunsigned long clkdco, void *data)\n4735 {\n4736 \tstruct dsi_clk_calc_ctx *ctx = data;\n4737\n4738 \tctx->dsi_cinfo.n = n;\n4739 \tctx->dsi_cinfo.m = m;\n4740 \tctx->dsi_cinfo.fint = fint;\n4741 \tctx->dsi_cinfo.clkdco = clkdco;\n4742\n4743 \treturn dss_pll_hsdiv_calc(ctx->pll, clkdco, ctx->req_pck_min,\n4744 \t\t\tdss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\n4745 \t\t\tdsi_vm_calc_hsdiv_cb, ctx);\n4746 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tools/virtio/linux/kernel.h",
                        "function_body": "138 #define min(x, y) ({\t\t\t\t\\\n139 \ttypeof(x) _min1 = (x);\t\t\t\\\n140 \ttypeof(y) _min2 = (y);\t\t\t\\\n141 \t(void) (&_min1 == &_min2);\t\t\\\n142 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/thermal/tmon/tui.c",
                        "function_body": "24 #define min(x, y) ({\t\t\t\t\\\n25 \ttypeof(x) _min1 = (x);\t\t\t\\\n26 \ttypeof(y) _min2 = (y);\t\t\t\\\n27 \t(void) (&_min1 == &_min2);\t\t\\\n28 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/testing/selftests/sparc64/drivers/adi-test.c",
                        "function_body": "48 #define min(x, y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/tools/testing/selftests/net/tcp_mmap.c",
                        "function_body": "76 #define min(a, b)  ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/progs/tcp_ca_write_sk_pacing.c",
                        "function_body": "12 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/selftests/bpf/bpf_tcp_helpers.h",
                        "function_body": "193 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/tools/testing/scatterlist/linux/mm.h",
                        "function_body": "67 #define min(x, y)                                       \\\n68 \t__min(typeof(x), typeof(y),                     \\\n69 \t      __UNIQUE_ID(min1_), __UNIQUE_ID(min2_),   \\\n70 \t      x, y)"
                    },
                    {
                        "file_path": "/tools/lib/bpf/libbpf_internal.h",
                        "function_body": "101 # define min(x, y) ((x) < (y) ? (x) : (y))"
                    },
                    {
                        "file_path": "/tools/include/linux/kernel.h",
                        "function_body": "50 #define min(x, y) ({\t\t\t\t\\\n51 \ttypeof(x) _min1 = (x);\t\t\t\\\n52 \ttypeof(y) _min2 = (y);\t\t\t\\\n53 \t(void) (&_min1 == &_min2);\t\t\\\n54 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/tools/arch/x86/intel_sdsi/intel_sdsi.c",
                        "function_body": "29 #define min(x, y) ({                            \\\n30 \ttypeof(x) _min1 = (x);                  \\\n31 \ttypeof(y) _min2 = (y);                  \\\n32 \t(void) (&_min1 == &_min2);              \\\n33 \t_min1 < _min2 ? _min1 : _min2; })"
                    },
                    {
                        "file_path": "/scripts/kconfig/nconf.h",
                        "function_body": "30 #define min(a, b) ({\\\n31 \t\ttypeof(a) _a = a;\\\n32 \t\ttypeof(b) _b = b;\\\n33 \t\t_a < _b ? _a : _b; })"
                    },
                    {
                        "file_path": "/samples/bpf/test_lru_dist.c",
                        "function_body": "23 #define min(a, b) ((a) < (b) ? (a) : (b))"
                    },
                    {
                        "file_path": "/include/linux/minmax.h",
                        "function_body": "85 #define min(x, y)\t__careful_cmp(min, x, y)"
                    },
                    {
                        "file_path": "/drivers/scsi/ips.h",
                        "function_body": "92       #define min(x,y) ((x) < (y) ? x : y)"
                    },
                    {
                        "file_path": "/arch/powerpc/boot/types.h",
                        "function_body": "28 #define min(x,y) ({ \\\n29 \ttypeof(x) _x = (x);\t\\\n30 \ttypeof(y) _y = (y);\t\\\n31 \t(void) (&_x == &_y);\t\\\n32 \t_x < _y ? _x : _y; })"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/pll.c",
                        "function_body": "121 bool dss_pll_hsdiv_calc(const struct dss_pll *pll, unsigned long clkdco,\n122 \t\tunsigned long out_min, unsigned long out_max,\n123 \t\tdss_hsdiv_calc_func func, void *data)\n124 {\n125 \tconst struct dss_pll_hw *hw = pll->hw;\n126 \tint m, m_start, m_stop;\n127 \tunsigned long out;\n128\n129 \tout_min = out_min ? out_min : 1;\n130 \tout_max = out_max ? out_max : ULONG_MAX;\n131\n132 \tm_start = max(DIV_ROUND_UP(clkdco, out_max), 1ul);\n133\n134 \tm_stop = min((unsigned)(clkdco / out_min), hw->mX_max);\n135\n136 \tfor (m = m_start; m <= m_stop; ++m) {\n137 \t\tout = clkdco / m;\n138\n139 \t\tif (func(m, out, data))\n140 \t\t\treturn true;\n141 \t}\n142\n143 \treturn false;\n144 }"
                    },
                    {
                        "file_path": "/drivers/video/fbdev/omap2/omapfb/dss/dsi.c",
                        "function_body": "4435 static bool dsi_cm_calc_pll_cb(int n, int m, unsigned long fint,\n4436 \t\tunsigned long clkdco, void *data)\n4437 {\n4438 \tstruct dsi_clk_calc_ctx *ctx = data;\n4439\n4440 \tctx->dsi_cinfo.n = n;\n4441 \tctx->dsi_cinfo.m = m;\n4442 \tctx->dsi_cinfo.fint = fint;\n4443 \tctx->dsi_cinfo.clkdco = clkdco;\n4444\n4445 \treturn dss_pll_hsdiv_calc(ctx->pll, clkdco, ctx->req_pck_min,\n4446 \t\t\tdss_feat_get_param_max(FEAT_PARAM_DSS_FCK),\n4447 \t\t\tdsi_cm_calc_hsdiv_cb, ctx);\n4448 }"
                    }
                ]
            }
        ],
        "sink": "m_stop = min((unsigned)(clkdco / out_min), hw->mX_max);",
        "final_sink": "m_stop = min((unsigned)(clkdco / out_min), hw->mX_max);"
    },
    {
        "prt": "blocksize",
        "function_call": [
            "static int affs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct affs_sb_info\t*sbi;\n\tstruct buffer_head\t*root_bh = NULL;\n\tstruct buffer_head\t*boot_bh;\n\tstruct inode\t\t*root_inode = NULL;\n\ts32\t\t\t root_block;\n\tint\t\t\t size, blocksize;\n\tu32\t\t\t chksum;\n\tint\t\t\t num_bm;\n\tint\t\t\t i, j;\n\tkuid_t\t\t\t uid;\n\tkgid_t\t\t\t gid;\n\tint\t\t\t reserved;\n\tunsigned long\t\t mount_flags;\n\tint\t\t\t tmp_flags;\t/* fix remount prototype... */\n\tu8\t\t\t sig[4];\n\tint\t\t\t ret;\n\n\tpr_debug(\"read_super(%s)\\n\", data ? (const char *)data : \"no options\");\n\n\tsb->s_magic             = AFFS_SUPER_MAGIC;\n\tsb->s_op                = &affs_sops;\n\tsb->s_flags |= SB_NODIRATIME;\n\n\tsb->s_time_gran = NSEC_PER_SEC;\n\tsb->s_time_min = sys_tz.tz_minuteswest * 60 + AFFS_EPOCH_DELTA;\n\tsb->s_time_max = 86400LL * U32_MAX + 86400 + sb->s_time_min;\n\n\tsbi = kzalloc(sizeof(struct affs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\tsbi->sb = sb;\n\tmutex_init(&sbi->s_bmlock);\n\tspin_lock_init(&sbi->symlink_lock);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sb_work, flush_superblock);\n\n\tif (!parse_options(data,&uid,&gid,&i,&reserved,&root_block,\n\t\t\t\t&blocksize,&sbi->s_prefix,\n\t\t\t\tsbi->s_volume, &mount_flags)) {\n\t\tpr_err(\"Error parsing options\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* N.B. after this point s_prefix must be released */\n\n\tsbi->s_flags   = mount_flags;\n\tsbi->s_mode    = i;\n\tsbi->s_uid     = uid;\n\tsbi->s_gid     = gid;\n\tsbi->s_reserved= reserved;\n\n\t/* Get the size of the device in 512-byte blocks.\n\t * If we later see that the partition uses bigger\n\t * blocks, we will have to change it.\n\t */\n\n\tsize = bdev_nr_sectors(sb->s_bdev);\n\tpr_debug(\"initial blocksize=%d, #blocks=%d\\n\", 512, size);\n\n\taffs_set_blocksize(sb, PAGE_SIZE);\n\t/* Try to find root block. Its location depends on the block size. */\n\n\ti = bdev_logical_block_size(sb->s_bdev);\n\tj = PAGE_SIZE;\n\tif (blocksize > 0) {\n\t\ti = j = blocksize;\n\t\tsize = size / (blocksize / 512);\n\t}\n\n\tfor (blocksize = i; blocksize <= j; blocksize <<= 1, size >>= 1) {\n\t\tsbi->s_root_block = root_block;\n\t\tif (root_block < 0)\n\t\t\tsbi->s_root_block = (reserved + size - 1) / 2;\n\t\tpr_debug(\"setting blocksize to %d\\n\", blocksize);\n\t\taffs_set_blocksize(sb, blocksize);\n\t\tsbi->s_partition_size = size;\n\n\t\t/* The root block location that was calculated above is not\n\t\t * correct if the partition size is an odd number of 512-\n\t\t * byte blocks, which will be rounded down to a number of\n\t\t * 1024-byte blocks, and if there were an even number of\n\t\t * reserved blocks. Ideally, all partition checkers should\n\t\t * report the real number of blocks of the real blocksize,\n\t\t * but since this just cannot be done, we have to try to\n\t\t * find the root block anyways. In the above case, it is one\n\t\t * block behind the calculated one. So we check this one, too.\n\t\t */\n\t\tfor (num_bm = 0; num_bm < 2; num_bm++) {\n\t\t\tpr_debug(\"Dev %s, trying root=%u, bs=%d, \"\n\t\t\t\t\"size=%d, reserved=%d\\n\",\n\t\t\t\tsb->s_id,\n\t\t\t\tsbi->s_root_block + num_bm,\n\t\t\t\tblocksize, size, reserved);\n\t\t\troot_bh = affs_bread(sb, sbi->s_root_block + num_bm);\n\t\t\tif (!root_bh)\n\t\t\t\tcontinue;\n\t\t\tif (!affs_checksum_block(sb, root_bh) &&\n\t\t\t    be32_to_cpu(AFFS_ROOT_HEAD(root_bh)->ptype) == T_SHORT &&\n\t\t\t    be32_to_cpu(AFFS_ROOT_TAIL(sb, root_bh)->stype) == ST_ROOT) {\n\t\t\t\tsbi->s_hashsize    = blocksize / 4 - 56;\n\t\t\t\tsbi->s_root_block += num_bm;\n\t\t\t\tgoto got_root;\n\t\t\t}\n\t\t\taffs_brelse(root_bh);\n\t\t\troot_bh = NULL;\n\t\t}\n\t}\n\tif (!silent)\n\t\tpr_err(\"No valid root block on device %s\\n\", sb->s_id);\n\treturn -EINVAL;\n\n\t/* N.B. after this point bh must be released */\ngot_root:\n\t/* Keep super block in cache */\n\tsbi->s_root_bh = root_bh;\n\troot_block = sbi->s_root_block;\n\n\t/* Find out which kind of FS we have */\n\tboot_bh = sb_bread(sb, 0);\n\tif (!boot_bh) {\n\t\tpr_err(\"Cannot read boot block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(sig, boot_bh->b_data, 4);\n\tbrelse(boot_bh);\n\tchksum = be32_to_cpu(*(__be32 *)sig);\n\n\t/* Dircache filesystems are compatible with non-dircache ones\n\t * when reading. As long as they aren't supported, writing is\n\t * not recommended.\n\t */\n\tif ((chksum == FS_DCFFS || chksum == MUFS_DCFFS || chksum == FS_DCOFS\n\t     || chksum == MUFS_DCOFS) && !sb_rdonly(sb)) {\n\t\tpr_notice(\"Dircache FS - mounting %s read only\\n\", sb->s_id);\n\t\tsb->s_flags |= SB_RDONLY;\n\t}\n\tswitch (chksum) {\n\tcase MUFS_FS:\n\tcase MUFS_INTLFFS:\n\tcase MUFS_DCFFS:\n\t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n\t\tfallthrough;\n\tcase FS_INTLFFS:\n\tcase FS_DCFFS:\n\t\taffs_set_opt(sbi->s_flags, SF_INTL);\n\t\tbreak;\n\tcase MUFS_FFS:\n\t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n\t\tbreak;\n\tcase FS_FFS:\n\t\tbreak;\n\tcase MUFS_OFS:\n\t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n\t\tfallthrough;\n\tcase FS_OFS:\n\t\taffs_set_opt(sbi->s_flags, SF_OFS);\n\t\tsb->s_flags |= SB_NOEXEC;\n\t\tbreak;\n\tcase MUFS_DCOFS:\n\tcase MUFS_INTLOFS:\n\t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n\t\tfallthrough;\n\tcase FS_DCOFS:\n\tcase FS_INTLOFS:\n\t\taffs_set_opt(sbi->s_flags, SF_INTL);\n\t\taffs_set_opt(sbi->s_flags, SF_OFS);\n\t\tsb->s_flags |= SB_NOEXEC;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown filesystem on device %s: %08X\\n\",\n\t\t       sb->s_id, chksum);\n\t\treturn -EINVAL;\n\t}\n\n\tif (affs_test_opt(mount_flags, SF_VERBOSE)) {\n\t\tu8 len = AFFS_ROOT_TAIL(sb, root_bh)->disk_name[0];\n\t\tpr_notice(\"Mounting volume \\\"%.*s\\\": Type=%.3s\\\\%c, Blocksize=%d\\n\",\n\t\t\tlen > 31 ? 31 : len,\n\t\t\tAFFS_ROOT_TAIL(sb, root_bh)->disk_name + 1,\n\t\t\tsig, sig[3] + '0', blocksize);\n\t}\n\n\tsb->s_flags |= SB_NODEV | SB_NOSUID;\n\n\tsbi->s_data_blksize = sb->s_blocksize;\n\tif (affs_test_opt(sbi->s_flags, SF_OFS))\n\t\tsbi->s_data_blksize -= 24;\n\n\ttmp_flags = sb->s_flags;\n\tret = affs_init_bitmap(sb, &tmp_flags);\n\tif (ret)\n\t\treturn ret;\n\tsb->s_flags = tmp_flags;\n\n\t/* set up enough so that it can read an inode */\n\n\troot_inode = affs_iget(sb, root_block);\n\tif (IS_ERR(root_inode))\n\t\treturn PTR_ERR(root_inode);\n\n\tif (affs_test_opt(AFFS_SB(sb)->s_flags, SF_INTL))\n\t\tsb->s_d_op = &affs_intl_dentry_operations;\n\telse\n\t\tsb->s_d_op = &affs_dentry_operations;\n\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tpr_err(\"AFFS: Get root inode failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsb->s_export_op = &affs_export_ops;\n\tpr_debug(\"s_flags=%lX\\n\", sb->s_flags);\n\treturn 0;\n}"
        ],
        "source": [
            "        int     size, blocksize;"
        ],
        "index": 10,
        "location": {
            "file_path": "linux-6.9.6/fs/affs/super.c",
            "region": {
                "startLine": 401,
                "startColumn": 15,
                "endColumn": 15
            },
            "context": {
                "startLine": 399,
                "endLine": 403,
                "snippet": {
                    "text": "size = size / (blocksize / 512);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/fs/affs/super.c",
                        "function_body": "332 static int affs_fill_super(struct super_block *sb, void *data, int silent)\n333 {\n334 \tstruct affs_sb_info\t*sbi;\n335 \tstruct buffer_head\t*root_bh = NULL;\n336 \tstruct buffer_head\t*boot_bh;\n337 \tstruct inode\t\t*root_inode = NULL;\n338 \ts32\t\t\t root_block;\n339 \tint\t\t\t size, blocksize;\n340 \tu32\t\t\t chksum;\n341 \tint\t\t\t num_bm;\n342 \tint\t\t\t i, j;\n343 \tkuid_t\t\t\t uid;\n344 \tkgid_t\t\t\t gid;\n345 \tint\t\t\t reserved;\n346 \tunsigned long\t\t mount_flags;\n347 \tint\t\t\t tmp_flags;\t/* fix remount prototype... */\n348 \tu8\t\t\t sig[4];\n349 \tint\t\t\t ret;\n350\n351 \tpr_debug(\"read_super(%s)\\n\", data ? (const char *)data : \"no options\");\n352\n353 \tsb->s_magic             = AFFS_SUPER_MAGIC;\n354 \tsb->s_op                = &affs_sops;\n355 \tsb->s_flags |= SB_NODIRATIME;\n356\n357 \tsb->s_time_gran = NSEC_PER_SEC;\n358 \tsb->s_time_min = sys_tz.tz_minuteswest * 60 + AFFS_EPOCH_DELTA;\n359 \tsb->s_time_max = 86400LL * U32_MAX + 86400 + sb->s_time_min;\n360\n361 \tsbi = kzalloc(sizeof(struct affs_sb_info), GFP_KERNEL);\n362 \tif (!sbi)\n363 \t\treturn -ENOMEM;\n364\n365 \tsb->s_fs_info = sbi;\n366 \tsbi->sb = sb;\n367 \tmutex_init(&sbi->s_bmlock);\n368 \tspin_lock_init(&sbi->symlink_lock);\n369 \tspin_lock_init(&sbi->work_lock);\n370 \tINIT_DELAYED_WORK(&sbi->sb_work, flush_superblock);\n371\n372 \tif (!parse_options(data,&uid,&gid,&i,&reserved,&root_block,\n373 \t\t\t\t&blocksize,&sbi->s_prefix,\n374 \t\t\t\tsbi->s_volume, &mount_flags)) {\n375 \t\tpr_err(\"Error parsing options\\n\");\n376 \t\treturn -EINVAL;\n377 \t}\n378 \t/* N.B. after this point s_prefix must be released */\n379\n380 \tsbi->s_flags   = mount_flags;\n381 \tsbi->s_mode    = i;\n382 \tsbi->s_uid     = uid;\n383 \tsbi->s_gid     = gid;\n384 \tsbi->s_reserved= reserved;\n385\n386 \t/* Get the size of the device in 512-byte blocks.\n387 \t * If we later see that the partition uses bigger\n388 \t * blocks, we will have to change it.\n389 \t */\n390\n391 \tsize = bdev_nr_sectors(sb->s_bdev);\n392 \tpr_debug(\"initial blocksize=%d, #blocks=%d\\n\", 512, size);\n393\n394 \taffs_set_blocksize(sb, PAGE_SIZE);\n395 \t/* Try to find root block. Its location depends on the block size. */\n396\n397 \ti = bdev_logical_block_size(sb->s_bdev);\n398 \tj = PAGE_SIZE;\n399 \tif (blocksize > 0) {\n400 \t\ti = j = blocksize;\n401 \t\tsize = size / (blocksize / 512);\n402 \t}\n403\n404 \tfor (blocksize = i; blocksize <= j; blocksize <<= 1, size >>= 1) {\n405 \t\tsbi->s_root_block = root_block;\n406 \t\tif (root_block < 0)\n407 \t\t\tsbi->s_root_block = (reserved + size - 1) / 2;\n408 \t\tpr_debug(\"setting blocksize to %d\\n\", blocksize);\n409 \t\taffs_set_blocksize(sb, blocksize);\n410 \t\tsbi->s_partition_size = size;\n411\n412 \t\t/* The root block location that was calculated above is not\n413 \t\t * correct if the partition size is an odd number of 512-\n414 \t\t * byte blocks, which will be rounded down to a number of\n415 \t\t * 1024-byte blocks, and if there were an even number of\n416 \t\t * reserved blocks. Ideally, all partition checkers should\n417 \t\t * report the real number of blocks of the real blocksize,\n418 \t\t * but since this just cannot be done, we have to try to\n419 \t\t * find the root block anyways. In the above case, it is one\n420 \t\t * block behind the calculated one. So we check this one, too.\n421 \t\t */\n422 \t\tfor (num_bm = 0; num_bm < 2; num_bm++) {\n423 \t\t\tpr_debug(\"Dev %s, trying root=%u, bs=%d, \"\n424 \t\t\t\t\"size=%d, reserved=%d\\n\",\n425 \t\t\t\tsb->s_id,\n426 \t\t\t\tsbi->s_root_block + num_bm,\n427 \t\t\t\tblocksize, size, reserved);\n428 \t\t\troot_bh = affs_bread(sb, sbi->s_root_block + num_bm);\n429 \t\t\tif (!root_bh)\n430 \t\t\t\tcontinue;\n431 \t\t\tif (!affs_checksum_block(sb, root_bh) &&\n432 \t\t\t    be32_to_cpu(AFFS_ROOT_HEAD(root_bh)->ptype) == T_SHORT &&\n433 \t\t\t    be32_to_cpu(AFFS_ROOT_TAIL(sb, root_bh)->stype) == ST_ROOT) {\n434 \t\t\t\tsbi->s_hashsize    = blocksize / 4 - 56;\n435 \t\t\t\tsbi->s_root_block += num_bm;\n436 \t\t\t\tgoto got_root;\n437 \t\t\t}\n438 \t\t\taffs_brelse(root_bh);\n439 \t\t\troot_bh = NULL;\n440 \t\t}\n441 \t}\n442 \tif (!silent)\n443 \t\tpr_err(\"No valid root block on device %s\\n\", sb->s_id);\n444 \treturn -EINVAL;\n445\n446 \t/* N.B. after this point bh must be released */\n447 got_root:\n448 \t/* Keep super block in cache */\n449 \tsbi->s_root_bh = root_bh;\n450 \troot_block = sbi->s_root_block;\n451\n452 \t/* Find out which kind of FS we have */\n453 \tboot_bh = sb_bread(sb, 0);\n454 \tif (!boot_bh) {\n455 \t\tpr_err(\"Cannot read boot block\\n\");\n456 \t\treturn -EINVAL;\n457 \t}\n458 \tmemcpy(sig, boot_bh->b_data, 4);\n459 \tbrelse(boot_bh);\n460 \tchksum = be32_to_cpu(*(__be32 *)sig);\n461\n462 \t/* Dircache filesystems are compatible with non-dircache ones\n463 \t * when reading. As long as they aren't supported, writing is\n464 \t * not recommended.\n465 \t */\n466 \tif ((chksum == FS_DCFFS || chksum == MUFS_DCFFS || chksum == FS_DCOFS\n467 \t     || chksum == MUFS_DCOFS) && !sb_rdonly(sb)) {\n468 \t\tpr_notice(\"Dircache FS - mounting %s read only\\n\", sb->s_id);\n469 \t\tsb->s_flags |= SB_RDONLY;\n470 \t}\n471 \tswitch (chksum) {\n472 \tcase MUFS_FS:\n473 \tcase MUFS_INTLFFS:\n474 \tcase MUFS_DCFFS:\n475 \t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n476 \t\tfallthrough;\n477 \tcase FS_INTLFFS:\n478 \tcase FS_DCFFS:\n479 \t\taffs_set_opt(sbi->s_flags, SF_INTL);\n480 \t\tbreak;\n481 \tcase MUFS_FFS:\n482 \t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n483 \t\tbreak;\n484 \tcase FS_FFS:\n485 \t\tbreak;\n486 \tcase MUFS_OFS:\n487 \t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n488 \t\tfallthrough;\n489 \tcase FS_OFS:\n490 \t\taffs_set_opt(sbi->s_flags, SF_OFS);\n491 \t\tsb->s_flags |= SB_NOEXEC;\n492 \t\tbreak;\n493 \tcase MUFS_DCOFS:\n494 \tcase MUFS_INTLOFS:\n495 \t\taffs_set_opt(sbi->s_flags, SF_MUFS);\n496 \t\tfallthrough;\n497 \tcase FS_DCOFS:\n498 \tcase FS_INTLOFS:\n499 \t\taffs_set_opt(sbi->s_flags, SF_INTL);\n500 \t\taffs_set_opt(sbi->s_flags, SF_OFS);\n501 \t\tsb->s_flags |= SB_NOEXEC;\n502 \t\tbreak;\n503 \tdefault:\n504 \t\tpr_err(\"Unknown filesystem on device %s: %08X\\n\",\n505 \t\t       sb->s_id, chksum);\n506 \t\treturn -EINVAL;\n507 \t}\n508\n509 \tif (affs_test_opt(mount_flags, SF_VERBOSE)) {\n510 \t\tu8 len = AFFS_ROOT_TAIL(sb, root_bh)->disk_name[0];\n511 \t\tpr_notice(\"Mounting volume \\\"%.*s\\\": Type=%.3s\\\\%c, Blocksize=%d\\n\",\n512 \t\t\tlen > 31 ? 31 : len,\n513 \t\t\tAFFS_ROOT_TAIL(sb, root_bh)->disk_name + 1,\n514 \t\t\tsig, sig[3] + '0', blocksize);\n515 \t}\n516\n517 \tsb->s_flags |= SB_NODEV | SB_NOSUID;\n518\n519 \tsbi->s_data_blksize = sb->s_blocksize;\n520 \tif (affs_test_opt(sbi->s_flags, SF_OFS))\n521 \t\tsbi->s_data_blksize -= 24;\n522\n523 \ttmp_flags = sb->s_flags;\n524 \tret = affs_init_bitmap(sb, &tmp_flags);\n525 \tif (ret)\n526 \t\treturn ret;\n527 \tsb->s_flags = tmp_flags;\n528\n529 \t/* set up enough so that it can read an inode */\n530\n531 \troot_inode = affs_iget(sb, root_block);\n532 \tif (IS_ERR(root_inode))\n533 \t\treturn PTR_ERR(root_inode);\n534\n535 \tif (affs_test_opt(AFFS_SB(sb)->s_flags, SF_INTL))\n536 \t\tsb->s_d_op = &affs_intl_dentry_operations;\n537 \telse\n538 \t\tsb->s_d_op = &affs_dentry_operations;\n539\n540 \tsb->s_root = d_make_root(root_inode);\n541 \tif (!sb->s_root) {\n542 \t\tpr_err(\"AFFS: Get root inode failed\\n\");\n543 \t\treturn -ENOMEM;\n544 \t}\n545\n546 \tsb->s_export_op = &affs_export_ops;\n547 \tpr_debug(\"s_flags=%lX\\n\", sb->s_flags);\n548 \treturn 0;\n549 }"
                    }
                ]
            }
        ],
        "sink": "size = size / (blocksize / 512);",
        "final_sink": "size = size / (blocksize / 512);"
    },
    {
        "prt": "scan_time",
        "function_call": [
            "static void scan_time_advisor(void)\n{\n\tunsigned int cpu_percent;\n\tunsigned long cpu_time;\n\tunsigned long cpu_time_diff;\n\tunsigned long cpu_time_diff_ms;\n\tunsigned long pages;\n\tunsigned long per_page_cost;\n\tunsigned long factor;\n\tunsigned long change;\n\tunsigned long last_scan_time;\n\tunsigned long scan_time;\n\n\t/* Convert scan time to seconds */\n\tscan_time = div_s64(ktime_ms_delta(ktime_get(), advisor_ctx.start_scan),\n\t\t\t    MSEC_PER_SEC);\n\tscan_time = scan_time ? scan_time : 1;\n\n\t/* Calculate CPU consumption of ksmd background thread */\n\tcpu_time = task_sched_runtime(current);\n\tcpu_time_diff = cpu_time - advisor_ctx.cpu_time;\n\tcpu_time_diff_ms = cpu_time_diff / 1000 / 1000;\n\n\tcpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);\n\tcpu_percent = cpu_percent ? cpu_percent : 1;\n\tlast_scan_time = prev_scan_time(&advisor_ctx, scan_time);\n\n\t/* Calculate scan time as percentage of target scan time */\n\tfactor = ksm_advisor_target_scan_time * 100 / scan_time;\n\tfactor = factor ? factor : 1;\n\n\t/*\n\t * Calculate scan time as percentage of last scan time and use\n\t * exponentially weighted average to smooth it\n\t */\n\tchange = scan_time * 100 / last_scan_time;\n\tchange = change ? change : 1;\n\tchange = ewma(advisor_ctx.change, change);\n\n\t/* Calculate new scan rate based on target scan rate. */\n\tpages = ksm_thread_pages_to_scan * 100 / factor;\n\t/* Update pages_to_scan by weighted change percentage. */\n\tpages = pages * change / 100;\n\n\t/* Cap new pages_to_scan value */\n\tper_page_cost = ksm_thread_pages_to_scan / cpu_percent;\n\tper_page_cost = per_page_cost ? per_page_cost : 1;\n\n\tpages = min(pages, per_page_cost * ksm_advisor_max_cpu);\n\tpages = max(pages, per_page_cost * KSM_ADVISOR_MIN_CPU);\n\tpages = min(pages, ksm_advisor_max_pages_to_scan);\n\n\t/* Update advisor context */\n\tadvisor_ctx.change = change;\n\tadvisor_ctx.scan_time = scan_time;\n\tadvisor_ctx.cpu_time = cpu_time;\n\n\tksm_thread_pages_to_scan = pages;\n\ttrace_ksm_advisor(scan_time, pages, cpu_percent);\n}"
        ],
        "source": [
            "        scan_time = scan_time ? scan_time : 1;"
        ],
        "index": 12,
        "location": {
            "file_path": "linux-6.9.6/mm/ksm.c",
            "region": {
                "startLine": 426,
                "startColumn": 41,
                "endColumn": 41
            },
            "context": {
                "startLine": 424,
                "endLine": 428,
                "snippet": {
                    "text": "cpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/mm/ksm.c",
                        "function_body": "403 static void scan_time_advisor(void)\n404 {\n405 \tunsigned int cpu_percent;\n406 \tunsigned long cpu_time;\n407 \tunsigned long cpu_time_diff;\n408 \tunsigned long cpu_time_diff_ms;\n409 \tunsigned long pages;\n410 \tunsigned long per_page_cost;\n411 \tunsigned long factor;\n412 \tunsigned long change;\n413 \tunsigned long last_scan_time;\n414 \tunsigned long scan_time;\n415\n416 \t/* Convert scan time to seconds */\n417 \tscan_time = div_s64(ktime_ms_delta(ktime_get(), advisor_ctx.start_scan),\n418 \t\t\t    MSEC_PER_SEC);\n419 \tscan_time = scan_time ? scan_time : 1;\n420\n421 \t/* Calculate CPU consumption of ksmd background thread */\n422 \tcpu_time = task_sched_runtime(current);\n423 \tcpu_time_diff = cpu_time - advisor_ctx.cpu_time;\n424 \tcpu_time_diff_ms = cpu_time_diff / 1000 / 1000;\n425\n426 \tcpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);\n427 \tcpu_percent = cpu_percent ? cpu_percent : 1;\n428 \tlast_scan_time = prev_scan_time(&advisor_ctx, scan_time);\n429\n430 \t/* Calculate scan time as percentage of target scan time */\n431 \tfactor = ksm_advisor_target_scan_time * 100 / scan_time;\n432 \tfactor = factor ? factor : 1;\n433\n434 \t/*\n435 \t * Calculate scan time as percentage of last scan time and use\n436 \t * exponentially weighted average to smooth it\n437 \t */\n438 \tchange = scan_time * 100 / last_scan_time;\n439 \tchange = change ? change : 1;\n440 \tchange = ewma(advisor_ctx.change, change);\n441\n442 \t/* Calculate new scan rate based on target scan rate. */\n443 \tpages = ksm_thread_pages_to_scan * 100 / factor;\n444 \t/* Update pages_to_scan by weighted change percentage. */\n445 \tpages = pages * change / 100;\n446\n447 \t/* Cap new pages_to_scan value */\n448 \tper_page_cost = ksm_thread_pages_to_scan / cpu_percent;\n449 \tper_page_cost = per_page_cost ? per_page_cost : 1;\n450\n451 \tpages = min(pages, per_page_cost * ksm_advisor_max_cpu);\n452 \tpages = max(pages, per_page_cost * KSM_ADVISOR_MIN_CPU);\n453 \tpages = min(pages, ksm_advisor_max_pages_to_scan);\n454\n455 \t/* Update advisor context */\n456 \tadvisor_ctx.change = change;\n457 \tadvisor_ctx.scan_time = scan_time;\n458 \tadvisor_ctx.cpu_time = cpu_time;\n459\n460 \tksm_thread_pages_to_scan = pages;\n461 \ttrace_ksm_advisor(scan_time, pages, cpu_percent);\n462 }"
                    },
                    {
                        "file_path": "/mm/ksm.c",
                        "function_body": "464 static void advisor_stop_scan(void)\n465 {\n466 \tif (ksm_advisor == KSM_ADVISOR_SCAN_TIME)\n467 \t\tscan_time_advisor();\n468 }"
                    }
                ]
            }
        ],
        "sink": "cpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);",
        "final_sink": "cpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);"
    },
    {
        "prt": "scan_time",
        "function_call": [
            "static void scan_time_advisor(void)\n{\n\tunsigned int cpu_percent;\n\tunsigned long cpu_time;\n\tunsigned long cpu_time_diff;\n\tunsigned long cpu_time_diff_ms;\n\tunsigned long pages;\n\tunsigned long per_page_cost;\n\tunsigned long factor;\n\tunsigned long change;\n\tunsigned long last_scan_time;\n\tunsigned long scan_time;\n\n\t/* Convert scan time to seconds */\n\tscan_time = div_s64(ktime_ms_delta(ktime_get(), advisor_ctx.start_scan),\n\t\t\t    MSEC_PER_SEC);\n\tscan_time = scan_time ? scan_time : 1;\n\n\t/* Calculate CPU consumption of ksmd background thread */\n\tcpu_time = task_sched_runtime(current);\n\tcpu_time_diff = cpu_time - advisor_ctx.cpu_time;\n\tcpu_time_diff_ms = cpu_time_diff / 1000 / 1000;\n\n\tcpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);\n\tcpu_percent = cpu_percent ? cpu_percent : 1;\n\tlast_scan_time = prev_scan_time(&advisor_ctx, scan_time);\n\n\t/* Calculate scan time as percentage of target scan time */\n\tfactor = ksm_advisor_target_scan_time * 100 / scan_time;\n\tfactor = factor ? factor : 1;\n\n\t/*\n\t * Calculate scan time as percentage of last scan time and use\n\t * exponentially weighted average to smooth it\n\t */\n\tchange = scan_time * 100 / last_scan_time;\n\tchange = change ? change : 1;\n\tchange = ewma(advisor_ctx.change, change);\n\n\t/* Calculate new scan rate based on target scan rate. */\n\tpages = ksm_thread_pages_to_scan * 100 / factor;\n\t/* Update pages_to_scan by weighted change percentage. */\n\tpages = pages * change / 100;\n\n\t/* Cap new pages_to_scan value */\n\tper_page_cost = ksm_thread_pages_to_scan / cpu_percent;\n\tper_page_cost = per_page_cost ? per_page_cost : 1;\n\n\tpages = min(pages, per_page_cost * ksm_advisor_max_cpu);\n\tpages = max(pages, per_page_cost * KSM_ADVISOR_MIN_CPU);\n\tpages = min(pages, ksm_advisor_max_pages_to_scan);\n\n\t/* Update advisor context */\n\tadvisor_ctx.change = change;\n\tadvisor_ctx.scan_time = scan_time;\n\tadvisor_ctx.cpu_time = cpu_time;\n\n\tksm_thread_pages_to_scan = pages;\n\ttrace_ksm_advisor(scan_time, pages, cpu_percent);\n}"
        ],
        "source": [
            "        scan_time = scan_time ? scan_time : 1;"
        ],
        "index": 13,
        "location": {
            "file_path": "linux-6.9.6/mm/ksm.c",
            "region": {
                "startLine": 431,
                "startColumn": 46,
                "endColumn": 46
            },
            "context": {
                "startLine": 429,
                "endLine": 433,
                "snippet": {
                    "text": "factor = ksm_advisor_target_scan_time * 100 / scan_time;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/mm/ksm.c",
                        "function_body": "403 static void scan_time_advisor(void)\n404 {\n405 \tunsigned int cpu_percent;\n406 \tunsigned long cpu_time;\n407 \tunsigned long cpu_time_diff;\n408 \tunsigned long cpu_time_diff_ms;\n409 \tunsigned long pages;\n410 \tunsigned long per_page_cost;\n411 \tunsigned long factor;\n412 \tunsigned long change;\n413 \tunsigned long last_scan_time;\n414 \tunsigned long scan_time;\n415\n416 \t/* Convert scan time to seconds */\n417 \tscan_time = div_s64(ktime_ms_delta(ktime_get(), advisor_ctx.start_scan),\n418 \t\t\t    MSEC_PER_SEC);\n419 \tscan_time = scan_time ? scan_time : 1;\n420\n421 \t/* Calculate CPU consumption of ksmd background thread */\n422 \tcpu_time = task_sched_runtime(current);\n423 \tcpu_time_diff = cpu_time - advisor_ctx.cpu_time;\n424 \tcpu_time_diff_ms = cpu_time_diff / 1000 / 1000;\n425\n426 \tcpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);\n427 \tcpu_percent = cpu_percent ? cpu_percent : 1;\n428 \tlast_scan_time = prev_scan_time(&advisor_ctx, scan_time);\n429\n430 \t/* Calculate scan time as percentage of target scan time */\n431 \tfactor = ksm_advisor_target_scan_time * 100 / scan_time;\n432 \tfactor = factor ? factor : 1;\n433\n434 \t/*\n435 \t * Calculate scan time as percentage of last scan time and use\n436 \t * exponentially weighted average to smooth it\n437 \t */\n438 \tchange = scan_time * 100 / last_scan_time;\n439 \tchange = change ? change : 1;\n440 \tchange = ewma(advisor_ctx.change, change);\n441\n442 \t/* Calculate new scan rate based on target scan rate. */\n443 \tpages = ksm_thread_pages_to_scan * 100 / factor;\n444 \t/* Update pages_to_scan by weighted change percentage. */\n445 \tpages = pages * change / 100;\n446\n447 \t/* Cap new pages_to_scan value */\n448 \tper_page_cost = ksm_thread_pages_to_scan / cpu_percent;\n449 \tper_page_cost = per_page_cost ? per_page_cost : 1;\n450\n451 \tpages = min(pages, per_page_cost * ksm_advisor_max_cpu);\n452 \tpages = max(pages, per_page_cost * KSM_ADVISOR_MIN_CPU);\n453 \tpages = min(pages, ksm_advisor_max_pages_to_scan);\n454\n455 \t/* Update advisor context */\n456 \tadvisor_ctx.change = change;\n457 \tadvisor_ctx.scan_time = scan_time;\n458 \tadvisor_ctx.cpu_time = cpu_time;\n459\n460 \tksm_thread_pages_to_scan = pages;\n461 \ttrace_ksm_advisor(scan_time, pages, cpu_percent);\n462 }"
                    },
                    {
                        "file_path": "/mm/ksm.c",
                        "function_body": "464 static void advisor_stop_scan(void)\n465 {\n466 \tif (ksm_advisor == KSM_ADVISOR_SCAN_TIME)\n467 \t\tscan_time_advisor();\n468 }"
                    }
                ]
            }
        ],
        "sink": "factor = ksm_advisor_target_scan_time * 100 / scan_time;",
        "final_sink": "factor = ksm_advisor_target_scan_time * 100 / scan_time;"
    },
    {
        "prt": "factor",
        "function_call": [
            "static void scan_time_advisor(void)\n{\n\tunsigned int cpu_percent;\n\tunsigned long cpu_time;\n\tunsigned long cpu_time_diff;\n\tunsigned long cpu_time_diff_ms;\n\tunsigned long pages;\n\tunsigned long per_page_cost;\n\tunsigned long factor;\n\tunsigned long change;\n\tunsigned long last_scan_time;\n\tunsigned long scan_time;\n\n\t/* Convert scan time to seconds */\n\tscan_time = div_s64(ktime_ms_delta(ktime_get(), advisor_ctx.start_scan),\n\t\t\t    MSEC_PER_SEC);\n\tscan_time = scan_time ? scan_time : 1;\n\n\t/* Calculate CPU consumption of ksmd background thread */\n\tcpu_time = task_sched_runtime(current);\n\tcpu_time_diff = cpu_time - advisor_ctx.cpu_time;\n\tcpu_time_diff_ms = cpu_time_diff / 1000 / 1000;\n\n\tcpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);\n\tcpu_percent = cpu_percent ? cpu_percent : 1;\n\tlast_scan_time = prev_scan_time(&advisor_ctx, scan_time);\n\n\t/* Calculate scan time as percentage of target scan time */\n\tfactor = ksm_advisor_target_scan_time * 100 / scan_time;\n\tfactor = factor ? factor : 1;\n\n\t/*\n\t * Calculate scan time as percentage of last scan time and use\n\t * exponentially weighted average to smooth it\n\t */\n\tchange = scan_time * 100 / last_scan_time;\n\tchange = change ? change : 1;\n\tchange = ewma(advisor_ctx.change, change);\n\n\t/* Calculate new scan rate based on target scan rate. */\n\tpages = ksm_thread_pages_to_scan * 100 / factor;\n\t/* Update pages_to_scan by weighted change percentage. */\n\tpages = pages * change / 100;\n\n\t/* Cap new pages_to_scan value */\n\tper_page_cost = ksm_thread_pages_to_scan / cpu_percent;\n\tper_page_cost = per_page_cost ? per_page_cost : 1;\n\n\tpages = min(pages, per_page_cost * ksm_advisor_max_cpu);\n\tpages = max(pages, per_page_cost * KSM_ADVISOR_MIN_CPU);\n\tpages = min(pages, ksm_advisor_max_pages_to_scan);\n\n\t/* Update advisor context */\n\tadvisor_ctx.change = change;\n\tadvisor_ctx.scan_time = scan_time;\n\tadvisor_ctx.cpu_time = cpu_time;\n\n\tksm_thread_pages_to_scan = pages;\n\ttrace_ksm_advisor(scan_time, pages, cpu_percent);\n}"
        ],
        "source": [
            "        factor = factor ? factor : 1;"
        ],
        "index": 14,
        "location": {
            "file_path": "linux-6.9.6/mm/ksm.c",
            "region": {
                "startLine": 443,
                "startColumn": 41,
                "endColumn": 41
            },
            "context": {
                "startLine": 441,
                "endLine": 445,
                "snippet": {
                    "text": "pages = ksm_thread_pages_to_scan * 100 / factor;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/mm/ksm.c",
                        "function_body": "403 static void scan_time_advisor(void)\n404 {\n405 \tunsigned int cpu_percent;\n406 \tunsigned long cpu_time;\n407 \tunsigned long cpu_time_diff;\n408 \tunsigned long cpu_time_diff_ms;\n409 \tunsigned long pages;\n410 \tunsigned long per_page_cost;\n411 \tunsigned long factor;\n412 \tunsigned long change;\n413 \tunsigned long last_scan_time;\n414 \tunsigned long scan_time;\n415\n416 \t/* Convert scan time to seconds */\n417 \tscan_time = div_s64(ktime_ms_delta(ktime_get(), advisor_ctx.start_scan),\n418 \t\t\t    MSEC_PER_SEC);\n419 \tscan_time = scan_time ? scan_time : 1;\n420\n421 \t/* Calculate CPU consumption of ksmd background thread */\n422 \tcpu_time = task_sched_runtime(current);\n423 \tcpu_time_diff = cpu_time - advisor_ctx.cpu_time;\n424 \tcpu_time_diff_ms = cpu_time_diff / 1000 / 1000;\n425\n426 \tcpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);\n427 \tcpu_percent = cpu_percent ? cpu_percent : 1;\n428 \tlast_scan_time = prev_scan_time(&advisor_ctx, scan_time);\n429\n430 \t/* Calculate scan time as percentage of target scan time */\n431 \tfactor = ksm_advisor_target_scan_time * 100 / scan_time;\n432 \tfactor = factor ? factor : 1;\n433\n434 \t/*\n435 \t * Calculate scan time as percentage of last scan time and use\n436 \t * exponentially weighted average to smooth it\n437 \t */\n438 \tchange = scan_time * 100 / last_scan_time;\n439 \tchange = change ? change : 1;\n440 \tchange = ewma(advisor_ctx.change, change);\n441\n442 \t/* Calculate new scan rate based on target scan rate. */\n443 \tpages = ksm_thread_pages_to_scan * 100 / factor;\n444 \t/* Update pages_to_scan by weighted change percentage. */\n445 \tpages = pages * change / 100;\n446\n447 \t/* Cap new pages_to_scan value */\n448 \tper_page_cost = ksm_thread_pages_to_scan / cpu_percent;\n449 \tper_page_cost = per_page_cost ? per_page_cost : 1;\n450\n451 \tpages = min(pages, per_page_cost * ksm_advisor_max_cpu);\n452 \tpages = max(pages, per_page_cost * KSM_ADVISOR_MIN_CPU);\n453 \tpages = min(pages, ksm_advisor_max_pages_to_scan);\n454\n455 \t/* Update advisor context */\n456 \tadvisor_ctx.change = change;\n457 \tadvisor_ctx.scan_time = scan_time;\n458 \tadvisor_ctx.cpu_time = cpu_time;\n459\n460 \tksm_thread_pages_to_scan = pages;\n461 \ttrace_ksm_advisor(scan_time, pages, cpu_percent);\n462 }"
                    },
                    {
                        "file_path": "/mm/ksm.c",
                        "function_body": "464 static void advisor_stop_scan(void)\n465 {\n466 \tif (ksm_advisor == KSM_ADVISOR_SCAN_TIME)\n467 \t\tscan_time_advisor();\n468 }"
                    }
                ]
            }
        ],
        "sink": "pages = ksm_thread_pages_to_scan * 100 / factor;",
        "final_sink": "pages = ksm_thread_pages_to_scan * 100 / factor;"
    },
    {
        "prt": "cpu_percent",
        "function_call": [
            "static void scan_time_advisor(void)\n{\n\tunsigned int cpu_percent;\n\tunsigned long cpu_time;\n\tunsigned long cpu_time_diff;\n\tunsigned long cpu_time_diff_ms;\n\tunsigned long pages;\n\tunsigned long per_page_cost;\n\tunsigned long factor;\n\tunsigned long change;\n\tunsigned long last_scan_time;\n\tunsigned long scan_time;\n\n\t/* Convert scan time to seconds */\n\tscan_time = div_s64(ktime_ms_delta(ktime_get(), advisor_ctx.start_scan),\n\t\t\t    MSEC_PER_SEC);\n\tscan_time = scan_time ? scan_time : 1;\n\n\t/* Calculate CPU consumption of ksmd background thread */\n\tcpu_time = task_sched_runtime(current);\n\tcpu_time_diff = cpu_time - advisor_ctx.cpu_time;\n\tcpu_time_diff_ms = cpu_time_diff / 1000 / 1000;\n\n\tcpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);\n\tcpu_percent = cpu_percent ? cpu_percent : 1;\n\tlast_scan_time = prev_scan_time(&advisor_ctx, scan_time);\n\n\t/* Calculate scan time as percentage of target scan time */\n\tfactor = ksm_advisor_target_scan_time * 100 / scan_time;\n\tfactor = factor ? factor : 1;\n\n\t/*\n\t * Calculate scan time as percentage of last scan time and use\n\t * exponentially weighted average to smooth it\n\t */\n\tchange = scan_time * 100 / last_scan_time;\n\tchange = change ? change : 1;\n\tchange = ewma(advisor_ctx.change, change);\n\n\t/* Calculate new scan rate based on target scan rate. */\n\tpages = ksm_thread_pages_to_scan * 100 / factor;\n\t/* Update pages_to_scan by weighted change percentage. */\n\tpages = pages * change / 100;\n\n\t/* Cap new pages_to_scan value */\n\tper_page_cost = ksm_thread_pages_to_scan / cpu_percent;\n\tper_page_cost = per_page_cost ? per_page_cost : 1;\n\n\tpages = min(pages, per_page_cost * ksm_advisor_max_cpu);\n\tpages = max(pages, per_page_cost * KSM_ADVISOR_MIN_CPU);\n\tpages = min(pages, ksm_advisor_max_pages_to_scan);\n\n\t/* Update advisor context */\n\tadvisor_ctx.change = change;\n\tadvisor_ctx.scan_time = scan_time;\n\tadvisor_ctx.cpu_time = cpu_time;\n\n\tksm_thread_pages_to_scan = pages;\n\ttrace_ksm_advisor(scan_time, pages, cpu_percent);\n}"
        ],
        "source": [
            "cpu_percent = cpu_percent ? cpu_percent : 1;"
        ],
        "index": 15,
        "location": {
            "file_path": "linux-6.9.6/mm/ksm.c",
            "region": {
                "startLine": 448,
                "startColumn": 43,
                "endColumn": 43
            },
            "context": {
                "startLine": 446,
                "endLine": 450,
                "snippet": {
                    "text": "per_page_cost = ksm_thread_pages_to_scan / cpu_percent;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/mm/ksm.c",
                        "function_body": "403 static void scan_time_advisor(void)\n404 {\n405 \tunsigned int cpu_percent;\n406 \tunsigned long cpu_time;\n407 \tunsigned long cpu_time_diff;\n408 \tunsigned long cpu_time_diff_ms;\n409 \tunsigned long pages;\n410 \tunsigned long per_page_cost;\n411 \tunsigned long factor;\n412 \tunsigned long change;\n413 \tunsigned long last_scan_time;\n414 \tunsigned long scan_time;\n415\n416 \t/* Convert scan time to seconds */\n417 \tscan_time = div_s64(ktime_ms_delta(ktime_get(), advisor_ctx.start_scan),\n418 \t\t\t    MSEC_PER_SEC);\n419 \tscan_time = scan_time ? scan_time : 1;\n420\n421 \t/* Calculate CPU consumption of ksmd background thread */\n422 \tcpu_time = task_sched_runtime(current);\n423 \tcpu_time_diff = cpu_time - advisor_ctx.cpu_time;\n424 \tcpu_time_diff_ms = cpu_time_diff / 1000 / 1000;\n425\n426 \tcpu_percent = (cpu_time_diff_ms * 100) / (scan_time * 1000);\n427 \tcpu_percent = cpu_percent ? cpu_percent : 1;\n428 \tlast_scan_time = prev_scan_time(&advisor_ctx, scan_time);\n429\n430 \t/* Calculate scan time as percentage of target scan time */\n431 \tfactor = ksm_advisor_target_scan_time * 100 / scan_time;\n432 \tfactor = factor ? factor : 1;\n433\n434 \t/*\n435 \t * Calculate scan time as percentage of last scan time and use\n436 \t * exponentially weighted average to smooth it\n437 \t */\n438 \tchange = scan_time * 100 / last_scan_time;\n439 \tchange = change ? change : 1;\n440 \tchange = ewma(advisor_ctx.change, change);\n441\n442 \t/* Calculate new scan rate based on target scan rate. */\n443 \tpages = ksm_thread_pages_to_scan * 100 / factor;\n444 \t/* Update pages_to_scan by weighted change percentage. */\n445 \tpages = pages * change / 100;\n446\n447 \t/* Cap new pages_to_scan value */\n448 \tper_page_cost = ksm_thread_pages_to_scan / cpu_percent;\n449 \tper_page_cost = per_page_cost ? per_page_cost : 1;\n450\n451 \tpages = min(pages, per_page_cost * ksm_advisor_max_cpu);\n452 \tpages = max(pages, per_page_cost * KSM_ADVISOR_MIN_CPU);\n453 \tpages = min(pages, ksm_advisor_max_pages_to_scan);\n454\n455 \t/* Update advisor context */\n456 \tadvisor_ctx.change = change;\n457 \tadvisor_ctx.scan_time = scan_time;\n458 \tadvisor_ctx.cpu_time = cpu_time;\n459\n460 \tksm_thread_pages_to_scan = pages;\n461 \ttrace_ksm_advisor(scan_time, pages, cpu_percent);\n462 }"
                    },
                    {
                        "file_path": "/mm/ksm.c",
                        "function_body": "464 static void advisor_stop_scan(void)\n465 {\n466 \tif (ksm_advisor == KSM_ADVISOR_SCAN_TIME)\n467 \t\tscan_time_advisor();\n468 }"
                    }
                ]
            }
        ],
        "sink": "per_page_cost = ksm_thread_pages_to_scan / cpu_percent;",
        "final_sink": "per_page_cost = ksm_thread_pages_to_scan / cpu_percent;"
    },
    {
        "prt": "s->pitch_diff_sh16",
        "function_call": [
            "static void synth_block_fcb_acb(WMAVoiceContext *s, BitstreamContext *bc,\n                                int block_idx, int size,\n                                int block_pitch_sh2,\n                                const struct frame_type_desc *frame_desc,\n                                float *excitation)\n{\n    static const float gain_coeff[6] = {\n        0.8169, -0.06545, 0.1726, 0.0185, -0.0359, 0.0458\n    };\n    float pulses[MAX_FRAMESIZE / 2], pred_err, acb_gain, fcb_gain;\n    int n, idx, gain_weight;\n    AMRFixed fcb;\n\n    assert(size <= MAX_FRAMESIZE / 2);\n    memset(pulses, 0, sizeof(*pulses) * size);\n\n    fcb.pitch_lag      = block_pitch_sh2 >> 2;\n    fcb.pitch_fac      = 1.0;\n    fcb.no_repeat_mask = 0;\n    fcb.n              = 0;\n\n    /* For the other frame types, this is where we apply the innovation\n     * (fixed) codebook pulses of the speech signal. */\n    if (frame_desc->fcb_type == FCB_TYPE_AW_PULSES) {\n        aw_pulse_set1(s, bc, block_idx, &fcb);\n        if (aw_pulse_set2(s, bc, block_idx, &fcb)) {\n            /* Conceal the block with silence and return.\n             * Skip the correct amount of bits to read the next\n             * block from the correct offset. */\n            int r_idx = pRNG(s->frame_cntr, block_idx, size);\n\n            for (n = 0; n < size; n++)\n                excitation[n] =\n                    wmavoice_std_codebook[r_idx + n] * s->silence_gain;\n            bitstream_skip(bc, 7 + 1);\n            return;\n        }\n    } else /* FCB_TYPE_EXC_PULSES */ {\n        int offset_nbits = 5 - frame_desc->log_n_blocks;\n\n        fcb.no_repeat_mask = -1;\n        /* similar to ff_decode_10_pulses_35bits(), but with single pulses\n         * (instead of double) for a subset of pulses */\n        for (n = 0; n < 5; n++) {\n            float sign;\n            int pos1, pos2;\n\n            sign           = bitstream_read_bit(bc) ? 1.0 : -1.0;\n            pos1           = bitstream_read(bc, offset_nbits);\n            fcb.x[fcb.n]   = n + 5 * pos1;\n            fcb.y[fcb.n++] = sign;\n            if (n < frame_desc->dbl_pulses) {\n                pos2           = bitstream_read(bc, offset_nbits);\n                fcb.x[fcb.n]   = n + 5 * pos2;\n                fcb.y[fcb.n++] = (pos1 < pos2) ? -sign : sign;\n            }\n        }\n    }\n    ff_set_fixed_vector(pulses, &fcb, 1.0, size);\n\n    /* Calculate gain for adaptive & fixed codebook signal.\n     * see ff_amr_set_fixed_gain(). */\n    idx = bitstream_read(bc, 7);\n    fcb_gain = expf(avpriv_scalarproduct_float_c(s->gain_pred_err,\n                                                 gain_coeff, 6) -\n                    5.2409161640 + wmavoice_gain_codebook_fcb[idx]);\n    acb_gain = wmavoice_gain_codebook_acb[idx];\n    pred_err = av_clipf(wmavoice_gain_codebook_fcb[idx],\n                        -2.9957322736 /* log(0.05) */,\n                         1.6094379124 /* log(5.0)  */);\n\n    gain_weight = 8 >> frame_desc->log_n_blocks;\n    memmove(&s->gain_pred_err[gain_weight], s->gain_pred_err,\n            sizeof(*s->gain_pred_err) * (6 - gain_weight));\n    for (n = 0; n < gain_weight; n++)\n        s->gain_pred_err[n] = pred_err;\n\n    /* Calculation of adaptive codebook */\n    if (frame_desc->acb_type == ACB_TYPE_ASYMMETRIC) {\n        int len;\n        for (n = 0; n < size; n += len) {\n            int next_idx_sh16;\n            int abs_idx    = block_idx * size + n;\n            int pitch_sh16 = (s->last_pitch_val << 16) +\n                             s->pitch_diff_sh16 * abs_idx;\n            int pitch      = (pitch_sh16 + 0x6FFF) >> 16;\n            int idx_sh16   = ((pitch << 16) - pitch_sh16) * 8 + 0x58000;\n            idx            = idx_sh16 >> 16;\n            if (s->pitch_diff_sh16) {\n                if (s->pitch_diff_sh16 > 0) {\n                    next_idx_sh16 = (idx_sh16) &~ 0xFFFF;\n                } else\n                    next_idx_sh16 = (idx_sh16 + 0x10000) &~ 0xFFFF;\n                len = av_clip((idx_sh16 - next_idx_sh16) / s->pitch_diff_sh16 / 8,\n                              1, size - n);\n            } else\n                len = size;\n\n            ff_acelp_interpolatef(&excitation[n], &excitation[n - pitch],\n                                  wmavoice_ipol1_coeffs, 17,\n                                  idx, 9, len);\n        }\n    } else /* ACB_TYPE_HAMMING */ {\n        int block_pitch = block_pitch_sh2 >> 2;\n        idx             = block_pitch_sh2 & 3;\n        if (idx) {\n            ff_acelp_interpolatef(excitation, &excitation[-block_pitch],\n                                  wmavoice_ipol2_coeffs, 4,\n                                  idx, 8, size);\n        } else\n            av_memcpy_backptr((uint8_t *) excitation, sizeof(float) * block_pitch,\n                              sizeof(float) * size);\n    }\n\n    /* Interpolate ACB/FCB and use as excitation signal */\n    ff_weighted_vector_sumf(excitation, excitation, pulses,\n                            acb_gain, fcb_gain, size);\n}"
        ],
        "source": [
            "static void synth_block_fcb_acb(WMAVoiceContext *s, BitstreamContext *bc,"
        ],
        "index": 16,
        "location": {
            "file_path": "libavcodec/wmavoice.c",
            "region": {
                "startLine": 1368,
                "startColumn": 58,
                "endColumn": 58
            },
            "context": {
                "startLine": 1366,
                "endLine": 1370,
                "snippet": {
                    "text": "len = av_clip((idx_sh16 - next_idx_sh16) / s->pitch_diff_sh16 / 8,"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavutil/common.h",
                        "function_body": "401 #   define av_clip          av_clip_c"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "1275 static void synth_block_fcb_acb(WMAVoiceContext *s, BitstreamContext *bc,\n1276                                 int block_idx, int size,\n1277                                 int block_pitch_sh2,\n1278                                 const struct frame_type_desc *frame_desc,\n1279                                 float *excitation)\n1280 {\n1281     static const float gain_coeff[6] = {\n1282         0.8169, -0.06545, 0.1726, 0.0185, -0.0359, 0.0458\n1283     };\n1284     float pulses[MAX_FRAMESIZE / 2], pred_err, acb_gain, fcb_gain;\n1285     int n, idx, gain_weight;\n1286     AMRFixed fcb;\n1287\n1288     assert(size <= MAX_FRAMESIZE / 2);\n1289     memset(pulses, 0, sizeof(*pulses) * size);\n1290\n1291     fcb.pitch_lag      = block_pitch_sh2 >> 2;\n1292     fcb.pitch_fac      = 1.0;\n1293     fcb.no_repeat_mask = 0;\n1294     fcb.n              = 0;\n1295\n1296     /* For the other frame types, this is where we apply the innovation\n1297      * (fixed) codebook pulses of the speech signal. */\n1298     if (frame_desc->fcb_type == FCB_TYPE_AW_PULSES) {\n1299         aw_pulse_set1(s, bc, block_idx, &fcb);\n1300         if (aw_pulse_set2(s, bc, block_idx, &fcb)) {\n1301             /* Conceal the block with silence and return.\n1302              * Skip the correct amount of bits to read the next\n1303              * block from the correct offset. */\n1304             int r_idx = pRNG(s->frame_cntr, block_idx, size);\n1305\n1306             for (n = 0; n < size; n++)\n1307                 excitation[n] =\n1308                     wmavoice_std_codebook[r_idx + n] * s->silence_gain;\n1309             bitstream_skip(bc, 7 + 1);\n1310             return;\n1311         }\n1312     } else /* FCB_TYPE_EXC_PULSES */ {\n1313         int offset_nbits = 5 - frame_desc->log_n_blocks;\n1314\n1315         fcb.no_repeat_mask = -1;\n1316         /* similar to ff_decode_10_pulses_35bits(), but with single pulses\n1317          * (instead of double) for a subset of pulses */\n1318         for (n = 0; n < 5; n++) {\n1319             float sign;\n1320             int pos1, pos2;\n1321\n1322             sign           = bitstream_read_bit(bc) ? 1.0 : -1.0;\n1323             pos1           = bitstream_read(bc, offset_nbits);\n1324             fcb.x[fcb.n]   = n + 5 * pos1;\n1325             fcb.y[fcb.n++] = sign;\n1326             if (n < frame_desc->dbl_pulses) {\n1327                 pos2           = bitstream_read(bc, offset_nbits);\n1328                 fcb.x[fcb.n]   = n + 5 * pos2;\n1329                 fcb.y[fcb.n++] = (pos1 < pos2) ? -sign : sign;\n1330             }\n1331         }\n1332     }\n1333     ff_set_fixed_vector(pulses, &fcb, 1.0, size);\n1334\n1335     /* Calculate gain for adaptive & fixed codebook signal.\n1336      * see ff_amr_set_fixed_gain(). */\n1337     idx = bitstream_read(bc, 7);\n1338     fcb_gain = expf(avpriv_scalarproduct_float_c(s->gain_pred_err,\n1339                                                  gain_coeff, 6) -\n1340                     5.2409161640 + wmavoice_gain_codebook_fcb[idx]);\n1341     acb_gain = wmavoice_gain_codebook_acb[idx];\n1342     pred_err = av_clipf(wmavoice_gain_codebook_fcb[idx],\n1343                         -2.9957322736 /* log(0.05) */,\n1344                          1.6094379124 /* log(5.0)  */);\n1345\n1346     gain_weight = 8 >> frame_desc->log_n_blocks;\n1347     memmove(&s->gain_pred_err[gain_weight], s->gain_pred_err,\n1348             sizeof(*s->gain_pred_err) * (6 - gain_weight));\n1349     for (n = 0; n < gain_weight; n++)\n1350         s->gain_pred_err[n] = pred_err;\n1351\n1352     /* Calculation of adaptive codebook */\n1353     if (frame_desc->acb_type == ACB_TYPE_ASYMMETRIC) {\n1354         int len;\n1355         for (n = 0; n < size; n += len) {\n1356             int next_idx_sh16;\n1357             int abs_idx    = block_idx * size + n;\n1358             int pitch_sh16 = (s->last_pitch_val << 16) +\n1359                              s->pitch_diff_sh16 * abs_idx;\n1360             int pitch      = (pitch_sh16 + 0x6FFF) >> 16;\n1361             int idx_sh16   = ((pitch << 16) - pitch_sh16) * 8 + 0x58000;\n1362             idx            = idx_sh16 >> 16;\n1363             if (s->pitch_diff_sh16) {\n1364                 if (s->pitch_diff_sh16 > 0) {\n1365                     next_idx_sh16 = (idx_sh16) &~ 0xFFFF;\n1366                 } else\n1367                     next_idx_sh16 = (idx_sh16 + 0x10000) &~ 0xFFFF;\n1368                 len = av_clip((idx_sh16 - next_idx_sh16) / s->pitch_diff_sh16 / 8,\n1369                               1, size - n);\n1370             } else\n1371                 len = size;\n1372\n1373             ff_acelp_interpolatef(&excitation[n], &excitation[n - pitch],\n1374                                   wmavoice_ipol1_coeffs, 17,\n1375                                   idx, 9, len);\n1376         }\n1377     } else /* ACB_TYPE_HAMMING */ {\n1378         int block_pitch = block_pitch_sh2 >> 2;\n1379         idx             = block_pitch_sh2 & 3;\n1380         if (idx) {\n1381             ff_acelp_interpolatef(excitation, &excitation[-block_pitch],\n1382                                   wmavoice_ipol2_coeffs, 4,\n1383                                   idx, 8, size);\n1384         } else\n1385             av_memcpy_backptr((uint8_t *) excitation, sizeof(float) * block_pitch,\n1386                               sizeof(float) * size);\n1387     }\n1388\n1389     /* Interpolate ACB/FCB and use as excitation signal */\n1390     ff_weighted_vector_sumf(excitation, excitation, pulses,\n1391                             acb_gain, fcb_gain, size);\n1392 }"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "1410 static void synth_block(WMAVoiceContext *s, BitstreamContext *bc,\n1411                         int block_idx, int size,\n1412                         int block_pitch_sh2,\n1413                         const double *lsps, const double *prev_lsps,\n1414                         const struct frame_type_desc *frame_desc,\n1415                         float *excitation, float *synth)\n1416 {\n1417     double i_lsps[MAX_LSPS];\n1418     float lpcs[MAX_LSPS];\n1419     float fac;\n1420     int n;\n1421\n1422     if (frame_desc->acb_type == ACB_TYPE_NONE)\n1423         synth_block_hardcoded(s, bc, block_idx, size, frame_desc, excitation);\n1424     else\n1425         synth_block_fcb_acb(s, bc, block_idx, size, block_pitch_sh2,\n1426                             frame_desc, excitation);\n1427\n1428     /* convert interpolated LSPs to LPCs */\n1429     fac = (block_idx + 0.5) / frame_desc->n_blocks;\n1430     for (n = 0; n < s->lsps; n++) // LSF -> LSP\n1431         i_lsps[n] = cos(prev_lsps[n] + fac * (lsps[n] - prev_lsps[n]));\n1432     ff_acelp_lspd2lpc(i_lsps, lpcs, s->lsps >> 1);\n1433\n1434     /* Speech synthesis */\n1435     ff_celp_lp_synthesis_filterf(synth, lpcs, excitation, size, s->lsps);\n1436 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavutil/common.h",
                        "function_body": "401 #   define av_clip          av_clip_c"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "1275 static void synth_block_fcb_acb(WMAVoiceContext *s, BitstreamContext *bc,\n1276                                 int block_idx, int size,\n1277                                 int block_pitch_sh2,\n1278                                 const struct frame_type_desc *frame_desc,\n1279                                 float *excitation)\n1280 {\n1281     static const float gain_coeff[6] = {\n1282         0.8169, -0.06545, 0.1726, 0.0185, -0.0359, 0.0458\n1283     };\n1284     float pulses[MAX_FRAMESIZE / 2], pred_err, acb_gain, fcb_gain;\n1285     int n, idx, gain_weight;\n1286     AMRFixed fcb;\n1287\n1288     assert(size <= MAX_FRAMESIZE / 2);\n1289     memset(pulses, 0, sizeof(*pulses) * size);\n1290\n1291     fcb.pitch_lag      = block_pitch_sh2 >> 2;\n1292     fcb.pitch_fac      = 1.0;\n1293     fcb.no_repeat_mask = 0;\n1294     fcb.n              = 0;\n1295\n1296     /* For the other frame types, this is where we apply the innovation\n1297      * (fixed) codebook pulses of the speech signal. */\n1298     if (frame_desc->fcb_type == FCB_TYPE_AW_PULSES) {\n1299         aw_pulse_set1(s, bc, block_idx, &fcb);\n1300         if (aw_pulse_set2(s, bc, block_idx, &fcb)) {\n1301             /* Conceal the block with silence and return.\n1302              * Skip the correct amount of bits to read the next\n1303              * block from the correct offset. */\n1304             int r_idx = pRNG(s->frame_cntr, block_idx, size);\n1305\n1306             for (n = 0; n < size; n++)\n1307                 excitation[n] =\n1308                     wmavoice_std_codebook[r_idx + n] * s->silence_gain;\n1309             bitstream_skip(bc, 7 + 1);\n1310             return;\n1311         }\n1312     } else /* FCB_TYPE_EXC_PULSES */ {\n1313         int offset_nbits = 5 - frame_desc->log_n_blocks;\n1314\n1315         fcb.no_repeat_mask = -1;\n1316         /* similar to ff_decode_10_pulses_35bits(), but with single pulses\n1317          * (instead of double) for a subset of pulses */\n1318         for (n = 0; n < 5; n++) {\n1319             float sign;\n1320             int pos1, pos2;\n1321\n1322             sign           = bitstream_read_bit(bc) ? 1.0 : -1.0;\n1323             pos1           = bitstream_read(bc, offset_nbits);\n1324             fcb.x[fcb.n]   = n + 5 * pos1;\n1325             fcb.y[fcb.n++] = sign;\n1326             if (n < frame_desc->dbl_pulses) {\n1327                 pos2           = bitstream_read(bc, offset_nbits);\n1328                 fcb.x[fcb.n]   = n + 5 * pos2;\n1329                 fcb.y[fcb.n++] = (pos1 < pos2) ? -sign : sign;\n1330             }\n1331         }\n1332     }\n1333     ff_set_fixed_vector(pulses, &fcb, 1.0, size);\n1334\n1335     /* Calculate gain for adaptive & fixed codebook signal.\n1336      * see ff_amr_set_fixed_gain(). */\n1337     idx = bitstream_read(bc, 7);\n1338     fcb_gain = expf(avpriv_scalarproduct_float_c(s->gain_pred_err,\n1339                                                  gain_coeff, 6) -\n1340                     5.2409161640 + wmavoice_gain_codebook_fcb[idx]);\n1341     acb_gain = wmavoice_gain_codebook_acb[idx];\n1342     pred_err = av_clipf(wmavoice_gain_codebook_fcb[idx],\n1343                         -2.9957322736 /* log(0.05) */,\n1344                          1.6094379124 /* log(5.0)  */);\n1345\n1346     gain_weight = 8 >> frame_desc->log_n_blocks;\n1347     memmove(&s->gain_pred_err[gain_weight], s->gain_pred_err,\n1348             sizeof(*s->gain_pred_err) * (6 - gain_weight));\n1349     for (n = 0; n < gain_weight; n++)\n1350         s->gain_pred_err[n] = pred_err;\n1351\n1352     /* Calculation of adaptive codebook */\n1353     if (frame_desc->acb_type == ACB_TYPE_ASYMMETRIC) {\n1354         int len;\n1355         for (n = 0; n < size; n += len) {\n1356             int next_idx_sh16;\n1357             int abs_idx    = block_idx * size + n;\n1358             int pitch_sh16 = (s->last_pitch_val << 16) +\n1359                              s->pitch_diff_sh16 * abs_idx;\n1360             int pitch      = (pitch_sh16 + 0x6FFF) >> 16;\n1361             int idx_sh16   = ((pitch << 16) - pitch_sh16) * 8 + 0x58000;\n1362             idx            = idx_sh16 >> 16;\n1363             if (s->pitch_diff_sh16) {\n1364                 if (s->pitch_diff_sh16 > 0) {\n1365                     next_idx_sh16 = (idx_sh16) &~ 0xFFFF;\n1366                 } else\n1367                     next_idx_sh16 = (idx_sh16 + 0x10000) &~ 0xFFFF;\n1368                 len = av_clip((idx_sh16 - next_idx_sh16) / s->pitch_diff_sh16 / 8,\n1369                               1, size - n);\n1370             } else\n1371                 len = size;\n1372\n1373             ff_acelp_interpolatef(&excitation[n], &excitation[n - pitch],\n1374                                   wmavoice_ipol1_coeffs, 17,\n1375                                   idx, 9, len);\n1376         }\n1377     } else /* ACB_TYPE_HAMMING */ {\n1378         int block_pitch = block_pitch_sh2 >> 2;\n1379         idx             = block_pitch_sh2 & 3;\n1380         if (idx) {\n1381             ff_acelp_interpolatef(excitation, &excitation[-block_pitch],\n1382                                   wmavoice_ipol2_coeffs, 4,\n1383                                   idx, 8, size);\n1384         } else\n1385             av_memcpy_backptr((uint8_t *) excitation, sizeof(float) * block_pitch,\n1386                               sizeof(float) * size);\n1387     }\n1388\n1389     /* Interpolate ACB/FCB and use as excitation signal */\n1390     ff_weighted_vector_sumf(excitation, excitation, pulses,\n1391                             acb_gain, fcb_gain, size);\n1392 }"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "575 static void calc_input_response(WMAVoiceContext *s, float *lpcs,\n576                                 int fcb_type, float *coeffs, int remainder)\n577 {\n578     float last_coeff, min = 15.0, max = -15.0;\n579     float irange, angle_mul, gain_mul, range, sq;\n580     int n, idx;\n581\n582     /* Create frequency power spectrum of speech input (i.e. RDFT of LPCs) */\n583     s->rdft.rdft_calc(&s->rdft, lpcs);\n584 #define log_range(var, assign) do { \\\n585         float tmp = log10f(assign);  var = tmp; \\\n586         max       = FFMAX(max, tmp); min = FFMIN(min, tmp); \\\n587     } while (0)\n588     log_range(last_coeff,  lpcs[1]         * lpcs[1]);\n589     for (n = 1; n < 64; n++)\n590         log_range(lpcs[n], lpcs[n * 2]     * lpcs[n * 2] +\n591                            lpcs[n * 2 + 1] * lpcs[n * 2 + 1]);\n592     log_range(lpcs[0],     lpcs[0]         * lpcs[0]);\n593 #undef log_range\n594     range    = max - min;\n595     lpcs[64] = last_coeff;\n596\n597     /* Now, use this spectrum to pick out these frequencies with higher\n598      * (relative) power/energy (which we then take to be \"not noise\"),\n599      * and set up a table (still in lpc[]) of (relative) gains per frequency.\n600      * These frequencies will be maintained, while others (\"noise\") will be\n601      * decreased in the filter output. */\n602     irange    = 64.0 / range; // so irange*(max-value) is in the range [0, 63]\n603     gain_mul  = range * (fcb_type == FCB_TYPE_HARDCODED ? (5.0 / 13.0) :\n604                                                           (5.0 / 14.7));\n605     angle_mul = gain_mul * (8.0 * M_LN10 / M_PI);\n606     for (n = 0; n <= 64; n++) {\n607         float pwr;\n608\n609         idx = FFMAX(0, lrint((max - lpcs[n]) * irange) - 1);\n610         pwr = wmavoice_denoise_power_table[s->denoise_strength][idx];\n611         lpcs[n] = angle_mul * pwr;\n612\n613         /* 70.57 =~ 1/log10(1.0331663) */\n614         idx = (pwr * gain_mul - 0.0295) * 70.570526123;\n615         if (idx > 127) { // fall back if index falls outside table range\n616             coeffs[n] = wmavoice_energy_table[127] *\n617                         powf(1.0331663, idx - 127);\n618         } else\n619             coeffs[n] = wmavoice_energy_table[FFMAX(0, idx)];\n620     }\n621\n622     /* calculate the Hilbert transform of the gains, which we do (since this\n623      * is a sine input) by doing a phase shift (in theory, H(sin())=cos()).\n624      * Hilbert_Transform(RDFT(x)) = Laplace_Transform(x), which calculates the\n625      * \"moment\" of the LPCs in this filter. */\n626     s->dct.dct_calc(&s->dct, lpcs);\n627     s->dst.dct_calc(&s->dst, lpcs);\n628\n629     /* Split out the coefficient indexes into phase/magnitude pairs */\n630     idx = 255 + av_clip(lpcs[64],               -255, 255);\n631     coeffs[0]  = coeffs[0]  * s->cos[idx];\n632     idx = 255 + av_clip(lpcs[64] - 2 * lpcs[63], -255, 255);\n633     last_coeff = coeffs[64] * s->cos[idx];\n634     for (n = 63;; n--) {\n635         idx = 255 + av_clip(-lpcs[64] - 2 * lpcs[n - 1], -255, 255);\n636         coeffs[n * 2 + 1] = coeffs[n] * s->sin[idx];\n637         coeffs[n * 2]     = coeffs[n] * s->cos[idx];\n638\n639         if (!--n) break;\n640\n641         idx = 255 + av_clip( lpcs[64] - 2 * lpcs[n - 1], -255, 255);\n642         coeffs[n * 2 + 1] = coeffs[n] * s->sin[idx];\n643         coeffs[n * 2]     = coeffs[n] * s->cos[idx];\n644     }\n645     coeffs[1] = last_coeff;\n646\n647     /* move into real domain */\n648     s->irdft.rdft_calc(&s->irdft, coeffs);\n649\n650     /* tilt correction and normalize scale */\n651     memset(&coeffs[remainder], 0, sizeof(coeffs[0]) * (128 - remainder));\n652     if (s->denoise_tilt_corr) {\n653         float tilt_mem = 0;\n654\n655         coeffs[remainder - 1] = 0;\n656         ff_tilt_compensation(&tilt_mem,\n657                              -1.8 * tilt_factor(coeffs, remainder - 1),\n658                              coeffs, remainder);\n659     }\n660     sq = (1.0 / 64.0) * sqrtf(1 / avpriv_scalarproduct_float_c(coeffs, coeffs,\n661                                                                remainder));\n662     for (n = 0; n < remainder; n++)\n663         coeffs[n] *= sq;\n664 }"
                    }
                ]
            }
        ],
        "sink": "len = av_clip((idx_sh16 - next_idx_sh16) / s->pitch_diff_sh16 / 8,",
        "final_sink": "len = av_clip((idx_sh16 - next_idx_sh16) / s->pitch_diff_sh16 / 8,"
    }
]