[
    {
        "prt": "interpmvp",
        "function_call": [
            "static void vc1_decode_b_mb_intfi(VC1Context *v)\n{\n    MpegEncContext *s = &v->s;\n    GetBitContext *gb = &s->gb;\n    int i, j;\n    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n    int cbp = 0; /* cbp decoding stuff */\n    int mqdiff, mquant; /* MB quantization */\n    int ttmb = v->ttfrm; /* MB Transform type */\n    int mb_has_coeffs = 0; /* last_flag */\n    int val; /* temp value */\n    int first_block = 1;\n    int dst_idx, off;\n    int fwd;\n    int dmv_x[2], dmv_y[2], pred_flag[2];\n    int bmvtype = BMV_TYPE_BACKWARD;\n    int idx_mbmode, interpmvp;\n\n    mquant      = v->pq; /* Lossy initialization */\n    s->mb_intra = 0;\n\n    idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_IF_MBMODE_VLC_BITS, 2);\n    if (idx_mbmode <= 1) { // intra MB\n        v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n        s->mb_intra          = 1;\n        s->current_picture.motion_val[1][s->block_index[0]][0] = 0;\n        s->current_picture.motion_val[1][s->block_index[0]][1] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off]         = MB_TYPE_INTRA;\n        GET_MQUANT();\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        /* Set DC scale - y and c use the same (not sure if necessary here) */\n        s->y_dc_scale = s->y_dc_scale_table[mquant];\n        s->c_dc_scale = s->c_dc_scale_table[mquant];\n        v->s.ac_pred  = v->acpred_plane[mb_pos] = get_bits1(gb);\n        mb_has_coeffs = idx_mbmode & 1;\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_ICBPCY_VLC_BITS, 2);\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            v->a_avail = v->c_avail          = 0;\n            v->mb_type[0][s->block_index[i]] = 1;\n            s->dc_val[0][s->block_index[i]]  = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            if (i == 2 || i == 3 || !s->first_slice_line)\n                v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n            if (i == 1 || i == 3 || s->mb_x)\n                v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n\n            vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n                                   (i & 4) ? v->codingset2 : v->codingset);\n            if ((i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n                continue;\n            v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);\n            if (v->rangeredfrm)\n                for (j = 0; j < 64; j++)\n                    s->block[i][j] <<= 1;\n            off  = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n            s->idsp.put_signed_pixels_clamped(s->block[i],\n                                              s->dest[dst_idx] + off,\n                                              (i & 4) ? s->uvlinesize\n                                                      : s->linesize);\n            // TODO: yet to perform loop filter\n        }\n    } else {\n        s->mb_intra = v->is_intra[s->mb_x] = 0;\n        s->current_picture.mb_type[mb_pos + v->mb_off] = MB_TYPE_16x16;\n        for (i = 0; i < 6; i++) v->mb_type[0][s->block_index[i]] = 0;\n        if (v->fmb_is_raw)\n            fwd = v->forward_mb_plane[mb_pos] = get_bits1(gb);\n        else\n            fwd = v->forward_mb_plane[mb_pos];\n        if (idx_mbmode <= 5) { // 1-MV\n            dmv_x[0]     = dmv_x[1] = dmv_y[0] = dmv_y[1] = 0;\n            pred_flag[0] = pred_flag[1] = 0;\n            if (fwd)\n                bmvtype = BMV_TYPE_FORWARD;\n            else {\n                bmvtype = decode012(gb);\n                switch (bmvtype) {\n                case 0:\n                    bmvtype = BMV_TYPE_BACKWARD;\n                    break;\n                case 1:\n                    bmvtype = BMV_TYPE_DIRECT;\n                    break;\n                case 2:\n                    bmvtype   = BMV_TYPE_INTERPOLATED;\n                    interpmvp = get_bits1(gb);\n                }\n            }\n            v->bmvtype = bmvtype;\n            if (bmvtype != BMV_TYPE_DIRECT && idx_mbmode & 1) {\n                get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD], &dmv_y[bmvtype == BMV_TYPE_BACKWARD], &pred_flag[bmvtype == BMV_TYPE_BACKWARD]);\n            }\n            if (bmvtype == BMV_TYPE_INTERPOLATED && interpmvp) {\n                get_mvdata_interlaced(v, &dmv_x[1], &dmv_y[1], &pred_flag[1]);\n            }\n            if (bmvtype == BMV_TYPE_DIRECT) {\n                dmv_x[0] = dmv_y[0] = pred_flag[0] = 0;\n                dmv_x[1] = dmv_y[1] = pred_flag[0] = 0;\n            }\n            ff_vc1_pred_b_mv_intfi(v, 0, dmv_x, dmv_y, 1, pred_flag);\n            vc1_b_mc(v, dmv_x, dmv_y, (bmvtype == BMV_TYPE_DIRECT), bmvtype);\n            mb_has_coeffs = !(idx_mbmode & 2);\n        } else { // 4-MV\n            if (fwd)\n                bmvtype = BMV_TYPE_FORWARD;\n            v->bmvtype  = bmvtype;\n            v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n            for (i = 0; i < 6; i++) {\n                if (i < 4) {\n                    dmv_x[0] = dmv_y[0] = pred_flag[0] = 0;\n                    dmv_x[1] = dmv_y[1] = pred_flag[1] = 0;\n                    val = ((v->fourmvbp >> (3 - i)) & 1);\n                    if (val) {\n                        get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD],\n                                                 &dmv_y[bmvtype == BMV_TYPE_BACKWARD],\n                                             &pred_flag[bmvtype == BMV_TYPE_BACKWARD]);\n                    }\n                    ff_vc1_pred_b_mv_intfi(v, i, dmv_x, dmv_y, 0, pred_flag);\n                    ff_vc1_mc_4mv_luma(v, i, bmvtype == BMV_TYPE_BACKWARD, 0);\n                } else if (i == 4)\n                    ff_vc1_mc_4mv_chroma(v, bmvtype == BMV_TYPE_BACKWARD);\n            }\n            mb_has_coeffs = idx_mbmode & 1;\n        }\n        if (mb_has_coeffs)\n            cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n        if (cbp) {\n            GET_MQUANT();\n        }\n        s->current_picture.qscale_table[mb_pos] = mquant;\n        if (!v->ttmbf && cbp) {\n            ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n        }\n        dst_idx = 0;\n        for (i = 0; i < 6; i++) {\n            s->dc_val[0][s->block_index[i]] = 0;\n            dst_idx += i >> 2;\n            val = ((cbp >> (5 - i)) & 1);\n            off = (i & 4) ? 0 : (i & 1) * 8 + (i & 2) * 4 * s->linesize;\n            if (val) {\n                vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n                                   first_block, s->dest[dst_idx] + off,\n                                   (i & 4) ? s->uvlinesize : s->linesize,\n                                   (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), NULL);\n                if (!v->ttmbf && ttmb < 8)\n                    ttmb = -1;\n                first_block = 0;\n            }\n        }\n    }\n}"
        ],
        "source": [
            "    int idx_mbmode, interpmvp;"
        ],
        "index": 0,
        "location": {
            "file_path": "libavcodec/vc1_block.c",
            "region": {
                "startLine": 2171,
                "startColumn": 53,
                "endColumn": 62
            },
            "context": {
                "startLine": 2169,
                "endLine": 2173,
                "snippet": {
                    "text": "            if (bmvtype == BMV_TYPE_INTERPOLATED && interpmvp) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vc1_block.c",
                        "function_body": "2076 static void vc1_decode_b_mb_intfi(VC1Context *v)\n2077 {\n2078     MpegEncContext *s = &v->s;\n2079     GetBitContext *gb = &s->gb;\n2080     int i, j;\n2081     int mb_pos = s->mb_x + s->mb_y * s->mb_stride;\n2082     int cbp = 0; /* cbp decoding stuff */\n2083     int mqdiff, mquant; /* MB quantization */\n2084     int ttmb = v->ttfrm; /* MB Transform type */\n2085     int mb_has_coeffs = 0; /* last_flag */\n2086     int val; /* temp value */\n2087     int first_block = 1;\n2088     int dst_idx, off;\n2089     int fwd;\n2090     int dmv_x[2], dmv_y[2], pred_flag[2];\n2091     int bmvtype = BMV_TYPE_BACKWARD;\n2092     int idx_mbmode, interpmvp;\n2093\n2094     mquant      = v->pq; /* Lossy initialization */\n2095     s->mb_intra = 0;\n2096\n2097     idx_mbmode = get_vlc2(gb, v->mbmode_vlc->table, VC1_IF_MBMODE_VLC_BITS, 2);\n2098     if (idx_mbmode <= 1) { // intra MB\n2099         v->is_intra[s->mb_x] = 0x3f; // Set the bitfield to all 1.\n2100         s->mb_intra          = 1;\n2101         s->current_picture.motion_val[1][s->block_index[0]][0] = 0;\n2102         s->current_picture.motion_val[1][s->block_index[0]][1] = 0;\n2103         s->current_picture.mb_type[mb_pos + v->mb_off]         = MB_TYPE_INTRA;\n2104         GET_MQUANT();\n2105         s->current_picture.qscale_table[mb_pos] = mquant;\n2106         /* Set DC scale - y and c use the same (not sure if necessary here) */\n2107         s->y_dc_scale = s->y_dc_scale_table[mquant];\n2108         s->c_dc_scale = s->c_dc_scale_table[mquant];\n2109         v->s.ac_pred  = v->acpred_plane[mb_pos] = get_bits1(gb);\n2110         mb_has_coeffs = idx_mbmode & 1;\n2111         if (mb_has_coeffs)\n2112             cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_ICBPCY_VLC_BITS, 2);\n2113         dst_idx = 0;\n2114         for (i = 0; i < 6; i++) {\n2115             v->a_avail = v->c_avail          = 0;\n2116             v->mb_type[0][s->block_index[i]] = 1;\n2117             s->dc_val[0][s->block_index[i]]  = 0;\n2118             dst_idx += i >> 2;\n2119             val = ((cbp >> (5 - i)) & 1);\n2120             if (i == 2 || i == 3 || !s->first_slice_line)\n2121                 v->a_avail = v->mb_type[0][s->block_index[i] - s->block_wrap[i]];\n2122             if (i == 1 || i == 3 || s->mb_x)\n2123                 v->c_avail = v->mb_type[0][s->block_index[i] - 1];\n2124\n2125             vc1_decode_intra_block(v, s->block[i], i, val, mquant,\n2126                                    (i & 4) ? v->codingset2 : v->codingset);\n2127             if ((i > 3) && (s->avctx->flags & AV_CODEC_FLAG_GRAY))\n2128                 continue;\n2129             v->vc1dsp.vc1_inv_trans_8x8(s->block[i]);\n2130             if (v->rangeredfrm)\n2131                 for (j = 0; j < 64; j++)\n2132                     s->block[i][j] <<= 1;\n2133             off  = (i & 4) ? 0 : ((i & 1) * 8 + (i & 2) * 4 * s->linesize);\n2134             s->idsp.put_signed_pixels_clamped(s->block[i],\n2135                                               s->dest[dst_idx] + off,\n2136                                               (i & 4) ? s->uvlinesize\n2137                                                       : s->linesize);\n2138             // TODO: yet to perform loop filter\n2139         }\n2140     } else {\n2141         s->mb_intra = v->is_intra[s->mb_x] = 0;\n2142         s->current_picture.mb_type[mb_pos + v->mb_off] = MB_TYPE_16x16;\n2143         for (i = 0; i < 6; i++) v->mb_type[0][s->block_index[i]] = 0;\n2144         if (v->fmb_is_raw)\n2145             fwd = v->forward_mb_plane[mb_pos] = get_bits1(gb);\n2146         else\n2147             fwd = v->forward_mb_plane[mb_pos];\n2148         if (idx_mbmode <= 5) { // 1-MV\n2149             dmv_x[0]     = dmv_x[1] = dmv_y[0] = dmv_y[1] = 0;\n2150             pred_flag[0] = pred_flag[1] = 0;\n2151             if (fwd)\n2152                 bmvtype = BMV_TYPE_FORWARD;\n2153             else {\n2154                 bmvtype = decode012(gb);\n2155                 switch (bmvtype) {\n2156                 case 0:\n2157                     bmvtype = BMV_TYPE_BACKWARD;\n2158                     break;\n2159                 case 1:\n2160                     bmvtype = BMV_TYPE_DIRECT;\n2161                     break;\n2162                 case 2:\n2163                     bmvtype   = BMV_TYPE_INTERPOLATED;\n2164                     interpmvp = get_bits1(gb);\n2165                 }\n2166             }\n2167             v->bmvtype = bmvtype;\n2168             if (bmvtype != BMV_TYPE_DIRECT && idx_mbmode & 1) {\n2169                 get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD], &dmv_y[bmvtype == BMV_TYPE_BACKWARD], &pred_flag[bmvtype == BMV_TYPE_BACKWARD]);\n2170             }\n2171             if (bmvtype == BMV_TYPE_INTERPOLATED && interpmvp) {\n2172                 get_mvdata_interlaced(v, &dmv_x[1], &dmv_y[1], &pred_flag[1]);\n2173             }\n2174             if (bmvtype == BMV_TYPE_DIRECT) {\n2175                 dmv_x[0] = dmv_y[0] = pred_flag[0] = 0;\n2176                 dmv_x[1] = dmv_y[1] = pred_flag[0] = 0;\n2177             }\n2178             ff_vc1_pred_b_mv_intfi(v, 0, dmv_x, dmv_y, 1, pred_flag);\n2179             vc1_b_mc(v, dmv_x, dmv_y, (bmvtype == BMV_TYPE_DIRECT), bmvtype);\n2180             mb_has_coeffs = !(idx_mbmode & 2);\n2181         } else { // 4-MV\n2182             if (fwd)\n2183                 bmvtype = BMV_TYPE_FORWARD;\n2184             v->bmvtype  = bmvtype;\n2185             v->fourmvbp = get_vlc2(gb, v->fourmvbp_vlc->table, VC1_4MV_BLOCK_PATTERN_VLC_BITS, 1);\n2186             for (i = 0; i < 6; i++) {\n2187                 if (i < 4) {\n2188                     dmv_x[0] = dmv_y[0] = pred_flag[0] = 0;\n2189                     dmv_x[1] = dmv_y[1] = pred_flag[1] = 0;\n2190                     val = ((v->fourmvbp >> (3 - i)) & 1);\n2191                     if (val) {\n2192                         get_mvdata_interlaced(v, &dmv_x[bmvtype == BMV_TYPE_BACKWARD],\n2193                                                  &dmv_y[bmvtype == BMV_TYPE_BACKWARD],\n2194                                              &pred_flag[bmvtype == BMV_TYPE_BACKWARD]);\n2195                     }\n2196                     ff_vc1_pred_b_mv_intfi(v, i, dmv_x, dmv_y, 0, pred_flag);\n2197                     ff_vc1_mc_4mv_luma(v, i, bmvtype == BMV_TYPE_BACKWARD, 0);\n2198                 } else if (i == 4)\n2199                     ff_vc1_mc_4mv_chroma(v, bmvtype == BMV_TYPE_BACKWARD);\n2200             }\n2201             mb_has_coeffs = idx_mbmode & 1;\n2202         }\n2203         if (mb_has_coeffs)\n2204             cbp = 1 + get_vlc2(&v->s.gb, v->cbpcy_vlc->table, VC1_CBPCY_P_VLC_BITS, 2);\n2205         if (cbp) {\n2206             GET_MQUANT();\n2207         }\n2208         s->current_picture.qscale_table[mb_pos] = mquant;\n2209         if (!v->ttmbf && cbp) {\n2210             ttmb = get_vlc2(gb, ff_vc1_ttmb_vlc[v->tt_index].table, VC1_TTMB_VLC_BITS, 2);\n2211         }\n2212         dst_idx = 0;\n2213         for (i = 0; i < 6; i++) {\n2214             s->dc_val[0][s->block_index[i]] = 0;\n2215             dst_idx += i >> 2;\n2216             val = ((cbp >> (5 - i)) & 1);\n2217             off = (i & 4) ? 0 : (i & 1) * 8 + (i & 2) * 4 * s->linesize;\n2218             if (val) {\n2219                 vc1_decode_p_block(v, s->block[i], i, mquant, ttmb,\n2220                                    first_block, s->dest[dst_idx] + off,\n2221                                    (i & 4) ? s->uvlinesize : s->linesize,\n2222                                    (i & 4) && (s->avctx->flags & AV_CODEC_FLAG_GRAY), NULL);\n2223                 if (!v->ttmbf && ttmb < 8)\n2224                     ttmb = -1;\n2225                 first_block = 0;\n2226             }\n2227         }\n2228     }\n2229 }"
                    },
                    {
                        "file_path": "/libavcodec/vc1_block.c",
                        "function_body": "2934 static void vc1_decode_b_blocks(VC1Context *v)\n2935 {\n2936     MpegEncContext *s = &v->s;\n2937\n2938     /* select coding mode used for VLC tables selection */\n2939     switch (v->c_ac_table_index) {\n2940     case 0:\n2941         v->codingset = (v->pqindex <= 8) ? CS_HIGH_RATE_INTRA : CS_LOW_MOT_INTRA;\n2942         break;\n2943     case 1:\n2944         v->codingset = CS_HIGH_MOT_INTRA;\n2945         break;\n2946     case 2:\n2947         v->codingset = CS_MID_RATE_INTRA;\n2948         break;\n2949     }\n2950\n2951     switch (v->c_ac_table_index) {\n2952     case 0:\n2953         v->codingset2 = (v->pqindex <= 8) ? CS_HIGH_RATE_INTER : CS_LOW_MOT_INTER;\n2954         break;\n2955     case 1:\n2956         v->codingset2 = CS_HIGH_MOT_INTER;\n2957         break;\n2958     case 2:\n2959         v->codingset2 = CS_MID_RATE_INTER;\n2960         break;\n2961     }\n2962\n2963     s->first_slice_line = 1;\n2964     for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {\n2965         s->mb_x = 0;\n2966         init_block_index(v);\n2967         for (; s->mb_x < s->mb_width; s->mb_x++) {\n2968             ff_update_block_index(s);\n2969\n2970             if (v->fcm == ILACE_FIELD)\n2971                 vc1_decode_b_mb_intfi(v);\n2972             else if (v->fcm == ILACE_FRAME)\n2973                 vc1_decode_b_mb_intfr(v);\n2974             else\n2975                 vc1_decode_b_mb(v);\n2976             if (get_bits_count(&s->gb) > v->bits || get_bits_count(&s->gb) < 0) {\n2977                 // TODO: may need modification to handle slice coding\n2978                 ff_er_add_slice(&s->er, 0, s->start_mb_y, s->mb_x, s->mb_y, ER_MB_ERROR);\n2979                 av_log(s->avctx, AV_LOG_ERROR, \"Bits overconsumption: %i > %i at %ix%i\\n\",\n2980                        get_bits_count(&s->gb), v->bits, s->mb_x, s->mb_y);\n2981                 return;\n2982             }\n2983             if (v->s.loop_filter)\n2984                 ff_vc1_loop_filter_iblk(v, v->pq);\n2985         }\n2986         if (!v->s.loop_filter)\n2987             ff_mpeg_draw_horiz_band(s, s->mb_y * 16, 16);\n2988         else if (s->mb_y)\n2989             ff_mpeg_draw_horiz_band(s, (s->mb_y - 1) * 16, 16);\n2990         s->first_slice_line = 0;\n2991     }\n2992     if (v->s.loop_filter)\n2993         ff_mpeg_draw_horiz_band(s, (s->end_mb_y - 1) * 16, 16);\n2994     ff_er_add_slice(&s->er, 0, s->start_mb_y << v->field_mode, s->mb_width - 1,\n2995                     (s->end_mb_y << v->field_mode) - 1, ER_MB_END);\n2996 }"
                    }
                ]
            }
        ],
        "sink": "if (bmvtype == BMV_TYPE_INTERPOLATED && interpmvp) {",
        "final_sink": "if (bmvtype == BMV_TYPE_INTERPOLATED && interpmvp) {"
    },
    {
        "prt": "flat8out",
        "function_call": [
            "static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n                                         int E, int I, int H,\n                                         ptrdiff_t stridea, ptrdiff_t strideb,\n                                         int wd)\n{\n    int i;\n\n    for (i = 0; i < 8; i++, dst += stridea) {\n        int p7, p6, p5, p4;\n        int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n        int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n        int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n        int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n        int q4, q5, q6, q7;\n        int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n                 FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n                 FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n                 FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n        int flat8out, flat8in;\n\n        if (!fm)\n            continue;\n\n        if (wd >= 16) {\n            p7 = dst[strideb * -8];\n            p6 = dst[strideb * -7];\n            p5 = dst[strideb * -6];\n            p4 = dst[strideb * -5];\n            q4 = dst[strideb * +4];\n            q5 = dst[strideb * +5];\n            q6 = dst[strideb * +6];\n            q7 = dst[strideb * +7];\n\n            flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n                       FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n                       FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n                       FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n        }\n\n        if (wd >= 8)\n            flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n                      FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n                      FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n\n        if (wd >= 16 && flat8out && flat8in) {\n            dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n            dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n                                 p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n            dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n                                 p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n            dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n                                 p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n            dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n                                 p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n            dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n                                 p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n            dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n                                 q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n            dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n                                 q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n            dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n                                 q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n            dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n                                 q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n                                 q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n                                 q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n                                 q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n                                 q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n        } else if (wd >= 8 && flat8in) {\n            dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n            dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n            dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n            dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n            dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n            dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n        } else {\n            int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n\n            if (hev) {\n                int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n            } else {\n                int f = av_clip_int8(3 * (q0 - p0));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n\n                f = (f1 + 1) >> 1;\n                dst[strideb * -2] = av_clip_uint8(p1 + f);\n                dst[strideb * +1] = av_clip_uint8(q1 - f);\n            }\n        }\n    }\n}"
        ],
        "source": [
            "        int flat8out, flat8in;"
        ],
        "index": 1,
        "location": {
            "file_path": "libavcodec/vp9dsp.c",
            "region": {
                "startLine": 1616,
                "startColumn": 25,
                "endColumn": 33
            },
            "context": {
                "startLine": 1614,
                "endLine": 1618,
                "snippet": {
                    "text": "        if (wd >= 16 && flat8out && flat8in) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2521 int ff_h264_execute_decode_slices(H264Context *h)\n2522 {\n2523     AVCodecContext *const avctx = h->avctx;\n2524     H264SliceContext *sl;\n2525     int context_count = h->nb_slice_ctx_queued;\n2526     int ret = 0;\n2527     int i, j;\n2528\n2529     if (h->avctx->hwaccel || context_count < 1)\n2530         return 0;\n2531     if (context_count == 1) {\n2532\n2533         h->slice_ctx[0].next_slice_idx = h->mb_width * h->mb_height;\n2534         h->postpone_filter = 0;\n2535\n2536         ret = decode_slice(avctx, &h->slice_ctx[0]);\n2537         h->mb_y = h->slice_ctx[0].mb_y;\n2538         if (ret < 0)\n2539             goto finish;\n2540     } else {\n2541         for (i = 0; i < context_count; i++) {\n2542             int next_slice_idx = h->mb_width * h->mb_height;\n2543             int slice_idx;\n2544\n2545             sl                 = &h->slice_ctx[i];\n2546             sl->er.error_count = 0;\n2547\n2548             /* make sure none of those slices overlap */\n2549             slice_idx = sl->mb_y * h->mb_width + sl->mb_x;\n2550             for (j = 0; j < context_count; j++) {\n2551                 H264SliceContext *sl2 = &h->slice_ctx[j];\n2552                 int        slice_idx2 = sl2->mb_y * h->mb_width + sl2->mb_x;\n2553\n2554                 if (i == j || slice_idx2 < slice_idx)\n2555                     continue;\n2556                 next_slice_idx = FFMIN(next_slice_idx, slice_idx2);\n2557             }\n2558             sl->next_slice_idx = next_slice_idx;\n2559         }\n2560\n2561         avctx->execute(avctx, decode_slice, h->slice_ctx,\n2562                        NULL, context_count, sizeof(h->slice_ctx[0]));\n2563\n2564         /* pull back stuff from slices to master context */\n2565         sl                   = &h->slice_ctx[context_count - 1];\n2566         h->mb_y              = sl->mb_y;\n2567         for (i = 1; i < context_count; i++)\n2568             h->slice_ctx[0].er.error_count += h->slice_ctx[i].er.error_count;\n2569\n2570         if (h->postpone_filter) {\n2571             h->postpone_filter = 0;\n2572\n2573             for (i = 0; i < context_count; i++) {\n2574                 int y_end, x_end;\n2575\n2576                 sl = &h->slice_ctx[i];\n2577                 y_end = FFMIN(sl->mb_y + 1, h->mb_height);\n2578                 x_end = (sl->mb_y >= h->mb_height) ? h->mb_width : sl->mb_x;\n2579\n2580                 for (j = sl->resync_mb_y; j < y_end; j += 1 + FIELD_OR_MBAFF_PICTURE(h)) {\n2581                     sl->mb_y = j;\n2582                     loop_filter(h, sl, j > sl->resync_mb_y ? 0 : sl->resync_mb_x,\n2583                                 j == y_end - 1 ? x_end : h->mb_width);\n2584                 }\n2585             }\n2586         }\n2587     }\n2588\n2589 finish:\n2590     h->nb_slice_ctx_queued = 0;\n2591     return ret;\n2592 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1606 int ff_rv34_decode_frame(AVCodecContext *avctx,\n1607                             void *data, int *got_picture_ptr,\n1608                             AVPacket *avpkt)\n1609 {\n1610     const uint8_t *buf = avpkt->data;\n1611     int buf_size = avpkt->size;\n1612     RV34DecContext *r = avctx->priv_data;\n1613     MpegEncContext *s = &r->s;\n1614     AVFrame *pict = data;\n1615     SliceInfo si;\n1616     int i, ret;\n1617     int slice_count;\n1618     const uint8_t *slices_hdr = NULL;\n1619     int last = 0;\n1620\n1621     /* no supplementary picture */\n1622     if (buf_size == 0) {\n1623         /* special case for last picture */\n1624         if (s->low_delay==0 && s->next_picture_ptr) {\n1625             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n1626                 return ret;\n1627             s->next_picture_ptr = NULL;\n1628\n1629             *got_picture_ptr = 1;\n1630         }\n1631         return 0;\n1632     }\n1633\n1634     if(!avctx->slice_count){\n1635         slice_count = (*buf++) + 1;\n1636         slices_hdr = buf + 4;\n1637         buf += 8 * slice_count;\n1638         buf_size -= 1 + 8 * slice_count;\n1639     }else\n1640         slice_count = avctx->slice_count;\n1641\n1642     //parse first slice header to check whether this frame can be decoded\n1643     if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n1644        get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n1645         av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1646         return AVERROR_INVALIDDATA;\n1647     }\n1648     init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n1649     if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n1650         av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n1651         return AVERROR_INVALIDDATA;\n1652     }\n1653     if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&\n1654         si.type == AV_PICTURE_TYPE_B) {\n1655         av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n1656                \"reference data.\\n\");\n1657         return AVERROR_INVALIDDATA;\n1658     }\n1659     if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n1660        || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n1661        ||  avctx->skip_frame >= AVDISCARD_ALL)\n1662         return avpkt->size;\n1663\n1664     /* first slice */\n1665     if (si.start == 0) {\n1666         if (s->mb_num_left > 0) {\n1667             av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n1668                    s->mb_num_left);\n1669             ff_er_frame_end(&s->er);\n1670             ff_mpv_frame_end(s);\n1671         }\n1672\n1673         if (s->width != si.width || s->height != si.height) {\n1674             int err;\n1675\n1676             av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n1677                    si.width, si.height);\n1678\n1679             s->width  = si.width;\n1680             s->height = si.height;\n1681\n1682             err = ff_set_dimensions(s->avctx, s->width, s->height);\n1683             if (err < 0)\n1684                 return err;\n1685\n1686             if ((err = ff_mpv_common_frame_size_change(s)) < 0)\n1687                 return err;\n1688             if ((err = rv34_decoder_realloc(r)) < 0)\n1689                 return err;\n1690         }\n1691         s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n1692         if (ff_mpv_frame_start(s, s->avctx) < 0)\n1693             return -1;\n1694         ff_mpeg_er_frame_start(s);\n1695         if (!r->tmp_b_block_base) {\n1696             int i;\n1697\n1698             r->tmp_b_block_base = av_malloc(s->linesize * 48);\n1699             for (i = 0; i < 2; i++)\n1700                 r->tmp_b_block_y[i] = r->tmp_b_block_base\n1701                                       + i * 16 * s->linesize;\n1702             for (i = 0; i < 4; i++)\n1703                 r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n1704                                        + (i >> 1) * 8 * s->uvlinesize\n1705                                        + (i &  1) * 16;\n1706         }\n1707         r->cur_pts = si.pts;\n1708         if (s->pict_type != AV_PICTURE_TYPE_B) {\n1709             r->last_pts = r->next_pts;\n1710             r->next_pts = r->cur_pts;\n1711         } else {\n1712             int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n1713             int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n1714             int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n1715\n1716             if(!refdist){\n1717                 r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n1718                 r->scaled_weight = 0;\n1719             }else{\n1720                 r->mv_weight1 = (dist0 << 14) / refdist;\n1721                 r->mv_weight2 = (dist1 << 14) / refdist;\n1722                 if((r->mv_weight1|r->mv_weight2) & 511){\n1723                     r->weight1 = r->mv_weight1;\n1724                     r->weight2 = r->mv_weight2;\n1725                     r->scaled_weight = 0;\n1726                 }else{\n1727                     r->weight1 = r->mv_weight1 >> 9;\n1728                     r->weight2 = r->mv_weight2 >> 9;\n1729                     r->scaled_weight = 1;\n1730                 }\n1731             }\n1732         }\n1733         s->mb_x = s->mb_y = 0;\n1734         ff_thread_finish_setup(s->avctx);\n1735     } else if (HAVE_THREADS &&\n1736                (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1737         av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n1738                \"multithreading mode (start MB is %d).\\n\", si.start);\n1739         return AVERROR_INVALIDDATA;\n1740     }\n1741\n1742     for(i = 0; i < slice_count; i++){\n1743         int offset = get_slice_offset(avctx, slices_hdr, i);\n1744         int size;\n1745         if(i+1 == slice_count)\n1746             size = buf_size - offset;\n1747         else\n1748             size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n1749\n1750         if(offset < 0 || offset > buf_size){\n1751             av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1752             break;\n1753         }\n1754\n1755         r->si.end = s->mb_width * s->mb_height;\n1756         s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n1757\n1758         if(i+1 < slice_count){\n1759             if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n1760                 get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n1761                 av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1762                 break;\n1763             }\n1764             init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n1765             if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n1766                 if(i+2 < slice_count)\n1767                     size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n1768                 else\n1769                     size = buf_size - offset;\n1770             }else\n1771                 r->si.end = si.start;\n1772         }\n1773         if (size < 0 || size > buf_size - offset) {\n1774             av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n1775             break;\n1776         }\n1777         last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n1778         if(last)\n1779             break;\n1780     }\n1781\n1782     if (s->current_picture_ptr) {\n1783         if (last) {\n1784             if(r->loop_filter)\n1785                 r->loop_filter(r, s->mb_height - 1);\n1786\n1787             ret = finish_frame(avctx, pict);\n1788             if (ret < 0)\n1789                 return ret;\n1790             *got_picture_ptr = ret;\n1791         } else if (HAVE_THREADS &&\n1792                    (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1793             av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n1794             /* always mark the current frame as finished, frame-mt supports\n1795              * only complete frames */\n1796             ff_er_frame_end(&s->er);\n1797             ff_mpv_frame_end(s);\n1798             s->mb_num_left = 0;\n1799             ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n1800             return AVERROR_INVALIDDATA;\n1801         }\n1802     }\n1803\n1804     return avpkt->size;\n1805 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1394 static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int buf_size)\n1395 {\n1396     MpegEncContext *s = &r->s;\n1397     GetBitContext *gb = &s->gb;\n1398     int mb_pos, slice_type;\n1399     int res;\n1400\n1401     init_get_bits(&r->s.gb, buf, buf_size*8);\n1402     res = r->parse_slice_header(r, gb, &r->si);\n1403     if(res < 0){\n1404         av_log(s->avctx, AV_LOG_ERROR, \"Incorrect or unknown slice header\\n\");\n1405         return -1;\n1406     }\n1407\n1408     slice_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n1409     if (slice_type != s->pict_type) {\n1410         av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n1411         return AVERROR_INVALIDDATA;\n1412     }\n1413\n1414     r->si.end = end;\n1415     s->qscale = r->si.quant;\n1416     s->mb_num_left = r->si.end - r->si.start;\n1417     r->s.mb_skip_run = 0;\n1418\n1419     mb_pos = s->mb_x + s->mb_y * s->mb_width;\n1420     if(r->si.start != mb_pos){\n1421         av_log(s->avctx, AV_LOG_ERROR, \"Slice indicates MB offset %d, got %d\\n\", r->si.start, mb_pos);\n1422         s->mb_x = r->si.start % s->mb_width;\n1423         s->mb_y = r->si.start / s->mb_width;\n1424     }\n1425     memset(r->intra_types_hist, -1, r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist));\n1426     s->first_slice_line = 1;\n1427     s->resync_mb_x = s->mb_x;\n1428     s->resync_mb_y = s->mb_y;\n1429\n1430     ff_init_block_index(s);\n1431     while(!check_slice_end(r, s)) {\n1432         ff_update_block_index(s);\n1433\n1434         if(r->si.type)\n1435             res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1436         else\n1437             res = rv34_decode_intra_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1438         if(res < 0){\n1439             ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_ERROR);\n1440             return -1;\n1441         }\n1442         if (++s->mb_x == s->mb_width) {\n1443             s->mb_x = 0;\n1444             s->mb_y++;\n1445             ff_init_block_index(s);\n1446\n1447             memmove(r->intra_types_hist, r->intra_types, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1448             memset(r->intra_types, -1, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1449\n1450             if(r->loop_filter && s->mb_y >= 2)\n1451                 r->loop_filter(r, s->mb_y - 2);\n1452\n1453             if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n1454                 ff_thread_report_progress(&s->current_picture_ptr->tf,\n1455                                           s->mb_y - 2, 0);\n1456\n1457         }\n1458         if(s->mb_x == s->resync_mb_x)\n1459             s->first_slice_line=0;\n1460         s->mb_num_left--;\n1461     }\n1462     ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n1463\n1464     return s->mb_y == s->mb_height;\n1465 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2327 static int decode_slice(struct AVCodecContext *avctx, void *arg)\n2328 {\n2329     H264SliceContext *sl = arg;\n2330     const H264Context *h = sl->h264;\n2331     int lf_x_start = sl->mb_x;\n2332     int orig_deblock = sl->deblocking_filter;\n2333     int ret;\n2334\n2335     sl->linesize   = h->cur_pic_ptr->f->linesize[0];\n2336     sl->uvlinesize = h->cur_pic_ptr->f->linesize[1];\n2337\n2338     ret = alloc_scratch_buffers(sl, sl->linesize);\n2339     if (ret < 0)\n2340         return ret;\n2341\n2342     sl->mb_skip_run = -1;\n2343\n2344     if (h->postpone_filter)\n2345         sl->deblocking_filter = 0;\n2346\n2347     sl->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n2348                      (CONFIG_GRAY && (h->flags & AV_CODEC_FLAG_GRAY));\n2349\n2350     if (h->ps.pps->cabac) {\n2351         /* realign */\n2352         align_get_bits(&sl->gb);\n2353\n2354         /* init cabac */\n2355         ff_init_cabac_decoder(&sl->cabac,\n2356                               sl->gb.buffer + get_bits_count(&sl->gb) / 8,\n2357                               (get_bits_left(&sl->gb) + 7) / 8);\n2358\n2359         ff_h264_init_cabac_states(h, sl);\n2360\n2361         for (;;) {\n2362             // START_TIMER\n2363             int ret, eos;\n2364\n2365             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2366                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2367                        sl->next_slice_idx);\n2368                 return AVERROR_INVALIDDATA;\n2369             }\n2370\n2371             ret = ff_h264_decode_mb_cabac(h, sl);\n2372             // STOP_TIMER(\"decode_mb_cabac\")\n2373\n2374             if (ret >= 0)\n2375                 ff_h264_hl_decode_mb(h, sl);\n2376\n2377             // FIXME optimal? or let mb_decode decode 16x32 ?\n2378             if (ret >= 0 && FRAME_MBAFF(h)) {\n2379                 sl->mb_y++;\n2380\n2381                 ret = ff_h264_decode_mb_cabac(h, sl);\n2382\n2383                 if (ret >= 0)\n2384                     ff_h264_hl_decode_mb(h, sl);\n2385                 sl->mb_y--;\n2386             }\n2387             eos = get_cabac_terminate(&sl->cabac);\n2388\n2389             if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n2390                 sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2391                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2392                              sl->mb_y, ER_MB_END);\n2393                 if (sl->mb_x >= lf_x_start)\n2394                     loop_filter(h, sl, lf_x_start, sl->mb_x + 1);\n2395                 goto finish;\n2396             }\n2397             if (ret < 0 || sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2398                 av_log(h->avctx, AV_LOG_ERROR,\n2399                        \"error while decoding MB %d %d, bytestream %td\\n\",\n2400                        sl->mb_x, sl->mb_y,\n2401                        sl->cabac.bytestream_end - sl->cabac.bytestream);\n2402                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2403                              sl->mb_y, ER_MB_ERROR);\n2404                 return AVERROR_INVALIDDATA;\n2405             }\n2406\n2407             if (++sl->mb_x >= h->mb_width) {\n2408                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2409                 sl->mb_x = lf_x_start = 0;\n2410                 decode_finish_row(h, sl);\n2411                 ++sl->mb_y;\n2412                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2413                     ++sl->mb_y;\n2414                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2415                         predict_field_decoding_flag(h, sl);\n2416                 }\n2417             }\n2418\n2419             if (eos || sl->mb_y >= h->mb_height) {\n2420                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2421                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2422                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2423                              sl->mb_y, ER_MB_END);\n2424                 if (sl->mb_x > lf_x_start)\n2425                     loop_filter(h, sl, lf_x_start, sl->mb_x);\n2426                 goto finish;\n2427             }\n2428         }\n2429     } else {\n2430         for (;;) {\n2431             int ret;\n2432\n2433             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2434                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2435                        sl->next_slice_idx);\n2436                 return AVERROR_INVALIDDATA;\n2437             }\n2438\n2439             ret = ff_h264_decode_mb_cavlc(h, sl);\n2440\n2441             if (ret >= 0)\n2442                 ff_h264_hl_decode_mb(h, sl);\n2443\n2444             // FIXME optimal? or let mb_decode decode 16x32 ?\n2445             if (ret >= 0 && FRAME_MBAFF(h)) {\n2446                 sl->mb_y++;\n2447                 ret = ff_h264_decode_mb_cavlc(h, sl);\n2448\n2449                 if (ret >= 0)\n2450                     ff_h264_hl_decode_mb(h, sl);\n2451                 sl->mb_y--;\n2452             }\n2453\n2454             if (ret < 0) {\n2455                 av_log(h->avctx, AV_LOG_ERROR,\n2456                        \"error while decoding MB %d %d\\n\", sl->mb_x, sl->mb_y);\n2457                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2458                              sl->mb_y, ER_MB_ERROR);\n2459                 return ret;\n2460             }\n2461\n2462             if (++sl->mb_x >= h->mb_width) {\n2463                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2464                 sl->mb_x = lf_x_start = 0;\n2465                 decode_finish_row(h, sl);\n2466                 ++sl->mb_y;\n2467                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2468                     ++sl->mb_y;\n2469                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2470                         predict_field_decoding_flag(h, sl);\n2471                 }\n2472                 if (sl->mb_y >= h->mb_height) {\n2473                     ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2474                             get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2475\n2476                     if (get_bits_left(&sl->gb) == 0) {\n2477                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2478                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2479\n2480                         goto finish;\n2481                     } else {\n2482                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2483                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2484\n2485                         return AVERROR_INVALIDDATA;\n2486                     }\n2487                 }\n2488             }\n2489\n2490             if (get_bits_left(&sl->gb) <= 0 && sl->mb_skip_run <= 0) {\n2491                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2492                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2493\n2494                 if (get_bits_left(&sl->gb) == 0) {\n2495                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2496                                  sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2497                     if (sl->mb_x > lf_x_start)\n2498                         loop_filter(h, sl, lf_x_start, sl->mb_x);\n2499\n2500                     goto finish;\n2501                 } else {\n2502                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2503                                  sl->mb_y, ER_MB_ERROR);\n2504\n2505                     return AVERROR_INVALIDDATA;\n2506                 }\n2507             }\n2508         }\n2509     }\n2510\n2511 finish:\n2512     sl->deblocking_filter = orig_deblock;\n2513     return 0;\n2514 }"
                    }
                ]
            }
        ],
        "sink": "if (wd >= 16 && flat8out && flat8in) {",
        "final_sink": "if (wd >= 16 && flat8out && flat8in) {"
    },
    {
        "prt": "flat8in",
        "function_call": [
            "static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n                                         int E, int I, int H,\n                                         ptrdiff_t stridea, ptrdiff_t strideb,\n                                         int wd)\n{\n    int i;\n\n    for (i = 0; i < 8; i++, dst += stridea) {\n        int p7, p6, p5, p4;\n        int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n        int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n        int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n        int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n        int q4, q5, q6, q7;\n        int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n                 FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n                 FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n                 FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n        int flat8out, flat8in;\n\n        if (!fm)\n            continue;\n\n        if (wd >= 16) {\n            p7 = dst[strideb * -8];\n            p6 = dst[strideb * -7];\n            p5 = dst[strideb * -6];\n            p4 = dst[strideb * -5];\n            q4 = dst[strideb * +4];\n            q5 = dst[strideb * +5];\n            q6 = dst[strideb * +6];\n            q7 = dst[strideb * +7];\n\n            flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n                       FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n                       FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n                       FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n        }\n\n        if (wd >= 8)\n            flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n                      FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n                      FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n\n        if (wd >= 16 && flat8out && flat8in) {\n            dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n            dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n                                 p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n            dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n                                 p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n            dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n                                 p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n            dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n                                 p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n            dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n                                 p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n            dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n                                 q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n            dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n                                 q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n            dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n                                 q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n            dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n                                 q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n                                 q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n                                 q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n                                 q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n                                 q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n        } else if (wd >= 8 && flat8in) {\n            dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n            dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n            dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n            dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n            dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n            dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n        } else {\n            int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n\n            if (hev) {\n                int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n            } else {\n                int f = av_clip_int8(3 * (q0 - p0));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n\n                f = (f1 + 1) >> 1;\n                dst[strideb * -2] = av_clip_uint8(p1 + f);\n                dst[strideb * +1] = av_clip_uint8(q1 - f);\n            }\n        }\n    }\n}"
        ],
        "source": [
            "        int flat8out, flat8in;"
        ],
        "index": 2,
        "location": {
            "file_path": "libavcodec/vp9dsp.c",
            "region": {
                "startLine": 1616,
                "startColumn": 37,
                "endColumn": 44
            },
            "context": {
                "startLine": 1614,
                "endLine": 1618,
                "snippet": {
                    "text": "        if (wd >= 16 && flat8out && flat8in) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1606 int ff_rv34_decode_frame(AVCodecContext *avctx,\n1607                             void *data, int *got_picture_ptr,\n1608                             AVPacket *avpkt)\n1609 {\n1610     const uint8_t *buf = avpkt->data;\n1611     int buf_size = avpkt->size;\n1612     RV34DecContext *r = avctx->priv_data;\n1613     MpegEncContext *s = &r->s;\n1614     AVFrame *pict = data;\n1615     SliceInfo si;\n1616     int i, ret;\n1617     int slice_count;\n1618     const uint8_t *slices_hdr = NULL;\n1619     int last = 0;\n1620\n1621     /* no supplementary picture */\n1622     if (buf_size == 0) {\n1623         /* special case for last picture */\n1624         if (s->low_delay==0 && s->next_picture_ptr) {\n1625             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n1626                 return ret;\n1627             s->next_picture_ptr = NULL;\n1628\n1629             *got_picture_ptr = 1;\n1630         }\n1631         return 0;\n1632     }\n1633\n1634     if(!avctx->slice_count){\n1635         slice_count = (*buf++) + 1;\n1636         slices_hdr = buf + 4;\n1637         buf += 8 * slice_count;\n1638         buf_size -= 1 + 8 * slice_count;\n1639     }else\n1640         slice_count = avctx->slice_count;\n1641\n1642     //parse first slice header to check whether this frame can be decoded\n1643     if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n1644        get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n1645         av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1646         return AVERROR_INVALIDDATA;\n1647     }\n1648     init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n1649     if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n1650         av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n1651         return AVERROR_INVALIDDATA;\n1652     }\n1653     if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&\n1654         si.type == AV_PICTURE_TYPE_B) {\n1655         av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n1656                \"reference data.\\n\");\n1657         return AVERROR_INVALIDDATA;\n1658     }\n1659     if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n1660        || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n1661        ||  avctx->skip_frame >= AVDISCARD_ALL)\n1662         return avpkt->size;\n1663\n1664     /* first slice */\n1665     if (si.start == 0) {\n1666         if (s->mb_num_left > 0) {\n1667             av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n1668                    s->mb_num_left);\n1669             ff_er_frame_end(&s->er);\n1670             ff_mpv_frame_end(s);\n1671         }\n1672\n1673         if (s->width != si.width || s->height != si.height) {\n1674             int err;\n1675\n1676             av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n1677                    si.width, si.height);\n1678\n1679             s->width  = si.width;\n1680             s->height = si.height;\n1681\n1682             err = ff_set_dimensions(s->avctx, s->width, s->height);\n1683             if (err < 0)\n1684                 return err;\n1685\n1686             if ((err = ff_mpv_common_frame_size_change(s)) < 0)\n1687                 return err;\n1688             if ((err = rv34_decoder_realloc(r)) < 0)\n1689                 return err;\n1690         }\n1691         s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n1692         if (ff_mpv_frame_start(s, s->avctx) < 0)\n1693             return -1;\n1694         ff_mpeg_er_frame_start(s);\n1695         if (!r->tmp_b_block_base) {\n1696             int i;\n1697\n1698             r->tmp_b_block_base = av_malloc(s->linesize * 48);\n1699             for (i = 0; i < 2; i++)\n1700                 r->tmp_b_block_y[i] = r->tmp_b_block_base\n1701                                       + i * 16 * s->linesize;\n1702             for (i = 0; i < 4; i++)\n1703                 r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n1704                                        + (i >> 1) * 8 * s->uvlinesize\n1705                                        + (i &  1) * 16;\n1706         }\n1707         r->cur_pts = si.pts;\n1708         if (s->pict_type != AV_PICTURE_TYPE_B) {\n1709             r->last_pts = r->next_pts;\n1710             r->next_pts = r->cur_pts;\n1711         } else {\n1712             int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n1713             int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n1714             int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n1715\n1716             if(!refdist){\n1717                 r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n1718                 r->scaled_weight = 0;\n1719             }else{\n1720                 r->mv_weight1 = (dist0 << 14) / refdist;\n1721                 r->mv_weight2 = (dist1 << 14) / refdist;\n1722                 if((r->mv_weight1|r->mv_weight2) & 511){\n1723                     r->weight1 = r->mv_weight1;\n1724                     r->weight2 = r->mv_weight2;\n1725                     r->scaled_weight = 0;\n1726                 }else{\n1727                     r->weight1 = r->mv_weight1 >> 9;\n1728                     r->weight2 = r->mv_weight2 >> 9;\n1729                     r->scaled_weight = 1;\n1730                 }\n1731             }\n1732         }\n1733         s->mb_x = s->mb_y = 0;\n1734         ff_thread_finish_setup(s->avctx);\n1735     } else if (HAVE_THREADS &&\n1736                (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1737         av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n1738                \"multithreading mode (start MB is %d).\\n\", si.start);\n1739         return AVERROR_INVALIDDATA;\n1740     }\n1741\n1742     for(i = 0; i < slice_count; i++){\n1743         int offset = get_slice_offset(avctx, slices_hdr, i);\n1744         int size;\n1745         if(i+1 == slice_count)\n1746             size = buf_size - offset;\n1747         else\n1748             size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n1749\n1750         if(offset < 0 || offset > buf_size){\n1751             av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1752             break;\n1753         }\n1754\n1755         r->si.end = s->mb_width * s->mb_height;\n1756         s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n1757\n1758         if(i+1 < slice_count){\n1759             if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n1760                 get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n1761                 av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1762                 break;\n1763             }\n1764             init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n1765             if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n1766                 if(i+2 < slice_count)\n1767                     size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n1768                 else\n1769                     size = buf_size - offset;\n1770             }else\n1771                 r->si.end = si.start;\n1772         }\n1773         if (size < 0 || size > buf_size - offset) {\n1774             av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n1775             break;\n1776         }\n1777         last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n1778         if(last)\n1779             break;\n1780     }\n1781\n1782     if (s->current_picture_ptr) {\n1783         if (last) {\n1784             if(r->loop_filter)\n1785                 r->loop_filter(r, s->mb_height - 1);\n1786\n1787             ret = finish_frame(avctx, pict);\n1788             if (ret < 0)\n1789                 return ret;\n1790             *got_picture_ptr = ret;\n1791         } else if (HAVE_THREADS &&\n1792                    (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1793             av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n1794             /* always mark the current frame as finished, frame-mt supports\n1795              * only complete frames */\n1796             ff_er_frame_end(&s->er);\n1797             ff_mpv_frame_end(s);\n1798             s->mb_num_left = 0;\n1799             ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n1800             return AVERROR_INVALIDDATA;\n1801         }\n1802     }\n1803\n1804     return avpkt->size;\n1805 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1394 static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int buf_size)\n1395 {\n1396     MpegEncContext *s = &r->s;\n1397     GetBitContext *gb = &s->gb;\n1398     int mb_pos, slice_type;\n1399     int res;\n1400\n1401     init_get_bits(&r->s.gb, buf, buf_size*8);\n1402     res = r->parse_slice_header(r, gb, &r->si);\n1403     if(res < 0){\n1404         av_log(s->avctx, AV_LOG_ERROR, \"Incorrect or unknown slice header\\n\");\n1405         return -1;\n1406     }\n1407\n1408     slice_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n1409     if (slice_type != s->pict_type) {\n1410         av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n1411         return AVERROR_INVALIDDATA;\n1412     }\n1413\n1414     r->si.end = end;\n1415     s->qscale = r->si.quant;\n1416     s->mb_num_left = r->si.end - r->si.start;\n1417     r->s.mb_skip_run = 0;\n1418\n1419     mb_pos = s->mb_x + s->mb_y * s->mb_width;\n1420     if(r->si.start != mb_pos){\n1421         av_log(s->avctx, AV_LOG_ERROR, \"Slice indicates MB offset %d, got %d\\n\", r->si.start, mb_pos);\n1422         s->mb_x = r->si.start % s->mb_width;\n1423         s->mb_y = r->si.start / s->mb_width;\n1424     }\n1425     memset(r->intra_types_hist, -1, r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist));\n1426     s->first_slice_line = 1;\n1427     s->resync_mb_x = s->mb_x;\n1428     s->resync_mb_y = s->mb_y;\n1429\n1430     ff_init_block_index(s);\n1431     while(!check_slice_end(r, s)) {\n1432         ff_update_block_index(s);\n1433\n1434         if(r->si.type)\n1435             res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1436         else\n1437             res = rv34_decode_intra_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1438         if(res < 0){\n1439             ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_ERROR);\n1440             return -1;\n1441         }\n1442         if (++s->mb_x == s->mb_width) {\n1443             s->mb_x = 0;\n1444             s->mb_y++;\n1445             ff_init_block_index(s);\n1446\n1447             memmove(r->intra_types_hist, r->intra_types, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1448             memset(r->intra_types, -1, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1449\n1450             if(r->loop_filter && s->mb_y >= 2)\n1451                 r->loop_filter(r, s->mb_y - 2);\n1452\n1453             if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n1454                 ff_thread_report_progress(&s->current_picture_ptr->tf,\n1455                                           s->mb_y - 2, 0);\n1456\n1457         }\n1458         if(s->mb_x == s->resync_mb_x)\n1459             s->first_slice_line=0;\n1460         s->mb_num_left--;\n1461     }\n1462     ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n1463\n1464     return s->mb_y == s->mb_height;\n1465 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2521 int ff_h264_execute_decode_slices(H264Context *h)\n2522 {\n2523     AVCodecContext *const avctx = h->avctx;\n2524     H264SliceContext *sl;\n2525     int context_count = h->nb_slice_ctx_queued;\n2526     int ret = 0;\n2527     int i, j;\n2528\n2529     if (h->avctx->hwaccel || context_count < 1)\n2530         return 0;\n2531     if (context_count == 1) {\n2532\n2533         h->slice_ctx[0].next_slice_idx = h->mb_width * h->mb_height;\n2534         h->postpone_filter = 0;\n2535\n2536         ret = decode_slice(avctx, &h->slice_ctx[0]);\n2537         h->mb_y = h->slice_ctx[0].mb_y;\n2538         if (ret < 0)\n2539             goto finish;\n2540     } else {\n2541         for (i = 0; i < context_count; i++) {\n2542             int next_slice_idx = h->mb_width * h->mb_height;\n2543             int slice_idx;\n2544\n2545             sl                 = &h->slice_ctx[i];\n2546             sl->er.error_count = 0;\n2547\n2548             /* make sure none of those slices overlap */\n2549             slice_idx = sl->mb_y * h->mb_width + sl->mb_x;\n2550             for (j = 0; j < context_count; j++) {\n2551                 H264SliceContext *sl2 = &h->slice_ctx[j];\n2552                 int        slice_idx2 = sl2->mb_y * h->mb_width + sl2->mb_x;\n2553\n2554                 if (i == j || slice_idx2 < slice_idx)\n2555                     continue;\n2556                 next_slice_idx = FFMIN(next_slice_idx, slice_idx2);\n2557             }\n2558             sl->next_slice_idx = next_slice_idx;\n2559         }\n2560\n2561         avctx->execute(avctx, decode_slice, h->slice_ctx,\n2562                        NULL, context_count, sizeof(h->slice_ctx[0]));\n2563\n2564         /* pull back stuff from slices to master context */\n2565         sl                   = &h->slice_ctx[context_count - 1];\n2566         h->mb_y              = sl->mb_y;\n2567         for (i = 1; i < context_count; i++)\n2568             h->slice_ctx[0].er.error_count += h->slice_ctx[i].er.error_count;\n2569\n2570         if (h->postpone_filter) {\n2571             h->postpone_filter = 0;\n2572\n2573             for (i = 0; i < context_count; i++) {\n2574                 int y_end, x_end;\n2575\n2576                 sl = &h->slice_ctx[i];\n2577                 y_end = FFMIN(sl->mb_y + 1, h->mb_height);\n2578                 x_end = (sl->mb_y >= h->mb_height) ? h->mb_width : sl->mb_x;\n2579\n2580                 for (j = sl->resync_mb_y; j < y_end; j += 1 + FIELD_OR_MBAFF_PICTURE(h)) {\n2581                     sl->mb_y = j;\n2582                     loop_filter(h, sl, j > sl->resync_mb_y ? 0 : sl->resync_mb_x,\n2583                                 j == y_end - 1 ? x_end : h->mb_width);\n2584                 }\n2585             }\n2586         }\n2587     }\n2588\n2589 finish:\n2590     h->nb_slice_ctx_queued = 0;\n2591     return ret;\n2592 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2327 static int decode_slice(struct AVCodecContext *avctx, void *arg)\n2328 {\n2329     H264SliceContext *sl = arg;\n2330     const H264Context *h = sl->h264;\n2331     int lf_x_start = sl->mb_x;\n2332     int orig_deblock = sl->deblocking_filter;\n2333     int ret;\n2334\n2335     sl->linesize   = h->cur_pic_ptr->f->linesize[0];\n2336     sl->uvlinesize = h->cur_pic_ptr->f->linesize[1];\n2337\n2338     ret = alloc_scratch_buffers(sl, sl->linesize);\n2339     if (ret < 0)\n2340         return ret;\n2341\n2342     sl->mb_skip_run = -1;\n2343\n2344     if (h->postpone_filter)\n2345         sl->deblocking_filter = 0;\n2346\n2347     sl->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n2348                      (CONFIG_GRAY && (h->flags & AV_CODEC_FLAG_GRAY));\n2349\n2350     if (h->ps.pps->cabac) {\n2351         /* realign */\n2352         align_get_bits(&sl->gb);\n2353\n2354         /* init cabac */\n2355         ff_init_cabac_decoder(&sl->cabac,\n2356                               sl->gb.buffer + get_bits_count(&sl->gb) / 8,\n2357                               (get_bits_left(&sl->gb) + 7) / 8);\n2358\n2359         ff_h264_init_cabac_states(h, sl);\n2360\n2361         for (;;) {\n2362             // START_TIMER\n2363             int ret, eos;\n2364\n2365             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2366                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2367                        sl->next_slice_idx);\n2368                 return AVERROR_INVALIDDATA;\n2369             }\n2370\n2371             ret = ff_h264_decode_mb_cabac(h, sl);\n2372             // STOP_TIMER(\"decode_mb_cabac\")\n2373\n2374             if (ret >= 0)\n2375                 ff_h264_hl_decode_mb(h, sl);\n2376\n2377             // FIXME optimal? or let mb_decode decode 16x32 ?\n2378             if (ret >= 0 && FRAME_MBAFF(h)) {\n2379                 sl->mb_y++;\n2380\n2381                 ret = ff_h264_decode_mb_cabac(h, sl);\n2382\n2383                 if (ret >= 0)\n2384                     ff_h264_hl_decode_mb(h, sl);\n2385                 sl->mb_y--;\n2386             }\n2387             eos = get_cabac_terminate(&sl->cabac);\n2388\n2389             if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n2390                 sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2391                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2392                              sl->mb_y, ER_MB_END);\n2393                 if (sl->mb_x >= lf_x_start)\n2394                     loop_filter(h, sl, lf_x_start, sl->mb_x + 1);\n2395                 goto finish;\n2396             }\n2397             if (ret < 0 || sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2398                 av_log(h->avctx, AV_LOG_ERROR,\n2399                        \"error while decoding MB %d %d, bytestream %td\\n\",\n2400                        sl->mb_x, sl->mb_y,\n2401                        sl->cabac.bytestream_end - sl->cabac.bytestream);\n2402                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2403                              sl->mb_y, ER_MB_ERROR);\n2404                 return AVERROR_INVALIDDATA;\n2405             }\n2406\n2407             if (++sl->mb_x >= h->mb_width) {\n2408                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2409                 sl->mb_x = lf_x_start = 0;\n2410                 decode_finish_row(h, sl);\n2411                 ++sl->mb_y;\n2412                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2413                     ++sl->mb_y;\n2414                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2415                         predict_field_decoding_flag(h, sl);\n2416                 }\n2417             }\n2418\n2419             if (eos || sl->mb_y >= h->mb_height) {\n2420                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2421                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2422                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2423                              sl->mb_y, ER_MB_END);\n2424                 if (sl->mb_x > lf_x_start)\n2425                     loop_filter(h, sl, lf_x_start, sl->mb_x);\n2426                 goto finish;\n2427             }\n2428         }\n2429     } else {\n2430         for (;;) {\n2431             int ret;\n2432\n2433             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2434                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2435                        sl->next_slice_idx);\n2436                 return AVERROR_INVALIDDATA;\n2437             }\n2438\n2439             ret = ff_h264_decode_mb_cavlc(h, sl);\n2440\n2441             if (ret >= 0)\n2442                 ff_h264_hl_decode_mb(h, sl);\n2443\n2444             // FIXME optimal? or let mb_decode decode 16x32 ?\n2445             if (ret >= 0 && FRAME_MBAFF(h)) {\n2446                 sl->mb_y++;\n2447                 ret = ff_h264_decode_mb_cavlc(h, sl);\n2448\n2449                 if (ret >= 0)\n2450                     ff_h264_hl_decode_mb(h, sl);\n2451                 sl->mb_y--;\n2452             }\n2453\n2454             if (ret < 0) {\n2455                 av_log(h->avctx, AV_LOG_ERROR,\n2456                        \"error while decoding MB %d %d\\n\", sl->mb_x, sl->mb_y);\n2457                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2458                              sl->mb_y, ER_MB_ERROR);\n2459                 return ret;\n2460             }\n2461\n2462             if (++sl->mb_x >= h->mb_width) {\n2463                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2464                 sl->mb_x = lf_x_start = 0;\n2465                 decode_finish_row(h, sl);\n2466                 ++sl->mb_y;\n2467                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2468                     ++sl->mb_y;\n2469                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2470                         predict_field_decoding_flag(h, sl);\n2471                 }\n2472                 if (sl->mb_y >= h->mb_height) {\n2473                     ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2474                             get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2475\n2476                     if (get_bits_left(&sl->gb) == 0) {\n2477                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2478                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2479\n2480                         goto finish;\n2481                     } else {\n2482                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2483                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2484\n2485                         return AVERROR_INVALIDDATA;\n2486                     }\n2487                 }\n2488             }\n2489\n2490             if (get_bits_left(&sl->gb) <= 0 && sl->mb_skip_run <= 0) {\n2491                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2492                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2493\n2494                 if (get_bits_left(&sl->gb) == 0) {\n2495                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2496                                  sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2497                     if (sl->mb_x > lf_x_start)\n2498                         loop_filter(h, sl, lf_x_start, sl->mb_x);\n2499\n2500                     goto finish;\n2501                 } else {\n2502                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2503                                  sl->mb_y, ER_MB_ERROR);\n2504\n2505                     return AVERROR_INVALIDDATA;\n2506                 }\n2507             }\n2508         }\n2509     }\n2510\n2511 finish:\n2512     sl->deblocking_filter = orig_deblock;\n2513     return 0;\n2514 }"
                    }
                ]
            }
        ],
        "sink": "if (wd >= 16 && flat8out && flat8in) {",
        "final_sink": "if (wd >= 16 && flat8out && flat8in) {"
    },
    {
        "prt": "p7",
        "function_call": [
            "static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n                                         int E, int I, int H,\n                                         ptrdiff_t stridea, ptrdiff_t strideb,\n                                         int wd)\n{\n    int i;\n\n    for (i = 0; i < 8; i++, dst += stridea) {\n        int p7, p6, p5, p4;\n        int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n        int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n        int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n        int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n        int q4, q5, q6, q7;\n        int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n                 FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n                 FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n                 FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n        int flat8out, flat8in;\n\n        if (!fm)\n            continue;\n\n        if (wd >= 16) {\n            p7 = dst[strideb * -8];\n            p6 = dst[strideb * -7];\n            p5 = dst[strideb * -6];\n            p4 = dst[strideb * -5];\n            q4 = dst[strideb * +4];\n            q5 = dst[strideb * +5];\n            q6 = dst[strideb * +6];\n            q7 = dst[strideb * +7];\n\n            flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n                       FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n                       FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n                       FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n        }\n\n        if (wd >= 8)\n            flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n                      FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n                      FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n\n        if (wd >= 16 && flat8out && flat8in) {\n            dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n            dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n                                 p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n            dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n                                 p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n            dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n                                 p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n            dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n                                 p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n            dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n                                 p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n            dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n                                 q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n            dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n                                 q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n            dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n                                 q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n            dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n                                 q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n                                 q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n                                 q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n                                 q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n                                 q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n        } else if (wd >= 8 && flat8in) {\n            dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n            dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n            dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n            dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n            dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n            dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n        } else {\n            int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n\n            if (hev) {\n                int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n            } else {\n                int f = av_clip_int8(3 * (q0 - p0));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n\n                f = (f1 + 1) >> 1;\n                dst[strideb * -2] = av_clip_uint8(p1 + f);\n                dst[strideb * +1] = av_clip_uint8(q1 - f);\n            }\n        }\n    }\n}"
        ],
        "source": [
            "        int p7, p6, p5, p4;"
        ],
        "index": 3,
        "location": {
            "file_path": "libavcodec/vp9dsp.c",
            "region": {
                "startLine": 1617,
                "startColumn": 34,
                "endColumn": 36
            },
            "context": {
                "startLine": 1615,
                "endLine": 1619,
                "snippet": {
                    "text": "dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +            "
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2327 static int decode_slice(struct AVCodecContext *avctx, void *arg)\n2328 {\n2329     H264SliceContext *sl = arg;\n2330     const H264Context *h = sl->h264;\n2331     int lf_x_start = sl->mb_x;\n2332     int orig_deblock = sl->deblocking_filter;\n2333     int ret;\n2334\n2335     sl->linesize   = h->cur_pic_ptr->f->linesize[0];\n2336     sl->uvlinesize = h->cur_pic_ptr->f->linesize[1];\n2337\n2338     ret = alloc_scratch_buffers(sl, sl->linesize);\n2339     if (ret < 0)\n2340         return ret;\n2341\n2342     sl->mb_skip_run = -1;\n2343\n2344     if (h->postpone_filter)\n2345         sl->deblocking_filter = 0;\n2346\n2347     sl->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n2348                      (CONFIG_GRAY && (h->flags & AV_CODEC_FLAG_GRAY));\n2349\n2350     if (h->ps.pps->cabac) {\n2351         /* realign */\n2352         align_get_bits(&sl->gb);\n2353\n2354         /* init cabac */\n2355         ff_init_cabac_decoder(&sl->cabac,\n2356                               sl->gb.buffer + get_bits_count(&sl->gb) / 8,\n2357                               (get_bits_left(&sl->gb) + 7) / 8);\n2358\n2359         ff_h264_init_cabac_states(h, sl);\n2360\n2361         for (;;) {\n2362             // START_TIMER\n2363             int ret, eos;\n2364\n2365             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2366                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2367                        sl->next_slice_idx);\n2368                 return AVERROR_INVALIDDATA;\n2369             }\n2370\n2371             ret = ff_h264_decode_mb_cabac(h, sl);\n2372             // STOP_TIMER(\"decode_mb_cabac\")\n2373\n2374             if (ret >= 0)\n2375                 ff_h264_hl_decode_mb(h, sl);\n2376\n2377             // FIXME optimal? or let mb_decode decode 16x32 ?\n2378             if (ret >= 0 && FRAME_MBAFF(h)) {\n2379                 sl->mb_y++;\n2380\n2381                 ret = ff_h264_decode_mb_cabac(h, sl);\n2382\n2383                 if (ret >= 0)\n2384                     ff_h264_hl_decode_mb(h, sl);\n2385                 sl->mb_y--;\n2386             }\n2387             eos = get_cabac_terminate(&sl->cabac);\n2388\n2389             if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n2390                 sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2391                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2392                              sl->mb_y, ER_MB_END);\n2393                 if (sl->mb_x >= lf_x_start)\n2394                     loop_filter(h, sl, lf_x_start, sl->mb_x + 1);\n2395                 goto finish;\n2396             }\n2397             if (ret < 0 || sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2398                 av_log(h->avctx, AV_LOG_ERROR,\n2399                        \"error while decoding MB %d %d, bytestream %td\\n\",\n2400                        sl->mb_x, sl->mb_y,\n2401                        sl->cabac.bytestream_end - sl->cabac.bytestream);\n2402                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2403                              sl->mb_y, ER_MB_ERROR);\n2404                 return AVERROR_INVALIDDATA;\n2405             }\n2406\n2407             if (++sl->mb_x >= h->mb_width) {\n2408                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2409                 sl->mb_x = lf_x_start = 0;\n2410                 decode_finish_row(h, sl);\n2411                 ++sl->mb_y;\n2412                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2413                     ++sl->mb_y;\n2414                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2415                         predict_field_decoding_flag(h, sl);\n2416                 }\n2417             }\n2418\n2419             if (eos || sl->mb_y >= h->mb_height) {\n2420                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2421                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2422                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2423                              sl->mb_y, ER_MB_END);\n2424                 if (sl->mb_x > lf_x_start)\n2425                     loop_filter(h, sl, lf_x_start, sl->mb_x);\n2426                 goto finish;\n2427             }\n2428         }\n2429     } else {\n2430         for (;;) {\n2431             int ret;\n2432\n2433             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2434                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2435                        sl->next_slice_idx);\n2436                 return AVERROR_INVALIDDATA;\n2437             }\n2438\n2439             ret = ff_h264_decode_mb_cavlc(h, sl);\n2440\n2441             if (ret >= 0)\n2442                 ff_h264_hl_decode_mb(h, sl);\n2443\n2444             // FIXME optimal? or let mb_decode decode 16x32 ?\n2445             if (ret >= 0 && FRAME_MBAFF(h)) {\n2446                 sl->mb_y++;\n2447                 ret = ff_h264_decode_mb_cavlc(h, sl);\n2448\n2449                 if (ret >= 0)\n2450                     ff_h264_hl_decode_mb(h, sl);\n2451                 sl->mb_y--;\n2452             }\n2453\n2454             if (ret < 0) {\n2455                 av_log(h->avctx, AV_LOG_ERROR,\n2456                        \"error while decoding MB %d %d\\n\", sl->mb_x, sl->mb_y);\n2457                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2458                              sl->mb_y, ER_MB_ERROR);\n2459                 return ret;\n2460             }\n2461\n2462             if (++sl->mb_x >= h->mb_width) {\n2463                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2464                 sl->mb_x = lf_x_start = 0;\n2465                 decode_finish_row(h, sl);\n2466                 ++sl->mb_y;\n2467                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2468                     ++sl->mb_y;\n2469                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2470                         predict_field_decoding_flag(h, sl);\n2471                 }\n2472                 if (sl->mb_y >= h->mb_height) {\n2473                     ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2474                             get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2475\n2476                     if (get_bits_left(&sl->gb) == 0) {\n2477                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2478                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2479\n2480                         goto finish;\n2481                     } else {\n2482                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2483                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2484\n2485                         return AVERROR_INVALIDDATA;\n2486                     }\n2487                 }\n2488             }\n2489\n2490             if (get_bits_left(&sl->gb) <= 0 && sl->mb_skip_run <= 0) {\n2491                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2492                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2493\n2494                 if (get_bits_left(&sl->gb) == 0) {\n2495                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2496                                  sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2497                     if (sl->mb_x > lf_x_start)\n2498                         loop_filter(h, sl, lf_x_start, sl->mb_x);\n2499\n2500                     goto finish;\n2501                 } else {\n2502                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2503                                  sl->mb_y, ER_MB_ERROR);\n2504\n2505                     return AVERROR_INVALIDDATA;\n2506                 }\n2507             }\n2508         }\n2509     }\n2510\n2511 finish:\n2512     sl->deblocking_filter = orig_deblock;\n2513     return 0;\n2514 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1394 static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int buf_size)\n1395 {\n1396     MpegEncContext *s = &r->s;\n1397     GetBitContext *gb = &s->gb;\n1398     int mb_pos, slice_type;\n1399     int res;\n1400\n1401     init_get_bits(&r->s.gb, buf, buf_size*8);\n1402     res = r->parse_slice_header(r, gb, &r->si);\n1403     if(res < 0){\n1404         av_log(s->avctx, AV_LOG_ERROR, \"Incorrect or unknown slice header\\n\");\n1405         return -1;\n1406     }\n1407\n1408     slice_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n1409     if (slice_type != s->pict_type) {\n1410         av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n1411         return AVERROR_INVALIDDATA;\n1412     }\n1413\n1414     r->si.end = end;\n1415     s->qscale = r->si.quant;\n1416     s->mb_num_left = r->si.end - r->si.start;\n1417     r->s.mb_skip_run = 0;\n1418\n1419     mb_pos = s->mb_x + s->mb_y * s->mb_width;\n1420     if(r->si.start != mb_pos){\n1421         av_log(s->avctx, AV_LOG_ERROR, \"Slice indicates MB offset %d, got %d\\n\", r->si.start, mb_pos);\n1422         s->mb_x = r->si.start % s->mb_width;\n1423         s->mb_y = r->si.start / s->mb_width;\n1424     }\n1425     memset(r->intra_types_hist, -1, r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist));\n1426     s->first_slice_line = 1;\n1427     s->resync_mb_x = s->mb_x;\n1428     s->resync_mb_y = s->mb_y;\n1429\n1430     ff_init_block_index(s);\n1431     while(!check_slice_end(r, s)) {\n1432         ff_update_block_index(s);\n1433\n1434         if(r->si.type)\n1435             res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1436         else\n1437             res = rv34_decode_intra_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1438         if(res < 0){\n1439             ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_ERROR);\n1440             return -1;\n1441         }\n1442         if (++s->mb_x == s->mb_width) {\n1443             s->mb_x = 0;\n1444             s->mb_y++;\n1445             ff_init_block_index(s);\n1446\n1447             memmove(r->intra_types_hist, r->intra_types, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1448             memset(r->intra_types, -1, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1449\n1450             if(r->loop_filter && s->mb_y >= 2)\n1451                 r->loop_filter(r, s->mb_y - 2);\n1452\n1453             if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n1454                 ff_thread_report_progress(&s->current_picture_ptr->tf,\n1455                                           s->mb_y - 2, 0);\n1456\n1457         }\n1458         if(s->mb_x == s->resync_mb_x)\n1459             s->first_slice_line=0;\n1460         s->mb_num_left--;\n1461     }\n1462     ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n1463\n1464     return s->mb_y == s->mb_height;\n1465 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2521 int ff_h264_execute_decode_slices(H264Context *h)\n2522 {\n2523     AVCodecContext *const avctx = h->avctx;\n2524     H264SliceContext *sl;\n2525     int context_count = h->nb_slice_ctx_queued;\n2526     int ret = 0;\n2527     int i, j;\n2528\n2529     if (h->avctx->hwaccel || context_count < 1)\n2530         return 0;\n2531     if (context_count == 1) {\n2532\n2533         h->slice_ctx[0].next_slice_idx = h->mb_width * h->mb_height;\n2534         h->postpone_filter = 0;\n2535\n2536         ret = decode_slice(avctx, &h->slice_ctx[0]);\n2537         h->mb_y = h->slice_ctx[0].mb_y;\n2538         if (ret < 0)\n2539             goto finish;\n2540     } else {\n2541         for (i = 0; i < context_count; i++) {\n2542             int next_slice_idx = h->mb_width * h->mb_height;\n2543             int slice_idx;\n2544\n2545             sl                 = &h->slice_ctx[i];\n2546             sl->er.error_count = 0;\n2547\n2548             /* make sure none of those slices overlap */\n2549             slice_idx = sl->mb_y * h->mb_width + sl->mb_x;\n2550             for (j = 0; j < context_count; j++) {\n2551                 H264SliceContext *sl2 = &h->slice_ctx[j];\n2552                 int        slice_idx2 = sl2->mb_y * h->mb_width + sl2->mb_x;\n2553\n2554                 if (i == j || slice_idx2 < slice_idx)\n2555                     continue;\n2556                 next_slice_idx = FFMIN(next_slice_idx, slice_idx2);\n2557             }\n2558             sl->next_slice_idx = next_slice_idx;\n2559         }\n2560\n2561         avctx->execute(avctx, decode_slice, h->slice_ctx,\n2562                        NULL, context_count, sizeof(h->slice_ctx[0]));\n2563\n2564         /* pull back stuff from slices to master context */\n2565         sl                   = &h->slice_ctx[context_count - 1];\n2566         h->mb_y              = sl->mb_y;\n2567         for (i = 1; i < context_count; i++)\n2568             h->slice_ctx[0].er.error_count += h->slice_ctx[i].er.error_count;\n2569\n2570         if (h->postpone_filter) {\n2571             h->postpone_filter = 0;\n2572\n2573             for (i = 0; i < context_count; i++) {\n2574                 int y_end, x_end;\n2575\n2576                 sl = &h->slice_ctx[i];\n2577                 y_end = FFMIN(sl->mb_y + 1, h->mb_height);\n2578                 x_end = (sl->mb_y >= h->mb_height) ? h->mb_width : sl->mb_x;\n2579\n2580                 for (j = sl->resync_mb_y; j < y_end; j += 1 + FIELD_OR_MBAFF_PICTURE(h)) {\n2581                     sl->mb_y = j;\n2582                     loop_filter(h, sl, j > sl->resync_mb_y ? 0 : sl->resync_mb_x,\n2583                                 j == y_end - 1 ? x_end : h->mb_width);\n2584                 }\n2585             }\n2586         }\n2587     }\n2588\n2589 finish:\n2590     h->nb_slice_ctx_queued = 0;\n2591     return ret;\n2592 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1606 int ff_rv34_decode_frame(AVCodecContext *avctx,\n1607                             void *data, int *got_picture_ptr,\n1608                             AVPacket *avpkt)\n1609 {\n1610     const uint8_t *buf = avpkt->data;\n1611     int buf_size = avpkt->size;\n1612     RV34DecContext *r = avctx->priv_data;\n1613     MpegEncContext *s = &r->s;\n1614     AVFrame *pict = data;\n1615     SliceInfo si;\n1616     int i, ret;\n1617     int slice_count;\n1618     const uint8_t *slices_hdr = NULL;\n1619     int last = 0;\n1620\n1621     /* no supplementary picture */\n1622     if (buf_size == 0) {\n1623         /* special case for last picture */\n1624         if (s->low_delay==0 && s->next_picture_ptr) {\n1625             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n1626                 return ret;\n1627             s->next_picture_ptr = NULL;\n1628\n1629             *got_picture_ptr = 1;\n1630         }\n1631         return 0;\n1632     }\n1633\n1634     if(!avctx->slice_count){\n1635         slice_count = (*buf++) + 1;\n1636         slices_hdr = buf + 4;\n1637         buf += 8 * slice_count;\n1638         buf_size -= 1 + 8 * slice_count;\n1639     }else\n1640         slice_count = avctx->slice_count;\n1641\n1642     //parse first slice header to check whether this frame can be decoded\n1643     if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n1644        get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n1645         av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1646         return AVERROR_INVALIDDATA;\n1647     }\n1648     init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n1649     if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n1650         av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n1651         return AVERROR_INVALIDDATA;\n1652     }\n1653     if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&\n1654         si.type == AV_PICTURE_TYPE_B) {\n1655         av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n1656                \"reference data.\\n\");\n1657         return AVERROR_INVALIDDATA;\n1658     }\n1659     if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n1660        || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n1661        ||  avctx->skip_frame >= AVDISCARD_ALL)\n1662         return avpkt->size;\n1663\n1664     /* first slice */\n1665     if (si.start == 0) {\n1666         if (s->mb_num_left > 0) {\n1667             av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n1668                    s->mb_num_left);\n1669             ff_er_frame_end(&s->er);\n1670             ff_mpv_frame_end(s);\n1671         }\n1672\n1673         if (s->width != si.width || s->height != si.height) {\n1674             int err;\n1675\n1676             av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n1677                    si.width, si.height);\n1678\n1679             s->width  = si.width;\n1680             s->height = si.height;\n1681\n1682             err = ff_set_dimensions(s->avctx, s->width, s->height);\n1683             if (err < 0)\n1684                 return err;\n1685\n1686             if ((err = ff_mpv_common_frame_size_change(s)) < 0)\n1687                 return err;\n1688             if ((err = rv34_decoder_realloc(r)) < 0)\n1689                 return err;\n1690         }\n1691         s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n1692         if (ff_mpv_frame_start(s, s->avctx) < 0)\n1693             return -1;\n1694         ff_mpeg_er_frame_start(s);\n1695         if (!r->tmp_b_block_base) {\n1696             int i;\n1697\n1698             r->tmp_b_block_base = av_malloc(s->linesize * 48);\n1699             for (i = 0; i < 2; i++)\n1700                 r->tmp_b_block_y[i] = r->tmp_b_block_base\n1701                                       + i * 16 * s->linesize;\n1702             for (i = 0; i < 4; i++)\n1703                 r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n1704                                        + (i >> 1) * 8 * s->uvlinesize\n1705                                        + (i &  1) * 16;\n1706         }\n1707         r->cur_pts = si.pts;\n1708         if (s->pict_type != AV_PICTURE_TYPE_B) {\n1709             r->last_pts = r->next_pts;\n1710             r->next_pts = r->cur_pts;\n1711         } else {\n1712             int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n1713             int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n1714             int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n1715\n1716             if(!refdist){\n1717                 r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n1718                 r->scaled_weight = 0;\n1719             }else{\n1720                 r->mv_weight1 = (dist0 << 14) / refdist;\n1721                 r->mv_weight2 = (dist1 << 14) / refdist;\n1722                 if((r->mv_weight1|r->mv_weight2) & 511){\n1723                     r->weight1 = r->mv_weight1;\n1724                     r->weight2 = r->mv_weight2;\n1725                     r->scaled_weight = 0;\n1726                 }else{\n1727                     r->weight1 = r->mv_weight1 >> 9;\n1728                     r->weight2 = r->mv_weight2 >> 9;\n1729                     r->scaled_weight = 1;\n1730                 }\n1731             }\n1732         }\n1733         s->mb_x = s->mb_y = 0;\n1734         ff_thread_finish_setup(s->avctx);\n1735     } else if (HAVE_THREADS &&\n1736                (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1737         av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n1738                \"multithreading mode (start MB is %d).\\n\", si.start);\n1739         return AVERROR_INVALIDDATA;\n1740     }\n1741\n1742     for(i = 0; i < slice_count; i++){\n1743         int offset = get_slice_offset(avctx, slices_hdr, i);\n1744         int size;\n1745         if(i+1 == slice_count)\n1746             size = buf_size - offset;\n1747         else\n1748             size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n1749\n1750         if(offset < 0 || offset > buf_size){\n1751             av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1752             break;\n1753         }\n1754\n1755         r->si.end = s->mb_width * s->mb_height;\n1756         s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n1757\n1758         if(i+1 < slice_count){\n1759             if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n1760                 get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n1761                 av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1762                 break;\n1763             }\n1764             init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n1765             if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n1766                 if(i+2 < slice_count)\n1767                     size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n1768                 else\n1769                     size = buf_size - offset;\n1770             }else\n1771                 r->si.end = si.start;\n1772         }\n1773         if (size < 0 || size > buf_size - offset) {\n1774             av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n1775             break;\n1776         }\n1777         last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n1778         if(last)\n1779             break;\n1780     }\n1781\n1782     if (s->current_picture_ptr) {\n1783         if (last) {\n1784             if(r->loop_filter)\n1785                 r->loop_filter(r, s->mb_height - 1);\n1786\n1787             ret = finish_frame(avctx, pict);\n1788             if (ret < 0)\n1789                 return ret;\n1790             *got_picture_ptr = ret;\n1791         } else if (HAVE_THREADS &&\n1792                    (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1793             av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n1794             /* always mark the current frame as finished, frame-mt supports\n1795              * only complete frames */\n1796             ff_er_frame_end(&s->er);\n1797             ff_mpv_frame_end(s);\n1798             s->mb_num_left = 0;\n1799             ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n1800             return AVERROR_INVALIDDATA;\n1801         }\n1802     }\n1803\n1804     return avpkt->size;\n1805 }"
                    }
                ]
            }
        ],
        "sink": "dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +",
        "final_sink": "dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +"
    },
    {
        "prt": "p6",
        "function_call": [
            "static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n                                         int E, int I, int H,\n                                         ptrdiff_t stridea, ptrdiff_t strideb,\n                                         int wd)\n{\n    int i;\n\n    for (i = 0; i < 8; i++, dst += stridea) {\n        int p7, p6, p5, p4;\n        int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n        int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n        int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n        int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n        int q4, q5, q6, q7;\n        int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n                 FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n                 FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n                 FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n        int flat8out, flat8in;\n\n        if (!fm)\n            continue;\n\n        if (wd >= 16) {\n            p7 = dst[strideb * -8];\n            p6 = dst[strideb * -7];\n            p5 = dst[strideb * -6];\n            p4 = dst[strideb * -5];\n            q4 = dst[strideb * +4];\n            q5 = dst[strideb * +5];\n            q6 = dst[strideb * +6];\n            q7 = dst[strideb * +7];\n\n            flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n                       FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n                       FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n                       FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n        }\n\n        if (wd >= 8)\n            flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n                      FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n                      FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n\n        if (wd >= 16 && flat8out && flat8in) {\n            dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n            dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n                                 p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n            dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n                                 p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n            dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n                                 p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n            dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n                                 p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n            dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n                                 p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n            dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n                                 q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n            dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n                                 q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n            dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n                                 q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n            dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n                                 q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n                                 q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n                                 q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n                                 q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n                                 q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n        } else if (wd >= 8 && flat8in) {\n            dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n            dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n            dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n            dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n            dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n            dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n        } else {\n            int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n\n            if (hev) {\n                int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n            } else {\n                int f = av_clip_int8(3 * (q0 - p0));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n\n                f = (f1 + 1) >> 1;\n                dst[strideb * -2] = av_clip_uint8(p1 + f);\n                dst[strideb * +1] = av_clip_uint8(q1 - f);\n            }\n        }\n    }\n}"
        ],
        "source": [
            "        int p7, p6, p5, p4;"
        ],
        "index": 4,
        "location": {
            "file_path": "libavcodec/vp9dsp.c",
            "region": {
                "startLine": 1617,
                "startColumn": 69,
                "endColumn": 71
            },
            "context": {
                "startLine": 1615,
                "endLine": 1619,
                "snippet": {
                    "text": "            dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2521 int ff_h264_execute_decode_slices(H264Context *h)\n2522 {\n2523     AVCodecContext *const avctx = h->avctx;\n2524     H264SliceContext *sl;\n2525     int context_count = h->nb_slice_ctx_queued;\n2526     int ret = 0;\n2527     int i, j;\n2528\n2529     if (h->avctx->hwaccel || context_count < 1)\n2530         return 0;\n2531     if (context_count == 1) {\n2532\n2533         h->slice_ctx[0].next_slice_idx = h->mb_width * h->mb_height;\n2534         h->postpone_filter = 0;\n2535\n2536         ret = decode_slice(avctx, &h->slice_ctx[0]);\n2537         h->mb_y = h->slice_ctx[0].mb_y;\n2538         if (ret < 0)\n2539             goto finish;\n2540     } else {\n2541         for (i = 0; i < context_count; i++) {\n2542             int next_slice_idx = h->mb_width * h->mb_height;\n2543             int slice_idx;\n2544\n2545             sl                 = &h->slice_ctx[i];\n2546             sl->er.error_count = 0;\n2547\n2548             /* make sure none of those slices overlap */\n2549             slice_idx = sl->mb_y * h->mb_width + sl->mb_x;\n2550             for (j = 0; j < context_count; j++) {\n2551                 H264SliceContext *sl2 = &h->slice_ctx[j];\n2552                 int        slice_idx2 = sl2->mb_y * h->mb_width + sl2->mb_x;\n2553\n2554                 if (i == j || slice_idx2 < slice_idx)\n2555                     continue;\n2556                 next_slice_idx = FFMIN(next_slice_idx, slice_idx2);\n2557             }\n2558             sl->next_slice_idx = next_slice_idx;\n2559         }\n2560\n2561         avctx->execute(avctx, decode_slice, h->slice_ctx,\n2562                        NULL, context_count, sizeof(h->slice_ctx[0]));\n2563\n2564         /* pull back stuff from slices to master context */\n2565         sl                   = &h->slice_ctx[context_count - 1];\n2566         h->mb_y              = sl->mb_y;\n2567         for (i = 1; i < context_count; i++)\n2568             h->slice_ctx[0].er.error_count += h->slice_ctx[i].er.error_count;\n2569\n2570         if (h->postpone_filter) {\n2571             h->postpone_filter = 0;\n2572\n2573             for (i = 0; i < context_count; i++) {\n2574                 int y_end, x_end;\n2575\n2576                 sl = &h->slice_ctx[i];\n2577                 y_end = FFMIN(sl->mb_y + 1, h->mb_height);\n2578                 x_end = (sl->mb_y >= h->mb_height) ? h->mb_width : sl->mb_x;\n2579\n2580                 for (j = sl->resync_mb_y; j < y_end; j += 1 + FIELD_OR_MBAFF_PICTURE(h)) {\n2581                     sl->mb_y = j;\n2582                     loop_filter(h, sl, j > sl->resync_mb_y ? 0 : sl->resync_mb_x,\n2583                                 j == y_end - 1 ? x_end : h->mb_width);\n2584                 }\n2585             }\n2586         }\n2587     }\n2588\n2589 finish:\n2590     h->nb_slice_ctx_queued = 0;\n2591     return ret;\n2592 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1394 static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int buf_size)\n1395 {\n1396     MpegEncContext *s = &r->s;\n1397     GetBitContext *gb = &s->gb;\n1398     int mb_pos, slice_type;\n1399     int res;\n1400\n1401     init_get_bits(&r->s.gb, buf, buf_size*8);\n1402     res = r->parse_slice_header(r, gb, &r->si);\n1403     if(res < 0){\n1404         av_log(s->avctx, AV_LOG_ERROR, \"Incorrect or unknown slice header\\n\");\n1405         return -1;\n1406     }\n1407\n1408     slice_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n1409     if (slice_type != s->pict_type) {\n1410         av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n1411         return AVERROR_INVALIDDATA;\n1412     }\n1413\n1414     r->si.end = end;\n1415     s->qscale = r->si.quant;\n1416     s->mb_num_left = r->si.end - r->si.start;\n1417     r->s.mb_skip_run = 0;\n1418\n1419     mb_pos = s->mb_x + s->mb_y * s->mb_width;\n1420     if(r->si.start != mb_pos){\n1421         av_log(s->avctx, AV_LOG_ERROR, \"Slice indicates MB offset %d, got %d\\n\", r->si.start, mb_pos);\n1422         s->mb_x = r->si.start % s->mb_width;\n1423         s->mb_y = r->si.start / s->mb_width;\n1424     }\n1425     memset(r->intra_types_hist, -1, r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist));\n1426     s->first_slice_line = 1;\n1427     s->resync_mb_x = s->mb_x;\n1428     s->resync_mb_y = s->mb_y;\n1429\n1430     ff_init_block_index(s);\n1431     while(!check_slice_end(r, s)) {\n1432         ff_update_block_index(s);\n1433\n1434         if(r->si.type)\n1435             res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1436         else\n1437             res = rv34_decode_intra_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1438         if(res < 0){\n1439             ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_ERROR);\n1440             return -1;\n1441         }\n1442         if (++s->mb_x == s->mb_width) {\n1443             s->mb_x = 0;\n1444             s->mb_y++;\n1445             ff_init_block_index(s);\n1446\n1447             memmove(r->intra_types_hist, r->intra_types, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1448             memset(r->intra_types, -1, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1449\n1450             if(r->loop_filter && s->mb_y >= 2)\n1451                 r->loop_filter(r, s->mb_y - 2);\n1452\n1453             if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n1454                 ff_thread_report_progress(&s->current_picture_ptr->tf,\n1455                                           s->mb_y - 2, 0);\n1456\n1457         }\n1458         if(s->mb_x == s->resync_mb_x)\n1459             s->first_slice_line=0;\n1460         s->mb_num_left--;\n1461     }\n1462     ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n1463\n1464     return s->mb_y == s->mb_height;\n1465 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2327 static int decode_slice(struct AVCodecContext *avctx, void *arg)\n2328 {\n2329     H264SliceContext *sl = arg;\n2330     const H264Context *h = sl->h264;\n2331     int lf_x_start = sl->mb_x;\n2332     int orig_deblock = sl->deblocking_filter;\n2333     int ret;\n2334\n2335     sl->linesize   = h->cur_pic_ptr->f->linesize[0];\n2336     sl->uvlinesize = h->cur_pic_ptr->f->linesize[1];\n2337\n2338     ret = alloc_scratch_buffers(sl, sl->linesize);\n2339     if (ret < 0)\n2340         return ret;\n2341\n2342     sl->mb_skip_run = -1;\n2343\n2344     if (h->postpone_filter)\n2345         sl->deblocking_filter = 0;\n2346\n2347     sl->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n2348                      (CONFIG_GRAY && (h->flags & AV_CODEC_FLAG_GRAY));\n2349\n2350     if (h->ps.pps->cabac) {\n2351         /* realign */\n2352         align_get_bits(&sl->gb);\n2353\n2354         /* init cabac */\n2355         ff_init_cabac_decoder(&sl->cabac,\n2356                               sl->gb.buffer + get_bits_count(&sl->gb) / 8,\n2357                               (get_bits_left(&sl->gb) + 7) / 8);\n2358\n2359         ff_h264_init_cabac_states(h, sl);\n2360\n2361         for (;;) {\n2362             // START_TIMER\n2363             int ret, eos;\n2364\n2365             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2366                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2367                        sl->next_slice_idx);\n2368                 return AVERROR_INVALIDDATA;\n2369             }\n2370\n2371             ret = ff_h264_decode_mb_cabac(h, sl);\n2372             // STOP_TIMER(\"decode_mb_cabac\")\n2373\n2374             if (ret >= 0)\n2375                 ff_h264_hl_decode_mb(h, sl);\n2376\n2377             // FIXME optimal? or let mb_decode decode 16x32 ?\n2378             if (ret >= 0 && FRAME_MBAFF(h)) {\n2379                 sl->mb_y++;\n2380\n2381                 ret = ff_h264_decode_mb_cabac(h, sl);\n2382\n2383                 if (ret >= 0)\n2384                     ff_h264_hl_decode_mb(h, sl);\n2385                 sl->mb_y--;\n2386             }\n2387             eos = get_cabac_terminate(&sl->cabac);\n2388\n2389             if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n2390                 sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2391                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2392                              sl->mb_y, ER_MB_END);\n2393                 if (sl->mb_x >= lf_x_start)\n2394                     loop_filter(h, sl, lf_x_start, sl->mb_x + 1);\n2395                 goto finish;\n2396             }\n2397             if (ret < 0 || sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2398                 av_log(h->avctx, AV_LOG_ERROR,\n2399                        \"error while decoding MB %d %d, bytestream %td\\n\",\n2400                        sl->mb_x, sl->mb_y,\n2401                        sl->cabac.bytestream_end - sl->cabac.bytestream);\n2402                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2403                              sl->mb_y, ER_MB_ERROR);\n2404                 return AVERROR_INVALIDDATA;\n2405             }\n2406\n2407             if (++sl->mb_x >= h->mb_width) {\n2408                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2409                 sl->mb_x = lf_x_start = 0;\n2410                 decode_finish_row(h, sl);\n2411                 ++sl->mb_y;\n2412                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2413                     ++sl->mb_y;\n2414                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2415                         predict_field_decoding_flag(h, sl);\n2416                 }\n2417             }\n2418\n2419             if (eos || sl->mb_y >= h->mb_height) {\n2420                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2421                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2422                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2423                              sl->mb_y, ER_MB_END);\n2424                 if (sl->mb_x > lf_x_start)\n2425                     loop_filter(h, sl, lf_x_start, sl->mb_x);\n2426                 goto finish;\n2427             }\n2428         }\n2429     } else {\n2430         for (;;) {\n2431             int ret;\n2432\n2433             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2434                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2435                        sl->next_slice_idx);\n2436                 return AVERROR_INVALIDDATA;\n2437             }\n2438\n2439             ret = ff_h264_decode_mb_cavlc(h, sl);\n2440\n2441             if (ret >= 0)\n2442                 ff_h264_hl_decode_mb(h, sl);\n2443\n2444             // FIXME optimal? or let mb_decode decode 16x32 ?\n2445             if (ret >= 0 && FRAME_MBAFF(h)) {\n2446                 sl->mb_y++;\n2447                 ret = ff_h264_decode_mb_cavlc(h, sl);\n2448\n2449                 if (ret >= 0)\n2450                     ff_h264_hl_decode_mb(h, sl);\n2451                 sl->mb_y--;\n2452             }\n2453\n2454             if (ret < 0) {\n2455                 av_log(h->avctx, AV_LOG_ERROR,\n2456                        \"error while decoding MB %d %d\\n\", sl->mb_x, sl->mb_y);\n2457                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2458                              sl->mb_y, ER_MB_ERROR);\n2459                 return ret;\n2460             }\n2461\n2462             if (++sl->mb_x >= h->mb_width) {\n2463                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2464                 sl->mb_x = lf_x_start = 0;\n2465                 decode_finish_row(h, sl);\n2466                 ++sl->mb_y;\n2467                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2468                     ++sl->mb_y;\n2469                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2470                         predict_field_decoding_flag(h, sl);\n2471                 }\n2472                 if (sl->mb_y >= h->mb_height) {\n2473                     ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2474                             get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2475\n2476                     if (get_bits_left(&sl->gb) == 0) {\n2477                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2478                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2479\n2480                         goto finish;\n2481                     } else {\n2482                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2483                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2484\n2485                         return AVERROR_INVALIDDATA;\n2486                     }\n2487                 }\n2488             }\n2489\n2490             if (get_bits_left(&sl->gb) <= 0 && sl->mb_skip_run <= 0) {\n2491                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2492                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2493\n2494                 if (get_bits_left(&sl->gb) == 0) {\n2495                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2496                                  sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2497                     if (sl->mb_x > lf_x_start)\n2498                         loop_filter(h, sl, lf_x_start, sl->mb_x);\n2499\n2500                     goto finish;\n2501                 } else {\n2502                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2503                                  sl->mb_y, ER_MB_ERROR);\n2504\n2505                     return AVERROR_INVALIDDATA;\n2506                 }\n2507             }\n2508         }\n2509     }\n2510\n2511 finish:\n2512     sl->deblocking_filter = orig_deblock;\n2513     return 0;\n2514 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1606 int ff_rv34_decode_frame(AVCodecContext *avctx,\n1607                             void *data, int *got_picture_ptr,\n1608                             AVPacket *avpkt)\n1609 {\n1610     const uint8_t *buf = avpkt->data;\n1611     int buf_size = avpkt->size;\n1612     RV34DecContext *r = avctx->priv_data;\n1613     MpegEncContext *s = &r->s;\n1614     AVFrame *pict = data;\n1615     SliceInfo si;\n1616     int i, ret;\n1617     int slice_count;\n1618     const uint8_t *slices_hdr = NULL;\n1619     int last = 0;\n1620\n1621     /* no supplementary picture */\n1622     if (buf_size == 0) {\n1623         /* special case for last picture */\n1624         if (s->low_delay==0 && s->next_picture_ptr) {\n1625             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n1626                 return ret;\n1627             s->next_picture_ptr = NULL;\n1628\n1629             *got_picture_ptr = 1;\n1630         }\n1631         return 0;\n1632     }\n1633\n1634     if(!avctx->slice_count){\n1635         slice_count = (*buf++) + 1;\n1636         slices_hdr = buf + 4;\n1637         buf += 8 * slice_count;\n1638         buf_size -= 1 + 8 * slice_count;\n1639     }else\n1640         slice_count = avctx->slice_count;\n1641\n1642     //parse first slice header to check whether this frame can be decoded\n1643     if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n1644        get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n1645         av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1646         return AVERROR_INVALIDDATA;\n1647     }\n1648     init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n1649     if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n1650         av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n1651         return AVERROR_INVALIDDATA;\n1652     }\n1653     if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&\n1654         si.type == AV_PICTURE_TYPE_B) {\n1655         av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n1656                \"reference data.\\n\");\n1657         return AVERROR_INVALIDDATA;\n1658     }\n1659     if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n1660        || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n1661        ||  avctx->skip_frame >= AVDISCARD_ALL)\n1662         return avpkt->size;\n1663\n1664     /* first slice */\n1665     if (si.start == 0) {\n1666         if (s->mb_num_left > 0) {\n1667             av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n1668                    s->mb_num_left);\n1669             ff_er_frame_end(&s->er);\n1670             ff_mpv_frame_end(s);\n1671         }\n1672\n1673         if (s->width != si.width || s->height != si.height) {\n1674             int err;\n1675\n1676             av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n1677                    si.width, si.height);\n1678\n1679             s->width  = si.width;\n1680             s->height = si.height;\n1681\n1682             err = ff_set_dimensions(s->avctx, s->width, s->height);\n1683             if (err < 0)\n1684                 return err;\n1685\n1686             if ((err = ff_mpv_common_frame_size_change(s)) < 0)\n1687                 return err;\n1688             if ((err = rv34_decoder_realloc(r)) < 0)\n1689                 return err;\n1690         }\n1691         s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n1692         if (ff_mpv_frame_start(s, s->avctx) < 0)\n1693             return -1;\n1694         ff_mpeg_er_frame_start(s);\n1695         if (!r->tmp_b_block_base) {\n1696             int i;\n1697\n1698             r->tmp_b_block_base = av_malloc(s->linesize * 48);\n1699             for (i = 0; i < 2; i++)\n1700                 r->tmp_b_block_y[i] = r->tmp_b_block_base\n1701                                       + i * 16 * s->linesize;\n1702             for (i = 0; i < 4; i++)\n1703                 r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n1704                                        + (i >> 1) * 8 * s->uvlinesize\n1705                                        + (i &  1) * 16;\n1706         }\n1707         r->cur_pts = si.pts;\n1708         if (s->pict_type != AV_PICTURE_TYPE_B) {\n1709             r->last_pts = r->next_pts;\n1710             r->next_pts = r->cur_pts;\n1711         } else {\n1712             int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n1713             int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n1714             int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n1715\n1716             if(!refdist){\n1717                 r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n1718                 r->scaled_weight = 0;\n1719             }else{\n1720                 r->mv_weight1 = (dist0 << 14) / refdist;\n1721                 r->mv_weight2 = (dist1 << 14) / refdist;\n1722                 if((r->mv_weight1|r->mv_weight2) & 511){\n1723                     r->weight1 = r->mv_weight1;\n1724                     r->weight2 = r->mv_weight2;\n1725                     r->scaled_weight = 0;\n1726                 }else{\n1727                     r->weight1 = r->mv_weight1 >> 9;\n1728                     r->weight2 = r->mv_weight2 >> 9;\n1729                     r->scaled_weight = 1;\n1730                 }\n1731             }\n1732         }\n1733         s->mb_x = s->mb_y = 0;\n1734         ff_thread_finish_setup(s->avctx);\n1735     } else if (HAVE_THREADS &&\n1736                (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1737         av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n1738                \"multithreading mode (start MB is %d).\\n\", si.start);\n1739         return AVERROR_INVALIDDATA;\n1740     }\n1741\n1742     for(i = 0; i < slice_count; i++){\n1743         int offset = get_slice_offset(avctx, slices_hdr, i);\n1744         int size;\n1745         if(i+1 == slice_count)\n1746             size = buf_size - offset;\n1747         else\n1748             size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n1749\n1750         if(offset < 0 || offset > buf_size){\n1751             av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1752             break;\n1753         }\n1754\n1755         r->si.end = s->mb_width * s->mb_height;\n1756         s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n1757\n1758         if(i+1 < slice_count){\n1759             if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n1760                 get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n1761                 av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1762                 break;\n1763             }\n1764             init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n1765             if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n1766                 if(i+2 < slice_count)\n1767                     size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n1768                 else\n1769                     size = buf_size - offset;\n1770             }else\n1771                 r->si.end = si.start;\n1772         }\n1773         if (size < 0 || size > buf_size - offset) {\n1774             av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n1775             break;\n1776         }\n1777         last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n1778         if(last)\n1779             break;\n1780     }\n1781\n1782     if (s->current_picture_ptr) {\n1783         if (last) {\n1784             if(r->loop_filter)\n1785                 r->loop_filter(r, s->mb_height - 1);\n1786\n1787             ret = finish_frame(avctx, pict);\n1788             if (ret < 0)\n1789                 return ret;\n1790             *got_picture_ptr = ret;\n1791         } else if (HAVE_THREADS &&\n1792                    (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1793             av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n1794             /* always mark the current frame as finished, frame-mt supports\n1795              * only complete frames */\n1796             ff_er_frame_end(&s->er);\n1797             ff_mpv_frame_end(s);\n1798             s->mb_num_left = 0;\n1799             ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n1800             return AVERROR_INVALIDDATA;\n1801         }\n1802     }\n1803\n1804     return avpkt->size;\n1805 }"
                    }
                ]
            }
        ],
        "sink": "dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +",
        "final_sink": "dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +"
    },
    {
        "prt": "p5",
        "function_call": [
            "static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n                                         int E, int I, int H,\n                                         ptrdiff_t stridea, ptrdiff_t strideb,\n                                         int wd)\n{\n    int i;\n\n    for (i = 0; i < 8; i++, dst += stridea) {\n        int p7, p6, p5, p4;\n        int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n        int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n        int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n        int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n        int q4, q5, q6, q7;\n        int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n                 FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n                 FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n                 FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n        int flat8out, flat8in;\n\n        if (!fm)\n            continue;\n\n        if (wd >= 16) {\n            p7 = dst[strideb * -8];\n            p6 = dst[strideb * -7];\n            p5 = dst[strideb * -6];\n            p4 = dst[strideb * -5];\n            q4 = dst[strideb * +4];\n            q5 = dst[strideb * +5];\n            q6 = dst[strideb * +6];\n            q7 = dst[strideb * +7];\n\n            flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n                       FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n                       FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n                       FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n        }\n\n        if (wd >= 8)\n            flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n                      FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n                      FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n\n        if (wd >= 16 && flat8out && flat8in) {\n            dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n            dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n                                 p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n            dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n                                 p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n            dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n                                 p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n            dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n                                 p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n            dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n                                 p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n            dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n                                 q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n            dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n                                 q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n            dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n                                 q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n            dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n                                 q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n                                 q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n                                 q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n                                 q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n                                 q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n        } else if (wd >= 8 && flat8in) {\n            dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n            dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n            dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n            dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n            dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n            dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n        } else {\n            int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n\n            if (hev) {\n                int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n            } else {\n                int f = av_clip_int8(3 * (q0 - p0));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n\n                f = (f1 + 1) >> 1;\n                dst[strideb * -2] = av_clip_uint8(p1 + f);\n                dst[strideb * +1] = av_clip_uint8(q1 - f);\n            }\n        }\n    }\n}"
        ],
        "source": [
            "        int p7, p6, p5, p4;"
        ],
        "index": 5,
        "location": {
            "file_path": "libavcodec/vp9dsp.c",
            "region": {
                "startLine": 1618,
                "startColumn": 34,
                "endColumn": 36
            },
            "context": {
                "startLine": 1616,
                "endLine": 1620,
                "snippet": {
                    "text": "                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1606 int ff_rv34_decode_frame(AVCodecContext *avctx,\n1607                             void *data, int *got_picture_ptr,\n1608                             AVPacket *avpkt)\n1609 {\n1610     const uint8_t *buf = avpkt->data;\n1611     int buf_size = avpkt->size;\n1612     RV34DecContext *r = avctx->priv_data;\n1613     MpegEncContext *s = &r->s;\n1614     AVFrame *pict = data;\n1615     SliceInfo si;\n1616     int i, ret;\n1617     int slice_count;\n1618     const uint8_t *slices_hdr = NULL;\n1619     int last = 0;\n1620\n1621     /* no supplementary picture */\n1622     if (buf_size == 0) {\n1623         /* special case for last picture */\n1624         if (s->low_delay==0 && s->next_picture_ptr) {\n1625             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n1626                 return ret;\n1627             s->next_picture_ptr = NULL;\n1628\n1629             *got_picture_ptr = 1;\n1630         }\n1631         return 0;\n1632     }\n1633\n1634     if(!avctx->slice_count){\n1635         slice_count = (*buf++) + 1;\n1636         slices_hdr = buf + 4;\n1637         buf += 8 * slice_count;\n1638         buf_size -= 1 + 8 * slice_count;\n1639     }else\n1640         slice_count = avctx->slice_count;\n1641\n1642     //parse first slice header to check whether this frame can be decoded\n1643     if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n1644        get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n1645         av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1646         return AVERROR_INVALIDDATA;\n1647     }\n1648     init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n1649     if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n1650         av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n1651         return AVERROR_INVALIDDATA;\n1652     }\n1653     if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&\n1654         si.type == AV_PICTURE_TYPE_B) {\n1655         av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n1656                \"reference data.\\n\");\n1657         return AVERROR_INVALIDDATA;\n1658     }\n1659     if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n1660        || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n1661        ||  avctx->skip_frame >= AVDISCARD_ALL)\n1662         return avpkt->size;\n1663\n1664     /* first slice */\n1665     if (si.start == 0) {\n1666         if (s->mb_num_left > 0) {\n1667             av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n1668                    s->mb_num_left);\n1669             ff_er_frame_end(&s->er);\n1670             ff_mpv_frame_end(s);\n1671         }\n1672\n1673         if (s->width != si.width || s->height != si.height) {\n1674             int err;\n1675\n1676             av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n1677                    si.width, si.height);\n1678\n1679             s->width  = si.width;\n1680             s->height = si.height;\n1681\n1682             err = ff_set_dimensions(s->avctx, s->width, s->height);\n1683             if (err < 0)\n1684                 return err;\n1685\n1686             if ((err = ff_mpv_common_frame_size_change(s)) < 0)\n1687                 return err;\n1688             if ((err = rv34_decoder_realloc(r)) < 0)\n1689                 return err;\n1690         }\n1691         s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n1692         if (ff_mpv_frame_start(s, s->avctx) < 0)\n1693             return -1;\n1694         ff_mpeg_er_frame_start(s);\n1695         if (!r->tmp_b_block_base) {\n1696             int i;\n1697\n1698             r->tmp_b_block_base = av_malloc(s->linesize * 48);\n1699             for (i = 0; i < 2; i++)\n1700                 r->tmp_b_block_y[i] = r->tmp_b_block_base\n1701                                       + i * 16 * s->linesize;\n1702             for (i = 0; i < 4; i++)\n1703                 r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n1704                                        + (i >> 1) * 8 * s->uvlinesize\n1705                                        + (i &  1) * 16;\n1706         }\n1707         r->cur_pts = si.pts;\n1708         if (s->pict_type != AV_PICTURE_TYPE_B) {\n1709             r->last_pts = r->next_pts;\n1710             r->next_pts = r->cur_pts;\n1711         } else {\n1712             int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n1713             int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n1714             int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n1715\n1716             if(!refdist){\n1717                 r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n1718                 r->scaled_weight = 0;\n1719             }else{\n1720                 r->mv_weight1 = (dist0 << 14) / refdist;\n1721                 r->mv_weight2 = (dist1 << 14) / refdist;\n1722                 if((r->mv_weight1|r->mv_weight2) & 511){\n1723                     r->weight1 = r->mv_weight1;\n1724                     r->weight2 = r->mv_weight2;\n1725                     r->scaled_weight = 0;\n1726                 }else{\n1727                     r->weight1 = r->mv_weight1 >> 9;\n1728                     r->weight2 = r->mv_weight2 >> 9;\n1729                     r->scaled_weight = 1;\n1730                 }\n1731             }\n1732         }\n1733         s->mb_x = s->mb_y = 0;\n1734         ff_thread_finish_setup(s->avctx);\n1735     } else if (HAVE_THREADS &&\n1736                (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1737         av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n1738                \"multithreading mode (start MB is %d).\\n\", si.start);\n1739         return AVERROR_INVALIDDATA;\n1740     }\n1741\n1742     for(i = 0; i < slice_count; i++){\n1743         int offset = get_slice_offset(avctx, slices_hdr, i);\n1744         int size;\n1745         if(i+1 == slice_count)\n1746             size = buf_size - offset;\n1747         else\n1748             size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n1749\n1750         if(offset < 0 || offset > buf_size){\n1751             av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1752             break;\n1753         }\n1754\n1755         r->si.end = s->mb_width * s->mb_height;\n1756         s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n1757\n1758         if(i+1 < slice_count){\n1759             if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n1760                 get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n1761                 av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1762                 break;\n1763             }\n1764             init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n1765             if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n1766                 if(i+2 < slice_count)\n1767                     size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n1768                 else\n1769                     size = buf_size - offset;\n1770             }else\n1771                 r->si.end = si.start;\n1772         }\n1773         if (size < 0 || size > buf_size - offset) {\n1774             av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n1775             break;\n1776         }\n1777         last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n1778         if(last)\n1779             break;\n1780     }\n1781\n1782     if (s->current_picture_ptr) {\n1783         if (last) {\n1784             if(r->loop_filter)\n1785                 r->loop_filter(r, s->mb_height - 1);\n1786\n1787             ret = finish_frame(avctx, pict);\n1788             if (ret < 0)\n1789                 return ret;\n1790             *got_picture_ptr = ret;\n1791         } else if (HAVE_THREADS &&\n1792                    (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1793             av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n1794             /* always mark the current frame as finished, frame-mt supports\n1795              * only complete frames */\n1796             ff_er_frame_end(&s->er);\n1797             ff_mpv_frame_end(s);\n1798             s->mb_num_left = 0;\n1799             ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n1800             return AVERROR_INVALIDDATA;\n1801         }\n1802     }\n1803\n1804     return avpkt->size;\n1805 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2327 static int decode_slice(struct AVCodecContext *avctx, void *arg)\n2328 {\n2329     H264SliceContext *sl = arg;\n2330     const H264Context *h = sl->h264;\n2331     int lf_x_start = sl->mb_x;\n2332     int orig_deblock = sl->deblocking_filter;\n2333     int ret;\n2334\n2335     sl->linesize   = h->cur_pic_ptr->f->linesize[0];\n2336     sl->uvlinesize = h->cur_pic_ptr->f->linesize[1];\n2337\n2338     ret = alloc_scratch_buffers(sl, sl->linesize);\n2339     if (ret < 0)\n2340         return ret;\n2341\n2342     sl->mb_skip_run = -1;\n2343\n2344     if (h->postpone_filter)\n2345         sl->deblocking_filter = 0;\n2346\n2347     sl->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n2348                      (CONFIG_GRAY && (h->flags & AV_CODEC_FLAG_GRAY));\n2349\n2350     if (h->ps.pps->cabac) {\n2351         /* realign */\n2352         align_get_bits(&sl->gb);\n2353\n2354         /* init cabac */\n2355         ff_init_cabac_decoder(&sl->cabac,\n2356                               sl->gb.buffer + get_bits_count(&sl->gb) / 8,\n2357                               (get_bits_left(&sl->gb) + 7) / 8);\n2358\n2359         ff_h264_init_cabac_states(h, sl);\n2360\n2361         for (;;) {\n2362             // START_TIMER\n2363             int ret, eos;\n2364\n2365             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2366                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2367                        sl->next_slice_idx);\n2368                 return AVERROR_INVALIDDATA;\n2369             }\n2370\n2371             ret = ff_h264_decode_mb_cabac(h, sl);\n2372             // STOP_TIMER(\"decode_mb_cabac\")\n2373\n2374             if (ret >= 0)\n2375                 ff_h264_hl_decode_mb(h, sl);\n2376\n2377             // FIXME optimal? or let mb_decode decode 16x32 ?\n2378             if (ret >= 0 && FRAME_MBAFF(h)) {\n2379                 sl->mb_y++;\n2380\n2381                 ret = ff_h264_decode_mb_cabac(h, sl);\n2382\n2383                 if (ret >= 0)\n2384                     ff_h264_hl_decode_mb(h, sl);\n2385                 sl->mb_y--;\n2386             }\n2387             eos = get_cabac_terminate(&sl->cabac);\n2388\n2389             if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n2390                 sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2391                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2392                              sl->mb_y, ER_MB_END);\n2393                 if (sl->mb_x >= lf_x_start)\n2394                     loop_filter(h, sl, lf_x_start, sl->mb_x + 1);\n2395                 goto finish;\n2396             }\n2397             if (ret < 0 || sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2398                 av_log(h->avctx, AV_LOG_ERROR,\n2399                        \"error while decoding MB %d %d, bytestream %td\\n\",\n2400                        sl->mb_x, sl->mb_y,\n2401                        sl->cabac.bytestream_end - sl->cabac.bytestream);\n2402                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2403                              sl->mb_y, ER_MB_ERROR);\n2404                 return AVERROR_INVALIDDATA;\n2405             }\n2406\n2407             if (++sl->mb_x >= h->mb_width) {\n2408                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2409                 sl->mb_x = lf_x_start = 0;\n2410                 decode_finish_row(h, sl);\n2411                 ++sl->mb_y;\n2412                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2413                     ++sl->mb_y;\n2414                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2415                         predict_field_decoding_flag(h, sl);\n2416                 }\n2417             }\n2418\n2419             if (eos || sl->mb_y >= h->mb_height) {\n2420                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2421                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2422                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2423                              sl->mb_y, ER_MB_END);\n2424                 if (sl->mb_x > lf_x_start)\n2425                     loop_filter(h, sl, lf_x_start, sl->mb_x);\n2426                 goto finish;\n2427             }\n2428         }\n2429     } else {\n2430         for (;;) {\n2431             int ret;\n2432\n2433             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2434                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2435                        sl->next_slice_idx);\n2436                 return AVERROR_INVALIDDATA;\n2437             }\n2438\n2439             ret = ff_h264_decode_mb_cavlc(h, sl);\n2440\n2441             if (ret >= 0)\n2442                 ff_h264_hl_decode_mb(h, sl);\n2443\n2444             // FIXME optimal? or let mb_decode decode 16x32 ?\n2445             if (ret >= 0 && FRAME_MBAFF(h)) {\n2446                 sl->mb_y++;\n2447                 ret = ff_h264_decode_mb_cavlc(h, sl);\n2448\n2449                 if (ret >= 0)\n2450                     ff_h264_hl_decode_mb(h, sl);\n2451                 sl->mb_y--;\n2452             }\n2453\n2454             if (ret < 0) {\n2455                 av_log(h->avctx, AV_LOG_ERROR,\n2456                        \"error while decoding MB %d %d\\n\", sl->mb_x, sl->mb_y);\n2457                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2458                              sl->mb_y, ER_MB_ERROR);\n2459                 return ret;\n2460             }\n2461\n2462             if (++sl->mb_x >= h->mb_width) {\n2463                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2464                 sl->mb_x = lf_x_start = 0;\n2465                 decode_finish_row(h, sl);\n2466                 ++sl->mb_y;\n2467                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2468                     ++sl->mb_y;\n2469                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2470                         predict_field_decoding_flag(h, sl);\n2471                 }\n2472                 if (sl->mb_y >= h->mb_height) {\n2473                     ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2474                             get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2475\n2476                     if (get_bits_left(&sl->gb) == 0) {\n2477                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2478                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2479\n2480                         goto finish;\n2481                     } else {\n2482                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2483                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2484\n2485                         return AVERROR_INVALIDDATA;\n2486                     }\n2487                 }\n2488             }\n2489\n2490             if (get_bits_left(&sl->gb) <= 0 && sl->mb_skip_run <= 0) {\n2491                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2492                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2493\n2494                 if (get_bits_left(&sl->gb) == 0) {\n2495                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2496                                  sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2497                     if (sl->mb_x > lf_x_start)\n2498                         loop_filter(h, sl, lf_x_start, sl->mb_x);\n2499\n2500                     goto finish;\n2501                 } else {\n2502                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2503                                  sl->mb_y, ER_MB_ERROR);\n2504\n2505                     return AVERROR_INVALIDDATA;\n2506                 }\n2507             }\n2508         }\n2509     }\n2510\n2511 finish:\n2512     sl->deblocking_filter = orig_deblock;\n2513     return 0;\n2514 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1394 static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int buf_size)\n1395 {\n1396     MpegEncContext *s = &r->s;\n1397     GetBitContext *gb = &s->gb;\n1398     int mb_pos, slice_type;\n1399     int res;\n1400\n1401     init_get_bits(&r->s.gb, buf, buf_size*8);\n1402     res = r->parse_slice_header(r, gb, &r->si);\n1403     if(res < 0){\n1404         av_log(s->avctx, AV_LOG_ERROR, \"Incorrect or unknown slice header\\n\");\n1405         return -1;\n1406     }\n1407\n1408     slice_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n1409     if (slice_type != s->pict_type) {\n1410         av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n1411         return AVERROR_INVALIDDATA;\n1412     }\n1413\n1414     r->si.end = end;\n1415     s->qscale = r->si.quant;\n1416     s->mb_num_left = r->si.end - r->si.start;\n1417     r->s.mb_skip_run = 0;\n1418\n1419     mb_pos = s->mb_x + s->mb_y * s->mb_width;\n1420     if(r->si.start != mb_pos){\n1421         av_log(s->avctx, AV_LOG_ERROR, \"Slice indicates MB offset %d, got %d\\n\", r->si.start, mb_pos);\n1422         s->mb_x = r->si.start % s->mb_width;\n1423         s->mb_y = r->si.start / s->mb_width;\n1424     }\n1425     memset(r->intra_types_hist, -1, r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist));\n1426     s->first_slice_line = 1;\n1427     s->resync_mb_x = s->mb_x;\n1428     s->resync_mb_y = s->mb_y;\n1429\n1430     ff_init_block_index(s);\n1431     while(!check_slice_end(r, s)) {\n1432         ff_update_block_index(s);\n1433\n1434         if(r->si.type)\n1435             res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1436         else\n1437             res = rv34_decode_intra_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1438         if(res < 0){\n1439             ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_ERROR);\n1440             return -1;\n1441         }\n1442         if (++s->mb_x == s->mb_width) {\n1443             s->mb_x = 0;\n1444             s->mb_y++;\n1445             ff_init_block_index(s);\n1446\n1447             memmove(r->intra_types_hist, r->intra_types, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1448             memset(r->intra_types, -1, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1449\n1450             if(r->loop_filter && s->mb_y >= 2)\n1451                 r->loop_filter(r, s->mb_y - 2);\n1452\n1453             if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n1454                 ff_thread_report_progress(&s->current_picture_ptr->tf,\n1455                                           s->mb_y - 2, 0);\n1456\n1457         }\n1458         if(s->mb_x == s->resync_mb_x)\n1459             s->first_slice_line=0;\n1460         s->mb_num_left--;\n1461     }\n1462     ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n1463\n1464     return s->mb_y == s->mb_height;\n1465 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2521 int ff_h264_execute_decode_slices(H264Context *h)\n2522 {\n2523     AVCodecContext *const avctx = h->avctx;\n2524     H264SliceContext *sl;\n2525     int context_count = h->nb_slice_ctx_queued;\n2526     int ret = 0;\n2527     int i, j;\n2528\n2529     if (h->avctx->hwaccel || context_count < 1)\n2530         return 0;\n2531     if (context_count == 1) {\n2532\n2533         h->slice_ctx[0].next_slice_idx = h->mb_width * h->mb_height;\n2534         h->postpone_filter = 0;\n2535\n2536         ret = decode_slice(avctx, &h->slice_ctx[0]);\n2537         h->mb_y = h->slice_ctx[0].mb_y;\n2538         if (ret < 0)\n2539             goto finish;\n2540     } else {\n2541         for (i = 0; i < context_count; i++) {\n2542             int next_slice_idx = h->mb_width * h->mb_height;\n2543             int slice_idx;\n2544\n2545             sl                 = &h->slice_ctx[i];\n2546             sl->er.error_count = 0;\n2547\n2548             /* make sure none of those slices overlap */\n2549             slice_idx = sl->mb_y * h->mb_width + sl->mb_x;\n2550             for (j = 0; j < context_count; j++) {\n2551                 H264SliceContext *sl2 = &h->slice_ctx[j];\n2552                 int        slice_idx2 = sl2->mb_y * h->mb_width + sl2->mb_x;\n2553\n2554                 if (i == j || slice_idx2 < slice_idx)\n2555                     continue;\n2556                 next_slice_idx = FFMIN(next_slice_idx, slice_idx2);\n2557             }\n2558             sl->next_slice_idx = next_slice_idx;\n2559         }\n2560\n2561         avctx->execute(avctx, decode_slice, h->slice_ctx,\n2562                        NULL, context_count, sizeof(h->slice_ctx[0]));\n2563\n2564         /* pull back stuff from slices to master context */\n2565         sl                   = &h->slice_ctx[context_count - 1];\n2566         h->mb_y              = sl->mb_y;\n2567         for (i = 1; i < context_count; i++)\n2568             h->slice_ctx[0].er.error_count += h->slice_ctx[i].er.error_count;\n2569\n2570         if (h->postpone_filter) {\n2571             h->postpone_filter = 0;\n2572\n2573             for (i = 0; i < context_count; i++) {\n2574                 int y_end, x_end;\n2575\n2576                 sl = &h->slice_ctx[i];\n2577                 y_end = FFMIN(sl->mb_y + 1, h->mb_height);\n2578                 x_end = (sl->mb_y >= h->mb_height) ? h->mb_width : sl->mb_x;\n2579\n2580                 for (j = sl->resync_mb_y; j < y_end; j += 1 + FIELD_OR_MBAFF_PICTURE(h)) {\n2581                     sl->mb_y = j;\n2582                     loop_filter(h, sl, j > sl->resync_mb_y ? 0 : sl->resync_mb_x,\n2583                                 j == y_end - 1 ? x_end : h->mb_width);\n2584                 }\n2585             }\n2586         }\n2587     }\n2588\n2589 finish:\n2590     h->nb_slice_ctx_queued = 0;\n2591     return ret;\n2592 }"
                    }
                ]
            }
        ],
        "sink": "p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;",
        "final_sink": "p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;"
    },
    {
        "prt": "p4",
        "function_call": [
            "static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n                                         int E, int I, int H,\n                                         ptrdiff_t stridea, ptrdiff_t strideb,\n                                         int wd)\n{\n    int i;\n\n    for (i = 0; i < 8; i++, dst += stridea) {\n        int p7, p6, p5, p4;\n        int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n        int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n        int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n        int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n        int q4, q5, q6, q7;\n        int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n                 FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n                 FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n                 FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n        int flat8out, flat8in;\n\n        if (!fm)\n            continue;\n\n        if (wd >= 16) {\n            p7 = dst[strideb * -8];\n            p6 = dst[strideb * -7];\n            p5 = dst[strideb * -6];\n            p4 = dst[strideb * -5];\n            q4 = dst[strideb * +4];\n            q5 = dst[strideb * +5];\n            q6 = dst[strideb * +6];\n            q7 = dst[strideb * +7];\n\n            flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n                       FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n                       FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n                       FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n        }\n\n        if (wd >= 8)\n            flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n                      FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n                      FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n\n        if (wd >= 16 && flat8out && flat8in) {\n            dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n            dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n                                 p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n            dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n                                 p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n            dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n                                 p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n            dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n                                 p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n            dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n                                 p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n            dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n                                 q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n            dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n                                 q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n            dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n                                 q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n            dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n                                 q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n                                 q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n                                 q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n                                 q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n                                 q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n        } else if (wd >= 8 && flat8in) {\n            dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n            dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n            dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n            dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n            dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n            dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n        } else {\n            int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n\n            if (hev) {\n                int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n            } else {\n                int f = av_clip_int8(3 * (q0 - p0));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n\n                f = (f1 + 1) >> 1;\n                dst[strideb * -2] = av_clip_uint8(p1 + f);\n                dst[strideb * +1] = av_clip_uint8(q1 - f);\n            }\n        }\n    }\n}"
        ],
        "source": [
            "        int p7, p6, p5, p4;"
        ],
        "index": 6,
        "location": {
            "file_path": "libavcodec/vp9dsp.c",
            "region": {
                "startLine": 1618,
                "startColumn": 39,
                "endColumn": 41
            },
            "context": {
                "startLine": 1616,
                "endLine": 1620,
                "snippet": {
                    "text": "                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2327 static int decode_slice(struct AVCodecContext *avctx, void *arg)\n2328 {\n2329     H264SliceContext *sl = arg;\n2330     const H264Context *h = sl->h264;\n2331     int lf_x_start = sl->mb_x;\n2332     int orig_deblock = sl->deblocking_filter;\n2333     int ret;\n2334\n2335     sl->linesize   = h->cur_pic_ptr->f->linesize[0];\n2336     sl->uvlinesize = h->cur_pic_ptr->f->linesize[1];\n2337\n2338     ret = alloc_scratch_buffers(sl, sl->linesize);\n2339     if (ret < 0)\n2340         return ret;\n2341\n2342     sl->mb_skip_run = -1;\n2343\n2344     if (h->postpone_filter)\n2345         sl->deblocking_filter = 0;\n2346\n2347     sl->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n2348                      (CONFIG_GRAY && (h->flags & AV_CODEC_FLAG_GRAY));\n2349\n2350     if (h->ps.pps->cabac) {\n2351         /* realign */\n2352         align_get_bits(&sl->gb);\n2353\n2354         /* init cabac */\n2355         ff_init_cabac_decoder(&sl->cabac,\n2356                               sl->gb.buffer + get_bits_count(&sl->gb) / 8,\n2357                               (get_bits_left(&sl->gb) + 7) / 8);\n2358\n2359         ff_h264_init_cabac_states(h, sl);\n2360\n2361         for (;;) {\n2362             // START_TIMER\n2363             int ret, eos;\n2364\n2365             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2366                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2367                        sl->next_slice_idx);\n2368                 return AVERROR_INVALIDDATA;\n2369             }\n2370\n2371             ret = ff_h264_decode_mb_cabac(h, sl);\n2372             // STOP_TIMER(\"decode_mb_cabac\")\n2373\n2374             if (ret >= 0)\n2375                 ff_h264_hl_decode_mb(h, sl);\n2376\n2377             // FIXME optimal? or let mb_decode decode 16x32 ?\n2378             if (ret >= 0 && FRAME_MBAFF(h)) {\n2379                 sl->mb_y++;\n2380\n2381                 ret = ff_h264_decode_mb_cabac(h, sl);\n2382\n2383                 if (ret >= 0)\n2384                     ff_h264_hl_decode_mb(h, sl);\n2385                 sl->mb_y--;\n2386             }\n2387             eos = get_cabac_terminate(&sl->cabac);\n2388\n2389             if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n2390                 sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2391                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2392                              sl->mb_y, ER_MB_END);\n2393                 if (sl->mb_x >= lf_x_start)\n2394                     loop_filter(h, sl, lf_x_start, sl->mb_x + 1);\n2395                 goto finish;\n2396             }\n2397             if (ret < 0 || sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2398                 av_log(h->avctx, AV_LOG_ERROR,\n2399                        \"error while decoding MB %d %d, bytestream %td\\n\",\n2400                        sl->mb_x, sl->mb_y,\n2401                        sl->cabac.bytestream_end - sl->cabac.bytestream);\n2402                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2403                              sl->mb_y, ER_MB_ERROR);\n2404                 return AVERROR_INVALIDDATA;\n2405             }\n2406\n2407             if (++sl->mb_x >= h->mb_width) {\n2408                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2409                 sl->mb_x = lf_x_start = 0;\n2410                 decode_finish_row(h, sl);\n2411                 ++sl->mb_y;\n2412                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2413                     ++sl->mb_y;\n2414                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2415                         predict_field_decoding_flag(h, sl);\n2416                 }\n2417             }\n2418\n2419             if (eos || sl->mb_y >= h->mb_height) {\n2420                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2421                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2422                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2423                              sl->mb_y, ER_MB_END);\n2424                 if (sl->mb_x > lf_x_start)\n2425                     loop_filter(h, sl, lf_x_start, sl->mb_x);\n2426                 goto finish;\n2427             }\n2428         }\n2429     } else {\n2430         for (;;) {\n2431             int ret;\n2432\n2433             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2434                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2435                        sl->next_slice_idx);\n2436                 return AVERROR_INVALIDDATA;\n2437             }\n2438\n2439             ret = ff_h264_decode_mb_cavlc(h, sl);\n2440\n2441             if (ret >= 0)\n2442                 ff_h264_hl_decode_mb(h, sl);\n2443\n2444             // FIXME optimal? or let mb_decode decode 16x32 ?\n2445             if (ret >= 0 && FRAME_MBAFF(h)) {\n2446                 sl->mb_y++;\n2447                 ret = ff_h264_decode_mb_cavlc(h, sl);\n2448\n2449                 if (ret >= 0)\n2450                     ff_h264_hl_decode_mb(h, sl);\n2451                 sl->mb_y--;\n2452             }\n2453\n2454             if (ret < 0) {\n2455                 av_log(h->avctx, AV_LOG_ERROR,\n2456                        \"error while decoding MB %d %d\\n\", sl->mb_x, sl->mb_y);\n2457                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2458                              sl->mb_y, ER_MB_ERROR);\n2459                 return ret;\n2460             }\n2461\n2462             if (++sl->mb_x >= h->mb_width) {\n2463                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2464                 sl->mb_x = lf_x_start = 0;\n2465                 decode_finish_row(h, sl);\n2466                 ++sl->mb_y;\n2467                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2468                     ++sl->mb_y;\n2469                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2470                         predict_field_decoding_flag(h, sl);\n2471                 }\n2472                 if (sl->mb_y >= h->mb_height) {\n2473                     ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2474                             get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2475\n2476                     if (get_bits_left(&sl->gb) == 0) {\n2477                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2478                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2479\n2480                         goto finish;\n2481                     } else {\n2482                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2483                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2484\n2485                         return AVERROR_INVALIDDATA;\n2486                     }\n2487                 }\n2488             }\n2489\n2490             if (get_bits_left(&sl->gb) <= 0 && sl->mb_skip_run <= 0) {\n2491                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2492                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2493\n2494                 if (get_bits_left(&sl->gb) == 0) {\n2495                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2496                                  sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2497                     if (sl->mb_x > lf_x_start)\n2498                         loop_filter(h, sl, lf_x_start, sl->mb_x);\n2499\n2500                     goto finish;\n2501                 } else {\n2502                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2503                                  sl->mb_y, ER_MB_ERROR);\n2504\n2505                     return AVERROR_INVALIDDATA;\n2506                 }\n2507             }\n2508         }\n2509     }\n2510\n2511 finish:\n2512     sl->deblocking_filter = orig_deblock;\n2513     return 0;\n2514 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2521 int ff_h264_execute_decode_slices(H264Context *h)\n2522 {\n2523     AVCodecContext *const avctx = h->avctx;\n2524     H264SliceContext *sl;\n2525     int context_count = h->nb_slice_ctx_queued;\n2526     int ret = 0;\n2527     int i, j;\n2528\n2529     if (h->avctx->hwaccel || context_count < 1)\n2530         return 0;\n2531     if (context_count == 1) {\n2532\n2533         h->slice_ctx[0].next_slice_idx = h->mb_width * h->mb_height;\n2534         h->postpone_filter = 0;\n2535\n2536         ret = decode_slice(avctx, &h->slice_ctx[0]);\n2537         h->mb_y = h->slice_ctx[0].mb_y;\n2538         if (ret < 0)\n2539             goto finish;\n2540     } else {\n2541         for (i = 0; i < context_count; i++) {\n2542             int next_slice_idx = h->mb_width * h->mb_height;\n2543             int slice_idx;\n2544\n2545             sl                 = &h->slice_ctx[i];\n2546             sl->er.error_count = 0;\n2547\n2548             /* make sure none of those slices overlap */\n2549             slice_idx = sl->mb_y * h->mb_width + sl->mb_x;\n2550             for (j = 0; j < context_count; j++) {\n2551                 H264SliceContext *sl2 = &h->slice_ctx[j];\n2552                 int        slice_idx2 = sl2->mb_y * h->mb_width + sl2->mb_x;\n2553\n2554                 if (i == j || slice_idx2 < slice_idx)\n2555                     continue;\n2556                 next_slice_idx = FFMIN(next_slice_idx, slice_idx2);\n2557             }\n2558             sl->next_slice_idx = next_slice_idx;\n2559         }\n2560\n2561         avctx->execute(avctx, decode_slice, h->slice_ctx,\n2562                        NULL, context_count, sizeof(h->slice_ctx[0]));\n2563\n2564         /* pull back stuff from slices to master context */\n2565         sl                   = &h->slice_ctx[context_count - 1];\n2566         h->mb_y              = sl->mb_y;\n2567         for (i = 1; i < context_count; i++)\n2568             h->slice_ctx[0].er.error_count += h->slice_ctx[i].er.error_count;\n2569\n2570         if (h->postpone_filter) {\n2571             h->postpone_filter = 0;\n2572\n2573             for (i = 0; i < context_count; i++) {\n2574                 int y_end, x_end;\n2575\n2576                 sl = &h->slice_ctx[i];\n2577                 y_end = FFMIN(sl->mb_y + 1, h->mb_height);\n2578                 x_end = (sl->mb_y >= h->mb_height) ? h->mb_width : sl->mb_x;\n2579\n2580                 for (j = sl->resync_mb_y; j < y_end; j += 1 + FIELD_OR_MBAFF_PICTURE(h)) {\n2581                     sl->mb_y = j;\n2582                     loop_filter(h, sl, j > sl->resync_mb_y ? 0 : sl->resync_mb_x,\n2583                                 j == y_end - 1 ? x_end : h->mb_width);\n2584                 }\n2585             }\n2586         }\n2587     }\n2588\n2589 finish:\n2590     h->nb_slice_ctx_queued = 0;\n2591     return ret;\n2592 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1606 int ff_rv34_decode_frame(AVCodecContext *avctx,\n1607                             void *data, int *got_picture_ptr,\n1608                             AVPacket *avpkt)\n1609 {\n1610     const uint8_t *buf = avpkt->data;\n1611     int buf_size = avpkt->size;\n1612     RV34DecContext *r = avctx->priv_data;\n1613     MpegEncContext *s = &r->s;\n1614     AVFrame *pict = data;\n1615     SliceInfo si;\n1616     int i, ret;\n1617     int slice_count;\n1618     const uint8_t *slices_hdr = NULL;\n1619     int last = 0;\n1620\n1621     /* no supplementary picture */\n1622     if (buf_size == 0) {\n1623         /* special case for last picture */\n1624         if (s->low_delay==0 && s->next_picture_ptr) {\n1625             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n1626                 return ret;\n1627             s->next_picture_ptr = NULL;\n1628\n1629             *got_picture_ptr = 1;\n1630         }\n1631         return 0;\n1632     }\n1633\n1634     if(!avctx->slice_count){\n1635         slice_count = (*buf++) + 1;\n1636         slices_hdr = buf + 4;\n1637         buf += 8 * slice_count;\n1638         buf_size -= 1 + 8 * slice_count;\n1639     }else\n1640         slice_count = avctx->slice_count;\n1641\n1642     //parse first slice header to check whether this frame can be decoded\n1643     if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n1644        get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n1645         av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1646         return AVERROR_INVALIDDATA;\n1647     }\n1648     init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n1649     if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n1650         av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n1651         return AVERROR_INVALIDDATA;\n1652     }\n1653     if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&\n1654         si.type == AV_PICTURE_TYPE_B) {\n1655         av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n1656                \"reference data.\\n\");\n1657         return AVERROR_INVALIDDATA;\n1658     }\n1659     if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n1660        || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n1661        ||  avctx->skip_frame >= AVDISCARD_ALL)\n1662         return avpkt->size;\n1663\n1664     /* first slice */\n1665     if (si.start == 0) {\n1666         if (s->mb_num_left > 0) {\n1667             av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n1668                    s->mb_num_left);\n1669             ff_er_frame_end(&s->er);\n1670             ff_mpv_frame_end(s);\n1671         }\n1672\n1673         if (s->width != si.width || s->height != si.height) {\n1674             int err;\n1675\n1676             av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n1677                    si.width, si.height);\n1678\n1679             s->width  = si.width;\n1680             s->height = si.height;\n1681\n1682             err = ff_set_dimensions(s->avctx, s->width, s->height);\n1683             if (err < 0)\n1684                 return err;\n1685\n1686             if ((err = ff_mpv_common_frame_size_change(s)) < 0)\n1687                 return err;\n1688             if ((err = rv34_decoder_realloc(r)) < 0)\n1689                 return err;\n1690         }\n1691         s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n1692         if (ff_mpv_frame_start(s, s->avctx) < 0)\n1693             return -1;\n1694         ff_mpeg_er_frame_start(s);\n1695         if (!r->tmp_b_block_base) {\n1696             int i;\n1697\n1698             r->tmp_b_block_base = av_malloc(s->linesize * 48);\n1699             for (i = 0; i < 2; i++)\n1700                 r->tmp_b_block_y[i] = r->tmp_b_block_base\n1701                                       + i * 16 * s->linesize;\n1702             for (i = 0; i < 4; i++)\n1703                 r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n1704                                        + (i >> 1) * 8 * s->uvlinesize\n1705                                        + (i &  1) * 16;\n1706         }\n1707         r->cur_pts = si.pts;\n1708         if (s->pict_type != AV_PICTURE_TYPE_B) {\n1709             r->last_pts = r->next_pts;\n1710             r->next_pts = r->cur_pts;\n1711         } else {\n1712             int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n1713             int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n1714             int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n1715\n1716             if(!refdist){\n1717                 r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n1718                 r->scaled_weight = 0;\n1719             }else{\n1720                 r->mv_weight1 = (dist0 << 14) / refdist;\n1721                 r->mv_weight2 = (dist1 << 14) / refdist;\n1722                 if((r->mv_weight1|r->mv_weight2) & 511){\n1723                     r->weight1 = r->mv_weight1;\n1724                     r->weight2 = r->mv_weight2;\n1725                     r->scaled_weight = 0;\n1726                 }else{\n1727                     r->weight1 = r->mv_weight1 >> 9;\n1728                     r->weight2 = r->mv_weight2 >> 9;\n1729                     r->scaled_weight = 1;\n1730                 }\n1731             }\n1732         }\n1733         s->mb_x = s->mb_y = 0;\n1734         ff_thread_finish_setup(s->avctx);\n1735     } else if (HAVE_THREADS &&\n1736                (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1737         av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n1738                \"multithreading mode (start MB is %d).\\n\", si.start);\n1739         return AVERROR_INVALIDDATA;\n1740     }\n1741\n1742     for(i = 0; i < slice_count; i++){\n1743         int offset = get_slice_offset(avctx, slices_hdr, i);\n1744         int size;\n1745         if(i+1 == slice_count)\n1746             size = buf_size - offset;\n1747         else\n1748             size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n1749\n1750         if(offset < 0 || offset > buf_size){\n1751             av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1752             break;\n1753         }\n1754\n1755         r->si.end = s->mb_width * s->mb_height;\n1756         s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n1757\n1758         if(i+1 < slice_count){\n1759             if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n1760                 get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n1761                 av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1762                 break;\n1763             }\n1764             init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n1765             if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n1766                 if(i+2 < slice_count)\n1767                     size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n1768                 else\n1769                     size = buf_size - offset;\n1770             }else\n1771                 r->si.end = si.start;\n1772         }\n1773         if (size < 0 || size > buf_size - offset) {\n1774             av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n1775             break;\n1776         }\n1777         last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n1778         if(last)\n1779             break;\n1780     }\n1781\n1782     if (s->current_picture_ptr) {\n1783         if (last) {\n1784             if(r->loop_filter)\n1785                 r->loop_filter(r, s->mb_height - 1);\n1786\n1787             ret = finish_frame(avctx, pict);\n1788             if (ret < 0)\n1789                 return ret;\n1790             *got_picture_ptr = ret;\n1791         } else if (HAVE_THREADS &&\n1792                    (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1793             av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n1794             /* always mark the current frame as finished, frame-mt supports\n1795              * only complete frames */\n1796             ff_er_frame_end(&s->er);\n1797             ff_mpv_frame_end(s);\n1798             s->mb_num_left = 0;\n1799             ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n1800             return AVERROR_INVALIDDATA;\n1801         }\n1802     }\n1803\n1804     return avpkt->size;\n1805 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1394 static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int buf_size)\n1395 {\n1396     MpegEncContext *s = &r->s;\n1397     GetBitContext *gb = &s->gb;\n1398     int mb_pos, slice_type;\n1399     int res;\n1400\n1401     init_get_bits(&r->s.gb, buf, buf_size*8);\n1402     res = r->parse_slice_header(r, gb, &r->si);\n1403     if(res < 0){\n1404         av_log(s->avctx, AV_LOG_ERROR, \"Incorrect or unknown slice header\\n\");\n1405         return -1;\n1406     }\n1407\n1408     slice_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n1409     if (slice_type != s->pict_type) {\n1410         av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n1411         return AVERROR_INVALIDDATA;\n1412     }\n1413\n1414     r->si.end = end;\n1415     s->qscale = r->si.quant;\n1416     s->mb_num_left = r->si.end - r->si.start;\n1417     r->s.mb_skip_run = 0;\n1418\n1419     mb_pos = s->mb_x + s->mb_y * s->mb_width;\n1420     if(r->si.start != mb_pos){\n1421         av_log(s->avctx, AV_LOG_ERROR, \"Slice indicates MB offset %d, got %d\\n\", r->si.start, mb_pos);\n1422         s->mb_x = r->si.start % s->mb_width;\n1423         s->mb_y = r->si.start / s->mb_width;\n1424     }\n1425     memset(r->intra_types_hist, -1, r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist));\n1426     s->first_slice_line = 1;\n1427     s->resync_mb_x = s->mb_x;\n1428     s->resync_mb_y = s->mb_y;\n1429\n1430     ff_init_block_index(s);\n1431     while(!check_slice_end(r, s)) {\n1432         ff_update_block_index(s);\n1433\n1434         if(r->si.type)\n1435             res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1436         else\n1437             res = rv34_decode_intra_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1438         if(res < 0){\n1439             ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_ERROR);\n1440             return -1;\n1441         }\n1442         if (++s->mb_x == s->mb_width) {\n1443             s->mb_x = 0;\n1444             s->mb_y++;\n1445             ff_init_block_index(s);\n1446\n1447             memmove(r->intra_types_hist, r->intra_types, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1448             memset(r->intra_types, -1, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1449\n1450             if(r->loop_filter && s->mb_y >= 2)\n1451                 r->loop_filter(r, s->mb_y - 2);\n1452\n1453             if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n1454                 ff_thread_report_progress(&s->current_picture_ptr->tf,\n1455                                           s->mb_y - 2, 0);\n1456\n1457         }\n1458         if(s->mb_x == s->resync_mb_x)\n1459             s->first_slice_line=0;\n1460         s->mb_num_left--;\n1461     }\n1462     ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n1463\n1464     return s->mb_y == s->mb_height;\n1465 }"
                    }
                ]
            }
        ],
        "sink": "p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;",
        "final_sink": "p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;"
    },
    {
        "prt": "q4",
        "function_call": [
            "static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n                                         int E, int I, int H,\n                                         ptrdiff_t stridea, ptrdiff_t strideb,\n                                         int wd)\n{\n    int i;\n\n    for (i = 0; i < 8; i++, dst += stridea) {\n        int p7, p6, p5, p4;\n        int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n        int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n        int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n        int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n        int q4, q5, q6, q7;\n        int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n                 FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n                 FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n                 FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n        int flat8out, flat8in;\n\n        if (!fm)\n            continue;\n\n        if (wd >= 16) {\n            p7 = dst[strideb * -8];\n            p6 = dst[strideb * -7];\n            p5 = dst[strideb * -6];\n            p4 = dst[strideb * -5];\n            q4 = dst[strideb * +4];\n            q5 = dst[strideb * +5];\n            q6 = dst[strideb * +6];\n            q7 = dst[strideb * +7];\n\n            flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n                       FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n                       FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n                       FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n        }\n\n        if (wd >= 8)\n            flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n                      FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n                      FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n\n        if (wd >= 16 && flat8out && flat8in) {\n            dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n                                 p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n            dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n                                 p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n            dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n                                 p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n            dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n                                 p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n            dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n                                 p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n            dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n                                 p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n            dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n                                 q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n            dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n                                 q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n            dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n                                 q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n            dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n                                 q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n                                 q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n                                 q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n                                 q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n            dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n                                 q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n        } else if (wd >= 8 && flat8in) {\n            dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n            dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n            dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n            dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n            dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n            dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n        } else {\n            int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n\n            if (hev) {\n                int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n            } else {\n                int f = av_clip_int8(3 * (q0 - p0));\n                int f1 = FFMIN(f + 4, 127) >> 3;\n                int f2 = FFMIN(f + 3, 127) >> 3;\n\n                dst[strideb * -1] = av_clip_uint8(p0 + f2);\n                dst[strideb * +0] = av_clip_uint8(q0 - f1);\n\n                f = (f1 + 1) >> 1;\n                dst[strideb * -2] = av_clip_uint8(p1 + f);\n                dst[strideb * +1] = av_clip_uint8(q1 - f);\n            }\n        }\n    }\n}"
        ],
        "source": [
            "        int q4, q5, q6, q7;"
        ],
        "index": 7,
        "location": {
            "file_path": "libavcodec/vp9dsp.c",
            "region": {
                "startLine": 1630,
                "startColumn": 54,
                "endColumn": 56
            },
            "context": {
                "startLine": 1628,
                "endLine": 1632,
                "snippet": {
                    "text": "                                 q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1606 int ff_rv34_decode_frame(AVCodecContext *avctx,\n1607                             void *data, int *got_picture_ptr,\n1608                             AVPacket *avpkt)\n1609 {\n1610     const uint8_t *buf = avpkt->data;\n1611     int buf_size = avpkt->size;\n1612     RV34DecContext *r = avctx->priv_data;\n1613     MpegEncContext *s = &r->s;\n1614     AVFrame *pict = data;\n1615     SliceInfo si;\n1616     int i, ret;\n1617     int slice_count;\n1618     const uint8_t *slices_hdr = NULL;\n1619     int last = 0;\n1620\n1621     /* no supplementary picture */\n1622     if (buf_size == 0) {\n1623         /* special case for last picture */\n1624         if (s->low_delay==0 && s->next_picture_ptr) {\n1625             if ((ret = av_frame_ref(pict, s->next_picture_ptr->f)) < 0)\n1626                 return ret;\n1627             s->next_picture_ptr = NULL;\n1628\n1629             *got_picture_ptr = 1;\n1630         }\n1631         return 0;\n1632     }\n1633\n1634     if(!avctx->slice_count){\n1635         slice_count = (*buf++) + 1;\n1636         slices_hdr = buf + 4;\n1637         buf += 8 * slice_count;\n1638         buf_size -= 1 + 8 * slice_count;\n1639     }else\n1640         slice_count = avctx->slice_count;\n1641\n1642     //parse first slice header to check whether this frame can be decoded\n1643     if(get_slice_offset(avctx, slices_hdr, 0) < 0 ||\n1644        get_slice_offset(avctx, slices_hdr, 0) > buf_size){\n1645         av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1646         return AVERROR_INVALIDDATA;\n1647     }\n1648     init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, 0), (buf_size-get_slice_offset(avctx, slices_hdr, 0))*8);\n1649     if(r->parse_slice_header(r, &r->s.gb, &si) < 0 || si.start){\n1650         av_log(avctx, AV_LOG_ERROR, \"First slice header is incorrect\\n\");\n1651         return AVERROR_INVALIDDATA;\n1652     }\n1653     if ((!s->last_picture_ptr || !s->last_picture_ptr->f->data[0]) &&\n1654         si.type == AV_PICTURE_TYPE_B) {\n1655         av_log(avctx, AV_LOG_ERROR, \"Invalid decoder state: B-frame without \"\n1656                \"reference data.\\n\");\n1657         return AVERROR_INVALIDDATA;\n1658     }\n1659     if(   (avctx->skip_frame >= AVDISCARD_NONREF && si.type==AV_PICTURE_TYPE_B)\n1660        || (avctx->skip_frame >= AVDISCARD_NONKEY && si.type!=AV_PICTURE_TYPE_I)\n1661        ||  avctx->skip_frame >= AVDISCARD_ALL)\n1662         return avpkt->size;\n1663\n1664     /* first slice */\n1665     if (si.start == 0) {\n1666         if (s->mb_num_left > 0) {\n1667             av_log(avctx, AV_LOG_ERROR, \"New frame but still %d MB left.\",\n1668                    s->mb_num_left);\n1669             ff_er_frame_end(&s->er);\n1670             ff_mpv_frame_end(s);\n1671         }\n1672\n1673         if (s->width != si.width || s->height != si.height) {\n1674             int err;\n1675\n1676             av_log(s->avctx, AV_LOG_WARNING, \"Changing dimensions to %dx%d\\n\",\n1677                    si.width, si.height);\n1678\n1679             s->width  = si.width;\n1680             s->height = si.height;\n1681\n1682             err = ff_set_dimensions(s->avctx, s->width, s->height);\n1683             if (err < 0)\n1684                 return err;\n1685\n1686             if ((err = ff_mpv_common_frame_size_change(s)) < 0)\n1687                 return err;\n1688             if ((err = rv34_decoder_realloc(r)) < 0)\n1689                 return err;\n1690         }\n1691         s->pict_type = si.type ? si.type : AV_PICTURE_TYPE_I;\n1692         if (ff_mpv_frame_start(s, s->avctx) < 0)\n1693             return -1;\n1694         ff_mpeg_er_frame_start(s);\n1695         if (!r->tmp_b_block_base) {\n1696             int i;\n1697\n1698             r->tmp_b_block_base = av_malloc(s->linesize * 48);\n1699             for (i = 0; i < 2; i++)\n1700                 r->tmp_b_block_y[i] = r->tmp_b_block_base\n1701                                       + i * 16 * s->linesize;\n1702             for (i = 0; i < 4; i++)\n1703                 r->tmp_b_block_uv[i] = r->tmp_b_block_base + 32 * s->linesize\n1704                                        + (i >> 1) * 8 * s->uvlinesize\n1705                                        + (i &  1) * 16;\n1706         }\n1707         r->cur_pts = si.pts;\n1708         if (s->pict_type != AV_PICTURE_TYPE_B) {\n1709             r->last_pts = r->next_pts;\n1710             r->next_pts = r->cur_pts;\n1711         } else {\n1712             int refdist = GET_PTS_DIFF(r->next_pts, r->last_pts);\n1713             int dist0   = GET_PTS_DIFF(r->cur_pts,  r->last_pts);\n1714             int dist1   = GET_PTS_DIFF(r->next_pts, r->cur_pts);\n1715\n1716             if(!refdist){\n1717                 r->mv_weight1 = r->mv_weight2 = r->weight1 = r->weight2 = 8192;\n1718                 r->scaled_weight = 0;\n1719             }else{\n1720                 r->mv_weight1 = (dist0 << 14) / refdist;\n1721                 r->mv_weight2 = (dist1 << 14) / refdist;\n1722                 if((r->mv_weight1|r->mv_weight2) & 511){\n1723                     r->weight1 = r->mv_weight1;\n1724                     r->weight2 = r->mv_weight2;\n1725                     r->scaled_weight = 0;\n1726                 }else{\n1727                     r->weight1 = r->mv_weight1 >> 9;\n1728                     r->weight2 = r->mv_weight2 >> 9;\n1729                     r->scaled_weight = 1;\n1730                 }\n1731             }\n1732         }\n1733         s->mb_x = s->mb_y = 0;\n1734         ff_thread_finish_setup(s->avctx);\n1735     } else if (HAVE_THREADS &&\n1736                (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1737         av_log(s->avctx, AV_LOG_ERROR, \"Decoder needs full frames in frame \"\n1738                \"multithreading mode (start MB is %d).\\n\", si.start);\n1739         return AVERROR_INVALIDDATA;\n1740     }\n1741\n1742     for(i = 0; i < slice_count; i++){\n1743         int offset = get_slice_offset(avctx, slices_hdr, i);\n1744         int size;\n1745         if(i+1 == slice_count)\n1746             size = buf_size - offset;\n1747         else\n1748             size = get_slice_offset(avctx, slices_hdr, i+1) - offset;\n1749\n1750         if(offset < 0 || offset > buf_size){\n1751             av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1752             break;\n1753         }\n1754\n1755         r->si.end = s->mb_width * s->mb_height;\n1756         s->mb_num_left = r->s.mb_x + r->s.mb_y*r->s.mb_width - r->si.start;\n1757\n1758         if(i+1 < slice_count){\n1759             if (get_slice_offset(avctx, slices_hdr, i+1) < 0 ||\n1760                 get_slice_offset(avctx, slices_hdr, i+1) > buf_size) {\n1761                 av_log(avctx, AV_LOG_ERROR, \"Slice offset is invalid\\n\");\n1762                 break;\n1763             }\n1764             init_get_bits(&s->gb, buf+get_slice_offset(avctx, slices_hdr, i+1), (buf_size-get_slice_offset(avctx, slices_hdr, i+1))*8);\n1765             if(r->parse_slice_header(r, &r->s.gb, &si) < 0){\n1766                 if(i+2 < slice_count)\n1767                     size = get_slice_offset(avctx, slices_hdr, i+2) - offset;\n1768                 else\n1769                     size = buf_size - offset;\n1770             }else\n1771                 r->si.end = si.start;\n1772         }\n1773         if (size < 0 || size > buf_size - offset) {\n1774             av_log(avctx, AV_LOG_ERROR, \"Slice size is invalid\\n\");\n1775             break;\n1776         }\n1777         last = rv34_decode_slice(r, r->si.end, buf + offset, size);\n1778         if(last)\n1779             break;\n1780     }\n1781\n1782     if (s->current_picture_ptr) {\n1783         if (last) {\n1784             if(r->loop_filter)\n1785                 r->loop_filter(r, s->mb_height - 1);\n1786\n1787             ret = finish_frame(avctx, pict);\n1788             if (ret < 0)\n1789                 return ret;\n1790             *got_picture_ptr = ret;\n1791         } else if (HAVE_THREADS &&\n1792                    (s->avctx->active_thread_type & FF_THREAD_FRAME)) {\n1793             av_log(avctx, AV_LOG_INFO, \"marking unfished frame as finished\\n\");\n1794             /* always mark the current frame as finished, frame-mt supports\n1795              * only complete frames */\n1796             ff_er_frame_end(&s->er);\n1797             ff_mpv_frame_end(s);\n1798             s->mb_num_left = 0;\n1799             ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n1800             return AVERROR_INVALIDDATA;\n1801         }\n1802     }\n1803\n1804     return avpkt->size;\n1805 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2521 int ff_h264_execute_decode_slices(H264Context *h)\n2522 {\n2523     AVCodecContext *const avctx = h->avctx;\n2524     H264SliceContext *sl;\n2525     int context_count = h->nb_slice_ctx_queued;\n2526     int ret = 0;\n2527     int i, j;\n2528\n2529     if (h->avctx->hwaccel || context_count < 1)\n2530         return 0;\n2531     if (context_count == 1) {\n2532\n2533         h->slice_ctx[0].next_slice_idx = h->mb_width * h->mb_height;\n2534         h->postpone_filter = 0;\n2535\n2536         ret = decode_slice(avctx, &h->slice_ctx[0]);\n2537         h->mb_y = h->slice_ctx[0].mb_y;\n2538         if (ret < 0)\n2539             goto finish;\n2540     } else {\n2541         for (i = 0; i < context_count; i++) {\n2542             int next_slice_idx = h->mb_width * h->mb_height;\n2543             int slice_idx;\n2544\n2545             sl                 = &h->slice_ctx[i];\n2546             sl->er.error_count = 0;\n2547\n2548             /* make sure none of those slices overlap */\n2549             slice_idx = sl->mb_y * h->mb_width + sl->mb_x;\n2550             for (j = 0; j < context_count; j++) {\n2551                 H264SliceContext *sl2 = &h->slice_ctx[j];\n2552                 int        slice_idx2 = sl2->mb_y * h->mb_width + sl2->mb_x;\n2553\n2554                 if (i == j || slice_idx2 < slice_idx)\n2555                     continue;\n2556                 next_slice_idx = FFMIN(next_slice_idx, slice_idx2);\n2557             }\n2558             sl->next_slice_idx = next_slice_idx;\n2559         }\n2560\n2561         avctx->execute(avctx, decode_slice, h->slice_ctx,\n2562                        NULL, context_count, sizeof(h->slice_ctx[0]));\n2563\n2564         /* pull back stuff from slices to master context */\n2565         sl                   = &h->slice_ctx[context_count - 1];\n2566         h->mb_y              = sl->mb_y;\n2567         for (i = 1; i < context_count; i++)\n2568             h->slice_ctx[0].er.error_count += h->slice_ctx[i].er.error_count;\n2569\n2570         if (h->postpone_filter) {\n2571             h->postpone_filter = 0;\n2572\n2573             for (i = 0; i < context_count; i++) {\n2574                 int y_end, x_end;\n2575\n2576                 sl = &h->slice_ctx[i];\n2577                 y_end = FFMIN(sl->mb_y + 1, h->mb_height);\n2578                 x_end = (sl->mb_y >= h->mb_height) ? h->mb_width : sl->mb_x;\n2579\n2580                 for (j = sl->resync_mb_y; j < y_end; j += 1 + FIELD_OR_MBAFF_PICTURE(h)) {\n2581                     sl->mb_y = j;\n2582                     loop_filter(h, sl, j > sl->resync_mb_y ? 0 : sl->resync_mb_x,\n2583                                 j == y_end - 1 ? x_end : h->mb_width);\n2584                 }\n2585             }\n2586         }\n2587     }\n2588\n2589 finish:\n2590     h->nb_slice_ctx_queued = 0;\n2591     return ret;\n2592 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/rv34.c",
                        "function_body": "1394 static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int buf_size)\n1395 {\n1396     MpegEncContext *s = &r->s;\n1397     GetBitContext *gb = &s->gb;\n1398     int mb_pos, slice_type;\n1399     int res;\n1400\n1401     init_get_bits(&r->s.gb, buf, buf_size*8);\n1402     res = r->parse_slice_header(r, gb, &r->si);\n1403     if(res < 0){\n1404         av_log(s->avctx, AV_LOG_ERROR, \"Incorrect or unknown slice header\\n\");\n1405         return -1;\n1406     }\n1407\n1408     slice_type = r->si.type ? r->si.type : AV_PICTURE_TYPE_I;\n1409     if (slice_type != s->pict_type) {\n1410         av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n1411         return AVERROR_INVALIDDATA;\n1412     }\n1413\n1414     r->si.end = end;\n1415     s->qscale = r->si.quant;\n1416     s->mb_num_left = r->si.end - r->si.start;\n1417     r->s.mb_skip_run = 0;\n1418\n1419     mb_pos = s->mb_x + s->mb_y * s->mb_width;\n1420     if(r->si.start != mb_pos){\n1421         av_log(s->avctx, AV_LOG_ERROR, \"Slice indicates MB offset %d, got %d\\n\", r->si.start, mb_pos);\n1422         s->mb_x = r->si.start % s->mb_width;\n1423         s->mb_y = r->si.start / s->mb_width;\n1424     }\n1425     memset(r->intra_types_hist, -1, r->intra_types_stride * 4 * 2 * sizeof(*r->intra_types_hist));\n1426     s->first_slice_line = 1;\n1427     s->resync_mb_x = s->mb_x;\n1428     s->resync_mb_y = s->mb_y;\n1429\n1430     ff_init_block_index(s);\n1431     while(!check_slice_end(r, s)) {\n1432         ff_update_block_index(s);\n1433\n1434         if(r->si.type)\n1435             res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1436         else\n1437             res = rv34_decode_intra_macroblock(r, r->intra_types + s->mb_x * 4 + 4);\n1438         if(res < 0){\n1439             ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_ERROR);\n1440             return -1;\n1441         }\n1442         if (++s->mb_x == s->mb_width) {\n1443             s->mb_x = 0;\n1444             s->mb_y++;\n1445             ff_init_block_index(s);\n1446\n1447             memmove(r->intra_types_hist, r->intra_types, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1448             memset(r->intra_types, -1, r->intra_types_stride * 4 * sizeof(*r->intra_types_hist));\n1449\n1450             if(r->loop_filter && s->mb_y >= 2)\n1451                 r->loop_filter(r, s->mb_y - 2);\n1452\n1453             if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME))\n1454                 ff_thread_report_progress(&s->current_picture_ptr->tf,\n1455                                           s->mb_y - 2, 0);\n1456\n1457         }\n1458         if(s->mb_x == s->resync_mb_x)\n1459             s->first_slice_line=0;\n1460         s->mb_num_left--;\n1461     }\n1462     ff_er_add_slice(&s->er, s->resync_mb_x, s->resync_mb_y, s->mb_x-1, s->mb_y, ER_MB_END);\n1463\n1464     return s->mb_y == s->mb_height;\n1465 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/vp9dsp.c",
                        "function_body": "1572 static av_always_inline void loop_filter(uint8_t *dst, ptrdiff_t stride,\n1573                                          int E, int I, int H,\n1574                                          ptrdiff_t stridea, ptrdiff_t strideb,\n1575                                          int wd)\n1576 {\n1577     int i;\n1578\n1579     for (i = 0; i < 8; i++, dst += stridea) {\n1580         int p7, p6, p5, p4;\n1581         int p3 = dst[strideb * -4], p2 = dst[strideb * -3];\n1582         int p1 = dst[strideb * -2], p0 = dst[strideb * -1];\n1583         int q0 = dst[strideb * +0], q1 = dst[strideb * +1];\n1584         int q2 = dst[strideb * +2], q3 = dst[strideb * +3];\n1585         int q4, q5, q6, q7;\n1586         int fm = FFABS(p3 - p2) <= I && FFABS(p2 - p1) <= I &&\n1587                  FFABS(p1 - p0) <= I && FFABS(q1 - q0) <= I &&\n1588                  FFABS(q2 - q1) <= I && FFABS(q3 - q2) <= I &&\n1589                  FFABS(p0 - q0) * 2 + (FFABS(p1 - q1) >> 1) <= E;\n1590         int flat8out, flat8in;\n1591\n1592         if (!fm)\n1593             continue;\n1594\n1595         if (wd >= 16) {\n1596             p7 = dst[strideb * -8];\n1597             p6 = dst[strideb * -7];\n1598             p5 = dst[strideb * -6];\n1599             p4 = dst[strideb * -5];\n1600             q4 = dst[strideb * +4];\n1601             q5 = dst[strideb * +5];\n1602             q6 = dst[strideb * +6];\n1603             q7 = dst[strideb * +7];\n1604\n1605             flat8out = FFABS(p7 - p0) <= 1 && FFABS(p6 - p0) <= 1 &&\n1606                        FFABS(p5 - p0) <= 1 && FFABS(p4 - p0) <= 1 &&\n1607                        FFABS(q4 - q0) <= 1 && FFABS(q5 - q0) <= 1 &&\n1608                        FFABS(q6 - q0) <= 1 && FFABS(q7 - q0) <= 1;\n1609         }\n1610\n1611         if (wd >= 8)\n1612             flat8in = FFABS(p3 - p0) <= 1 && FFABS(p2 - p0) <= 1 &&\n1613                       FFABS(p1 - p0) <= 1 && FFABS(q1 - q0) <= 1 &&\n1614                       FFABS(q2 - q0) <= 1 && FFABS(q3 - q0) <= 1;\n1615\n1616         if (wd >= 16 && flat8out && flat8in) {\n1617             dst[strideb * -7] = (p7 + p7 + p7 + p7 + p7 + p7 + p7 + p6 * 2 +\n1618                                  p5 + p4 + p3 + p2 + p1 + p0 + q0 + 8) >> 4;\n1619             dst[strideb * -6] = (p7 + p7 + p7 + p7 + p7 + p7 + p6 + p5 * 2 +\n1620                                  p4 + p3 + p2 + p1 + p0 + q0 + q1 + 8) >> 4;\n1621             dst[strideb * -5] = (p7 + p7 + p7 + p7 + p7 + p6 + p5 + p4 * 2 +\n1622                                  p3 + p2 + p1 + p0 + q0 + q1 + q2 + 8) >> 4;\n1623             dst[strideb * -4] = (p7 + p7 + p7 + p7 + p6 + p5 + p4 + p3 * 2 +\n1624                                  p2 + p1 + p0 + q0 + q1 + q2 + q3 + 8) >> 4;\n1625             dst[strideb * -3] = (p7 + p7 + p7 + p6 + p5 + p4 + p3 + p2 * 2 +\n1626                                  p1 + p0 + q0 + q1 + q2 + q3 + q4 + 8) >> 4;\n1627             dst[strideb * -2] = (p7 + p7 + p6 + p5 + p4 + p3 + p2 + p1 * 2 +\n1628                                  p0 + q0 + q1 + q2 + q3 + q4 + q5 + 8) >> 4;\n1629             dst[strideb * -1] = (p7 + p6 + p5 + p4 + p3 + p2 + p1 + p0 * 2 +\n1630                                  q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;\n1631             dst[strideb * +0] = (p6 + p5 + p4 + p3 + p2 + p1 + p0 + q0 * 2 +\n1632                                  q1 + q2 + q3 + q4 + q5 + q6 + q7 + 8) >> 4;\n1633             dst[strideb * +1] = (p5 + p4 + p3 + p2 + p1 + p0 + q0 + q1 * 2 +\n1634                                  q2 + q3 + q4 + q5 + q6 + q7 + q7 + 8) >> 4;\n1635             dst[strideb * +2] = (p4 + p3 + p2 + p1 + p0 + q0 + q1 + q2 * 2 +\n1636                                  q3 + q4 + q5 + q6 + q7 + q7 + q7 + 8) >> 4;\n1637             dst[strideb * +3] = (p3 + p2 + p1 + p0 + q0 + q1 + q2 + q3 * 2 +\n1638                                  q4 + q5 + q6 + q7 + q7 + q7 + q7 + 8) >> 4;\n1639             dst[strideb * +4] = (p2 + p1 + p0 + q0 + q1 + q2 + q3 + q4 * 2 +\n1640                                  q5 + q6 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1641             dst[strideb * +5] = (p1 + p0 + q0 + q1 + q2 + q3 + q4 + q5 * 2 +\n1642                                  q6 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1643             dst[strideb * +6] = (p0 + q0 + q1 + q2 + q3 + q4 + q5 + q6 * 2 +\n1644                                  q7 + q7 + q7 + q7 + q7 + q7 + q7 + 8) >> 4;\n1645         } else if (wd >= 8 && flat8in) {\n1646             dst[strideb * -3] = (p3 + p3 + p3 + 2 * p2 + p1 + p0 + q0 + 4) >> 3;\n1647             dst[strideb * -2] = (p3 + p3 + p2 + 2 * p1 + p0 + q0 + q1 + 4) >> 3;\n1648             dst[strideb * -1] = (p3 + p2 + p1 + 2 * p0 + q0 + q1 + q2 + 4) >> 3;\n1649             dst[strideb * +0] = (p2 + p1 + p0 + 2 * q0 + q1 + q2 + q3 + 4) >> 3;\n1650             dst[strideb * +1] = (p1 + p0 + q0 + 2 * q1 + q2 + q3 + q3 + 4) >> 3;\n1651             dst[strideb * +2] = (p0 + q0 + q1 + 2 * q2 + q3 + q3 + q3 + 4) >> 3;\n1652         } else {\n1653             int hev = FFABS(p1 - p0) > H || FFABS(q1 - q0) > H;\n1654\n1655             if (hev) {\n1656                 int f = av_clip_int8(3 * (q0 - p0) + av_clip_int8(p1 - q1));\n1657                 int f1 = FFMIN(f + 4, 127) >> 3;\n1658                 int f2 = FFMIN(f + 3, 127) >> 3;\n1659\n1660                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1661                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1662             } else {\n1663                 int f = av_clip_int8(3 * (q0 - p0));\n1664                 int f1 = FFMIN(f + 4, 127) >> 3;\n1665                 int f2 = FFMIN(f + 3, 127) >> 3;\n1666\n1667                 dst[strideb * -1] = av_clip_uint8(p0 + f2);\n1668                 dst[strideb * +0] = av_clip_uint8(q0 - f1);\n1669\n1670                 f = (f1 + 1) >> 1;\n1671                 dst[strideb * -2] = av_clip_uint8(p1 + f);\n1672                 dst[strideb * +1] = av_clip_uint8(q1 - f);\n1673             }\n1674         }\n1675     }\n1676 }"
                    },
                    {
                        "file_path": "/libavcodec/h264_slice.c",
                        "function_body": "2327 static int decode_slice(struct AVCodecContext *avctx, void *arg)\n2328 {\n2329     H264SliceContext *sl = arg;\n2330     const H264Context *h = sl->h264;\n2331     int lf_x_start = sl->mb_x;\n2332     int orig_deblock = sl->deblocking_filter;\n2333     int ret;\n2334\n2335     sl->linesize   = h->cur_pic_ptr->f->linesize[0];\n2336     sl->uvlinesize = h->cur_pic_ptr->f->linesize[1];\n2337\n2338     ret = alloc_scratch_buffers(sl, sl->linesize);\n2339     if (ret < 0)\n2340         return ret;\n2341\n2342     sl->mb_skip_run = -1;\n2343\n2344     if (h->postpone_filter)\n2345         sl->deblocking_filter = 0;\n2346\n2347     sl->is_complex = FRAME_MBAFF(h) || h->picture_structure != PICT_FRAME ||\n2348                      (CONFIG_GRAY && (h->flags & AV_CODEC_FLAG_GRAY));\n2349\n2350     if (h->ps.pps->cabac) {\n2351         /* realign */\n2352         align_get_bits(&sl->gb);\n2353\n2354         /* init cabac */\n2355         ff_init_cabac_decoder(&sl->cabac,\n2356                               sl->gb.buffer + get_bits_count(&sl->gb) / 8,\n2357                               (get_bits_left(&sl->gb) + 7) / 8);\n2358\n2359         ff_h264_init_cabac_states(h, sl);\n2360\n2361         for (;;) {\n2362             // START_TIMER\n2363             int ret, eos;\n2364\n2365             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2366                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2367                        sl->next_slice_idx);\n2368                 return AVERROR_INVALIDDATA;\n2369             }\n2370\n2371             ret = ff_h264_decode_mb_cabac(h, sl);\n2372             // STOP_TIMER(\"decode_mb_cabac\")\n2373\n2374             if (ret >= 0)\n2375                 ff_h264_hl_decode_mb(h, sl);\n2376\n2377             // FIXME optimal? or let mb_decode decode 16x32 ?\n2378             if (ret >= 0 && FRAME_MBAFF(h)) {\n2379                 sl->mb_y++;\n2380\n2381                 ret = ff_h264_decode_mb_cabac(h, sl);\n2382\n2383                 if (ret >= 0)\n2384                     ff_h264_hl_decode_mb(h, sl);\n2385                 sl->mb_y--;\n2386             }\n2387             eos = get_cabac_terminate(&sl->cabac);\n2388\n2389             if ((h->workaround_bugs & FF_BUG_TRUNCATED) &&\n2390                 sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2391                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2392                              sl->mb_y, ER_MB_END);\n2393                 if (sl->mb_x >= lf_x_start)\n2394                     loop_filter(h, sl, lf_x_start, sl->mb_x + 1);\n2395                 goto finish;\n2396             }\n2397             if (ret < 0 || sl->cabac.bytestream > sl->cabac.bytestream_end + 2) {\n2398                 av_log(h->avctx, AV_LOG_ERROR,\n2399                        \"error while decoding MB %d %d, bytestream %td\\n\",\n2400                        sl->mb_x, sl->mb_y,\n2401                        sl->cabac.bytestream_end - sl->cabac.bytestream);\n2402                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2403                              sl->mb_y, ER_MB_ERROR);\n2404                 return AVERROR_INVALIDDATA;\n2405             }\n2406\n2407             if (++sl->mb_x >= h->mb_width) {\n2408                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2409                 sl->mb_x = lf_x_start = 0;\n2410                 decode_finish_row(h, sl);\n2411                 ++sl->mb_y;\n2412                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2413                     ++sl->mb_y;\n2414                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2415                         predict_field_decoding_flag(h, sl);\n2416                 }\n2417             }\n2418\n2419             if (eos || sl->mb_y >= h->mb_height) {\n2420                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2421                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2422                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x - 1,\n2423                              sl->mb_y, ER_MB_END);\n2424                 if (sl->mb_x > lf_x_start)\n2425                     loop_filter(h, sl, lf_x_start, sl->mb_x);\n2426                 goto finish;\n2427             }\n2428         }\n2429     } else {\n2430         for (;;) {\n2431             int ret;\n2432\n2433             if (sl->mb_x + sl->mb_y * h->mb_width >= sl->next_slice_idx) {\n2434                 av_log(h->avctx, AV_LOG_ERROR, \"Slice overlaps with next at %d\\n\",\n2435                        sl->next_slice_idx);\n2436                 return AVERROR_INVALIDDATA;\n2437             }\n2438\n2439             ret = ff_h264_decode_mb_cavlc(h, sl);\n2440\n2441             if (ret >= 0)\n2442                 ff_h264_hl_decode_mb(h, sl);\n2443\n2444             // FIXME optimal? or let mb_decode decode 16x32 ?\n2445             if (ret >= 0 && FRAME_MBAFF(h)) {\n2446                 sl->mb_y++;\n2447                 ret = ff_h264_decode_mb_cavlc(h, sl);\n2448\n2449                 if (ret >= 0)\n2450                     ff_h264_hl_decode_mb(h, sl);\n2451                 sl->mb_y--;\n2452             }\n2453\n2454             if (ret < 0) {\n2455                 av_log(h->avctx, AV_LOG_ERROR,\n2456                        \"error while decoding MB %d %d\\n\", sl->mb_x, sl->mb_y);\n2457                 er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2458                              sl->mb_y, ER_MB_ERROR);\n2459                 return ret;\n2460             }\n2461\n2462             if (++sl->mb_x >= h->mb_width) {\n2463                 loop_filter(h, sl, lf_x_start, sl->mb_x);\n2464                 sl->mb_x = lf_x_start = 0;\n2465                 decode_finish_row(h, sl);\n2466                 ++sl->mb_y;\n2467                 if (FIELD_OR_MBAFF_PICTURE(h)) {\n2468                     ++sl->mb_y;\n2469                     if (FRAME_MBAFF(h) && sl->mb_y < h->mb_height)\n2470                         predict_field_decoding_flag(h, sl);\n2471                 }\n2472                 if (sl->mb_y >= h->mb_height) {\n2473                     ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2474                             get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2475\n2476                     if (get_bits_left(&sl->gb) == 0) {\n2477                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2478                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2479\n2480                         goto finish;\n2481                     } else {\n2482                         er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2483                                      sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2484\n2485                         return AVERROR_INVALIDDATA;\n2486                     }\n2487                 }\n2488             }\n2489\n2490             if (get_bits_left(&sl->gb) <= 0 && sl->mb_skip_run <= 0) {\n2491                 ff_tlog(h->avctx, \"slice end %d %d\\n\",\n2492                         get_bits_count(&sl->gb), sl->gb.size_in_bits);\n2493\n2494                 if (get_bits_left(&sl->gb) == 0) {\n2495                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y,\n2496                                  sl->mb_x - 1, sl->mb_y, ER_MB_END);\n2497                     if (sl->mb_x > lf_x_start)\n2498                         loop_filter(h, sl, lf_x_start, sl->mb_x);\n2499\n2500                     goto finish;\n2501                 } else {\n2502                     er_add_slice(sl, sl->resync_mb_x, sl->resync_mb_y, sl->mb_x,\n2503                                  sl->mb_y, ER_MB_ERROR);\n2504\n2505                     return AVERROR_INVALIDDATA;\n2506                 }\n2507             }\n2508         }\n2509     }\n2510\n2511 finish:\n2512     sl->deblocking_filter = orig_deblock;\n2513     return 0;\n2514 }"
                    }
                ]
            }
        ],
        "sink": "q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;",
        "final_sink": "q0 + q1 + q2 + q3 + q4 + q5 + q6 + 8) >> 4;"
    },
    {
        "prt": "remainder",
        "function_call": [
            "static void wiener_denoise(WMAVoiceContext *s, int fcb_type,\n                           float *synth_pf, int size,\n                           const float *lpcs)\n{\n    int remainder, lim, n;\n\n    if (fcb_type != FCB_TYPE_SILENCE) {\n        float *tilted_lpcs = s->tilted_lpcs_pf,\n              *coeffs = s->denoise_coeffs_pf, tilt_mem = 0;\n\n        tilted_lpcs[0]           = 1.0;\n        memcpy(&tilted_lpcs[1], lpcs, sizeof(lpcs[0]) * s->lsps);\n        memset(&tilted_lpcs[s->lsps + 1], 0,\n               sizeof(tilted_lpcs[0]) * (128 - s->lsps - 1));\n        ff_tilt_compensation(&tilt_mem, 0.7 * tilt_factor(lpcs, s->lsps),\n                             tilted_lpcs, s->lsps + 2);\n\n        /* The IRDFT output (127 samples for 7-bit filter) beyond the frame\n         * size is applied to the next frame. All input beyond this is zero,\n         * and thus all output beyond this will go towards zero, hence we can\n         * limit to min(size-1, 127-size) as a performance consideration. */\n        remainder = FFMIN(127 - size, size - 1);\n        calc_input_response(s, tilted_lpcs, fcb_type, coeffs, remainder);\n\n        /* apply coefficients (in frequency spectrum domain), i.e. complex\n         * number multiplication */\n        memset(&synth_pf[size], 0, sizeof(synth_pf[0]) * (128 - size));\n        s->rdft.rdft_calc(&s->rdft, synth_pf);\n        s->rdft.rdft_calc(&s->rdft, coeffs);\n        synth_pf[0] *= coeffs[0];\n        synth_pf[1] *= coeffs[1];\n        for (n = 1; n < 64; n++) {\n            float v1 = synth_pf[n * 2], v2 = synth_pf[n * 2 + 1];\n            synth_pf[n * 2]     = v1 * coeffs[n * 2] - v2 * coeffs[n * 2 + 1];\n            synth_pf[n * 2 + 1] = v2 * coeffs[n * 2] + v1 * coeffs[n * 2 + 1];\n        }\n        s->irdft.rdft_calc(&s->irdft, synth_pf);\n    }\n\n    /* merge filter output with the history of previous runs */\n    if (s->denoise_filter_cache_size) {\n        lim = FFMIN(s->denoise_filter_cache_size, size);\n        for (n = 0; n < lim; n++)\n            synth_pf[n] += s->denoise_filter_cache[n];\n        s->denoise_filter_cache_size -= lim;\n        memmove(s->denoise_filter_cache, &s->denoise_filter_cache[size],\n                sizeof(s->denoise_filter_cache[0]) * s->denoise_filter_cache_size);\n    }\n\n    /* move remainder of filter output into a cache for future runs */\n    if (fcb_type != FCB_TYPE_SILENCE) {\n        lim = FFMIN(remainder, s->denoise_filter_cache_size);\n        for (n = 0; n < lim; n++)\n            s->denoise_filter_cache[n] += synth_pf[size + n];\n        if (lim < remainder) {\n            memcpy(&s->denoise_filter_cache[lim], &synth_pf[size + lim],\n                   sizeof(s->denoise_filter_cache[0]) * (remainder - lim));\n            s->denoise_filter_cache_size = remainder;\n        }\n    }\n}"
        ],
        "source": [
            "    int remainder, lim, n;"
        ],
        "index": 8,
        "location": {
            "file_path": "libavcodec/wmavoice.c",
            "region": {
                "startLine": 743,
                "startColumn": 21,
                "endColumn": 30
            },
            "context": {
                "startLine": 741,
                "endLine": 745,
                "snippet": {
                    "text": "        lim = FFMIN(remainder, s->denoise_filter_cache_size);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/tests/tiny_psnr.c",
                        "function_body": "31 #define FFMIN(a, b) ((a) > (b) ? (b) : (a))"
                    },
                    {
                        "file_path": "/libavutil/common.h",
                        "function_body": "66 #define FFMIN(a,b) ((a) > (b) ? (b) : (a))"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "692 static void wiener_denoise(WMAVoiceContext *s, int fcb_type,\n693                            float *synth_pf, int size,\n694                            const float *lpcs)\n695 {\n696     int remainder, lim, n;\n697\n698     if (fcb_type != FCB_TYPE_SILENCE) {\n699         float *tilted_lpcs = s->tilted_lpcs_pf,\n700               *coeffs = s->denoise_coeffs_pf, tilt_mem = 0;\n701\n702         tilted_lpcs[0]           = 1.0;\n703         memcpy(&tilted_lpcs[1], lpcs, sizeof(lpcs[0]) * s->lsps);\n704         memset(&tilted_lpcs[s->lsps + 1], 0,\n705                sizeof(tilted_lpcs[0]) * (128 - s->lsps - 1));\n706         ff_tilt_compensation(&tilt_mem, 0.7 * tilt_factor(lpcs, s->lsps),\n707                              tilted_lpcs, s->lsps + 2);\n708\n709         /* The IRDFT output (127 samples for 7-bit filter) beyond the frame\n710          * size is applied to the next frame. All input beyond this is zero,\n711          * and thus all output beyond this will go towards zero, hence we can\n712          * limit to min(size-1, 127-size) as a performance consideration. */\n713         remainder = FFMIN(127 - size, size - 1);\n714         calc_input_response(s, tilted_lpcs, fcb_type, coeffs, remainder);\n715\n716         /* apply coefficients (in frequency spectrum domain), i.e. complex\n717          * number multiplication */\n718         memset(&synth_pf[size], 0, sizeof(synth_pf[0]) * (128 - size));\n719         s->rdft.rdft_calc(&s->rdft, synth_pf);\n720         s->rdft.rdft_calc(&s->rdft, coeffs);\n721         synth_pf[0] *= coeffs[0];\n722         synth_pf[1] *= coeffs[1];\n723         for (n = 1; n < 64; n++) {\n724             float v1 = synth_pf[n * 2], v2 = synth_pf[n * 2 + 1];\n725             synth_pf[n * 2]     = v1 * coeffs[n * 2] - v2 * coeffs[n * 2 + 1];\n726             synth_pf[n * 2 + 1] = v2 * coeffs[n * 2] + v1 * coeffs[n * 2 + 1];\n727         }\n728         s->irdft.rdft_calc(&s->irdft, synth_pf);\n729     }\n730\n731     /* merge filter output with the history of previous runs */\n732     if (s->denoise_filter_cache_size) {\n733         lim = FFMIN(s->denoise_filter_cache_size, size);\n734         for (n = 0; n < lim; n++)\n735             synth_pf[n] += s->denoise_filter_cache[n];\n736         s->denoise_filter_cache_size -= lim;\n737         memmove(s->denoise_filter_cache, &s->denoise_filter_cache[size],\n738                 sizeof(s->denoise_filter_cache[0]) * s->denoise_filter_cache_size);\n739     }\n740\n741     /* move remainder of filter output into a cache for future runs */\n742     if (fcb_type != FCB_TYPE_SILENCE) {\n743         lim = FFMIN(remainder, s->denoise_filter_cache_size);\n744         for (n = 0; n < lim; n++)\n745             s->denoise_filter_cache[n] += synth_pf[size + n];\n746         if (lim < remainder) {\n747             memcpy(&s->denoise_filter_cache[lim], &synth_pf[size + lim],\n748                    sizeof(s->denoise_filter_cache[0]) * (remainder - lim));\n749             s->denoise_filter_cache_size = remainder;\n750         }\n751     }\n752 }"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "575 static void calc_input_response(WMAVoiceContext *s, float *lpcs,\n576                                 int fcb_type, float *coeffs, int remainder)\n577 {\n578     float last_coeff, min = 15.0, max = -15.0;\n579     float irange, angle_mul, gain_mul, range, sq;\n580     int n, idx;\n581\n582     /* Create frequency power spectrum of speech input (i.e. RDFT of LPCs) */\n583     s->rdft.rdft_calc(&s->rdft, lpcs);\n584 #define log_range(var, assign) do { \\\n585         float tmp = log10f(assign);  var = tmp; \\\n586         max       = FFMAX(max, tmp); min = FFMIN(min, tmp); \\\n587     } while (0)\n588     log_range(last_coeff,  lpcs[1]         * lpcs[1]);\n589     for (n = 1; n < 64; n++)\n590         log_range(lpcs[n], lpcs[n * 2]     * lpcs[n * 2] +\n591                            lpcs[n * 2 + 1] * lpcs[n * 2 + 1]);\n592     log_range(lpcs[0],     lpcs[0]         * lpcs[0]);\n593 #undef log_range\n594     range    = max - min;\n595     lpcs[64] = last_coeff;\n596\n597     /* Now, use this spectrum to pick out these frequencies with higher\n598      * (relative) power/energy (which we then take to be \"not noise\"),\n599      * and set up a table (still in lpc[]) of (relative) gains per frequency.\n600      * These frequencies will be maintained, while others (\"noise\") will be\n601      * decreased in the filter output. */\n602     irange    = 64.0 / range; // so irange*(max-value) is in the range [0, 63]\n603     gain_mul  = range * (fcb_type == FCB_TYPE_HARDCODED ? (5.0 / 13.0) :\n604                                                           (5.0 / 14.7));\n605     angle_mul = gain_mul * (8.0 * M_LN10 / M_PI);\n606     for (n = 0; n <= 64; n++) {\n607         float pwr;\n608\n609         idx = FFMAX(0, lrint((max - lpcs[n]) * irange) - 1);\n610         pwr = wmavoice_denoise_power_table[s->denoise_strength][idx];\n611         lpcs[n] = angle_mul * pwr;\n612\n613         /* 70.57 =~ 1/log10(1.0331663) */\n614         idx = (pwr * gain_mul - 0.0295) * 70.570526123;\n615         if (idx > 127) { // fall back if index falls outside table range\n616             coeffs[n] = wmavoice_energy_table[127] *\n617                         powf(1.0331663, idx - 127);\n618         } else\n619             coeffs[n] = wmavoice_energy_table[FFMAX(0, idx)];\n620     }\n621\n622     /* calculate the Hilbert transform of the gains, which we do (since this\n623      * is a sine input) by doing a phase shift (in theory, H(sin())=cos()).\n624      * Hilbert_Transform(RDFT(x)) = Laplace_Transform(x), which calculates the\n625      * \"moment\" of the LPCs in this filter. */\n626     s->dct.dct_calc(&s->dct, lpcs);\n627     s->dst.dct_calc(&s->dst, lpcs);\n628\n629     /* Split out the coefficient indexes into phase/magnitude pairs */\n630     idx = 255 + av_clip(lpcs[64],               -255, 255);\n631     coeffs[0]  = coeffs[0]  * s->cos[idx];\n632     idx = 255 + av_clip(lpcs[64] - 2 * lpcs[63], -255, 255);\n633     last_coeff = coeffs[64] * s->cos[idx];\n634     for (n = 63;; n--) {\n635         idx = 255 + av_clip(-lpcs[64] - 2 * lpcs[n - 1], -255, 255);\n636         coeffs[n * 2 + 1] = coeffs[n] * s->sin[idx];\n637         coeffs[n * 2]     = coeffs[n] * s->cos[idx];\n638\n639         if (!--n) break;\n640\n641         idx = 255 + av_clip( lpcs[64] - 2 * lpcs[n - 1], -255, 255);\n642         coeffs[n * 2 + 1] = coeffs[n] * s->sin[idx];\n643         coeffs[n * 2]     = coeffs[n] * s->cos[idx];\n644     }\n645     coeffs[1] = last_coeff;\n646\n647     /* move into real domain */\n648     s->irdft.rdft_calc(&s->irdft, coeffs);\n649\n650     /* tilt correction and normalize scale */\n651     memset(&coeffs[remainder], 0, sizeof(coeffs[0]) * (128 - remainder));\n652     if (s->denoise_tilt_corr) {\n653         float tilt_mem = 0;\n654\n655         coeffs[remainder - 1] = 0;\n656         ff_tilt_compensation(&tilt_mem,\n657                              -1.8 * tilt_factor(coeffs, remainder - 1),\n658                              coeffs, remainder);\n659     }\n660     sq = (1.0 / 64.0) * sqrtf(1 / avpriv_scalarproduct_float_c(coeffs, coeffs,\n661                                                                remainder));\n662     for (n = 0; n < remainder; n++)\n663         coeffs[n] *= sq;\n664 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/tests/tiny_psnr.c",
                        "function_body": "31 #define FFMIN(a, b) ((a) > (b) ? (b) : (a))"
                    },
                    {
                        "file_path": "/libavutil/common.h",
                        "function_body": "66 #define FFMIN(a,b) ((a) > (b) ? (b) : (a))"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "692 static void wiener_denoise(WMAVoiceContext *s, int fcb_type,\n693                            float *synth_pf, int size,\n694                            const float *lpcs)\n695 {\n696     int remainder, lim, n;\n697\n698     if (fcb_type != FCB_TYPE_SILENCE) {\n699         float *tilted_lpcs = s->tilted_lpcs_pf,\n700               *coeffs = s->denoise_coeffs_pf, tilt_mem = 0;\n701\n702         tilted_lpcs[0]           = 1.0;\n703         memcpy(&tilted_lpcs[1], lpcs, sizeof(lpcs[0]) * s->lsps);\n704         memset(&tilted_lpcs[s->lsps + 1], 0,\n705                sizeof(tilted_lpcs[0]) * (128 - s->lsps - 1));\n706         ff_tilt_compensation(&tilt_mem, 0.7 * tilt_factor(lpcs, s->lsps),\n707                              tilted_lpcs, s->lsps + 2);\n708\n709         /* The IRDFT output (127 samples for 7-bit filter) beyond the frame\n710          * size is applied to the next frame. All input beyond this is zero,\n711          * and thus all output beyond this will go towards zero, hence we can\n712          * limit to min(size-1, 127-size) as a performance consideration. */\n713         remainder = FFMIN(127 - size, size - 1);\n714         calc_input_response(s, tilted_lpcs, fcb_type, coeffs, remainder);\n715\n716         /* apply coefficients (in frequency spectrum domain), i.e. complex\n717          * number multiplication */\n718         memset(&synth_pf[size], 0, sizeof(synth_pf[0]) * (128 - size));\n719         s->rdft.rdft_calc(&s->rdft, synth_pf);\n720         s->rdft.rdft_calc(&s->rdft, coeffs);\n721         synth_pf[0] *= coeffs[0];\n722         synth_pf[1] *= coeffs[1];\n723         for (n = 1; n < 64; n++) {\n724             float v1 = synth_pf[n * 2], v2 = synth_pf[n * 2 + 1];\n725             synth_pf[n * 2]     = v1 * coeffs[n * 2] - v2 * coeffs[n * 2 + 1];\n726             synth_pf[n * 2 + 1] = v2 * coeffs[n * 2] + v1 * coeffs[n * 2 + 1];\n727         }\n728         s->irdft.rdft_calc(&s->irdft, synth_pf);\n729     }\n730\n731     /* merge filter output with the history of previous runs */\n732     if (s->denoise_filter_cache_size) {\n733         lim = FFMIN(s->denoise_filter_cache_size, size);\n734         for (n = 0; n < lim; n++)\n735             synth_pf[n] += s->denoise_filter_cache[n];\n736         s->denoise_filter_cache_size -= lim;\n737         memmove(s->denoise_filter_cache, &s->denoise_filter_cache[size],\n738                 sizeof(s->denoise_filter_cache[0]) * s->denoise_filter_cache_size);\n739     }\n740\n741     /* move remainder of filter output into a cache for future runs */\n742     if (fcb_type != FCB_TYPE_SILENCE) {\n743         lim = FFMIN(remainder, s->denoise_filter_cache_size);\n744         for (n = 0; n < lim; n++)\n745             s->denoise_filter_cache[n] += synth_pf[size + n];\n746         if (lim < remainder) {\n747             memcpy(&s->denoise_filter_cache[lim], &synth_pf[size + lim],\n748                    sizeof(s->denoise_filter_cache[0]) * (remainder - lim));\n749             s->denoise_filter_cache_size = remainder;\n750         }\n751     }\n752 }"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "774 static void postfilter(WMAVoiceContext *s, const float *synth,\n775                        float *samples,    int size,\n776                        const float *lpcs, float *zero_exc_pf,\n777                        int fcb_type,      int pitch)\n778 {\n779     float synth_filter_in_buf[MAX_FRAMESIZE / 2],\n780           *synth_pf = &s->synth_filter_out_buf[MAX_LSPS_ALIGN16],\n781           *synth_filter_in = zero_exc_pf;\n782\n783     assert(size <= MAX_FRAMESIZE / 2);\n784\n785     /* generate excitation from input signal */\n786     ff_celp_lp_zero_synthesis_filterf(zero_exc_pf, lpcs, synth, size, s->lsps);\n787\n788     if (fcb_type >= FCB_TYPE_AW_PULSES &&\n789         !kalman_smoothen(s, pitch, zero_exc_pf, synth_filter_in_buf, size))\n790         synth_filter_in = synth_filter_in_buf;\n791\n792     /* re-synthesize speech after smoothening, and keep history */\n793     ff_celp_lp_synthesis_filterf(synth_pf, lpcs,\n794                                  synth_filter_in, size, s->lsps);\n795     memcpy(&synth_pf[-s->lsps], &synth_pf[size - s->lsps],\n796            sizeof(synth_pf[0]) * s->lsps);\n797\n798     wiener_denoise(s, fcb_type, synth_pf, size, lpcs);\n799\n800     adaptive_gain_control(samples, synth_pf, synth, size, 0.99,\n801                           &s->postfilter_agc);\n802\n803     if (s->dc_level > 8) {\n804         /* remove ultra-low frequency DC noise / highpass filter;\n805          * coefficients are identical to those used in SIPR decoding,\n806          * and very closely resemble those used in AMR-NB decoding. */\n807         ff_acelp_apply_order_2_transfer_function(samples, samples,\n808             (const float[2]) { -1.99997,      1.0 },\n809             (const float[2]) { -1.9330735188, 0.93589198496 },\n810             0.93980580475, s->dcf_mem, size);\n811     }\n812 }"
                    }
                ]
            }
        ],
        "sink": "lim = FFMIN(remainder, s->denoise_filter_cache_size);",
        "final_sink": "lim = FFMIN(remainder, s->denoise_filter_cache_size);"
    },
    {
        "prt": "remainder",
        "function_call": [
            "static void wiener_denoise(WMAVoiceContext *s, int fcb_type,\n                           float *synth_pf, int size,\n                           const float *lpcs)\n{\n    int remainder, lim, n;\n\n    if (fcb_type != FCB_TYPE_SILENCE) {\n        float *tilted_lpcs = s->tilted_lpcs_pf,\n              *coeffs = s->denoise_coeffs_pf, tilt_mem = 0;\n\n        tilted_lpcs[0]           = 1.0;\n        memcpy(&tilted_lpcs[1], lpcs, sizeof(lpcs[0]) * s->lsps);\n        memset(&tilted_lpcs[s->lsps + 1], 0,\n               sizeof(tilted_lpcs[0]) * (128 - s->lsps - 1));\n        ff_tilt_compensation(&tilt_mem, 0.7 * tilt_factor(lpcs, s->lsps),\n                             tilted_lpcs, s->lsps + 2);\n\n        /* The IRDFT output (127 samples for 7-bit filter) beyond the frame\n         * size is applied to the next frame. All input beyond this is zero,\n         * and thus all output beyond this will go towards zero, hence we can\n         * limit to min(size-1, 127-size) as a performance consideration. */\n        remainder = FFMIN(127 - size, size - 1);\n        calc_input_response(s, tilted_lpcs, fcb_type, coeffs, remainder);\n\n        /* apply coefficients (in frequency spectrum domain), i.e. complex\n         * number multiplication */\n        memset(&synth_pf[size], 0, sizeof(synth_pf[0]) * (128 - size));\n        s->rdft.rdft_calc(&s->rdft, synth_pf);\n        s->rdft.rdft_calc(&s->rdft, coeffs);\n        synth_pf[0] *= coeffs[0];\n        synth_pf[1] *= coeffs[1];\n        for (n = 1; n < 64; n++) {\n            float v1 = synth_pf[n * 2], v2 = synth_pf[n * 2 + 1];\n            synth_pf[n * 2]     = v1 * coeffs[n * 2] - v2 * coeffs[n * 2 + 1];\n            synth_pf[n * 2 + 1] = v2 * coeffs[n * 2] + v1 * coeffs[n * 2 + 1];\n        }\n        s->irdft.rdft_calc(&s->irdft, synth_pf);\n    }\n\n    /* merge filter output with the history of previous runs */\n    if (s->denoise_filter_cache_size) {\n        lim = FFMIN(s->denoise_filter_cache_size, size);\n        for (n = 0; n < lim; n++)\n            synth_pf[n] += s->denoise_filter_cache[n];\n        s->denoise_filter_cache_size -= lim;\n        memmove(s->denoise_filter_cache, &s->denoise_filter_cache[size],\n                sizeof(s->denoise_filter_cache[0]) * s->denoise_filter_cache_size);\n    }\n\n    /* move remainder of filter output into a cache for future runs */\n    if (fcb_type != FCB_TYPE_SILENCE) {\n        lim = FFMIN(remainder, s->denoise_filter_cache_size);\n        for (n = 0; n < lim; n++)\n            s->denoise_filter_cache[n] += synth_pf[size + n];\n        if (lim < remainder) {\n            memcpy(&s->denoise_filter_cache[lim], &synth_pf[size + lim],\n                   sizeof(s->denoise_filter_cache[0]) * (remainder - lim));\n            s->denoise_filter_cache_size = remainder;\n        }\n    }\n}"
        ],
        "source": [
            "    int remainder, lim, n;"
        ],
        "index": 9,
        "location": {
            "file_path": "libavcodec/wmavoice.c",
            "region": {
                "startLine": 746,
                "startColumn": 19,
                "endColumn": 28
            },
            "context": {
                "startLine": 744,
                "endLine": 748,
                "snippet": {
                    "text": "        if (lim < remainder) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "692 static void wiener_denoise(WMAVoiceContext *s, int fcb_type,\n693                            float *synth_pf, int size,\n694                            const float *lpcs)\n695 {\n696     int remainder, lim, n;\n697\n698     if (fcb_type != FCB_TYPE_SILENCE) {\n699         float *tilted_lpcs = s->tilted_lpcs_pf,\n700               *coeffs = s->denoise_coeffs_pf, tilt_mem = 0;\n701\n702         tilted_lpcs[0]           = 1.0;\n703         memcpy(&tilted_lpcs[1], lpcs, sizeof(lpcs[0]) * s->lsps);\n704         memset(&tilted_lpcs[s->lsps + 1], 0,\n705                sizeof(tilted_lpcs[0]) * (128 - s->lsps - 1));\n706         ff_tilt_compensation(&tilt_mem, 0.7 * tilt_factor(lpcs, s->lsps),\n707                              tilted_lpcs, s->lsps + 2);\n708\n709         /* The IRDFT output (127 samples for 7-bit filter) beyond the frame\n710          * size is applied to the next frame. All input beyond this is zero,\n711          * and thus all output beyond this will go towards zero, hence we can\n712          * limit to min(size-1, 127-size) as a performance consideration. */\n713         remainder = FFMIN(127 - size, size - 1);\n714         calc_input_response(s, tilted_lpcs, fcb_type, coeffs, remainder);\n715\n716         /* apply coefficients (in frequency spectrum domain), i.e. complex\n717          * number multiplication */\n718         memset(&synth_pf[size], 0, sizeof(synth_pf[0]) * (128 - size));\n719         s->rdft.rdft_calc(&s->rdft, synth_pf);\n720         s->rdft.rdft_calc(&s->rdft, coeffs);\n721         synth_pf[0] *= coeffs[0];\n722         synth_pf[1] *= coeffs[1];\n723         for (n = 1; n < 64; n++) {\n724             float v1 = synth_pf[n * 2], v2 = synth_pf[n * 2 + 1];\n725             synth_pf[n * 2]     = v1 * coeffs[n * 2] - v2 * coeffs[n * 2 + 1];\n726             synth_pf[n * 2 + 1] = v2 * coeffs[n * 2] + v1 * coeffs[n * 2 + 1];\n727         }\n728         s->irdft.rdft_calc(&s->irdft, synth_pf);\n729     }\n730\n731     /* merge filter output with the history of previous runs */\n732     if (s->denoise_filter_cache_size) {\n733         lim = FFMIN(s->denoise_filter_cache_size, size);\n734         for (n = 0; n < lim; n++)\n735             synth_pf[n] += s->denoise_filter_cache[n];\n736         s->denoise_filter_cache_size -= lim;\n737         memmove(s->denoise_filter_cache, &s->denoise_filter_cache[size],\n738                 sizeof(s->denoise_filter_cache[0]) * s->denoise_filter_cache_size);\n739     }\n740\n741     /* move remainder of filter output into a cache for future runs */\n742     if (fcb_type != FCB_TYPE_SILENCE) {\n743         lim = FFMIN(remainder, s->denoise_filter_cache_size);\n744         for (n = 0; n < lim; n++)\n745             s->denoise_filter_cache[n] += synth_pf[size + n];\n746         if (lim < remainder) {\n747             memcpy(&s->denoise_filter_cache[lim], &synth_pf[size + lim],\n748                    sizeof(s->denoise_filter_cache[0]) * (remainder - lim));\n749             s->denoise_filter_cache_size = remainder;\n750         }\n751     }\n752 }"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "575 static void calc_input_response(WMAVoiceContext *s, float *lpcs,\n576                                 int fcb_type, float *coeffs, int remainder)\n577 {\n578     float last_coeff, min = 15.0, max = -15.0;\n579     float irange, angle_mul, gain_mul, range, sq;\n580     int n, idx;\n581\n582     /* Create frequency power spectrum of speech input (i.e. RDFT of LPCs) */\n583     s->rdft.rdft_calc(&s->rdft, lpcs);\n584 #define log_range(var, assign) do { \\\n585         float tmp = log10f(assign);  var = tmp; \\\n586         max       = FFMAX(max, tmp); min = FFMIN(min, tmp); \\\n587     } while (0)\n588     log_range(last_coeff,  lpcs[1]         * lpcs[1]);\n589     for (n = 1; n < 64; n++)\n590         log_range(lpcs[n], lpcs[n * 2]     * lpcs[n * 2] +\n591                            lpcs[n * 2 + 1] * lpcs[n * 2 + 1]);\n592     log_range(lpcs[0],     lpcs[0]         * lpcs[0]);\n593 #undef log_range\n594     range    = max - min;\n595     lpcs[64] = last_coeff;\n596\n597     /* Now, use this spectrum to pick out these frequencies with higher\n598      * (relative) power/energy (which we then take to be \"not noise\"),\n599      * and set up a table (still in lpc[]) of (relative) gains per frequency.\n600      * These frequencies will be maintained, while others (\"noise\") will be\n601      * decreased in the filter output. */\n602     irange    = 64.0 / range; // so irange*(max-value) is in the range [0, 63]\n603     gain_mul  = range * (fcb_type == FCB_TYPE_HARDCODED ? (5.0 / 13.0) :\n604                                                           (5.0 / 14.7));\n605     angle_mul = gain_mul * (8.0 * M_LN10 / M_PI);\n606     for (n = 0; n <= 64; n++) {\n607         float pwr;\n608\n609         idx = FFMAX(0, lrint((max - lpcs[n]) * irange) - 1);\n610         pwr = wmavoice_denoise_power_table[s->denoise_strength][idx];\n611         lpcs[n] = angle_mul * pwr;\n612\n613         /* 70.57 =~ 1/log10(1.0331663) */\n614         idx = (pwr * gain_mul - 0.0295) * 70.570526123;\n615         if (idx > 127) { // fall back if index falls outside table range\n616             coeffs[n] = wmavoice_energy_table[127] *\n617                         powf(1.0331663, idx - 127);\n618         } else\n619             coeffs[n] = wmavoice_energy_table[FFMAX(0, idx)];\n620     }\n621\n622     /* calculate the Hilbert transform of the gains, which we do (since this\n623      * is a sine input) by doing a phase shift (in theory, H(sin())=cos()).\n624      * Hilbert_Transform(RDFT(x)) = Laplace_Transform(x), which calculates the\n625      * \"moment\" of the LPCs in this filter. */\n626     s->dct.dct_calc(&s->dct, lpcs);\n627     s->dst.dct_calc(&s->dst, lpcs);\n628\n629     /* Split out the coefficient indexes into phase/magnitude pairs */\n630     idx = 255 + av_clip(lpcs[64],               -255, 255);\n631     coeffs[0]  = coeffs[0]  * s->cos[idx];\n632     idx = 255 + av_clip(lpcs[64] - 2 * lpcs[63], -255, 255);\n633     last_coeff = coeffs[64] * s->cos[idx];\n634     for (n = 63;; n--) {\n635         idx = 255 + av_clip(-lpcs[64] - 2 * lpcs[n - 1], -255, 255);\n636         coeffs[n * 2 + 1] = coeffs[n] * s->sin[idx];\n637         coeffs[n * 2]     = coeffs[n] * s->cos[idx];\n638\n639         if (!--n) break;\n640\n641         idx = 255 + av_clip( lpcs[64] - 2 * lpcs[n - 1], -255, 255);\n642         coeffs[n * 2 + 1] = coeffs[n] * s->sin[idx];\n643         coeffs[n * 2]     = coeffs[n] * s->cos[idx];\n644     }\n645     coeffs[1] = last_coeff;\n646\n647     /* move into real domain */\n648     s->irdft.rdft_calc(&s->irdft, coeffs);\n649\n650     /* tilt correction and normalize scale */\n651     memset(&coeffs[remainder], 0, sizeof(coeffs[0]) * (128 - remainder));\n652     if (s->denoise_tilt_corr) {\n653         float tilt_mem = 0;\n654\n655         coeffs[remainder - 1] = 0;\n656         ff_tilt_compensation(&tilt_mem,\n657                              -1.8 * tilt_factor(coeffs, remainder - 1),\n658                              coeffs, remainder);\n659     }\n660     sq = (1.0 / 64.0) * sqrtf(1 / avpriv_scalarproduct_float_c(coeffs, coeffs,\n661                                                                remainder));\n662     for (n = 0; n < remainder; n++)\n663         coeffs[n] *= sq;\n664 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "692 static void wiener_denoise(WMAVoiceContext *s, int fcb_type,\n693                            float *synth_pf, int size,\n694                            const float *lpcs)\n695 {\n696     int remainder, lim, n;\n697\n698     if (fcb_type != FCB_TYPE_SILENCE) {\n699         float *tilted_lpcs = s->tilted_lpcs_pf,\n700               *coeffs = s->denoise_coeffs_pf, tilt_mem = 0;\n701\n702         tilted_lpcs[0]           = 1.0;\n703         memcpy(&tilted_lpcs[1], lpcs, sizeof(lpcs[0]) * s->lsps);\n704         memset(&tilted_lpcs[s->lsps + 1], 0,\n705                sizeof(tilted_lpcs[0]) * (128 - s->lsps - 1));\n706         ff_tilt_compensation(&tilt_mem, 0.7 * tilt_factor(lpcs, s->lsps),\n707                              tilted_lpcs, s->lsps + 2);\n708\n709         /* The IRDFT output (127 samples for 7-bit filter) beyond the frame\n710          * size is applied to the next frame. All input beyond this is zero,\n711          * and thus all output beyond this will go towards zero, hence we can\n712          * limit to min(size-1, 127-size) as a performance consideration. */\n713         remainder = FFMIN(127 - size, size - 1);\n714         calc_input_response(s, tilted_lpcs, fcb_type, coeffs, remainder);\n715\n716         /* apply coefficients (in frequency spectrum domain), i.e. complex\n717          * number multiplication */\n718         memset(&synth_pf[size], 0, sizeof(synth_pf[0]) * (128 - size));\n719         s->rdft.rdft_calc(&s->rdft, synth_pf);\n720         s->rdft.rdft_calc(&s->rdft, coeffs);\n721         synth_pf[0] *= coeffs[0];\n722         synth_pf[1] *= coeffs[1];\n723         for (n = 1; n < 64; n++) {\n724             float v1 = synth_pf[n * 2], v2 = synth_pf[n * 2 + 1];\n725             synth_pf[n * 2]     = v1 * coeffs[n * 2] - v2 * coeffs[n * 2 + 1];\n726             synth_pf[n * 2 + 1] = v2 * coeffs[n * 2] + v1 * coeffs[n * 2 + 1];\n727         }\n728         s->irdft.rdft_calc(&s->irdft, synth_pf);\n729     }\n730\n731     /* merge filter output with the history of previous runs */\n732     if (s->denoise_filter_cache_size) {\n733         lim = FFMIN(s->denoise_filter_cache_size, size);\n734         for (n = 0; n < lim; n++)\n735             synth_pf[n] += s->denoise_filter_cache[n];\n736         s->denoise_filter_cache_size -= lim;\n737         memmove(s->denoise_filter_cache, &s->denoise_filter_cache[size],\n738                 sizeof(s->denoise_filter_cache[0]) * s->denoise_filter_cache_size);\n739     }\n740\n741     /* move remainder of filter output into a cache for future runs */\n742     if (fcb_type != FCB_TYPE_SILENCE) {\n743         lim = FFMIN(remainder, s->denoise_filter_cache_size);\n744         for (n = 0; n < lim; n++)\n745             s->denoise_filter_cache[n] += synth_pf[size + n];\n746         if (lim < remainder) {\n747             memcpy(&s->denoise_filter_cache[lim], &synth_pf[size + lim],\n748                    sizeof(s->denoise_filter_cache[0]) * (remainder - lim));\n749             s->denoise_filter_cache_size = remainder;\n750         }\n751     }\n752 }"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "774 static void postfilter(WMAVoiceContext *s, const float *synth,\n775                        float *samples,    int size,\n776                        const float *lpcs, float *zero_exc_pf,\n777                        int fcb_type,      int pitch)\n778 {\n779     float synth_filter_in_buf[MAX_FRAMESIZE / 2],\n780           *synth_pf = &s->synth_filter_out_buf[MAX_LSPS_ALIGN16],\n781           *synth_filter_in = zero_exc_pf;\n782\n783     assert(size <= MAX_FRAMESIZE / 2);\n784\n785     /* generate excitation from input signal */\n786     ff_celp_lp_zero_synthesis_filterf(zero_exc_pf, lpcs, synth, size, s->lsps);\n787\n788     if (fcb_type >= FCB_TYPE_AW_PULSES &&\n789         !kalman_smoothen(s, pitch, zero_exc_pf, synth_filter_in_buf, size))\n790         synth_filter_in = synth_filter_in_buf;\n791\n792     /* re-synthesize speech after smoothening, and keep history */\n793     ff_celp_lp_synthesis_filterf(synth_pf, lpcs,\n794                                  synth_filter_in, size, s->lsps);\n795     memcpy(&synth_pf[-s->lsps], &synth_pf[size - s->lsps],\n796            sizeof(synth_pf[0]) * s->lsps);\n797\n798     wiener_denoise(s, fcb_type, synth_pf, size, lpcs);\n799\n800     adaptive_gain_control(samples, synth_pf, synth, size, 0.99,\n801                           &s->postfilter_agc);\n802\n803     if (s->dc_level > 8) {\n804         /* remove ultra-low frequency DC noise / highpass filter;\n805          * coefficients are identical to those used in SIPR decoding,\n806          * and very closely resemble those used in AMR-NB decoding. */\n807         ff_acelp_apply_order_2_transfer_function(samples, samples,\n808             (const float[2]) { -1.99997,      1.0 },\n809             (const float[2]) { -1.9330735188, 0.93589198496 },\n810             0.93980580475, s->dcf_mem, size);\n811     }\n812 }"
                    }
                ]
            }
        ],
        "sink": "if (lim < remainder) {",
        "final_sink": "if (lim < remainder) {"
    },
    {
        "prt": "ret",
        "function_call": [
            "static int request_frame(AVFilterLink *outlink)\n{\n    AVFilterContext *ctx = outlink->src;\n    FramepackContext *s = ctx->priv;\n    AVStereo3D *stereo;\n    int ret, i;\n\n    /* get a frame on the either input, stop as soon as a video ends */\n    for (i = 0; i < 2; i++) {\n        if (!s->input_views[i]) {\n            ret = ff_request_frame(ctx->inputs[i]);\n            if (ret < 0)\n                return ret;\n        }\n    }\n\n    if (s->format == AV_STEREO3D_FRAMESEQUENCE) {\n        if (s->double_pts == AV_NOPTS_VALUE)\n            s->double_pts = s->input_views[LEFT]->pts;\n\n        for (i = 0; i < 2; i++) {\n            // set correct timestamps\n            s->input_views[i]->pts = s->double_pts++;\n\n            // set stereo3d side data\n            stereo = av_stereo3d_create_side_data(s->input_views[i]);\n            if (!stereo)\n                return AVERROR(ENOMEM);\n            stereo->type = s->format;\n            stereo->view = i == LEFT ? AV_STEREO3D_VIEW_LEFT\n                                     : AV_STEREO3D_VIEW_RIGHT;\n\n            // filter the frame and immediately relinquish its pointer\n            ret = ff_filter_frame(outlink, s->input_views[i]);\n            s->input_views[i] = NULL;\n            if (ret < 0)\n                return ret;\n        }\n        return ret;\n    } else {\n        AVFrame *dst = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!dst)\n            return AVERROR(ENOMEM);\n\n        spatial_frame_pack(outlink, dst);\n\n        // get any property from the original frame\n        ret = av_frame_copy_props(dst, s->input_views[LEFT]);\n        if (ret < 0) {\n            av_frame_free(&dst);\n            return ret;\n        }\n\n        for (i = 0; i < 2; i++)\n            av_frame_free(&s->input_views[i]);\n\n        // set stereo3d side data\n        stereo = av_stereo3d_create_side_data(dst);\n        if (!stereo) {\n            av_frame_free(&dst);\n            return AVERROR(ENOMEM);\n        }\n        stereo->type = s->format;\n\n        return ff_filter_frame(outlink, dst);\n    }\n}"
        ],
        "source": [
            "    int ret, i;"
        ],
        "index": 10,
        "location": {
            "file_path": "libavfilter/vf_framepack.c",
            "region": {
                "startLine": 322,
                "startColumn": 16,
                "endColumn": 19
            },
            "context": {
                "startLine": 320,
                "endLine": 324,
                "snippet": {
                    "text": "        return ret;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavfilter/vf_framepack.c",
                        "function_body": "284 static int request_frame(AVFilterLink *outlink)\n285 {\n286     AVFilterContext *ctx = outlink->src;\n287     FramepackContext *s = ctx->priv;\n288     AVStereo3D *stereo;\n289     int ret, i;\n290\n291     /* get a frame on the either input, stop as soon as a video ends */\n292     for (i = 0; i < 2; i++) {\n293         if (!s->input_views[i]) {\n294             ret = ff_request_frame(ctx->inputs[i]);\n295             if (ret < 0)\n296                 return ret;\n297         }\n298     }\n299\n300     if (s->format == AV_STEREO3D_FRAMESEQUENCE) {\n301         if (s->double_pts == AV_NOPTS_VALUE)\n302             s->double_pts = s->input_views[LEFT]->pts;\n303\n304         for (i = 0; i < 2; i++) {\n305             // set correct timestamps\n306             s->input_views[i]->pts = s->double_pts++;\n307\n308             // set stereo3d side data\n309             stereo = av_stereo3d_create_side_data(s->input_views[i]);\n310             if (!stereo)\n311                 return AVERROR(ENOMEM);\n312             stereo->type = s->format;\n313             stereo->view = i == LEFT ? AV_STEREO3D_VIEW_LEFT\n314                                      : AV_STEREO3D_VIEW_RIGHT;\n315\n316             // filter the frame and immediately relinquish its pointer\n317             ret = ff_filter_frame(outlink, s->input_views[i]);\n318             s->input_views[i] = NULL;\n319             if (ret < 0)\n320                 return ret;\n321         }\n322         return ret;\n323     } else {\n324         AVFrame *dst = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n325         if (!dst)\n326             return AVERROR(ENOMEM);\n327\n328         spatial_frame_pack(outlink, dst);\n329\n330         // get any property from the original frame\n331         ret = av_frame_copy_props(dst, s->input_views[LEFT]);\n332         if (ret < 0) {\n333             av_frame_free(&dst);\n334             return ret;\n335         }\n336\n337         for (i = 0; i < 2; i++)\n338             av_frame_free(&s->input_views[i]);\n339\n340         // set stereo3d side data\n341         stereo = av_stereo3d_create_side_data(dst);\n342         if (!stereo) {\n343             av_frame_free(&dst);\n344             return AVERROR(ENOMEM);\n345         }\n346         stereo->type = s->format;\n347\n348         return ff_filter_frame(outlink, dst);\n349     }\n350 }"
                    },
                    {
                        "file_path": "/libavfilter/avfilter.c",
                        "function_body": "263 int ff_request_frame(AVFilterLink *link)\n264 {\n265     FF_DPRINTF_START(NULL, request_frame); ff_dlog_link(NULL, link, 1);\n266\n267     if (link->srcpad->request_frame)\n268         return link->srcpad->request_frame(link);\n269     else if (link->src->inputs[0])\n270         return ff_request_frame(link->src->inputs[0]);\n271     else\n272         return AVERROR(EINVAL);\n273 }"
                    }
                ]
            }
        ],
        "sink": "return ret;",
        "final_sink": "return ret;"
    },
    {
        "prt": "c",
        "function_call": [
            "static int ape_tag_read_field(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    uint8_t key[1024], *value;\n    int64_t size, flags;\n    int i, c;\n\n    size = avio_rl32(pb);  /* field size */\n    flags = avio_rl32(pb); /* field flags */\n    for (i = 0; i < sizeof(key) - 1; i++) {\n        c = avio_r8(pb);\n        if (c < 0x20 || c > 0x7E)\n            break;\n        else\n            key[i] = c;\n    }\n    key[i] = 0;\n    if (c != 0) {\n        av_log(s, AV_LOG_WARNING, \"Invalid APE tag key '%s'.\\n\", key);\n        return -1;\n    }\n    if (size > INT32_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n        av_log(s, AV_LOG_ERROR, \"APE tag size too large.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (flags & APE_TAG_FLAG_IS_BINARY) {\n        uint8_t filename[1024];\n        enum AVCodecID id;\n        AVStream *st = avformat_new_stream(s, NULL);\n        if (!st)\n            return AVERROR(ENOMEM);\n\n        size -= avio_get_str(pb, size, filename, sizeof(filename));\n        if (size <= 0) {\n            av_log(s, AV_LOG_WARNING, \"Skipping binary tag '%s'.\\n\", key);\n            return 0;\n        }\n\n        av_dict_set(&st->metadata, key, filename, 0);\n\n        if ((id = ff_guess_image2_codec(filename)) != AV_CODEC_ID_NONE) {\n            AVPacket pkt;\n            int ret;\n\n            ret = av_get_packet(s->pb, &pkt, size);\n            if (ret < 0) {\n                av_log(s, AV_LOG_ERROR, \"Error reading cover art.\\n\");\n                return ret;\n            }\n\n            st->disposition      |= AV_DISPOSITION_ATTACHED_PIC;\n            st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n            st->codecpar->codec_id   = id;\n\n            st->attached_pic              = pkt;\n            st->attached_pic.stream_index = st->index;\n            st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n        } else {\n            st->codecpar->extradata = av_malloc(size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!st->codecpar->extradata)\n                return AVERROR(ENOMEM);\n            if (avio_read(pb, st->codecpar->extradata, size) != size) {\n                av_freep(&st->codecpar->extradata);\n                return AVERROR(EIO);\n            }\n            st->codecpar->extradata_size = size;\n            st->codecpar->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n        }\n    } else {\n        value = av_malloc(size+1);\n        if (!value)\n            return AVERROR(ENOMEM);\n        c = avio_read(pb, value, size);\n        if (c < 0) {\n            av_free(value);\n            return c;\n        }\n        value[c] = 0;\n        av_dict_set(&s->metadata, key, value, AV_DICT_DONT_STRDUP_VAL);\n    }\n    return 0;\n}"
        ],
        "source": [
            "    int i, c;"
        ],
        "index": 11,
        "location": {
            "file_path": "libavformat/apetag.c",
            "region": {
                "startLine": 57,
                "startColumn": 9,
                "endColumn": 10
            },
            "context": {
                "startLine": 55,
                "endLine": 59,
                "snippet": {
                    "text": "    if (c != 0) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/apetag.c",
                        "function_body": "40 static int ape_tag_read_field(AVFormatContext *s)\n41 {\n42     AVIOContext *pb = s->pb;\n43     uint8_t key[1024], *value;\n44     int64_t size, flags;\n45     int i, c;\n46\n47     size = avio_rl32(pb);  /* field size */\n48     flags = avio_rl32(pb); /* field flags */\n49     for (i = 0; i < sizeof(key) - 1; i++) {\n50         c = avio_r8(pb);\n51         if (c < 0x20 || c > 0x7E)\n52             break;\n53         else\n54             key[i] = c;\n55     }\n56     key[i] = 0;\n57     if (c != 0) {\n58         av_log(s, AV_LOG_WARNING, \"Invalid APE tag key '%s'.\\n\", key);\n59         return -1;\n60     }\n61     if (size > INT32_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {\n62         av_log(s, AV_LOG_ERROR, \"APE tag size too large.\\n\");\n63         return AVERROR_INVALIDDATA;\n64     }\n65     if (flags & APE_TAG_FLAG_IS_BINARY) {\n66         uint8_t filename[1024];\n67         enum AVCodecID id;\n68         AVStream *st = avformat_new_stream(s, NULL);\n69         if (!st)\n70             return AVERROR(ENOMEM);\n71\n72         size -= avio_get_str(pb, size, filename, sizeof(filename));\n73         if (size <= 0) {\n74             av_log(s, AV_LOG_WARNING, \"Skipping binary tag '%s'.\\n\", key);\n75             return 0;\n76         }\n77\n78         av_dict_set(&st->metadata, key, filename, 0);\n79\n80         if ((id = ff_guess_image2_codec(filename)) != AV_CODEC_ID_NONE) {\n81             AVPacket pkt;\n82             int ret;\n83\n84             ret = av_get_packet(s->pb, &pkt, size);\n85             if (ret < 0) {\n86                 av_log(s, AV_LOG_ERROR, \"Error reading cover art.\\n\");\n87                 return ret;\n88             }\n89\n90             st->disposition      |= AV_DISPOSITION_ATTACHED_PIC;\n91             st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n92             st->codecpar->codec_id   = id;\n93\n94             st->attached_pic              = pkt;\n95             st->attached_pic.stream_index = st->index;\n96             st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n97         } else {\n98             st->codecpar->extradata = av_malloc(size + AV_INPUT_BUFFER_PADDING_SIZE);\n99             if (!st->codecpar->extradata)\n100                 return AVERROR(ENOMEM);\n101             if (avio_read(pb, st->codecpar->extradata, size) != size) {\n102                 av_freep(&st->codecpar->extradata);\n103                 return AVERROR(EIO);\n104             }\n105             st->codecpar->extradata_size = size;\n106             st->codecpar->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n107         }\n108     } else {\n109         value = av_malloc(size+1);\n110         if (!value)\n111             return AVERROR(ENOMEM);\n112         c = avio_read(pb, value, size);\n113         if (c < 0) {\n114             av_free(value);\n115             return c;\n116         }\n117         value[c] = 0;\n118         av_dict_set(&s->metadata, key, value, AV_DICT_DONT_STRDUP_VAL);\n119     }\n120     return 0;\n121 }"
                    },
                    {
                        "file_path": "/libavformat/apetag.c",
                        "function_body": "123 int64_t ff_ape_parse_tag(AVFormatContext *s)\n124 {\n125     AVIOContext *pb = s->pb;\n126     int64_t file_size = avio_size(pb);\n127     uint32_t val, fields, tag_bytes;\n128     uint8_t buf[8];\n129     int64_t tag_start;\n130     int i;\n131\n132     if (file_size < APE_TAG_FOOTER_BYTES)\n133         return 0;\n134\n135     avio_seek(pb, file_size - APE_TAG_FOOTER_BYTES, SEEK_SET);\n136\n137     avio_read(pb, buf, 8);     /* APETAGEX */\n138     if (strncmp(buf, \"APETAGEX\", 8)) {\n139         return 0;\n140     }\n141\n142     val = avio_rl32(pb);       /* APE tag version */\n143     if (val > APE_TAG_VERSION) {\n144         av_log(s, AV_LOG_ERROR, \"Unsupported tag version. (>=%d)\\n\", APE_TAG_VERSION);\n145         return 0;\n146     }\n147\n148     tag_bytes = avio_rl32(pb); /* tag size */\n149     if (tag_bytes - APE_TAG_FOOTER_BYTES > (1024 * 1024 * 16)) {\n150         av_log(s, AV_LOG_ERROR, \"Tag size is way too big\\n\");\n151         return 0;\n152     }\n153\n154     if (tag_bytes > file_size - APE_TAG_FOOTER_BYTES) {\n155         av_log(s, AV_LOG_ERROR, \"Invalid tag size %\"PRIu32\".\\n\", tag_bytes);\n156         return 0;\n157     }\n158\n159     fields = avio_rl32(pb);    /* number of fields */\n160     if (fields > 65536) {\n161         av_log(s, AV_LOG_ERROR, \"Too many tag fields (%\"PRIu32\")\\n\", fields);\n162         return 0;\n163     }\n164\n165     val = avio_rl32(pb);       /* flags */\n166     if (val & APE_TAG_FLAG_IS_HEADER) {\n167         av_log(s, AV_LOG_ERROR, \"APE Tag is a header\\n\");\n168         return 0;\n169     }\n170\n171     avio_seek(pb, file_size - tag_bytes, SEEK_SET);\n172\n173     if (val & APE_TAG_FLAG_CONTAINS_HEADER)\n174         tag_bytes += APE_TAG_HEADER_BYTES;\n175\n176     tag_start = file_size - tag_bytes;\n177\n178     for (i=0; i<fields; i++)\n179         if (ape_tag_read_field(s) < 0) break;\n180\n181     return tag_start;\n182 }"
                    }
                ]
            }
        ],
        "sink": "if (c != 0) {",
        "final_sink": "if (c != 0) {"
    },
    {
        "prt": "extra_func",
        "function_call": [
            "static void id3v2_parse(AVFormatContext *s, int len, uint8_t version,\n                        uint8_t flags, ID3v2ExtraMeta **extra_meta)\n{\n    int isv34, tlen, unsync;\n    char tag[5];\n    int64_t next, end = avio_tell(s->pb) + len;\n    int taghdrlen;\n    const char *reason = NULL;\n    AVIOContext pb;\n    AVIOContext *pbx;\n    unsigned char *buffer = NULL;\n    int buffer_size       = 0;\n    const ID3v2EMFunc *extra_func;\n\n    switch (version) {\n    case 2:\n        if (flags & 0x40) {\n            reason = \"compression\";\n            goto error;\n        }\n        isv34     = 0;\n        taghdrlen = 6;\n        break;\n\n    case 3:\n    case 4:\n        isv34     = 1;\n        taghdrlen = 10;\n        break;\n\n    default:\n        reason = \"version\";\n        goto error;\n    }\n\n    unsync = flags & 0x80;\n\n    if (isv34 && flags & 0x40) { /* Extended header present, just skip over it */\n        int extlen = get_size(s->pb, 4);\n        if (version == 4)\n            /* In v2.4 the length includes the length field we just read. */\n            extlen -= 4;\n\n        if (extlen < 0) {\n            reason = \"invalid extended header length\";\n            goto error;\n        }\n        avio_skip(s->pb, extlen);\n    }\n\n    while (len >= taghdrlen) {\n        unsigned int tflags = 0;\n        int tunsync         = 0;\n\n        if (isv34) {\n            avio_read(s->pb, tag, 4);\n            tag[4] = 0;\n            if (version == 3) {\n                tlen = avio_rb32(s->pb);\n            } else\n                tlen = get_size(s->pb, 4);\n            tflags  = avio_rb16(s->pb);\n            tunsync = tflags & ID3v2_FLAG_UNSYNCH;\n        } else {\n            avio_read(s->pb, tag, 3);\n            tag[3] = 0;\n            tlen   = avio_rb24(s->pb);\n        }\n        if (tlen < 0 || tlen > len - taghdrlen) {\n            av_log(s, AV_LOG_WARNING,\n                   \"Invalid size in frame %s, skipping the rest of tag.\\n\",\n                   tag);\n            break;\n        }\n        len -= taghdrlen + tlen;\n        next = avio_tell(s->pb) + tlen;\n\n        if (!tlen) {\n            if (tag[0])\n                av_log(s, AV_LOG_DEBUG, \"Invalid empty frame %s, skipping.\\n\",\n                       tag);\n            continue;\n        }\n\n        if (tflags & ID3v2_FLAG_DATALEN) {\n            avio_rb32(s->pb);\n            tlen -= 4;\n        }\n\n        if (tflags & (ID3v2_FLAG_ENCRYPTION | ID3v2_FLAG_COMPRESSION)) {\n            av_log(s, AV_LOG_WARNING,\n                   \"Skipping encrypted/compressed ID3v2 frame %s.\\n\", tag);\n            avio_skip(s->pb, tlen);\n        /* check for text tag or supported special meta tag */\n        } else if (tag[0] == 'T' ||\n                   (extra_meta &&\n                    (extra_func = get_extra_meta_func(tag, isv34)))) {\n            if (unsync || tunsync) {\n                int64_t end = avio_tell(s->pb) + tlen;\n                uint8_t *b;\n                av_fast_malloc(&buffer, &buffer_size, tlen);\n                if (!buffer) {\n                    av_log(s, AV_LOG_ERROR, \"Failed to alloc %d bytes\\n\", tlen);\n                    goto seek;\n                }\n                b = buffer;\n                while (avio_tell(s->pb) < end && !s->pb->eof_reached) {\n                    *b++ = avio_r8(s->pb);\n                    if (*(b - 1) == 0xff && avio_tell(s->pb) < end - 1 &&\n                        !s->pb->eof_reached ) {\n                        uint8_t val = avio_r8(s->pb);\n                        *b++ = val ? val : avio_r8(s->pb);\n                    }\n                }\n                ffio_init_context(&pb, buffer, b - buffer, 0, NULL, NULL, NULL,\n                                  NULL);\n                tlen = b - buffer;\n                pbx  = &pb; // read from sync buffer\n            } else {\n                pbx = s->pb; // read straight from input\n            }\n            if (tag[0] == 'T')\n                /* parse text tag */\n                read_ttag(s, pbx, tlen, tag);\n            else\n                /* parse special meta tag */\n                extra_func->read(s, pbx, tlen, tag, extra_meta, isv34);\n        } else if (!tag[0]) {\n            if (tag[1])\n                av_log(s, AV_LOG_WARNING, \"invalid frame id, assuming padding\");\n            avio_skip(s->pb, tlen);\n            break;\n        }\n        /* Skip to end of tag */\nseek:\n        avio_seek(s->pb, next, SEEK_SET);\n    }\n\n    /* Footer preset, always 10 bytes, skip over it */\n    if (version == 4 && flags & 0x10)\n        end += 10;\n\nerror:\n    if (reason)\n        av_log(s, AV_LOG_INFO, \"ID3v2.%d tag skipped, cannot handle %s\\n\",\n               version, reason);\n    avio_seek(s->pb, end, SEEK_SET);\n    av_free(buffer);\n    return;\n}"
        ],
        "source": [
            "    const ID3v2EMFunc *extra_func;"
        ],
        "index": 12,
        "location": {
            "file_path": "libavformat/id3v2.c",
            "region": {
                "startLine": 677,
                "startColumn": 17,
                "endColumn": 27
            },
            "context": {
                "startLine": 675,
                "endLine": 679,
                "snippet": {
                    "text": "                extra_func->read(s, pbx, tlen, tag, extra_meta, isv34);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/id3v2.c",
                        "function_body": "551 static void id3v2_parse(AVFormatContext *s, int len, uint8_t version,\n552                         uint8_t flags, ID3v2ExtraMeta **extra_meta)\n553 {\n554     int isv34, tlen, unsync;\n555     char tag[5];\n556     int64_t next, end = avio_tell(s->pb) + len;\n557     int taghdrlen;\n558     const char *reason = NULL;\n559     AVIOContext pb;\n560     AVIOContext *pbx;\n561     unsigned char *buffer = NULL;\n562     int buffer_size       = 0;\n563     const ID3v2EMFunc *extra_func;\n564\n565     switch (version) {\n566     case 2:\n567         if (flags & 0x40) {\n568             reason = \"compression\";\n569             goto error;\n570         }\n571         isv34     = 0;\n572         taghdrlen = 6;\n573         break;\n574\n575     case 3:\n576     case 4:\n577         isv34     = 1;\n578         taghdrlen = 10;\n579         break;\n580\n581     default:\n582         reason = \"version\";\n583         goto error;\n584     }\n585\n586     unsync = flags & 0x80;\n587\n588     if (isv34 && flags & 0x40) { /* Extended header present, just skip over it */\n589         int extlen = get_size(s->pb, 4);\n590         if (version == 4)\n591             /* In v2.4 the length includes the length field we just read. */\n592             extlen -= 4;\n593\n594         if (extlen < 0) {\n595             reason = \"invalid extended header length\";\n596             goto error;\n597         }\n598         avio_skip(s->pb, extlen);\n599     }\n600\n601     while (len >= taghdrlen) {\n602         unsigned int tflags = 0;\n603         int tunsync         = 0;\n604\n605         if (isv34) {\n606             avio_read(s->pb, tag, 4);\n607             tag[4] = 0;\n608             if (version == 3) {\n609                 tlen = avio_rb32(s->pb);\n610             } else\n611                 tlen = get_size(s->pb, 4);\n612             tflags  = avio_rb16(s->pb);\n613             tunsync = tflags & ID3v2_FLAG_UNSYNCH;\n614         } else {\n615             avio_read(s->pb, tag, 3);\n616             tag[3] = 0;\n617             tlen   = avio_rb24(s->pb);\n618         }\n619         if (tlen < 0 || tlen > len - taghdrlen) {\n620             av_log(s, AV_LOG_WARNING,\n621                    \"Invalid size in frame %s, skipping the rest of tag.\\n\",\n622                    tag);\n623             break;\n624         }\n625         len -= taghdrlen + tlen;\n626         next = avio_tell(s->pb) + tlen;\n627\n628         if (!tlen) {\n629             if (tag[0])\n630                 av_log(s, AV_LOG_DEBUG, \"Invalid empty frame %s, skipping.\\n\",\n631                        tag);\n632             continue;\n633         }\n634\n635         if (tflags & ID3v2_FLAG_DATALEN) {\n636             avio_rb32(s->pb);\n637             tlen -= 4;\n638         }\n639\n640         if (tflags & (ID3v2_FLAG_ENCRYPTION | ID3v2_FLAG_COMPRESSION)) {\n641             av_log(s, AV_LOG_WARNING,\n642                    \"Skipping encrypted/compressed ID3v2 frame %s.\\n\", tag);\n643             avio_skip(s->pb, tlen);\n644         /* check for text tag or supported special meta tag */\n645         } else if (tag[0] == 'T' ||\n646                    (extra_meta &&\n647                     (extra_func = get_extra_meta_func(tag, isv34)))) {\n648             if (unsync || tunsync) {\n649                 int64_t end = avio_tell(s->pb) + tlen;\n650                 uint8_t *b;\n651                 av_fast_malloc(&buffer, &buffer_size, tlen);\n652                 if (!buffer) {\n653                     av_log(s, AV_LOG_ERROR, \"Failed to alloc %d bytes\\n\", tlen);\n654                     goto seek;\n655                 }\n656                 b = buffer;\n657                 while (avio_tell(s->pb) < end && !s->pb->eof_reached) {\n658                     *b++ = avio_r8(s->pb);\n659                     if (*(b - 1) == 0xff && avio_tell(s->pb) < end - 1 &&\n660                         !s->pb->eof_reached ) {\n661                         uint8_t val = avio_r8(s->pb);\n662                         *b++ = val ? val : avio_r8(s->pb);\n663                     }\n664                 }\n665                 ffio_init_context(&pb, buffer, b - buffer, 0, NULL, NULL, NULL,\n666                                   NULL);\n667                 tlen = b - buffer;\n668                 pbx  = &pb; // read from sync buffer\n669             } else {\n670                 pbx = s->pb; // read straight from input\n671             }\n672             if (tag[0] == 'T')\n673                 /* parse text tag */\n674                 read_ttag(s, pbx, tlen, tag);\n675             else\n676                 /* parse special meta tag */\n677                 extra_func->read(s, pbx, tlen, tag, extra_meta, isv34);\n678         } else if (!tag[0]) {\n679             if (tag[1])\n680                 av_log(s, AV_LOG_WARNING, \"invalid frame id, assuming padding\");\n681             avio_skip(s->pb, tlen);\n682             break;\n683         }\n684         /* Skip to end of tag */\n685 seek:\n686         avio_seek(s->pb, next, SEEK_SET);\n687     }\n688\n689     /* Footer preset, always 10 bytes, skip over it */\n690     if (version == 4 && flags & 0x10)\n691         end += 10;\n692\n693 error:\n694     if (reason)\n695         av_log(s, AV_LOG_INFO, \"ID3v2.%d tag skipped, cannot handle %s\\n\",\n696                version, reason);\n697     avio_seek(s->pb, end, SEEK_SET);\n698     av_free(buffer);\n699     return;\n700 }"
                    },
                    {
                        "file_path": "/libavformat/id3v2.c",
                        "function_body": "702 void ff_id3v2_read(AVFormatContext *s, const char *magic,\n703                    ID3v2ExtraMeta **extra_meta)\n704 {\n705     int len, ret;\n706     uint8_t buf[ID3v2_HEADER_SIZE];\n707     int found_header;\n708     int64_t off;\n709\n710     do {\n711         /* save the current offset in case there's nothing to read/skip */\n712         off = avio_tell(s->pb);\n713         ret = avio_read(s->pb, buf, ID3v2_HEADER_SIZE);\n714         if (ret != ID3v2_HEADER_SIZE)\n715             break;\n716         found_header = ff_id3v2_match(buf, magic);\n717         if (found_header) {\n718             /* parse ID3v2 header */\n719             len = ((buf[6] & 0x7f) << 21) |\n720                   ((buf[7] & 0x7f) << 14) |\n721                   ((buf[8] & 0x7f) << 7) |\n722                    (buf[9] & 0x7f);\n723             id3v2_parse(s, len, buf[3], buf[5], extra_meta);\n724         } else {\n725             avio_seek(s->pb, off, SEEK_SET);\n726         }\n727     } while (found_header);\n728     ff_metadata_conv(&s->metadata, NULL, ff_id3v2_34_metadata_conv);\n729     ff_metadata_conv(&s->metadata, NULL, id3v2_2_metadata_conv);\n730     ff_metadata_conv(&s->metadata, NULL, ff_id3v2_4_metadata_conv);\n731     merge_date(&s->metadata);\n732 }"
                    }
                ]
            }
        ],
        "sink": "extra_func->read(s, pbx, tlen, tag, extra_meta, isv34);",
        "final_sink": "extra_func->read(s, pbx, tlen, tag, extra_meta, isv34);"
    },
    {
        "prt": "layer",
        "function_call": [
            "static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,\n                                    AVPacket *pkt, uint64_t display_duration)\n{\n    AVBufferRef *line;\n    char *layer, *ptr = pkt->data, *end = ptr + pkt->size;\n\n    for (; *ptr != ',' && ptr < end - 1; ptr++)\n        ;\n    if (*ptr == ',')\n        layer = ++ptr;\n    for (; *ptr != ',' && ptr < end - 1; ptr++)\n        ;\n    if (*ptr == ',') {\n        int64_t end_pts = pkt->pts + display_duration;\n        int sc = matroska->time_scale * pkt->pts / 10000000;\n        int ec = matroska->time_scale * end_pts  / 10000000;\n        int sh, sm, ss, eh, em, es, len;\n        sh     = sc / 360000;\n        sc    -= 360000 * sh;\n        sm     = sc / 6000;\n        sc    -= 6000 * sm;\n        ss     = sc / 100;\n        sc    -= 100 * ss;\n        eh     = ec / 360000;\n        ec    -= 360000 * eh;\n        em     = ec / 6000;\n        ec    -= 6000 * em;\n        es     = ec / 100;\n        ec    -= 100 * es;\n        *ptr++ = '\\0';\n        len    = 50 + end - ptr + AV_INPUT_BUFFER_PADDING_SIZE;\n        if (!(line = av_buffer_alloc(len)))\n            return;\n        snprintf(line->data, len,\n                 \"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\\r\\n\",\n                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);\n        av_buffer_unref(&pkt->buf);\n        pkt->buf  = line;\n        pkt->data = line->data;\n        pkt->size = strlen(line->data);\n    }\n}"
        ],
        "source": [
            "    char *layer, *ptr = pkt->data, *end = ptr + pkt->size;"
        ],
        "index": 13,
        "location": {
            "file_path": "libavformat/matroskadec.c",
            "region": {
                "startLine": 1239,
                "startColumn": 18,
                "endColumn": 23
            },
            "context": {
                "startLine": 1237,
                "endLine": 1241,
                "snippet": {
                    "text": "                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/matroskadec.c",
                        "function_body": "1204 static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,\n1205                                     AVPacket *pkt, uint64_t display_duration)\n1206 {\n1207     AVBufferRef *line;\n1208     char *layer, *ptr = pkt->data, *end = ptr + pkt->size;\n1209\n1210     for (; *ptr != ',' && ptr < end - 1; ptr++)\n1211         ;\n1212     if (*ptr == ',')\n1213         layer = ++ptr;\n1214     for (; *ptr != ',' && ptr < end - 1; ptr++)\n1215         ;\n1216     if (*ptr == ',') {\n1217         int64_t end_pts = pkt->pts + display_duration;\n1218         int sc = matroska->time_scale * pkt->pts / 10000000;\n1219         int ec = matroska->time_scale * end_pts  / 10000000;\n1220         int sh, sm, ss, eh, em, es, len;\n1221         sh     = sc / 360000;\n1222         sc    -= 360000 * sh;\n1223         sm     = sc / 6000;\n1224         sc    -= 6000 * sm;\n1225         ss     = sc / 100;\n1226         sc    -= 100 * ss;\n1227         eh     = ec / 360000;\n1228         ec    -= 360000 * eh;\n1229         em     = ec / 6000;\n1230         ec    -= 6000 * em;\n1231         es     = ec / 100;\n1232         ec    -= 100 * es;\n1233         *ptr++ = '\\0';\n1234         len    = 50 + end - ptr + AV_INPUT_BUFFER_PADDING_SIZE;\n1235         if (!(line = av_buffer_alloc(len)))\n1236             return;\n1237         snprintf(line->data, len,\n1238                  \"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\\r\\n\",\n1239                  layer, sh, sm, ss, sc, eh, em, es, ec, ptr);\n1240         av_buffer_unref(&pkt->buf);\n1241         pkt->buf  = line;\n1242         pkt->data = line->data;\n1243         pkt->size = strlen(line->data);\n1244     }\n1245 }"
                    },
                    {
                        "file_path": "/libavformat/matroskadec.c",
                        "function_body": "2504 static int matroska_parse_frame(MatroskaDemuxContext *matroska,\n2505                                 MatroskaTrack *track, AVStream *st,\n2506                                 uint8_t *data, int pkt_size,\n2507                                 uint64_t timecode, uint64_t duration,\n2508                                 int64_t pos, int is_keyframe)\n2509 {\n2510     MatroskaTrackEncoding *encodings = track->encodings.elem;\n2511     uint8_t *pkt_data = data;\n2512     int offset = 0, res;\n2513     AVPacket *pkt;\n2514\n2515     if (encodings && encodings->scope & 1) {\n2516         res = matroska_decode_buffer(&pkt_data, &pkt_size, track);\n2517         if (res < 0)\n2518             return res;\n2519     }\n2520\n2521     if (st->codecpar->codec_id == AV_CODEC_ID_WAVPACK) {\n2522         uint8_t *wv_data;\n2523         res = matroska_parse_wavpack(track, pkt_data, &wv_data, &pkt_size);\n2524         if (res < 0) {\n2525             av_log(matroska->ctx, AV_LOG_ERROR,\n2526                    \"Error parsing a wavpack block.\\n\");\n2527             goto fail;\n2528         }\n2529         if (pkt_data != data)\n2530             av_freep(&pkt_data);\n2531         pkt_data = wv_data;\n2532     }\n2533\n2534     if (st->codecpar->codec_id == AV_CODEC_ID_PRORES)\n2535         offset = 8;\n2536\n2537     pkt = av_mallocz(sizeof(AVPacket));\n2538     if (!pkt) {\n2539         av_freep(&pkt_data);\n2540         return AVERROR(ENOMEM);\n2541     }\n2542     /* XXX: prevent data copy... */\n2543     if (av_new_packet(pkt, pkt_size + offset) < 0) {\n2544         av_free(pkt);\n2545         av_freep(&pkt_data);\n2546         return AVERROR(ENOMEM);\n2547     }\n2548\n2549     if (st->codecpar->codec_id == AV_CODEC_ID_PRORES) {\n2550         uint8_t *buf = pkt->data;\n2551         bytestream_put_be32(&buf, pkt_size);\n2552         bytestream_put_be32(&buf, MKBETAG('i', 'c', 'p', 'f'));\n2553     }\n2554\n2555     memcpy(pkt->data + offset, pkt_data, pkt_size);\n2556\n2557     if (pkt_data != data)\n2558         av_free(pkt_data);\n2559\n2560     pkt->flags        = is_keyframe;\n2561     pkt->stream_index = st->index;\n2562\n2563     if (track->ms_compat)\n2564         pkt->dts = timecode;\n2565     else\n2566         pkt->pts = timecode;\n2567     pkt->pos = pos;\n2568     if (track->type != MATROSKA_TRACK_TYPE_SUBTITLE || st->codecpar->codec_id == AV_CODEC_ID_SRT)\n2569         pkt->duration = duration;\n2570 #if FF_API_CONVERGENCE_DURATION\n2571 FF_DISABLE_DEPRECATION_WARNINGS\n2572     if (st->codecpar->codec_id == AV_CODEC_ID_SRT)\n2573         pkt->convergence_duration = duration;\n2574 FF_ENABLE_DEPRECATION_WARNINGS\n2575 #endif\n2576\n2577     if (st->codecpar->codec_id == AV_CODEC_ID_SSA)\n2578         matroska_fix_ass_packet(matroska, pkt, duration);\n2579\n2580     if (matroska->prev_pkt                                 &&\n2581         timecode                         != AV_NOPTS_VALUE &&\n2582         matroska->prev_pkt->pts          == timecode       &&\n2583         matroska->prev_pkt->stream_index == st->index      &&\n2584         st->codecpar->codec_id == AV_CODEC_ID_SSA)\n2585         matroska_merge_packets(matroska->prev_pkt, pkt);\n2586     else {\n2587         dynarray_add(&matroska->packets, &matroska->num_packets, pkt);\n2588         matroska->prev_pkt = pkt;\n2589     }\n2590\n2591     return 0;\n2592\n2593 fail:\n2594     if (pkt_data != data)\n2595         av_freep(&pkt_data);\n2596     return res;\n2597 }"
                    }
                ]
            }
        ],
        "sink": "layer, sh, sm, ss, sc, eh, em, es, ec, ptr);",
        "final_sink": "layer, sh, sm, ss, sc, eh, em, es, ec, ptr);"
    },
    {
        "prt": "srate_idx",
        "function_call": [
            "static void mp3_write_xing(AVFormatContext *s)\n{\n    MP3Context       *mp3 = s->priv_data;\n    AVCodecParameters *par = s->streams[mp3->audio_stream_idx]->codecpar;\n    AVDictionaryEntry *enc = av_dict_get(s->streams[mp3->audio_stream_idx]->metadata, \"encoder\", NULL, 0);\n    AVIOContext *dyn_ctx;\n    int32_t        header;\n    MPADecodeHeader  mpah;\n    int srate_idx, i, channels;\n    int bitrate_idx;\n    int best_bitrate_idx;\n    int best_bitrate_error = INT_MAX;\n    int ret;\n    int ver = 0;\n    int lsf, bytes_needed;\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) || !mp3->write_xing)\n        return;\n\n    for (i = 0; i < FF_ARRAY_ELEMS(avpriv_mpa_freq_tab); i++) {\n        const uint16_t base_freq = avpriv_mpa_freq_tab[i];\n\n        if      (par->sample_rate == base_freq)     ver = 0x3; // MPEG 1\n        else if (par->sample_rate == base_freq / 2) ver = 0x2; // MPEG 2\n        else if (par->sample_rate == base_freq / 4) ver = 0x0; // MPEG 2.5\n        else continue;\n\n        srate_idx = i;\n        break;\n    }\n    if (i == FF_ARRAY_ELEMS(avpriv_mpa_freq_tab)) {\n        av_log(s, AV_LOG_WARNING, \"Unsupported sample rate, not writing Xing \"\n               \"header.\\n\");\n        return;\n    }\n\n    switch (par->channels) {\n    case 1:  channels = MPA_MONO;                                          break;\n    case 2:  channels = MPA_STEREO;                                        break;\n    default: av_log(s, AV_LOG_WARNING, \"Unsupported number of channels, \"\n                    \"not writing Xing header.\\n\");\n             return;\n    }\n\n    /* dummy MPEG audio header */\n    header  =  0xff                                  << 24; // sync\n    header |= (0x7 << 5 | ver << 3 | 0x1 << 1 | 0x1) << 16; // sync/audio-version/layer 3/no crc*/\n    header |= (srate_idx << 2) << 8;\n    header |= channels << 6;\n\n    lsf = !((header & (1 << 20) && header & (1 << 19)));\n\n    mp3->xing_offset = xing_offtbl[ver != 3][channels == 1] + 4;\n    bytes_needed     = mp3->xing_offset + XING_SIZE;\n\n    for (bitrate_idx = 1; bitrate_idx < 15; bitrate_idx++) {\n        int bit_rate = 1000 * avpriv_mpa_bitrate_tab[lsf][3 - 1][bitrate_idx];\n        int error    = FFABS(bit_rate - par->bit_rate);\n\n        if (error < best_bitrate_error){\n            best_bitrate_error = error;\n            best_bitrate_idx   = bitrate_idx;\n        }\n    }\n\n    for (bitrate_idx = best_bitrate_idx; bitrate_idx < 15; bitrate_idx++) {\n        int32_t mask = bitrate_idx << (4 + 8);\n        header |= mask;\n\n        avpriv_mpegaudio_decode_header(&mpah, header);\n\n        if (bytes_needed <= mpah.frame_size)\n            break;\n\n        header &= ~mask;\n    }\n\n    ret = avio_open_dyn_buf(&dyn_ctx);\n    if (ret < 0)\n        return;\n\n    avio_wb32(dyn_ctx, header);\n\n    avpriv_mpegaudio_decode_header(&mpah, header);\n\n    av_assert0(mpah.frame_size >= bytes_needed);\n\n    ffio_fill(dyn_ctx, 0, mp3->xing_offset - 4);\n    ffio_wfourcc(dyn_ctx, \"Xing\");\n    avio_wb32(dyn_ctx, 0x01 | 0x02 | 0x04 | 0x08);  // frames / size / TOC / vbr scale\n\n    mp3->size = mpah.frame_size;\n    mp3->want = 1;\n\n    avio_wb32(dyn_ctx, 0);  // frames\n    avio_wb32(dyn_ctx, 0);  // size\n\n    // TOC\n    for (i = 0; i < XING_TOC_SIZE; i++)\n        avio_w8(dyn_ctx, 255 * i / XING_TOC_SIZE);\n\n    // vbr quality\n    // we write it, because some (broken) tools always expect it to be present\n    avio_wb32(dyn_ctx, 0);\n\n    // encoder short version string\n    if (enc) {\n        uint8_t encoder_str[9] = { 0 };\n        memcpy(encoder_str, enc->value, FFMIN(strlen(enc->value), sizeof(encoder_str)));\n        avio_write(dyn_ctx, encoder_str, sizeof(encoder_str));\n    } else\n        ffio_fill(dyn_ctx, 0, 9);\n\n    avio_w8(dyn_ctx, 0);      // tag revision 0 / unknown vbr method\n    avio_w8(dyn_ctx, 0);      // unknown lowpass filter value\n    ffio_fill(dyn_ctx, 0, 8); // empty replaygain fields\n    avio_w8(dyn_ctx, 0);      // unknown encoding flags\n    avio_w8(dyn_ctx, 0);      // unknown abr/minimal bitrate\n\n    // encoder delay\n    if (par->initial_padding >= 1 << 12 ||\n        par->trailing_padding >= 1 << 12) {\n        av_log(s, AV_LOG_WARNING, \"Too many samples of padding.\\n\");\n        avio_wb24(dyn_ctx, 0);\n    } else {\n        avio_wb24(dyn_ctx, par->initial_padding << 12 | par->trailing_padding);\n    }\n\n    avio_w8(dyn_ctx,   0); // misc\n    avio_w8(dyn_ctx,   0); // mp3gain\n    avio_wb16(dyn_ctx, 0); // preset\n\n    // audio length and CRCs (will be updated later)\n    avio_wb32(dyn_ctx, 0); // music length\n    avio_wb16(dyn_ctx, 0); // music crc\n    avio_wb16(dyn_ctx, 0); // tag crc\n\n    ffio_fill(dyn_ctx, 0, mpah.frame_size - bytes_needed);\n\n    mp3->xing_frame_size   = avio_close_dyn_buf(dyn_ctx, &mp3->xing_frame);\n    mp3->xing_frame_offset = avio_tell(s->pb);\n    avio_write(s->pb, mp3->xing_frame, mp3->xing_frame_size);\n\n    mp3->audio_size = mp3->xing_frame_size;\n}"
        ],
        "source": [
            "    int srate_idx, i, channels;"
        ],
        "index": 14,
        "location": {
            "file_path": "libavformat/mp3enc.c",
            "region": {
                "startLine": 175,
                "startColumn": 16,
                "endColumn": 25
            },
            "context": {
                "startLine": 173,
                "endLine": 177,
                "snippet": {
                    "text": "    header |= (srate_idx << 2) << 8;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/mp3enc.c",
                        "function_body": "128 static void mp3_write_xing(AVFormatContext *s)\n129 {\n130     MP3Context       *mp3 = s->priv_data;\n131     AVCodecParameters *par = s->streams[mp3->audio_stream_idx]->codecpar;\n132     AVDictionaryEntry *enc = av_dict_get(s->streams[mp3->audio_stream_idx]->metadata, \"encoder\", NULL, 0);\n133     AVIOContext *dyn_ctx;\n134     int32_t        header;\n135     MPADecodeHeader  mpah;\n136     int srate_idx, i, channels;\n137     int bitrate_idx;\n138     int best_bitrate_idx;\n139     int best_bitrate_error = INT_MAX;\n140     int ret;\n141     int ver = 0;\n142     int lsf, bytes_needed;\n143\n144     if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) || !mp3->write_xing)\n145         return;\n146\n147     for (i = 0; i < FF_ARRAY_ELEMS(avpriv_mpa_freq_tab); i++) {\n148         const uint16_t base_freq = avpriv_mpa_freq_tab[i];\n149\n150         if      (par->sample_rate == base_freq)     ver = 0x3; // MPEG 1\n151         else if (par->sample_rate == base_freq / 2) ver = 0x2; // MPEG 2\n152         else if (par->sample_rate == base_freq / 4) ver = 0x0; // MPEG 2.5\n153         else continue;\n154\n155         srate_idx = i;\n156         break;\n157     }\n158     if (i == FF_ARRAY_ELEMS(avpriv_mpa_freq_tab)) {\n159         av_log(s, AV_LOG_WARNING, \"Unsupported sample rate, not writing Xing \"\n160                \"header.\\n\");\n161         return;\n162     }\n163\n164     switch (par->channels) {\n165     case 1:  channels = MPA_MONO;                                          break;\n166     case 2:  channels = MPA_STEREO;                                        break;\n167     default: av_log(s, AV_LOG_WARNING, \"Unsupported number of channels, \"\n168                     \"not writing Xing header.\\n\");\n169              return;\n170     }\n171\n172     /* dummy MPEG audio header */\n173     header  =  0xff                                  << 24; // sync\n174     header |= (0x7 << 5 | ver << 3 | 0x1 << 1 | 0x1) << 16; // sync/audio-version/layer 3/no crc*/\n175     header |= (srate_idx << 2) << 8;\n176     header |= channels << 6;\n177\n178     lsf = !((header & (1 << 20) && header & (1 << 19)));\n179\n180     mp3->xing_offset = xing_offtbl[ver != 3][channels == 1] + 4;\n181     bytes_needed     = mp3->xing_offset + XING_SIZE;\n182\n183     for (bitrate_idx = 1; bitrate_idx < 15; bitrate_idx++) {\n184         int bit_rate = 1000 * avpriv_mpa_bitrate_tab[lsf][3 - 1][bitrate_idx];\n185         int error    = FFABS(bit_rate - par->bit_rate);\n186\n187         if (error < best_bitrate_error){\n188             best_bitrate_error = error;\n189             best_bitrate_idx   = bitrate_idx;\n190         }\n191     }\n192\n193     for (bitrate_idx = best_bitrate_idx; bitrate_idx < 15; bitrate_idx++) {\n194         int32_t mask = bitrate_idx << (4 + 8);\n195         header |= mask;\n196\n197         avpriv_mpegaudio_decode_header(&mpah, header);\n198\n199         if (bytes_needed <= mpah.frame_size)\n200             break;\n201\n202         header &= ~mask;\n203     }\n204\n205     ret = avio_open_dyn_buf(&dyn_ctx);\n206     if (ret < 0)\n207         return;\n208\n209     avio_wb32(dyn_ctx, header);\n210\n211     avpriv_mpegaudio_decode_header(&mpah, header);\n212\n213     av_assert0(mpah.frame_size >= bytes_needed);\n214\n215     ffio_fill(dyn_ctx, 0, mp3->xing_offset - 4);\n216     ffio_wfourcc(dyn_ctx, \"Xing\");\n217     avio_wb32(dyn_ctx, 0x01 | 0x02 | 0x04 | 0x08);  // frames / size / TOC / vbr scale\n218\n219     mp3->size = mpah.frame_size;\n220     mp3->want = 1;\n221\n222     avio_wb32(dyn_ctx, 0);  // frames\n223     avio_wb32(dyn_ctx, 0);  // size\n224\n225     // TOC\n226     for (i = 0; i < XING_TOC_SIZE; i++)\n227         avio_w8(dyn_ctx, 255 * i / XING_TOC_SIZE);\n228\n229     // vbr quality\n230     // we write it, because some (broken) tools always expect it to be present\n231     avio_wb32(dyn_ctx, 0);\n232\n233     // encoder short version string\n234     if (enc) {\n235         uint8_t encoder_str[9] = { 0 };\n236         memcpy(encoder_str, enc->value, FFMIN(strlen(enc->value), sizeof(encoder_str)));\n237         avio_write(dyn_ctx, encoder_str, sizeof(encoder_str));\n238     } else\n239         ffio_fill(dyn_ctx, 0, 9);\n240\n241     avio_w8(dyn_ctx, 0);      // tag revision 0 / unknown vbr method\n242     avio_w8(dyn_ctx, 0);      // unknown lowpass filter value\n243     ffio_fill(dyn_ctx, 0, 8); // empty replaygain fields\n244     avio_w8(dyn_ctx, 0);      // unknown encoding flags\n245     avio_w8(dyn_ctx, 0);      // unknown abr/minimal bitrate\n246\n247     // encoder delay\n248     if (par->initial_padding >= 1 << 12 ||\n249         par->trailing_padding >= 1 << 12) {\n250         av_log(s, AV_LOG_WARNING, \"Too many samples of padding.\\n\");\n251         avio_wb24(dyn_ctx, 0);\n252     } else {\n253         avio_wb24(dyn_ctx, par->initial_padding << 12 | par->trailing_padding);\n254     }\n255\n256     avio_w8(dyn_ctx,   0); // misc\n257     avio_w8(dyn_ctx,   0); // mp3gain\n258     avio_wb16(dyn_ctx, 0); // preset\n259\n260     // audio length and CRCs (will be updated later)\n261     avio_wb32(dyn_ctx, 0); // music length\n262     avio_wb16(dyn_ctx, 0); // music crc\n263     avio_wb16(dyn_ctx, 0); // tag crc\n264\n265     ffio_fill(dyn_ctx, 0, mpah.frame_size - bytes_needed);\n266\n267     mp3->xing_frame_size   = avio_close_dyn_buf(dyn_ctx, &mp3->xing_frame);\n268     mp3->xing_frame_offset = avio_tell(s->pb);\n269     avio_write(s->pb, mp3->xing_frame, mp3->xing_frame_size);\n270\n271     mp3->audio_size = mp3->xing_frame_size;\n272 }"
                    },
                    {
                        "file_path": "/libavformat/mp3enc.c",
                        "function_body": "506 static int mp3_write_header(struct AVFormatContext *s)\n507 {\n508     MP3Context  *mp3 = s->priv_data;\n509     int ret, i;\n510\n511     if (mp3->id3v2_version      &&\n512         mp3->id3v2_version != 3 &&\n513         mp3->id3v2_version != 4) {\n514         av_log(s, AV_LOG_ERROR, \"Invalid ID3v2 version requested: %d. Only \"\n515                \"3, 4 or 0 (disabled) are allowed.\\n\", mp3->id3v2_version);\n516         return AVERROR(EINVAL);\n517     }\n518\n519     /* check the streams -- we want exactly one audio and arbitrary number of\n520      * video (attached pictures) */\n521     mp3->audio_stream_idx = -1;\n522     for (i = 0; i < s->nb_streams; i++) {\n523         AVStream *st = s->streams[i];\n524         if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n525             if (mp3->audio_stream_idx >= 0 || st->codecpar->codec_id != AV_CODEC_ID_MP3) {\n526                 av_log(s, AV_LOG_ERROR, \"Invalid audio stream. Exactly one MP3 \"\n527                        \"audio stream is required.\\n\");\n528                 return AVERROR(EINVAL);\n529             }\n530             mp3->audio_stream_idx = i;\n531         } else if (st->codecpar->codec_type != AVMEDIA_TYPE_VIDEO) {\n532             av_log(s, AV_LOG_ERROR, \"Only audio streams and pictures are allowed in MP3.\\n\");\n533             return AVERROR(EINVAL);\n534         }\n535     }\n536     if (mp3->audio_stream_idx < 0) {\n537         av_log(s, AV_LOG_ERROR, \"No audio stream present.\\n\");\n538         return AVERROR(EINVAL);\n539     }\n540     mp3->pics_to_write = s->nb_streams - 1;\n541\n542     if (mp3->pics_to_write && !mp3->id3v2_version) {\n543         av_log(s, AV_LOG_ERROR, \"Attached pictures were requested, but the \"\n544                \"ID3v2 header is disabled.\\n\");\n545         return AVERROR(EINVAL);\n546     }\n547\n548     if (mp3->id3v2_version) {\n549         ff_id3v2_start(&mp3->id3, s->pb, mp3->id3v2_version, ID3v2_DEFAULT_MAGIC);\n550         ret = ff_id3v2_write_metadata(s, &mp3->id3);\n551         if (ret < 0)\n552             return ret;\n553     }\n554\n555     if (!mp3->pics_to_write) {\n556         if (mp3->id3v2_version)\n557             ff_id3v2_finish(&mp3->id3, s->pb);\n558         mp3_write_xing(s);\n559     }\n560\n561     return 0;\n562 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavformat/mp3enc.c",
                        "function_body": "128 static void mp3_write_xing(AVFormatContext *s)\n129 {\n130     MP3Context       *mp3 = s->priv_data;\n131     AVCodecParameters *par = s->streams[mp3->audio_stream_idx]->codecpar;\n132     AVDictionaryEntry *enc = av_dict_get(s->streams[mp3->audio_stream_idx]->metadata, \"encoder\", NULL, 0);\n133     AVIOContext *dyn_ctx;\n134     int32_t        header;\n135     MPADecodeHeader  mpah;\n136     int srate_idx, i, channels;\n137     int bitrate_idx;\n138     int best_bitrate_idx;\n139     int best_bitrate_error = INT_MAX;\n140     int ret;\n141     int ver = 0;\n142     int lsf, bytes_needed;\n143\n144     if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) || !mp3->write_xing)\n145         return;\n146\n147     for (i = 0; i < FF_ARRAY_ELEMS(avpriv_mpa_freq_tab); i++) {\n148         const uint16_t base_freq = avpriv_mpa_freq_tab[i];\n149\n150         if      (par->sample_rate == base_freq)     ver = 0x3; // MPEG 1\n151         else if (par->sample_rate == base_freq / 2) ver = 0x2; // MPEG 2\n152         else if (par->sample_rate == base_freq / 4) ver = 0x0; // MPEG 2.5\n153         else continue;\n154\n155         srate_idx = i;\n156         break;\n157     }\n158     if (i == FF_ARRAY_ELEMS(avpriv_mpa_freq_tab)) {\n159         av_log(s, AV_LOG_WARNING, \"Unsupported sample rate, not writing Xing \"\n160                \"header.\\n\");\n161         return;\n162     }\n163\n164     switch (par->channels) {\n165     case 1:  channels = MPA_MONO;                                          break;\n166     case 2:  channels = MPA_STEREO;                                        break;\n167     default: av_log(s, AV_LOG_WARNING, \"Unsupported number of channels, \"\n168                     \"not writing Xing header.\\n\");\n169              return;\n170     }\n171\n172     /* dummy MPEG audio header */\n173     header  =  0xff                                  << 24; // sync\n174     header |= (0x7 << 5 | ver << 3 | 0x1 << 1 | 0x1) << 16; // sync/audio-version/layer 3/no crc*/\n175     header |= (srate_idx << 2) << 8;\n176     header |= channels << 6;\n177\n178     lsf = !((header & (1 << 20) && header & (1 << 19)));\n179\n180     mp3->xing_offset = xing_offtbl[ver != 3][channels == 1] + 4;\n181     bytes_needed     = mp3->xing_offset + XING_SIZE;\n182\n183     for (bitrate_idx = 1; bitrate_idx < 15; bitrate_idx++) {\n184         int bit_rate = 1000 * avpriv_mpa_bitrate_tab[lsf][3 - 1][bitrate_idx];\n185         int error    = FFABS(bit_rate - par->bit_rate);\n186\n187         if (error < best_bitrate_error){\n188             best_bitrate_error = error;\n189             best_bitrate_idx   = bitrate_idx;\n190         }\n191     }\n192\n193     for (bitrate_idx = best_bitrate_idx; bitrate_idx < 15; bitrate_idx++) {\n194         int32_t mask = bitrate_idx << (4 + 8);\n195         header |= mask;\n196\n197         avpriv_mpegaudio_decode_header(&mpah, header);\n198\n199         if (bytes_needed <= mpah.frame_size)\n200             break;\n201\n202         header &= ~mask;\n203     }\n204\n205     ret = avio_open_dyn_buf(&dyn_ctx);\n206     if (ret < 0)\n207         return;\n208\n209     avio_wb32(dyn_ctx, header);\n210\n211     avpriv_mpegaudio_decode_header(&mpah, header);\n212\n213     av_assert0(mpah.frame_size >= bytes_needed);\n214\n215     ffio_fill(dyn_ctx, 0, mp3->xing_offset - 4);\n216     ffio_wfourcc(dyn_ctx, \"Xing\");\n217     avio_wb32(dyn_ctx, 0x01 | 0x02 | 0x04 | 0x08);  // frames / size / TOC / vbr scale\n218\n219     mp3->size = mpah.frame_size;\n220     mp3->want = 1;\n221\n222     avio_wb32(dyn_ctx, 0);  // frames\n223     avio_wb32(dyn_ctx, 0);  // size\n224\n225     // TOC\n226     for (i = 0; i < XING_TOC_SIZE; i++)\n227         avio_w8(dyn_ctx, 255 * i / XING_TOC_SIZE);\n228\n229     // vbr quality\n230     // we write it, because some (broken) tools always expect it to be present\n231     avio_wb32(dyn_ctx, 0);\n232\n233     // encoder short version string\n234     if (enc) {\n235         uint8_t encoder_str[9] = { 0 };\n236         memcpy(encoder_str, enc->value, FFMIN(strlen(enc->value), sizeof(encoder_str)));\n237         avio_write(dyn_ctx, encoder_str, sizeof(encoder_str));\n238     } else\n239         ffio_fill(dyn_ctx, 0, 9);\n240\n241     avio_w8(dyn_ctx, 0);      // tag revision 0 / unknown vbr method\n242     avio_w8(dyn_ctx, 0);      // unknown lowpass filter value\n243     ffio_fill(dyn_ctx, 0, 8); // empty replaygain fields\n244     avio_w8(dyn_ctx, 0);      // unknown encoding flags\n245     avio_w8(dyn_ctx, 0);      // unknown abr/minimal bitrate\n246\n247     // encoder delay\n248     if (par->initial_padding >= 1 << 12 ||\n249         par->trailing_padding >= 1 << 12) {\n250         av_log(s, AV_LOG_WARNING, \"Too many samples of padding.\\n\");\n251         avio_wb24(dyn_ctx, 0);\n252     } else {\n253         avio_wb24(dyn_ctx, par->initial_padding << 12 | par->trailing_padding);\n254     }\n255\n256     avio_w8(dyn_ctx,   0); // misc\n257     avio_w8(dyn_ctx,   0); // mp3gain\n258     avio_wb16(dyn_ctx, 0); // preset\n259\n260     // audio length and CRCs (will be updated later)\n261     avio_wb32(dyn_ctx, 0); // music length\n262     avio_wb16(dyn_ctx, 0); // music crc\n263     avio_wb16(dyn_ctx, 0); // tag crc\n264\n265     ffio_fill(dyn_ctx, 0, mpah.frame_size - bytes_needed);\n266\n267     mp3->xing_frame_size   = avio_close_dyn_buf(dyn_ctx, &mp3->xing_frame);\n268     mp3->xing_frame_offset = avio_tell(s->pb);\n269     avio_write(s->pb, mp3->xing_frame, mp3->xing_frame_size);\n270\n271     mp3->audio_size = mp3->xing_frame_size;\n272 }"
                    },
                    {
                        "file_path": "/libavformat/mp3enc.c",
                        "function_body": "334 static int mp3_queue_flush(AVFormatContext *s)\n335 {\n336     MP3Context *mp3 = s->priv_data;\n337     AVPacketList *pktl;\n338     int ret = 0, write = 1;\n339\n340     ff_id3v2_finish(&mp3->id3, s->pb);\n341     mp3_write_xing(s);\n342\n343     while ((pktl = mp3->queue)) {\n344         if (write && (ret = mp3_write_audio_packet(s, &pktl->pkt)) < 0)\n345             write = 0;\n346         av_packet_unref(&pktl->pkt);\n347         mp3->queue = pktl->next;\n348         av_freep(&pktl);\n349     }\n350     mp3->queue_end = NULL;\n351     return ret;\n352 }"
                    }
                ]
            }
        ],
        "sink": "header |= (srate_idx << 2) << 8;",
        "final_sink": "header |= (srate_idx << 2) << 8;"
    },
    {
        "prt": "soi_pos",
        "function_call": [
            "static int mxg_update_cache(AVFormatContext *s, unsigned int cache_size)\n{\n    MXGContext *mxg = s->priv_data;\n    unsigned int current_pos = mxg->buffer_ptr - mxg->buffer;\n    unsigned int soi_pos;\n    int ret;\n\n    /* reallocate internal buffer */\n    if (current_pos > current_pos + cache_size)\n        return AVERROR(ENOMEM);\n    if (mxg->soi_ptr) soi_pos = mxg->soi_ptr - mxg->buffer;\n    mxg->buffer = av_fast_realloc(mxg->buffer, &mxg->buffer_size,\n                                  current_pos + cache_size +\n                                  AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!mxg->buffer)\n        return AVERROR(ENOMEM);\n    mxg->buffer_ptr = mxg->buffer + current_pos;\n    if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;\n\n    /* get data */\n    ret = avio_read(s->pb, mxg->buffer_ptr + mxg->cache_size,\n                     cache_size - mxg->cache_size);\n    if (ret < 0)\n        return ret;\n\n    mxg->cache_size += ret;\n\n    return ret;\n}"
        ],
        "source": [
            "    unsigned int soi_pos;"
        ],
        "index": 15,
        "location": {
            "file_path": "libavformat/mxg.c",
            "region": {
                "startLine": 117,
                "startColumn": 52,
                "endColumn": 59
            },
            "context": {
                "startLine": 115,
                "endLine": 119,
                "snippet": {
                    "text": "    if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/mxg.c",
                        "function_body": "100 static int mxg_update_cache(AVFormatContext *s, unsigned int cache_size)\n101 {\n102     MXGContext *mxg = s->priv_data;\n103     unsigned int current_pos = mxg->buffer_ptr - mxg->buffer;\n104     unsigned int soi_pos;\n105     int ret;\n106\n107     /* reallocate internal buffer */\n108     if (current_pos > current_pos + cache_size)\n109         return AVERROR(ENOMEM);\n110     if (mxg->soi_ptr) soi_pos = mxg->soi_ptr - mxg->buffer;\n111     mxg->buffer = av_fast_realloc(mxg->buffer, &mxg->buffer_size,\n112                                   current_pos + cache_size +\n113                                   AV_INPUT_BUFFER_PADDING_SIZE);\n114     if (!mxg->buffer)\n115         return AVERROR(ENOMEM);\n116     mxg->buffer_ptr = mxg->buffer + current_pos;\n117     if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;\n118\n119     /* get data */\n120     ret = avio_read(s->pb, mxg->buffer_ptr + mxg->cache_size,\n121                      cache_size - mxg->cache_size);\n122     if (ret < 0)\n123         return ret;\n124\n125     mxg->cache_size += ret;\n126\n127     return ret;\n128 }"
                    },
                    {
                        "file_path": "/libavformat/mxg.c",
                        "function_body": "130 static int mxg_read_packet(AVFormatContext *s, AVPacket *pkt)\n131 {\n132     int ret;\n133     unsigned int size;\n134     uint8_t *startmarker_ptr, *end, *search_end, marker;\n135     MXGContext *mxg = s->priv_data;\n136\n137     while (!s->pb->eof_reached && !s->pb->error){\n138         if (mxg->cache_size <= OVERREAD_SIZE) {\n139             /* update internal buffer */\n140             ret = mxg_update_cache(s, DEFAULT_PACKET_SIZE + OVERREAD_SIZE);\n141             if (ret < 0)\n142                 return ret;\n143         }\n144         end = mxg->buffer_ptr + mxg->cache_size;\n145\n146         /* find start marker - 0xff */\n147         if (mxg->cache_size > OVERREAD_SIZE) {\n148             search_end = end - OVERREAD_SIZE;\n149             startmarker_ptr = mxg_find_startmarker(mxg->buffer_ptr, search_end);\n150         } else {\n151             search_end = end;\n152             startmarker_ptr = mxg_find_startmarker(mxg->buffer_ptr, search_end);\n153             if (startmarker_ptr >= search_end - 1 ||\n154                 *(startmarker_ptr + 1) != EOI) break;\n155         }\n156\n157         if (startmarker_ptr != search_end) { /* start marker found */\n158             marker = *(startmarker_ptr + 1);\n159             mxg->buffer_ptr = startmarker_ptr + 2;\n160             mxg->cache_size = end - mxg->buffer_ptr;\n161\n162             if (marker == SOI) {\n163                 mxg->soi_ptr = startmarker_ptr;\n164             } else if (marker == EOI) {\n165                 if (!mxg->soi_ptr) {\n166                     av_log(s, AV_LOG_WARNING, \"Found EOI before SOI, skipping\\n\");\n167                     continue;\n168                 }\n169\n170                 pkt->pts = pkt->dts = mxg->dts;\n171                 pkt->stream_index = 0;\n172                 pkt->buf  = NULL;\n173                 pkt->size = mxg->buffer_ptr - mxg->soi_ptr;\n174                 pkt->data = mxg->soi_ptr;\n175\n176                 if (mxg->soi_ptr - mxg->buffer > mxg->cache_size) {\n177                     if (mxg->cache_size > 0) {\n178                         memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);\n179                     }\n180\n181                     mxg->buffer_ptr = mxg->buffer;\n182                 }\n183                 mxg->soi_ptr = 0;\n184\n185                 return pkt->size;\n186             } else if ( (SOF0 <= marker && marker <= SOF15) ||\n187                         (SOS  <= marker && marker <= COM) ) {\n188                 /* all other markers that start marker segment also contain\n189                    length value (see specification for JPEG Annex B.1) */\n190                 size = AV_RB16(mxg->buffer_ptr);\n191                 if (size < 2)\n192                     return AVERROR(EINVAL);\n193\n194                 if (mxg->cache_size < size) {\n195                     ret = mxg_update_cache(s, size);\n196                     if (ret < 0)\n197                         return ret;\n198                     startmarker_ptr = mxg->buffer_ptr - 2;\n199                     mxg->cache_size = 0;\n200                 } else {\n201                     mxg->cache_size -= size;\n202                 }\n203\n204                 mxg->buffer_ptr += size;\n205\n206                 if (marker == APP13 && size >= 16) { /* audio data */\n207                     /* time (GMT) of first sample in usec since 1970, little-endian */\n208                     pkt->pts = pkt->dts = AV_RL64(startmarker_ptr + 8);\n209                     pkt->stream_index = 1;\n210                     pkt->buf  = NULL;\n211                     pkt->size = size - 14;\n212                     pkt->data = startmarker_ptr + 16;\n213\n214                     if (startmarker_ptr - mxg->buffer > mxg->cache_size) {\n215                         if (mxg->cache_size > 0) {\n216                             memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);\n217                         }\n218                         mxg->buffer_ptr = mxg->buffer;\n219                     }\n220\n221                     return pkt->size;\n222                 } else if (marker == COM && size >= 18 &&\n223                            !strncmp(startmarker_ptr + 4, \"MXF\", 3)) {\n224                     /* time (GMT) of video frame in usec since 1970, little-endian */\n225                     mxg->dts = AV_RL64(startmarker_ptr + 12);\n226                 }\n227             }\n228         } else {\n229             /* start marker not found */\n230             mxg->buffer_ptr = search_end;\n231             mxg->cache_size = OVERREAD_SIZE;\n232         }\n233     }\n234\n235     return AVERROR_EOF;\n236 }"
                    }
                ]
            }
        ],
        "sink": "if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;",
        "final_sink": "if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;"
    },
    {
        "prt": "len2",
        "function_call": [
            "static int rm_assemble_video_frame(AVFormatContext *s, AVIOContext *pb,\n                                   RMDemuxContext *rm, RMStream *vst,\n                                   AVPacket *pkt, int len, int *pseq,\n                                   int64_t *timestamp)\n{\n    int hdr, seq, pic_num, len2, pos;\n    int type;\n\n    hdr = avio_r8(pb); len--;\n    type = hdr >> 6;\n\n    if(type != 3){  // not frame as a part of packet\n        seq = avio_r8(pb); len--;\n    }\n    if(type != 1){  // not whole frame\n        len2 = get_num(pb, &len);\n        pos  = get_num(pb, &len);\n        pic_num = avio_r8(pb); len--;\n    }\n    if(len<0)\n        return -1;\n    rm->remaining_len = len;\n    if(type&1){     // frame, not slice\n        if(type == 3){  // frame as a part of packet\n            len= len2;\n            *timestamp = pos;\n        }\n        if(rm->remaining_len < len)\n            return -1;\n        rm->remaining_len -= len;\n        if(av_new_packet(pkt, len + 9) < 0)\n            return AVERROR(EIO);\n        pkt->data[0] = 0;\n        AV_WL32(pkt->data + 1, 1);\n        AV_WL32(pkt->data + 5, 0);\n        avio_read(pb, pkt->data + 9, len);\n        return 0;\n    }\n    //now we have to deal with single slice\n\n    *pseq = seq;\n    if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){\n        vst->slices = ((hdr & 0x3F) << 1) + 1;\n        vst->videobufsize = len2 + 8*vst->slices + 1;\n        av_packet_unref(&vst->pkt); //FIXME this should be output.\n        if(av_new_packet(&vst->pkt, vst->videobufsize) < 0)\n            return AVERROR(ENOMEM);\n        vst->videobufpos = 8*vst->slices + 1;\n        vst->cur_slice = 0;\n        vst->curpic_num = pic_num;\n        vst->pktpos = avio_tell(pb);\n    }\n    if(type == 2)\n        len = FFMIN(len, pos);\n\n    if(++vst->cur_slice > vst->slices)\n        return 1;\n    AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1);\n    AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1);\n    if(vst->videobufpos + len > vst->videobufsize)\n        return 1;\n    if (avio_read(pb, vst->pkt.data + vst->videobufpos, len) != len)\n        return AVERROR(EIO);\n    vst->videobufpos += len;\n    rm->remaining_len-= len;\n\n    if (type == 2 || vst->videobufpos == vst->videobufsize) {\n        vst->pkt.data[0] = vst->cur_slice-1;\n        *pkt= vst->pkt;\n        vst->pkt.data= NULL;\n        vst->pkt.size= 0;\n        vst->pkt.buf = NULL;\n        if(vst->slices != vst->cur_slice) //FIXME find out how to set slices correct from the begin\n            memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices,\n                vst->videobufpos - 1 - 8*vst->slices);\n        pkt->size = vst->videobufpos + 8*(vst->cur_slice - vst->slices);\n        pkt->pts = AV_NOPTS_VALUE;\n        pkt->pos = vst->pktpos;\n        vst->slices = 0;\n        return 0;\n    }\n\n    return 1;\n}"
        ],
        "source": [
            "    int hdr, seq, pic_num, len2, pos;"
        ],
        "index": 16,
        "location": {
            "file_path": "libavformat/rmdec.c",
            "region": {
                "startLine": 643,
                "startColumn": 18,
                "endColumn": 22
            },
            "context": {
                "startLine": 641,
                "endLine": 645,
                "snippet": {
                    "text": "            len= len2;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/rmdec.c",
                        "function_body": "619 static int rm_assemble_video_frame(AVFormatContext *s, AVIOContext *pb,\n620                                    RMDemuxContext *rm, RMStream *vst,\n621                                    AVPacket *pkt, int len, int *pseq,\n622                                    int64_t *timestamp)\n623 {\n624     int hdr, seq, pic_num, len2, pos;\n625     int type;\n626\n627     hdr = avio_r8(pb); len--;\n628     type = hdr >> 6;\n629\n630     if(type != 3){  // not frame as a part of packet\n631         seq = avio_r8(pb); len--;\n632     }\n633     if(type != 1){  // not whole frame\n634         len2 = get_num(pb, &len);\n635         pos  = get_num(pb, &len);\n636         pic_num = avio_r8(pb); len--;\n637     }\n638     if(len<0)\n639         return -1;\n640     rm->remaining_len = len;\n641     if(type&1){     // frame, not slice\n642         if(type == 3){  // frame as a part of packet\n643             len= len2;\n644             *timestamp = pos;\n645         }\n646         if(rm->remaining_len < len)\n647             return -1;\n648         rm->remaining_len -= len;\n649         if(av_new_packet(pkt, len + 9) < 0)\n650             return AVERROR(EIO);\n651         pkt->data[0] = 0;\n652         AV_WL32(pkt->data + 1, 1);\n653         AV_WL32(pkt->data + 5, 0);\n654         avio_read(pb, pkt->data + 9, len);\n655         return 0;\n656     }\n657     //now we have to deal with single slice\n658\n659     *pseq = seq;\n660     if((seq & 0x7F) == 1 || vst->curpic_num != pic_num){\n661         vst->slices = ((hdr & 0x3F) << 1) + 1;\n662         vst->videobufsize = len2 + 8*vst->slices + 1;\n663         av_packet_unref(&vst->pkt); //FIXME this should be output.\n664         if(av_new_packet(&vst->pkt, vst->videobufsize) < 0)\n665             return AVERROR(ENOMEM);\n666         vst->videobufpos = 8*vst->slices + 1;\n667         vst->cur_slice = 0;\n668         vst->curpic_num = pic_num;\n669         vst->pktpos = avio_tell(pb);\n670     }\n671     if(type == 2)\n672         len = FFMIN(len, pos);\n673\n674     if(++vst->cur_slice > vst->slices)\n675         return 1;\n676     AV_WL32(vst->pkt.data - 7 + 8*vst->cur_slice, 1);\n677     AV_WL32(vst->pkt.data - 3 + 8*vst->cur_slice, vst->videobufpos - 8*vst->slices - 1);\n678     if(vst->videobufpos + len > vst->videobufsize)\n679         return 1;\n680     if (avio_read(pb, vst->pkt.data + vst->videobufpos, len) != len)\n681         return AVERROR(EIO);\n682     vst->videobufpos += len;\n683     rm->remaining_len-= len;\n684\n685     if (type == 2 || vst->videobufpos == vst->videobufsize) {\n686         vst->pkt.data[0] = vst->cur_slice-1;\n687         *pkt= vst->pkt;\n688         vst->pkt.data= NULL;\n689         vst->pkt.size= 0;\n690         vst->pkt.buf = NULL;\n691         if(vst->slices != vst->cur_slice) //FIXME find out how to set slices correct from the begin\n692             memmove(pkt->data + 1 + 8*vst->cur_slice, pkt->data + 1 + 8*vst->slices,\n693                 vst->videobufpos - 1 - 8*vst->slices);\n694         pkt->size = vst->videobufpos + 8*(vst->cur_slice - vst->slices);\n695         pkt->pts = AV_NOPTS_VALUE;\n696         pkt->pos = vst->pktpos;\n697         vst->slices = 0;\n698         return 0;\n699     }\n700\n701     return 1;\n702 }"
                    },
                    {
                        "file_path": "/libavformat/rmdec.c",
                        "function_body": "720 ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n721                     AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n722                     int *seq, int flags, int64_t timestamp)\n723 {\n724     RMDemuxContext *rm = s->priv_data;\n725     int ret;\n726\n727     if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n728         rm->current_stream= st->id;\n729         if(rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp))\n730             return -1; //got partial frame\n731     } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n732         if ((ast->deint_id == DEINT_ID_GENR) ||\n733             (ast->deint_id == DEINT_ID_INT4) ||\n734             (ast->deint_id == DEINT_ID_SIPR)) {\n735             int x;\n736             int sps = ast->sub_packet_size;\n737             int cfs = ast->coded_framesize;\n738             int h = ast->sub_packet_h;\n739             int y = ast->sub_packet_cnt;\n740             int w = ast->audio_framesize;\n741\n742             if (flags & 2)\n743                 y = ast->sub_packet_cnt = 0;\n744             if (!y)\n745                 ast->audiotimestamp = timestamp;\n746\n747             switch (ast->deint_id) {\n748                 case DEINT_ID_INT4:\n749                     for (x = 0; x < h/2; x++)\n750                         avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n751                     break;\n752                 case DEINT_ID_GENR:\n753                     for (x = 0; x < w/sps; x++)\n754                         avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n755                     break;\n756                 case DEINT_ID_SIPR:\n757                     avio_read(pb, ast->pkt.data + y * w, w);\n758                     break;\n759             }\n760\n761             if (++(ast->sub_packet_cnt) < h)\n762                 return -1;\n763             if (ast->deint_id == DEINT_ID_SIPR)\n764                 ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n765\n766              ast->sub_packet_cnt = 0;\n767              rm->audio_stream_num = st->index;\n768              rm->audio_pkt_cnt = h * w / st->codecpar->block_align;\n769         } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n770                    (ast->deint_id == DEINT_ID_VBRS)) {\n771             int x;\n772             rm->audio_stream_num = st->index;\n773             ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n774             if (ast->sub_packet_cnt) {\n775                 for (x = 0; x < ast->sub_packet_cnt; x++)\n776                     ast->sub_packet_lengths[x] = avio_rb16(pb);\n777                 rm->audio_pkt_cnt = ast->sub_packet_cnt;\n778                 ast->audiotimestamp = timestamp;\n779             } else\n780                 return -1;\n781         } else {\n782             ret = av_get_packet(pb, pkt, len);\n783             if (ret < 0)\n784                 return ret;\n785             rm_ac3_swap_bytes(st, pkt);\n786         }\n787     } else {\n788         ret = av_get_packet(pb, pkt, len);\n789         if (ret < 0)\n790             return ret;\n791     }\n792\n793     pkt->stream_index = st->index;\n794\n795     pkt->pts = timestamp;\n796     if (flags & 2)\n797         pkt->flags |= AV_PKT_FLAG_KEY;\n798\n799     return st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n800 }"
                    }
                ]
            }
        ],
        "sink": "len= len2;",
        "final_sink": "len= len2;"
    },
    {
        "prt": "sps_end",
        "function_call": [
            "static char *extradata2psets(AVFormatContext *s, AVCodecParameters *par)\n{\n    char *psets, *p;\n    const uint8_t *r;\n    static const char pset_string[] = \"; sprop-parameter-sets=\";\n    static const char profile_string[] = \"; profile-level-id=\";\n    uint8_t *extradata = par->extradata;\n    int extradata_size = par->extradata_size;\n    uint8_t *tmpbuf = NULL;\n    const uint8_t *sps = NULL, *sps_end;\n\n    if (par->extradata_size > MAX_EXTRADATA_SIZE) {\n        av_log(s, AV_LOG_ERROR, \"Too much extradata!\\n\");\n\n        return NULL;\n    }\n    if (par->extradata[0] == 1) {\n        if (ff_avc_write_annexb_extradata(par->extradata, &extradata,\n                                          &extradata_size))\n            return NULL;\n        tmpbuf = extradata;\n    }\n\n    psets = av_mallocz(MAX_PSET_SIZE);\n    if (!psets) {\n        av_log(s, AV_LOG_ERROR, \"Cannot allocate memory for the parameter sets.\\n\");\n        av_free(tmpbuf);\n        return NULL;\n    }\n    memcpy(psets, pset_string, strlen(pset_string));\n    p = psets + strlen(pset_string);\n    r = ff_avc_find_startcode(extradata, extradata + extradata_size);\n    while (r < extradata + extradata_size) {\n        const uint8_t *r1;\n        uint8_t nal_type;\n\n        while (!*(r++));\n        nal_type = *r & 0x1f;\n        r1 = ff_avc_find_startcode(r, extradata + extradata_size);\n        if (nal_type != 7 && nal_type != 8) { /* Only output SPS and PPS */\n            r = r1;\n            continue;\n        }\n        if (p != (psets + strlen(pset_string))) {\n            *p = ',';\n            p++;\n        }\n        if (!sps) {\n            sps = r;\n            sps_end = r1;\n        }\n        if (!av_base64_encode(p, MAX_PSET_SIZE - (p - psets), r, r1 - r)) {\n            av_log(s, AV_LOG_ERROR, \"Cannot Base64-encode %td %td!\\n\", MAX_PSET_SIZE - (p - psets), r1 - r);\n            av_free(psets);\n            av_free(tmpbuf);\n\n            return NULL;\n        }\n        p += strlen(p);\n        r = r1;\n    }\n    if (sps && sps_end - sps >= 4) {\n        memcpy(p, profile_string, strlen(profile_string));\n        p += strlen(p);\n        ff_data_to_hex(p, sps + 1, 3, 0);\n        p[6] = '\\0';\n    }\n    av_free(tmpbuf);\n\n    return psets;\n}"
        ],
        "source": [
            "    const uint8_t *sps = NULL, *sps_end;"
        ],
        "index": 17,
        "location": {
            "file_path": "libavformat/sdp.c",
            "region": {
                "startLine": 215,
                "startColumn": 16,
                "endColumn": 23
            },
            "context": {
                "startLine": 213,
                "endLine": 217,
                "snippet": {
                    "text": "    if (sps && sps_end - sps >= 4) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/sdp.c",
                        "function_body": "154 static char *extradata2psets(AVFormatContext *s, AVCodecParameters *par)\n155 {\n156     char *psets, *p;\n157     const uint8_t *r;\n158     static const char pset_string[] = \"; sprop-parameter-sets=\";\n159     static const char profile_string[] = \"; profile-level-id=\";\n160     uint8_t *extradata = par->extradata;\n161     int extradata_size = par->extradata_size;\n162     uint8_t *tmpbuf = NULL;\n163     const uint8_t *sps = NULL, *sps_end;\n164\n165     if (par->extradata_size > MAX_EXTRADATA_SIZE) {\n166         av_log(s, AV_LOG_ERROR, \"Too much extradata!\\n\");\n167\n168         return NULL;\n169     }\n170     if (par->extradata[0] == 1) {\n171         if (ff_avc_write_annexb_extradata(par->extradata, &extradata,\n172                                           &extradata_size))\n173             return NULL;\n174         tmpbuf = extradata;\n175     }\n176\n177     psets = av_mallocz(MAX_PSET_SIZE);\n178     if (!psets) {\n179         av_log(s, AV_LOG_ERROR, \"Cannot allocate memory for the parameter sets.\\n\");\n180         av_free(tmpbuf);\n181         return NULL;\n182     }\n183     memcpy(psets, pset_string, strlen(pset_string));\n184     p = psets + strlen(pset_string);\n185     r = ff_avc_find_startcode(extradata, extradata + extradata_size);\n186     while (r < extradata + extradata_size) {\n187         const uint8_t *r1;\n188         uint8_t nal_type;\n189\n190         while (!*(r++));\n191         nal_type = *r & 0x1f;\n192         r1 = ff_avc_find_startcode(r, extradata + extradata_size);\n193         if (nal_type != 7 && nal_type != 8) { /* Only output SPS and PPS */\n194             r = r1;\n195             continue;\n196         }\n197         if (p != (psets + strlen(pset_string))) {\n198             *p = ',';\n199             p++;\n200         }\n201         if (!sps) {\n202             sps = r;\n203             sps_end = r1;\n204         }\n205         if (!av_base64_encode(p, MAX_PSET_SIZE - (p - psets), r, r1 - r)) {\n206             av_log(s, AV_LOG_ERROR, \"Cannot Base64-encode %td %td!\\n\", MAX_PSET_SIZE - (p - psets), r1 - r);\n207             av_free(psets);\n208             av_free(tmpbuf);\n209\n210             return NULL;\n211         }\n212         p += strlen(p);\n213         r = r1;\n214     }\n215     if (sps && sps_end - sps >= 4) {\n216         memcpy(p, profile_string, strlen(profile_string));\n217         p += strlen(p);\n218         ff_data_to_hex(p, sps + 1, 3, 0);\n219         p[6] = '\\0';\n220     }\n221     av_free(tmpbuf);\n222\n223     return psets;\n224 }"
                    },
                    {
                        "file_path": "/libavformat/sdp.c",
                        "function_body": "482 static char *sdp_write_media_attributes(char *buff, int size, AVCodecParameters *p, int payload_type, AVFormatContext *fmt)\n483 {\n484     char *config = NULL;\n485\n486     switch (p->codec_id) {\n487         case AV_CODEC_ID_H264: {\n488             int mode = 1;\n489             if (fmt && fmt->oformat && fmt->oformat->priv_class &&\n490                 av_opt_flag_is_set(fmt->priv_data, \"rtpflags\", \"h264_mode0\"))\n491                 mode = 0;\n492             if (p->extradata_size) {\n493                 config = extradata2psets(fmt, p);\n494             }\n495             av_strlcatf(buff, size, \"a=rtpmap:%d H264/90000\\r\\n\"\n496                                     \"a=fmtp:%d packetization-mode=%d%s\\r\\n\",\n497                                      payload_type,\n498                                      payload_type, mode, config ? config : \"\");\n499             break;\n500         }\n501         case AV_CODEC_ID_H261:\n502         {\n503             const char *pic_fmt = NULL;\n504             /* only QCIF and CIF are specified as supported in RFC 4587 */\n505             if (p->width == 176 && p->height == 144)\n506                 pic_fmt = \"QCIF=1\";\n507             else if (p->width == 352 && p->height == 288)\n508                 pic_fmt = \"CIF=1\";\n509             if (payload_type >= RTP_PT_PRIVATE)\n510                 av_strlcatf(buff, size, \"a=rtpmap:%d H261/90000\\r\\n\", payload_type);\n511             if (pic_fmt)\n512                 av_strlcatf(buff, size, \"a=fmtp:%d %s\\r\\n\", payload_type, pic_fmt);\n513             break;\n514         }\n515         case AV_CODEC_ID_H263:\n516         case AV_CODEC_ID_H263P:\n517             /* a=framesize is required by 3GPP TS 26.234 (PSS). It\n518              * actually specifies the maximum video size, but we only know\n519              * the current size. This is required for playback on Android\n520              * stagefright and on Samsung bada. */\n521             if (!fmt || !fmt->oformat->priv_class ||\n522                 !av_opt_flag_is_set(fmt->priv_data, \"rtpflags\", \"rfc2190\") ||\n523                 p->codec_id == AV_CODEC_ID_H263P)\n524             av_strlcatf(buff, size, \"a=rtpmap:%d H263-2000/90000\\r\\n\"\n525                                     \"a=framesize:%d %d-%d\\r\\n\",\n526                                     payload_type,\n527                                     payload_type, p->width, p->height);\n528             break;\n529         case AV_CODEC_ID_HEVC:\n530             if (p->extradata_size)\n531                 config = extradata2psets_hevc(p);\n532             av_strlcatf(buff, size, \"a=rtpmap:%d H265/90000\\r\\n\", payload_type);\n533             if (config)\n534                 av_strlcatf(buff, size, \"a=fmtp:%d %s\\r\\n\",\n535                                          payload_type, config);\n536             break;\n537         case AV_CODEC_ID_MPEG4:\n538             if (p->extradata_size) {\n539                 config = extradata2config(fmt, p);\n540             }\n541             av_strlcatf(buff, size, \"a=rtpmap:%d MP4V-ES/90000\\r\\n\"\n542                                     \"a=fmtp:%d profile-level-id=1%s\\r\\n\",\n543                                      payload_type,\n544                                      payload_type, config ? config : \"\");\n545             break;\n546         case AV_CODEC_ID_AAC:\n547             if (fmt && fmt->oformat->priv_class &&\n548                 av_opt_flag_is_set(fmt->priv_data, \"rtpflags\", \"latm\")) {\n549                 config = latm_context2config(fmt, p);\n550                 if (!config)\n551                     return NULL;\n552                 av_strlcatf(buff, size, \"a=rtpmap:%d MP4A-LATM/%d/%d\\r\\n\"\n553                                         \"a=fmtp:%d profile-level-id=%d;cpresent=0;config=%s\\r\\n\",\n554                                          payload_type, p->sample_rate, p->channels,\n555                                          payload_type, latm_context2profilelevel(p), config);\n556             } else {\n557                 if (p->extradata_size) {\n558                     config = extradata2config(fmt, p);\n559                 } else {\n560                     /* FIXME: maybe we can forge config information based on the\n561                      *        codec parameters...\n562                      */\n563                     av_log(fmt, AV_LOG_ERROR, \"AAC with no global headers is currently not supported.\\n\");\n564                     return NULL;\n565                 }\n566                 if (!config) {\n567                     return NULL;\n568                 }\n569                 av_strlcatf(buff, size, \"a=rtpmap:%d MPEG4-GENERIC/%d/%d\\r\\n\"\n570                                         \"a=fmtp:%d profile-level-id=1;\"\n571                                         \"mode=AAC-hbr;sizelength=13;indexlength=3;\"\n572                                         \"indexdeltalength=3%s\\r\\n\",\n573                                          payload_type, p->sample_rate, p->channels,\n574                                          payload_type, config);\n575             }\n576             break;\n577         case AV_CODEC_ID_PCM_S16BE:\n578             if (payload_type >= RTP_PT_PRIVATE)\n579                 av_strlcatf(buff, size, \"a=rtpmap:%d L16/%d/%d\\r\\n\",\n580                                          payload_type,\n581                                          p->sample_rate, p->channels);\n582             break;\n583         case AV_CODEC_ID_PCM_MULAW:\n584             if (payload_type >= RTP_PT_PRIVATE)\n585                 av_strlcatf(buff, size, \"a=rtpmap:%d PCMU/%d/%d\\r\\n\",\n586                                          payload_type,\n587                                          p->sample_rate, p->channels);\n588             break;\n589         case AV_CODEC_ID_PCM_ALAW:\n590             if (payload_type >= RTP_PT_PRIVATE)\n591                 av_strlcatf(buff, size, \"a=rtpmap:%d PCMA/%d/%d\\r\\n\",\n592                                          payload_type,\n593                                          p->sample_rate, p->channels);\n594             break;\n595         case AV_CODEC_ID_AMR_NB:\n596             av_strlcatf(buff, size, \"a=rtpmap:%d AMR/%d/%d\\r\\n\"\n597                                     \"a=fmtp:%d octet-align=1\\r\\n\",\n598                                      payload_type, p->sample_rate, p->channels,\n599                                      payload_type);\n600             break;\n601         case AV_CODEC_ID_AMR_WB:\n602             av_strlcatf(buff, size, \"a=rtpmap:%d AMR-WB/%d/%d\\r\\n\"\n603                                     \"a=fmtp:%d octet-align=1\\r\\n\",\n604                                      payload_type, p->sample_rate, p->channels,\n605                                      payload_type);\n606             break;\n607         case AV_CODEC_ID_VORBIS:\n608             if (p->extradata_size)\n609                 config = xiph_extradata2config(fmt, p);\n610             else\n611                 av_log(fmt, AV_LOG_ERROR, \"Vorbis configuration info missing\\n\");\n612             if (!config)\n613                 return NULL;\n614\n615             av_strlcatf(buff, size, \"a=rtpmap:%d vorbis/%d/%d\\r\\n\"\n616                                     \"a=fmtp:%d configuration=%s\\r\\n\",\n617                                     payload_type, p->sample_rate, p->channels,\n618                                     payload_type, config);\n619             break;\n620         case AV_CODEC_ID_THEORA: {\n621             const char *pix_fmt;\n622             switch (p->format) {\n623             case AV_PIX_FMT_YUV420P:\n624                 pix_fmt = \"YCbCr-4:2:0\";\n625                 break;\n626             case AV_PIX_FMT_YUV422P:\n627                 pix_fmt = \"YCbCr-4:2:2\";\n628                 break;\n629             case AV_PIX_FMT_YUV444P:\n630                 pix_fmt = \"YCbCr-4:4:4\";\n631                 break;\n632             default:\n633                 av_log(fmt, AV_LOG_ERROR, \"Unsupported pixel format.\\n\");\n634                 return NULL;\n635             }\n636\n637             if (p->extradata_size)\n638                 config = xiph_extradata2config(fmt, p);\n639             else\n640                 av_log(fmt, AV_LOG_ERROR, \"Theora configuation info missing\\n\");\n641             if (!config)\n642                 return NULL;\n643\n644             av_strlcatf(buff, size, \"a=rtpmap:%d theora/90000\\r\\n\"\n645                                     \"a=fmtp:%d delivery-method=inline; \"\n646                                     \"width=%d; height=%d; sampling=%s; \"\n647                                     \"configuration=%s\\r\\n\",\n648                                     payload_type, payload_type,\n649                                     p->width, p->height, pix_fmt, config);\n650             break;\n651         }\n652         case AV_CODEC_ID_VP8:\n653             av_strlcatf(buff, size, \"a=rtpmap:%d VP8/90000\\r\\n\",\n654                                      payload_type);\n655             break;\n656         case AV_CODEC_ID_MJPEG:\n657             if (payload_type >= RTP_PT_PRIVATE)\n658                 av_strlcatf(buff, size, \"a=rtpmap:%d JPEG/90000\\r\\n\",\n659                                          payload_type);\n660             break;\n661         case AV_CODEC_ID_ADPCM_G722:\n662             if (payload_type >= RTP_PT_PRIVATE)\n663                 av_strlcatf(buff, size, \"a=rtpmap:%d G722/%d/%d\\r\\n\",\n664                                          payload_type,\n665                                          8000, p->channels);\n666             break;\n667         case AV_CODEC_ID_ADPCM_G726: {\n668             if (payload_type >= RTP_PT_PRIVATE)\n669                 av_strlcatf(buff, size, \"a=rtpmap:%d G726-%d/%d\\r\\n\",\n670                                          payload_type,\n671                                          p->bits_per_coded_sample*8,\n672                                          p->sample_rate);\n673             break;\n674         }\n675         case AV_CODEC_ID_ILBC:\n676             av_strlcatf(buff, size, \"a=rtpmap:%d iLBC/%d\\r\\n\"\n677                                     \"a=fmtp:%d mode=%d\\r\\n\",\n678                                      payload_type, p->sample_rate,\n679                                      payload_type, p->block_align == 38 ? 20 : 30);\n680             break;\n681         case AV_CODEC_ID_SPEEX:\n682             av_strlcatf(buff, size, \"a=rtpmap:%d speex/%d\\r\\n\",\n683                                      payload_type, p->sample_rate);\n684             break;\n685         case AV_CODEC_ID_OPUS:\n686             /* The opus RTP draft says that all opus streams MUST be declared\n687                as stereo, to avoid negotiation failures. The actual number of\n688                channels can change on a packet-by-packet basis. The number of\n689                channels a receiver prefers to receive or a sender plans to send\n690                can be declared via fmtp parameters (both default to mono), but\n691                receivers MUST be able to receive and process stereo packets. */\n692             av_strlcatf(buff, size, \"a=rtpmap:%d opus/48000/2\\r\\n\",\n693                                      payload_type);\n694             if (p->channels == 2) {\n695                 av_strlcatf(buff, size, \"a=fmtp:%d sprop-stereo=1\\r\\n\",\n696                                          payload_type);\n697             }\n698             break;\n699         default:\n700             /* Nothing special to do here... */\n701             break;\n702     }\n703\n704     av_free(config);\n705\n706     return buff;\n707 }"
                    }
                ]
            }
        ],
        "sink": "if (sps && sps_end - sps >= 4) {",
        "final_sink": "if (sps && sps_end - sps >= 4) {"
    },
    {
        "prt": "cur_pitch_val",
        "function_call": [
            "static int synth_frame(AVCodecContext *ctx, BitstreamContext *bc,\n                       int frame_idx, float *samples,\n                       const double *lsps, const double *prev_lsps,\n                       float *excitation, float *synth)\n{\n    WMAVoiceContext *s = ctx->priv_data;\n    int n, n_blocks_x2, log_n_blocks_x2, cur_pitch_val;\n    int pitch[MAX_BLOCKS], last_block_pitch;\n\n    /* Parse frame type (\"frame header\"), see frame_descs */\n    int bd_idx = s->vbm_tree[bitstream_read_vlc(bc, frame_type_vlc.table, 6, 3)], block_nsamples;\n\n    if (bd_idx < 0) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"Invalid frame type VLC code, skipping\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    block_nsamples = MAX_FRAMESIZE / frame_descs[bd_idx].n_blocks;\n\n    /* Pitch calculation for ACB_TYPE_ASYMMETRIC (\"pitch-per-frame\") */\n    if (frame_descs[bd_idx].acb_type == ACB_TYPE_ASYMMETRIC) {\n        /* Pitch is provided per frame, which is interpreted as the pitch of\n         * the last sample of the last block of this frame. We can interpolate\n         * the pitch of other blocks (and even pitch-per-sample) by gradually\n         * incrementing/decrementing prev_frame_pitch to cur_pitch_val. */\n        n_blocks_x2      = frame_descs[bd_idx].n_blocks << 1;\n        log_n_blocks_x2  = frame_descs[bd_idx].log_n_blocks + 1;\n        cur_pitch_val    = s->min_pitch_val + bitstream_read(bc, s->pitch_nbits);\n        cur_pitch_val    = FFMIN(cur_pitch_val, s->max_pitch_val - 1);\n        if (s->last_acb_type == ACB_TYPE_NONE ||\n            20 * abs(cur_pitch_val - s->last_pitch_val) >\n                (cur_pitch_val + s->last_pitch_val))\n            s->last_pitch_val = cur_pitch_val;\n\n        /* pitch per block */\n        for (n = 0; n < frame_descs[bd_idx].n_blocks; n++) {\n            int fac = n * 2 + 1;\n\n            pitch[n] = (MUL16(fac,                 cur_pitch_val) +\n                        MUL16((n_blocks_x2 - fac), s->last_pitch_val) +\n                        frame_descs[bd_idx].n_blocks) >> log_n_blocks_x2;\n        }\n\n        /* \"pitch-diff-per-sample\" for calculation of pitch per sample */\n        s->pitch_diff_sh16 =\n            ((cur_pitch_val - s->last_pitch_val) << 16) / MAX_FRAMESIZE;\n    }\n\n    /* Global gain (if silence) and pitch-adaptive window coordinates */\n    switch (frame_descs[bd_idx].fcb_type) {\n    case FCB_TYPE_SILENCE:\n        s->silence_gain = wmavoice_gain_silence[bitstream_read(bc, 8)];\n        break;\n    case FCB_TYPE_AW_PULSES:\n        aw_parse_coords(s, bc, pitch);\n        break;\n    }\n\n    for (n = 0; n < frame_descs[bd_idx].n_blocks; n++) {\n        int bl_pitch_sh2;\n\n        /* Pitch calculation for ACB_TYPE_HAMMING (\"pitch-per-block\") */\n        switch (frame_descs[bd_idx].acb_type) {\n        case ACB_TYPE_HAMMING: {\n            /* Pitch is given per block. Per-block pitches are encoded as an\n             * absolute value for the first block, and then delta values\n             * relative to this value) for all subsequent blocks. The scale of\n             * this pitch value is semi-logarithmic compared to its use in the\n             * decoder, so we convert it to normal scale also. */\n            int block_pitch,\n                t1 = (s->block_conv_table[1] - s->block_conv_table[0]) << 2,\n                t2 = (s->block_conv_table[2] - s->block_conv_table[1]) << 1,\n                t3 =  s->block_conv_table[3] - s->block_conv_table[2] + 1;\n\n            if (n == 0) {\n                block_pitch = bitstream_read(bc, s->block_pitch_nbits);\n            } else\n                block_pitch = last_block_pitch - s->block_delta_pitch_hrange +\n                              bitstream_read(bc, s->block_delta_pitch_nbits);\n            /* Convert last_ so that any next delta is within _range */\n            last_block_pitch = av_clip(block_pitch,\n                                       s->block_delta_pitch_hrange,\n                                       s->block_pitch_range -\n                                           s->block_delta_pitch_hrange);\n\n            /* Convert semi-log-style scale back to normal scale */\n            if (block_pitch < t1) {\n                bl_pitch_sh2 = (s->block_conv_table[0] << 2) + block_pitch;\n            } else {\n                block_pitch -= t1;\n                if (block_pitch < t2) {\n                    bl_pitch_sh2 =\n                        (s->block_conv_table[1] << 2) + (block_pitch << 1);\n                } else {\n                    block_pitch -= t2;\n                    if (block_pitch < t3) {\n                        bl_pitch_sh2 =\n                            (s->block_conv_table[2] + block_pitch) << 2;\n                    } else\n                        bl_pitch_sh2 = s->block_conv_table[3] << 2;\n                }\n            }\n            pitch[n] = bl_pitch_sh2 >> 2;\n            break;\n        }\n\n        case ACB_TYPE_ASYMMETRIC: {\n            bl_pitch_sh2 = pitch[n] << 2;\n            break;\n        }\n\n        default: // ACB_TYPE_NONE has no pitch\n            bl_pitch_sh2 = 0;\n            break;\n        }\n\n        synth_block(s, bc, n, block_nsamples, bl_pitch_sh2,\n                    lsps, prev_lsps, &frame_descs[bd_idx],\n                    &excitation[n * block_nsamples],\n                    &synth[n * block_nsamples]);\n    }\n\n    /* Averaging projection filter, if applicable. Else, just copy samples\n     * from synthesis buffer */\n    if (s->do_apf) {\n        double i_lsps[MAX_LSPS];\n        float lpcs[MAX_LSPS];\n\n        for (n = 0; n < s->lsps; n++) // LSF -> LSP\n            i_lsps[n] = cos(0.5 * (prev_lsps[n] + lsps[n]));\n        ff_acelp_lspd2lpc(i_lsps, lpcs, s->lsps >> 1);\n        postfilter(s, synth, samples, 80, lpcs,\n                   &s->zero_exc_pf[s->history_nsamples + MAX_FRAMESIZE * frame_idx],\n                   frame_descs[bd_idx].fcb_type, pitch[0]);\n\n        for (n = 0; n < s->lsps; n++) // LSF -> LSP\n            i_lsps[n] = cos(lsps[n]);\n        ff_acelp_lspd2lpc(i_lsps, lpcs, s->lsps >> 1);\n        postfilter(s, &synth[80], &samples[80], 80, lpcs,\n                   &s->zero_exc_pf[s->history_nsamples + MAX_FRAMESIZE * frame_idx + 80],\n                   frame_descs[bd_idx].fcb_type, pitch[0]);\n    } else\n        memcpy(samples, synth, 160 * sizeof(synth[0]));\n\n    /* Cache values for next frame */\n    s->frame_cntr++;\n    if (s->frame_cntr >= 0xFFFF) s->frame_cntr -= 0xFFFF; // i.e. modulo (%)\n    s->last_acb_type = frame_descs[bd_idx].acb_type;\n    switch (frame_descs[bd_idx].acb_type) {\n    case ACB_TYPE_NONE:\n        s->last_pitch_val = 0;\n        break;\n    case ACB_TYPE_ASYMMETRIC:\n        s->last_pitch_val = cur_pitch_val;\n        break;\n    case ACB_TYPE_HAMMING:\n        s->last_pitch_val = pitch[frame_descs[bd_idx].n_blocks - 1];\n        break;\n    }\n\n    return 0;\n}"
        ],
        "source": [
            "    int n, n_blocks_x2, log_n_blocks_x2, cur_pitch_val;"
        ],
        "index": 18,
        "location": {
            "file_path": "libavcodec/wmavoice.c",
            "region": {
                "startLine": 1607,
                "startColumn": 29,
                "endColumn": 42
            },
            "context": {
                "startLine": 1605,
                "endLine": 1609,
                "snippet": {
                    "text": "        s->last_pitch_val = cur_pitch_val;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "1453 static int synth_frame(AVCodecContext *ctx, BitstreamContext *bc,\n1454                        int frame_idx, float *samples,\n1455                        const double *lsps, const double *prev_lsps,\n1456                        float *excitation, float *synth)\n1457 {\n1458     WMAVoiceContext *s = ctx->priv_data;\n1459     int n, n_blocks_x2, log_n_blocks_x2, cur_pitch_val;\n1460     int pitch[MAX_BLOCKS], last_block_pitch;\n1461\n1462     /* Parse frame type (\"frame header\"), see frame_descs */\n1463     int bd_idx = s->vbm_tree[bitstream_read_vlc(bc, frame_type_vlc.table, 6, 3)], block_nsamples;\n1464\n1465     if (bd_idx < 0) {\n1466         av_log(ctx, AV_LOG_ERROR,\n1467                \"Invalid frame type VLC code, skipping\\n\");\n1468         return AVERROR_INVALIDDATA;\n1469     }\n1470\n1471     block_nsamples = MAX_FRAMESIZE / frame_descs[bd_idx].n_blocks;\n1472\n1473     /* Pitch calculation for ACB_TYPE_ASYMMETRIC (\"pitch-per-frame\") */\n1474     if (frame_descs[bd_idx].acb_type == ACB_TYPE_ASYMMETRIC) {\n1475         /* Pitch is provided per frame, which is interpreted as the pitch of\n1476          * the last sample of the last block of this frame. We can interpolate\n1477          * the pitch of other blocks (and even pitch-per-sample) by gradually\n1478          * incrementing/decrementing prev_frame_pitch to cur_pitch_val. */\n1479         n_blocks_x2      = frame_descs[bd_idx].n_blocks << 1;\n1480         log_n_blocks_x2  = frame_descs[bd_idx].log_n_blocks + 1;\n1481         cur_pitch_val    = s->min_pitch_val + bitstream_read(bc, s->pitch_nbits);\n1482         cur_pitch_val    = FFMIN(cur_pitch_val, s->max_pitch_val - 1);\n1483         if (s->last_acb_type == ACB_TYPE_NONE ||\n1484             20 * abs(cur_pitch_val - s->last_pitch_val) >\n1485                 (cur_pitch_val + s->last_pitch_val))\n1486             s->last_pitch_val = cur_pitch_val;\n1487\n1488         /* pitch per block */\n1489         for (n = 0; n < frame_descs[bd_idx].n_blocks; n++) {\n1490             int fac = n * 2 + 1;\n1491\n1492             pitch[n] = (MUL16(fac,                 cur_pitch_val) +\n1493                         MUL16((n_blocks_x2 - fac), s->last_pitch_val) +\n1494                         frame_descs[bd_idx].n_blocks) >> log_n_blocks_x2;\n1495         }\n1496\n1497         /* \"pitch-diff-per-sample\" for calculation of pitch per sample */\n1498         s->pitch_diff_sh16 =\n1499             ((cur_pitch_val - s->last_pitch_val) << 16) / MAX_FRAMESIZE;\n1500     }\n1501\n1502     /* Global gain (if silence) and pitch-adaptive window coordinates */\n1503     switch (frame_descs[bd_idx].fcb_type) {\n1504     case FCB_TYPE_SILENCE:\n1505         s->silence_gain = wmavoice_gain_silence[bitstream_read(bc, 8)];\n1506         break;\n1507     case FCB_TYPE_AW_PULSES:\n1508         aw_parse_coords(s, bc, pitch);\n1509         break;\n1510     }\n1511\n1512     for (n = 0; n < frame_descs[bd_idx].n_blocks; n++) {\n1513         int bl_pitch_sh2;\n1514\n1515         /* Pitch calculation for ACB_TYPE_HAMMING (\"pitch-per-block\") */\n1516         switch (frame_descs[bd_idx].acb_type) {\n1517         case ACB_TYPE_HAMMING: {\n1518             /* Pitch is given per block. Per-block pitches are encoded as an\n1519              * absolute value for the first block, and then delta values\n1520              * relative to this value) for all subsequent blocks. The scale of\n1521              * this pitch value is semi-logarithmic compared to its use in the\n1522              * decoder, so we convert it to normal scale also. */\n1523             int block_pitch,\n1524                 t1 = (s->block_conv_table[1] - s->block_conv_table[0]) << 2,\n1525                 t2 = (s->block_conv_table[2] - s->block_conv_table[1]) << 1,\n1526                 t3 =  s->block_conv_table[3] - s->block_conv_table[2] + 1;\n1527\n1528             if (n == 0) {\n1529                 block_pitch = bitstream_read(bc, s->block_pitch_nbits);\n1530             } else\n1531                 block_pitch = last_block_pitch - s->block_delta_pitch_hrange +\n1532                               bitstream_read(bc, s->block_delta_pitch_nbits);\n1533             /* Convert last_ so that any next delta is within _range */\n1534             last_block_pitch = av_clip(block_pitch,\n1535                                        s->block_delta_pitch_hrange,\n1536                                        s->block_pitch_range -\n1537                                            s->block_delta_pitch_hrange);\n1538\n1539             /* Convert semi-log-style scale back to normal scale */\n1540             if (block_pitch < t1) {\n1541                 bl_pitch_sh2 = (s->block_conv_table[0] << 2) + block_pitch;\n1542             } else {\n1543                 block_pitch -= t1;\n1544                 if (block_pitch < t2) {\n1545                     bl_pitch_sh2 =\n1546                         (s->block_conv_table[1] << 2) + (block_pitch << 1);\n1547                 } else {\n1548                     block_pitch -= t2;\n1549                     if (block_pitch < t3) {\n1550                         bl_pitch_sh2 =\n1551                             (s->block_conv_table[2] + block_pitch) << 2;\n1552                     } else\n1553                         bl_pitch_sh2 = s->block_conv_table[3] << 2;\n1554                 }\n1555             }\n1556             pitch[n] = bl_pitch_sh2 >> 2;\n1557             break;\n1558         }\n1559\n1560         case ACB_TYPE_ASYMMETRIC: {\n1561             bl_pitch_sh2 = pitch[n] << 2;\n1562             break;\n1563         }\n1564\n1565         default: // ACB_TYPE_NONE has no pitch\n1566             bl_pitch_sh2 = 0;\n1567             break;\n1568         }\n1569\n1570         synth_block(s, bc, n, block_nsamples, bl_pitch_sh2,\n1571                     lsps, prev_lsps, &frame_descs[bd_idx],\n1572                     &excitation[n * block_nsamples],\n1573                     &synth[n * block_nsamples]);\n1574     }\n1575\n1576     /* Averaging projection filter, if applicable. Else, just copy samples\n1577      * from synthesis buffer */\n1578     if (s->do_apf) {\n1579         double i_lsps[MAX_LSPS];\n1580         float lpcs[MAX_LSPS];\n1581\n1582         for (n = 0; n < s->lsps; n++) // LSF -> LSP\n1583             i_lsps[n] = cos(0.5 * (prev_lsps[n] + lsps[n]));\n1584         ff_acelp_lspd2lpc(i_lsps, lpcs, s->lsps >> 1);\n1585         postfilter(s, synth, samples, 80, lpcs,\n1586                    &s->zero_exc_pf[s->history_nsamples + MAX_FRAMESIZE * frame_idx],\n1587                    frame_descs[bd_idx].fcb_type, pitch[0]);\n1588\n1589         for (n = 0; n < s->lsps; n++) // LSF -> LSP\n1590             i_lsps[n] = cos(lsps[n]);\n1591         ff_acelp_lspd2lpc(i_lsps, lpcs, s->lsps >> 1);\n1592         postfilter(s, &synth[80], &samples[80], 80, lpcs,\n1593                    &s->zero_exc_pf[s->history_nsamples + MAX_FRAMESIZE * frame_idx + 80],\n1594                    frame_descs[bd_idx].fcb_type, pitch[0]);\n1595     } else\n1596         memcpy(samples, synth, 160 * sizeof(synth[0]));\n1597\n1598     /* Cache values for next frame */\n1599     s->frame_cntr++;\n1600     if (s->frame_cntr >= 0xFFFF) s->frame_cntr -= 0xFFFF; // i.e. modulo (%)\n1601     s->last_acb_type = frame_descs[bd_idx].acb_type;\n1602     switch (frame_descs[bd_idx].acb_type) {\n1603     case ACB_TYPE_NONE:\n1604         s->last_pitch_val = 0;\n1605         break;\n1606     case ACB_TYPE_ASYMMETRIC:\n1607         s->last_pitch_val = cur_pitch_val;\n1608         break;\n1609     case ACB_TYPE_HAMMING:\n1610         s->last_pitch_val = pitch[frame_descs[bd_idx].n_blocks - 1];\n1611         break;\n1612     }\n1613\n1614     return 0;\n1615 }"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "1751 static int synth_superframe(AVCodecContext *ctx, AVFrame *frame,\n1752                             int *got_frame_ptr)\n1753 {\n1754     WMAVoiceContext *s = ctx->priv_data;\n1755     BitstreamContext *bc = &s->bc, s_bc;\n1756     int n, res, n_samples = 480;\n1757     double lsps[MAX_FRAMES][MAX_LSPS];\n1758     const double *mean_lsf = s->lsps == 16 ?\n1759         wmavoice_mean_lsf16[s->lsp_def_mode] : wmavoice_mean_lsf10[s->lsp_def_mode];\n1760     float excitation[MAX_SIGNAL_HISTORY + MAX_SFRAMESIZE + 12];\n1761     float synth[MAX_LSPS + MAX_SFRAMESIZE];\n1762     float *samples;\n1763\n1764     memcpy(synth,      s->synth_history,\n1765            s->lsps             * sizeof(*synth));\n1766     memcpy(excitation, s->excitation_history,\n1767            s->history_nsamples * sizeof(*excitation));\n1768\n1769     if (s->sframe_cache_size > 0) {\n1770         bc = &s_bc;\n1771         bitstream_init(bc, s->sframe_cache, s->sframe_cache_size);\n1772         s->sframe_cache_size = 0;\n1773     }\n1774\n1775     if ((res = check_bits_for_superframe(bc, s)) == 1) {\n1776         *got_frame_ptr = 0;\n1777         return 1;\n1778     } else if (res < 0)\n1779         return res;\n1780\n1781     /* First bit is speech/music bit, it differentiates between WMAVoice\n1782      * speech samples (the actual codec) and WMAVoice music samples, which\n1783      * are really WMAPro-in-WMAVoice-superframes. I've never seen those in\n1784      * the wild yet. */\n1785     if (!bitstream_read_bit(bc)) {\n1786         avpriv_request_sample(ctx, \"WMAPro-in-WMAVoice\");\n1787         return AVERROR_PATCHWELCOME;\n1788     }\n1789\n1790     /* (optional) nr. of samples in superframe; always <= 480 and >= 0 */\n1791     if (bitstream_read_bit(bc)) {\n1792         if ((n_samples = bitstream_read(bc, 12)) > 480) {\n1793             av_log(ctx, AV_LOG_ERROR,\n1794                    \"Superframe encodes >480 samples (%d), not allowed\\n\",\n1795                    n_samples);\n1796             return AVERROR_INVALIDDATA;\n1797         }\n1798     }\n1799     /* Parse LSPs, if global for the superframe (can also be per-frame). */\n1800     if (s->has_residual_lsps) {\n1801         double prev_lsps[MAX_LSPS], a1[MAX_LSPS * 2], a2[MAX_LSPS * 2];\n1802\n1803         for (n = 0; n < s->lsps; n++)\n1804             prev_lsps[n] = s->prev_lsps[n] - mean_lsf[n];\n1805\n1806         if (s->lsps == 10) {\n1807             dequant_lsp10r(bc, lsps[2], prev_lsps, a1, a2, s->lsp_q_mode);\n1808         } else /* s->lsps == 16 */\n1809             dequant_lsp16r(bc, lsps[2], prev_lsps, a1, a2, s->lsp_q_mode);\n1810\n1811         for (n = 0; n < s->lsps; n++) {\n1812             lsps[0][n]  = mean_lsf[n] + (a1[n]           - a2[n * 2]);\n1813             lsps[1][n]  = mean_lsf[n] + (a1[s->lsps + n] - a2[n * 2 + 1]);\n1814             lsps[2][n] += mean_lsf[n];\n1815         }\n1816         for (n = 0; n < 3; n++)\n1817             stabilize_lsps(lsps[n], s->lsps);\n1818     }\n1819\n1820     /* get output buffer */\n1821     frame->nb_samples = 480;\n1822     if ((res = ff_get_buffer(ctx, frame, 0)) < 0) {\n1823         av_log(ctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n1824         return res;\n1825     }\n1826     frame->nb_samples = n_samples;\n1827     samples = (float *)frame->data[0];\n1828\n1829     /* Parse frames, optionally preceded by per-frame (independent) LSPs. */\n1830     for (n = 0; n < 3; n++) {\n1831         if (!s->has_residual_lsps) {\n1832             int m;\n1833\n1834             if (s->lsps == 10) {\n1835                 dequant_lsp10i(bc, lsps[n]);\n1836             } else /* s->lsps == 16 */\n1837                 dequant_lsp16i(bc, lsps[n]);\n1838\n1839             for (m = 0; m < s->lsps; m++)\n1840                 lsps[n][m] += mean_lsf[m];\n1841             stabilize_lsps(lsps[n], s->lsps);\n1842         }\n1843\n1844         if ((res = synth_frame(ctx, bc, n,\n1845                                &samples[n * MAX_FRAMESIZE],\n1846                                lsps[n], n == 0 ? s->prev_lsps : lsps[n - 1],\n1847                                &excitation[s->history_nsamples + n * MAX_FRAMESIZE],\n1848                                &synth[s->lsps + n * MAX_FRAMESIZE]))) {\n1849             *got_frame_ptr = 0;\n1850             return res;\n1851         }\n1852     }\n1853\n1854     /* Statistics? FIXME - we don't check for length, a slight overrun\n1855      * will be caught by internal buffer padding, and anything else\n1856      * will be skipped, not read. */\n1857     if (bitstream_read_bit(bc)) {\n1858         res = bitstream_read(bc, 4);\n1859         bitstream_skip(bc, 10 * (res + 1));\n1860     }\n1861\n1862     *got_frame_ptr = 1;\n1863\n1864     /* Update history */\n1865     memcpy(s->prev_lsps,           lsps[2],\n1866            s->lsps             * sizeof(*s->prev_lsps));\n1867     memcpy(s->synth_history,      &synth[MAX_SFRAMESIZE],\n1868            s->lsps             * sizeof(*synth));\n1869     memcpy(s->excitation_history, &excitation[MAX_SFRAMESIZE],\n1870            s->history_nsamples * sizeof(*excitation));\n1871     if (s->do_apf)\n1872         memmove(s->zero_exc_pf,       &s->zero_exc_pf[MAX_SFRAMESIZE],\n1873                 s->history_nsamples * sizeof(*s->zero_exc_pf));\n1874\n1875     return 0;\n1876 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "1453 static int synth_frame(AVCodecContext *ctx, BitstreamContext *bc,\n1454                        int frame_idx, float *samples,\n1455                        const double *lsps, const double *prev_lsps,\n1456                        float *excitation, float *synth)\n1457 {\n1458     WMAVoiceContext *s = ctx->priv_data;\n1459     int n, n_blocks_x2, log_n_blocks_x2, cur_pitch_val;\n1460     int pitch[MAX_BLOCKS], last_block_pitch;\n1461\n1462     /* Parse frame type (\"frame header\"), see frame_descs */\n1463     int bd_idx = s->vbm_tree[bitstream_read_vlc(bc, frame_type_vlc.table, 6, 3)], block_nsamples;\n1464\n1465     if (bd_idx < 0) {\n1466         av_log(ctx, AV_LOG_ERROR,\n1467                \"Invalid frame type VLC code, skipping\\n\");\n1468         return AVERROR_INVALIDDATA;\n1469     }\n1470\n1471     block_nsamples = MAX_FRAMESIZE / frame_descs[bd_idx].n_blocks;\n1472\n1473     /* Pitch calculation for ACB_TYPE_ASYMMETRIC (\"pitch-per-frame\") */\n1474     if (frame_descs[bd_idx].acb_type == ACB_TYPE_ASYMMETRIC) {\n1475         /* Pitch is provided per frame, which is interpreted as the pitch of\n1476          * the last sample of the last block of this frame. We can interpolate\n1477          * the pitch of other blocks (and even pitch-per-sample) by gradually\n1478          * incrementing/decrementing prev_frame_pitch to cur_pitch_val. */\n1479         n_blocks_x2      = frame_descs[bd_idx].n_blocks << 1;\n1480         log_n_blocks_x2  = frame_descs[bd_idx].log_n_blocks + 1;\n1481         cur_pitch_val    = s->min_pitch_val + bitstream_read(bc, s->pitch_nbits);\n1482         cur_pitch_val    = FFMIN(cur_pitch_val, s->max_pitch_val - 1);\n1483         if (s->last_acb_type == ACB_TYPE_NONE ||\n1484             20 * abs(cur_pitch_val - s->last_pitch_val) >\n1485                 (cur_pitch_val + s->last_pitch_val))\n1486             s->last_pitch_val = cur_pitch_val;\n1487\n1488         /* pitch per block */\n1489         for (n = 0; n < frame_descs[bd_idx].n_blocks; n++) {\n1490             int fac = n * 2 + 1;\n1491\n1492             pitch[n] = (MUL16(fac,                 cur_pitch_val) +\n1493                         MUL16((n_blocks_x2 - fac), s->last_pitch_val) +\n1494                         frame_descs[bd_idx].n_blocks) >> log_n_blocks_x2;\n1495         }\n1496\n1497         /* \"pitch-diff-per-sample\" for calculation of pitch per sample */\n1498         s->pitch_diff_sh16 =\n1499             ((cur_pitch_val - s->last_pitch_val) << 16) / MAX_FRAMESIZE;\n1500     }\n1501\n1502     /* Global gain (if silence) and pitch-adaptive window coordinates */\n1503     switch (frame_descs[bd_idx].fcb_type) {\n1504     case FCB_TYPE_SILENCE:\n1505         s->silence_gain = wmavoice_gain_silence[bitstream_read(bc, 8)];\n1506         break;\n1507     case FCB_TYPE_AW_PULSES:\n1508         aw_parse_coords(s, bc, pitch);\n1509         break;\n1510     }\n1511\n1512     for (n = 0; n < frame_descs[bd_idx].n_blocks; n++) {\n1513         int bl_pitch_sh2;\n1514\n1515         /* Pitch calculation for ACB_TYPE_HAMMING (\"pitch-per-block\") */\n1516         switch (frame_descs[bd_idx].acb_type) {\n1517         case ACB_TYPE_HAMMING: {\n1518             /* Pitch is given per block. Per-block pitches are encoded as an\n1519              * absolute value for the first block, and then delta values\n1520              * relative to this value) for all subsequent blocks. The scale of\n1521              * this pitch value is semi-logarithmic compared to its use in the\n1522              * decoder, so we convert it to normal scale also. */\n1523             int block_pitch,\n1524                 t1 = (s->block_conv_table[1] - s->block_conv_table[0]) << 2,\n1525                 t2 = (s->block_conv_table[2] - s->block_conv_table[1]) << 1,\n1526                 t3 =  s->block_conv_table[3] - s->block_conv_table[2] + 1;\n1527\n1528             if (n == 0) {\n1529                 block_pitch = bitstream_read(bc, s->block_pitch_nbits);\n1530             } else\n1531                 block_pitch = last_block_pitch - s->block_delta_pitch_hrange +\n1532                               bitstream_read(bc, s->block_delta_pitch_nbits);\n1533             /* Convert last_ so that any next delta is within _range */\n1534             last_block_pitch = av_clip(block_pitch,\n1535                                        s->block_delta_pitch_hrange,\n1536                                        s->block_pitch_range -\n1537                                            s->block_delta_pitch_hrange);\n1538\n1539             /* Convert semi-log-style scale back to normal scale */\n1540             if (block_pitch < t1) {\n1541                 bl_pitch_sh2 = (s->block_conv_table[0] << 2) + block_pitch;\n1542             } else {\n1543                 block_pitch -= t1;\n1544                 if (block_pitch < t2) {\n1545                     bl_pitch_sh2 =\n1546                         (s->block_conv_table[1] << 2) + (block_pitch << 1);\n1547                 } else {\n1548                     block_pitch -= t2;\n1549                     if (block_pitch < t3) {\n1550                         bl_pitch_sh2 =\n1551                             (s->block_conv_table[2] + block_pitch) << 2;\n1552                     } else\n1553                         bl_pitch_sh2 = s->block_conv_table[3] << 2;\n1554                 }\n1555             }\n1556             pitch[n] = bl_pitch_sh2 >> 2;\n1557             break;\n1558         }\n1559\n1560         case ACB_TYPE_ASYMMETRIC: {\n1561             bl_pitch_sh2 = pitch[n] << 2;\n1562             break;\n1563         }\n1564\n1565         default: // ACB_TYPE_NONE has no pitch\n1566             bl_pitch_sh2 = 0;\n1567             break;\n1568         }\n1569\n1570         synth_block(s, bc, n, block_nsamples, bl_pitch_sh2,\n1571                     lsps, prev_lsps, &frame_descs[bd_idx],\n1572                     &excitation[n * block_nsamples],\n1573                     &synth[n * block_nsamples]);\n1574     }\n1575\n1576     /* Averaging projection filter, if applicable. Else, just copy samples\n1577      * from synthesis buffer */\n1578     if (s->do_apf) {\n1579         double i_lsps[MAX_LSPS];\n1580         float lpcs[MAX_LSPS];\n1581\n1582         for (n = 0; n < s->lsps; n++) // LSF -> LSP\n1583             i_lsps[n] = cos(0.5 * (prev_lsps[n] + lsps[n]));\n1584         ff_acelp_lspd2lpc(i_lsps, lpcs, s->lsps >> 1);\n1585         postfilter(s, synth, samples, 80, lpcs,\n1586                    &s->zero_exc_pf[s->history_nsamples + MAX_FRAMESIZE * frame_idx],\n1587                    frame_descs[bd_idx].fcb_type, pitch[0]);\n1588\n1589         for (n = 0; n < s->lsps; n++) // LSF -> LSP\n1590             i_lsps[n] = cos(lsps[n]);\n1591         ff_acelp_lspd2lpc(i_lsps, lpcs, s->lsps >> 1);\n1592         postfilter(s, &synth[80], &samples[80], 80, lpcs,\n1593                    &s->zero_exc_pf[s->history_nsamples + MAX_FRAMESIZE * frame_idx + 80],\n1594                    frame_descs[bd_idx].fcb_type, pitch[0]);\n1595     } else\n1596         memcpy(samples, synth, 160 * sizeof(synth[0]));\n1597\n1598     /* Cache values for next frame */\n1599     s->frame_cntr++;\n1600     if (s->frame_cntr >= 0xFFFF) s->frame_cntr -= 0xFFFF; // i.e. modulo (%)\n1601     s->last_acb_type = frame_descs[bd_idx].acb_type;\n1602     switch (frame_descs[bd_idx].acb_type) {\n1603     case ACB_TYPE_NONE:\n1604         s->last_pitch_val = 0;\n1605         break;\n1606     case ACB_TYPE_ASYMMETRIC:\n1607         s->last_pitch_val = cur_pitch_val;\n1608         break;\n1609     case ACB_TYPE_HAMMING:\n1610         s->last_pitch_val = pitch[frame_descs[bd_idx].n_blocks - 1];\n1611         break;\n1612     }\n1613\n1614     return 0;\n1615 }"
                    },
                    {
                        "file_path": "/libavcodec/wmavoice.c",
                        "function_body": "575 static void calc_input_response(WMAVoiceContext *s, float *lpcs,\n576                                 int fcb_type, float *coeffs, int remainder)\n577 {\n578     float last_coeff, min = 15.0, max = -15.0;\n579     float irange, angle_mul, gain_mul, range, sq;\n580     int n, idx;\n581\n582     /* Create frequency power spectrum of speech input (i.e. RDFT of LPCs) */\n583     s->rdft.rdft_calc(&s->rdft, lpcs);\n584 #define log_range(var, assign) do { \\\n585         float tmp = log10f(assign);  var = tmp; \\\n586         max       = FFMAX(max, tmp); min = FFMIN(min, tmp); \\\n587     } while (0)\n588     log_range(last_coeff,  lpcs[1]         * lpcs[1]);\n589     for (n = 1; n < 64; n++)\n590         log_range(lpcs[n], lpcs[n * 2]     * lpcs[n * 2] +\n591                            lpcs[n * 2 + 1] * lpcs[n * 2 + 1]);\n592     log_range(lpcs[0],     lpcs[0]         * lpcs[0]);\n593 #undef log_range\n594     range    = max - min;\n595     lpcs[64] = last_coeff;\n596\n597     /* Now, use this spectrum to pick out these frequencies with higher\n598      * (relative) power/energy (which we then take to be \"not noise\"),\n599      * and set up a table (still in lpc[]) of (relative) gains per frequency.\n600      * These frequencies will be maintained, while others (\"noise\") will be\n601      * decreased in the filter output. */\n602     irange    = 64.0 / range; // so irange*(max-value) is in the range [0, 63]\n603     gain_mul  = range * (fcb_type == FCB_TYPE_HARDCODED ? (5.0 / 13.0) :\n604                                                           (5.0 / 14.7));\n605     angle_mul = gain_mul * (8.0 * M_LN10 / M_PI);\n606     for (n = 0; n <= 64; n++) {\n607         float pwr;\n608\n609         idx = FFMAX(0, lrint((max - lpcs[n]) * irange) - 1);\n610         pwr = wmavoice_denoise_power_table[s->denoise_strength][idx];\n611         lpcs[n] = angle_mul * pwr;\n612\n613         /* 70.57 =~ 1/log10(1.0331663) */\n614         idx = (pwr * gain_mul - 0.0295) * 70.570526123;\n615         if (idx > 127) { // fall back if index falls outside table range\n616             coeffs[n] = wmavoice_energy_table[127] *\n617                         powf(1.0331663, idx - 127);\n618         } else\n619             coeffs[n] = wmavoice_energy_table[FFMAX(0, idx)];\n620     }\n621\n622     /* calculate the Hilbert transform of the gains, which we do (since this\n623      * is a sine input) by doing a phase shift (in theory, H(sin())=cos()).\n624      * Hilbert_Transform(RDFT(x)) = Laplace_Transform(x), which calculates the\n625      * \"moment\" of the LPCs in this filter. */\n626     s->dct.dct_calc(&s->dct, lpcs);\n627     s->dst.dct_calc(&s->dst, lpcs);\n628\n629     /* Split out the coefficient indexes into phase/magnitude pairs */\n630     idx = 255 + av_clip(lpcs[64],               -255, 255);\n631     coeffs[0]  = coeffs[0]  * s->cos[idx];\n632     idx = 255 + av_clip(lpcs[64] - 2 * lpcs[63], -255, 255);\n633     last_coeff = coeffs[64] * s->cos[idx];\n634     for (n = 63;; n--) {\n635         idx = 255 + av_clip(-lpcs[64] - 2 * lpcs[n - 1], -255, 255);\n636         coeffs[n * 2 + 1] = coeffs[n] * s->sin[idx];\n637         coeffs[n * 2]     = coeffs[n] * s->cos[idx];\n638\n639         if (!--n) break;\n640\n641         idx = 255 + av_clip( lpcs[64] - 2 * lpcs[n - 1], -255, 255);\n642         coeffs[n * 2 + 1] = coeffs[n] * s->sin[idx];\n643         coeffs[n * 2]     = coeffs[n] * s->cos[idx];\n644     }\n645     coeffs[1] = last_coeff;\n646\n647     /* move into real domain */\n648     s->irdft.rdft_calc(&s->irdft, coeffs);\n649\n650     /* tilt correction and normalize scale */\n651     memset(&coeffs[remainder], 0, sizeof(coeffs[0]) * (128 - remainder));\n652     if (s->denoise_tilt_corr) {\n653         float tilt_mem = 0;\n654\n655         coeffs[remainder - 1] = 0;\n656         ff_tilt_compensation(&tilt_mem,\n657                              -1.8 * tilt_factor(coeffs, remainder - 1),\n658                              coeffs, remainder);\n659     }\n660     sq = (1.0 / 64.0) * sqrtf(1 / avpriv_scalarproduct_float_c(coeffs, coeffs,\n661                                                                remainder));\n662     for (n = 0; n < remainder; n++)\n663         coeffs[n] *= sq;\n664 }"
                    }
                ]
            }
        ],
        "sink": "s->last_pitch_val = cur_pitch_val;",
        "final_sink": "s->last_pitch_val = cur_pitch_val;"
    },
    {
        "prt": "oggstream",
        "function_call": [
            "static int ogg_write_header(AVFormatContext *s)\n{\n    OGGContext *ogg = s->priv_data;\n    OGGStreamContext *oggstream;\n    int i, j;\n\n    if (ogg->pref_size)\n        av_log(s, AV_LOG_WARNING, \"The pagesize option is deprecated\\n\");\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        unsigned serial_num = i + ogg->serial_offset;\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n            if (st->codecpar->codec_id == AV_CODEC_ID_OPUS)\n                /* Opus requires a fixed 48kHz clock */\n                avpriv_set_pts_info(st, 64, 1, 48000);\n            else\n                avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);\n\n        if (st->codecpar->codec_id != AV_CODEC_ID_VORBIS &&\n            st->codecpar->codec_id != AV_CODEC_ID_THEORA &&\n            st->codecpar->codec_id != AV_CODEC_ID_SPEEX  &&\n            st->codecpar->codec_id != AV_CODEC_ID_FLAC   &&\n            st->codecpar->codec_id != AV_CODEC_ID_OPUS) {\n            av_log(s, AV_LOG_ERROR, \"Unsupported codec id in stream %d\\n\", i);\n            return -1;\n        }\n\n        if (!st->codecpar->extradata || !st->codecpar->extradata_size) {\n            av_log(s, AV_LOG_ERROR, \"No extradata present\\n\");\n            return -1;\n        }\n        oggstream = av_mallocz(sizeof(*oggstream));\n        if (!oggstream)\n            return AVERROR(ENOMEM);\n        oggstream->page.stream_index = i;\n\n        if (!(s->flags & AVFMT_FLAG_BITEXACT))\n            do {\n                serial_num = av_get_random_seed();\n                for (j = 0; j < i; j++) {\n                    OGGStreamContext *sc = s->streams[j]->priv_data;\n                    if (serial_num == sc->serial_num)\n                        break;\n                }\n            } while (j < i);\n        oggstream->serial_num = serial_num;\n\n        st->priv_data = oggstream;\n        if (st->codecpar->codec_id == AV_CODEC_ID_FLAC) {\n            int err = ogg_build_flac_headers(st->codecpar, oggstream,\n                                             s->flags & AVFMT_FLAG_BITEXACT,\n                                             &s->metadata);\n            if (err) {\n                av_log(s, AV_LOG_ERROR, \"Error writing FLAC headers\\n\");\n                av_freep(&st->priv_data);\n                return err;\n            }\n        } else if (st->codecpar->codec_id == AV_CODEC_ID_SPEEX) {\n            int err = ogg_build_speex_headers(st->codecpar, oggstream,\n                                              s->flags & AVFMT_FLAG_BITEXACT,\n                                              &s->metadata);\n            if (err) {\n                av_log(s, AV_LOG_ERROR, \"Error writing Speex headers\\n\");\n                av_freep(&st->priv_data);\n                return err;\n            }\n        } else if (st->codecpar->codec_id == AV_CODEC_ID_OPUS) {\n            int err = ogg_build_opus_headers(st->codecpar, oggstream,\n                                             s->flags & AVFMT_FLAG_BITEXACT,\n                                             &s->metadata);\n            if (err) {\n                av_log(s, AV_LOG_ERROR, \"Error writing Opus headers\\n\");\n                av_freep(&st->priv_data);\n                return err;\n            }\n        } else {\n            uint8_t *p;\n            const char *cstr = st->codecpar->codec_id == AV_CODEC_ID_VORBIS ? \"vorbis\" : \"theora\";\n            int header_type = st->codecpar->codec_id == AV_CODEC_ID_VORBIS ? 3 : 0x81;\n            int framing_bit = st->codecpar->codec_id == AV_CODEC_ID_VORBIS ? 1 : 0;\n\n            if (avpriv_split_xiph_headers(st->codecpar->extradata, st->codecpar->extradata_size,\n                                      st->codecpar->codec_id == AV_CODEC_ID_VORBIS ? 30 : 42,\n                                      oggstream->header, oggstream->header_len) < 0) {\n                av_log(s, AV_LOG_ERROR, \"Extradata corrupted\\n\");\n                av_freep(&st->priv_data);\n                return -1;\n            }\n\n            p = ogg_write_vorbiscomment(7, s->flags & AVFMT_FLAG_BITEXACT,\n                                        &oggstream->header_len[1], &s->metadata,\n                                        framing_bit);\n            oggstream->header[1] = p;\n            if (!p)\n                return AVERROR(ENOMEM);\n\n            bytestream_put_byte(&p, header_type);\n            bytestream_put_buffer(&p, cstr, 6);\n\n            if (st->codecpar->codec_id == AV_CODEC_ID_THEORA) {\n                /** KFGSHIFT is the width of the less significant section of the granule position\n                    The less significant section is the frame count since the last keyframe */\n                oggstream->kfgshift = ((oggstream->header[0][40]&3)<<3)|(oggstream->header[0][41]>>5);\n                oggstream->vrev = oggstream->header[0][9];\n                av_log(s, AV_LOG_DEBUG, \"theora kfgshift %d, vrev %d\\n\",\n                       oggstream->kfgshift, oggstream->vrev);\n            }\n        }\n    }\n\n    for (j = 0; j < s->nb_streams; j++) {\n        OGGStreamContext *oggstream = s->streams[j]->priv_data;\n        ogg_buffer_data(s, s->streams[j], oggstream->header[0],\n                        oggstream->header_len[0], 0, 1);\n        oggstream->page.flags |= 2; // bos\n        ogg_buffer_page(s, oggstream);\n    }\n    for (j = 0; j < s->nb_streams; j++) {\n        AVStream *st = s->streams[j];\n        OGGStreamContext *oggstream = st->priv_data;\n        for (i = 1; i < 3; i++) {\n            if (oggstream->header_len[i])\n                ogg_buffer_data(s, st, oggstream->header[i],\n                                oggstream->header_len[i], 0, 1);\n        }\n        ogg_buffer_page(s, oggstream);\n    }\n\n    oggstream->page.start_granule = AV_NOPTS_VALUE;\n\n    ogg_write_pages(s, 2);\n\n    return 0;\n}"
        ],
        "source": [
            "    OGGStreamContext *oggstream;"
        ],
        "index": 19,
        "location": {
            "file_path": "libavformat/oggenc.c",
            "region": {
                "startLine": 543,
                "startColumn": 5,
                "endColumn": 14
            },
            "context": {
                "startLine": 541,
                "endLine": 545,
                "snippet": {
                    "text": "    oggstream->page.start_granule = AV_NOPTS_VALUE;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavutil/avutil.h",
                        "function_body": "241 #define AV_NOPTS_VALUE          INT64_C(0x8000000000000000)"
                    },
                    {
                        "file_path": "/libavformat/oggenc.c",
                        "function_body": "413 static int ogg_write_header(AVFormatContext *s)\n414 {\n415     OGGContext *ogg = s->priv_data;\n416     OGGStreamContext *oggstream;\n417     int i, j;\n418\n419     if (ogg->pref_size)\n420         av_log(s, AV_LOG_WARNING, \"The pagesize option is deprecated\\n\");\n421\n422     for (i = 0; i < s->nb_streams; i++) {\n423         AVStream *st = s->streams[i];\n424         unsigned serial_num = i + ogg->serial_offset;\n425\n426         if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n427             if (st->codecpar->codec_id == AV_CODEC_ID_OPUS)\n428                 /* Opus requires a fixed 48kHz clock */\n429                 avpriv_set_pts_info(st, 64, 1, 48000);\n430             else\n431                 avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);\n432\n433         if (st->codecpar->codec_id != AV_CODEC_ID_VORBIS &&\n434             st->codecpar->codec_id != AV_CODEC_ID_THEORA &&\n435             st->codecpar->codec_id != AV_CODEC_ID_SPEEX  &&\n436             st->codecpar->codec_id != AV_CODEC_ID_FLAC   &&\n437             st->codecpar->codec_id != AV_CODEC_ID_OPUS) {\n438             av_log(s, AV_LOG_ERROR, \"Unsupported codec id in stream %d\\n\", i);\n439             return -1;\n440         }\n441\n442         if (!st->codecpar->extradata || !st->codecpar->extradata_size) {\n443             av_log(s, AV_LOG_ERROR, \"No extradata present\\n\");\n444             return -1;\n445         }\n446         oggstream = av_mallocz(sizeof(*oggstream));\n447         if (!oggstream)\n448             return AVERROR(ENOMEM);\n449         oggstream->page.stream_index = i;\n450\n451         if (!(s->flags & AVFMT_FLAG_BITEXACT))\n452             do {\n453                 serial_num = av_get_random_seed();\n454                 for (j = 0; j < i; j++) {\n455                     OGGStreamContext *sc = s->streams[j]->priv_data;\n456                     if (serial_num == sc->serial_num)\n457                         break;\n458                 }\n459             } while (j < i);\n460         oggstream->serial_num = serial_num;\n461\n462         st->priv_data = oggstream;\n463         if (st->codecpar->codec_id == AV_CODEC_ID_FLAC) {\n464             int err = ogg_build_flac_headers(st->codecpar, oggstream,\n465                                              s->flags & AVFMT_FLAG_BITEXACT,\n466                                              &s->metadata);\n467             if (err) {\n468                 av_log(s, AV_LOG_ERROR, \"Error writing FLAC headers\\n\");\n469                 av_freep(&st->priv_data);\n470                 return err;\n471             }\n472         } else if (st->codecpar->codec_id == AV_CODEC_ID_SPEEX) {\n473             int err = ogg_build_speex_headers(st->codecpar, oggstream,\n474                                               s->flags & AVFMT_FLAG_BITEXACT,\n475                                               &s->metadata);\n476             if (err) {\n477                 av_log(s, AV_LOG_ERROR, \"Error writing Speex headers\\n\");\n478                 av_freep(&st->priv_data);\n479                 return err;\n480             }\n481         } else if (st->codecpar->codec_id == AV_CODEC_ID_OPUS) {\n482             int err = ogg_build_opus_headers(st->codecpar, oggstream,\n483                                              s->flags & AVFMT_FLAG_BITEXACT,\n484                                              &s->metadata);\n485             if (err) {\n486                 av_log(s, AV_LOG_ERROR, \"Error writing Opus headers\\n\");\n487                 av_freep(&st->priv_data);\n488                 return err;\n489             }\n490         } else {\n491             uint8_t *p;\n492             const char *cstr = st->codecpar->codec_id == AV_CODEC_ID_VORBIS ? \"vorbis\" : \"theora\";\n493             int header_type = st->codecpar->codec_id == AV_CODEC_ID_VORBIS ? 3 : 0x81;\n494             int framing_bit = st->codecpar->codec_id == AV_CODEC_ID_VORBIS ? 1 : 0;\n495\n496             if (avpriv_split_xiph_headers(st->codecpar->extradata, st->codecpar->extradata_size,\n497                                       st->codecpar->codec_id == AV_CODEC_ID_VORBIS ? 30 : 42,\n498                                       oggstream->header, oggstream->header_len) < 0) {\n499                 av_log(s, AV_LOG_ERROR, \"Extradata corrupted\\n\");\n500                 av_freep(&st->priv_data);\n501                 return -1;\n502             }\n503\n504             p = ogg_write_vorbiscomment(7, s->flags & AVFMT_FLAG_BITEXACT,\n505                                         &oggstream->header_len[1], &s->metadata,\n506                                         framing_bit);\n507             oggstream->header[1] = p;\n508             if (!p)\n509                 return AVERROR(ENOMEM);\n510\n511             bytestream_put_byte(&p, header_type);\n512             bytestream_put_buffer(&p, cstr, 6);\n513\n514             if (st->codecpar->codec_id == AV_CODEC_ID_THEORA) {\n515                 /** KFGSHIFT is the width of the less significant section of the granule position\n516                     The less significant section is the frame count since the last keyframe */\n517                 oggstream->kfgshift = ((oggstream->header[0][40]&3)<<3)|(oggstream->header[0][41]>>5);\n518                 oggstream->vrev = oggstream->header[0][9];\n519                 av_log(s, AV_LOG_DEBUG, \"theora kfgshift %d, vrev %d\\n\",\n520                        oggstream->kfgshift, oggstream->vrev);\n521             }\n522         }\n523     }\n524\n525     for (j = 0; j < s->nb_streams; j++) {\n526         OGGStreamContext *oggstream = s->streams[j]->priv_data;\n527         ogg_buffer_data(s, s->streams[j], oggstream->header[0],\n528                         oggstream->header_len[0], 0, 1);\n529         oggstream->page.flags |= 2; // bos\n530         ogg_buffer_page(s, oggstream);\n531     }\n532     for (j = 0; j < s->nb_streams; j++) {\n533         AVStream *st = s->streams[j];\n534         OGGStreamContext *oggstream = st->priv_data;\n535         for (i = 1; i < 3; i++) {\n536             if (oggstream->header_len[i])\n537                 ogg_buffer_data(s, st, oggstream->header[i],\n538                                 oggstream->header_len[i], 0, 1);\n539         }\n540         ogg_buffer_page(s, oggstream);\n541     }\n542\n543     oggstream->page.start_granule = AV_NOPTS_VALUE;\n544\n545     ogg_write_pages(s, 2);\n546\n547     return 0;\n548 }"
                    }
                ]
            }
        ],
        "sink": "oggstream->page.start_granule = AV_NOPTS_VALUE;",
        "final_sink": "oggstream->page.start_granule = AV_NOPTS_VALUE;"
    },
    {
        "prt": "st",
        "function_call": [
            "static int rm_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    AVStream *st;\n    int i, len, res, seq = 1;\n    int64_t timestamp, pos;\n    int flags;\n\n    for (;;) {\n        if (rm->audio_pkt_cnt) {\n            // If there are queued audio packet return them first\n            st = s->streams[rm->audio_stream_num];\n            ff_rm_retrieve_cache(s, s->pb, st, st->priv_data, pkt);\n            flags = 0;\n        } else {\n            if (rm->old_format) {\n                RMStream *ast;\n\n                st = s->streams[0];\n                ast = st->priv_data;\n                timestamp = AV_NOPTS_VALUE;\n                len = !ast->audio_framesize ? RAW_PACKET_SIZE :\n                    ast->coded_framesize * ast->sub_packet_h / 2;\n                flags = (seq++ == 1) ? 2 : 0;\n                pos = avio_tell(s->pb);\n            } else {\n                len=sync(s, &timestamp, &flags, &i, &pos);\n                if (len > 0)\n                    st = s->streams[i];\n            }\n\n            if (len <= 0 || s->pb->eof_reached)\n                return AVERROR(EIO);\n\n            res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,\n                                      &seq, flags, timestamp);\n            if((flags&2) && (seq&0x7F) == 1)\n                av_add_index_entry(st, pos, timestamp, 0, 0, AVINDEX_KEYFRAME);\n            if (res)\n                continue;\n        }\n\n        if(  (st->discard >= AVDISCARD_NONKEY && !(flags&2))\n           || st->discard >= AVDISCARD_ALL){\n            av_packet_unref(pkt);\n        } else\n            break;\n    }\n\n    return 0;\n}"
        ],
        "source": [
            "    AVStream *st;"
        ],
        "index": 20,
        "location": {
            "file_path": "libavformat/rmdec.c",
            "region": {
                "startLine": 870,
                "startColumn": 49,
                "endColumn": 51
            },
            "context": {
                "startLine": 868,
                "endLine": 872,
                "snippet": {
                    "text": "            res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/rmdec.c",
                        "function_body": "720 ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,\n721                     AVStream *st, RMStream *ast, int len, AVPacket *pkt,\n722                     int *seq, int flags, int64_t timestamp)\n723 {\n724     RMDemuxContext *rm = s->priv_data;\n725     int ret;\n726\n727     if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n728         rm->current_stream= st->id;\n729         if(rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp))\n730             return -1; //got partial frame\n731     } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n732         if ((ast->deint_id == DEINT_ID_GENR) ||\n733             (ast->deint_id == DEINT_ID_INT4) ||\n734             (ast->deint_id == DEINT_ID_SIPR)) {\n735             int x;\n736             int sps = ast->sub_packet_size;\n737             int cfs = ast->coded_framesize;\n738             int h = ast->sub_packet_h;\n739             int y = ast->sub_packet_cnt;\n740             int w = ast->audio_framesize;\n741\n742             if (flags & 2)\n743                 y = ast->sub_packet_cnt = 0;\n744             if (!y)\n745                 ast->audiotimestamp = timestamp;\n746\n747             switch (ast->deint_id) {\n748                 case DEINT_ID_INT4:\n749                     for (x = 0; x < h/2; x++)\n750                         avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs);\n751                     break;\n752                 case DEINT_ID_GENR:\n753                     for (x = 0; x < w/sps; x++)\n754                         avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps);\n755                     break;\n756                 case DEINT_ID_SIPR:\n757                     avio_read(pb, ast->pkt.data + y * w, w);\n758                     break;\n759             }\n760\n761             if (++(ast->sub_packet_cnt) < h)\n762                 return -1;\n763             if (ast->deint_id == DEINT_ID_SIPR)\n764                 ff_rm_reorder_sipr_data(ast->pkt.data, h, w);\n765\n766              ast->sub_packet_cnt = 0;\n767              rm->audio_stream_num = st->index;\n768              rm->audio_pkt_cnt = h * w / st->codecpar->block_align;\n769         } else if ((ast->deint_id == DEINT_ID_VBRF) ||\n770                    (ast->deint_id == DEINT_ID_VBRS)) {\n771             int x;\n772             rm->audio_stream_num = st->index;\n773             ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4;\n774             if (ast->sub_packet_cnt) {\n775                 for (x = 0; x < ast->sub_packet_cnt; x++)\n776                     ast->sub_packet_lengths[x] = avio_rb16(pb);\n777                 rm->audio_pkt_cnt = ast->sub_packet_cnt;\n778                 ast->audiotimestamp = timestamp;\n779             } else\n780                 return -1;\n781         } else {\n782             ret = av_get_packet(pb, pkt, len);\n783             if (ret < 0)\n784                 return ret;\n785             rm_ac3_swap_bytes(st, pkt);\n786         }\n787     } else {\n788         ret = av_get_packet(pb, pkt, len);\n789         if (ret < 0)\n790             return ret;\n791     }\n792\n793     pkt->stream_index = st->index;\n794\n795     pkt->pts = timestamp;\n796     if (flags & 2)\n797         pkt->flags |= AV_PKT_FLAG_KEY;\n798\n799     return st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0;\n800 }"
                    },
                    {
                        "file_path": "/libavformat/rmdec.c",
                        "function_body": "836 static int rm_read_packet(AVFormatContext *s, AVPacket *pkt)\n837 {\n838     RMDemuxContext *rm = s->priv_data;\n839     AVStream *st;\n840     int i, len, res, seq = 1;\n841     int64_t timestamp, pos;\n842     int flags;\n843\n844     for (;;) {\n845         if (rm->audio_pkt_cnt) {\n846             // If there are queued audio packet return them first\n847             st = s->streams[rm->audio_stream_num];\n848             ff_rm_retrieve_cache(s, s->pb, st, st->priv_data, pkt);\n849             flags = 0;\n850         } else {\n851             if (rm->old_format) {\n852                 RMStream *ast;\n853\n854                 st = s->streams[0];\n855                 ast = st->priv_data;\n856                 timestamp = AV_NOPTS_VALUE;\n857                 len = !ast->audio_framesize ? RAW_PACKET_SIZE :\n858                     ast->coded_framesize * ast->sub_packet_h / 2;\n859                 flags = (seq++ == 1) ? 2 : 0;\n860                 pos = avio_tell(s->pb);\n861             } else {\n862                 len=sync(s, &timestamp, &flags, &i, &pos);\n863                 if (len > 0)\n864                     st = s->streams[i];\n865             }\n866\n867             if (len <= 0 || s->pb->eof_reached)\n868                 return AVERROR(EIO);\n869\n870             res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,\n871                                       &seq, flags, timestamp);\n872             if((flags&2) && (seq&0x7F) == 1)\n873                 av_add_index_entry(st, pos, timestamp, 0, 0, AVINDEX_KEYFRAME);\n874             if (res)\n875                 continue;\n876         }\n877\n878         if(  (st->discard >= AVDISCARD_NONKEY && !(flags&2))\n879            || st->discard >= AVDISCARD_ALL){\n880             av_packet_unref(pkt);\n881         } else\n882             break;\n883     }\n884\n885     return 0;\n886 }"
                    }
                ]
            }
        ],
        "sink": "res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,",
        "final_sink": "res = ff_rm_parse_packet (s, s->pb, st, st->priv_data, len, pkt,"
    },
    {
        "prt": "next",
        "function_call": [
            "enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n{\n    enum AVHWDeviceType next;\n    int i, set = 0;\n    for (i = 0; hw_table[i]; i++) {\n        if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n            continue;\n        if (!set || hw_table[i]->type < next) {\n            next = hw_table[i]->type;\n            set = 1;\n        }\n    }\n    return set ? next : AV_HWDEVICE_TYPE_NONE;\n}"
        ],
        "source": [
            "    enum AVHWDeviceType next;"
        ],
        "index": 21,
        "location": {
            "file_path": "libavutil/hwcontext.c",
            "region": {
                "startLine": 88,
                "startColumn": 41,
                "endColumn": 45
            },
            "context": {
                "startLine": 86,
                "endLine": 90,
                "snippet": {
                    "text": "        if (!set || hw_table[i]->type < next) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavutil/hwcontext.c",
                        "function_body": "81 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n82 {\n83     enum AVHWDeviceType next;\n84     int i, set = 0;\n85     for (i = 0; hw_table[i]; i++) {\n86         if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n87             continue;\n88         if (!set || hw_table[i]->type < next) {\n89             next = hw_table[i]->type;\n90             set = 1;\n91         }\n92     }\n93     return set ? next : AV_HWDEVICE_TYPE_NONE;\n94 }"
                    },
                    {
                        "file_path": "/avtools/avconv_opt.c",
                        "function_body": "347 static int opt_init_hw_device(void *optctx, const char *opt, const char *arg)\n348 {\n349     if (!strcmp(arg, \"list\")) {\n350         enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE;\n351         printf(\"Supported hardware device types:\\n\");\n352         while ((type = av_hwdevice_iterate_types(type)) !=\n353                AV_HWDEVICE_TYPE_NONE)\n354             printf(\"%s\\n\", av_hwdevice_get_type_name(type));\n355         printf(\"\\n\");\n356         exit_program(0);\n357     } else {\n358         return hw_device_init_from_string(arg, NULL);\n359     }\n360 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavutil/hwcontext.c",
                        "function_body": "81 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n82 {\n83     enum AVHWDeviceType next;\n84     int i, set = 0;\n85     for (i = 0; hw_table[i]; i++) {\n86         if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n87             continue;\n88         if (!set || hw_table[i]->type < next) {\n89             next = hw_table[i]->type;\n90             set = 1;\n91         }\n92     }\n93     return set ? next : AV_HWDEVICE_TYPE_NONE;\n94 }"
                    },
                    {
                        "file_path": "/avtools/avconv_opt.c",
                        "function_body": "180 static int show_hwaccels(void *optctx, const char *opt, const char *arg)\n181 {\n182     enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE;\n183     int i;\n184\n185     printf(\"Supported hardware acceleration:\\n\");\n186     while ((type = av_hwdevice_iterate_types(type)) !=\n187            AV_HWDEVICE_TYPE_NONE)\n188         printf(\"%s\\n\", av_hwdevice_get_type_name(type));\n189     for (i = 0; hwaccels[i].name; i++)\n190         printf(\"%s\\n\", hwaccels[i].name);\n191     printf(\"\\n\");\n192     return 0;\n193 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavutil/hwcontext.c",
                        "function_body": "81 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n82 {\n83     enum AVHWDeviceType next;\n84     int i, set = 0;\n85     for (i = 0; hw_table[i]; i++) {\n86         if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n87             continue;\n88         if (!set || hw_table[i]->type < next) {\n89             next = hw_table[i]->type;\n90             set = 1;\n91         }\n92     }\n93     return set ? next : AV_HWDEVICE_TYPE_NONE;\n94 }"
                    },
                    {
                        "file_path": "/avtools/avconv_opt.c",
                        "function_body": "534 static void add_input_streams(OptionsContext *o, AVFormatContext *ic)\n535 {\n536     int i, ret;\n537\n538     for (i = 0; i < ic->nb_streams; i++) {\n539         AVStream *st = ic->streams[i];\n540         AVCodecParameters *par = st->codecpar;\n541         InputStream *ist = av_mallocz(sizeof(*ist));\n542         char *framerate = NULL, *hwaccel = NULL, *hwaccel_device = NULL;\n543         char *hwaccel_output_format = NULL;\n544         char *codec_tag = NULL;\n545         char *next;\n546\n547         if (!ist)\n548             exit_program(1);\n549\n550         GROW_ARRAY(input_streams, nb_input_streams);\n551         input_streams[nb_input_streams - 1] = ist;\n552\n553         ist->st = st;\n554         ist->file_index = nb_input_files;\n555         ist->discard = 1;\n556         st->discard  = AVDISCARD_ALL;\n557         ist->nb_samples = 0;\n558         ist->min_pts = INT64_MAX;\n559         ist->max_pts = INT64_MIN;\n560\n561         ist->ts_scale = 1.0;\n562         MATCH_PER_STREAM_OPT(ts_scale, dbl, ist->ts_scale, ic, st);\n563\n564         ist->autorotate = 1;\n565         MATCH_PER_STREAM_OPT(autorotate, i, ist->autorotate, ic, st);\n566\n567         MATCH_PER_STREAM_OPT(codec_tags, str, codec_tag, ic, st);\n568         if (codec_tag) {\n569             uint32_t tag = strtol(codec_tag, &next, 0);\n570             if (*next)\n571                 tag = AV_RL32(codec_tag);\n572             st->codecpar->codec_tag = tag;\n573         }\n574\n575         ist->dec = choose_decoder(o, ic, st);\n576         ist->decoder_opts = filter_codec_opts(o->g->codec_opts, par->codec_id, ic, st, ist->dec);\n577\n578         ist->dec_ctx = avcodec_alloc_context3(ist->dec);\n579         if (!ist->dec_ctx) {\n580             av_log(NULL, AV_LOG_ERROR, \"Error allocating the decoder context.\\n\");\n581             exit_program(1);\n582         }\n583\n584         ret = avcodec_parameters_to_context(ist->dec_ctx, par);\n585         if (ret < 0) {\n586             av_log(NULL, AV_LOG_ERROR, \"Error initializing the decoder context.\\n\");\n587             exit_program(1);\n588         }\n589\n590         switch (par->codec_type) {\n591         case AVMEDIA_TYPE_VIDEO:\n592             MATCH_PER_STREAM_OPT(frame_rates, str, framerate, ic, st);\n593             if (framerate && av_parse_video_rate(&ist->framerate,\n594                                                  framerate) < 0) {\n595                 av_log(NULL, AV_LOG_ERROR, \"Error parsing framerate %s.\\n\",\n596                        framerate);\n597                 exit_program(1);\n598             }\n599\n600             MATCH_PER_STREAM_OPT(hwaccels, str, hwaccel, ic, st);\n601             if (hwaccel) {\n602                 if (!strcmp(hwaccel, \"none\"))\n603                     ist->hwaccel_id = HWACCEL_NONE;\n604                 else if (!strcmp(hwaccel, \"auto\"))\n605                     ist->hwaccel_id = HWACCEL_AUTO;\n606                 else {\n607                     enum AVHWDeviceType type;\n608                     int i;\n609                     for (i = 0; hwaccels[i].name; i++) {\n610                         if (!strcmp(hwaccels[i].name, hwaccel)) {\n611                             ist->hwaccel_id = hwaccels[i].id;\n612                             break;\n613                         }\n614                     }\n615\n616                     if (!ist->hwaccel_id) {\n617                         type = av_hwdevice_find_type_by_name(hwaccel);\n618                         if (type != AV_HWDEVICE_TYPE_NONE) {\n619                             ist->hwaccel_id = HWACCEL_GENERIC;\n620                             ist->hwaccel_device_type = type;\n621                         }\n622                     }\n623\n624                     if (!ist->hwaccel_id) {\n625                         av_log(NULL, AV_LOG_FATAL, \"Unrecognized hwaccel: %s.\\n\",\n626                                hwaccel);\n627                         av_log(NULL, AV_LOG_FATAL, \"Supported hwaccels: \");\n628                         type = AV_HWDEVICE_TYPE_NONE;\n629                         while ((type = av_hwdevice_iterate_types(type)) !=\n630                                AV_HWDEVICE_TYPE_NONE)\n631                             av_log(NULL, AV_LOG_FATAL, \"%s \",\n632                                    av_hwdevice_get_type_name(type));\n633                         for (i = 0; hwaccels[i].name; i++)\n634                             av_log(NULL, AV_LOG_FATAL, \"%s \", hwaccels[i].name);\n635                         av_log(NULL, AV_LOG_FATAL, \"\\n\");\n636                         exit_program(1);\n637                     }\n638                 }\n639             }\n640\n641             MATCH_PER_STREAM_OPT(hwaccel_devices, str, hwaccel_device, ic, st);\n642             if (hwaccel_device) {\n643                 ist->hwaccel_device = av_strdup(hwaccel_device);\n644                 if (!ist->hwaccel_device)\n645                     exit_program(1);\n646             }\n647\n648             MATCH_PER_STREAM_OPT(hwaccel_output_formats, str,\n649                                  hwaccel_output_format, ic, st);\n650             if (hwaccel_output_format) {\n651                 ist->hwaccel_output_format = av_get_pix_fmt(hwaccel_output_format);\n652                 if (ist->hwaccel_output_format == AV_PIX_FMT_NONE) {\n653                     av_log(NULL, AV_LOG_FATAL, \"Unrecognised hwaccel output \"\n654                            \"format: %s\", hwaccel_output_format);\n655                 }\n656             } else {\n657                 ist->hwaccel_output_format = AV_PIX_FMT_NONE;\n658             }\n659\n660             ist->hwaccel_pix_fmt = AV_PIX_FMT_NONE;\n661\n662             break;\n663         case AVMEDIA_TYPE_AUDIO:\n664             guess_input_channel_layout(ist);\n665             break;\n666         case AVMEDIA_TYPE_DATA:\n667         case AVMEDIA_TYPE_SUBTITLE:\n668         case AVMEDIA_TYPE_ATTACHMENT:\n669         case AVMEDIA_TYPE_UNKNOWN:\n670             break;\n671         default:\n672             abort();\n673         }\n674     }\n675 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavutil/hwcontext.c",
                        "function_body": "81 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n82 {\n83     enum AVHWDeviceType next;\n84     int i, set = 0;\n85     for (i = 0; hw_table[i]; i++) {\n86         if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n87             continue;\n88         if (!set || hw_table[i]->type < next) {\n89             next = hw_table[i]->type;\n90             set = 1;\n91         }\n92     }\n93     return set ? next : AV_HWDEVICE_TYPE_NONE;\n94 }"
                    },
                    {
                        "file_path": "/avtools/avconv_opt.c",
                        "function_body": "410 static int copy_metadata(char *outspec, char *inspec, AVFormatContext *oc, AVFormatContext *ic, OptionsContext *o)\n411 {\n412     AVDictionary **meta_in = NULL;\n413     AVDictionary **meta_out;\n414     int i, ret = 0;\n415     char type_in, type_out;\n416     const char *istream_spec = NULL, *ostream_spec = NULL;\n417     int idx_in = 0, idx_out = 0;\n418\n419     parse_meta_type(inspec,  &type_in,  &idx_in,  &istream_spec);\n420     parse_meta_type(outspec, &type_out, &idx_out, &ostream_spec);\n421\n422     if (type_in == 'g' || type_out == 'g')\n423         o->metadata_global_manual = 1;\n424     if (type_in == 's' || type_out == 's')\n425         o->metadata_streams_manual = 1;\n426     if (type_in == 'c' || type_out == 'c')\n427         o->metadata_chapters_manual = 1;\n428\n429     /* ic is NULL when just disabling automatic mappings */\n430     if (!ic)\n431         return 0;\n432\n433 #define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n434     if ((index) < 0 || (index) >= (nb_elems)) {\\\n435         av_log(NULL, AV_LOG_FATAL, \"Invalid %s index %d while processing metadata maps.\\n\",\\\n436                 (desc), (index));\\\n437         exit_program(1);\\\n438     }\n439\n440 #define SET_DICT(type, meta, context, index)\\\n441         switch (type) {\\\n442         case 'g':\\\n443             meta = &context->metadata;\\\n444             break;\\\n445         case 'c':\\\n446             METADATA_CHECK_INDEX(index, context->nb_chapters, \"chapter\")\\\n447             meta = &context->chapters[index]->metadata;\\\n448             break;\\\n449         case 'p':\\\n450             METADATA_CHECK_INDEX(index, context->nb_programs, \"program\")\\\n451             meta = &context->programs[index]->metadata;\\\n452             break;\\\n453         case 's':\\\n454             break; /* handled separately below */ \\\n455         default: av_assert0(0);\\\n456         }\\\n457\n458     SET_DICT(type_in, meta_in, ic, idx_in);\n459     SET_DICT(type_out, meta_out, oc, idx_out);\n460\n461     /* for input streams choose first matching stream */\n462     if (type_in == 's') {\n463         for (i = 0; i < ic->nb_streams; i++) {\n464             if ((ret = check_stream_specifier(ic, ic->streams[i], istream_spec)) > 0) {\n465                 meta_in = &ic->streams[i]->metadata;\n466                 break;\n467             } else if (ret < 0)\n468                 exit_program(1);\n469         }\n470         if (!meta_in) {\n471             av_log(NULL, AV_LOG_FATAL, \"Stream specifier %s does not match  any streams.\\n\", istream_spec);\n472             exit_program(1);\n473         }\n474     }\n475\n476     if (type_out == 's') {\n477         for (i = 0; i < oc->nb_streams; i++) {\n478             if ((ret = check_stream_specifier(oc, oc->streams[i], ostream_spec)) > 0) {\n479                 meta_out = &oc->streams[i]->metadata;\n480                 av_dict_copy(meta_out, *meta_in, AV_DICT_DONT_OVERWRITE);\n481             } else if (ret < 0)\n482                 exit_program(1);\n483         }\n484     } else\n485         av_dict_copy(meta_out, *meta_in, AV_DICT_DONT_OVERWRITE);\n486\n487     return 0;\n488 }"
                    }
                ]
            }
        ],
        "sink": "if (!set || hw_table[i]->type < next) {",
        "final_sink": "if (!set || hw_table[i]->type < next) {"
    },
    {
        "prt": "A1",
        "function_call": [
            "static av_always_inline void\nyuv2rgb_1_c_template(SwsContext *c, const int16_t *buf0,\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n                     const int16_t *abuf0, uint8_t *dest, int dstW,\n                     int uvalpha, int y, enum AVPixelFormat target,\n                     int hasAlpha)\n{\n    const int16_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n    int i;\n\n    if (uvalpha < 2048) {\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n            int Y1 = buf0[i * 2]     >> 7;\n            int Y2 = buf0[i * 2 + 1] >> 7;\n            int U  = ubuf0[i]        >> 7;\n            int V  = vbuf0[i]        >> 7;\n            int A1, A2;\n            const void *r, *g, *b;\n\n            Y1 = av_clip_uint8(Y1);\n            Y2 = av_clip_uint8(Y2);\n            U  = av_clip_uint8(U);\n            V  = av_clip_uint8(V);\n\n            r =  c->table_rV[V];\n            g = (c->table_gU[U] + c->table_gV[V]);\n            b =  c->table_bU[U];\n\n            if (hasAlpha) {\n                A1 = abuf0[i * 2    ] >> 7;\n                A2 = abuf0[i * 2 + 1] >> 7;\n                A1 = av_clip_uint8(A1);\n                A2 = av_clip_uint8(A2);\n            }\n\n            yuv2rgb_write(dest, i, Y1, Y2, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n                          r, g, b, y, target, hasAlpha);\n        }\n    } else {\n        const int16_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n        for (i = 0; i < ((dstW + 1) >> 1); i++) {\n            int Y1 =  buf0[i * 2]          >> 7;\n            int Y2 =  buf0[i * 2 + 1]      >> 7;\n            int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n            int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n            int A1, A2;\n            const void *r, *g, *b;\n\n            Y1 = av_clip_uint8(Y1);\n            Y2 = av_clip_uint8(Y2);\n            U  = av_clip_uint8(U);\n            V  = av_clip_uint8(V);\n\n            r =  c->table_rV[V];\n            g = (c->table_gU[U] + c->table_gV[V]);\n            b =  c->table_bU[U];\n\n            if (hasAlpha) {\n                A1 = abuf0[i * 2    ] >> 7;\n                A2 = abuf0[i * 2 + 1] >> 7;\n                A1 = av_clip_uint8(A1);\n                A2 = av_clip_uint8(A2);\n            }\n\n            yuv2rgb_write(dest, i, Y1, Y2, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n                          r, g, b, y, target, hasAlpha);\n        }\n    }\n}"
        ],
        "source": [
            "            int A1, A2;"
        ],
        "index": 22,
        "location": {
            "file_path": "libswscale/output.c",
            "region": {
                "startLine": 1077,
                "startColumn": 55,
                "endColumn": 57
            },
            "context": {
                "startLine": 1075,
                "endLine": 1079,
                "snippet": {
                    "text": "            yuv2rgb_write(dest, i, Y1, Y2, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/faanidct.c",
                        "function_body": "37 #define A2 0.92387953251128675613 // cos(pi*2/16)"
                    },
                    {
                        "file_path": "/libavcodec/faandct.c",
                        "function_body": "51 #define A2 0.54119610014619698435 // cos(pi*6/16)sqrt(2)"
                    },
                    {
                        "file_path": "/libavcodec/eaidct.c",
                        "function_body": "33 #define A2    277 /* sin(pi/8)*sqrt(2)<<9 */"
                    },
                    {
                        "file_path": "/libavcodec/binkdsp.c",
                        "function_body": "32 #define A2  2217"
                    },
                    {
                        "file_path": "/libavcodec/faandct.c",
                        "function_body": "50 #define A1 0.70710678118654752438 // cos(pi*4/16)"
                    },
                    {
                        "file_path": "/libavcodec/binkdsp.c",
                        "function_body": "31 #define A1  2896 /* (1/sqrt(2))<<12 */"
                    },
                    {
                        "file_path": "/libswscale/output.c",
                        "function_body": "811 YUV2PACKED16WRAPPER(yuv2, rgb48, rgb48be, AV_PIX_FMT_RGB48BE)\n812 YUV2PACKED16WRAPPER(yuv2, rgb48, rgb48le, AV_PIX_FMT_RGB48LE)\n813 YUV2PACKED16WRAPPER(yuv2, rgb48, bgr48be, AV_PIX_FMT_BGR48BE)\n814 YUV2PACKED16WRAPPER(yuv2, rgb48, bgr48le, AV_PIX_FMT_BGR48LE)\n815\n816 /*\n817  * Write out 2 RGB pixels in the target pixel format. This function takes a\n818  * R/G/B LUT as generated by ff_yuv2rgb_c_init_tables(), which takes care of\n819  * things like endianness conversion and shifting. The caller takes care of\n820  * setting the correct offset in these tables from the chroma (U/V) values.\n821  * This function then uses the luminance (Y1/Y2) values to write out the\n822  * correct RGB values into the destination buffer.\n823  */\n824 static av_always_inline void\n825 yuv2rgb_write(uint8_t *_dest, int i, unsigned Y1, unsigned Y2,\n826               unsigned A1, unsigned A2,\n827               const void *_r, const void *_g, const void *_b, int y,\n828               enum AVPixelFormat target, int hasAlpha)\n829 {\n830     if (target == AV_PIX_FMT_ARGB || target == AV_PIX_FMT_RGBA ||\n831         target == AV_PIX_FMT_ABGR || target == AV_PIX_FMT_BGRA) {\n832         uint32_t *dest = (uint32_t *) _dest;\n833         const uint32_t *r = (const uint32_t *) _r;\n834         const uint32_t *g = (const uint32_t *) _g;\n835         const uint32_t *b = (const uint32_t *) _b;\n836\n837 #if CONFIG_SMALL\n838         int sh = hasAlpha ? ((target == AV_PIX_FMT_RGB32_1 || target == AV_PIX_FMT_BGR32_1) ? 0 : 24) : 0;\n839\n840         dest[i * 2 + 0] = r[Y1] + g[Y1] + b[Y1] + (hasAlpha ? A1 << sh : 0);\n841         dest[i * 2 + 1] = r[Y2] + g[Y2] + b[Y2] + (hasAlpha ? A2 << sh : 0);\n842 #else\n843         if (hasAlpha) {\n844             int sh = (target == AV_PIX_FMT_RGB32_1 || target == AV_PIX_FMT_BGR32_1) ? 0 : 24;\n845\n846             dest[i * 2 + 0] = r[Y1] + g[Y1] + b[Y1] + (A1 << sh);\n847             dest[i * 2 + 1] = r[Y2] + g[Y2] + b[Y2] + (A2 << sh);\n848         } else {\n849             dest[i * 2 + 0] = r[Y1] + g[Y1] + b[Y1];\n850             dest[i * 2 + 1] = r[Y2] + g[Y2] + b[Y2];\n851         }\n852 #endif\n853     } else if (target == AV_PIX_FMT_RGB24 || target == AV_PIX_FMT_BGR24) {\n854         uint8_t *dest = (uint8_t *) _dest;\n855         const uint8_t *r = (const uint8_t *) _r;\n856         const uint8_t *g = (const uint8_t *) _g;\n857         const uint8_t *b = (const uint8_t *) _b;\n858\n859 #define r_b ((target == AV_PIX_FMT_RGB24) ? r : b)\n860 #define b_r ((target == AV_PIX_FMT_RGB24) ? b : r)\n861         dest[i * 6 + 0] = r_b[Y1];\n862         dest[i * 6 + 1] =   g[Y1];\n863         dest[i * 6 + 2] = b_r[Y1];\n864         dest[i * 6 + 3] = r_b[Y2];\n865         dest[i * 6 + 4] =   g[Y2];\n866         dest[i * 6 + 5] = b_r[Y2];\n867 #undef r_b\n868 #undef b_r\n869     } else if (target == AV_PIX_FMT_RGB565 || target == AV_PIX_FMT_BGR565 ||\n870                target == AV_PIX_FMT_RGB555 || target == AV_PIX_FMT_BGR555 ||\n871                target == AV_PIX_FMT_RGB444 || target == AV_PIX_FMT_BGR444) {\n872         uint16_t *dest = (uint16_t *) _dest;\n873         const uint16_t *r = (const uint16_t *) _r;\n874         const uint16_t *g = (const uint16_t *) _g;\n875         const uint16_t *b = (const uint16_t *) _b;\n876         int dr1, dg1, db1, dr2, dg2, db2;\n877\n878         if (target == AV_PIX_FMT_RGB565 || target == AV_PIX_FMT_BGR565) {\n879             dr1 = dither_2x2_8[ y & 1     ][0];\n880             dg1 = dither_2x2_4[ y & 1     ][0];\n881             db1 = dither_2x2_8[(y & 1) ^ 1][0];\n882             dr2 = dither_2x2_8[ y & 1     ][1];\n883             dg2 = dither_2x2_4[ y & 1     ][1];\n884             db2 = dither_2x2_8[(y & 1) ^ 1][1];\n885         } else if (target == AV_PIX_FMT_RGB555 || target == AV_PIX_FMT_BGR555) {\n886             dr1 = dither_2x2_8[ y & 1     ][0];\n887             dg1 = dither_2x2_8[ y & 1     ][1];\n888             db1 = dither_2x2_8[(y & 1) ^ 1][0];\n889             dr2 = dither_2x2_8[ y & 1     ][1];\n890             dg2 = dither_2x2_8[ y & 1     ][0];\n891             db2 = dither_2x2_8[(y & 1) ^ 1][1];\n892         } else {\n893             dr1 = ff_dither_4x4_16[ y & 3     ][0];\n894             dg1 = ff_dither_4x4_16[ y & 3     ][1];\n895             db1 = ff_dither_4x4_16[(y & 3) ^ 3][0];\n896             dr2 = ff_dither_4x4_16[ y & 3     ][1];\n897             dg2 = ff_dither_4x4_16[ y & 3     ][0];\n898             db2 = ff_dither_4x4_16[(y & 3) ^ 3][1];\n899         }\n900\n901         dest[i * 2 + 0] = r[Y1 + dr1] + g[Y1 + dg1] + b[Y1 + db1];\n902         dest[i * 2 + 1] = r[Y2 + dr2] + g[Y2 + dg2] + b[Y2 + db2];\n903     } else /* 8/4 bits */ {\n904         uint8_t *dest = (uint8_t *) _dest;\n905         const uint8_t *r = (const uint8_t *) _r;\n906         const uint8_t *g = (const uint8_t *) _g;\n907         const uint8_t *b = (const uint8_t *) _b;\n908         int dr1, dg1, db1, dr2, dg2, db2;\n909\n910         if (target == AV_PIX_FMT_RGB8 || target == AV_PIX_FMT_BGR8) {\n911             const uint8_t * const d64 = ff_dither_8x8_73[y & 7];\n912             const uint8_t * const d32 = ff_dither_8x8_32[y & 7];\n913             dr1 = dg1 = d32[(i * 2 + 0) & 7];\n914             db1 =       d64[(i * 2 + 0) & 7];\n915             dr2 = dg2 = d32[(i * 2 + 1) & 7];\n916             db2 =       d64[(i * 2 + 1) & 7];\n917         } else {\n918             const uint8_t * const d64  = ff_dither_8x8_73 [y & 7];\n919             const uint8_t * const d128 = ff_dither_8x8_220[y & 7];\n920             dr1 = db1 = d128[(i * 2 + 0) & 7];\n921             dg1 =        d64[(i * 2 + 0) & 7];\n922             dr2 = db2 = d128[(i * 2 + 1) & 7];\n923             dg2 =        d64[(i * 2 + 1) & 7];\n924         }\n925\n926         if (target == AV_PIX_FMT_RGB4 || target == AV_PIX_FMT_BGR4) {\n927             dest[i] = r[Y1 + dr1] + g[Y1 + dg1] + b[Y1 + db1] +\n928                     ((r[Y2 + dr2] + g[Y2 + dg2] + b[Y2 + db2]) << 4);\n929         } else {\n930             dest[i * 2 + 0] = r[Y1 + dr1] + g[Y1 + dg1] + b[Y1 + db1];\n931             dest[i * 2 + 1] = r[Y2 + dr2] + g[Y2 + dg2] + b[Y2 + db2];\n932         }\n933     }\n934 }"
                    },
                    {
                        "file_path": "/libswscale/output.c",
                        "function_body": "1043 yuv2rgb_1_c_template(SwsContext *c, const int16_t *buf0,\n1044                      const int16_t *ubuf[2], const int16_t *vbuf[2],\n1045                      const int16_t *abuf0, uint8_t *dest, int dstW,\n1046                      int uvalpha, int y, enum AVPixelFormat target,\n1047                      int hasAlpha)\n1048 {\n1049     const int16_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n1050     int i;\n1051\n1052     if (uvalpha < 2048) {\n1053         for (i = 0; i < ((dstW + 1) >> 1); i++) {\n1054             int Y1 = buf0[i * 2]     >> 7;\n1055             int Y2 = buf0[i * 2 + 1] >> 7;\n1056             int U  = ubuf0[i]        >> 7;\n1057             int V  = vbuf0[i]        >> 7;\n1058             int A1, A2;\n1059             const void *r, *g, *b;\n1060\n1061             Y1 = av_clip_uint8(Y1);\n1062             Y2 = av_clip_uint8(Y2);\n1063             U  = av_clip_uint8(U);\n1064             V  = av_clip_uint8(V);\n1065\n1066             r =  c->table_rV[V];\n1067             g = (c->table_gU[U] + c->table_gV[V]);\n1068             b =  c->table_bU[U];\n1069\n1070             if (hasAlpha) {\n1071                 A1 = abuf0[i * 2    ] >> 7;\n1072                 A2 = abuf0[i * 2 + 1] >> 7;\n1073                 A1 = av_clip_uint8(A1);\n1074                 A2 = av_clip_uint8(A2);\n1075             }\n1076\n1077             yuv2rgb_write(dest, i, Y1, Y2, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n1078                           r, g, b, y, target, hasAlpha);\n1079         }\n1080     } else {\n1081         const int16_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n1082         for (i = 0; i < ((dstW + 1) >> 1); i++) {\n1083             int Y1 =  buf0[i * 2]          >> 7;\n1084             int Y2 =  buf0[i * 2 + 1]      >> 7;\n1085             int U  = (ubuf0[i] + ubuf1[i]) >> 8;\n1086             int V  = (vbuf0[i] + vbuf1[i]) >> 8;\n1087             int A1, A2;\n1088             const void *r, *g, *b;\n1089\n1090             Y1 = av_clip_uint8(Y1);\n1091             Y2 = av_clip_uint8(Y2);\n1092             U  = av_clip_uint8(U);\n1093             V  = av_clip_uint8(V);\n1094\n1095             r =  c->table_rV[V];\n1096             g = (c->table_gU[U] + c->table_gV[V]);\n1097             b =  c->table_bU[U];\n1098\n1099             if (hasAlpha) {\n1100                 A1 = abuf0[i * 2    ] >> 7;\n1101                 A2 = abuf0[i * 2 + 1] >> 7;\n1102                 A1 = av_clip_uint8(A1);\n1103                 A2 = av_clip_uint8(A2);\n1104             }\n1105\n1106             yuv2rgb_write(dest, i, Y1, Y2, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n1107                           r, g, b, y, target, hasAlpha);\n1108         }\n1109     }\n1110 }"
                    }
                ]
            }
        ],
        "sink": "yuv2rgb_write(dest, i, Y1, Y2, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,",
        "final_sink": "yuv2rgb_write(dest, i, Y1, Y2, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,"
    },
    {
        "prt": "extradata",
        "function_call": [
            "static av_cold int encode_init(AVCodecContext *avctx)\n{\n    WMACodecContext *s = avctx->priv_data;\n    int i, flags1, flags2, block_align;\n    uint8_t *extradata;\n\n    s->avctx = avctx;\n\n    if (avctx->channels > MAX_CHANNELS) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"too many channels: got %i, need %i or fewer\",\n               avctx->channels, MAX_CHANNELS);\n        return AVERROR(EINVAL);\n    }\n\n    if (avctx->sample_rate > 48000) {\n        av_log(avctx, AV_LOG_ERROR, \"sample rate is too high: %d > 48kHz\",\n               avctx->sample_rate);\n        return AVERROR(EINVAL);\n    }\n\n    if (avctx->bit_rate < 24 * 1000) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"bitrate too low: got %i, need 24000 or higher\\n\",\n               avctx->bit_rate);\n        return AVERROR(EINVAL);\n    }\n\n    /* extract flag info */\n    flags1 = 0;\n    flags2 = 1;\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n        extradata             = av_malloc(4);\n        if (!extradata)\n            return AVERROR(ENOMEM);\n        avctx->extradata_size = 4;\n        AV_WL16(extradata, flags1);\n        AV_WL16(extradata + 2, flags2);\n    } else if (avctx->codec->id == AV_CODEC_ID_WMAV2) {\n        extradata             = av_mallocz(10);\n        if (!extradata)\n            return AVERROR(ENOMEM);\n        avctx->extradata_size = 10;\n        AV_WL32(extradata, flags1);\n        AV_WL16(extradata + 4, flags2);\n    } else {\n        assert(0);\n    }\n    avctx->extradata          = extradata;\n    s->use_exp_vlc            = flags2 & 0x0001;\n    s->use_bit_reservoir      = flags2 & 0x0002;\n    s->use_variable_block_len = flags2 & 0x0004;\n    if (avctx->channels == 2)\n        s->ms_stereo = 1;\n\n    ff_wma_init(avctx, flags2);\n\n    /* init MDCT */\n    for (i = 0; i < s->nb_block_sizes; i++)\n        ff_mdct_init(&s->mdct_ctx[i], s->frame_len_bits - i + 1, 0, 1.0);\n\n    block_align        = avctx->bit_rate * (int64_t) s->frame_len /\n                         (avctx->sample_rate * 8);\n    block_align        = FFMIN(block_align, MAX_CODED_SUPERFRAME_SIZE);\n    avctx->block_align = block_align;\n    avctx->bit_rate    = avctx->block_align * 8LL * avctx->sample_rate /\n                         s->frame_len;\n    avctx->frame_size = avctx->initial_padding = s->frame_len;\n\n    return 0;\n}"
        ],
        "source": [
            "    uint8_t *extradata;"
        ],
        "index": 23,
        "location": {
            "file_path": "libavcodec/wmaenc.c",
            "region": {
                "startLine": 80,
                "startColumn": 5,
                "endColumn": 14
            },
            "context": {
                "startLine": 78,
                "endLine": 82,
                "snippet": {
                    "text": "avctx->extradata          = extradata;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/wmaenc.c",
                        "function_body": "32 static av_cold int encode_init(AVCodecContext *avctx)\n33 {\n34     WMACodecContext *s = avctx->priv_data;\n35     int i, flags1, flags2, block_align;\n36     uint8_t *extradata;\n37\n38     s->avctx = avctx;\n39\n40     if (avctx->channels > MAX_CHANNELS) {\n41         av_log(avctx, AV_LOG_ERROR,\n42                \"too many channels: got %i, need %i or fewer\",\n43                avctx->channels, MAX_CHANNELS);\n44         return AVERROR(EINVAL);\n45     }\n46\n47     if (avctx->sample_rate > 48000) {\n48         av_log(avctx, AV_LOG_ERROR, \"sample rate is too high: %d > 48kHz\",\n49                avctx->sample_rate);\n50         return AVERROR(EINVAL);\n51     }\n52\n53     if (avctx->bit_rate < 24 * 1000) {\n54         av_log(avctx, AV_LOG_ERROR,\n55                \"bitrate too low: got %i, need 24000 or higher\\n\",\n56                avctx->bit_rate);\n57         return AVERROR(EINVAL);\n58     }\n59\n60     /* extract flag info */\n61     flags1 = 0;\n62     flags2 = 1;\n63     if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n64         extradata             = av_malloc(4);\n65         if (!extradata)\n66             return AVERROR(ENOMEM);\n67         avctx->extradata_size = 4;\n68         AV_WL16(extradata, flags1);\n69         AV_WL16(extradata + 2, flags2);\n70     } else if (avctx->codec->id == AV_CODEC_ID_WMAV2) {\n71         extradata             = av_mallocz(10);\n72         if (!extradata)\n73             return AVERROR(ENOMEM);\n74         avctx->extradata_size = 10;\n75         AV_WL32(extradata, flags1);\n76         AV_WL16(extradata + 4, flags2);\n77     } else {\n78         assert(0);\n79     }\n80     avctx->extradata          = extradata;\n81     s->use_exp_vlc            = flags2 & 0x0001;\n82     s->use_bit_reservoir      = flags2 & 0x0002;\n83     s->use_variable_block_len = flags2 & 0x0004;\n84     if (avctx->channels == 2)\n85         s->ms_stereo = 1;\n86\n87     ff_wma_init(avctx, flags2);\n88\n89     /* init MDCT */\n90     for (i = 0; i < s->nb_block_sizes; i++)\n91         ff_mdct_init(&s->mdct_ctx[i], s->frame_len_bits - i + 1, 0, 1.0);\n92\n93     block_align        = avctx->bit_rate * (int64_t) s->frame_len /\n94                          (avctx->sample_rate * 8);\n95     block_align        = FFMIN(block_align, MAX_CODED_SUPERFRAME_SIZE);\n96     avctx->block_align = block_align;\n97     avctx->bit_rate    = avctx->block_align * 8LL * avctx->sample_rate /\n98                          s->frame_len;\n99     avctx->frame_size = avctx->initial_padding = s->frame_len;\n100\n101     return 0;\n102 }"
                    }
                ]
            }
        ],
        "sink": "avctx->extradata          = extradata;",
        "final_sink": "avctx->extradata          = extradata;"
    },
    {
        "prt": "b0_1",
        "function_call": [
            "void ff_ivi_recompose53(const IVIPlaneDesc *plane, uint8_t *dst,\n                        const ptrdiff_t dst_pitch)\n{\n    int             x, y, indx;\n    int32_t         p0, p1, p2, p3, tmp0, tmp1, tmp2;\n    int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;\n    int32_t         b3_1, b3_2, b3_3, b3_4, b3_5, b3_6, b3_7, b3_8, b3_9;\n    ptrdiff_t       pitch, back_pitch;\n    const short    *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n    const int       num_bands = 4;\n\n    /* all bands should have the same pitch */\n    pitch = plane->bands[0].pitch;\n\n    /* pixels at the position \"y-1\" will be set to pixels at the \"y\" for the 1st iteration */\n    back_pitch = 0;\n\n    /* get pointers to the wavelet bands */\n    b0_ptr = plane->bands[0].buf;\n    b1_ptr = plane->bands[1].buf;\n    b2_ptr = plane->bands[2].buf;\n    b3_ptr = plane->bands[3].buf;\n\n    for (y = 0; y < plane->height; y += 2) {\n        /* load storage variables with values */\n        if (num_bands > 0) {\n            b0_1 = b0_ptr[0];\n            b0_2 = b0_ptr[pitch];\n        }\n\n        if (num_bands > 1) {\n            b1_1 = b1_ptr[back_pitch];\n            b1_2 = b1_ptr[0];\n            b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch];\n        }\n\n        if (num_bands > 2) {\n            b2_2 = b2_ptr[0];     // b2[x,  y  ]\n            b2_3 = b2_2;          // b2[x+1,y  ] = b2[x,y]\n            b2_5 = b2_ptr[pitch]; // b2[x  ,y+1]\n            b2_6 = b2_5;          // b2[x+1,y+1] = b2[x,y+1]\n        }\n\n        if (num_bands > 3) {\n            b3_2 = b3_ptr[back_pitch]; // b3[x  ,y-1]\n            b3_3 = b3_2;               // b3[x+1,y-1] = b3[x  ,y-1]\n            b3_5 = b3_ptr[0];          // b3[x  ,y  ]\n            b3_6 = b3_5;               // b3[x+1,y  ] = b3[x  ,y  ]\n            b3_8 = b3_2 - b3_5*6 + b3_ptr[pitch];\n            b3_9 = b3_8;\n        }\n\n        for (x = 0, indx = 0; x < plane->width; x+=2, indx++) {\n            /* some values calculated in the previous iterations can */\n            /* be reused in the next ones, so do appropriate copying */\n            b2_1 = b2_2; // b2[x-1,y  ] = b2[x,  y  ]\n            b2_2 = b2_3; // b2[x  ,y  ] = b2[x+1,y  ]\n            b2_4 = b2_5; // b2[x-1,y+1] = b2[x  ,y+1]\n            b2_5 = b2_6; // b2[x  ,y+1] = b2[x+1,y+1]\n            b3_1 = b3_2; // b3[x-1,y-1] = b3[x  ,y-1]\n            b3_2 = b3_3; // b3[x  ,y-1] = b3[x+1,y-1]\n            b3_4 = b3_5; // b3[x-1,y  ] = b3[x  ,y  ]\n            b3_5 = b3_6; // b3[x  ,y  ] = b3[x+1,y  ]\n            b3_7 = b3_8; // vert_HPF(x-1)\n            b3_8 = b3_9; // vert_HPF(x  )\n\n            p0 = p1 = p2 = p3 = 0;\n\n            /* process the LL-band by applying LPF both vertically and horizontally */\n            if (num_bands > 0) {\n                tmp0 = b0_1;\n                tmp2 = b0_2;\n                b0_1 = b0_ptr[indx+1];\n                b0_2 = b0_ptr[pitch+indx+1];\n                tmp1 = tmp0 + b0_1;\n\n                p0 =  tmp0 << 4;\n                p1 =  tmp1 << 3;\n                p2 = (tmp0 + tmp2) << 3;\n                p3 = (tmp1 + tmp2 + b0_2) << 2;\n            }\n\n            /* process the HL-band by applying HPF vertically and LPF horizontally */\n            if (num_bands > 1) {\n                tmp0 = b1_2;\n                tmp1 = b1_1;\n                b1_2 = b1_ptr[indx+1];\n                b1_1 = b1_ptr[back_pitch+indx+1];\n\n                tmp2 = tmp1 - tmp0*6 + b1_3;\n                b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch+indx+1];\n\n                p0 += (tmp0 + tmp1) << 3;\n                p1 += (tmp0 + tmp1 + b1_1 + b1_2) << 2;\n                p2 +=  tmp2 << 2;\n                p3 += (tmp2 + b1_3) << 1;\n            }\n\n            /* process the LH-band by applying LPF vertically and HPF horizontally */\n            if (num_bands > 2) {\n                b2_3 = b2_ptr[indx+1];\n                b2_6 = b2_ptr[pitch+indx+1];\n\n                tmp0 = b2_1 + b2_2;\n                tmp1 = b2_1 - b2_2*6 + b2_3;\n\n                p0 += tmp0 << 3;\n                p1 += tmp1 << 2;\n                p2 += (tmp0 + b2_4 + b2_5) << 2;\n                p3 += (tmp1 + b2_4 - b2_5*6 + b2_6) << 1;\n            }\n\n            /* process the HH-band by applying HPF both vertically and horizontally */\n            if (num_bands > 3) {\n                b3_6 = b3_ptr[indx+1];            // b3[x+1,y  ]\n                b3_3 = b3_ptr[back_pitch+indx+1]; // b3[x+1,y-1]\n\n                tmp0 = b3_1 + b3_4;\n                tmp1 = b3_2 + b3_5;\n                tmp2 = b3_3 + b3_6;\n\n                b3_9 = b3_3 - b3_6*6 + b3_ptr[pitch+indx+1];\n\n                p0 += (tmp0 + tmp1) << 2;\n                p1 += (tmp0 - tmp1*6 + tmp2) << 1;\n                p2 += (b3_7 + b3_8) << 1;\n                p3 +=  b3_7 - b3_8*6 + b3_9;\n            }\n\n            /* output four pixels */\n            dst[x]             = av_clip_uint8((p0 >> 6) + 128);\n            dst[x+1]           = av_clip_uint8((p1 >> 6) + 128);\n            dst[dst_pitch+x]   = av_clip_uint8((p2 >> 6) + 128);\n            dst[dst_pitch+x+1] = av_clip_uint8((p3 >> 6) + 128);\n        }// for x\n\n        dst += dst_pitch << 1;\n\n        back_pitch = -pitch;\n\n        b0_ptr += pitch;\n        b1_ptr += pitch;\n        b2_ptr += pitch;\n        b3_ptr += pitch;\n    }\n}"
        ],
        "source": [
            "    int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;"
        ],
        "index": 24,
        "location": {
            "file_path": "libavcodec/ivi_dsp.c",
            "region": {
                "startLine": 103,
                "startColumn": 17,
                "endColumn": 21
            },
            "context": {
                "startLine": 101,
                "endLine": 105,
                "snippet": {
                    "text": "tmp0 = b0_1;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/ivi_dsp.c",
                        "function_body": "33  void ff_ivi_recompose53(const IVIPlaneDesc *plane, uint8_t *dst,\n34                          const ptrdiff_t dst_pitch)\n35  {\n36      int             x, y, indx;\n37      int32_t         p0, p1, p2, p3, tmp0, tmp1, tmp2;\n38      int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;\n39      int32_t         b3_1, b3_2, b3_3, b3_4, b3_5, b3_6, b3_7, b3_8, b3_9;\n40      ptrdiff_t       pitch, back_pitch;\n41      const short    *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n42      const int       num_bands = 4;\n43\n44      /* all bands should have the same pitch */\n45      pitch = plane->bands[0].pitch;\n46\n47      /* pixels at the position \"y-1\" will be set to pixels at the \"y\" for the 1st iteration */\n48      back_pitch = 0;\n49\n50      /* get pointers to the wavelet bands */\n51      b0_ptr = plane->bands[0].buf;\n52      b1_ptr = plane->bands[1].buf;\n53      b2_ptr = plane->bands[2].buf;\n54      b3_ptr = plane->bands[3].buf;\n55\n56      for (y = 0; y < plane->height; y += 2) {\n57          /* load storage variables with values */\n58          if (num_bands > 0) {\n59              b0_1 = b0_ptr[0];\n60              b0_2 = b0_ptr[pitch];\n61          }\n62\n63          if (num_bands > 1) {\n64              b1_1 = b1_ptr[back_pitch];\n65              b1_2 = b1_ptr[0];\n66              b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch];\n67          }\n68\n69          if (num_bands > 2) {\n70              b2_2 = b2_ptr[0];     // b2[x,  y  ]\n71              b2_3 = b2_2;          // b2[x+1,y  ] = b2[x,y]\n72              b2_5 = b2_ptr[pitch]; // b2[x  ,y+1]\n73              b2_6 = b2_5;          // b2[x+1,y+1] = b2[x,y+1]\n74          }\n75\n76          if (num_bands > 3) {\n77              b3_2 = b3_ptr[back_pitch]; // b3[x  ,y-1]\n78              b3_3 = b3_2;               // b3[x+1,y-1] = b3[x  ,y-1]\n79              b3_5 = b3_ptr[0];          // b3[x  ,y  ]\n80              b3_6 = b3_5;               // b3[x+1,y  ] = b3[x  ,y  ]\n81              b3_8 = b3_2 - b3_5*6 + b3_ptr[pitch];\n82              b3_9 = b3_8;\n83          }\n84\n85          for (x = 0, indx = 0; x < plane->width; x+=2, indx++) {\n86              /* some values calculated in the previous iterations can */\n87              /* be reused in the next ones, so do appropriate copying */\n88              b2_1 = b2_2; // b2[x-1,y  ] = b2[x,  y  ]\n89              b2_2 = b2_3; // b2[x  ,y  ] = b2[x+1,y  ]\n90              b2_4 = b2_5; // b2[x-1,y+1] = b2[x  ,y+1]\n91              b2_5 = b2_6; // b2[x  ,y+1] = b2[x+1,y+1]\n92              b3_1 = b3_2; // b3[x-1,y-1] = b3[x  ,y-1]\n93              b3_2 = b3_3; // b3[x  ,y-1] = b3[x+1,y-1]\n94              b3_4 = b3_5; // b3[x-1,y  ] = b3[x  ,y  ]\n95              b3_5 = b3_6; // b3[x  ,y  ] = b3[x+1,y  ]\n96              b3_7 = b3_8; // vert_HPF(x-1)\n97              b3_8 = b3_9; // vert_HPF(x  )\n98\n99              p0 = p1 = p2 = p3 = 0;\n100\n101             /* process the LL-band by applying LPF both vertically and horizontally */\n102             if (num_bands > 0) {\n103                 tmp0 = b0_1;\n104                 tmp2 = b0_2;\n105                 b0_1 = b0_ptr[indx+1];\n106                 b0_2 = b0_ptr[pitch+indx+1];\n107                 tmp1 = tmp0 + b0_1;\n108\n109                 p0 =  tmp0 << 4;\n110                 p1 =  tmp1 << 3;\n111                 p2 = (tmp0 + tmp2) << 3;\n112                 p3 = (tmp1 + tmp2 + b0_2) << 2;\n113             }\n114\n115             /* process the HL-band by applying HPF vertically and LPF horizontally */\n116             if (num_bands > 1) {\n117                 tmp0 = b1_2;\n118                 tmp1 = b1_1;\n119                 b1_2 = b1_ptr[indx+1];\n120                 b1_1 = b1_ptr[back_pitch+indx+1];\n121\n122                 tmp2 = tmp1 - tmp0*6 + b1_3;\n123                 b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch+indx+1];\n124\n125                 p0 += (tmp0 + tmp1) << 3;\n126                 p1 += (tmp0 + tmp1 + b1_1 + b1_2) << 2;\n127                 p2 +=  tmp2 << 2;\n128                 p3 += (tmp2 + b1_3) << 1;\n129             }\n130\n131             /* process the LH-band by applying LPF vertically and HPF horizontally */\n132             if (num_bands > 2) {\n133                 b2_3 = b2_ptr[indx+1];\n134                 b2_6 = b2_ptr[pitch+indx+1];\n135\n136                 tmp0 = b2_1 + b2_2;\n137                 tmp1 = b2_1 - b2_2*6 + b2_3;\n138\n139                 p0 += tmp0 << 3;\n140                 p1 += tmp1 << 2;\n141                 p2 += (tmp0 + b2_4 + b2_5) << 2;\n142                 p3 += (tmp1 + b2_4 - b2_5*6 + b2_6) << 1;\n143             }\n144\n145             /* process the HH-band by applying HPF both vertically and horizontally */\n146             if (num_bands > 3) {\n147                 b3_6 = b3_ptr[indx+1];            // b3[x+1,y  ]\n148                 b3_3 = b3_ptr[back_pitch+indx+1]; // b3[x+1,y-1]\n149\n150                 tmp0 = b3_1 + b3_4;\n151                 tmp1 = b3_2 + b3_5;\n152                 tmp2 = b3_3 + b3_6;\n153\n154                 b3_9 = b3_3 - b3_6*6 + b3_ptr[pitch+indx+1];\n155\n156                 p0 += (tmp0 + tmp1) << 2;\n157                 p1 += (tmp0 - tmp1*6 + tmp2) << 1;\n158                 p2 += (b3_7 + b3_8) << 1;\n159                 p3 +=  b3_7 - b3_8*6 + b3_9;\n160             }\n161\n162             /* output four pixels */\n163             dst[x]             = av_clip_uint8((p0 >> 6) + 128);\n164             dst[x+1]           = av_clip_uint8((p1 >> 6) + 128);\n165             dst[dst_pitch+x]   = av_clip_uint8((p2 >> 6) + 128);\n166             dst[dst_pitch+x+1] = av_clip_uint8((p3 >> 6) + 128);\n167         }// for x\n168\n169         dst += dst_pitch << 1;\n170\n171         back_pitch = -pitch;\n172\n173         b0_ptr += pitch;\n174         b1_ptr += pitch;\n175         b2_ptr += pitch;\n176         b3_ptr += pitch;\n177     }\n178 }"
                    },
                    {
                        "file_path": "/libavcodec/ivi.c",
                        "function_body": "1023 int ff_ivi_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n1024                         AVPacket *avpkt)\n1025 {\n1026     IVI45DecContext *ctx = avctx->priv_data;\n1027     const uint8_t   *buf = avpkt->data;\n1028     AVFrame       *frame = data;\n1029     int             buf_size = avpkt->size;\n1030     int             result, p, b;\n1031\n1032     bitstream_init8(&ctx->bc, buf, buf_size);\n1033     ctx->frame_data = buf;\n1034     ctx->frame_size = buf_size;\n1035\n1036     result = ctx->decode_pic_hdr(ctx, avctx);\n1037     if (result) {\n1038         av_log(avctx, AV_LOG_ERROR,\n1039                \"Error while decoding picture header: %d\\n\", result);\n1040         return result;\n1041     }\n1042     if (ctx->gop_invalid)\n1043         return AVERROR_INVALIDDATA;\n1044\n1045     if (ctx->is_indeo4 && ctx->frame_type == IVI4_FRAMETYPE_NULL_LAST) {\n1046         if (ctx->got_p_frame) {\n1047             av_frame_move_ref(data, ctx->p_frame);\n1048             *got_frame = 1;\n1049             ctx->got_p_frame = 0;\n1050         } else {\n1051             *got_frame = 0;\n1052         }\n1053         return buf_size;\n1054     }\n1055\n1056     if (ctx->gop_flags & IVI5_IS_PROTECTED) {\n1057         avpriv_report_missing_feature(avctx, \"Password-protected clip\");\n1058         return AVERROR_PATCHWELCOME;\n1059     }\n1060\n1061     if (!ctx->planes[0].bands) {\n1062         av_log(avctx, AV_LOG_ERROR, \"Color planes not initialized yet\\n\");\n1063         return AVERROR_INVALIDDATA;\n1064     }\n1065\n1066     ctx->switch_buffers(ctx);\n1067\n1068     //{ START_TIMER;\n1069\n1070     if (ctx->is_nonnull_frame(ctx)) {\n1071         for (p = 0; p < 3; p++) {\n1072             for (b = 0; b < ctx->planes[p].num_bands; b++) {\n1073                 result = decode_band(ctx, &ctx->planes[p].bands[b], avctx);\n1074                 if (result < 0) {\n1075                     av_log(avctx, AV_LOG_ERROR,\n1076                            \"Error while decoding band: %d, plane: %d\\n\", b, p);\n1077                     return result;\n1078                 }\n1079             }\n1080         }\n1081     } else {\n1082         if (ctx->is_scalable)\n1083             return AVERROR_INVALIDDATA;\n1084\n1085         for (p = 0; p < 3; p++) {\n1086             if (!ctx->planes[p].bands[0].buf)\n1087                 return AVERROR_INVALIDDATA;\n1088         }\n1089     }\n1090\n1091     //STOP_TIMER(\"decode_planes\"); }\n1092\n1093     result = ff_set_dimensions(avctx, ctx->planes[0].width, ctx->planes[0].height);\n1094     if (result < 0)\n1095         return result;\n1096\n1097     if ((result = ff_get_buffer(avctx, frame, 0)) < 0) {\n1098         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n1099         return result;\n1100     }\n1101\n1102     if (ctx->is_scalable) {\n1103         if (ctx->is_indeo4)\n1104             ff_ivi_recompose_haar(&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1105         else\n1106             ff_ivi_recompose53   (&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1107     } else {\n1108         ivi_output_plane(&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1109     }\n1110\n1111     ivi_output_plane(&ctx->planes[2], frame->data[1], frame->linesize[1]);\n1112     ivi_output_plane(&ctx->planes[1], frame->data[2], frame->linesize[2]);\n1113\n1114     *got_frame = 1;\n1115\n1116     /* If the bidirectional mode is enabled, next I and the following P\n1117      * frame will be sent together. Unfortunately the approach below seems\n1118      * to be the only way to handle the B-frames mode.\n1119      * That's exactly the same Intel decoders do.\n1120      */\n1121     if (ctx->is_indeo4 && ctx->frame_type == IVI4_FRAMETYPE_INTRA) {\n1122         int left;\n1123\n1124         while (bitstream_read(&ctx->bc, 8)); // skip version string\n1125         left = bitstream_tell(&ctx->bc) & 0x18;\n1126         bitstream_skip(&ctx->bc, 64 - left);\n1127         if (bitstream_bits_left(&ctx->bc) > 18 &&\n1128             bitstream_peek(&ctx->bc, 21) == 0xBFFF8) { // syncheader + inter type\n1129             AVPacket pkt;\n1130             pkt.data = avpkt->data + (bitstream_tell(&ctx->bc) >> 3);\n1131             pkt.size = bitstream_bits_left(&ctx->bc) >> 3;\n1132             ff_ivi_decode_frame(avctx, ctx->p_frame, &ctx->got_p_frame, &pkt);\n1133         }\n1134     }\n1135\n1136     if (ctx->show_indeo4_info) {\n1137         if (ctx->is_scalable)\n1138             av_log(avctx, AV_LOG_DEBUG, \"This video uses scalability mode\\n\");\n1139         if (ctx->uses_tiling)\n1140             av_log(avctx, AV_LOG_DEBUG, \"This video uses local decoding\\n\");\n1141         if (ctx->has_b_frames)\n1142             av_log(avctx, AV_LOG_DEBUG, \"This video contains B-frames\\n\");\n1143         if (ctx->has_transp)\n1144             av_log(avctx, AV_LOG_DEBUG, \"Transparency mode is enabled\\n\");\n1145         if (ctx->uses_haar)\n1146             av_log(avctx, AV_LOG_DEBUG, \"This video uses Haar transform\\n\");\n1147         if (ctx->uses_fullpel)\n1148             av_log(avctx, AV_LOG_DEBUG, \"This video uses fullpel motion vectors\\n\");\n1149         ctx->show_indeo4_info = 0;\n1150     }\n1151\n1152     return buf_size;\n1153 }"
                    }
                ]
            }
        ],
        "sink": "tmp0 = b0_1;",
        "final_sink": "tmp0 = b0_1;"
    },
    {
        "prt": "b0_2",
        "function_call": [
            "void ff_ivi_recompose53(const IVIPlaneDesc *plane, uint8_t *dst,\n                        const ptrdiff_t dst_pitch)\n{\n    int             x, y, indx;\n    int32_t         p0, p1, p2, p3, tmp0, tmp1, tmp2;\n    int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;\n    int32_t         b3_1, b3_2, b3_3, b3_4, b3_5, b3_6, b3_7, b3_8, b3_9;\n    ptrdiff_t       pitch, back_pitch;\n    const short    *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n    const int       num_bands = 4;\n\n    /* all bands should have the same pitch */\n    pitch = plane->bands[0].pitch;\n\n    /* pixels at the position \"y-1\" will be set to pixels at the \"y\" for the 1st iteration */\n    back_pitch = 0;\n\n    /* get pointers to the wavelet bands */\n    b0_ptr = plane->bands[0].buf;\n    b1_ptr = plane->bands[1].buf;\n    b2_ptr = plane->bands[2].buf;\n    b3_ptr = plane->bands[3].buf;\n\n    for (y = 0; y < plane->height; y += 2) {\n        /* load storage variables with values */\n        if (num_bands > 0) {\n            b0_1 = b0_ptr[0];\n            b0_2 = b0_ptr[pitch];\n        }\n\n        if (num_bands > 1) {\n            b1_1 = b1_ptr[back_pitch];\n            b1_2 = b1_ptr[0];\n            b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch];\n        }\n\n        if (num_bands > 2) {\n            b2_2 = b2_ptr[0];     // b2[x,  y  ]\n            b2_3 = b2_2;          // b2[x+1,y  ] = b2[x,y]\n            b2_5 = b2_ptr[pitch]; // b2[x  ,y+1]\n            b2_6 = b2_5;          // b2[x+1,y+1] = b2[x,y+1]\n        }\n\n        if (num_bands > 3) {\n            b3_2 = b3_ptr[back_pitch]; // b3[x  ,y-1]\n            b3_3 = b3_2;               // b3[x+1,y-1] = b3[x  ,y-1]\n            b3_5 = b3_ptr[0];          // b3[x  ,y  ]\n            b3_6 = b3_5;               // b3[x+1,y  ] = b3[x  ,y  ]\n            b3_8 = b3_2 - b3_5*6 + b3_ptr[pitch];\n            b3_9 = b3_8;\n        }\n\n        for (x = 0, indx = 0; x < plane->width; x+=2, indx++) {\n            /* some values calculated in the previous iterations can */\n            /* be reused in the next ones, so do appropriate copying */\n            b2_1 = b2_2; // b2[x-1,y  ] = b2[x,  y  ]\n            b2_2 = b2_3; // b2[x  ,y  ] = b2[x+1,y  ]\n            b2_4 = b2_5; // b2[x-1,y+1] = b2[x  ,y+1]\n            b2_5 = b2_6; // b2[x  ,y+1] = b2[x+1,y+1]\n            b3_1 = b3_2; // b3[x-1,y-1] = b3[x  ,y-1]\n            b3_2 = b3_3; // b3[x  ,y-1] = b3[x+1,y-1]\n            b3_4 = b3_5; // b3[x-1,y  ] = b3[x  ,y  ]\n            b3_5 = b3_6; // b3[x  ,y  ] = b3[x+1,y  ]\n            b3_7 = b3_8; // vert_HPF(x-1)\n            b3_8 = b3_9; // vert_HPF(x  )\n\n            p0 = p1 = p2 = p3 = 0;\n\n            /* process the LL-band by applying LPF both vertically and horizontally */\n            if (num_bands > 0) {\n                tmp0 = b0_1;\n                tmp2 = b0_2;\n                b0_1 = b0_ptr[indx+1];\n                b0_2 = b0_ptr[pitch+indx+1];\n                tmp1 = tmp0 + b0_1;\n\n                p0 =  tmp0 << 4;\n                p1 =  tmp1 << 3;\n                p2 = (tmp0 + tmp2) << 3;\n                p3 = (tmp1 + tmp2 + b0_2) << 2;\n            }\n\n            /* process the HL-band by applying HPF vertically and LPF horizontally */\n            if (num_bands > 1) {\n                tmp0 = b1_2;\n                tmp1 = b1_1;\n                b1_2 = b1_ptr[indx+1];\n                b1_1 = b1_ptr[back_pitch+indx+1];\n\n                tmp2 = tmp1 - tmp0*6 + b1_3;\n                b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch+indx+1];\n\n                p0 += (tmp0 + tmp1) << 3;\n                p1 += (tmp0 + tmp1 + b1_1 + b1_2) << 2;\n                p2 +=  tmp2 << 2;\n                p3 += (tmp2 + b1_3) << 1;\n            }\n\n            /* process the LH-band by applying LPF vertically and HPF horizontally */\n            if (num_bands > 2) {\n                b2_3 = b2_ptr[indx+1];\n                b2_6 = b2_ptr[pitch+indx+1];\n\n                tmp0 = b2_1 + b2_2;\n                tmp1 = b2_1 - b2_2*6 + b2_3;\n\n                p0 += tmp0 << 3;\n                p1 += tmp1 << 2;\n                p2 += (tmp0 + b2_4 + b2_5) << 2;\n                p3 += (tmp1 + b2_4 - b2_5*6 + b2_6) << 1;\n            }\n\n            /* process the HH-band by applying HPF both vertically and horizontally */\n            if (num_bands > 3) {\n                b3_6 = b3_ptr[indx+1];            // b3[x+1,y  ]\n                b3_3 = b3_ptr[back_pitch+indx+1]; // b3[x+1,y-1]\n\n                tmp0 = b3_1 + b3_4;\n                tmp1 = b3_2 + b3_5;\n                tmp2 = b3_3 + b3_6;\n\n                b3_9 = b3_3 - b3_6*6 + b3_ptr[pitch+indx+1];\n\n                p0 += (tmp0 + tmp1) << 2;\n                p1 += (tmp0 - tmp1*6 + tmp2) << 1;\n                p2 += (b3_7 + b3_8) << 1;\n                p3 +=  b3_7 - b3_8*6 + b3_9;\n            }\n\n            /* output four pixels */\n            dst[x]             = av_clip_uint8((p0 >> 6) + 128);\n            dst[x+1]           = av_clip_uint8((p1 >> 6) + 128);\n            dst[dst_pitch+x]   = av_clip_uint8((p2 >> 6) + 128);\n            dst[dst_pitch+x+1] = av_clip_uint8((p3 >> 6) + 128);\n        }// for x\n\n        dst += dst_pitch << 1;\n\n        back_pitch = -pitch;\n\n        b0_ptr += pitch;\n        b1_ptr += pitch;\n        b2_ptr += pitch;\n        b3_ptr += pitch;\n    }\n}"
        ],
        "source": [
            "    int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;"
        ],
        "index": 25,
        "location": {
            "file_path": "libavcodec/ivi_dsp.c",
            "region": {
                "startLine": 104,
                "startColumn": 17,
                "endColumn": 21
            },
            "context": {
                "startLine": 102,
                "endLine": 106,
                "snippet": {
                    "text": "tmp2 = b0_2;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/ivi_dsp.c",
                        "function_body": "33  void ff_ivi_recompose53(const IVIPlaneDesc *plane, uint8_t *dst,\n34                          const ptrdiff_t dst_pitch)\n35  {\n36      int             x, y, indx;\n37      int32_t         p0, p1, p2, p3, tmp0, tmp1, tmp2;\n38      int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;\n39      int32_t         b3_1, b3_2, b3_3, b3_4, b3_5, b3_6, b3_7, b3_8, b3_9;\n40      ptrdiff_t       pitch, back_pitch;\n41      const short    *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n42      const int       num_bands = 4;\n43\n44      /* all bands should have the same pitch */\n45      pitch = plane->bands[0].pitch;\n46\n47      /* pixels at the position \"y-1\" will be set to pixels at the \"y\" for the 1st iteration */\n48      back_pitch = 0;\n49\n50      /* get pointers to the wavelet bands */\n51      b0_ptr = plane->bands[0].buf;\n52      b1_ptr = plane->bands[1].buf;\n53      b2_ptr = plane->bands[2].buf;\n54      b3_ptr = plane->bands[3].buf;\n55\n56      for (y = 0; y < plane->height; y += 2) {\n57          /* load storage variables with values */\n58          if (num_bands > 0) {\n59              b0_1 = b0_ptr[0];\n60              b0_2 = b0_ptr[pitch];\n61          }\n62\n63          if (num_bands > 1) {\n64              b1_1 = b1_ptr[back_pitch];\n65              b1_2 = b1_ptr[0];\n66              b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch];\n67          }\n68\n69          if (num_bands > 2) {\n70              b2_2 = b2_ptr[0];     // b2[x,  y  ]\n71              b2_3 = b2_2;          // b2[x+1,y  ] = b2[x,y]\n72              b2_5 = b2_ptr[pitch]; // b2[x  ,y+1]\n73              b2_6 = b2_5;          // b2[x+1,y+1] = b2[x,y+1]\n74          }\n75\n76          if (num_bands > 3) {\n77              b3_2 = b3_ptr[back_pitch]; // b3[x  ,y-1]\n78              b3_3 = b3_2;               // b3[x+1,y-1] = b3[x  ,y-1]\n79              b3_5 = b3_ptr[0];          // b3[x  ,y  ]\n80              b3_6 = b3_5;               // b3[x+1,y  ] = b3[x  ,y  ]\n81              b3_8 = b3_2 - b3_5*6 + b3_ptr[pitch];\n82              b3_9 = b3_8;\n83          }\n84\n85          for (x = 0, indx = 0; x < plane->width; x+=2, indx++) {\n86              /* some values calculated in the previous iterations can */\n87              /* be reused in the next ones, so do appropriate copying */\n88              b2_1 = b2_2; // b2[x-1,y  ] = b2[x,  y  ]\n89              b2_2 = b2_3; // b2[x  ,y  ] = b2[x+1,y  ]\n90              b2_4 = b2_5; // b2[x-1,y+1] = b2[x  ,y+1]\n91              b2_5 = b2_6; // b2[x  ,y+1] = b2[x+1,y+1]\n92              b3_1 = b3_2; // b3[x-1,y-1] = b3[x  ,y-1]\n93              b3_2 = b3_3; // b3[x  ,y-1] = b3[x+1,y-1]\n94              b3_4 = b3_5; // b3[x-1,y  ] = b3[x  ,y  ]\n95              b3_5 = b3_6; // b3[x  ,y  ] = b3[x+1,y  ]\n96              b3_7 = b3_8; // vert_HPF(x-1)\n97              b3_8 = b3_9; // vert_HPF(x  )\n98\n99              p0 = p1 = p2 = p3 = 0;\n100\n101             /* process the LL-band by applying LPF both vertically and horizontally */\n102             if (num_bands > 0) {\n103                 tmp0 = b0_1;\n104                 tmp2 = b0_2;\n105                 b0_1 = b0_ptr[indx+1];\n106                 b0_2 = b0_ptr[pitch+indx+1];\n107                 tmp1 = tmp0 + b0_1;\n108\n109                 p0 =  tmp0 << 4;\n110                 p1 =  tmp1 << 3;\n111                 p2 = (tmp0 + tmp2) << 3;\n112                 p3 = (tmp1 + tmp2 + b0_2) << 2;\n113             }\n114\n115             /* process the HL-band by applying HPF vertically and LPF horizontally */\n116             if (num_bands > 1) {\n117                 tmp0 = b1_2;\n118                 tmp1 = b1_1;\n119                 b1_2 = b1_ptr[indx+1];\n120                 b1_1 = b1_ptr[back_pitch+indx+1];\n121\n122                 tmp2 = tmp1 - tmp0*6 + b1_3;\n123                 b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch+indx+1];\n124\n125                 p0 += (tmp0 + tmp1) << 3;\n126                 p1 += (tmp0 + tmp1 + b1_1 + b1_2) << 2;\n127                 p2 +=  tmp2 << 2;\n128                 p3 += (tmp2 + b1_3) << 1;\n129             }\n130\n131             /* process the LH-band by applying LPF vertically and HPF horizontally */\n132             if (num_bands > 2) {\n133                 b2_3 = b2_ptr[indx+1];\n134                 b2_6 = b2_ptr[pitch+indx+1];\n135\n136                 tmp0 = b2_1 + b2_2;\n137                 tmp1 = b2_1 - b2_2*6 + b2_3;\n138\n139                 p0 += tmp0 << 3;\n140                 p1 += tmp1 << 2;\n141                 p2 += (tmp0 + b2_4 + b2_5) << 2;\n142                 p3 += (tmp1 + b2_4 - b2_5*6 + b2_6) << 1;\n143             }\n144\n145             /* process the HH-band by applying HPF both vertically and horizontally */\n146             if (num_bands > 3) {\n147                 b3_6 = b3_ptr[indx+1];            // b3[x+1,y  ]\n148                 b3_3 = b3_ptr[back_pitch+indx+1]; // b3[x+1,y-1]\n149\n150                 tmp0 = b3_1 + b3_4;\n151                 tmp1 = b3_2 + b3_5;\n152                 tmp2 = b3_3 + b3_6;\n153\n154                 b3_9 = b3_3 - b3_6*6 + b3_ptr[pitch+indx+1];\n155\n156                 p0 += (tmp0 + tmp1) << 2;\n157                 p1 += (tmp0 - tmp1*6 + tmp2) << 1;\n158                 p2 += (b3_7 + b3_8) << 1;\n159                 p3 +=  b3_7 - b3_8*6 + b3_9;\n160             }\n161\n162             /* output four pixels */\n163             dst[x]             = av_clip_uint8((p0 >> 6) + 128);\n164             dst[x+1]           = av_clip_uint8((p1 >> 6) + 128);\n165             dst[dst_pitch+x]   = av_clip_uint8((p2 >> 6) + 128);\n166             dst[dst_pitch+x+1] = av_clip_uint8((p3 >> 6) + 128);\n167         }// for x\n168\n169         dst += dst_pitch << 1;\n170\n171         back_pitch = -pitch;\n172\n173         b0_ptr += pitch;\n174         b1_ptr += pitch;\n175         b2_ptr += pitch;\n176         b3_ptr += pitch;\n177     }\n178 }"
                    },
                    {
                        "file_path": "/libavcodec/ivi.c",
                        "function_body": "1023 int ff_ivi_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n1024                         AVPacket *avpkt)\n1025 {\n1026     IVI45DecContext *ctx = avctx->priv_data;\n1027     const uint8_t   *buf = avpkt->data;\n1028     AVFrame       *frame = data;\n1029     int             buf_size = avpkt->size;\n1030     int             result, p, b;\n1031\n1032     bitstream_init8(&ctx->bc, buf, buf_size);\n1033     ctx->frame_data = buf;\n1034     ctx->frame_size = buf_size;\n1035\n1036     result = ctx->decode_pic_hdr(ctx, avctx);\n1037     if (result) {\n1038         av_log(avctx, AV_LOG_ERROR,\n1039                \"Error while decoding picture header: %d\\n\", result);\n1040         return result;\n1041     }\n1042     if (ctx->gop_invalid)\n1043         return AVERROR_INVALIDDATA;\n1044\n1045     if (ctx->is_indeo4 && ctx->frame_type == IVI4_FRAMETYPE_NULL_LAST) {\n1046         if (ctx->got_p_frame) {\n1047             av_frame_move_ref(data, ctx->p_frame);\n1048             *got_frame = 1;\n1049             ctx->got_p_frame = 0;\n1050         } else {\n1051             *got_frame = 0;\n1052         }\n1053         return buf_size;\n1054     }\n1055\n1056     if (ctx->gop_flags & IVI5_IS_PROTECTED) {\n1057         avpriv_report_missing_feature(avctx, \"Password-protected clip\");\n1058         return AVERROR_PATCHWELCOME;\n1059     }\n1060\n1061     if (!ctx->planes[0].bands) {\n1062         av_log(avctx, AV_LOG_ERROR, \"Color planes not initialized yet\\n\");\n1063         return AVERROR_INVALIDDATA;\n1064     }\n1065\n1066     ctx->switch_buffers(ctx);\n1067\n1068     //{ START_TIMER;\n1069\n1070     if (ctx->is_nonnull_frame(ctx)) {\n1071         for (p = 0; p < 3; p++) {\n1072             for (b = 0; b < ctx->planes[p].num_bands; b++) {\n1073                 result = decode_band(ctx, &ctx->planes[p].bands[b], avctx);\n1074                 if (result < 0) {\n1075                     av_log(avctx, AV_LOG_ERROR,\n1076                            \"Error while decoding band: %d, plane: %d\\n\", b, p);\n1077                     return result;\n1078                 }\n1079             }\n1080         }\n1081     } else {\n1082         if (ctx->is_scalable)\n1083             return AVERROR_INVALIDDATA;\n1084\n1085         for (p = 0; p < 3; p++) {\n1086             if (!ctx->planes[p].bands[0].buf)\n1087                 return AVERROR_INVALIDDATA;\n1088         }\n1089     }\n1090\n1091     //STOP_TIMER(\"decode_planes\"); }\n1092\n1093     result = ff_set_dimensions(avctx, ctx->planes[0].width, ctx->planes[0].height);\n1094     if (result < 0)\n1095         return result;\n1096\n1097     if ((result = ff_get_buffer(avctx, frame, 0)) < 0) {\n1098         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n1099         return result;\n1100     }\n1101\n1102     if (ctx->is_scalable) {\n1103         if (ctx->is_indeo4)\n1104             ff_ivi_recompose_haar(&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1105         else\n1106             ff_ivi_recompose53   (&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1107     } else {\n1108         ivi_output_plane(&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1109     }\n1110\n1111     ivi_output_plane(&ctx->planes[2], frame->data[1], frame->linesize[1]);\n1112     ivi_output_plane(&ctx->planes[1], frame->data[2], frame->linesize[2]);\n1113\n1114     *got_frame = 1;\n1115\n1116     /* If the bidirectional mode is enabled, next I and the following P\n1117      * frame will be sent together. Unfortunately the approach below seems\n1118      * to be the only way to handle the B-frames mode.\n1119      * That's exactly the same Intel decoders do.\n1120      */\n1121     if (ctx->is_indeo4 && ctx->frame_type == IVI4_FRAMETYPE_INTRA) {\n1122         int left;\n1123\n1124         while (bitstream_read(&ctx->bc, 8)); // skip version string\n1125         left = bitstream_tell(&ctx->bc) & 0x18;\n1126         bitstream_skip(&ctx->bc, 64 - left);\n1127         if (bitstream_bits_left(&ctx->bc) > 18 &&\n1128             bitstream_peek(&ctx->bc, 21) == 0xBFFF8) { // syncheader + inter type\n1129             AVPacket pkt;\n1130             pkt.data = avpkt->data + (bitstream_tell(&ctx->bc) >> 3);\n1131             pkt.size = bitstream_bits_left(&ctx->bc) >> 3;\n1132             ff_ivi_decode_frame(avctx, ctx->p_frame, &ctx->got_p_frame, &pkt);\n1133         }\n1134     }\n1135\n1136     if (ctx->show_indeo4_info) {\n1137         if (ctx->is_scalable)\n1138             av_log(avctx, AV_LOG_DEBUG, \"This video uses scalability mode\\n\");\n1139         if (ctx->uses_tiling)\n1140             av_log(avctx, AV_LOG_DEBUG, \"This video uses local decoding\\n\");\n1141         if (ctx->has_b_frames)\n1142             av_log(avctx, AV_LOG_DEBUG, \"This video contains B-frames\\n\");\n1143         if (ctx->has_transp)\n1144             av_log(avctx, AV_LOG_DEBUG, \"Transparency mode is enabled\\n\");\n1145         if (ctx->uses_haar)\n1146             av_log(avctx, AV_LOG_DEBUG, \"This video uses Haar transform\\n\");\n1147         if (ctx->uses_fullpel)\n1148             av_log(avctx, AV_LOG_DEBUG, \"This video uses fullpel motion vectors\\n\");\n1149         ctx->show_indeo4_info = 0;\n1150     }\n1151\n1152     return buf_size;\n1153 }"
                    }
                ]
            }
        ],
        "sink": "tmp2 = b0_2;",
        "final_sink": "tmp2 = b0_2;"
    },
    {
        "prt": "b1_1",
        "function_call": [
            "void ff_ivi_recompose53(const IVIPlaneDesc *plane, uint8_t *dst,\n                        const ptrdiff_t dst_pitch)\n{\n    int             x, y, indx;\n    int32_t         p0, p1, p2, p3, tmp0, tmp1, tmp2;\n    int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;\n    int32_t         b3_1, b3_2, b3_3, b3_4, b3_5, b3_6, b3_7, b3_8, b3_9;\n    ptrdiff_t       pitch, back_pitch;\n    const short    *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n    const int       num_bands = 4;\n\n    /* all bands should have the same pitch */\n    pitch = plane->bands[0].pitch;\n\n    /* pixels at the position \"y-1\" will be set to pixels at the \"y\" for the 1st iteration */\n    back_pitch = 0;\n\n    /* get pointers to the wavelet bands */\n    b0_ptr = plane->bands[0].buf;\n    b1_ptr = plane->bands[1].buf;\n    b2_ptr = plane->bands[2].buf;\n    b3_ptr = plane->bands[3].buf;\n\n    for (y = 0; y < plane->height; y += 2) {\n        /* load storage variables with values */\n        if (num_bands > 0) {\n            b0_1 = b0_ptr[0];\n            b0_2 = b0_ptr[pitch];\n        }\n\n        if (num_bands > 1) {\n            b1_1 = b1_ptr[back_pitch];\n            b1_2 = b1_ptr[0];\n            b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch];\n        }\n\n        if (num_bands > 2) {\n            b2_2 = b2_ptr[0];     // b2[x,  y  ]\n            b2_3 = b2_2;          // b2[x+1,y  ] = b2[x,y]\n            b2_5 = b2_ptr[pitch]; // b2[x  ,y+1]\n            b2_6 = b2_5;          // b2[x+1,y+1] = b2[x,y+1]\n        }\n\n        if (num_bands > 3) {\n            b3_2 = b3_ptr[back_pitch]; // b3[x  ,y-1]\n            b3_3 = b3_2;               // b3[x+1,y-1] = b3[x  ,y-1]\n            b3_5 = b3_ptr[0];          // b3[x  ,y  ]\n            b3_6 = b3_5;               // b3[x+1,y  ] = b3[x  ,y  ]\n            b3_8 = b3_2 - b3_5*6 + b3_ptr[pitch];\n            b3_9 = b3_8;\n        }\n\n        for (x = 0, indx = 0; x < plane->width; x+=2, indx++) {\n            /* some values calculated in the previous iterations can */\n            /* be reused in the next ones, so do appropriate copying */\n            b2_1 = b2_2; // b2[x-1,y  ] = b2[x,  y  ]\n            b2_2 = b2_3; // b2[x  ,y  ] = b2[x+1,y  ]\n            b2_4 = b2_5; // b2[x-1,y+1] = b2[x  ,y+1]\n            b2_5 = b2_6; // b2[x  ,y+1] = b2[x+1,y+1]\n            b3_1 = b3_2; // b3[x-1,y-1] = b3[x  ,y-1]\n            b3_2 = b3_3; // b3[x  ,y-1] = b3[x+1,y-1]\n            b3_4 = b3_5; // b3[x-1,y  ] = b3[x  ,y  ]\n            b3_5 = b3_6; // b3[x  ,y  ] = b3[x+1,y  ]\n            b3_7 = b3_8; // vert_HPF(x-1)\n            b3_8 = b3_9; // vert_HPF(x  )\n\n            p0 = p1 = p2 = p3 = 0;\n\n            /* process the LL-band by applying LPF both vertically and horizontally */\n            if (num_bands > 0) {\n                tmp0 = b0_1;\n                tmp2 = b0_2;\n                b0_1 = b0_ptr[indx+1];\n                b0_2 = b0_ptr[pitch+indx+1];\n                tmp1 = tmp0 + b0_1;\n\n                p0 =  tmp0 << 4;\n                p1 =  tmp1 << 3;\n                p2 = (tmp0 + tmp2) << 3;\n                p3 = (tmp1 + tmp2 + b0_2) << 2;\n            }\n\n            /* process the HL-band by applying HPF vertically and LPF horizontally */\n            if (num_bands > 1) {\n                tmp0 = b1_2;\n                tmp1 = b1_1;\n                b1_2 = b1_ptr[indx+1];\n                b1_1 = b1_ptr[back_pitch+indx+1];\n\n                tmp2 = tmp1 - tmp0*6 + b1_3;\n                b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch+indx+1];\n\n                p0 += (tmp0 + tmp1) << 3;\n                p1 += (tmp0 + tmp1 + b1_1 + b1_2) << 2;\n                p2 +=  tmp2 << 2;\n                p3 += (tmp2 + b1_3) << 1;\n            }\n\n            /* process the LH-band by applying LPF vertically and HPF horizontally */\n            if (num_bands > 2) {\n                b2_3 = b2_ptr[indx+1];\n                b2_6 = b2_ptr[pitch+indx+1];\n\n                tmp0 = b2_1 + b2_2;\n                tmp1 = b2_1 - b2_2*6 + b2_3;\n\n                p0 += tmp0 << 3;\n                p1 += tmp1 << 2;\n                p2 += (tmp0 + b2_4 + b2_5) << 2;\n                p3 += (tmp1 + b2_4 - b2_5*6 + b2_6) << 1;\n            }\n\n            /* process the HH-band by applying HPF both vertically and horizontally */\n            if (num_bands > 3) {\n                b3_6 = b3_ptr[indx+1];            // b3[x+1,y  ]\n                b3_3 = b3_ptr[back_pitch+indx+1]; // b3[x+1,y-1]\n\n                tmp0 = b3_1 + b3_4;\n                tmp1 = b3_2 + b3_5;\n                tmp2 = b3_3 + b3_6;\n\n                b3_9 = b3_3 - b3_6*6 + b3_ptr[pitch+indx+1];\n\n                p0 += (tmp0 + tmp1) << 2;\n                p1 += (tmp0 - tmp1*6 + tmp2) << 1;\n                p2 += (b3_7 + b3_8) << 1;\n                p3 +=  b3_7 - b3_8*6 + b3_9;\n            }\n\n            /* output four pixels */\n            dst[x]             = av_clip_uint8((p0 >> 6) + 128);\n            dst[x+1]           = av_clip_uint8((p1 >> 6) + 128);\n            dst[dst_pitch+x]   = av_clip_uint8((p2 >> 6) + 128);\n            dst[dst_pitch+x+1] = av_clip_uint8((p3 >> 6) + 128);\n        }// for x\n\n        dst += dst_pitch << 1;\n\n        back_pitch = -pitch;\n\n        b0_ptr += pitch;\n        b1_ptr += pitch;\n        b2_ptr += pitch;\n        b3_ptr += pitch;\n    }\n}"
        ],
        "source": [
            "    int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;"
        ],
        "index": 26,
        "location": {
            "file_path": "libavcodec/ivi_dsp.c",
            "region": {
                "startLine": 118,
                "startColumn": 17,
                "endColumn": 21
            },
            "context": {
                "startLine": 116,
                "endLine": 120,
                "snippet": {
                    "text": "tmp1 = b1_1;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/ivi_dsp.c",
                        "function_body": "33  void ff_ivi_recompose53(const IVIPlaneDesc *plane, uint8_t *dst,\n34                          const ptrdiff_t dst_pitch)\n35  {\n36      int             x, y, indx;\n37      int32_t         p0, p1, p2, p3, tmp0, tmp1, tmp2;\n38      int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;\n39      int32_t         b3_1, b3_2, b3_3, b3_4, b3_5, b3_6, b3_7, b3_8, b3_9;\n40      ptrdiff_t       pitch, back_pitch;\n41      const short    *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n42      const int       num_bands = 4;\n43\n44      /* all bands should have the same pitch */\n45      pitch = plane->bands[0].pitch;\n46\n47      /* pixels at the position \"y-1\" will be set to pixels at the \"y\" for the 1st iteration */\n48      back_pitch = 0;\n49\n50      /* get pointers to the wavelet bands */\n51      b0_ptr = plane->bands[0].buf;\n52      b1_ptr = plane->bands[1].buf;\n53      b2_ptr = plane->bands[2].buf;\n54      b3_ptr = plane->bands[3].buf;\n55\n56      for (y = 0; y < plane->height; y += 2) {\n57          /* load storage variables with values */\n58          if (num_bands > 0) {\n59              b0_1 = b0_ptr[0];\n60              b0_2 = b0_ptr[pitch];\n61          }\n62\n63          if (num_bands > 1) {\n64              b1_1 = b1_ptr[back_pitch];\n65              b1_2 = b1_ptr[0];\n66              b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch];\n67          }\n68\n69          if (num_bands > 2) {\n70              b2_2 = b2_ptr[0];     // b2[x,  y  ]\n71              b2_3 = b2_2;          // b2[x+1,y  ] = b2[x,y]\n72              b2_5 = b2_ptr[pitch]; // b2[x  ,y+1]\n73              b2_6 = b2_5;          // b2[x+1,y+1] = b2[x,y+1]\n74          }\n75\n76          if (num_bands > 3) {\n77              b3_2 = b3_ptr[back_pitch]; // b3[x  ,y-1]\n78              b3_3 = b3_2;               // b3[x+1,y-1] = b3[x  ,y-1]\n79              b3_5 = b3_ptr[0];          // b3[x  ,y  ]\n80              b3_6 = b3_5;               // b3[x+1,y  ] = b3[x  ,y  ]\n81              b3_8 = b3_2 - b3_5*6 + b3_ptr[pitch];\n82              b3_9 = b3_8;\n83          }\n84\n85          for (x = 0, indx = 0; x < plane->width; x+=2, indx++) {\n86              /* some values calculated in the previous iterations can */\n87              /* be reused in the next ones, so do appropriate copying */\n88              b2_1 = b2_2; // b2[x-1,y  ] = b2[x,  y  ]\n89              b2_2 = b2_3; // b2[x  ,y  ] = b2[x+1,y  ]\n90              b2_4 = b2_5; // b2[x-1,y+1] = b2[x  ,y+1]\n91              b2_5 = b2_6; // b2[x  ,y+1] = b2[x+1,y+1]\n92              b3_1 = b3_2; // b3[x-1,y-1] = b3[x  ,y-1]\n93              b3_2 = b3_3; // b3[x  ,y-1] = b3[x+1,y-1]\n94              b3_4 = b3_5; // b3[x-1,y  ] = b3[x  ,y  ]\n95              b3_5 = b3_6; // b3[x  ,y  ] = b3[x+1,y  ]\n96              b3_7 = b3_8; // vert_HPF(x-1)\n97              b3_8 = b3_9; // vert_HPF(x  )\n98\n99              p0 = p1 = p2 = p3 = 0;\n100\n101             /* process the LL-band by applying LPF both vertically and horizontally */\n102             if (num_bands > 0) {\n103                 tmp0 = b0_1;\n104                 tmp2 = b0_2;\n105                 b0_1 = b0_ptr[indx+1];\n106                 b0_2 = b0_ptr[pitch+indx+1];\n107                 tmp1 = tmp0 + b0_1;\n108\n109                 p0 =  tmp0 << 4;\n110                 p1 =  tmp1 << 3;\n111                 p2 = (tmp0 + tmp2) << 3;\n112                 p3 = (tmp1 + tmp2 + b0_2) << 2;\n113             }\n114\n115             /* process the HL-band by applying HPF vertically and LPF horizontally */\n116             if (num_bands > 1) {\n117                 tmp0 = b1_2;\n118                 tmp1 = b1_1;\n119                 b1_2 = b1_ptr[indx+1];\n120                 b1_1 = b1_ptr[back_pitch+indx+1];\n121\n122                 tmp2 = tmp1 - tmp0*6 + b1_3;\n123                 b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch+indx+1];\n124\n125                 p0 += (tmp0 + tmp1) << 3;\n126                 p1 += (tmp0 + tmp1 + b1_1 + b1_2) << 2;\n127                 p2 +=  tmp2 << 2;\n128                 p3 += (tmp2 + b1_3) << 1;\n129             }\n130\n131             /* process the LH-band by applying LPF vertically and HPF horizontally */\n132             if (num_bands > 2) {\n133                 b2_3 = b2_ptr[indx+1];\n134                 b2_6 = b2_ptr[pitch+indx+1];\n135\n136                 tmp0 = b2_1 + b2_2;\n137                 tmp1 = b2_1 - b2_2*6 + b2_3;\n138\n139                 p0 += tmp0 << 3;\n140                 p1 += tmp1 << 2;\n141                 p2 += (tmp0 + b2_4 + b2_5) << 2;\n142                 p3 += (tmp1 + b2_4 - b2_5*6 + b2_6) << 1;\n143             }\n144\n145             /* process the HH-band by applying HPF both vertically and horizontally */\n146             if (num_bands > 3) {\n147                 b3_6 = b3_ptr[indx+1];            // b3[x+1,y  ]\n148                 b3_3 = b3_ptr[back_pitch+indx+1]; // b3[x+1,y-1]\n149\n150                 tmp0 = b3_1 + b3_4;\n151                 tmp1 = b3_2 + b3_5;\n152                 tmp2 = b3_3 + b3_6;\n153\n154                 b3_9 = b3_3 - b3_6*6 + b3_ptr[pitch+indx+1];\n155\n156                 p0 += (tmp0 + tmp1) << 2;\n157                 p1 += (tmp0 - tmp1*6 + tmp2) << 1;\n158                 p2 += (b3_7 + b3_8) << 1;\n159                 p3 +=  b3_7 - b3_8*6 + b3_9;\n160             }\n161\n162             /* output four pixels */\n163             dst[x]             = av_clip_uint8((p0 >> 6) + 128);\n164             dst[x+1]           = av_clip_uint8((p1 >> 6) + 128);\n165             dst[dst_pitch+x]   = av_clip_uint8((p2 >> 6) + 128);\n166             dst[dst_pitch+x+1] = av_clip_uint8((p3 >> 6) + 128);\n167         }// for x\n168\n169         dst += dst_pitch << 1;\n170\n171         back_pitch = -pitch;\n172\n173         b0_ptr += pitch;\n174         b1_ptr += pitch;\n175         b2_ptr += pitch;\n176         b3_ptr += pitch;\n177     }\n178 }"
                    },
                    {
                        "file_path": "/libavcodec/ivi.c",
                        "function_body": "1023 int ff_ivi_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n1024                         AVPacket *avpkt)\n1025 {\n1026     IVI45DecContext *ctx = avctx->priv_data;\n1027     const uint8_t   *buf = avpkt->data;\n1028     AVFrame       *frame = data;\n1029     int             buf_size = avpkt->size;\n1030     int             result, p, b;\n1031\n1032     bitstream_init8(&ctx->bc, buf, buf_size);\n1033     ctx->frame_data = buf;\n1034     ctx->frame_size = buf_size;\n1035\n1036     result = ctx->decode_pic_hdr(ctx, avctx);\n1037     if (result) {\n1038         av_log(avctx, AV_LOG_ERROR,\n1039                \"Error while decoding picture header: %d\\n\", result);\n1040         return result;\n1041     }\n1042     if (ctx->gop_invalid)\n1043         return AVERROR_INVALIDDATA;\n1044\n1045     if (ctx->is_indeo4 && ctx->frame_type == IVI4_FRAMETYPE_NULL_LAST) {\n1046         if (ctx->got_p_frame) {\n1047             av_frame_move_ref(data, ctx->p_frame);\n1048             *got_frame = 1;\n1049             ctx->got_p_frame = 0;\n1050         } else {\n1051             *got_frame = 0;\n1052         }\n1053         return buf_size;\n1054     }\n1055\n1056     if (ctx->gop_flags & IVI5_IS_PROTECTED) {\n1057         avpriv_report_missing_feature(avctx, \"Password-protected clip\");\n1058         return AVERROR_PATCHWELCOME;\n1059     }\n1060\n1061     if (!ctx->planes[0].bands) {\n1062         av_log(avctx, AV_LOG_ERROR, \"Color planes not initialized yet\\n\");\n1063         return AVERROR_INVALIDDATA;\n1064     }\n1065\n1066     ctx->switch_buffers(ctx);\n1067\n1068     //{ START_TIMER;\n1069\n1070     if (ctx->is_nonnull_frame(ctx)) {\n1071         for (p = 0; p < 3; p++) {\n1072             for (b = 0; b < ctx->planes[p].num_bands; b++) {\n1073                 result = decode_band(ctx, &ctx->planes[p].bands[b], avctx);\n1074                 if (result < 0) {\n1075                     av_log(avctx, AV_LOG_ERROR,\n1076                            \"Error while decoding band: %d, plane: %d\\n\", b, p);\n1077                     return result;\n1078                 }\n1079             }\n1080         }\n1081     } else {\n1082         if (ctx->is_scalable)\n1083             return AVERROR_INVALIDDATA;\n1084\n1085         for (p = 0; p < 3; p++) {\n1086             if (!ctx->planes[p].bands[0].buf)\n1087                 return AVERROR_INVALIDDATA;\n1088         }\n1089     }\n1090\n1091     //STOP_TIMER(\"decode_planes\"); }\n1092\n1093     result = ff_set_dimensions(avctx, ctx->planes[0].width, ctx->planes[0].height);\n1094     if (result < 0)\n1095         return result;\n1096\n1097     if ((result = ff_get_buffer(avctx, frame, 0)) < 0) {\n1098         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n1099         return result;\n1100     }\n1101\n1102     if (ctx->is_scalable) {\n1103         if (ctx->is_indeo4)\n1104             ff_ivi_recompose_haar(&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1105         else\n1106             ff_ivi_recompose53   (&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1107     } else {\n1108         ivi_output_plane(&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1109     }\n1110\n1111     ivi_output_plane(&ctx->planes[2], frame->data[1], frame->linesize[1]);\n1112     ivi_output_plane(&ctx->planes[1], frame->data[2], frame->linesize[2]);\n1113\n1114     *got_frame = 1;\n1115\n1116     /* If the bidirectional mode is enabled, next I and the following P\n1117      * frame will be sent together. Unfortunately the approach below seems\n1118      * to be the only way to handle the B-frames mode.\n1119      * That's exactly the same Intel decoders do.\n1120      */\n1121     if (ctx->is_indeo4 && ctx->frame_type == IVI4_FRAMETYPE_INTRA) {\n1122         int left;\n1123\n1124         while (bitstream_read(&ctx->bc, 8)); // skip version string\n1125         left = bitstream_tell(&ctx->bc) & 0x18;\n1126         bitstream_skip(&ctx->bc, 64 - left);\n1127         if (bitstream_bits_left(&ctx->bc) > 18 &&\n1128             bitstream_peek(&ctx->bc, 21) == 0xBFFF8) { // syncheader + inter type\n1129             AVPacket pkt;\n1130             pkt.data = avpkt->data + (bitstream_tell(&ctx->bc) >> 3);\n1131             pkt.size = bitstream_bits_left(&ctx->bc) >> 3;\n1132             ff_ivi_decode_frame(avctx, ctx->p_frame, &ctx->got_p_frame, &pkt);\n1133         }\n1134     }\n1135\n1136     if (ctx->show_indeo4_info) {\n1137         if (ctx->is_scalable)\n1138             av_log(avctx, AV_LOG_DEBUG, \"This video uses scalability mode\\n\");\n1139         if (ctx->uses_tiling)\n1140             av_log(avctx, AV_LOG_DEBUG, \"This video uses local decoding\\n\");\n1141         if (ctx->has_b_frames)\n1142             av_log(avctx, AV_LOG_DEBUG, \"This video contains B-frames\\n\");\n1143         if (ctx->has_transp)\n1144             av_log(avctx, AV_LOG_DEBUG, \"Transparency mode is enabled\\n\");\n1145         if (ctx->uses_haar)\n1146             av_log(avctx, AV_LOG_DEBUG, \"This video uses Haar transform\\n\");\n1147         if (ctx->uses_fullpel)\n1148             av_log(avctx, AV_LOG_DEBUG, \"This video uses fullpel motion vectors\\n\");\n1149         ctx->show_indeo4_info = 0;\n1150     }\n1151\n1152     return buf_size;\n1153 }"
                    }
                ]
            }
        ],
        "sink": "tmp1 = b1_1;",
        "final_sink": "tmp1 = b1_1;"
    },
    {
        "prt": "b1_2",
        "function_call": [
            "void ff_ivi_recompose53(const IVIPlaneDesc *plane, uint8_t *dst,\n                        const ptrdiff_t dst_pitch)\n{\n    int             x, y, indx;\n    int32_t         p0, p1, p2, p3, tmp0, tmp1, tmp2;\n    int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;\n    int32_t         b3_1, b3_2, b3_3, b3_4, b3_5, b3_6, b3_7, b3_8, b3_9;\n    ptrdiff_t       pitch, back_pitch;\n    const short    *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n    const int       num_bands = 4;\n\n    /* all bands should have the same pitch */\n    pitch = plane->bands[0].pitch;\n\n    /* pixels at the position \"y-1\" will be set to pixels at the \"y\" for the 1st iteration */\n    back_pitch = 0;\n\n    /* get pointers to the wavelet bands */\n    b0_ptr = plane->bands[0].buf;\n    b1_ptr = plane->bands[1].buf;\n    b2_ptr = plane->bands[2].buf;\n    b3_ptr = plane->bands[3].buf;\n\n    for (y = 0; y < plane->height; y += 2) {\n        /* load storage variables with values */\n        if (num_bands > 0) {\n            b0_1 = b0_ptr[0];\n            b0_2 = b0_ptr[pitch];\n        }\n\n        if (num_bands > 1) {\n            b1_1 = b1_ptr[back_pitch];\n            b1_2 = b1_ptr[0];\n            b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch];\n        }\n\n        if (num_bands > 2) {\n            b2_2 = b2_ptr[0];     // b2[x,  y  ]\n            b2_3 = b2_2;          // b2[x+1,y  ] = b2[x,y]\n            b2_5 = b2_ptr[pitch]; // b2[x  ,y+1]\n            b2_6 = b2_5;          // b2[x+1,y+1] = b2[x,y+1]\n        }\n\n        if (num_bands > 3) {\n            b3_2 = b3_ptr[back_pitch]; // b3[x  ,y-1]\n            b3_3 = b3_2;               // b3[x+1,y-1] = b3[x  ,y-1]\n            b3_5 = b3_ptr[0];          // b3[x  ,y  ]\n            b3_6 = b3_5;               // b3[x+1,y  ] = b3[x  ,y  ]\n            b3_8 = b3_2 - b3_5*6 + b3_ptr[pitch];\n            b3_9 = b3_8;\n        }\n\n        for (x = 0, indx = 0; x < plane->width; x+=2, indx++) {\n            /* some values calculated in the previous iterations can */\n            /* be reused in the next ones, so do appropriate copying */\n            b2_1 = b2_2; // b2[x-1,y  ] = b2[x,  y  ]\n            b2_2 = b2_3; // b2[x  ,y  ] = b2[x+1,y  ]\n            b2_4 = b2_5; // b2[x-1,y+1] = b2[x  ,y+1]\n            b2_5 = b2_6; // b2[x  ,y+1] = b2[x+1,y+1]\n            b3_1 = b3_2; // b3[x-1,y-1] = b3[x  ,y-1]\n            b3_2 = b3_3; // b3[x  ,y-1] = b3[x+1,y-1]\n            b3_4 = b3_5; // b3[x-1,y  ] = b3[x  ,y  ]\n            b3_5 = b3_6; // b3[x  ,y  ] = b3[x+1,y  ]\n            b3_7 = b3_8; // vert_HPF(x-1)\n            b3_8 = b3_9; // vert_HPF(x  )\n\n            p0 = p1 = p2 = p3 = 0;\n\n            /* process the LL-band by applying LPF both vertically and horizontally */\n            if (num_bands > 0) {\n                tmp0 = b0_1;\n                tmp2 = b0_2;\n                b0_1 = b0_ptr[indx+1];\n                b0_2 = b0_ptr[pitch+indx+1];\n                tmp1 = tmp0 + b0_1;\n\n                p0 =  tmp0 << 4;\n                p1 =  tmp1 << 3;\n                p2 = (tmp0 + tmp2) << 3;\n                p3 = (tmp1 + tmp2 + b0_2) << 2;\n            }\n\n            /* process the HL-band by applying HPF vertically and LPF horizontally */\n            if (num_bands > 1) {\n                tmp0 = b1_2;\n                tmp1 = b1_1;\n                b1_2 = b1_ptr[indx+1];\n                b1_1 = b1_ptr[back_pitch+indx+1];\n\n                tmp2 = tmp1 - tmp0*6 + b1_3;\n                b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch+indx+1];\n\n                p0 += (tmp0 + tmp1) << 3;\n                p1 += (tmp0 + tmp1 + b1_1 + b1_2) << 2;\n                p2 +=  tmp2 << 2;\n                p3 += (tmp2 + b1_3) << 1;\n            }\n\n            /* process the LH-band by applying LPF vertically and HPF horizontally */\n            if (num_bands > 2) {\n                b2_3 = b2_ptr[indx+1];\n                b2_6 = b2_ptr[pitch+indx+1];\n\n                tmp0 = b2_1 + b2_2;\n                tmp1 = b2_1 - b2_2*6 + b2_3;\n\n                p0 += tmp0 << 3;\n                p1 += tmp1 << 2;\n                p2 += (tmp0 + b2_4 + b2_5) << 2;\n                p3 += (tmp1 + b2_4 - b2_5*6 + b2_6) << 1;\n            }\n\n            /* process the HH-band by applying HPF both vertically and horizontally */\n            if (num_bands > 3) {\n                b3_6 = b3_ptr[indx+1];            // b3[x+1,y  ]\n                b3_3 = b3_ptr[back_pitch+indx+1]; // b3[x+1,y-1]\n\n                tmp0 = b3_1 + b3_4;\n                tmp1 = b3_2 + b3_5;\n                tmp2 = b3_3 + b3_6;\n\n                b3_9 = b3_3 - b3_6*6 + b3_ptr[pitch+indx+1];\n\n                p0 += (tmp0 + tmp1) << 2;\n                p1 += (tmp0 - tmp1*6 + tmp2) << 1;\n                p2 += (b3_7 + b3_8) << 1;\n                p3 +=  b3_7 - b3_8*6 + b3_9;\n            }\n\n            /* output four pixels */\n            dst[x]             = av_clip_uint8((p0 >> 6) + 128);\n            dst[x+1]           = av_clip_uint8((p1 >> 6) + 128);\n            dst[dst_pitch+x]   = av_clip_uint8((p2 >> 6) + 128);\n            dst[dst_pitch+x+1] = av_clip_uint8((p3 >> 6) + 128);\n        }// for x\n\n        dst += dst_pitch << 1;\n\n        back_pitch = -pitch;\n\n        b0_ptr += pitch;\n        b1_ptr += pitch;\n        b2_ptr += pitch;\n        b3_ptr += pitch;\n    }\n}"
        ],
        "source": [
            "    int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;"
        ],
        "index": 27,
        "location": {
            "file_path": "libavcodec/ivi_dsp.c",
            "region": {
                "startLine": 117,
                "startColumn": 17,
                "endColumn": 21
            },
            "context": {
                "startLine": 115,
                "endLine": 119,
                "snippet": {
                    "text": "tmp0 = b1_2;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/ivi_dsp.c",
                        "function_body": "33  void ff_ivi_recompose53(const IVIPlaneDesc *plane, uint8_t *dst,\n34                          const ptrdiff_t dst_pitch)\n35  {\n36      int             x, y, indx;\n37      int32_t         p0, p1, p2, p3, tmp0, tmp1, tmp2;\n38      int32_t         b0_1, b0_2, b1_1, b1_2, b1_3, b2_1, b2_2, b2_3, b2_4, b2_5, b2_6;\n39      int32_t         b3_1, b3_2, b3_3, b3_4, b3_5, b3_6, b3_7, b3_8, b3_9;\n40      ptrdiff_t       pitch, back_pitch;\n41      const short    *b0_ptr, *b1_ptr, *b2_ptr, *b3_ptr;\n42      const int       num_bands = 4;\n43\n44      /* all bands should have the same pitch */\n45      pitch = plane->bands[0].pitch;\n46\n47      /* pixels at the position \"y-1\" will be set to pixels at the \"y\" for the 1st iteration */\n48      back_pitch = 0;\n49\n50      /* get pointers to the wavelet bands */\n51      b0_ptr = plane->bands[0].buf;\n52      b1_ptr = plane->bands[1].buf;\n53      b2_ptr = plane->bands[2].buf;\n54      b3_ptr = plane->bands[3].buf;\n55\n56      for (y = 0; y < plane->height; y += 2) {\n57          /* load storage variables with values */\n58          if (num_bands > 0) {\n59              b0_1 = b0_ptr[0];\n60              b0_2 = b0_ptr[pitch];\n61          }\n62\n63          if (num_bands > 1) {\n64              b1_1 = b1_ptr[back_pitch];\n65              b1_2 = b1_ptr[0];\n66              b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch];\n67          }\n68\n69          if (num_bands > 2) {\n70              b2_2 = b2_ptr[0];     // b2[x,  y  ]\n71              b2_3 = b2_2;          // b2[x+1,y  ] = b2[x,y]\n72              b2_5 = b2_ptr[pitch]; // b2[x  ,y+1]\n73              b2_6 = b2_5;          // b2[x+1,y+1] = b2[x,y+1]\n74          }\n75\n76          if (num_bands > 3) {\n77              b3_2 = b3_ptr[back_pitch]; // b3[x  ,y-1]\n78              b3_3 = b3_2;               // b3[x+1,y-1] = b3[x  ,y-1]\n79              b3_5 = b3_ptr[0];          // b3[x  ,y  ]\n80              b3_6 = b3_5;               // b3[x+1,y  ] = b3[x  ,y  ]\n81              b3_8 = b3_2 - b3_5*6 + b3_ptr[pitch];\n82              b3_9 = b3_8;\n83          }\n84\n85          for (x = 0, indx = 0; x < plane->width; x+=2, indx++) {\n86              /* some values calculated in the previous iterations can */\n87              /* be reused in the next ones, so do appropriate copying */\n88              b2_1 = b2_2; // b2[x-1,y  ] = b2[x,  y  ]\n89              b2_2 = b2_3; // b2[x  ,y  ] = b2[x+1,y  ]\n90              b2_4 = b2_5; // b2[x-1,y+1] = b2[x  ,y+1]\n91              b2_5 = b2_6; // b2[x  ,y+1] = b2[x+1,y+1]\n92              b3_1 = b3_2; // b3[x-1,y-1] = b3[x  ,y-1]\n93              b3_2 = b3_3; // b3[x  ,y-1] = b3[x+1,y-1]\n94              b3_4 = b3_5; // b3[x-1,y  ] = b3[x  ,y  ]\n95              b3_5 = b3_6; // b3[x  ,y  ] = b3[x+1,y  ]\n96              b3_7 = b3_8; // vert_HPF(x-1)\n97              b3_8 = b3_9; // vert_HPF(x  )\n98\n99              p0 = p1 = p2 = p3 = 0;\n100\n101             /* process the LL-band by applying LPF both vertically and horizontally */\n102             if (num_bands > 0) {\n103                 tmp0 = b0_1;\n104                 tmp2 = b0_2;\n105                 b0_1 = b0_ptr[indx+1];\n106                 b0_2 = b0_ptr[pitch+indx+1];\n107                 tmp1 = tmp0 + b0_1;\n108\n109                 p0 =  tmp0 << 4;\n110                 p1 =  tmp1 << 3;\n111                 p2 = (tmp0 + tmp2) << 3;\n112                 p3 = (tmp1 + tmp2 + b0_2) << 2;\n113             }\n114\n115             /* process the HL-band by applying HPF vertically and LPF horizontally */\n116             if (num_bands > 1) {\n117                 tmp0 = b1_2;\n118                 tmp1 = b1_1;\n119                 b1_2 = b1_ptr[indx+1];\n120                 b1_1 = b1_ptr[back_pitch+indx+1];\n121\n122                 tmp2 = tmp1 - tmp0*6 + b1_3;\n123                 b1_3 = b1_1 - b1_2*6 + b1_ptr[pitch+indx+1];\n124\n125                 p0 += (tmp0 + tmp1) << 3;\n126                 p1 += (tmp0 + tmp1 + b1_1 + b1_2) << 2;\n127                 p2 +=  tmp2 << 2;\n128                 p3 += (tmp2 + b1_3) << 1;\n129             }\n130\n131             /* process the LH-band by applying LPF vertically and HPF horizontally */\n132             if (num_bands > 2) {\n133                 b2_3 = b2_ptr[indx+1];\n134                 b2_6 = b2_ptr[pitch+indx+1];\n135\n136                 tmp0 = b2_1 + b2_2;\n137                 tmp1 = b2_1 - b2_2*6 + b2_3;\n138\n139                 p0 += tmp0 << 3;\n140                 p1 += tmp1 << 2;\n141                 p2 += (tmp0 + b2_4 + b2_5) << 2;\n142                 p3 += (tmp1 + b2_4 - b2_5*6 + b2_6) << 1;\n143             }\n144\n145             /* process the HH-band by applying HPF both vertically and horizontally */\n146             if (num_bands > 3) {\n147                 b3_6 = b3_ptr[indx+1];            // b3[x+1,y  ]\n148                 b3_3 = b3_ptr[back_pitch+indx+1]; // b3[x+1,y-1]\n149\n150                 tmp0 = b3_1 + b3_4;\n151                 tmp1 = b3_2 + b3_5;\n152                 tmp2 = b3_3 + b3_6;\n153\n154                 b3_9 = b3_3 - b3_6*6 + b3_ptr[pitch+indx+1];\n155\n156                 p0 += (tmp0 + tmp1) << 2;\n157                 p1 += (tmp0 - tmp1*6 + tmp2) << 1;\n158                 p2 += (b3_7 + b3_8) << 1;\n159                 p3 +=  b3_7 - b3_8*6 + b3_9;\n160             }\n161\n162             /* output four pixels */\n163             dst[x]             = av_clip_uint8((p0 >> 6) + 128);\n164             dst[x+1]           = av_clip_uint8((p1 >> 6) + 128);\n165             dst[dst_pitch+x]   = av_clip_uint8((p2 >> 6) + 128);\n166             dst[dst_pitch+x+1] = av_clip_uint8((p3 >> 6) + 128);\n167         }// for x\n168\n169         dst += dst_pitch << 1;\n170\n171         back_pitch = -pitch;\n172\n173         b0_ptr += pitch;\n174         b1_ptr += pitch;\n175         b2_ptr += pitch;\n176         b3_ptr += pitch;\n177     }\n178 }"
                    },
                    {
                        "file_path": "/libavcodec/ivi.c",
                        "function_body": "1023 int ff_ivi_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n1024                         AVPacket *avpkt)\n1025 {\n1026     IVI45DecContext *ctx = avctx->priv_data;\n1027     const uint8_t   *buf = avpkt->data;\n1028     AVFrame       *frame = data;\n1029     int             buf_size = avpkt->size;\n1030     int             result, p, b;\n1031\n1032     bitstream_init8(&ctx->bc, buf, buf_size);\n1033     ctx->frame_data = buf;\n1034     ctx->frame_size = buf_size;\n1035\n1036     result = ctx->decode_pic_hdr(ctx, avctx);\n1037     if (result) {\n1038         av_log(avctx, AV_LOG_ERROR,\n1039                \"Error while decoding picture header: %d\\n\", result);\n1040         return result;\n1041     }\n1042     if (ctx->gop_invalid)\n1043         return AVERROR_INVALIDDATA;\n1044\n1045     if (ctx->is_indeo4 && ctx->frame_type == IVI4_FRAMETYPE_NULL_LAST) {\n1046         if (ctx->got_p_frame) {\n1047             av_frame_move_ref(data, ctx->p_frame);\n1048             *got_frame = 1;\n1049             ctx->got_p_frame = 0;\n1050         } else {\n1051             *got_frame = 0;\n1052         }\n1053         return buf_size;\n1054     }\n1055\n1056     if (ctx->gop_flags & IVI5_IS_PROTECTED) {\n1057         avpriv_report_missing_feature(avctx, \"Password-protected clip\");\n1058         return AVERROR_PATCHWELCOME;\n1059     }\n1060\n1061     if (!ctx->planes[0].bands) {\n1062         av_log(avctx, AV_LOG_ERROR, \"Color planes not initialized yet\\n\");\n1063         return AVERROR_INVALIDDATA;\n1064     }\n1065\n1066     ctx->switch_buffers(ctx);\n1067\n1068     //{ START_TIMER;\n1069\n1070     if (ctx->is_nonnull_frame(ctx)) {\n1071         for (p = 0; p < 3; p++) {\n1072             for (b = 0; b < ctx->planes[p].num_bands; b++) {\n1073                 result = decode_band(ctx, &ctx->planes[p].bands[b], avctx);\n1074                 if (result < 0) {\n1075                     av_log(avctx, AV_LOG_ERROR,\n1076                            \"Error while decoding band: %d, plane: %d\\n\", b, p);\n1077                     return result;\n1078                 }\n1079             }\n1080         }\n1081     } else {\n1082         if (ctx->is_scalable)\n1083             return AVERROR_INVALIDDATA;\n1084\n1085         for (p = 0; p < 3; p++) {\n1086             if (!ctx->planes[p].bands[0].buf)\n1087                 return AVERROR_INVALIDDATA;\n1088         }\n1089     }\n1090\n1091     //STOP_TIMER(\"decode_planes\"); }\n1092\n1093     result = ff_set_dimensions(avctx, ctx->planes[0].width, ctx->planes[0].height);\n1094     if (result < 0)\n1095         return result;\n1096\n1097     if ((result = ff_get_buffer(avctx, frame, 0)) < 0) {\n1098         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n1099         return result;\n1100     }\n1101\n1102     if (ctx->is_scalable) {\n1103         if (ctx->is_indeo4)\n1104             ff_ivi_recompose_haar(&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1105         else\n1106             ff_ivi_recompose53   (&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1107     } else {\n1108         ivi_output_plane(&ctx->planes[0], frame->data[0], frame->linesize[0]);\n1109     }\n1110\n1111     ivi_output_plane(&ctx->planes[2], frame->data[1], frame->linesize[1]);\n1112     ivi_output_plane(&ctx->planes[1], frame->data[2], frame->linesize[2]);\n1113\n1114     *got_frame = 1;\n1115\n1116     /* If the bidirectional mode is enabled, next I and the following P\n1117      * frame will be sent together. Unfortunately the approach below seems\n1118      * to be the only way to handle the B-frames mode.\n1119      * That's exactly the same Intel decoders do.\n1120      */\n1121     if (ctx->is_indeo4 && ctx->frame_type == IVI4_FRAMETYPE_INTRA) {\n1122         int left;\n1123\n1124         while (bitstream_read(&ctx->bc, 8)); // skip version string\n1125         left = bitstream_tell(&ctx->bc) & 0x18;\n1126         bitstream_skip(&ctx->bc, 64 - left);\n1127         if (bitstream_bits_left(&ctx->bc) > 18 &&\n1128             bitstream_peek(&ctx->bc, 21) == 0xBFFF8) { // syncheader + inter type\n1129             AVPacket pkt;\n1130             pkt.data = avpkt->data + (bitstream_tell(&ctx->bc) >> 3);\n1131             pkt.size = bitstream_bits_left(&ctx->bc) >> 3;\n1132             ff_ivi_decode_frame(avctx, ctx->p_frame, &ctx->got_p_frame, &pkt);\n1133         }\n1134     }\n1135\n1136     if (ctx->show_indeo4_info) {\n1137         if (ctx->is_scalable)\n1138             av_log(avctx, AV_LOG_DEBUG, \"This video uses scalability mode\\n\");\n1139         if (ctx->uses_tiling)\n1140             av_log(avctx, AV_LOG_DEBUG, \"This video uses local decoding\\n\");\n1141         if (ctx->has_b_frames)\n1142             av_log(avctx, AV_LOG_DEBUG, \"This video contains B-frames\\n\");\n1143         if (ctx->has_transp)\n1144             av_log(avctx, AV_LOG_DEBUG, \"Transparency mode is enabled\\n\");\n1145         if (ctx->uses_haar)\n1146             av_log(avctx, AV_LOG_DEBUG, \"This video uses Haar transform\\n\");\n1147         if (ctx->uses_fullpel)\n1148             av_log(avctx, AV_LOG_DEBUG, \"This video uses fullpel motion vectors\\n\");\n1149         ctx->show_indeo4_info = 0;\n1150     }\n1151\n1152     return buf_size;\n1153 }"
                    }
                ]
            }
        ],
        "sink": "tmp0 = b1_2;",
        "final_sink": "tmp0 = b1_2;"
    },
    {
        "prt": "c",
        "function_call": [
            "static void pnm_get(PNMContext *sc, char *str, int buf_size)\n{\n    char *s;\n    int c;\n\n    /* skip spaces and comments */\n    for (;;) {\n        c = *sc->bytestream++;\n        if (c == '#')  {\n            do {\n                c = *sc->bytestream++;\n            } while (c != '\\n' && sc->bytestream < sc->bytestream_end);\n        } else if (!pnm_space(c)) {\n            break;\n        }\n    }\n\n    s = str;\n    while (sc->bytestream < sc->bytestream_end && !pnm_space(c)) {\n        if ((s - str)  < buf_size - 1)\n            *s++ = c;\n        c = *sc->bytestream++;\n    }\n    *s = '\\0';\n}"
        ],
        "source": [
            "    int c;"
        ],
        "index": 28,
        "location": {
            "file_path": "libavcodec/pnm.c",
            "region": {
                "startLine": 54,
                "startColumn": 13,
                "endColumn": 14
            },
            "context": {
                "startLine": 52,
                "endLine": 56,
                "snippet": {
                    "text": "*s++ = c;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/pnm.c",
                        "function_body": "34 static void pnm_get(PNMContext *sc, char *str, int buf_size)\n35 {\n36     char *s;\n37     int c;\n38\n39     /* skip spaces and comments */\n40     for (;;) {\n41         c = *sc->bytestream++;\n42         if (c == '#')  {\n43             do {\n44                 c = *sc->bytestream++;\n45             } while (c != '\\n' && sc->bytestream < sc->bytestream_end);\n46         } else if (!pnm_space(c)) {\n47             break;\n48         }\n49     }\n50\n51     s = str;\n52     while (sc->bytestream < sc->bytestream_end && !pnm_space(c)) {\n53         if ((s - str)  < buf_size - 1)\n54             *s++ = c;\n55         c = *sc->bytestream++;\n56     }\n57     *s = '\\0';\n58 }"
                    },
                    {
                        "file_path": "/libavcodec/pnm.c",
                        "function_body": "60  int ff_pnm_decode_header(AVCodecContext *avctx, PNMContext * const s)\n61  {\n62      char buf1[32], tuple_type[32];\n63      int h, w, depth, maxval;\n64\n65      pnm_get(s, buf1, sizeof(buf1));\n66      s->type= buf1[1]-'0';\n67      if(buf1[0] != 'P')\n68          return AVERROR_INVALIDDATA;\n69\n70      if (s->type==1 || s->type==4) {\n71          avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;\n72      } else if (s->type==2 || s->type==5) {\n73          if (avctx->codec_id == AV_CODEC_ID_PGMYUV)\n74              avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n75          else\n76              avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n77      } else if (s->type==3 || s->type==6) {\n78          avctx->pix_fmt = AV_PIX_FMT_RGB24;\n79      } else if (s->type==7) {\n80          w      = -1;\n81          h      = -1;\n82          maxval = -1;\n83          depth  = -1;\n84          tuple_type[0] = '\\0';\n85          for (;;) {\n86              pnm_get(s, buf1, sizeof(buf1));\n87              if (!strcmp(buf1, \"WIDTH\")) {\n88                  pnm_get(s, buf1, sizeof(buf1));\n89                  w = strtol(buf1, NULL, 10);\n90              } else if (!strcmp(buf1, \"HEIGHT\")) {\n91                  pnm_get(s, buf1, sizeof(buf1));\n92                  h = strtol(buf1, NULL, 10);\n93              } else if (!strcmp(buf1, \"DEPTH\")) {\n94                  pnm_get(s, buf1, sizeof(buf1));\n95                  depth = strtol(buf1, NULL, 10);\n96              } else if (!strcmp(buf1, \"MAXVAL\")) {\n97                  pnm_get(s, buf1, sizeof(buf1));\n98                  maxval = strtol(buf1, NULL, 10);\n99              } else if (!strcmp(buf1, \"TUPLTYPE\") ||\n100                        /* libavcodec used to write invalid files */\n101                        !strcmp(buf1, \"TUPLETYPE\")) {\n102                 pnm_get(s, tuple_type, sizeof(tuple_type));\n103             } else if (!strcmp(buf1, \"ENDHDR\")) {\n104                 break;\n105             } else {\n106                 return AVERROR_INVALIDDATA;\n107             }\n108         }\n109         /* check that all tags are present */\n110         if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\\0' || av_image_check_size(w, h, 0, avctx))\n111             return AVERROR_INVALIDDATA;\n112\n113         avctx->width  = w;\n114         avctx->height = h;\n115         if (depth == 1) {\n116             if (maxval == 1)\n117                 avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;\n118             else\n119                 avctx->pix_fmt = AV_PIX_FMT_GRAY8;\n120         } else if (depth == 3) {\n121             if (maxval < 256) {\n122             avctx->pix_fmt = AV_PIX_FMT_RGB24;\n123             } else {\n124                 av_log(avctx, AV_LOG_ERROR, \"16-bit components are only supported for grayscale\\n\");\n125                 avctx->pix_fmt = AV_PIX_FMT_NONE;\n126                 return AVERROR_INVALIDDATA;\n127             }\n128         } else if (depth == 4) {\n129             avctx->pix_fmt = AV_PIX_FMT_RGB32;\n130         } else {\n131             return AVERROR_INVALIDDATA;\n132         }\n133         return 0;\n134     } else {\n135         return AVERROR_INVALIDDATA;\n136     }\n137     pnm_get(s, buf1, sizeof(buf1));\n138     avctx->width = atoi(buf1);\n139     if (avctx->width <= 0)\n140         return AVERROR_INVALIDDATA;\n141     pnm_get(s, buf1, sizeof(buf1));\n142     avctx->height = atoi(buf1);\n143     if(av_image_check_size(avctx->width, avctx->height, 0, avctx))\n144         return AVERROR_INVALIDDATA;\n145     if (avctx->pix_fmt != AV_PIX_FMT_MONOWHITE) {\n146         pnm_get(s, buf1, sizeof(buf1));\n147         s->maxval = atoi(buf1);\n148         if (s->maxval <= 0) {\n149             av_log(avctx, AV_LOG_ERROR, \"Invalid maxval: %d\\n\", s->maxval);\n150             s->maxval = 255;\n151         }\n152         if (s->maxval >= 256) {\n153             if (avctx->pix_fmt == AV_PIX_FMT_GRAY8) {\n154                 avctx->pix_fmt = AV_PIX_FMT_GRAY16BE;\n155                 if (s->maxval != 65535)\n156                     avctx->pix_fmt = AV_PIX_FMT_GRAY16;\n157             } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) {\n158                 if (s->maxval > 255)\n159                     avctx->pix_fmt = AV_PIX_FMT_RGB48BE;\n160             } else if (avctx->pix_fmt == AV_PIX_FMT_YUV420P && s->maxval < 65536) {\n161                 if (s->maxval < 512)\n162                     avctx->pix_fmt = AV_PIX_FMT_YUV420P9BE;\n163                 else if (s->maxval < 1024)\n164                     avctx->pix_fmt = AV_PIX_FMT_YUV420P10BE;\n165                 else\n166                     avctx->pix_fmt = AV_PIX_FMT_YUV420P16;\n167             } else {\n168                 av_log(avctx, AV_LOG_ERROR, \"Unsupported pixel format\\n\");\n169                 avctx->pix_fmt = AV_PIX_FMT_NONE;\n170                 return AVERROR_INVALIDDATA;\n171             }\n172         }\n173     }else\n174         s->maxval=1;\n175     /* more check if YUV420 */\n176     if (av_pix_fmt_desc_get(avctx->pix_fmt)->flags & AV_PIX_FMT_FLAG_PLANAR) {\n177         if ((avctx->width & 1) != 0)\n178             return AVERROR_INVALIDDATA;\n179         h = (avctx->height * 2);\n180         if ((h % 3) != 0)\n181             return AVERROR_INVALIDDATA;\n182         h /= 3;\n183         avctx->height = h;\n184     }\n185     return 0;\n186 }"
                    }
                ]
            }
        ],
        "sink": "*s++ = c;",
        "final_sink": "*s++ = c;"
    },
    {
        "prt": "val",
        "function_call": [
            "static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    int h, w, ret;\n    AVFrame *pic = data;\n    const uint8_t *psrc = avpkt->data;\n    uint16_t *y, *u, *v;\n    int aligned_width = ((avctx->width + 47) / 48) * 48;\n    int stride = aligned_width * 8 / 3;\n\n    if (avpkt->size < stride * avctx->height) {\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    y = (uint16_t*)pic->data[0];\n    u = (uint16_t*)pic->data[1];\n    v = (uint16_t*)pic->data[2];\n    pic->pict_type = AV_PICTURE_TYPE_I;\n    pic->key_frame = 1;\n\n#define READ_PIXELS(a, b, c)         \\\n    do {                             \\\n        val  = av_le2ne32(*src++);   \\\n        *a++ =  val & 0x3FF;         \\\n        *b++ = (val >> 10) & 0x3FF;  \\\n        *c++ = (val >> 20) & 0x3FF;  \\\n    } while (0)\n\n    for (h = 0; h < avctx->height; h++) {\n        const uint32_t *src = (const uint32_t*)psrc;\n        uint32_t val;\n        for (w = 0; w < avctx->width - 5; w += 6) {\n            READ_PIXELS(u, y, v);\n            READ_PIXELS(y, u, y);\n            READ_PIXELS(v, y, u);\n            READ_PIXELS(y, v, y);\n        }\n        if (w < avctx->width - 1) {\n            READ_PIXELS(u, y, v);\n\n            val  = av_le2ne32(*src++);\n            *y++ =  val & 0x3FF;\n        }\n        if (w < avctx->width - 3) {\n            *u++ = (val >> 10) & 0x3FF;\n            *y++ = (val >> 20) & 0x3FF;\n\n            val  = av_le2ne32(*src++);\n            *v++ =  val & 0x3FF;\n            *y++ = (val >> 10) & 0x3FF;\n        }\n\n        psrc += stride;\n        y += pic->linesize[0] / 2 - avctx->width;\n        u += pic->linesize[1] / 2 - avctx->width / 2;\n        v += pic->linesize[2] / 2 - avctx->width / 2;\n    }\n\n    *got_frame      = 1;\n\n    return avpkt->size;\n}"
        ],
        "source": [
            "        uint32_t val;"
        ],
        "index": 29,
        "location": {
            "file_path": "libavcodec/v210dec.c",
            "region": {
                "startLine": 90,
                "startColumn": 13,
                "endColumn": 16
            },
            "context": {
                "startLine": 88,
                "endLine": 92,
                "snippet": {
                    "text": "*u++ = (val >> 10) & 0x3FF;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "344 #define u(width, name, range_min, range_max) \\\n345         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "267 #define u(width, name, range_min, range_max) \\\n268         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/atrac3.c",
                        "function_body": "734 static int atrac3_decode_frame(AVCodecContext *avctx, void *data,\n735                                int *got_frame_ptr, AVPacket *avpkt)\n736 {\n737     AVFrame *frame     = data;\n738     const uint8_t *buf = avpkt->data;\n739     int buf_size = avpkt->size;\n740     ATRAC3Context *q = avctx->priv_data;\n741     int ret;\n742     const uint8_t *databuf;\n743\n744     if (buf_size < avctx->block_align) {\n745         av_log(avctx, AV_LOG_ERROR,\n746                \"Frame too small (%d bytes). Truncated file?\\n\", buf_size);\n747         return AVERROR_INVALIDDATA;\n748     }\n749\n750     /* get output buffer */\n751     frame->nb_samples = SAMPLES_PER_FRAME;\n752     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n753         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n754         return ret;\n755     }\n756\n757     /* Check if we need to descramble and what buffer to pass on. */\n758     if (q->scrambled_stream) {\n759         decode_bytes(buf, q->decoded_bytes_buffer, avctx->block_align);\n760         databuf = q->decoded_bytes_buffer;\n761     } else {\n762         databuf = buf;\n763     }\n764\n765     ret = decode_frame(avctx, databuf, (float **)frame->extended_data);\n766     if (ret) {\n767         av_log(NULL, AV_LOG_ERROR, \"Frame decoding error!\\n\");\n768         return ret;\n769     }\n770\n771     *got_frame_ptr = 1;\n772\n773     return avctx->block_align;\n774 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "344 #define u(width, name, range_min, range_max) \\\n345         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "267 #define u(width, name, range_min, range_max) \\\n268         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/flacdec.c",
                        "function_body": "486 static int flac_decode_frame(AVCodecContext *avctx, void *data,\n487                              int *got_frame_ptr, AVPacket *avpkt)\n488 {\n489     AVFrame *frame     = data;\n490     const uint8_t *buf = avpkt->data;\n491     int buf_size = avpkt->size;\n492     FLACContext *s = avctx->priv_data;\n493     int bytes_read = 0;\n494     int ret;\n495\n496     *got_frame_ptr = 0;\n497\n498     if (s->max_framesize == 0) {\n499         s->max_framesize =\n500             ff_flac_get_max_frame_size(s->max_blocksize ? s->max_blocksize : FLAC_MAX_BLOCKSIZE,\n501                                        FLAC_MAX_CHANNELS, 32);\n502     }\n503\n504     /* check that there is at least the smallest decodable amount of data.\n505        this amount corresponds to the smallest valid FLAC frame possible.\n506        FF F8 69 02 00 00 9A 00 00 34 46 */\n507     if (buf_size < FLAC_MIN_FRAME_SIZE)\n508         return buf_size;\n509\n510     /* check for inline header */\n511     if (AV_RB32(buf) == MKBETAG('f','L','a','C')) {\n512         if (!s->got_streaminfo && (ret = parse_streaminfo(s, buf, buf_size))) {\n513             av_log(s->avctx, AV_LOG_ERROR, \"invalid header\\n\");\n514             return ret;\n515         }\n516         return get_metadata_size(buf, buf_size);\n517     }\n518\n519     /* decode frame */\n520     bitstream_init8(&s->bc, buf, buf_size);\n521     if ((ret = decode_frame(s)) < 0) {\n522         av_log(s->avctx, AV_LOG_ERROR, \"decode_frame() failed\\n\");\n523         return ret;\n524     }\n525     bytes_read = (bitstream_tell(&s->bc) + 7) / 8;\n526\n527     /* get output buffer */\n528     frame->nb_samples = s->blocksize;\n529     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n530         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n531         return ret;\n532     }\n533\n534     s->dsp.decorrelate[s->ch_mode](frame->data, s->decoded, s->channels,\n535                                    s->blocksize, s->sample_shift);\n536\n537     if (bytes_read > buf_size) {\n538         av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", bytes_read - buf_size);\n539         return AVERROR_INVALIDDATA;\n540     }\n541     if (bytes_read < buf_size) {\n542         av_log(s->avctx, AV_LOG_DEBUG, \"underread: %d orig size: %d\\n\",\n543                buf_size - bytes_read, buf_size);\n544     }\n545\n546     *got_frame_ptr = 1;\n547\n548     return bytes_read;\n549 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "344 #define u(width, name, range_min, range_max) \\\n345         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "267 #define u(width, name, range_min, range_max) \\\n268         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/wmalosslessdec.c",
                        "function_body": "1170 static int decode_packet(AVCodecContext *avctx, void *data, int *got_frame_ptr,\n1171                          AVPacket* avpkt)\n1172 {\n1173     WmallDecodeCtx *s = avctx->priv_data;\n1174     BitstreamContext *bc = &s->pbc;\n1175     const uint8_t* buf = avpkt->data;\n1176     int buf_size       = avpkt->size;\n1177     int num_bits_prev_frame, packet_sequence_number, spliced_packet;\n1178\n1179     s->frame->nb_samples = 0;\n1180\n1181     if (s->packet_done || s->packet_loss) {\n1182         s->packet_done = 0;\n1183\n1184         /* sanity check for the buffer length */\n1185         if (buf_size < avctx->block_align)\n1186             return 0;\n1187\n1188         s->next_packet_start = buf_size - avctx->block_align;\n1189         buf_size             = avctx->block_align;\n1190         s->buf_bit_size      = buf_size << 3;\n1191\n1192         /* parse packet header */\n1193         bitstream_init(bc, buf, s->buf_bit_size);\n1194         packet_sequence_number = bitstream_read(bc, 4);\n1195         bitstream_skip(bc, 1); // Skip seekable_frame_in_packet, currently ununused\n1196         spliced_packet = bitstream_read_bit(bc);\n1197         if (spliced_packet)\n1198             avpriv_request_sample(avctx, \"Bitstream splicing\");\n1199\n1200         /* get number of bits that need to be added to the previous frame */\n1201         num_bits_prev_frame = bitstream_read(bc, s->log2_frame_size);\n1202\n1203         /* check for packet loss */\n1204         if (!s->packet_loss &&\n1205             ((s->packet_sequence_number + 1) & 0xF) != packet_sequence_number) {\n1206             s->packet_loss = 1;\n1207             av_log(avctx, AV_LOG_ERROR,\n1208                    \"Packet loss detected! seq %\"PRIx8\" vs %x\\n\",\n1209                    s->packet_sequence_number, packet_sequence_number);\n1210         }\n1211         s->packet_sequence_number = packet_sequence_number;\n1212\n1213         if (num_bits_prev_frame > 0) {\n1214             int remaining_packet_bits = s->buf_bit_size - bitstream_tell(bc);\n1215             if (num_bits_prev_frame >= remaining_packet_bits) {\n1216                 num_bits_prev_frame = remaining_packet_bits;\n1217                 s->packet_done = 1;\n1218             }\n1219\n1220             /* Append the previous frame data to the remaining data from the\n1221              * previous packet to create a full frame. */\n1222             save_bits(s, bc, num_bits_prev_frame, 1);\n1223\n1224             /* decode the cross packet frame if it is valid */\n1225             if (num_bits_prev_frame < remaining_packet_bits && !s->packet_loss)\n1226                 decode_frame(s);\n1227         } else if (s->num_saved_bits - s->frame_offset) {\n1228             ff_dlog(avctx, \"ignoring %x previously saved bits\\n\",\n1229                     s->num_saved_bits - s->frame_offset);\n1230         }\n1231\n1232         if (s->packet_loss) {\n1233             /* Reset number of saved bits so that the decoder does not start\n1234              * to decode incomplete frames in the s->len_prefix == 0 case. */\n1235             s->num_saved_bits = 0;\n1236             s->packet_loss    = 0;\n1237             init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n1238         }\n1239\n1240     } else {\n1241         int frame_size;\n1242\n1243         s->buf_bit_size = (avpkt->size - s->next_packet_start) << 3;\n1244         bitstream_init(bc, avpkt->data, s->buf_bit_size);\n1245         bitstream_skip(bc, s->packet_offset);\n1246\n1247         if (s->len_prefix && remaining_bits(s, bc) > s->log2_frame_size &&\n1248             (frame_size = bitstream_peek(bc, s->log2_frame_size)) &&\n1249             frame_size <= remaining_bits(s, bc)) {\n1250             save_bits(s, bc, frame_size, 0);\n1251             s->packet_done = !decode_frame(s);\n1252         } else if (!s->len_prefix\n1253                    && s->num_saved_bits > bitstream_tell(&s->bc)) {\n1254             /* when the frames do not have a length prefix, we don't know the\n1255              * compressed length of the individual frames however, we know what\n1256              * part of a new packet belongs to the previous frame therefore we\n1257              * save the incoming packet first, then we append the \"previous\n1258              * frame\" data from the next packet so that we get a buffer that\n1259              * only contains full frames */\n1260             s->packet_done = !decode_frame(s);\n1261         } else {\n1262             s->packet_done = 1;\n1263         }\n1264     }\n1265\n1266     if (s->packet_done && !s->packet_loss &&\n1267         remaining_bits(s, bc) > 0) {\n1268         /* save the rest of the data so that it can be decoded\n1269          * with the next packet */\n1270         save_bits(s, bc, remaining_bits(s, bc), 0);\n1271     }\n1272\n1273     *got_frame_ptr   = s->frame->nb_samples > 0;\n1274     av_frame_move_ref(data, s->frame);\n1275\n1276     s->packet_offset = bitstream_tell(bc) & 7;\n1277\n1278     return (s->packet_loss) ? AVERROR_INVALIDDATA : bitstream_tell(bc) >> 3;\n1279 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "344 #define u(width, name, range_min, range_max) \\\n345         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "267 #define u(width, name, range_min, range_max) \\\n268         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavformat/nutdec.c",
                        "function_body": "880 static int nut_read_packet(AVFormatContext *s, AVPacket *pkt)\n881 {\n882     NUTContext *nut = s->priv_data;\n883     AVIOContext *bc = s->pb;\n884     int i, frame_code = 0, ret, skip;\n885     int64_t ts, back_ptr;\n886\n887     for (;;) {\n888         int64_t pos  = avio_tell(bc);\n889         uint64_t tmp = nut->next_startcode;\n890         nut->next_startcode = 0;\n891\n892         if (tmp) {\n893             pos -= 8;\n894         } else {\n895             frame_code = avio_r8(bc);\n896             if (bc->eof_reached)\n897                 return AVERROR_EOF;\n898             if (frame_code == 'N') {\n899                 tmp = frame_code;\n900                 for (i = 1; i < 8; i++)\n901                     tmp = (tmp << 8) + avio_r8(bc);\n902             }\n903         }\n904         switch (tmp) {\n905         case MAIN_STARTCODE:\n906         case STREAM_STARTCODE:\n907         case INDEX_STARTCODE:\n908             skip = get_packetheader(nut, bc, 0, tmp);\n909             avio_skip(bc, skip);\n910             break;\n911         case INFO_STARTCODE:\n912             if (decode_info_header(nut) < 0)\n913                 goto resync;\n914             break;\n915         case SYNCPOINT_STARTCODE:\n916             if (decode_syncpoint(nut, &ts, &back_ptr) < 0)\n917                 goto resync;\n918             frame_code = avio_r8(bc);\n919         case 0:\n920             ret = decode_frame(nut, pkt, frame_code);\n921             if (ret == 0)\n922                 return 0;\n923             else if (ret == 1) // OK but discard packet\n924                 break;\n925         default:\n926 resync:\n927             av_log(s, AV_LOG_DEBUG, \"syncing from %\"PRId64\"\\n\", pos);\n928             tmp = find_any_startcode(bc, nut->last_syncpoint_pos + 1);\n929             if (tmp == 0)\n930                 return AVERROR_INVALIDDATA;\n931             av_log(s, AV_LOG_DEBUG, \"sync\\n\");\n932             nut->next_startcode = tmp;\n933         }\n934     }\n935 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "344 #define u(width, name, range_min, range_max) \\\n345         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "267 #define u(width, name, range_min, range_max) \\\n268         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/wmaprodec.c",
                        "function_body": "1513 static int decode_packet(AVCodecContext *avctx, void *data,\n1514                          int *got_frame_ptr, AVPacket* avpkt)\n1515 {\n1516     WMAProDecodeCtx *s = avctx->priv_data;\n1517     BitstreamContext *bc = &s->pbc;\n1518     const uint8_t* buf = avpkt->data;\n1519     int buf_size       = avpkt->size;\n1520     int num_bits_prev_frame;\n1521     int packet_sequence_number;\n1522\n1523     *got_frame_ptr = 0;\n1524\n1525     if (s->packet_done || s->packet_loss) {\n1526         s->packet_done = 0;\n1527\n1528         /** sanity check for the buffer length */\n1529         if (buf_size < avctx->block_align) {\n1530             av_log(avctx, AV_LOG_ERROR, \"Input packet too small (%d < %d)\\n\",\n1531                    buf_size, avctx->block_align);\n1532             return AVERROR_INVALIDDATA;\n1533         }\n1534\n1535         s->next_packet_start = buf_size - avctx->block_align;\n1536         buf_size = avctx->block_align;\n1537         s->buf_bit_size = buf_size << 3;\n1538\n1539         /** parse packet header */\n1540         bitstream_init(bc, buf, s->buf_bit_size);\n1541         packet_sequence_number = bitstream_read(bc, 4);\n1542         bitstream_skip(bc, 2);\n1543\n1544         /** get number of bits that need to be added to the previous frame */\n1545         num_bits_prev_frame = bitstream_read(bc, s->log2_frame_size);\n1546         ff_dlog(avctx, \"packet[%d]: nbpf %x\\n\", avctx->frame_number,\n1547                 num_bits_prev_frame);\n1548\n1549         /** check for packet loss */\n1550         if (!s->packet_loss &&\n1551             ((s->packet_sequence_number + 1) & 0xF) != packet_sequence_number) {\n1552             s->packet_loss = 1;\n1553             av_log(avctx, AV_LOG_ERROR,\n1554                    \"Packet loss detected! seq %\"PRIx8\" vs %x\\n\",\n1555                    s->packet_sequence_number, packet_sequence_number);\n1556         }\n1557         s->packet_sequence_number = packet_sequence_number;\n1558\n1559         if (num_bits_prev_frame > 0) {\n1560             int remaining_packet_bits = s->buf_bit_size - bitstream_tell(bc);\n1561             if (num_bits_prev_frame >= remaining_packet_bits) {\n1562                 num_bits_prev_frame = remaining_packet_bits;\n1563                 s->packet_done = 1;\n1564             }\n1565\n1566             /** append the previous frame data to the remaining data from the\n1567                 previous packet to create a full frame */\n1568             save_bits(s, bc, num_bits_prev_frame, 1);\n1569             ff_dlog(avctx, \"accumulated %x bits of frame data\\n\",\n1570                     s->num_saved_bits - s->frame_offset);\n1571\n1572             /** decode the cross packet frame if it is valid */\n1573             if (!s->packet_loss)\n1574                 decode_frame(s, data, got_frame_ptr);\n1575         } else if (s->num_saved_bits - s->frame_offset) {\n1576             ff_dlog(avctx, \"ignoring %x previously saved bits\\n\",\n1577                     s->num_saved_bits - s->frame_offset);\n1578         }\n1579\n1580         if (s->packet_loss) {\n1581             /** reset number of saved bits so that the decoder\n1582                 does not start to decode incomplete frames in the\n1583                 s->len_prefix == 0 case */\n1584             s->num_saved_bits = 0;\n1585             s->packet_loss = 0;\n1586         }\n1587\n1588     } else {\n1589         int frame_size;\n1590         s->buf_bit_size = (avpkt->size - s->next_packet_start) << 3;\n1591         bitstream_init(bc, avpkt->data, s->buf_bit_size);\n1592         bitstream_skip(bc, s->packet_offset);\n1593         if (s->len_prefix && remaining_bits(s, bc) > s->log2_frame_size &&\n1594             (frame_size = bitstream_peek(bc, s->log2_frame_size)) &&\n1595             frame_size <= remaining_bits(s, bc)) {\n1596             save_bits(s, bc, frame_size, 0);\n1597             s->packet_done = !decode_frame(s, data, got_frame_ptr);\n1598         } else if (!s->len_prefix\n1599                    && s->num_saved_bits > bitstream_tell(&s->bc)) {\n1600             /** when the frames do not have a length prefix, we don't know\n1601                 the compressed length of the individual frames\n1602                 however, we know what part of a new packet belongs to the\n1603                 previous frame\n1604                 therefore we save the incoming packet first, then we append\n1605                 the \"previous frame\" data from the next packet so that\n1606                 we get a buffer that only contains full frames */\n1607             s->packet_done = !decode_frame(s, data, got_frame_ptr);\n1608         } else\n1609             s->packet_done = 1;\n1610     }\n1611\n1612     if (s->packet_done && !s->packet_loss &&\n1613         remaining_bits(s, bc) > 0) {\n1614         /** save the rest of the data so that it can be decoded\n1615             with the next packet */\n1616         save_bits(s, bc, remaining_bits(s, bc), 0);\n1617     }\n1618\n1619     s->packet_offset = bitstream_tell(bc) & 7;\n1620     if (s->packet_loss)\n1621         return AVERROR_INVALIDDATA;\n1622\n1623     return bitstream_tell(bc) >> 3;\n1624 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "344 #define u(width, name, range_min, range_max) \\\n345         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/cbs_h2645.c",
                        "function_body": "267 #define u(width, name, range_min, range_max) \\\n268         xu(width, name, current->name, range_min, range_max)"
                    },
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/sipr.c",
                        "function_body": "522 static int sipr_decode_frame(AVCodecContext *avctx, void *data,\n523                              int *got_frame_ptr, AVPacket *avpkt)\n524 {\n525     SiprContext *ctx = avctx->priv_data;\n526     AVFrame *frame   = data;\n527     const uint8_t *buf=avpkt->data;\n528     SiprParameters parm;\n529     const SiprModeParam *mode_par = &modes[ctx->mode];\n530     BitstreamContext bc;\n531     float *samples;\n532     int subframe_size = ctx->mode == MODE_16k ? L_SUBFR_16k : SUBFR_SIZE;\n533     int i, ret;\n534\n535     ctx->avctx = avctx;\n536     if (avpkt->size < (mode_par->bits_per_frame >> 3)) {\n537         av_log(avctx, AV_LOG_ERROR,\n538                \"Error processing packet: packet size (%d) too small\\n\",\n539                avpkt->size);\n540         return -1;\n541     }\n542\n543     /* get output buffer */\n544     frame->nb_samples = mode_par->frames_per_packet * subframe_size *\n545                         mode_par->subframe_count;\n546     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n547         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n548         return ret;\n549     }\n550     samples = (float *)frame->data[0];\n551\n552     bitstream_init(&bc, buf, mode_par->bits_per_frame);\n553\n554     for (i = 0; i < mode_par->frames_per_packet; i++) {\n555         decode_parameters(&parm, &bc, mode_par);\n556\n557         ctx->decode_frame(ctx, &parm, samples);\n558\n559         samples += subframe_size * mode_par->subframe_count;\n560     }\n561\n562     *got_frame_ptr = 1;\n563\n564     return mode_par->bits_per_frame >> 3;\n565 }"
                    }
                ]
            }
        ],
        "sink": "*u++ = (val >> 10) & 0x3FF;",
        "final_sink": "*u++ = (val >> 10) & 0x3FF;"
    },
    {
        "prt": "val",
        "function_call": [
            "static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    int h, w, ret;\n    AVFrame *pic = data;\n    const uint8_t *psrc = avpkt->data;\n    uint16_t *y, *u, *v;\n    int aligned_width = ((avctx->width + 47) / 48) * 48;\n    int stride = aligned_width * 8 / 3;\n\n    if (avpkt->size < stride * avctx->height) {\n        av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n        return ret;\n\n    y = (uint16_t*)pic->data[0];\n    u = (uint16_t*)pic->data[1];\n    v = (uint16_t*)pic->data[2];\n    pic->pict_type = AV_PICTURE_TYPE_I;\n    pic->key_frame = 1;\n\n#define READ_PIXELS(a, b, c)         \\\n    do {                             \\\n        val  = av_le2ne32(*src++);   \\\n        *a++ =  val & 0x3FF;         \\\n        *b++ = (val >> 10) & 0x3FF;  \\\n        *c++ = (val >> 20) & 0x3FF;  \\\n    } while (0)\n\n    for (h = 0; h < avctx->height; h++) {\n        const uint32_t *src = (const uint32_t*)psrc;\n        uint32_t val;\n        for (w = 0; w < avctx->width - 5; w += 6) {\n            READ_PIXELS(u, y, v);\n            READ_PIXELS(y, u, y);\n            READ_PIXELS(v, y, u);\n            READ_PIXELS(y, v, y);\n        }\n        if (w < avctx->width - 1) {\n            READ_PIXELS(u, y, v);\n\n            val  = av_le2ne32(*src++);\n            *y++ =  val & 0x3FF;\n        }\n        if (w < avctx->width - 3) {\n            *u++ = (val >> 10) & 0x3FF;\n            *y++ = (val >> 20) & 0x3FF;\n\n            val  = av_le2ne32(*src++);\n            *v++ =  val & 0x3FF;\n            *y++ = (val >> 10) & 0x3FF;\n        }\n\n        psrc += stride;\n        y += pic->linesize[0] / 2 - avctx->width;\n        u += pic->linesize[1] / 2 - avctx->width / 2;\n        v += pic->linesize[2] / 2 - avctx->width / 2;\n    }\n\n    *got_frame      = 1;\n\n    return avpkt->size;\n}"
        ],
        "source": [
            "        uint32_t val;"
        ],
        "index": 30,
        "location": {
            "file_path": "libavcodec/v210dec.c",
            "region": {
                "startLine": 91,
                "startColumn": 13,
                "endColumn": 16
            },
            "context": {
                "startLine": 89,
                "endLine": 93,
                "snippet": {
                    "text": "*y++ = (val >> 20) & 0x3FF;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavformat/nutdec.c",
                        "function_body": "880 static int nut_read_packet(AVFormatContext *s, AVPacket *pkt)\n881 {\n882     NUTContext *nut = s->priv_data;\n883     AVIOContext *bc = s->pb;\n884     int i, frame_code = 0, ret, skip;\n885     int64_t ts, back_ptr;\n886\n887     for (;;) {\n888         int64_t pos  = avio_tell(bc);\n889         uint64_t tmp = nut->next_startcode;\n890         nut->next_startcode = 0;\n891\n892         if (tmp) {\n893             pos -= 8;\n894         } else {\n895             frame_code = avio_r8(bc);\n896             if (bc->eof_reached)\n897                 return AVERROR_EOF;\n898             if (frame_code == 'N') {\n899                 tmp = frame_code;\n900                 for (i = 1; i < 8; i++)\n901                     tmp = (tmp << 8) + avio_r8(bc);\n902             }\n903         }\n904         switch (tmp) {\n905         case MAIN_STARTCODE:\n906         case STREAM_STARTCODE:\n907         case INDEX_STARTCODE:\n908             skip = get_packetheader(nut, bc, 0, tmp);\n909             avio_skip(bc, skip);\n910             break;\n911         case INFO_STARTCODE:\n912             if (decode_info_header(nut) < 0)\n913                 goto resync;\n914             break;\n915         case SYNCPOINT_STARTCODE:\n916             if (decode_syncpoint(nut, &ts, &back_ptr) < 0)\n917                 goto resync;\n918             frame_code = avio_r8(bc);\n919         case 0:\n920             ret = decode_frame(nut, pkt, frame_code);\n921             if (ret == 0)\n922                 return 0;\n923             else if (ret == 1) // OK but discard packet\n924                 break;\n925         default:\n926 resync:\n927             av_log(s, AV_LOG_DEBUG, \"syncing from %\"PRId64\"\\n\", pos);\n928             tmp = find_any_startcode(bc, nut->last_syncpoint_pos + 1);\n929             if (tmp == 0)\n930                 return AVERROR_INVALIDDATA;\n931             av_log(s, AV_LOG_DEBUG, \"sync\\n\");\n932             nut->next_startcode = tmp;\n933         }\n934     }\n935 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/wmalosslessdec.c",
                        "function_body": "1170 static int decode_packet(AVCodecContext *avctx, void *data, int *got_frame_ptr,\n1171                          AVPacket* avpkt)\n1172 {\n1173     WmallDecodeCtx *s = avctx->priv_data;\n1174     BitstreamContext *bc = &s->pbc;\n1175     const uint8_t* buf = avpkt->data;\n1176     int buf_size       = avpkt->size;\n1177     int num_bits_prev_frame, packet_sequence_number, spliced_packet;\n1178\n1179     s->frame->nb_samples = 0;\n1180\n1181     if (s->packet_done || s->packet_loss) {\n1182         s->packet_done = 0;\n1183\n1184         /* sanity check for the buffer length */\n1185         if (buf_size < avctx->block_align)\n1186             return 0;\n1187\n1188         s->next_packet_start = buf_size - avctx->block_align;\n1189         buf_size             = avctx->block_align;\n1190         s->buf_bit_size      = buf_size << 3;\n1191\n1192         /* parse packet header */\n1193         bitstream_init(bc, buf, s->buf_bit_size);\n1194         packet_sequence_number = bitstream_read(bc, 4);\n1195         bitstream_skip(bc, 1); // Skip seekable_frame_in_packet, currently ununused\n1196         spliced_packet = bitstream_read_bit(bc);\n1197         if (spliced_packet)\n1198             avpriv_request_sample(avctx, \"Bitstream splicing\");\n1199\n1200         /* get number of bits that need to be added to the previous frame */\n1201         num_bits_prev_frame = bitstream_read(bc, s->log2_frame_size);\n1202\n1203         /* check for packet loss */\n1204         if (!s->packet_loss &&\n1205             ((s->packet_sequence_number + 1) & 0xF) != packet_sequence_number) {\n1206             s->packet_loss = 1;\n1207             av_log(avctx, AV_LOG_ERROR,\n1208                    \"Packet loss detected! seq %\"PRIx8\" vs %x\\n\",\n1209                    s->packet_sequence_number, packet_sequence_number);\n1210         }\n1211         s->packet_sequence_number = packet_sequence_number;\n1212\n1213         if (num_bits_prev_frame > 0) {\n1214             int remaining_packet_bits = s->buf_bit_size - bitstream_tell(bc);\n1215             if (num_bits_prev_frame >= remaining_packet_bits) {\n1216                 num_bits_prev_frame = remaining_packet_bits;\n1217                 s->packet_done = 1;\n1218             }\n1219\n1220             /* Append the previous frame data to the remaining data from the\n1221              * previous packet to create a full frame. */\n1222             save_bits(s, bc, num_bits_prev_frame, 1);\n1223\n1224             /* decode the cross packet frame if it is valid */\n1225             if (num_bits_prev_frame < remaining_packet_bits && !s->packet_loss)\n1226                 decode_frame(s);\n1227         } else if (s->num_saved_bits - s->frame_offset) {\n1228             ff_dlog(avctx, \"ignoring %x previously saved bits\\n\",\n1229                     s->num_saved_bits - s->frame_offset);\n1230         }\n1231\n1232         if (s->packet_loss) {\n1233             /* Reset number of saved bits so that the decoder does not start\n1234              * to decode incomplete frames in the s->len_prefix == 0 case. */\n1235             s->num_saved_bits = 0;\n1236             s->packet_loss    = 0;\n1237             init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n1238         }\n1239\n1240     } else {\n1241         int frame_size;\n1242\n1243         s->buf_bit_size = (avpkt->size - s->next_packet_start) << 3;\n1244         bitstream_init(bc, avpkt->data, s->buf_bit_size);\n1245         bitstream_skip(bc, s->packet_offset);\n1246\n1247         if (s->len_prefix && remaining_bits(s, bc) > s->log2_frame_size &&\n1248             (frame_size = bitstream_peek(bc, s->log2_frame_size)) &&\n1249             frame_size <= remaining_bits(s, bc)) {\n1250             save_bits(s, bc, frame_size, 0);\n1251             s->packet_done = !decode_frame(s);\n1252         } else if (!s->len_prefix\n1253                    && s->num_saved_bits > bitstream_tell(&s->bc)) {\n1254             /* when the frames do not have a length prefix, we don't know the\n1255              * compressed length of the individual frames however, we know what\n1256              * part of a new packet belongs to the previous frame therefore we\n1257              * save the incoming packet first, then we append the \"previous\n1258              * frame\" data from the next packet so that we get a buffer that\n1259              * only contains full frames */\n1260             s->packet_done = !decode_frame(s);\n1261         } else {\n1262             s->packet_done = 1;\n1263         }\n1264     }\n1265\n1266     if (s->packet_done && !s->packet_loss &&\n1267         remaining_bits(s, bc) > 0) {\n1268         /* save the rest of the data so that it can be decoded\n1269          * with the next packet */\n1270         save_bits(s, bc, remaining_bits(s, bc), 0);\n1271     }\n1272\n1273     *got_frame_ptr   = s->frame->nb_samples > 0;\n1274     av_frame_move_ref(data, s->frame);\n1275\n1276     s->packet_offset = bitstream_tell(bc) & 7;\n1277\n1278     return (s->packet_loss) ? AVERROR_INVALIDDATA : bitstream_tell(bc) >> 3;\n1279 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/flacdec.c",
                        "function_body": "486 static int flac_decode_frame(AVCodecContext *avctx, void *data,\n487                              int *got_frame_ptr, AVPacket *avpkt)\n488 {\n489     AVFrame *frame     = data;\n490     const uint8_t *buf = avpkt->data;\n491     int buf_size = avpkt->size;\n492     FLACContext *s = avctx->priv_data;\n493     int bytes_read = 0;\n494     int ret;\n495\n496     *got_frame_ptr = 0;\n497\n498     if (s->max_framesize == 0) {\n499         s->max_framesize =\n500             ff_flac_get_max_frame_size(s->max_blocksize ? s->max_blocksize : FLAC_MAX_BLOCKSIZE,\n501                                        FLAC_MAX_CHANNELS, 32);\n502     }\n503\n504     /* check that there is at least the smallest decodable amount of data.\n505        this amount corresponds to the smallest valid FLAC frame possible.\n506        FF F8 69 02 00 00 9A 00 00 34 46 */\n507     if (buf_size < FLAC_MIN_FRAME_SIZE)\n508         return buf_size;\n509\n510     /* check for inline header */\n511     if (AV_RB32(buf) == MKBETAG('f','L','a','C')) {\n512         if (!s->got_streaminfo && (ret = parse_streaminfo(s, buf, buf_size))) {\n513             av_log(s->avctx, AV_LOG_ERROR, \"invalid header\\n\");\n514             return ret;\n515         }\n516         return get_metadata_size(buf, buf_size);\n517     }\n518\n519     /* decode frame */\n520     bitstream_init8(&s->bc, buf, buf_size);\n521     if ((ret = decode_frame(s)) < 0) {\n522         av_log(s->avctx, AV_LOG_ERROR, \"decode_frame() failed\\n\");\n523         return ret;\n524     }\n525     bytes_read = (bitstream_tell(&s->bc) + 7) / 8;\n526\n527     /* get output buffer */\n528     frame->nb_samples = s->blocksize;\n529     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n530         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n531         return ret;\n532     }\n533\n534     s->dsp.decorrelate[s->ch_mode](frame->data, s->decoded, s->channels,\n535                                    s->blocksize, s->sample_shift);\n536\n537     if (bytes_read > buf_size) {\n538         av_log(s->avctx, AV_LOG_ERROR, \"overread: %d\\n\", bytes_read - buf_size);\n539         return AVERROR_INVALIDDATA;\n540     }\n541     if (bytes_read < buf_size) {\n542         av_log(s->avctx, AV_LOG_DEBUG, \"underread: %d orig size: %d\\n\",\n543                buf_size - bytes_read, buf_size);\n544     }\n545\n546     *got_frame_ptr = 1;\n547\n548     return bytes_read;\n549 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/sipr.c",
                        "function_body": "522 static int sipr_decode_frame(AVCodecContext *avctx, void *data,\n523                              int *got_frame_ptr, AVPacket *avpkt)\n524 {\n525     SiprContext *ctx = avctx->priv_data;\n526     AVFrame *frame   = data;\n527     const uint8_t *buf=avpkt->data;\n528     SiprParameters parm;\n529     const SiprModeParam *mode_par = &modes[ctx->mode];\n530     BitstreamContext bc;\n531     float *samples;\n532     int subframe_size = ctx->mode == MODE_16k ? L_SUBFR_16k : SUBFR_SIZE;\n533     int i, ret;\n534\n535     ctx->avctx = avctx;\n536     if (avpkt->size < (mode_par->bits_per_frame >> 3)) {\n537         av_log(avctx, AV_LOG_ERROR,\n538                \"Error processing packet: packet size (%d) too small\\n\",\n539                avpkt->size);\n540         return -1;\n541     }\n542\n543     /* get output buffer */\n544     frame->nb_samples = mode_par->frames_per_packet * subframe_size *\n545                         mode_par->subframe_count;\n546     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n547         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n548         return ret;\n549     }\n550     samples = (float *)frame->data[0];\n551\n552     bitstream_init(&bc, buf, mode_par->bits_per_frame);\n553\n554     for (i = 0; i < mode_par->frames_per_packet; i++) {\n555         decode_parameters(&parm, &bc, mode_par);\n556\n557         ctx->decode_frame(ctx, &parm, samples);\n558\n559         samples += subframe_size * mode_par->subframe_count;\n560     }\n561\n562     *got_frame_ptr = 1;\n563\n564     return mode_par->bits_per_frame >> 3;\n565 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/wmaprodec.c",
                        "function_body": "1513 static int decode_packet(AVCodecContext *avctx, void *data,\n1514                          int *got_frame_ptr, AVPacket* avpkt)\n1515 {\n1516     WMAProDecodeCtx *s = avctx->priv_data;\n1517     BitstreamContext *bc = &s->pbc;\n1518     const uint8_t* buf = avpkt->data;\n1519     int buf_size       = avpkt->size;\n1520     int num_bits_prev_frame;\n1521     int packet_sequence_number;\n1522\n1523     *got_frame_ptr = 0;\n1524\n1525     if (s->packet_done || s->packet_loss) {\n1526         s->packet_done = 0;\n1527\n1528         /** sanity check for the buffer length */\n1529         if (buf_size < avctx->block_align) {\n1530             av_log(avctx, AV_LOG_ERROR, \"Input packet too small (%d < %d)\\n\",\n1531                    buf_size, avctx->block_align);\n1532             return AVERROR_INVALIDDATA;\n1533         }\n1534\n1535         s->next_packet_start = buf_size - avctx->block_align;\n1536         buf_size = avctx->block_align;\n1537         s->buf_bit_size = buf_size << 3;\n1538\n1539         /** parse packet header */\n1540         bitstream_init(bc, buf, s->buf_bit_size);\n1541         packet_sequence_number = bitstream_read(bc, 4);\n1542         bitstream_skip(bc, 2);\n1543\n1544         /** get number of bits that need to be added to the previous frame */\n1545         num_bits_prev_frame = bitstream_read(bc, s->log2_frame_size);\n1546         ff_dlog(avctx, \"packet[%d]: nbpf %x\\n\", avctx->frame_number,\n1547                 num_bits_prev_frame);\n1548\n1549         /** check for packet loss */\n1550         if (!s->packet_loss &&\n1551             ((s->packet_sequence_number + 1) & 0xF) != packet_sequence_number) {\n1552             s->packet_loss = 1;\n1553             av_log(avctx, AV_LOG_ERROR,\n1554                    \"Packet loss detected! seq %\"PRIx8\" vs %x\\n\",\n1555                    s->packet_sequence_number, packet_sequence_number);\n1556         }\n1557         s->packet_sequence_number = packet_sequence_number;\n1558\n1559         if (num_bits_prev_frame > 0) {\n1560             int remaining_packet_bits = s->buf_bit_size - bitstream_tell(bc);\n1561             if (num_bits_prev_frame >= remaining_packet_bits) {\n1562                 num_bits_prev_frame = remaining_packet_bits;\n1563                 s->packet_done = 1;\n1564             }\n1565\n1566             /** append the previous frame data to the remaining data from the\n1567                 previous packet to create a full frame */\n1568             save_bits(s, bc, num_bits_prev_frame, 1);\n1569             ff_dlog(avctx, \"accumulated %x bits of frame data\\n\",\n1570                     s->num_saved_bits - s->frame_offset);\n1571\n1572             /** decode the cross packet frame if it is valid */\n1573             if (!s->packet_loss)\n1574                 decode_frame(s, data, got_frame_ptr);\n1575         } else if (s->num_saved_bits - s->frame_offset) {\n1576             ff_dlog(avctx, \"ignoring %x previously saved bits\\n\",\n1577                     s->num_saved_bits - s->frame_offset);\n1578         }\n1579\n1580         if (s->packet_loss) {\n1581             /** reset number of saved bits so that the decoder\n1582                 does not start to decode incomplete frames in the\n1583                 s->len_prefix == 0 case */\n1584             s->num_saved_bits = 0;\n1585             s->packet_loss = 0;\n1586         }\n1587\n1588     } else {\n1589         int frame_size;\n1590         s->buf_bit_size = (avpkt->size - s->next_packet_start) << 3;\n1591         bitstream_init(bc, avpkt->data, s->buf_bit_size);\n1592         bitstream_skip(bc, s->packet_offset);\n1593         if (s->len_prefix && remaining_bits(s, bc) > s->log2_frame_size &&\n1594             (frame_size = bitstream_peek(bc, s->log2_frame_size)) &&\n1595             frame_size <= remaining_bits(s, bc)) {\n1596             save_bits(s, bc, frame_size, 0);\n1597             s->packet_done = !decode_frame(s, data, got_frame_ptr);\n1598         } else if (!s->len_prefix\n1599                    && s->num_saved_bits > bitstream_tell(&s->bc)) {\n1600             /** when the frames do not have a length prefix, we don't know\n1601                 the compressed length of the individual frames\n1602                 however, we know what part of a new packet belongs to the\n1603                 previous frame\n1604                 therefore we save the incoming packet first, then we append\n1605                 the \"previous frame\" data from the next packet so that\n1606                 we get a buffer that only contains full frames */\n1607             s->packet_done = !decode_frame(s, data, got_frame_ptr);\n1608         } else\n1609             s->packet_done = 1;\n1610     }\n1611\n1612     if (s->packet_done && !s->packet_loss &&\n1613         remaining_bits(s, bc) > 0) {\n1614         /** save the rest of the data so that it can be decoded\n1615             with the next packet */\n1616         save_bits(s, bc, remaining_bits(s, bc), 0);\n1617     }\n1618\n1619     s->packet_offset = bitstream_tell(bc) & 7;\n1620     if (s->packet_loss)\n1621         return AVERROR_INVALIDDATA;\n1622\n1623     return bitstream_tell(bc) >> 3;\n1624 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/v210dec.c",
                        "function_body": "42 static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n43                         AVPacket *avpkt)\n44 {\n45     int h, w, ret;\n46     AVFrame *pic = data;\n47     const uint8_t *psrc = avpkt->data;\n48     uint16_t *y, *u, *v;\n49     int aligned_width = ((avctx->width + 47) / 48) * 48;\n50     int stride = aligned_width * 8 / 3;\n51\n52     if (avpkt->size < stride * avctx->height) {\n53         av_log(avctx, AV_LOG_ERROR, \"packet too small\\n\");\n54         return AVERROR_INVALIDDATA;\n55     }\n56\n57     if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n58         return ret;\n59\n60     y = (uint16_t*)pic->data[0];\n61     u = (uint16_t*)pic->data[1];\n62     v = (uint16_t*)pic->data[2];\n63     pic->pict_type = AV_PICTURE_TYPE_I;\n64     pic->key_frame = 1;\n65\n66 #define READ_PIXELS(a, b, c)         \\\n67     do {                             \\\n68         val  = av_le2ne32(*src++);   \\\n69         *a++ =  val & 0x3FF;         \\\n70         *b++ = (val >> 10) & 0x3FF;  \\\n71         *c++ = (val >> 20) & 0x3FF;  \\\n72     } while (0)\n73\n74     for (h = 0; h < avctx->height; h++) {\n75         const uint32_t *src = (const uint32_t*)psrc;\n76         uint32_t val;\n77         for (w = 0; w < avctx->width - 5; w += 6) {\n78             READ_PIXELS(u, y, v);\n79             READ_PIXELS(y, u, y);\n80             READ_PIXELS(v, y, u);\n81             READ_PIXELS(y, v, y);\n82         }\n83         if (w < avctx->width - 1) {\n84             READ_PIXELS(u, y, v);\n85\n86             val  = av_le2ne32(*src++);\n87             *y++ =  val & 0x3FF;\n88         }\n89         if (w < avctx->width - 3) {\n90             *u++ = (val >> 10) & 0x3FF;\n91             *y++ = (val >> 20) & 0x3FF;\n92\n93             val  = av_le2ne32(*src++);\n94             *v++ =  val & 0x3FF;\n95             *y++ = (val >> 10) & 0x3FF;\n96         }\n97\n98         psrc += stride;\n99         y += pic->linesize[0] / 2 - avctx->width;\n100         u += pic->linesize[1] / 2 - avctx->width / 2;\n101         v += pic->linesize[2] / 2 - avctx->width / 2;\n102     }\n103\n104     *got_frame      = 1;\n105\n106     return avpkt->size;\n107 }"
                    },
                    {
                        "file_path": "/libavcodec/atrac3.c",
                        "function_body": "734 static int atrac3_decode_frame(AVCodecContext *avctx, void *data,\n735                                int *got_frame_ptr, AVPacket *avpkt)\n736 {\n737     AVFrame *frame     = data;\n738     const uint8_t *buf = avpkt->data;\n739     int buf_size = avpkt->size;\n740     ATRAC3Context *q = avctx->priv_data;\n741     int ret;\n742     const uint8_t *databuf;\n743\n744     if (buf_size < avctx->block_align) {\n745         av_log(avctx, AV_LOG_ERROR,\n746                \"Frame too small (%d bytes). Truncated file?\\n\", buf_size);\n747         return AVERROR_INVALIDDATA;\n748     }\n749\n750     /* get output buffer */\n751     frame->nb_samples = SAMPLES_PER_FRAME;\n752     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {\n753         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n754         return ret;\n755     }\n756\n757     /* Check if we need to descramble and what buffer to pass on. */\n758     if (q->scrambled_stream) {\n759         decode_bytes(buf, q->decoded_bytes_buffer, avctx->block_align);\n760         databuf = q->decoded_bytes_buffer;\n761     } else {\n762         databuf = buf;\n763     }\n764\n765     ret = decode_frame(avctx, databuf, (float **)frame->extended_data);\n766     if (ret) {\n767         av_log(NULL, AV_LOG_ERROR, \"Frame decoding error!\\n\");\n768         return ret;\n769     }\n770\n771     *got_frame_ptr = 1;\n772\n773     return avctx->block_align;\n774 }"
                    }
                ]
            }
        ],
        "sink": "*y++ = (val >> 20) & 0x3FF;",
        "final_sink": "*y++ = (val >> 20) & 0x3FF;"
    },
    {
        "prt": "opcode",
        "function_call": [
            "static int decode_type2(GetByteContext *gb, PutByteContext *pb)\n{\n    unsigned repeat = 0, first = 1, opcode;\n    int i, len, pos;\n\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        GetByteContext gbc;\n\n        while (bytestream2_get_bytes_left(gb) > 0) {\n            if (first) {\n                first = 0;\n                if (bytestream2_peek_byte(gb) > 17) {\n                    len = bytestream2_get_byte(gb) - 17;\n                    if (len < 4) {\n                        do {\n                            bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                            --len;\n                        } while (len);\n                        opcode = bytestream2_peek_byte(gb);\n                        continue;\n                    } else {\n                        do {\n                            bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                            --len;\n                        } while (len);\n                        opcode = bytestream2_peek_byte(gb);\n                        if (opcode < 0x10) {\n                            bytestream2_skip(gb, 1);\n                            pos = - (opcode >> 2) - 4 * bytestream2_get_byte(gb) - 2049;\n\n                            bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n                            bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n                            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                            len = opcode & 3;\n                            if (!len) {\n                                repeat = 1;\n                            } else {\n                                do {\n                                    bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                                    --len;\n                                } while (len);\n                                opcode = bytestream2_peek_byte(gb);\n                            }\n                            continue;\n                        }\n                    }\n                    repeat = 0;\n                }\n                repeat = 1;\n            }\n            if (repeat) {\n                repeat = 0;\n                opcode = bytestream2_peek_byte(gb);\n                if (opcode < 0x10) {\n                    bytestream2_skip(gb, 1);\n                    if (!opcode) {\n                        if (!bytestream2_peek_byte(gb)) {\n                            do {\n                                bytestream2_skip(gb, 1);\n                                opcode += 255;\n                            } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n                        }\n                        opcode += bytestream2_get_byte(gb) + 15;\n                    }\n                    bytestream2_put_le32(pb, bytestream2_get_le32(gb));\n                    for (i = opcode - 1; i > 0; --i)\n                        bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                    opcode = bytestream2_peek_byte(gb);\n                    if (opcode < 0x10) {\n                        bytestream2_skip(gb, 1);\n                        pos = - (opcode >> 2) - 4 * bytestream2_get_byte(gb) - 2049;\n\n                        bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n                        bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n                        bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                        bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                        bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                        len = opcode & 3;\n                        if (!len) {\n                            repeat = 1;\n                        } else {\n                            do {\n                                bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                                --len;\n                            } while (len);\n                            opcode = bytestream2_peek_byte(gb);\n                        }\n                        continue;\n                    }\n                }\n            }\n\n            if (opcode >= 0x40) {\n                bytestream2_skip(gb, 1);\n                pos = - ((opcode >> 2) & 7) - 1 - 8 * bytestream2_get_byte(gb);\n                len =    (opcode >> 5)      - 1;\n\n                bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n                bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                    --len;\n                } while (len);\n\n                len = opcode & 3;\n\n                if (!len) {\n                    repeat = 1;\n                } else {\n                    do {\n                        bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                        --len;\n                    } while (len);\n                    opcode = bytestream2_peek_byte(gb);\n                }\n                continue;\n            } else if (opcode < 0x20) {\n                break;\n            }\n            len = opcode & 0x1F;\n            bytestream2_skip(gb, 1);\n            if (!len) {\n                if (!bytestream2_peek_byte(gb)) {\n                    do {\n                        bytestream2_skip(gb, 1);\n                        len += 255;\n                    } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n                }\n                len += bytestream2_get_byte(gb) + 31;\n            }\n            i = bytestream2_get_le16(gb);\n            pos = - (i >> 2) - 1;\n\n            bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n            bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n            if (len < 6 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                    --len;\n                } while (len);\n            } else {\n                bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n                for (len = len - 2; len; --len)\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            }\n            len = i & 3;\n            if (!len) {\n                repeat = 1;\n            } else {\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                    --len;\n                } while (len);\n                opcode = bytestream2_peek_byte(gb);\n            }\n        }\n        bytestream2_skip(gb, 1);\n        if (opcode < 0x10) {\n            pos = -(opcode >> 2) - 1 - 4 * bytestream2_get_byte(gb);\n\n            bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n            bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            len = opcode & 3;\n            if (!len) {\n                repeat = 1;\n            } else {\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                    --len;\n                } while (len);\n                opcode = bytestream2_peek_byte(gb);\n            }\n            continue;\n        }\n        len = opcode & 7;\n        if (!len) {\n            if (!bytestream2_peek_byte(gb)) {\n                do {\n                    bytestream2_skip(gb, 1);\n                    len += 255;\n                } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n            }\n            len += bytestream2_get_byte(gb) + 7;\n        }\n        i = bytestream2_get_le16(gb);\n        pos = bytestream2_tell_p(pb) - 2048 * (opcode & 8);\n        pos = pos - (i >> 2);\n        if (pos == bytestream2_tell_p(pb))\n            break;\n\n        pos = pos - 0x4000;\n        bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n        bytestream2_seek(&gbc, pos, SEEK_SET);\n\n        if (len < 6 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            do {\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                --len;\n            } while (len);\n        } else {\n            bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n            for (len = len - 2; len; --len)\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n        }\n\n        len = i & 3;\n        if (!len) {\n            repeat = 1;\n        } else {\n            do {\n                bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                --len;\n            } while (len);\n            opcode = bytestream2_peek_byte(gb);\n        }\n    }\n\n    return 0;\n}"
        ],
        "source": [
            "    unsigned repeat = 0, first = 1, opcode;"
        ],
        "index": 31,
        "location": {
            "file_path": "libavcodec/fmvc.c",
            "region": {
                "startLine": 152,
                "startColumn": 17,
                "endColumn": 23
            },
            "context": {
                "startLine": 150,
                "endLine": 154,
                "snippet": {
                    "text": "pos = - ((opcode >> 2) & 7) - 1 - 8 * bytestream2_get_byte(gb);"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/fmvc.c",
                        "function_body": "54  static int decode_type2(GetByteContext *gb, PutByteContext *pb)\n55  {\n56      unsigned repeat = 0, first = 1, opcode;\n57      int i, len, pos;\n58\n59      while (bytestream2_get_bytes_left(gb) > 0) {\n60          GetByteContext gbc;\n61\n62          while (bytestream2_get_bytes_left(gb) > 0) {\n63              if (first) {\n64                  first = 0;\n65                  if (bytestream2_peek_byte(gb) > 17) {\n66                      len = bytestream2_get_byte(gb) - 17;\n67                      if (len < 4) {\n68                          do {\n69                              bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n70                              --len;\n71                          } while (len);\n72                          opcode = bytestream2_peek_byte(gb);\n73                          continue;\n74                      } else {\n75                          do {\n76                              bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n77                              --len;\n78                          } while (len);\n79                          opcode = bytestream2_peek_byte(gb);\n80                          if (opcode < 0x10) {\n81                              bytestream2_skip(gb, 1);\n82                              pos = - (opcode >> 2) - 4 * bytestream2_get_byte(gb) - 2049;\n83\n84                              bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n85                              bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n86\n87                              bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n88                              bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n89                              bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n90                              len = opcode & 3;\n91                              if (!len) {\n92                                  repeat = 1;\n93                              } else {\n94                                  do {\n95                                      bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n96                                      --len;\n97                                  } while (len);\n98                                  opcode = bytestream2_peek_byte(gb);\n99                              }\n100                             continue;\n101                         }\n102                     }\n103                     repeat = 0;\n104                 }\n105                 repeat = 1;\n106             }\n107             if (repeat) {\n108                 repeat = 0;\n109                 opcode = bytestream2_peek_byte(gb);\n110                 if (opcode < 0x10) {\n111                     bytestream2_skip(gb, 1);\n112                     if (!opcode) {\n113                         if (!bytestream2_peek_byte(gb)) {\n114                             do {\n115                                 bytestream2_skip(gb, 1);\n116                                 opcode += 255;\n117                             } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n118                         }\n119                         opcode += bytestream2_get_byte(gb) + 15;\n120                     }\n121                     bytestream2_put_le32(pb, bytestream2_get_le32(gb));\n122                     for (i = opcode - 1; i > 0; --i)\n123                         bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n124                     opcode = bytestream2_peek_byte(gb);\n125                     if (opcode < 0x10) {\n126                         bytestream2_skip(gb, 1);\n127                         pos = - (opcode >> 2) - 4 * bytestream2_get_byte(gb) - 2049;\n128\n129                         bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n130                         bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n131\n132                         bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n133                         bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n134                         bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n135                         len = opcode & 3;\n136                         if (!len) {\n137                             repeat = 1;\n138                         } else {\n139                             do {\n140                                 bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n141                                 --len;\n142                             } while (len);\n143                             opcode = bytestream2_peek_byte(gb);\n144                         }\n145                         continue;\n146                     }\n147                 }\n148             }\n149\n150             if (opcode >= 0x40) {\n151                 bytestream2_skip(gb, 1);\n152                 pos = - ((opcode >> 2) & 7) - 1 - 8 * bytestream2_get_byte(gb);\n153                 len =    (opcode >> 5)      - 1;\n154\n155                 bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n156                 bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n157\n158                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n159                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n160                 do {\n161                     bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n162                     --len;\n163                 } while (len);\n164\n165                 len = opcode & 3;\n166\n167                 if (!len) {\n168                     repeat = 1;\n169                 } else {\n170                     do {\n171                         bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n172                         --len;\n173                     } while (len);\n174                     opcode = bytestream2_peek_byte(gb);\n175                 }\n176                 continue;\n177             } else if (opcode < 0x20) {\n178                 break;\n179             }\n180             len = opcode & 0x1F;\n181             bytestream2_skip(gb, 1);\n182             if (!len) {\n183                 if (!bytestream2_peek_byte(gb)) {\n184                     do {\n185                         bytestream2_skip(gb, 1);\n186                         len += 255;\n187                     } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n188                 }\n189                 len += bytestream2_get_byte(gb) + 31;\n190             }\n191             i = bytestream2_get_le16(gb);\n192             pos = - (i >> 2) - 1;\n193\n194             bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n195             bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n196\n197             if (len < 6 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n198                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n199                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n200                 do {\n201                     bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n202                     --len;\n203                 } while (len);\n204             } else {\n205                 bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n206                 for (len = len - 2; len; --len)\n207                     bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n208             }\n209             len = i & 3;\n210             if (!len) {\n211                 repeat = 1;\n212             } else {\n213                 do {\n214                     bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n215                     --len;\n216                 } while (len);\n217                 opcode = bytestream2_peek_byte(gb);\n218             }\n219         }\n220         bytestream2_skip(gb, 1);\n221         if (opcode < 0x10) {\n222             pos = -(opcode >> 2) - 1 - 4 * bytestream2_get_byte(gb);\n223\n224             bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n225             bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n226\n227             bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n228             bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n229             len = opcode & 3;\n230             if (!len) {\n231                 repeat = 1;\n232             } else {\n233                 do {\n234                     bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n235                     --len;\n236                 } while (len);\n237                 opcode = bytestream2_peek_byte(gb);\n238             }\n239             continue;\n240         }\n241         len = opcode & 7;\n242         if (!len) {\n243             if (!bytestream2_peek_byte(gb)) {\n244                 do {\n245                     bytestream2_skip(gb, 1);\n246                     len += 255;\n247                 } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n248             }\n249             len += bytestream2_get_byte(gb) + 7;\n250         }\n251         i = bytestream2_get_le16(gb);\n252         pos = bytestream2_tell_p(pb) - 2048 * (opcode & 8);\n253         pos = pos - (i >> 2);\n254         if (pos == bytestream2_tell_p(pb))\n255             break;\n256\n257         pos = pos - 0x4000;\n258         bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n259         bytestream2_seek(&gbc, pos, SEEK_SET);\n260\n261         if (len < 6 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n262             bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n263             bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n264             do {\n265                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n266                 --len;\n267             } while (len);\n268         } else {\n269             bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n270             for (len = len - 2; len; --len)\n271                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n272         }\n273\n274         len = i & 3;\n275         if (!len) {\n276             repeat = 1;\n277         } else {\n278             do {\n279                 bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n280                 --len;\n281             } while (len);\n282             opcode = bytestream2_peek_byte(gb);\n283         }\n284     }\n285\n286     return 0;\n287 }"
                    },
                    {
                        "file_path": "/libavcodec/fmvc.c",
                        "function_body": "396 static int decode_frame(AVCodecContext *avctx, void *data,\n397                         int *got_frame, AVPacket *avpkt)\n398 {\n399     FMVCContext *s = avctx->priv_data;\n400     GetByteContext *gb = &s->gb;\n401     PutByteContext *pb = &s->pb;\n402     AVFrame *frame = data;\n403     int ret, y, x;\n404\n405     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n406         return ret;\n407\n408     bytestream2_init(gb, avpkt->data, avpkt->size);\n409     bytestream2_skip(gb, 2);\n410\n411     frame->key_frame = !!bytestream2_get_le16(gb);\n412     frame->pict_type = frame->key_frame ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n413\n414     if (frame->key_frame) {\n415         const uint8_t *src;\n416         unsigned type, size;\n417         uint8_t *dst;\n418\n419         type = bytestream2_get_le16(gb);\n420         size = bytestream2_get_le16(gb);\n421         if (size > bytestream2_get_bytes_left(gb))\n422             return AVERROR_INVALIDDATA;\n423\n424         bytestream2_init_writer(pb, s->buffer, s->buffer_size);\n425         if (type == 1) {\n426             decode_type1(gb, pb);\n427         } else if (type == 2){\n428             decode_type2(gb, pb);\n429         } else {\n430             avpriv_report_missing_feature(avctx, \"Compression type %d\", type);\n431             return AVERROR_PATCHWELCOME;\n432         }\n433\n434         src = s->buffer;\n435         dst = frame->data[0] + (avctx->height - 1) * frame->linesize[0];\n436         for (y = 0; y < avctx->height; y++) {\n437             memcpy(dst, src, avctx->width * s->bpp);\n438             dst -= frame->linesize[0];\n439             src += avctx->width * s->bpp;\n440         }\n441     } else {\n442         unsigned block, nb_blocks;\n443         int type, k, l;\n444         uint8_t *ssrc, *ddst;\n445         const uint32_t *src;\n446         uint32_t *dst;\n447\n448         for (block = 0; block < s->nb_blocks; block++)\n449             s->blocks[block].xor = 0;\n450\n451         nb_blocks = bytestream2_get_le16(gb);\n452         if (nb_blocks > s->nb_blocks)\n453             return AVERROR_INVALIDDATA;\n454\n455         bytestream2_init_writer(pb, s->pbuffer, s->pbuffer_size);\n456\n457         type = bytestream2_get_le16(gb);\n458         for (block = 0; block < nb_blocks; block++) {\n459             unsigned size, offset;\n460             int start = 0;\n461\n462             offset = bytestream2_get_le16(gb);\n463             if (offset > s->nb_blocks)\n464                 return AVERROR_INVALIDDATA;\n465\n466             size = bytestream2_get_le16(gb);\n467             if (size > bytestream2_get_bytes_left(gb))\n468                 return AVERROR_INVALIDDATA;\n469\n470             start = bytestream2_tell_p(pb);\n471             if (type == 1) {\n472                 decode_type1(gb, pb);\n473             } else if (type == 2){\n474                 decode_type2(gb, pb);\n475             } else {\n476                 avpriv_report_missing_feature(avctx, \"Compression type %d\", type);\n477                 return AVERROR_PATCHWELCOME;\n478             }\n479\n480             if (s->blocks[offset].size * 4 != bytestream2_tell_p(pb) - start)\n481                 return AVERROR_INVALIDDATA;\n482\n483             s->blocks[offset].xor = 1;\n484         }\n485\n486         src = (const uint32_t *)s->pbuffer;\n487         dst = (uint32_t *)s->buffer;\n488\n489         for (block = 0, y = 0; y < s->yb; y++) {\n490             int block_h = s->blocks[block].h;\n491             uint32_t *rect = dst;\n492\n493             for (x = 0; x < s->xb; x++) {\n494                 int block_w = s->blocks[block].w;\n495                 uint32_t *row = dst;\n496\n497                 block_h = s->blocks[block].h;\n498                 if (s->blocks[block].xor) {\n499                     for (k = 0; k < block_h; k++) {\n500                         uint32_t *column = dst;\n501                         for (l = 0; l < block_w; l++)\n502                             *dst++ ^= *src++;\n503                         dst = &column[s->stride];\n504                     }\n505                 }\n506                 dst = &row[block_w];\n507                 ++block;\n508             }\n509             dst = &rect[block_h * s->stride];\n510         }\n511\n512         ssrc = s->buffer;\n513         ddst = frame->data[0] + (avctx->height - 1) * frame->linesize[0];\n514         for (y = 0; y < avctx->height; y++) {\n515             memcpy(ddst, ssrc, avctx->width * s->bpp);\n516             ddst -= frame->linesize[0];\n517             ssrc += avctx->width * s->bpp;\n518         }\n519     }\n520\n521     *got_frame = 1;\n522\n523     return avpkt->size;\n524 }"
                    }
                ]
            }
        ],
        "sink": "pos = - ((opcode >> 2) & 7) - 1 - 8 * bytestream2_get_byte(gb);",
        "final_sink": "pos = - ((opcode >> 2) & 7) - 1 - 8 * bytestream2_get_byte(gb);"
    },
    {
        "prt": "opcode",
        "function_call": [
            "static int decode_type2(GetByteContext *gb, PutByteContext *pb)\n{\n    unsigned repeat = 0, first = 1, opcode;\n    int i, len, pos;\n\n    while (bytestream2_get_bytes_left(gb) > 0) {\n        GetByteContext gbc;\n\n        while (bytestream2_get_bytes_left(gb) > 0) {\n            if (first) {\n                first = 0;\n                if (bytestream2_peek_byte(gb) > 17) {\n                    len = bytestream2_get_byte(gb) - 17;\n                    if (len < 4) {\n                        do {\n                            bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                            --len;\n                        } while (len);\n                        opcode = bytestream2_peek_byte(gb);\n                        continue;\n                    } else {\n                        do {\n                            bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                            --len;\n                        } while (len);\n                        opcode = bytestream2_peek_byte(gb);\n                        if (opcode < 0x10) {\n                            bytestream2_skip(gb, 1);\n                            pos = - (opcode >> 2) - 4 * bytestream2_get_byte(gb) - 2049;\n\n                            bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n                            bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n                            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                            len = opcode & 3;\n                            if (!len) {\n                                repeat = 1;\n                            } else {\n                                do {\n                                    bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                                    --len;\n                                } while (len);\n                                opcode = bytestream2_peek_byte(gb);\n                            }\n                            continue;\n                        }\n                    }\n                    repeat = 0;\n                }\n                repeat = 1;\n            }\n            if (repeat) {\n                repeat = 0;\n                opcode = bytestream2_peek_byte(gb);\n                if (opcode < 0x10) {\n                    bytestream2_skip(gb, 1);\n                    if (!opcode) {\n                        if (!bytestream2_peek_byte(gb)) {\n                            do {\n                                bytestream2_skip(gb, 1);\n                                opcode += 255;\n                            } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n                        }\n                        opcode += bytestream2_get_byte(gb) + 15;\n                    }\n                    bytestream2_put_le32(pb, bytestream2_get_le32(gb));\n                    for (i = opcode - 1; i > 0; --i)\n                        bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                    opcode = bytestream2_peek_byte(gb);\n                    if (opcode < 0x10) {\n                        bytestream2_skip(gb, 1);\n                        pos = - (opcode >> 2) - 4 * bytestream2_get_byte(gb) - 2049;\n\n                        bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n                        bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n                        bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                        bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                        bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                        len = opcode & 3;\n                        if (!len) {\n                            repeat = 1;\n                        } else {\n                            do {\n                                bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                                --len;\n                            } while (len);\n                            opcode = bytestream2_peek_byte(gb);\n                        }\n                        continue;\n                    }\n                }\n            }\n\n            if (opcode >= 0x40) {\n                bytestream2_skip(gb, 1);\n                pos = - ((opcode >> 2) & 7) - 1 - 8 * bytestream2_get_byte(gb);\n                len =    (opcode >> 5)      - 1;\n\n                bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n                bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                    --len;\n                } while (len);\n\n                len = opcode & 3;\n\n                if (!len) {\n                    repeat = 1;\n                } else {\n                    do {\n                        bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                        --len;\n                    } while (len);\n                    opcode = bytestream2_peek_byte(gb);\n                }\n                continue;\n            } else if (opcode < 0x20) {\n                break;\n            }\n            len = opcode & 0x1F;\n            bytestream2_skip(gb, 1);\n            if (!len) {\n                if (!bytestream2_peek_byte(gb)) {\n                    do {\n                        bytestream2_skip(gb, 1);\n                        len += 255;\n                    } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n                }\n                len += bytestream2_get_byte(gb) + 31;\n            }\n            i = bytestream2_get_le16(gb);\n            pos = - (i >> 2) - 1;\n\n            bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n            bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n            if (len < 6 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                    --len;\n                } while (len);\n            } else {\n                bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n                for (len = len - 2; len; --len)\n                    bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            }\n            len = i & 3;\n            if (!len) {\n                repeat = 1;\n            } else {\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                    --len;\n                } while (len);\n                opcode = bytestream2_peek_byte(gb);\n            }\n        }\n        bytestream2_skip(gb, 1);\n        if (opcode < 0x10) {\n            pos = -(opcode >> 2) - 1 - 4 * bytestream2_get_byte(gb);\n\n            bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n            bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            len = opcode & 3;\n            if (!len) {\n                repeat = 1;\n            } else {\n                do {\n                    bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                    --len;\n                } while (len);\n                opcode = bytestream2_peek_byte(gb);\n            }\n            continue;\n        }\n        len = opcode & 7;\n        if (!len) {\n            if (!bytestream2_peek_byte(gb)) {\n                do {\n                    bytestream2_skip(gb, 1);\n                    len += 255;\n                } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n            }\n            len += bytestream2_get_byte(gb) + 7;\n        }\n        i = bytestream2_get_le16(gb);\n        pos = bytestream2_tell_p(pb) - 2048 * (opcode & 8);\n        pos = pos - (i >> 2);\n        if (pos == bytestream2_tell_p(pb))\n            break;\n\n        pos = pos - 0x4000;\n        bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n        bytestream2_seek(&gbc, pos, SEEK_SET);\n\n        if (len < 6 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n            do {\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n                --len;\n            } while (len);\n        } else {\n            bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n            for (len = len - 2; len; --len)\n                bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n        }\n\n        len = i & 3;\n        if (!len) {\n            repeat = 1;\n        } else {\n            do {\n                bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n                --len;\n            } while (len);\n            opcode = bytestream2_peek_byte(gb);\n        }\n    }\n\n    return 0;\n}"
        ],
        "source": [
            "    unsigned repeat = 0, first = 1, opcode;"
        ],
        "index": 32,
        "location": {
            "file_path": "libavcodec/fmvc.c",
            "region": {
                "startLine": 153,
                "startColumn": 17,
                "endColumn": 23
            },
            "context": {
                "startLine": 151,
                "endLine": 155,
                "snippet": {
                    "text": "len =    (opcode >> 5)      - 1;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/fmvc.c",
                        "function_body": "54  static int decode_type2(GetByteContext *gb, PutByteContext *pb)\n55  {\n56      unsigned repeat = 0, first = 1, opcode;\n57      int i, len, pos;\n58\n59      while (bytestream2_get_bytes_left(gb) > 0) {\n60          GetByteContext gbc;\n61\n62          while (bytestream2_get_bytes_left(gb) > 0) {\n63              if (first) {\n64                  first = 0;\n65                  if (bytestream2_peek_byte(gb) > 17) {\n66                      len = bytestream2_get_byte(gb) - 17;\n67                      if (len < 4) {\n68                          do {\n69                              bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n70                              --len;\n71                          } while (len);\n72                          opcode = bytestream2_peek_byte(gb);\n73                          continue;\n74                      } else {\n75                          do {\n76                              bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n77                              --len;\n78                          } while (len);\n79                          opcode = bytestream2_peek_byte(gb);\n80                          if (opcode < 0x10) {\n81                              bytestream2_skip(gb, 1);\n82                              pos = - (opcode >> 2) - 4 * bytestream2_get_byte(gb) - 2049;\n83\n84                              bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n85                              bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n86\n87                              bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n88                              bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n89                              bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n90                              len = opcode & 3;\n91                              if (!len) {\n92                                  repeat = 1;\n93                              } else {\n94                                  do {\n95                                      bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n96                                      --len;\n97                                  } while (len);\n98                                  opcode = bytestream2_peek_byte(gb);\n99                              }\n100                             continue;\n101                         }\n102                     }\n103                     repeat = 0;\n104                 }\n105                 repeat = 1;\n106             }\n107             if (repeat) {\n108                 repeat = 0;\n109                 opcode = bytestream2_peek_byte(gb);\n110                 if (opcode < 0x10) {\n111                     bytestream2_skip(gb, 1);\n112                     if (!opcode) {\n113                         if (!bytestream2_peek_byte(gb)) {\n114                             do {\n115                                 bytestream2_skip(gb, 1);\n116                                 opcode += 255;\n117                             } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n118                         }\n119                         opcode += bytestream2_get_byte(gb) + 15;\n120                     }\n121                     bytestream2_put_le32(pb, bytestream2_get_le32(gb));\n122                     for (i = opcode - 1; i > 0; --i)\n123                         bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n124                     opcode = bytestream2_peek_byte(gb);\n125                     if (opcode < 0x10) {\n126                         bytestream2_skip(gb, 1);\n127                         pos = - (opcode >> 2) - 4 * bytestream2_get_byte(gb) - 2049;\n128\n129                         bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n130                         bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n131\n132                         bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n133                         bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n134                         bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n135                         len = opcode & 3;\n136                         if (!len) {\n137                             repeat = 1;\n138                         } else {\n139                             do {\n140                                 bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n141                                 --len;\n142                             } while (len);\n143                             opcode = bytestream2_peek_byte(gb);\n144                         }\n145                         continue;\n146                     }\n147                 }\n148             }\n149\n150             if (opcode >= 0x40) {\n151                 bytestream2_skip(gb, 1);\n152                 pos = - ((opcode >> 2) & 7) - 1 - 8 * bytestream2_get_byte(gb);\n153                 len =    (opcode >> 5)      - 1;\n154\n155                 bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n156                 bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n157\n158                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n159                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n160                 do {\n161                     bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n162                     --len;\n163                 } while (len);\n164\n165                 len = opcode & 3;\n166\n167                 if (!len) {\n168                     repeat = 1;\n169                 } else {\n170                     do {\n171                         bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n172                         --len;\n173                     } while (len);\n174                     opcode = bytestream2_peek_byte(gb);\n175                 }\n176                 continue;\n177             } else if (opcode < 0x20) {\n178                 break;\n179             }\n180             len = opcode & 0x1F;\n181             bytestream2_skip(gb, 1);\n182             if (!len) {\n183                 if (!bytestream2_peek_byte(gb)) {\n184                     do {\n185                         bytestream2_skip(gb, 1);\n186                         len += 255;\n187                     } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n188                 }\n189                 len += bytestream2_get_byte(gb) + 31;\n190             }\n191             i = bytestream2_get_le16(gb);\n192             pos = - (i >> 2) - 1;\n193\n194             bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n195             bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n196\n197             if (len < 6 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n198                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n199                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n200                 do {\n201                     bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n202                     --len;\n203                 } while (len);\n204             } else {\n205                 bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n206                 for (len = len - 2; len; --len)\n207                     bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n208             }\n209             len = i & 3;\n210             if (!len) {\n211                 repeat = 1;\n212             } else {\n213                 do {\n214                     bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n215                     --len;\n216                 } while (len);\n217                 opcode = bytestream2_peek_byte(gb);\n218             }\n219         }\n220         bytestream2_skip(gb, 1);\n221         if (opcode < 0x10) {\n222             pos = -(opcode >> 2) - 1 - 4 * bytestream2_get_byte(gb);\n223\n224             bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n225             bytestream2_seek(&gbc, bytestream2_tell_p(pb) + pos, SEEK_SET);\n226\n227             bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n228             bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n229             len = opcode & 3;\n230             if (!len) {\n231                 repeat = 1;\n232             } else {\n233                 do {\n234                     bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n235                     --len;\n236                 } while (len);\n237                 opcode = bytestream2_peek_byte(gb);\n238             }\n239             continue;\n240         }\n241         len = opcode & 7;\n242         if (!len) {\n243             if (!bytestream2_peek_byte(gb)) {\n244                 do {\n245                     bytestream2_skip(gb, 1);\n246                     len += 255;\n247                 } while (!bytestream2_peek_byte(gb) && bytestream2_get_bytes_left(gb) > 0);\n248             }\n249             len += bytestream2_get_byte(gb) + 7;\n250         }\n251         i = bytestream2_get_le16(gb);\n252         pos = bytestream2_tell_p(pb) - 2048 * (opcode & 8);\n253         pos = pos - (i >> 2);\n254         if (pos == bytestream2_tell_p(pb))\n255             break;\n256\n257         pos = pos - 0x4000;\n258         bytestream2_init(&gbc, pb->buffer_start, pb->buffer_end - pb->buffer_start);\n259         bytestream2_seek(&gbc, pos, SEEK_SET);\n260\n261         if (len < 6 || bytestream2_tell_p(pb) - bytestream2_tell(&gbc) < 4) {\n262             bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n263             bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n264             do {\n265                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n266                 --len;\n267             } while (len);\n268         } else {\n269             bytestream2_put_le32(pb, bytestream2_get_le32(&gbc));\n270             for (len = len - 2; len; --len)\n271                 bytestream2_put_byte(pb, bytestream2_get_byte(&gbc));\n272         }\n273\n274         len = i & 3;\n275         if (!len) {\n276             repeat = 1;\n277         } else {\n278             do {\n279                 bytestream2_put_byte(pb, bytestream2_get_byte(gb));\n280                 --len;\n281             } while (len);\n282             opcode = bytestream2_peek_byte(gb);\n283         }\n284     }\n285\n286     return 0;\n287 }"
                    },
                    {
                        "file_path": "/libavcodec/fmvc.c",
                        "function_body": "396 static int decode_frame(AVCodecContext *avctx, void *data,\n397                         int *got_frame, AVPacket *avpkt)\n398 {\n399     FMVCContext *s = avctx->priv_data;\n400     GetByteContext *gb = &s->gb;\n401     PutByteContext *pb = &s->pb;\n402     AVFrame *frame = data;\n403     int ret, y, x;\n404\n405     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n406         return ret;\n407\n408     bytestream2_init(gb, avpkt->data, avpkt->size);\n409     bytestream2_skip(gb, 2);\n410\n411     frame->key_frame = !!bytestream2_get_le16(gb);\n412     frame->pict_type = frame->key_frame ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n413\n414     if (frame->key_frame) {\n415         const uint8_t *src;\n416         unsigned type, size;\n417         uint8_t *dst;\n418\n419         type = bytestream2_get_le16(gb);\n420         size = bytestream2_get_le16(gb);\n421         if (size > bytestream2_get_bytes_left(gb))\n422             return AVERROR_INVALIDDATA;\n423\n424         bytestream2_init_writer(pb, s->buffer, s->buffer_size);\n425         if (type == 1) {\n426             decode_type1(gb, pb);\n427         } else if (type == 2){\n428             decode_type2(gb, pb);\n429         } else {\n430             avpriv_report_missing_feature(avctx, \"Compression type %d\", type);\n431             return AVERROR_PATCHWELCOME;\n432         }\n433\n434         src = s->buffer;\n435         dst = frame->data[0] + (avctx->height - 1) * frame->linesize[0];\n436         for (y = 0; y < avctx->height; y++) {\n437             memcpy(dst, src, avctx->width * s->bpp);\n438             dst -= frame->linesize[0];\n439             src += avctx->width * s->bpp;\n440         }\n441     } else {\n442         unsigned block, nb_blocks;\n443         int type, k, l;\n444         uint8_t *ssrc, *ddst;\n445         const uint32_t *src;\n446         uint32_t *dst;\n447\n448         for (block = 0; block < s->nb_blocks; block++)\n449             s->blocks[block].xor = 0;\n450\n451         nb_blocks = bytestream2_get_le16(gb);\n452         if (nb_blocks > s->nb_blocks)\n453             return AVERROR_INVALIDDATA;\n454\n455         bytestream2_init_writer(pb, s->pbuffer, s->pbuffer_size);\n456\n457         type = bytestream2_get_le16(gb);\n458         for (block = 0; block < nb_blocks; block++) {\n459             unsigned size, offset;\n460             int start = 0;\n461\n462             offset = bytestream2_get_le16(gb);\n463             if (offset > s->nb_blocks)\n464                 return AVERROR_INVALIDDATA;\n465\n466             size = bytestream2_get_le16(gb);\n467             if (size > bytestream2_get_bytes_left(gb))\n468                 return AVERROR_INVALIDDATA;\n469\n470             start = bytestream2_tell_p(pb);\n471             if (type == 1) {\n472                 decode_type1(gb, pb);\n473             } else if (type == 2){\n474                 decode_type2(gb, pb);\n475             } else {\n476                 avpriv_report_missing_feature(avctx, \"Compression type %d\", type);\n477                 return AVERROR_PATCHWELCOME;\n478             }\n479\n480             if (s->blocks[offset].size * 4 != bytestream2_tell_p(pb) - start)\n481                 return AVERROR_INVALIDDATA;\n482\n483             s->blocks[offset].xor = 1;\n484         }\n485\n486         src = (const uint32_t *)s->pbuffer;\n487         dst = (uint32_t *)s->buffer;\n488\n489         for (block = 0, y = 0; y < s->yb; y++) {\n490             int block_h = s->blocks[block].h;\n491             uint32_t *rect = dst;\n492\n493             for (x = 0; x < s->xb; x++) {\n494                 int block_w = s->blocks[block].w;\n495                 uint32_t *row = dst;\n496\n497                 block_h = s->blocks[block].h;\n498                 if (s->blocks[block].xor) {\n499                     for (k = 0; k < block_h; k++) {\n500                         uint32_t *column = dst;\n501                         for (l = 0; l < block_w; l++)\n502                             *dst++ ^= *src++;\n503                         dst = &column[s->stride];\n504                     }\n505                 }\n506                 dst = &row[block_w];\n507                 ++block;\n508             }\n509             dst = &rect[block_h * s->stride];\n510         }\n511\n512         ssrc = s->buffer;\n513         ddst = frame->data[0] + (avctx->height - 1) * frame->linesize[0];\n514         for (y = 0; y < avctx->height; y++) {\n515             memcpy(ddst, ssrc, avctx->width * s->bpp);\n516             ddst -= frame->linesize[0];\n517             ssrc += avctx->width * s->bpp;\n518         }\n519     }\n520\n521     *got_frame = 1;\n522\n523     return avpkt->size;\n524 }"
                    }
                ]
            }
        ],
        "sink": "len =    (opcode >> 5)      - 1;",
        "final_sink": "len =    (opcode >> 5)      - 1;"
    },
    {
        "prt": "filtered_buf",
        "function_call": [
            "static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n                                   uint8_t **data, int *size)\n{\n    static const int extradata_nal_types_hevc[] = {\n        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n    };\n    static const int extradata_nal_types_h264[] = {\n        H264_NAL_SPS, H264_NAL_PPS,\n    };\n\n    ExtractExtradataContext *s = ctx->priv_data;\n\n    int extradata_size = 0, filtered_size = 0;\n    const int *extradata_nal_types;\n    int nb_extradata_nal_types;\n    int i, has_sps = 0, has_vps = 0, ret = 0;\n\n    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n        extradata_nal_types    = extradata_nal_types_hevc;\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n    } else {\n        extradata_nal_types    = extradata_nal_types_h264;\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n    }\n\n    ret = ff_h2645_packet_split(&s->h2645_pkt, pkt->data, pkt->size,\n                                ctx, 0, 0, ctx->par_in->codec_id);\n    if (ret < 0)\n        return ret;\n\n    for (i = 0; i < s->h2645_pkt.nb_nals; i++) {\n        H2645NAL *nal = &s->h2645_pkt.nals[i];\n        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n            extradata_size += nal->raw_size + 3;\n            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n                if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n                if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n            } else {\n                if (nal->type == H264_NAL_SPS) has_sps = 1;\n            }\n        } else if (s->remove) {\n            filtered_size += nal->raw_size + 3;\n        }\n    }\n\n    if (extradata_size &&\n        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n        AVBufferRef *filtered_buf;\n        uint8_t *extradata, *filtered_data;\n\n        if (s->remove) {\n            filtered_buf = av_buffer_alloc(filtered_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!filtered_buf) {\n                return AVERROR(ENOMEM);\n            }\n            memset(filtered_buf->data + filtered_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n            filtered_data = filtered_buf->data;\n        }\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!extradata) {\n            av_buffer_unref(&filtered_buf);\n            return AVERROR(ENOMEM);\n        }\n        memset(extradata + extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        *data = extradata;\n        *size = extradata_size;\n\n        for (i = 0; i < s->h2645_pkt.nb_nals; i++) {\n            H2645NAL *nal = &s->h2645_pkt.nals[i];\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n                             nal->type)) {\n                AV_WB24(extradata, 1); // startcode\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n                extradata += 3 + nal->raw_size;\n            } else if (s->remove) {\n                AV_WB24(filtered_data, 1); // startcode\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n                filtered_data += 3 + nal->raw_size;\n            }\n        }\n\n        if (s->remove) {\n            av_buffer_unref(&pkt->buf);\n            pkt->buf  = filtered_buf;\n            pkt->data = filtered_buf->data;\n            pkt->size = filtered_size;\n        }\n    }\n\n    return 0;\n}"
        ],
        "source": [
            "        AVBufferRef *filtered_buf;"
        ],
        "index": 33,
        "location": {
            "file_path": "libavcodec/extract_extradata_bsf.c",
            "region": {
                "startLine": 142,
                "startColumn": 13,
                "endColumn": 25
            },
            "context": {
                "startLine": 140,
                "endLine": 144,
                "snippet": {
                    "text": "pkt->buf  = filtered_buf;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/extract_extradata_bsf.c",
                        "function_body": "55  static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n56                                     uint8_t **data, int *size)\n57  {\n58      static const int extradata_nal_types_hevc[] = {\n59          HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n60      };\n61      static const int extradata_nal_types_h264[] = {\n62          H264_NAL_SPS, H264_NAL_PPS,\n63      };\n64\n65      ExtractExtradataContext *s = ctx->priv_data;\n66\n67      int extradata_size = 0, filtered_size = 0;\n68      const int *extradata_nal_types;\n69      int nb_extradata_nal_types;\n70      int i, has_sps = 0, has_vps = 0, ret = 0;\n71\n72      if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n73          extradata_nal_types    = extradata_nal_types_hevc;\n74          nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n75      } else {\n76          extradata_nal_types    = extradata_nal_types_h264;\n77          nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n78      }\n79\n80      ret = ff_h2645_packet_split(&s->h2645_pkt, pkt->data, pkt->size,\n81                                  ctx, 0, 0, ctx->par_in->codec_id);\n82      if (ret < 0)\n83          return ret;\n84\n85      for (i = 0; i < s->h2645_pkt.nb_nals; i++) {\n86          H2645NAL *nal = &s->h2645_pkt.nals[i];\n87          if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n88              extradata_size += nal->raw_size + 3;\n89              if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n90                  if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n91                  if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n92              } else {\n93                  if (nal->type == H264_NAL_SPS) has_sps = 1;\n94              }\n95          } else if (s->remove) {\n96              filtered_size += nal->raw_size + 3;\n97          }\n98      }\n99\n100     if (extradata_size &&\n101         ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n102          (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n103         AVBufferRef *filtered_buf;\n104         uint8_t *extradata, *filtered_data;\n105\n106         if (s->remove) {\n107             filtered_buf = av_buffer_alloc(filtered_size + AV_INPUT_BUFFER_PADDING_SIZE);\n108             if (!filtered_buf) {\n109                 return AVERROR(ENOMEM);\n110             }\n111             memset(filtered_buf->data + filtered_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n112\n113             filtered_data = filtered_buf->data;\n114         }\n115\n116         extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n117         if (!extradata) {\n118             av_buffer_unref(&filtered_buf);\n119             return AVERROR(ENOMEM);\n120         }\n121         memset(extradata + extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n122\n123         *data = extradata;\n124         *size = extradata_size;\n125\n126         for (i = 0; i < s->h2645_pkt.nb_nals; i++) {\n127             H2645NAL *nal = &s->h2645_pkt.nals[i];\n128             if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n129                              nal->type)) {\n130                 AV_WB24(extradata, 1); // startcode\n131                 memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n132                 extradata += 3 + nal->raw_size;\n133             } else if (s->remove) {\n134                 AV_WB24(filtered_data, 1); // startcode\n135                 memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n136                 filtered_data += 3 + nal->raw_size;\n137             }\n138         }\n139\n140         if (s->remove) {\n141             av_buffer_unref(&pkt->buf);\n142             pkt->buf  = filtered_buf;\n143             pkt->data = filtered_buf->data;\n144             pkt->size = filtered_size;\n145         }\n146     }\n147\n148     return 0;\n149 }"
                    }
                ]
            }
        ],
        "sink": "pkt->buf  = filtered_buf;",
        "final_sink": "pkt->buf  = filtered_buf;"
    },
    {
        "prt": "filtered_data",
        "function_call": [
            "static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n                                   uint8_t **data, int *size)\n{\n    static const int extradata_nal_types_hevc[] = {\n        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n    };\n    static const int extradata_nal_types_h264[] = {\n        H264_NAL_SPS, H264_NAL_PPS,\n    };\n\n    ExtractExtradataContext *s = ctx->priv_data;\n\n    int extradata_size = 0, filtered_size = 0;\n    const int *extradata_nal_types;\n    int nb_extradata_nal_types;\n    int i, has_sps = 0, has_vps = 0, ret = 0;\n\n    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n        extradata_nal_types    = extradata_nal_types_hevc;\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n    } else {\n        extradata_nal_types    = extradata_nal_types_h264;\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n    }\n\n    ret = ff_h2645_packet_split(&s->h2645_pkt, pkt->data, pkt->size,\n                                ctx, 0, 0, ctx->par_in->codec_id);\n    if (ret < 0)\n        return ret;\n\n    for (i = 0; i < s->h2645_pkt.nb_nals; i++) {\n        H2645NAL *nal = &s->h2645_pkt.nals[i];\n        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n            extradata_size += nal->raw_size + 3;\n            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n                if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n                if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n            } else {\n                if (nal->type == H264_NAL_SPS) has_sps = 1;\n            }\n        } else if (s->remove) {\n            filtered_size += nal->raw_size + 3;\n        }\n    }\n\n    if (extradata_size &&\n        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n        AVBufferRef *filtered_buf;\n        uint8_t *extradata, *filtered_data;\n\n        if (s->remove) {\n            filtered_buf = av_buffer_alloc(filtered_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!filtered_buf) {\n                return AVERROR(ENOMEM);\n            }\n            memset(filtered_buf->data + filtered_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n            filtered_data = filtered_buf->data;\n        }\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!extradata) {\n            av_buffer_unref(&filtered_buf);\n            return AVERROR(ENOMEM);\n        }\n        memset(extradata + extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        *data = extradata;\n        *size = extradata_size;\n\n        for (i = 0; i < s->h2645_pkt.nb_nals; i++) {\n            H2645NAL *nal = &s->h2645_pkt.nals[i];\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n                             nal->type)) {\n                AV_WB24(extradata, 1); // startcode\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n                extradata += 3 + nal->raw_size;\n            } else if (s->remove) {\n                AV_WB24(filtered_data, 1); // startcode\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n                filtered_data += 3 + nal->raw_size;\n            }\n        }\n\n        if (s->remove) {\n            av_buffer_unref(&pkt->buf);\n            pkt->buf  = filtered_buf;\n            pkt->data = filtered_buf->data;\n            pkt->size = filtered_size;\n        }\n    }\n\n    return 0;\n}"
        ],
        "source": [
            "        uint8_t *extradata, *filtered_data;"
        ],
        "index": 34,
        "location": {
            "file_path": "libavcodec/extract_extradata_bsf.c",
            "region": {
                "startLine": 136,
                "startColumn": 17,
                "endColumn": 30
            },
            "context": {
                "startLine": 134,
                "endLine": 138,
                "snippet": {
                    "text": "filtered_data += 3 + nal->raw_size;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/extract_extradata_bsf.c",
                        "function_body": "55  static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n56                                     uint8_t **data, int *size)\n57  {\n58      static const int extradata_nal_types_hevc[] = {\n59          HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n60      };\n61      static const int extradata_nal_types_h264[] = {\n62          H264_NAL_SPS, H264_NAL_PPS,\n63      };\n64\n65      ExtractExtradataContext *s = ctx->priv_data;\n66\n67      int extradata_size = 0, filtered_size = 0;\n68      const int *extradata_nal_types;\n69      int nb_extradata_nal_types;\n70      int i, has_sps = 0, has_vps = 0, ret = 0;\n71\n72      if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n73          extradata_nal_types    = extradata_nal_types_hevc;\n74          nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n75      } else {\n76          extradata_nal_types    = extradata_nal_types_h264;\n77          nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n78      }\n79\n80      ret = ff_h2645_packet_split(&s->h2645_pkt, pkt->data, pkt->size,\n81                                  ctx, 0, 0, ctx->par_in->codec_id);\n82      if (ret < 0)\n83          return ret;\n84\n85      for (i = 0; i < s->h2645_pkt.nb_nals; i++) {\n86          H2645NAL *nal = &s->h2645_pkt.nals[i];\n87          if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n88              extradata_size += nal->raw_size + 3;\n89              if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n90                  if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n91                  if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n92              } else {\n93                  if (nal->type == H264_NAL_SPS) has_sps = 1;\n94              }\n95          } else if (s->remove) {\n96              filtered_size += nal->raw_size + 3;\n97          }\n98      }\n99\n100     if (extradata_size &&\n101         ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n102          (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n103         AVBufferRef *filtered_buf;\n104         uint8_t *extradata, *filtered_data;\n105\n106         if (s->remove) {\n107             filtered_buf = av_buffer_alloc(filtered_size + AV_INPUT_BUFFER_PADDING_SIZE);\n108             if (!filtered_buf) {\n109                 return AVERROR(ENOMEM);\n110             }\n111             memset(filtered_buf->data + filtered_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n112\n113             filtered_data = filtered_buf->data;\n114         }\n115\n116         extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n117         if (!extradata) {\n118             av_buffer_unref(&filtered_buf);\n119             return AVERROR(ENOMEM);\n120         }\n121         memset(extradata + extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n122\n123         *data = extradata;\n124         *size = extradata_size;\n125\n126         for (i = 0; i < s->h2645_pkt.nb_nals; i++) {\n127             H2645NAL *nal = &s->h2645_pkt.nals[i];\n128             if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n129                              nal->type)) {\n130                 AV_WB24(extradata, 1); // startcode\n131                 memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n132                 extradata += 3 + nal->raw_size;\n133             } else if (s->remove) {\n134                 AV_WB24(filtered_data, 1); // startcode\n135                 memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n136                 filtered_data += 3 + nal->raw_size;\n137             }\n138         }\n139\n140         if (s->remove) {\n141             av_buffer_unref(&pkt->buf);\n142             pkt->buf  = filtered_buf;\n143             pkt->data = filtered_buf->data;\n144             pkt->size = filtered_size;\n145         }\n146     }\n147\n148     return 0;\n149 }"
                    }
                ]
            }
        ],
        "sink": "filtered_data += 3 + nal->raw_size;",
        "final_sink": "filtered_data += 3 + nal->raw_size;"
    },
    {
        "prt": "ret",
        "function_call": [
            "static int read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    CDGContext *priv = s->priv_data;\n    int ret;\n\n    while (1) {\n        ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n        if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n            break;\n        av_packet_unref(pkt);\n    }\n\n    if (!priv->got_first_packet) {\n        pkt->flags |= AV_PKT_FLAG_KEY;\n        priv->got_first_packet = 1;\n    }\n\n    pkt->stream_index = 0;\n    return ret;\n}"
        ],
        "source": [
            "    int ret;"
        ],
        "index": 35,
        "location": {
            "file_path": "libavformat/cdg.c",
            "region": {
                "startLine": 74,
                "startColumn": 5,
                "endColumn": 8
            },
            "context": {
                "startLine": 72,
                "endLine": 76,
                "snippet": {
                    "text": "return ret;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/cdg.c",
                        "function_body": "56 static int read_packet(AVFormatContext *s, AVPacket *pkt)\n57 {\n58     CDGContext *priv = s->priv_data;\n59     int ret;\n60\n61     while (1) {\n62         ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n63         if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n64             break;\n65         av_packet_unref(pkt);\n66     }\n67\n68     if (!priv->got_first_packet) {\n69         pkt->flags |= AV_PKT_FLAG_KEY;\n70         priv->got_first_packet = 1;\n71     }\n72\n73     pkt->stream_index = 0;\n74     return ret;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/mpegts.c",
                        "function_body": "2166 static int mpegts_raw_read_packet(AVFormatContext *s, AVPacket *pkt)\n2167 {\n2168     MpegTSContext *ts = s->priv_data;\n2169     int ret, i;\n2170     int64_t pcr_h, next_pcr_h, pos;\n2171     int pcr_l, next_pcr_l;\n2172     uint8_t pcr_buf[12];\n2173     const uint8_t *data;\n2174\n2175     if (av_new_packet(pkt, TS_PACKET_SIZE) < 0)\n2176         return AVERROR(ENOMEM);\n2177     ret = read_packet(s, pkt->data, ts->raw_packet_size, &data);\n2178     pkt->pos = avio_tell(s->pb);\n2179     if (ret < 0) {\n2180         av_packet_unref(pkt);\n2181         return ret;\n2182     }\n2183     if (data != pkt->data)\n2184         memcpy(pkt->data, data, ts->raw_packet_size);\n2185     finished_reading_packet(s, ts->raw_packet_size);\n2186     if (ts->mpeg2ts_compute_pcr) {\n2187         /* compute exact PCR for each packet */\n2188         if (parse_pcr(&pcr_h, &pcr_l, pkt->data) == 0) {\n2189             /* we read the next PCR (XXX: optimize it by using a bigger buffer */\n2190             pos = avio_tell(s->pb);\n2191             for (i = 0; i < MAX_PACKET_READAHEAD; i++) {\n2192                 avio_seek(s->pb, pos + i * ts->raw_packet_size, SEEK_SET);\n2193                 avio_read(s->pb, pcr_buf, 12);\n2194                 if (parse_pcr(&next_pcr_h, &next_pcr_l, pcr_buf) == 0) {\n2195                     /* XXX: not precise enough */\n2196                     ts->pcr_incr =\n2197                         ((next_pcr_h - pcr_h) * 300 + (next_pcr_l - pcr_l)) /\n2198                         (i + 1);\n2199                     break;\n2200                 }\n2201             }\n2202             avio_seek(s->pb, pos, SEEK_SET);\n2203             /* no next PCR found: we use previous increment */\n2204             ts->cur_pcr = pcr_h * 300 + pcr_l;\n2205         }\n2206         pkt->pts      = ts->cur_pcr;\n2207         pkt->duration = ts->pcr_incr;\n2208         ts->cur_pcr  += ts->pcr_incr;\n2209     }\n2210     pkt->stream_index = 0;\n2211     return 0;\n2212 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavformat/cdg.c",
                        "function_body": "56 static int read_packet(AVFormatContext *s, AVPacket *pkt)\n57 {\n58     CDGContext *priv = s->priv_data;\n59     int ret;\n60\n61     while (1) {\n62         ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n63         if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n64             break;\n65         av_packet_unref(pkt);\n66     }\n67\n68     if (!priv->got_first_packet) {\n69         pkt->flags |= AV_PKT_FLAG_KEY;\n70         priv->got_first_packet = 1;\n71     }\n72\n73     pkt->stream_index = 0;\n74     return ret;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/aviobuf.c",
                        "function_body": "557 int avio_read(AVIOContext *s, unsigned char *buf, int size)\n558 {\n559     int len, size1;\n560\n561     size1 = size;\n562     while (size > 0) {\n563         len = s->buf_end - s->buf_ptr;\n564         if (len > size)\n565             len = size;\n566         if (len == 0 || s->write_flag) {\n567             if(size > s->buffer_size && !s->update_checksum){\n568                 if(s->read_packet)\n569                     len = s->read_packet(s->opaque, buf, size);\n570                 if (len <= 0) {\n571                     /* do not modify buffer if EOF reached so that a seek back can\n572                     be done without rereading data */\n573                     s->eof_reached = 1;\n574                     if(len<0)\n575                         s->error= len;\n576                     break;\n577                 } else {\n578                     s->pos += len;\n579                     size -= len;\n580                     buf += len;\n581                     s->buf_ptr = s->buffer;\n582                     s->buf_end = s->buffer/* + len*/;\n583                 }\n584             } else {\n585                 fill_buffer(s);\n586                 len = s->buf_end - s->buf_ptr;\n587                 if (len == 0)\n588                     break;\n589             }\n590         } else {\n591             memcpy(buf, s->buf_ptr, len);\n592             buf += len;\n593             s->buf_ptr += len;\n594             size -= len;\n595         }\n596     }\n597     if (size1 == size) {\n598         if (s->error)         return s->error;\n599         if (s->eof_reached)   return AVERROR_EOF;\n600     }\n601     return size1 - size;\n602 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavformat/cdg.c",
                        "function_body": "56 static int read_packet(AVFormatContext *s, AVPacket *pkt)\n57 {\n58     CDGContext *priv = s->priv_data;\n59     int ret;\n60\n61     while (1) {\n62         ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n63         if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n64             break;\n65         av_packet_unref(pkt);\n66     }\n67\n68     if (!priv->got_first_packet) {\n69         pkt->flags |= AV_PKT_FLAG_KEY;\n70         priv->got_first_packet = 1;\n71     }\n72\n73     pkt->stream_index = 0;\n74     return ret;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/mpegts.c",
                        "function_body": "2067 static int mpegts_read_header(AVFormatContext *s)\n2068 {\n2069     MpegTSContext *ts = s->priv_data;\n2070     AVIOContext *pb   = s->pb;\n2071     uint8_t buf[5 * 1024];\n2072     int len;\n2073     int64_t pos;\n2074\n2075     /* read the first 1024 bytes to get packet size */\n2076     pos = avio_tell(pb);\n2077     len = avio_read(pb, buf, sizeof(buf));\n2078     if (len < 0)\n2079         return len;\n2080     if (len != sizeof(buf))\n2081         return AVERROR_BUG;\n2082     ts->raw_packet_size = get_packet_size(buf, sizeof(buf));\n2083     if (ts->raw_packet_size <= 0)\n2084         return AVERROR_INVALIDDATA;\n2085     ts->stream     = s;\n2086     ts->auto_guess = 0;\n2087\n2088     if (s->iformat == &ff_mpegts_demuxer) {\n2089         /* normal demux */\n2090\n2091         /* first do a scan to get all the services */\n2092         if (avio_seek(pb, pos, SEEK_SET) < 0 &&\n2093             (pb->seekable & AVIO_SEEKABLE_NORMAL))\n2094             av_log(s, AV_LOG_ERROR, \"Unable to seek back to the start\\n\");\n2095\n2096         mpegts_open_section_filter(ts, SDT_PID, sdt_cb, ts, 1);\n2097\n2098         mpegts_open_section_filter(ts, PAT_PID, pat_cb, ts, 1);\n2099\n2100         handle_packets(ts, s->probesize / ts->raw_packet_size);\n2101         /* if could not find service, enable auto_guess */\n2102\n2103         ts->auto_guess = 1;\n2104\n2105         av_log(ts->stream, AV_LOG_TRACE, \"tuning done\\n\");\n2106\n2107         s->ctx_flags |= AVFMTCTX_NOHEADER;\n2108     } else {\n2109         AVStream *st;\n2110         int pcr_pid, pid, nb_packets, nb_pcrs, ret, pcr_l;\n2111         int64_t pcrs[2], pcr_h;\n2112         int packet_count[2];\n2113         uint8_t packet[TS_PACKET_SIZE];\n2114         const uint8_t *data;\n2115\n2116         /* only read packets */\n2117\n2118         st = avformat_new_stream(s, NULL);\n2119         if (!st)\n2120             return AVERROR(ENOMEM);\n2121         avpriv_set_pts_info(st, 60, 1, 27000000);\n2122         st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n2123         st->codecpar->codec_id   = AV_CODEC_ID_MPEG2TS;\n2124\n2125         /* we iterate until we find two PCRs to estimate the bitrate */\n2126         pcr_pid    = -1;\n2127         nb_pcrs    = 0;\n2128         nb_packets = 0;\n2129         for (;;) {\n2130             ret = read_packet(s, packet, ts->raw_packet_size, &data);\n2131             if (ret < 0)\n2132                 return ret;\n2133             pid = AV_RB16(data + 1) & 0x1fff;\n2134             if ((pcr_pid == -1 || pcr_pid == pid) &&\n2135                 parse_pcr(&pcr_h, &pcr_l, data) == 0) {\n2136                 finished_reading_packet(s, ts->raw_packet_size);\n2137                 pcr_pid = pid;\n2138                 packet_count[nb_pcrs] = nb_packets;\n2139                 pcrs[nb_pcrs] = pcr_h * 300 + pcr_l;\n2140                 nb_pcrs++;\n2141                 if (nb_pcrs >= 2)\n2142                     break;\n2143             } else {\n2144                 finished_reading_packet(s, ts->raw_packet_size);\n2145             }\n2146             nb_packets++;\n2147         }\n2148\n2149         /* NOTE1: the bitrate is computed without the FEC */\n2150         /* NOTE2: it is only the bitrate of the start of the stream */\n2151         ts->pcr_incr = (pcrs[1] - pcrs[0]) / (packet_count[1] - packet_count[0]);\n2152         ts->cur_pcr  = pcrs[0] - ts->pcr_incr * packet_count[0];\n2153         s->bit_rate  = TS_PACKET_SIZE * 8 * 27e6 / ts->pcr_incr;\n2154         st->codecpar->bit_rate = s->bit_rate;\n2155         st->start_time      = ts->cur_pcr;\n2156         av_log(ts->stream, AV_LOG_TRACE, \"start=%0.3f pcr=%0.3f incr=%d\\n\",\n2157                 st->start_time / 1000000.0, pcrs[0] / 27e6, ts->pcr_incr);\n2158     }\n2159\n2160     avio_seek(pb, pos, SEEK_SET);\n2161     return 0;\n2162 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavformat/cdg.c",
                        "function_body": "56 static int read_packet(AVFormatContext *s, AVPacket *pkt)\n57 {\n58     CDGContext *priv = s->priv_data;\n59     int ret;\n60\n61     while (1) {\n62         ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n63         if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n64             break;\n65         av_packet_unref(pkt);\n66     }\n67\n68     if (!priv->got_first_packet) {\n69         pkt->flags |= AV_PKT_FLAG_KEY;\n70         priv->got_first_packet = 1;\n71     }\n72\n73     pkt->stream_index = 0;\n74     return ret;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/mpegts.c",
                        "function_body": "1963 static int handle_packets(MpegTSContext *ts, int nb_packets)\n1964 {\n1965     AVFormatContext *s = ts->stream;\n1966     uint8_t packet[TS_PACKET_SIZE + AV_INPUT_BUFFER_PADDING_SIZE];\n1967     const uint8_t *data;\n1968     int packet_num, ret = 0;\n1969\n1970     if (avio_tell(s->pb) != ts->last_pos) {\n1971         int i;\n1972         av_log(ts->stream, AV_LOG_TRACE, \"Skipping after seek\\n\");\n1973         /* seek detected, flush pes buffer */\n1974         for (i = 0; i < NB_PID_MAX; i++) {\n1975             if (ts->pids[i]) {\n1976                 if (ts->pids[i]->type == MPEGTS_PES) {\n1977                     PESContext *pes = ts->pids[i]->u.pes_filter.opaque;\n1978                     av_buffer_unref(&pes->buffer);\n1979                     pes->data_index = 0;\n1980                     pes->state = MPEGTS_SKIP; /* skip until pes header */\n1981                 }\n1982                 ts->pids[i]->last_cc = -1;\n1983             }\n1984         }\n1985     }\n1986\n1987     ts->stop_parse = 0;\n1988     packet_num = 0;\n1989     memset(packet + TS_PACKET_SIZE, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n1990     for (;;) {\n1991         if (ts->stop_parse > 0)\n1992             break;\n1993         packet_num++;\n1994         if (nb_packets != 0 && packet_num >= nb_packets)\n1995             break;\n1996         ret = read_packet(s, packet, ts->raw_packet_size, &data);\n1997         if (ret != 0)\n1998             break;\n1999         ret = handle_packet(ts, data);\n2000         finished_reading_packet(s, ts->raw_packet_size);\n2001         if (ret != 0)\n2002             break;\n2003     }\n2004     ts->last_pos = avio_tell(s->pb);\n2005     return ret;\n2006 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavformat/cdg.c",
                        "function_body": "56 static int read_packet(AVFormatContext *s, AVPacket *pkt)\n57 {\n58     CDGContext *priv = s->priv_data;\n59     int ret;\n60\n61     while (1) {\n62         ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n63         if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n64             break;\n65         av_packet_unref(pkt);\n66     }\n67\n68     if (!priv->got_first_packet) {\n69         pkt->flags |= AV_PKT_FLAG_KEY;\n70         priv->got_first_packet = 1;\n71     }\n72\n73     pkt->stream_index = 0;\n74     return ret;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/aviobuf.c",
                        "function_body": "624 int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)\n625 {\n626     int len;\n627\n628     if (size < 0)\n629         return -1;\n630\n631     if (s->read_packet && s->write_flag) {\n632         len = s->read_packet(s->opaque, buf, size);\n633         if (len > 0)\n634             s->pos += len;\n635         return len;\n636     }\n637\n638     len = s->buf_end - s->buf_ptr;\n639     if (len == 0) {\n640         /* Reset the buf_end pointer to the start of the buffer, to make sure\n641          * the fill_buffer call tries to read as much data as fits into the\n642          * full buffer, instead of just what space is left after buf_end.\n643          * This avoids returning partial packets at the end of the buffer,\n644          * for packet based inputs.\n645          */\n646         s->buf_end = s->buf_ptr = s->buffer;\n647         fill_buffer(s);\n648         len = s->buf_end - s->buf_ptr;\n649     }\n650     if (len > size)\n651         len = size;\n652     memcpy(buf, s->buf_ptr, len);\n653     s->buf_ptr += len;\n654     if (!len) {\n655         if (s->error)         return s->error;\n656         if (s->eof_reached)   return AVERROR_EOF;\n657     }\n658     return len;\n659 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavformat/cdg.c",
                        "function_body": "56 static int read_packet(AVFormatContext *s, AVPacket *pkt)\n57 {\n58     CDGContext *priv = s->priv_data;\n59     int ret;\n60\n61     while (1) {\n62         ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n63         if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n64             break;\n65         av_packet_unref(pkt);\n66     }\n67\n68     if (!priv->got_first_packet) {\n69         pkt->flags |= AV_PKT_FLAG_KEY;\n70         priv->got_first_packet = 1;\n71     }\n72\n73     pkt->stream_index = 0;\n74     return ret;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/rtsp.c",
                        "function_body": "2098 int ff_rtsp_fetch_packet(AVFormatContext *s, AVPacket *pkt)\n2099 {\n2100     RTSPState *rt = s->priv_data;\n2101     int ret, len;\n2102     RTSPStream *rtsp_st, *first_queue_st = NULL;\n2103     int64_t wait_end = 0;\n2104\n2105     if (rt->nb_byes == rt->nb_rtsp_streams)\n2106         return AVERROR_EOF;\n2107\n2108     /* get next frames from the same RTP packet */\n2109     if (rt->cur_transport_priv) {\n2110         if (rt->transport == RTSP_TRANSPORT_RDT) {\n2111             ret = ff_rdt_parse_packet(rt->cur_transport_priv, pkt, NULL, 0);\n2112         } else if (rt->transport == RTSP_TRANSPORT_RTP) {\n2113             ret = ff_rtp_parse_packet(rt->cur_transport_priv, pkt, NULL, 0);\n2114         } else if (CONFIG_RTPDEC && rt->ts) {\n2115             ret = ff_mpegts_parse_packet(rt->ts, pkt, rt->recvbuf + rt->recvbuf_pos, rt->recvbuf_len - rt->recvbuf_pos);\n2116             if (ret >= 0) {\n2117                 rt->recvbuf_pos += ret;\n2118                 ret = rt->recvbuf_pos < rt->recvbuf_len;\n2119             }\n2120         } else\n2121             ret = -1;\n2122         if (ret == 0) {\n2123             rt->cur_transport_priv = NULL;\n2124             return 0;\n2125         } else if (ret == 1) {\n2126             return 0;\n2127         } else\n2128             rt->cur_transport_priv = NULL;\n2129     }\n2130\n2131 redo:\n2132     if (rt->transport == RTSP_TRANSPORT_RTP) {\n2133         int i;\n2134         int64_t first_queue_time = 0;\n2135         for (i = 0; i < rt->nb_rtsp_streams; i++) {\n2136             RTPDemuxContext *rtpctx = rt->rtsp_streams[i]->transport_priv;\n2137             int64_t queue_time;\n2138             if (!rtpctx)\n2139                 continue;\n2140             queue_time = ff_rtp_queued_packet_time(rtpctx);\n2141             if (queue_time && (queue_time - first_queue_time < 0 ||\n2142                                !first_queue_time)) {\n2143                 first_queue_time = queue_time;\n2144                 first_queue_st   = rt->rtsp_streams[i];\n2145             }\n2146         }\n2147         if (first_queue_time) {\n2148             wait_end = first_queue_time + s->max_delay;\n2149         } else {\n2150             wait_end = 0;\n2151             first_queue_st = NULL;\n2152         }\n2153     }\n2154\n2155     /* read next RTP packet */\n2156     if (!rt->recvbuf) {\n2157         rt->recvbuf = av_malloc(RECVBUF_SIZE);\n2158         if (!rt->recvbuf)\n2159             return AVERROR(ENOMEM);\n2160     }\n2161\n2162     len = read_packet(s, &rtsp_st, first_queue_st, wait_end);\n2163     if (len == AVERROR(EAGAIN) && first_queue_st &&\n2164         rt->transport == RTSP_TRANSPORT_RTP) {\n2165         av_log(s, AV_LOG_WARNING,\n2166                 \"max delay reached. need to consume packet\\n\");\n2167         rtsp_st = first_queue_st;\n2168         ret = ff_rtp_parse_packet(rtsp_st->transport_priv, pkt, NULL, 0);\n2169         goto end;\n2170     }\n2171     if (len < 0)\n2172         return len;\n2173\n2174     if (rt->transport == RTSP_TRANSPORT_RDT) {\n2175         ret = ff_rdt_parse_packet(rtsp_st->transport_priv, pkt, &rt->recvbuf, len);\n2176     } else if (rt->transport == RTSP_TRANSPORT_RTP) {\n2177         ret = ff_rtp_parse_packet(rtsp_st->transport_priv, pkt, &rt->recvbuf, len);\n2178         if (rtsp_st->feedback) {\n2179             AVIOContext *pb = NULL;\n2180             if (rt->lower_transport == RTSP_LOWER_TRANSPORT_CUSTOM)\n2181                 pb = s->pb;\n2182             ff_rtp_send_rtcp_feedback(rtsp_st->transport_priv, rtsp_st->rtp_handle, pb);\n2183         }\n2184         if (ret < 0) {\n2185             /* Either bad packet, or a RTCP packet. Check if the\n2186              * first_rtcp_ntp_time field was initialized. */\n2187             RTPDemuxContext *rtpctx = rtsp_st->transport_priv;\n2188             if (rtpctx->first_rtcp_ntp_time != AV_NOPTS_VALUE) {\n2189                 /* first_rtcp_ntp_time has been initialized for this stream,\n2190                  * copy the same value to all other uninitialized streams,\n2191                  * in order to map their timestamp origin to the same ntp time\n2192                  * as this one. */\n2193                 int i;\n2194                 AVStream *st = NULL;\n2195                 if (rtsp_st->stream_index >= 0)\n2196                     st = s->streams[rtsp_st->stream_index];\n2197                 for (i = 0; i < rt->nb_rtsp_streams; i++) {\n2198                     RTPDemuxContext *rtpctx2 = rt->rtsp_streams[i]->transport_priv;\n2199                     AVStream *st2 = NULL;\n2200                     if (rt->rtsp_streams[i]->stream_index >= 0)\n2201                         st2 = s->streams[rt->rtsp_streams[i]->stream_index];\n2202                     if (rtpctx2 && st && st2 &&\n2203                         rtpctx2->first_rtcp_ntp_time == AV_NOPTS_VALUE) {\n2204                         rtpctx2->first_rtcp_ntp_time = rtpctx->first_rtcp_ntp_time;\n2205                         rtpctx2->rtcp_ts_offset = av_rescale_q(\n2206                             rtpctx->rtcp_ts_offset, st->time_base,\n2207                             st2->time_base);\n2208                     }\n2209                 }\n2210             }\n2211             if (ret == -RTCP_BYE) {\n2212                 rt->nb_byes++;\n2213\n2214                 av_log(s, AV_LOG_DEBUG, \"Received BYE for stream %d (%d/%d)\\n\",\n2215                        rtsp_st->stream_index, rt->nb_byes, rt->nb_rtsp_streams);\n2216\n2217                 if (rt->nb_byes == rt->nb_rtsp_streams)\n2218                     return AVERROR_EOF;\n2219             }\n2220         }\n2221     } else if (CONFIG_RTPDEC && rt->ts) {\n2222         ret = ff_mpegts_parse_packet(rt->ts, pkt, rt->recvbuf, len);\n2223         if (ret >= 0) {\n2224             if (ret < len) {\n2225                 rt->recvbuf_len = len;\n2226                 rt->recvbuf_pos = ret;\n2227                 rt->cur_transport_priv = rt->ts;\n2228                 return 1;\n2229             } else {\n2230                 ret = 0;\n2231             }\n2232         }\n2233     } else {\n2234         return AVERROR_INVALIDDATA;\n2235     }\n2236 end:\n2237     if (ret < 0)\n2238         goto redo;\n2239     if (ret == 1)\n2240         /* more packets may follow, so we save the RTP context */\n2241         rt->cur_transport_priv = rtsp_st->transport_priv;\n2242\n2243     return ret;\n2244 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavformat/cdg.c",
                        "function_body": "56 static int read_packet(AVFormatContext *s, AVPacket *pkt)\n57 {\n58     CDGContext *priv = s->priv_data;\n59     int ret;\n60\n61     while (1) {\n62         ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n63         if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n64             break;\n65         av_packet_unref(pkt);\n66     }\n67\n68     if (!priv->got_first_packet) {\n69         pkt->flags |= AV_PKT_FLAG_KEY;\n70         priv->got_first_packet = 1;\n71     }\n72\n73     pkt->stream_index = 0;\n74     return ret;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/utils.c",
                        "function_body": "416 int ff_read_packet(AVFormatContext *s, AVPacket *pkt)\n417 {\n418     int ret, i, err;\n419     AVStream *st;\n420\n421     for (;;) {\n422         AVPacketList *pktl = s->internal->raw_packet_buffer;\n423\n424         if (pktl) {\n425             *pkt = pktl->pkt;\n426             st   = s->streams[pkt->stream_index];\n427             if (st->codecpar->codec_id != AV_CODEC_ID_PROBE ||\n428                 !st->probe_packets ||\n429                 s->internal->raw_packet_buffer_remaining_size < pkt->size) {\n430                 AVProbeData *pd;\n431                 if (st->probe_packets)\n432                     if ((err = probe_codec(s, st, NULL)) < 0)\n433                         return err;\n434                 pd = &st->probe_data;\n435                 av_freep(&pd->buf);\n436                 pd->buf_size = 0;\n437                 s->internal->raw_packet_buffer                 = pktl->next;\n438                 s->internal->raw_packet_buffer_remaining_size += pkt->size;\n439                 av_free(pktl);\n440                 return 0;\n441             }\n442         }\n443\n444         pkt->data = NULL;\n445         pkt->size = 0;\n446         av_init_packet(pkt);\n447         ret = s->iformat->read_packet(s, pkt);\n448         if (ret < 0) {\n449             if (!pktl || ret == AVERROR(EAGAIN))\n450                 return ret;\n451             for (i = 0; i < s->nb_streams; i++) {\n452                 st = s->streams[i];\n453                 if (st->probe_packets)\n454                     if ((err = probe_codec(s, st, NULL)) < 0)\n455                         return err;\n456             }\n457             continue;\n458         }\n459\n460         if (!pkt->buf) {\n461             AVPacket tmp = { 0 };\n462             ret = av_packet_ref(&tmp, pkt);\n463             if (ret < 0)\n464                 return ret;\n465             *pkt = tmp;\n466         }\n467\n468         if ((s->flags & AVFMT_FLAG_DISCARD_CORRUPT) &&\n469             (pkt->flags & AV_PKT_FLAG_CORRUPT)) {\n470             av_log(s, AV_LOG_WARNING,\n471                    \"Dropped corrupted packet (stream = %d)\\n\",\n472                    pkt->stream_index);\n473             av_packet_unref(pkt);\n474             continue;\n475         }\n476\n477         st = s->streams[pkt->stream_index];\n478\n479         switch (st->codecpar->codec_type) {\n480         case AVMEDIA_TYPE_VIDEO:\n481             if (s->video_codec_id)\n482                 st->codecpar->codec_id = s->video_codec_id;\n483             break;\n484         case AVMEDIA_TYPE_AUDIO:\n485             if (s->audio_codec_id)\n486                 st->codecpar->codec_id = s->audio_codec_id;\n487             break;\n488         case AVMEDIA_TYPE_SUBTITLE:\n489             if (s->subtitle_codec_id)\n490                 st->codecpar->codec_id = s->subtitle_codec_id;\n491             break;\n492         }\n493\n494         if (!pktl && (st->codecpar->codec_id != AV_CODEC_ID_PROBE ||\n495                       !st->probe_packets))\n496             return ret;\n497\n498         err = add_to_pktbuf(&s->internal->raw_packet_buffer, pkt,\n499                             &s->internal->raw_packet_buffer_end, 0);\n500         if (err)\n501             return err;\n502         s->internal->raw_packet_buffer_remaining_size -= pkt->size;\n503\n504         if ((err = probe_codec(s, st, pkt)) < 0)\n505             return err;\n506     }\n507 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavformat/cdg.c",
                        "function_body": "56 static int read_packet(AVFormatContext *s, AVPacket *pkt)\n57 {\n58     CDGContext *priv = s->priv_data;\n59     int ret;\n60\n61     while (1) {\n62         ret = av_get_packet(s->pb, pkt, CDG_PACKET_SIZE);\n63         if (ret < 1 || (pkt->data[0] & CDG_MASK) == CDG_COMMAND)\n64             break;\n65         av_packet_unref(pkt);\n66     }\n67\n68     if (!priv->got_first_packet) {\n69         pkt->flags |= AV_PKT_FLAG_KEY;\n70         priv->got_first_packet = 1;\n71     }\n72\n73     pkt->stream_index = 0;\n74     return ret;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/aviobuf.c",
                        "function_body": "467 static void fill_buffer(AVIOContext *s)\n468 {\n469     uint8_t *dst        = !s->max_packet_size &&\n470                           s->buf_end - s->buffer < s->buffer_size ?\n471                           s->buf_end : s->buffer;\n472     int len             = s->buffer_size - (dst - s->buffer);\n473     int max_buffer_size = s->max_packet_size ?\n474                           s->max_packet_size : IO_BUFFER_SIZE;\n475\n476     /* can't fill the buffer without read_packet, just set EOF if appropriate */\n477     if (!s->read_packet && s->buf_ptr >= s->buf_end)\n478         s->eof_reached = 1;\n479\n480     /* no need to do anything if EOF already reached */\n481     if (s->eof_reached)\n482         return;\n483\n484     if (s->update_checksum && dst == s->buffer) {\n485         if (s->buf_end > s->checksum_ptr)\n486             s->checksum = s->update_checksum(s->checksum, s->checksum_ptr,\n487                                              s->buf_end - s->checksum_ptr);\n488         s->checksum_ptr = s->buffer;\n489     }\n490\n491     /* make buffer smaller in case it ended up large after probing */\n492     if (s->buffer_size > max_buffer_size) {\n493         ffio_set_buf_size(s, max_buffer_size);\n494\n495         s->checksum_ptr = dst = s->buffer;\n496         len = s->buffer_size;\n497     }\n498\n499     if (s->read_packet)\n500         len = s->read_packet(s->opaque, dst, len);\n501     else\n502         len = 0;\n503     if (len <= 0) {\n504         /* do not modify buffer if EOF reached so that a seek back can\n505            be done without rereading data */\n506         s->eof_reached = 1;\n507         if (len < 0)\n508             s->error = len;\n509     } else {\n510         s->pos += len;\n511         s->buf_ptr = dst;\n512         s->buf_end = dst + len;\n513     }\n514 }"
                    }
                ]
            }
        ],
        "sink": "return ret;",
        "final_sink": "return ret;"
    },
    {
        "prt": "size",
        "function_call": [
            "static int64_t find_tag(AVIOContext *pb, uint32_t tag1)\n{\n    unsigned int tag;\n    int64_t size;\n\n    for (;;) {\n        if (pb->eof_reached)\n            return -1;\n        size = next_tag(pb, &tag);\n        if (tag == tag1)\n            break;\n        wav_seek_tag(pb, size, SEEK_CUR);\n    }\n    return size;\n}"
        ],
        "source": [
            "    int64_t size;"
        ],
        "index": 36,
        "location": {
            "file_path": "libavformat/wavdec.c",
            "region": {
                "startLine": 74,
                "startColumn": 5,
                "endColumn": 9
            },
            "context": {
                "startLine": 72,
                "endLine": 76,
                "snippet": {
                    "text": "return size;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/wavdec.c",
                        "function_body": "61 static int64_t find_tag(AVIOContext *pb, uint32_t tag1)\n62 {\n63     unsigned int tag;\n64     int64_t size;\n65\n66     for (;;) {\n67         if (pb->eof_reached)\n68             return -1;\n69         size = next_tag(pb, &tag);\n70         if (tag == tag1)\n71             break;\n72         wav_seek_tag(pb, size, SEEK_CUR);\n73     }\n74     return size;\n75 }"
                    },
                    {
                        "file_path": "/libavformat/wavdec.c",
                        "function_body": "373 static int wav_read_packet(AVFormatContext *s, AVPacket *pkt)\n374 {\n375     int ret, size;\n376     int64_t left;\n377     AVStream *st;\n378     WAVDemuxContext *wav = s->priv_data;\n379\n380     st = s->streams[0];\n381\n382     left = wav->data_end - avio_tell(s->pb);\n383     if (left <= 0) {\n384         if (CONFIG_W64_DEMUXER && wav->w64)\n385             left = find_guid(s->pb, guid_data) - 24;\n386         else\n387             left = find_tag(s->pb, MKTAG('d', 'a', 't', 'a'));\n388         if (left < 0)\n389             return AVERROR_EOF;\n390         wav->data_end = avio_tell(s->pb) + left;\n391     }\n392\n393     size = MAX_SIZE;\n394     if (st->codecpar->block_align > 1) {\n395         if (size < st->codecpar->block_align)\n396             size = st->codecpar->block_align;\n397         size = (size / st->codecpar->block_align) * st->codecpar->block_align;\n398     }\n399     size = FFMIN(size, left);\n400     ret  = av_get_packet(s->pb, pkt, size);\n401     if (ret < 0)\n402         return ret;\n403     pkt->stream_index = 0;\n404\n405     return ret;\n406 }"
                    }
                ]
            }
        ],
        "sink": "return size;",
        "final_sink": "return size;"
    },
    {
        "prt": "c",
        "function_call": [
            "static void x8_setup_spatial_compensation(uint8_t *src, uint8_t *dst,\n                                          ptrdiff_t stride, int *range,\n                                          int *psum, int edges)\n{\n    uint8_t *ptr;\n    int sum;\n    int i;\n    int min_pix, max_pix;\n    uint8_t c;\n\n    if ((edges & 3) == 3) {\n        *psum  = 0x80 * (8 + 1 + 8 + 2);\n        *range = 0;\n        memset(dst, 0x80, 16 + 1 + 16 + 8);\n        /* this triggers flat_dc for sure. flat_dc avoids all (other)\n         * prediction modes, but requires dc_level decoding. */\n        return;\n    }\n\n    min_pix = 256;\n    max_pix = -1;\n\n    sum = 0;\n\n    if (!(edges & 1)) { // (mb_x != 0) // there is previous block on this row\n        ptr = src - 1; // left column, area 2\n        for (i = 7; i >= 0; i--) {\n            c              = *(ptr - 1); // area1, same mb as area2, no need to check\n            dst[area1 + i] = c;\n            c              = *ptr;\n\n            sum           += c;\n            min_pix        = FFMIN(min_pix, c);\n            max_pix        = FFMAX(max_pix, c);\n            dst[area2 + i] = c;\n\n            ptr += stride;\n        }\n    }\n\n    if (!(edges & 2)) { // (mb_y != 0) // there is row above\n        ptr = src - stride; // top line\n        for (i = 0; i < 8; i++) {\n            c       = *(ptr + i);\n            sum    += c;\n            min_pix = FFMIN(min_pix, c);\n            max_pix = FFMAX(max_pix, c);\n        }\n        if (edges & 4) { // last block on the row?\n            memset(dst + area5, c, 8); // set with last pixel fr\n            memcpy(dst + area4, ptr, 8);\n        } else {\n            memcpy(dst + area4, ptr, 16); // both area4 and 5\n        }\n        // area6 always present in the above block\n        memcpy(dst + area6, ptr - stride, 8);\n    }\n    // now calculate the stuff we need\n    if (edges & 3) { // mb_x ==0 || mb_y == 0) {\n        int avg = (sum + 4) >> 3;\n\n        if (edges & 1) // (mb_x == 0) { // implies mb_y !=0\n            memset(dst + area1, avg, 8 + 8 + 1); // areas 1, 2, 3 are averaged\n        else // implies y == 0 x != 0\n            memset(dst + area3, avg, 1 + 16 + 8); // areas 3, 4, 5, 6\n\n        sum += avg * 9;\n    } else {\n        // the edge pixel, in the top line and left column\n        uint8_t c = *(src - 1 - stride);\n        dst[area3] = c;\n        sum       += c;\n        // edge pixel is not part of min/max\n    }\n    *range = max_pix - min_pix;\n    sum   += *(dst + area5) + *(dst + area5 + 1);\n    *psum  = sum;\n}"
        ],
        "source": [
            "    uint8_t c;"
        ],
        "index": 37,
        "location": {
            "file_path": "libavcodec/intrax8dsp.c",
            "region": {
                "startLine": 114,
                "startColumn": 13,
                "endColumn": 14
            },
            "context": {
                "startLine": 112,
                "endLine": 116,
                "snippet": {
                    "text": "memset(dst + area5, c, 8); // set with last pixel fr"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/intrax8dsp.c",
                        "function_body": "47 #define area5 (8 + 8 + 1 + 8)"
                    },
                    {
                        "file_path": "/libavcodec/intrax8dsp.c",
                        "function_body": "65  static void x8_setup_spatial_compensation(uint8_t *src, uint8_t *dst,\n66                                            ptrdiff_t stride, int *range,\n67                                            int *psum, int edges)\n68  {\n69      uint8_t *ptr;\n70      int sum;\n71      int i;\n72      int min_pix, max_pix;\n73      uint8_t c;\n74\n75      if ((edges & 3) == 3) {\n76          *psum  = 0x80 * (8 + 1 + 8 + 2);\n77          *range = 0;\n78          memset(dst, 0x80, 16 + 1 + 16 + 8);\n79          /* this triggers flat_dc for sure. flat_dc avoids all (other)\n80           * prediction modes, but requires dc_level decoding. */\n81          return;\n82      }\n83\n84      min_pix = 256;\n85      max_pix = -1;\n86\n87      sum = 0;\n88\n89      if (!(edges & 1)) { // (mb_x != 0) // there is previous block on this row\n90          ptr = src - 1; // left column, area 2\n91          for (i = 7; i >= 0; i--) {\n92              c              = *(ptr - 1); // area1, same mb as area2, no need to check\n93              dst[area1 + i] = c;\n94              c              = *ptr;\n95\n96              sum           += c;\n97              min_pix        = FFMIN(min_pix, c);\n98              max_pix        = FFMAX(max_pix, c);\n99              dst[area2 + i] = c;\n100\n101             ptr += stride;\n102         }\n103     }\n104\n105     if (!(edges & 2)) { // (mb_y != 0) // there is row above\n106         ptr = src - stride; // top line\n107         for (i = 0; i < 8; i++) {\n108             c       = *(ptr + i);\n109             sum    += c;\n110             min_pix = FFMIN(min_pix, c);\n111             max_pix = FFMAX(max_pix, c);\n112         }\n113         if (edges & 4) { // last block on the row?\n114             memset(dst + area5, c, 8); // set with last pixel fr\n115             memcpy(dst + area4, ptr, 8);\n116         } else {\n117             memcpy(dst + area4, ptr, 16); // both area4 and 5\n118         }\n119         // area6 always present in the above block\n120         memcpy(dst + area6, ptr - stride, 8);\n121     }\n122     // now calculate the stuff we need\n123     if (edges & 3) { // mb_x ==0 || mb_y == 0) {\n124         int avg = (sum + 4) >> 3;\n125\n126         if (edges & 1) // (mb_x == 0) { // implies mb_y !=0\n127             memset(dst + area1, avg, 8 + 8 + 1); // areas 1, 2, 3 are averaged\n128         else // implies y == 0 x != 0\n129             memset(dst + area3, avg, 1 + 16 + 8); // areas 3, 4, 5, 6\n130\n131         sum += avg * 9;\n132     } else {\n133         // the edge pixel, in the top line and left column\n134         uint8_t c = *(src - 1 - stride);\n135         dst[area3] = c;\n136         sum       += c;\n137         // edge pixel is not part of min/max\n138     }\n139     *range = max_pix - min_pix;\n140     sum   += *(dst + area5) + *(dst + area5 + 1);\n141     *psum  = sum;\n142 }"
                    }
                ]
            }
        ],
        "sink": "memset(dst + area5, c, 8); // set with last pixel fr",
        "final_sink": "memset(dst + area5, c, 8); // set with last pixel fr"
    },
    {
        "prt": "next",
        "function_call": [
            "enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n{\n    enum AVHWDeviceType next;\n    int i, set = 0;\n    for (i = 0; hw_table[i]; i++) {\n        if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n            continue;\n        if (!set || hw_table[i]->type < next) {\n            next = hw_table[i]->type;\n            set = 1;\n        }\n    }\n    return set ? next : AV_HWDEVICE_TYPE_NONE;\n}"
        ],
        "source": [
            "    enum AVHWDeviceType next;"
        ],
        "index": 38,
        "location": {
            "file_path": "libavutil/hwcontext.c",
            "region": {
                "startLine": 93,
                "startColumn": 12,
                "endColumn": 16
            },
            "context": {
                "startLine": 91,
                "endLine": 95,
                "snippet": {
                    "text": "return set ? next : AV_HWDEVICE_TYPE_NONE;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavutil/hwcontext.c",
                        "function_body": "81 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n82 {\n83     enum AVHWDeviceType next;\n84     int i, set = 0;\n85     for (i = 0; hw_table[i]; i++) {\n86         if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n87             continue;\n88         if (!set || hw_table[i]->type < next) {\n89             next = hw_table[i]->type;\n90             set = 1;\n91         }\n92     }\n93     return set ? next : AV_HWDEVICE_TYPE_NONE;\n94 }"
                    },
                    {
                        "file_path": "/avtools/avconv_opt.c",
                        "function_body": "347 static int opt_init_hw_device(void *optctx, const char *opt, const char *arg)\n348 {\n349     if (!strcmp(arg, \"list\")) {\n350         enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE;\n351         printf(\"Supported hardware device types:\\n\");\n352         while ((type = av_hwdevice_iterate_types(type)) !=\n353                AV_HWDEVICE_TYPE_NONE)\n354             printf(\"%s\\n\", av_hwdevice_get_type_name(type));\n355         printf(\"\\n\");\n356         exit_program(0);\n357     } else {\n358         return hw_device_init_from_string(arg, NULL);\n359     }\n360 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavutil/hwcontext.c",
                        "function_body": "81 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n82 {\n83     enum AVHWDeviceType next;\n84     int i, set = 0;\n85     for (i = 0; hw_table[i]; i++) {\n86         if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n87             continue;\n88         if (!set || hw_table[i]->type < next) {\n89             next = hw_table[i]->type;\n90             set = 1;\n91         }\n92     }\n93     return set ? next : AV_HWDEVICE_TYPE_NONE;\n94 }"
                    },
                    {
                        "file_path": "/avtools/avconv_opt.c",
                        "function_body": "534 static void add_input_streams(OptionsContext *o, AVFormatContext *ic)\n535 {\n536     int i, ret;\n537\n538     for (i = 0; i < ic->nb_streams; i++) {\n539         AVStream *st = ic->streams[i];\n540         AVCodecParameters *par = st->codecpar;\n541         InputStream *ist = av_mallocz(sizeof(*ist));\n542         char *framerate = NULL, *hwaccel = NULL, *hwaccel_device = NULL;\n543         char *hwaccel_output_format = NULL;\n544         char *codec_tag = NULL;\n545         char *next;\n546\n547         if (!ist)\n548             exit_program(1);\n549\n550         GROW_ARRAY(input_streams, nb_input_streams);\n551         input_streams[nb_input_streams - 1] = ist;\n552\n553         ist->st = st;\n554         ist->file_index = nb_input_files;\n555         ist->discard = 1;\n556         st->discard  = AVDISCARD_ALL;\n557         ist->nb_samples = 0;\n558         ist->min_pts = INT64_MAX;\n559         ist->max_pts = INT64_MIN;\n560\n561         ist->ts_scale = 1.0;\n562         MATCH_PER_STREAM_OPT(ts_scale, dbl, ist->ts_scale, ic, st);\n563\n564         ist->autorotate = 1;\n565         MATCH_PER_STREAM_OPT(autorotate, i, ist->autorotate, ic, st);\n566\n567         MATCH_PER_STREAM_OPT(codec_tags, str, codec_tag, ic, st);\n568         if (codec_tag) {\n569             uint32_t tag = strtol(codec_tag, &next, 0);\n570             if (*next)\n571                 tag = AV_RL32(codec_tag);\n572             st->codecpar->codec_tag = tag;\n573         }\n574\n575         ist->dec = choose_decoder(o, ic, st);\n576         ist->decoder_opts = filter_codec_opts(o->g->codec_opts, par->codec_id, ic, st, ist->dec);\n577\n578         ist->dec_ctx = avcodec_alloc_context3(ist->dec);\n579         if (!ist->dec_ctx) {\n580             av_log(NULL, AV_LOG_ERROR, \"Error allocating the decoder context.\\n\");\n581             exit_program(1);\n582         }\n583\n584         ret = avcodec_parameters_to_context(ist->dec_ctx, par);\n585         if (ret < 0) {\n586             av_log(NULL, AV_LOG_ERROR, \"Error initializing the decoder context.\\n\");\n587             exit_program(1);\n588         }\n589\n590         switch (par->codec_type) {\n591         case AVMEDIA_TYPE_VIDEO:\n592             MATCH_PER_STREAM_OPT(frame_rates, str, framerate, ic, st);\n593             if (framerate && av_parse_video_rate(&ist->framerate,\n594                                                  framerate) < 0) {\n595                 av_log(NULL, AV_LOG_ERROR, \"Error parsing framerate %s.\\n\",\n596                        framerate);\n597                 exit_program(1);\n598             }\n599\n600             MATCH_PER_STREAM_OPT(hwaccels, str, hwaccel, ic, st);\n601             if (hwaccel) {\n602                 if (!strcmp(hwaccel, \"none\"))\n603                     ist->hwaccel_id = HWACCEL_NONE;\n604                 else if (!strcmp(hwaccel, \"auto\"))\n605                     ist->hwaccel_id = HWACCEL_AUTO;\n606                 else {\n607                     enum AVHWDeviceType type;\n608                     int i;\n609                     for (i = 0; hwaccels[i].name; i++) {\n610                         if (!strcmp(hwaccels[i].name, hwaccel)) {\n611                             ist->hwaccel_id = hwaccels[i].id;\n612                             break;\n613                         }\n614                     }\n615\n616                     if (!ist->hwaccel_id) {\n617                         type = av_hwdevice_find_type_by_name(hwaccel);\n618                         if (type != AV_HWDEVICE_TYPE_NONE) {\n619                             ist->hwaccel_id = HWACCEL_GENERIC;\n620                             ist->hwaccel_device_type = type;\n621                         }\n622                     }\n623\n624                     if (!ist->hwaccel_id) {\n625                         av_log(NULL, AV_LOG_FATAL, \"Unrecognized hwaccel: %s.\\n\",\n626                                hwaccel);\n627                         av_log(NULL, AV_LOG_FATAL, \"Supported hwaccels: \");\n628                         type = AV_HWDEVICE_TYPE_NONE;\n629                         while ((type = av_hwdevice_iterate_types(type)) !=\n630                                AV_HWDEVICE_TYPE_NONE)\n631                             av_log(NULL, AV_LOG_FATAL, \"%s \",\n632                                    av_hwdevice_get_type_name(type));\n633                         for (i = 0; hwaccels[i].name; i++)\n634                             av_log(NULL, AV_LOG_FATAL, \"%s \", hwaccels[i].name);\n635                         av_log(NULL, AV_LOG_FATAL, \"\\n\");\n636                         exit_program(1);\n637                     }\n638                 }\n639             }\n640\n641             MATCH_PER_STREAM_OPT(hwaccel_devices, str, hwaccel_device, ic, st);\n642             if (hwaccel_device) {\n643                 ist->hwaccel_device = av_strdup(hwaccel_device);\n644                 if (!ist->hwaccel_device)\n645                     exit_program(1);\n646             }\n647\n648             MATCH_PER_STREAM_OPT(hwaccel_output_formats, str,\n649                                  hwaccel_output_format, ic, st);\n650             if (hwaccel_output_format) {\n651                 ist->hwaccel_output_format = av_get_pix_fmt(hwaccel_output_format);\n652                 if (ist->hwaccel_output_format == AV_PIX_FMT_NONE) {\n653                     av_log(NULL, AV_LOG_FATAL, \"Unrecognised hwaccel output \"\n654                            \"format: %s\", hwaccel_output_format);\n655                 }\n656             } else {\n657                 ist->hwaccel_output_format = AV_PIX_FMT_NONE;\n658             }\n659\n660             ist->hwaccel_pix_fmt = AV_PIX_FMT_NONE;\n661\n662             break;\n663         case AVMEDIA_TYPE_AUDIO:\n664             guess_input_channel_layout(ist);\n665             break;\n666         case AVMEDIA_TYPE_DATA:\n667         case AVMEDIA_TYPE_SUBTITLE:\n668         case AVMEDIA_TYPE_ATTACHMENT:\n669         case AVMEDIA_TYPE_UNKNOWN:\n670             break;\n671         default:\n672             abort();\n673         }\n674     }\n675 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavutil/hwcontext.c",
                        "function_body": "81 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n82 {\n83     enum AVHWDeviceType next;\n84     int i, set = 0;\n85     for (i = 0; hw_table[i]; i++) {\n86         if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n87             continue;\n88         if (!set || hw_table[i]->type < next) {\n89             next = hw_table[i]->type;\n90             set = 1;\n91         }\n92     }\n93     return set ? next : AV_HWDEVICE_TYPE_NONE;\n94 }"
                    },
                    {
                        "file_path": "/avtools/avconv_opt.c",
                        "function_body": "410 static int copy_metadata(char *outspec, char *inspec, AVFormatContext *oc, AVFormatContext *ic, OptionsContext *o)\n411 {\n412     AVDictionary **meta_in = NULL;\n413     AVDictionary **meta_out;\n414     int i, ret = 0;\n415     char type_in, type_out;\n416     const char *istream_spec = NULL, *ostream_spec = NULL;\n417     int idx_in = 0, idx_out = 0;\n418\n419     parse_meta_type(inspec,  &type_in,  &idx_in,  &istream_spec);\n420     parse_meta_type(outspec, &type_out, &idx_out, &ostream_spec);\n421\n422     if (type_in == 'g' || type_out == 'g')\n423         o->metadata_global_manual = 1;\n424     if (type_in == 's' || type_out == 's')\n425         o->metadata_streams_manual = 1;\n426     if (type_in == 'c' || type_out == 'c')\n427         o->metadata_chapters_manual = 1;\n428\n429     /* ic is NULL when just disabling automatic mappings */\n430     if (!ic)\n431         return 0;\n432\n433 #define METADATA_CHECK_INDEX(index, nb_elems, desc)\\\n434     if ((index) < 0 || (index) >= (nb_elems)) {\\\n435         av_log(NULL, AV_LOG_FATAL, \"Invalid %s index %d while processing metadata maps.\\n\",\\\n436                 (desc), (index));\\\n437         exit_program(1);\\\n438     }\n439\n440 #define SET_DICT(type, meta, context, index)\\\n441         switch (type) {\\\n442         case 'g':\\\n443             meta = &context->metadata;\\\n444             break;\\\n445         case 'c':\\\n446             METADATA_CHECK_INDEX(index, context->nb_chapters, \"chapter\")\\\n447             meta = &context->chapters[index]->metadata;\\\n448             break;\\\n449         case 'p':\\\n450             METADATA_CHECK_INDEX(index, context->nb_programs, \"program\")\\\n451             meta = &context->programs[index]->metadata;\\\n452             break;\\\n453         case 's':\\\n454             break; /* handled separately below */ \\\n455         default: av_assert0(0);\\\n456         }\\\n457\n458     SET_DICT(type_in, meta_in, ic, idx_in);\n459     SET_DICT(type_out, meta_out, oc, idx_out);\n460\n461     /* for input streams choose first matching stream */\n462     if (type_in == 's') {\n463         for (i = 0; i < ic->nb_streams; i++) {\n464             if ((ret = check_stream_specifier(ic, ic->streams[i], istream_spec)) > 0) {\n465                 meta_in = &ic->streams[i]->metadata;\n466                 break;\n467             } else if (ret < 0)\n468                 exit_program(1);\n469         }\n470         if (!meta_in) {\n471             av_log(NULL, AV_LOG_FATAL, \"Stream specifier %s does not match  any streams.\\n\", istream_spec);\n472             exit_program(1);\n473         }\n474     }\n475\n476     if (type_out == 's') {\n477         for (i = 0; i < oc->nb_streams; i++) {\n478             if ((ret = check_stream_specifier(oc, oc->streams[i], ostream_spec)) > 0) {\n479                 meta_out = &oc->streams[i]->metadata;\n480                 av_dict_copy(meta_out, *meta_in, AV_DICT_DONT_OVERWRITE);\n481             } else if (ret < 0)\n482                 exit_program(1);\n483         }\n484     } else\n485         av_dict_copy(meta_out, *meta_in, AV_DICT_DONT_OVERWRITE);\n486\n487     return 0;\n488 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavutil/hwcontext.c",
                        "function_body": "81 enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)\n82 {\n83     enum AVHWDeviceType next;\n84     int i, set = 0;\n85     for (i = 0; hw_table[i]; i++) {\n86         if (prev != AV_HWDEVICE_TYPE_NONE && hw_table[i]->type <= prev)\n87             continue;\n88         if (!set || hw_table[i]->type < next) {\n89             next = hw_table[i]->type;\n90             set = 1;\n91         }\n92     }\n93     return set ? next : AV_HWDEVICE_TYPE_NONE;\n94 }"
                    },
                    {
                        "file_path": "/avtools/avconv_opt.c",
                        "function_body": "180 static int show_hwaccels(void *optctx, const char *opt, const char *arg)\n181 {\n182     enum AVHWDeviceType type = AV_HWDEVICE_TYPE_NONE;\n183     int i;\n184\n185     printf(\"Supported hardware acceleration:\\n\");\n186     while ((type = av_hwdevice_iterate_types(type)) !=\n187            AV_HWDEVICE_TYPE_NONE)\n188         printf(\"%s\\n\", av_hwdevice_get_type_name(type));\n189     for (i = 0; hwaccels[i].name; i++)\n190         printf(\"%s\\n\", hwaccels[i].name);\n191     printf(\"\\n\");\n192     return 0;\n193 }"
                    }
                ]
            }
        ],
        "sink": "return set ? next : AV_HWDEVICE_TYPE_NONE;",
        "final_sink": "return set ? next : AV_HWDEVICE_TYPE_NONE;"
    },
    {
        "prt": "soi_pos",
        "function_call": [
            "static int mxg_update_cache(AVFormatContext *s, unsigned int cache_size)\n{\n    MXGContext *mxg = s->priv_data;\n    unsigned int current_pos = mxg->buffer_ptr - mxg->buffer;\n    unsigned int soi_pos;\n    int ret;\n\n    /* reallocate internal buffer */\n    if (current_pos > current_pos + cache_size)\n        return AVERROR(ENOMEM);\n    if (mxg->soi_ptr) soi_pos = mxg->soi_ptr - mxg->buffer;\n    mxg->buffer = av_fast_realloc(mxg->buffer, &mxg->buffer_size,\n                                  current_pos + cache_size +\n                                  AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!mxg->buffer)\n        return AVERROR(ENOMEM);\n    mxg->buffer_ptr = mxg->buffer + current_pos;\n    if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;\n\n    /* get data */\n    ret = avio_read(s->pb, mxg->buffer_ptr + mxg->cache_size,\n                     cache_size - mxg->cache_size);\n    if (ret < 0)\n        return ret;\n\n    mxg->cache_size += ret;\n\n    return ret;\n}"
        ],
        "source": [
            "    unsigned int soi_pos;"
        ],
        "index": 39,
        "location": {
            "file_path": "libavformat/mxg.c",
            "region": {
                "startLine": 117,
                "startColumn": 23,
                "endColumn": 30
            },
            "context": {
                "startLine": 115,
                "endLine": 119,
                "snippet": {
                    "text": "if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/mxg.c",
                        "function_body": "100 static int mxg_update_cache(AVFormatContext *s, unsigned int cache_size)\n101 {\n102     MXGContext *mxg = s->priv_data;\n103     unsigned int current_pos = mxg->buffer_ptr - mxg->buffer;\n104     unsigned int soi_pos;\n105     int ret;\n106\n107     /* reallocate internal buffer */\n108     if (current_pos > current_pos + cache_size)\n109         return AVERROR(ENOMEM);\n110     if (mxg->soi_ptr) soi_pos = mxg->soi_ptr - mxg->buffer;\n111     mxg->buffer = av_fast_realloc(mxg->buffer, &mxg->buffer_size,\n112                                   current_pos + cache_size +\n113                                   AV_INPUT_BUFFER_PADDING_SIZE);\n114     if (!mxg->buffer)\n115         return AVERROR(ENOMEM);\n116     mxg->buffer_ptr = mxg->buffer + current_pos;\n117     if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;\n118\n119     /* get data */\n120     ret = avio_read(s->pb, mxg->buffer_ptr + mxg->cache_size,\n121                      cache_size - mxg->cache_size);\n122     if (ret < 0)\n123         return ret;\n124\n125     mxg->cache_size += ret;\n126\n127     return ret;\n128 }"
                    },
                    {
                        "file_path": "/libavformat/mxg.c",
                        "function_body": "130 static int mxg_read_packet(AVFormatContext *s, AVPacket *pkt)\n131 {\n132     int ret;\n133     unsigned int size;\n134     uint8_t *startmarker_ptr, *end, *search_end, marker;\n135     MXGContext *mxg = s->priv_data;\n136\n137     while (!s->pb->eof_reached && !s->pb->error){\n138         if (mxg->cache_size <= OVERREAD_SIZE) {\n139             /* update internal buffer */\n140             ret = mxg_update_cache(s, DEFAULT_PACKET_SIZE + OVERREAD_SIZE);\n141             if (ret < 0)\n142                 return ret;\n143         }\n144         end = mxg->buffer_ptr + mxg->cache_size;\n145\n146         /* find start marker - 0xff */\n147         if (mxg->cache_size > OVERREAD_SIZE) {\n148             search_end = end - OVERREAD_SIZE;\n149             startmarker_ptr = mxg_find_startmarker(mxg->buffer_ptr, search_end);\n150         } else {\n151             search_end = end;\n152             startmarker_ptr = mxg_find_startmarker(mxg->buffer_ptr, search_end);\n153             if (startmarker_ptr >= search_end - 1 ||\n154                 *(startmarker_ptr + 1) != EOI) break;\n155         }\n156\n157         if (startmarker_ptr != search_end) { /* start marker found */\n158             marker = *(startmarker_ptr + 1);\n159             mxg->buffer_ptr = startmarker_ptr + 2;\n160             mxg->cache_size = end - mxg->buffer_ptr;\n161\n162             if (marker == SOI) {\n163                 mxg->soi_ptr = startmarker_ptr;\n164             } else if (marker == EOI) {\n165                 if (!mxg->soi_ptr) {\n166                     av_log(s, AV_LOG_WARNING, \"Found EOI before SOI, skipping\\n\");\n167                     continue;\n168                 }\n169\n170                 pkt->pts = pkt->dts = mxg->dts;\n171                 pkt->stream_index = 0;\n172                 pkt->buf  = NULL;\n173                 pkt->size = mxg->buffer_ptr - mxg->soi_ptr;\n174                 pkt->data = mxg->soi_ptr;\n175\n176                 if (mxg->soi_ptr - mxg->buffer > mxg->cache_size) {\n177                     if (mxg->cache_size > 0) {\n178                         memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);\n179                     }\n180\n181                     mxg->buffer_ptr = mxg->buffer;\n182                 }\n183                 mxg->soi_ptr = 0;\n184\n185                 return pkt->size;\n186             } else if ( (SOF0 <= marker && marker <= SOF15) ||\n187                         (SOS  <= marker && marker <= COM) ) {\n188                 /* all other markers that start marker segment also contain\n189                    length value (see specification for JPEG Annex B.1) */\n190                 size = AV_RB16(mxg->buffer_ptr);\n191                 if (size < 2)\n192                     return AVERROR(EINVAL);\n193\n194                 if (mxg->cache_size < size) {\n195                     ret = mxg_update_cache(s, size);\n196                     if (ret < 0)\n197                         return ret;\n198                     startmarker_ptr = mxg->buffer_ptr - 2;\n199                     mxg->cache_size = 0;\n200                 } else {\n201                     mxg->cache_size -= size;\n202                 }\n203\n204                 mxg->buffer_ptr += size;\n205\n206                 if (marker == APP13 && size >= 16) { /* audio data */\n207                     /* time (GMT) of first sample in usec since 1970, little-endian */\n208                     pkt->pts = pkt->dts = AV_RL64(startmarker_ptr + 8);\n209                     pkt->stream_index = 1;\n210                     pkt->buf  = NULL;\n211                     pkt->size = size - 14;\n212                     pkt->data = startmarker_ptr + 16;\n213\n214                     if (startmarker_ptr - mxg->buffer > mxg->cache_size) {\n215                         if (mxg->cache_size > 0) {\n216                             memcpy(mxg->buffer, mxg->buffer_ptr, mxg->cache_size);\n217                         }\n218                         mxg->buffer_ptr = mxg->buffer;\n219                     }\n220\n221                     return pkt->size;\n222                 } else if (marker == COM && size >= 18 &&\n223                            !strncmp(startmarker_ptr + 4, \"MXF\", 3)) {\n224                     /* time (GMT) of video frame in usec since 1970, little-endian */\n225                     mxg->dts = AV_RL64(startmarker_ptr + 12);\n226                 }\n227             }\n228         } else {\n229             /* start marker not found */\n230             mxg->buffer_ptr = search_end;\n231             mxg->cache_size = OVERREAD_SIZE;\n232         }\n233     }\n234\n235     return AVERROR_EOF;\n236 }"
                    }
                ]
            }
        ],
        "sink": "if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;",
        "final_sink": "if (mxg->soi_ptr) mxg->soi_ptr = mxg->buffer + soi_pos;"
    },
    {
        "prt": "last_off",
        "function_call": [
            "void ff_nelly_get_sample_bits(const float *buf, int *bits)\n{\n    int i, j;\n    short sbuf[128];\n    int bitsum = 0, last_bitsum, small_bitsum, big_bitsum;\n    short shift, shift_saved;\n    int max, sum, last_off, tmp;\n    int big_off, small_off;\n    int off;\n\n    max = 0;\n    for (i = 0; i < NELLY_FILL_LEN; i++) {\n        max = FFMAX(max, buf[i]);\n    }\n    shift = -16;\n    shift += headroom(&max);\n\n    sum = 0;\n    for (i = 0; i < NELLY_FILL_LEN; i++) {\n        sbuf[i] = signed_shift(buf[i], shift);\n        sbuf[i] = (3*sbuf[i])>>2;\n        sum += sbuf[i];\n    }\n\n    shift += 11;\n    shift_saved = shift;\n    sum -= NELLY_DETAIL_BITS << shift;\n    shift += headroom(&sum);\n    small_off = (NELLY_BASE_OFF * (sum>>16)) >> 15;\n    shift = shift_saved - (NELLY_BASE_SHIFT+shift-31);\n\n    small_off = signed_shift(small_off, shift);\n\n    bitsum = sum_bits(sbuf, shift_saved, small_off);\n\n    if (bitsum != NELLY_DETAIL_BITS) {\n        off = bitsum - NELLY_DETAIL_BITS;\n\n        for(shift=0; FFABS(off) <= 16383; shift++)\n            off *= 2;\n\n        off = (off * NELLY_BASE_OFF) >> 15;\n        shift = shift_saved-(NELLY_BASE_SHIFT+shift-15);\n\n        off = signed_shift(off, shift);\n\n        for (j = 1; j < 20; j++) {\n            last_off = small_off;\n            small_off += off;\n            last_bitsum = bitsum;\n\n            bitsum = sum_bits(sbuf, shift_saved, small_off);\n\n            if ((bitsum-NELLY_DETAIL_BITS) * (last_bitsum-NELLY_DETAIL_BITS) <= 0)\n                break;\n        }\n\n        if (bitsum > NELLY_DETAIL_BITS) {\n            big_off = small_off;\n            small_off = last_off;\n            big_bitsum=bitsum;\n            small_bitsum=last_bitsum;\n        } else {\n            big_off = last_off;\n            big_bitsum=last_bitsum;\n            small_bitsum=bitsum;\n        }\n\n        while (bitsum != NELLY_DETAIL_BITS && j <= 19) {\n            off = (big_off+small_off)>>1;\n            bitsum = sum_bits(sbuf, shift_saved, off);\n            if (bitsum > NELLY_DETAIL_BITS) {\n                big_off=off;\n                big_bitsum=bitsum;\n            } else {\n                small_off = off;\n                small_bitsum=bitsum;\n            }\n            j++;\n        }\n\n        if (abs(big_bitsum-NELLY_DETAIL_BITS) >=\n            abs(small_bitsum-NELLY_DETAIL_BITS)) {\n            bitsum = small_bitsum;\n        } else {\n            small_off = big_off;\n            bitsum = big_bitsum;\n        }\n    }\n\n    for (i = 0; i < NELLY_FILL_LEN; i++) {\n        tmp = sbuf[i]-small_off;\n        tmp = ((tmp>>(shift_saved-1))+1)>>1;\n        bits[i] = av_clip(tmp, 0, NELLY_BIT_CAP);\n    }\n\n    if (bitsum > NELLY_DETAIL_BITS) {\n        tmp = i = 0;\n        while (tmp < NELLY_DETAIL_BITS) {\n            tmp += bits[i];\n            i++;\n        }\n\n        bits[i-1] -= tmp - NELLY_DETAIL_BITS;\n        for(; i < NELLY_FILL_LEN; i++)\n            bits[i] = 0;\n    }\n}"
        ],
        "source": [
            "    int max, sum, last_off, tmp;"
        ],
        "index": 40,
        "location": {
            "file_path": "libavcodec/nellymoser.c",
            "region": {
                "startLine": 175,
                "startColumn": 13,
                "endColumn": 21
            },
            "context": {
                "startLine": 173,
                "endLine": 177,
                "snippet": {
                    "text": "small_off = last_off;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/nellymoser.c",
                        "function_body": "116 void ff_nelly_get_sample_bits(const float *buf, int *bits)\n117 {\n118     int i, j;\n119     short sbuf[128];\n120     int bitsum = 0, last_bitsum, small_bitsum, big_bitsum;\n121     short shift, shift_saved;\n122     int max, sum, last_off, tmp;\n123     int big_off, small_off;\n124     int off;\n125\n126     max = 0;\n127     for (i = 0; i < NELLY_FILL_LEN; i++) {\n128         max = FFMAX(max, buf[i]);\n129     }\n130     shift = -16;\n131     shift += headroom(&max);\n132\n133     sum = 0;\n134     for (i = 0; i < NELLY_FILL_LEN; i++) {\n135         sbuf[i] = signed_shift(buf[i], shift);\n136         sbuf[i] = (3*sbuf[i])>>2;\n137         sum += sbuf[i];\n138     }\n139\n140     shift += 11;\n141     shift_saved = shift;\n142     sum -= NELLY_DETAIL_BITS << shift;\n143     shift += headroom(&sum);\n144     small_off = (NELLY_BASE_OFF * (sum>>16)) >> 15;\n145     shift = shift_saved - (NELLY_BASE_SHIFT+shift-31);\n146\n147     small_off = signed_shift(small_off, shift);\n148\n149     bitsum = sum_bits(sbuf, shift_saved, small_off);\n150\n151     if (bitsum != NELLY_DETAIL_BITS) {\n152         off = bitsum - NELLY_DETAIL_BITS;\n153\n154         for(shift=0; FFABS(off) <= 16383; shift++)\n155             off *= 2;\n156\n157         off = (off * NELLY_BASE_OFF) >> 15;\n158         shift = shift_saved-(NELLY_BASE_SHIFT+shift-15);\n159\n160         off = signed_shift(off, shift);\n161\n162         for (j = 1; j < 20; j++) {\n163             last_off = small_off;\n164             small_off += off;\n165             last_bitsum = bitsum;\n166\n167             bitsum = sum_bits(sbuf, shift_saved, small_off);\n168\n169             if ((bitsum-NELLY_DETAIL_BITS) * (last_bitsum-NELLY_DETAIL_BITS) <= 0)\n170                 break;\n171         }\n172\n173         if (bitsum > NELLY_DETAIL_BITS) {\n174             big_off = small_off;\n175             small_off = last_off;\n176             big_bitsum=bitsum;\n177             small_bitsum=last_bitsum;\n178         } else {\n179             big_off = last_off;\n180             big_bitsum=last_bitsum;\n181             small_bitsum=bitsum;\n182         }\n183\n184         while (bitsum != NELLY_DETAIL_BITS && j <= 19) {\n185             off = (big_off+small_off)>>1;\n186             bitsum = sum_bits(sbuf, shift_saved, off);\n187             if (bitsum > NELLY_DETAIL_BITS) {\n188                 big_off=off;\n189                 big_bitsum=bitsum;\n190             } else {\n191                 small_off = off;\n192                 small_bitsum=bitsum;\n193             }\n194             j++;\n195         }\n196\n197         if (abs(big_bitsum-NELLY_DETAIL_BITS) >=\n198             abs(small_bitsum-NELLY_DETAIL_BITS)) {\n199             bitsum = small_bitsum;\n200         } else {\n201             small_off = big_off;\n202             bitsum = big_bitsum;\n203         }\n204     }\n205\n206     for (i = 0; i < NELLY_FILL_LEN; i++) {\n207         tmp = sbuf[i]-small_off;\n208         tmp = ((tmp>>(shift_saved-1))+1)>>1;\n209         bits[i] = av_clip(tmp, 0, NELLY_BIT_CAP);\n210     }\n211\n212     if (bitsum > NELLY_DETAIL_BITS) {\n213         tmp = i = 0;\n214         while (tmp < NELLY_DETAIL_BITS) {\n215             tmp += bits[i];\n216             i++;\n217         }\n218\n219         bits[i-1] -= tmp - NELLY_DETAIL_BITS;\n220         for(; i < NELLY_FILL_LEN; i++)\n221             bits[i] = 0;\n222     }\n223 }"
                    },
                    {
                        "file_path": "/libavcodec/nellymoserenc.c",
                        "function_body": "295 static void encode_block(NellyMoserEncodeContext *s, unsigned char *output, int output_size)\n296 {\n297     PutBitContext pb;\n298     int i, j, band, block, best_idx, power_idx = 0;\n299     float power_val, coeff, coeff_sum;\n300     float pows[NELLY_FILL_LEN];\n301     int bits[NELLY_BUF_LEN], idx_table[NELLY_BANDS];\n302     float cand[NELLY_BANDS];\n303\n304     apply_mdct(s);\n305\n306     init_put_bits(&pb, output, output_size * 8);\n307\n308     i = 0;\n309     for (band = 0; band < NELLY_BANDS; band++) {\n310         coeff_sum = 0;\n311         for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) {\n312             coeff_sum += s->mdct_out[i                ] * s->mdct_out[i                ]\n313                        + s->mdct_out[i + NELLY_BUF_LEN] * s->mdct_out[i + NELLY_BUF_LEN];\n314         }\n315         cand[band] =\n316             log(FFMAX(1.0, coeff_sum / (ff_nelly_band_sizes_table[band] << 7))) * 1024.0 / M_LN2;\n317     }\n318\n319     if (s->avctx->trellis) {\n320         get_exponent_dynamic(s, cand, idx_table);\n321     } else {\n322         get_exponent_greedy(s, cand, idx_table);\n323     }\n324\n325     i = 0;\n326     for (band = 0; band < NELLY_BANDS; band++) {\n327         if (band) {\n328             power_idx += ff_nelly_delta_table[idx_table[band]];\n329             put_bits(&pb, 5, idx_table[band]);\n330         } else {\n331             power_idx = ff_nelly_init_table[idx_table[0]];\n332             put_bits(&pb, 6, idx_table[0]);\n333         }\n334         power_val = pow_table[power_idx & 0x7FF] / (1 << ((power_idx >> 11) + POW_TABLE_OFFSET));\n335         for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) {\n336             s->mdct_out[i] *= power_val;\n337             s->mdct_out[i + NELLY_BUF_LEN] *= power_val;\n338             pows[i] = power_idx;\n339         }\n340     }\n341\n342     ff_nelly_get_sample_bits(pows, bits);\n343\n344     for (block = 0; block < 2; block++) {\n345         for (i = 0; i < NELLY_FILL_LEN; i++) {\n346             if (bits[i] > 0) {\n347                 const float *table = ff_nelly_dequantization_table + (1 << bits[i]) - 1;\n348                 coeff = s->mdct_out[block * NELLY_BUF_LEN + i];\n349                 best_idx =\n350                     quant_lut[av_clip (\n351                             coeff * quant_lut_mul[bits[i]] + quant_lut_add[bits[i]],\n352                             quant_lut_offset[bits[i]],\n353                             quant_lut_offset[bits[i]+1] - 1\n354                             )];\n355                 if (fabs(coeff - table[best_idx]) > fabs(coeff - table[best_idx + 1]))\n356                     best_idx++;\n357\n358                 put_bits(&pb, bits[i], best_idx);\n359             }\n360         }\n361         if (!block)\n362             put_bits(&pb, NELLY_HEADER_BITS + NELLY_DETAIL_BITS - put_bits_count(&pb), 0);\n363     }\n364\n365     flush_put_bits(&pb);\n366     memset(put_bits_ptr(&pb), 0, output + output_size - put_bits_ptr(&pb));\n367 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/nellymoser.c",
                        "function_body": "116 void ff_nelly_get_sample_bits(const float *buf, int *bits)\n117 {\n118     int i, j;\n119     short sbuf[128];\n120     int bitsum = 0, last_bitsum, small_bitsum, big_bitsum;\n121     short shift, shift_saved;\n122     int max, sum, last_off, tmp;\n123     int big_off, small_off;\n124     int off;\n125\n126     max = 0;\n127     for (i = 0; i < NELLY_FILL_LEN; i++) {\n128         max = FFMAX(max, buf[i]);\n129     }\n130     shift = -16;\n131     shift += headroom(&max);\n132\n133     sum = 0;\n134     for (i = 0; i < NELLY_FILL_LEN; i++) {\n135         sbuf[i] = signed_shift(buf[i], shift);\n136         sbuf[i] = (3*sbuf[i])>>2;\n137         sum += sbuf[i];\n138     }\n139\n140     shift += 11;\n141     shift_saved = shift;\n142     sum -= NELLY_DETAIL_BITS << shift;\n143     shift += headroom(&sum);\n144     small_off = (NELLY_BASE_OFF * (sum>>16)) >> 15;\n145     shift = shift_saved - (NELLY_BASE_SHIFT+shift-31);\n146\n147     small_off = signed_shift(small_off, shift);\n148\n149     bitsum = sum_bits(sbuf, shift_saved, small_off);\n150\n151     if (bitsum != NELLY_DETAIL_BITS) {\n152         off = bitsum - NELLY_DETAIL_BITS;\n153\n154         for(shift=0; FFABS(off) <= 16383; shift++)\n155             off *= 2;\n156\n157         off = (off * NELLY_BASE_OFF) >> 15;\n158         shift = shift_saved-(NELLY_BASE_SHIFT+shift-15);\n159\n160         off = signed_shift(off, shift);\n161\n162         for (j = 1; j < 20; j++) {\n163             last_off = small_off;\n164             small_off += off;\n165             last_bitsum = bitsum;\n166\n167             bitsum = sum_bits(sbuf, shift_saved, small_off);\n168\n169             if ((bitsum-NELLY_DETAIL_BITS) * (last_bitsum-NELLY_DETAIL_BITS) <= 0)\n170                 break;\n171         }\n172\n173         if (bitsum > NELLY_DETAIL_BITS) {\n174             big_off = small_off;\n175             small_off = last_off;\n176             big_bitsum=bitsum;\n177             small_bitsum=last_bitsum;\n178         } else {\n179             big_off = last_off;\n180             big_bitsum=last_bitsum;\n181             small_bitsum=bitsum;\n182         }\n183\n184         while (bitsum != NELLY_DETAIL_BITS && j <= 19) {\n185             off = (big_off+small_off)>>1;\n186             bitsum = sum_bits(sbuf, shift_saved, off);\n187             if (bitsum > NELLY_DETAIL_BITS) {\n188                 big_off=off;\n189                 big_bitsum=bitsum;\n190             } else {\n191                 small_off = off;\n192                 small_bitsum=bitsum;\n193             }\n194             j++;\n195         }\n196\n197         if (abs(big_bitsum-NELLY_DETAIL_BITS) >=\n198             abs(small_bitsum-NELLY_DETAIL_BITS)) {\n199             bitsum = small_bitsum;\n200         } else {\n201             small_off = big_off;\n202             bitsum = big_bitsum;\n203         }\n204     }\n205\n206     for (i = 0; i < NELLY_FILL_LEN; i++) {\n207         tmp = sbuf[i]-small_off;\n208         tmp = ((tmp>>(shift_saved-1))+1)>>1;\n209         bits[i] = av_clip(tmp, 0, NELLY_BIT_CAP);\n210     }\n211\n212     if (bitsum > NELLY_DETAIL_BITS) {\n213         tmp = i = 0;\n214         while (tmp < NELLY_DETAIL_BITS) {\n215             tmp += bits[i];\n216             i++;\n217         }\n218\n219         bits[i-1] -= tmp - NELLY_DETAIL_BITS;\n220         for(; i < NELLY_FILL_LEN; i++)\n221             bits[i] = 0;\n222     }\n223 }"
                    },
                    {
                        "file_path": "/libavcodec/nellymoserdec.c",
                        "function_body": "60 static void nelly_decode_block(NellyMoserDecodeContext *s,\n61                                const unsigned char block[NELLY_BLOCK_LEN],\n62                                float audio[NELLY_SAMPLES])\n63 {\n64     int i,j;\n65     float buf[NELLY_FILL_LEN], pows[NELLY_FILL_LEN];\n66     float *aptr, *bptr, *pptr, val, pval;\n67     int bits[NELLY_BUF_LEN];\n68     unsigned char v;\n69\n70     bitstream_init8(&s->bc, block, NELLY_BLOCK_LEN);\n71\n72     bptr = buf;\n73     pptr = pows;\n74     val = ff_nelly_init_table[bitstream_read(&s->bc, 6)];\n75     for (i=0 ; i<NELLY_BANDS ; i++) {\n76         if (i > 0)\n77             val += ff_nelly_delta_table[bitstream_read(&s->bc, 5)];\n78         pval = -pow(2, val/2048) * s->scale_bias;\n79         for (j = 0; j < ff_nelly_band_sizes_table[i]; j++) {\n80             *bptr++ = val;\n81             *pptr++ = pval;\n82         }\n83\n84     }\n85\n86     ff_nelly_get_sample_bits(buf, bits);\n87\n88     for (i = 0; i < 2; i++) {\n89         aptr = audio + i * NELLY_BUF_LEN;\n90\n91         bitstream_init8(&s->bc, block, NELLY_BLOCK_LEN);\n92         bitstream_skip(&s->bc, NELLY_HEADER_BITS + i * NELLY_DETAIL_BITS);\n93\n94         for (j = 0; j < NELLY_FILL_LEN; j++) {\n95             if (bits[j] <= 0) {\n96                 aptr[j] = M_SQRT1_2*pows[j];\n97                 if (av_lfg_get(&s->random_state) & 1)\n98                     aptr[j] *= -1.0;\n99             } else {\n100                 v = bitstream_read(&s->bc, bits[j]);\n101                 aptr[j] = ff_nelly_dequantization_table[(1<<bits[j])-1+v]*pows[j];\n102             }\n103         }\n104         memset(&aptr[NELLY_FILL_LEN], 0,\n105                (NELLY_BUF_LEN - NELLY_FILL_LEN) * sizeof(float));\n106\n107         s->imdct_ctx.imdct_half(&s->imdct_ctx, s->imdct_out, aptr);\n108         s->fdsp.vector_fmul_window(aptr, s->imdct_prev + NELLY_BUF_LEN / 2,\n109                                    s->imdct_out, ff_sine_128,\n110                                    NELLY_BUF_LEN / 2);\n111         FFSWAP(float *, s->imdct_out, s->imdct_prev);\n112     }\n113 }"
                    }
                ]
            }
        ],
        "sink": "small_off = last_off;",
        "final_sink": "small_off = last_off;"
    },
    {
        "prt": "last_off",
        "function_call": [
            "void ff_nelly_get_sample_bits(const float *buf, int *bits)\n{\n    int i, j;\n    short sbuf[128];\n    int bitsum = 0, last_bitsum, small_bitsum, big_bitsum;\n    short shift, shift_saved;\n    int max, sum, last_off, tmp;\n    int big_off, small_off;\n    int off;\n\n    max = 0;\n    for (i = 0; i < NELLY_FILL_LEN; i++) {\n        max = FFMAX(max, buf[i]);\n    }\n    shift = -16;\n    shift += headroom(&max);\n\n    sum = 0;\n    for (i = 0; i < NELLY_FILL_LEN; i++) {\n        sbuf[i] = signed_shift(buf[i], shift);\n        sbuf[i] = (3*sbuf[i])>>2;\n        sum += sbuf[i];\n    }\n\n    shift += 11;\n    shift_saved = shift;\n    sum -= NELLY_DETAIL_BITS << shift;\n    shift += headroom(&sum);\n    small_off = (NELLY_BASE_OFF * (sum>>16)) >> 15;\n    shift = shift_saved - (NELLY_BASE_SHIFT+shift-31);\n\n    small_off = signed_shift(small_off, shift);\n\n    bitsum = sum_bits(sbuf, shift_saved, small_off);\n\n    if (bitsum != NELLY_DETAIL_BITS) {\n        off = bitsum - NELLY_DETAIL_BITS;\n\n        for(shift=0; FFABS(off) <= 16383; shift++)\n            off *= 2;\n\n        off = (off * NELLY_BASE_OFF) >> 15;\n        shift = shift_saved-(NELLY_BASE_SHIFT+shift-15);\n\n        off = signed_shift(off, shift);\n\n        for (j = 1; j < 20; j++) {\n            last_off = small_off;\n            small_off += off;\n            last_bitsum = bitsum;\n\n            bitsum = sum_bits(sbuf, shift_saved, small_off);\n\n            if ((bitsum-NELLY_DETAIL_BITS) * (last_bitsum-NELLY_DETAIL_BITS) <= 0)\n                break;\n        }\n\n        if (bitsum > NELLY_DETAIL_BITS) {\n            big_off = small_off;\n            small_off = last_off;\n            big_bitsum=bitsum;\n            small_bitsum=last_bitsum;\n        } else {\n            big_off = last_off;\n            big_bitsum=last_bitsum;\n            small_bitsum=bitsum;\n        }\n\n        while (bitsum != NELLY_DETAIL_BITS && j <= 19) {\n            off = (big_off+small_off)>>1;\n            bitsum = sum_bits(sbuf, shift_saved, off);\n            if (bitsum > NELLY_DETAIL_BITS) {\n                big_off=off;\n                big_bitsum=bitsum;\n            } else {\n                small_off = off;\n                small_bitsum=bitsum;\n            }\n            j++;\n        }\n\n        if (abs(big_bitsum-NELLY_DETAIL_BITS) >=\n            abs(small_bitsum-NELLY_DETAIL_BITS)) {\n            bitsum = small_bitsum;\n        } else {\n            small_off = big_off;\n            bitsum = big_bitsum;\n        }\n    }\n\n    for (i = 0; i < NELLY_FILL_LEN; i++) {\n        tmp = sbuf[i]-small_off;\n        tmp = ((tmp>>(shift_saved-1))+1)>>1;\n        bits[i] = av_clip(tmp, 0, NELLY_BIT_CAP);\n    }\n\n    if (bitsum > NELLY_DETAIL_BITS) {\n        tmp = i = 0;\n        while (tmp < NELLY_DETAIL_BITS) {\n            tmp += bits[i];\n            i++;\n        }\n\n        bits[i-1] -= tmp - NELLY_DETAIL_BITS;\n        for(; i < NELLY_FILL_LEN; i++)\n            bits[i] = 0;\n    }\n}"
        ],
        "source": [
            "    int max, sum, last_off, tmp;"
        ],
        "index": 41,
        "location": {
            "file_path": "libavcodec/nellymoser.c",
            "region": {
                "startLine": 179,
                "startColumn": 13,
                "endColumn": 21
            },
            "context": {
                "startLine": 177,
                "endLine": 181,
                "snippet": {
                    "text": "big_off = last_off;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavcodec/nellymoser.c",
                        "function_body": "116 void ff_nelly_get_sample_bits(const float *buf, int *bits)\n117 {\n118     int i, j;\n119     short sbuf[128];\n120     int bitsum = 0, last_bitsum, small_bitsum, big_bitsum;\n121     short shift, shift_saved;\n122     int max, sum, last_off, tmp;\n123     int big_off, small_off;\n124     int off;\n125\n126     max = 0;\n127     for (i = 0; i < NELLY_FILL_LEN; i++) {\n128         max = FFMAX(max, buf[i]);\n129     }\n130     shift = -16;\n131     shift += headroom(&max);\n132\n133     sum = 0;\n134     for (i = 0; i < NELLY_FILL_LEN; i++) {\n135         sbuf[i] = signed_shift(buf[i], shift);\n136         sbuf[i] = (3*sbuf[i])>>2;\n137         sum += sbuf[i];\n138     }\n139\n140     shift += 11;\n141     shift_saved = shift;\n142     sum -= NELLY_DETAIL_BITS << shift;\n143     shift += headroom(&sum);\n144     small_off = (NELLY_BASE_OFF * (sum>>16)) >> 15;\n145     shift = shift_saved - (NELLY_BASE_SHIFT+shift-31);\n146\n147     small_off = signed_shift(small_off, shift);\n148\n149     bitsum = sum_bits(sbuf, shift_saved, small_off);\n150\n151     if (bitsum != NELLY_DETAIL_BITS) {\n152         off = bitsum - NELLY_DETAIL_BITS;\n153\n154         for(shift=0; FFABS(off) <= 16383; shift++)\n155             off *= 2;\n156\n157         off = (off * NELLY_BASE_OFF) >> 15;\n158         shift = shift_saved-(NELLY_BASE_SHIFT+shift-15);\n159\n160         off = signed_shift(off, shift);\n161\n162         for (j = 1; j < 20; j++) {\n163             last_off = small_off;\n164             small_off += off;\n165             last_bitsum = bitsum;\n166\n167             bitsum = sum_bits(sbuf, shift_saved, small_off);\n168\n169             if ((bitsum-NELLY_DETAIL_BITS) * (last_bitsum-NELLY_DETAIL_BITS) <= 0)\n170                 break;\n171         }\n172\n173         if (bitsum > NELLY_DETAIL_BITS) {\n174             big_off = small_off;\n175             small_off = last_off;\n176             big_bitsum=bitsum;\n177             small_bitsum=last_bitsum;\n178         } else {\n179             big_off = last_off;\n180             big_bitsum=last_bitsum;\n181             small_bitsum=bitsum;\n182         }\n183\n184         while (bitsum != NELLY_DETAIL_BITS && j <= 19) {\n185             off = (big_off+small_off)>>1;\n186             bitsum = sum_bits(sbuf, shift_saved, off);\n187             if (bitsum > NELLY_DETAIL_BITS) {\n188                 big_off=off;\n189                 big_bitsum=bitsum;\n190             } else {\n191                 small_off = off;\n192                 small_bitsum=bitsum;\n193             }\n194             j++;\n195         }\n196\n197         if (abs(big_bitsum-NELLY_DETAIL_BITS) >=\n198             abs(small_bitsum-NELLY_DETAIL_BITS)) {\n199             bitsum = small_bitsum;\n200         } else {\n201             small_off = big_off;\n202             bitsum = big_bitsum;\n203         }\n204     }\n205\n206     for (i = 0; i < NELLY_FILL_LEN; i++) {\n207         tmp = sbuf[i]-small_off;\n208         tmp = ((tmp>>(shift_saved-1))+1)>>1;\n209         bits[i] = av_clip(tmp, 0, NELLY_BIT_CAP);\n210     }\n211\n212     if (bitsum > NELLY_DETAIL_BITS) {\n213         tmp = i = 0;\n214         while (tmp < NELLY_DETAIL_BITS) {\n215             tmp += bits[i];\n216             i++;\n217         }\n218\n219         bits[i-1] -= tmp - NELLY_DETAIL_BITS;\n220         for(; i < NELLY_FILL_LEN; i++)\n221             bits[i] = 0;\n222     }\n223 }"
                    },
                    {
                        "file_path": "/libavcodec/nellymoserenc.c",
                        "function_body": "295 static void encode_block(NellyMoserEncodeContext *s, unsigned char *output, int output_size)\n296 {\n297     PutBitContext pb;\n298     int i, j, band, block, best_idx, power_idx = 0;\n299     float power_val, coeff, coeff_sum;\n300     float pows[NELLY_FILL_LEN];\n301     int bits[NELLY_BUF_LEN], idx_table[NELLY_BANDS];\n302     float cand[NELLY_BANDS];\n303\n304     apply_mdct(s);\n305\n306     init_put_bits(&pb, output, output_size * 8);\n307\n308     i = 0;\n309     for (band = 0; band < NELLY_BANDS; band++) {\n310         coeff_sum = 0;\n311         for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) {\n312             coeff_sum += s->mdct_out[i                ] * s->mdct_out[i                ]\n313                        + s->mdct_out[i + NELLY_BUF_LEN] * s->mdct_out[i + NELLY_BUF_LEN];\n314         }\n315         cand[band] =\n316             log(FFMAX(1.0, coeff_sum / (ff_nelly_band_sizes_table[band] << 7))) * 1024.0 / M_LN2;\n317     }\n318\n319     if (s->avctx->trellis) {\n320         get_exponent_dynamic(s, cand, idx_table);\n321     } else {\n322         get_exponent_greedy(s, cand, idx_table);\n323     }\n324\n325     i = 0;\n326     for (band = 0; band < NELLY_BANDS; band++) {\n327         if (band) {\n328             power_idx += ff_nelly_delta_table[idx_table[band]];\n329             put_bits(&pb, 5, idx_table[band]);\n330         } else {\n331             power_idx = ff_nelly_init_table[idx_table[0]];\n332             put_bits(&pb, 6, idx_table[0]);\n333         }\n334         power_val = pow_table[power_idx & 0x7FF] / (1 << ((power_idx >> 11) + POW_TABLE_OFFSET));\n335         for (j = 0; j < ff_nelly_band_sizes_table[band]; i++, j++) {\n336             s->mdct_out[i] *= power_val;\n337             s->mdct_out[i + NELLY_BUF_LEN] *= power_val;\n338             pows[i] = power_idx;\n339         }\n340     }\n341\n342     ff_nelly_get_sample_bits(pows, bits);\n343\n344     for (block = 0; block < 2; block++) {\n345         for (i = 0; i < NELLY_FILL_LEN; i++) {\n346             if (bits[i] > 0) {\n347                 const float *table = ff_nelly_dequantization_table + (1 << bits[i]) - 1;\n348                 coeff = s->mdct_out[block * NELLY_BUF_LEN + i];\n349                 best_idx =\n350                     quant_lut[av_clip (\n351                             coeff * quant_lut_mul[bits[i]] + quant_lut_add[bits[i]],\n352                             quant_lut_offset[bits[i]],\n353                             quant_lut_offset[bits[i]+1] - 1\n354                             )];\n355                 if (fabs(coeff - table[best_idx]) > fabs(coeff - table[best_idx + 1]))\n356                     best_idx++;\n357\n358                 put_bits(&pb, bits[i], best_idx);\n359             }\n360         }\n361         if (!block)\n362             put_bits(&pb, NELLY_HEADER_BITS + NELLY_DETAIL_BITS - put_bits_count(&pb), 0);\n363     }\n364\n365     flush_put_bits(&pb);\n366     memset(put_bits_ptr(&pb), 0, output + output_size - put_bits_ptr(&pb));\n367 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/libavcodec/nellymoser.c",
                        "function_body": "116 void ff_nelly_get_sample_bits(const float *buf, int *bits)\n117 {\n118     int i, j;\n119     short sbuf[128];\n120     int bitsum = 0, last_bitsum, small_bitsum, big_bitsum;\n121     short shift, shift_saved;\n122     int max, sum, last_off, tmp;\n123     int big_off, small_off;\n124     int off;\n125\n126     max = 0;\n127     for (i = 0; i < NELLY_FILL_LEN; i++) {\n128         max = FFMAX(max, buf[i]);\n129     }\n130     shift = -16;\n131     shift += headroom(&max);\n132\n133     sum = 0;\n134     for (i = 0; i < NELLY_FILL_LEN; i++) {\n135         sbuf[i] = signed_shift(buf[i], shift);\n136         sbuf[i] = (3*sbuf[i])>>2;\n137         sum += sbuf[i];\n138     }\n139\n140     shift += 11;\n141     shift_saved = shift;\n142     sum -= NELLY_DETAIL_BITS << shift;\n143     shift += headroom(&sum);\n144     small_off = (NELLY_BASE_OFF * (sum>>16)) >> 15;\n145     shift = shift_saved - (NELLY_BASE_SHIFT+shift-31);\n146\n147     small_off = signed_shift(small_off, shift);\n148\n149     bitsum = sum_bits(sbuf, shift_saved, small_off);\n150\n151     if (bitsum != NELLY_DETAIL_BITS) {\n152         off = bitsum - NELLY_DETAIL_BITS;\n153\n154         for(shift=0; FFABS(off) <= 16383; shift++)\n155             off *= 2;\n156\n157         off = (off * NELLY_BASE_OFF) >> 15;\n158         shift = shift_saved-(NELLY_BASE_SHIFT+shift-15);\n159\n160         off = signed_shift(off, shift);\n161\n162         for (j = 1; j < 20; j++) {\n163             last_off = small_off;\n164             small_off += off;\n165             last_bitsum = bitsum;\n166\n167             bitsum = sum_bits(sbuf, shift_saved, small_off);\n168\n169             if ((bitsum-NELLY_DETAIL_BITS) * (last_bitsum-NELLY_DETAIL_BITS) <= 0)\n170                 break;\n171         }\n172\n173         if (bitsum > NELLY_DETAIL_BITS) {\n174             big_off = small_off;\n175             small_off = last_off;\n176             big_bitsum=bitsum;\n177             small_bitsum=last_bitsum;\n178         } else {\n179             big_off = last_off;\n180             big_bitsum=last_bitsum;\n181             small_bitsum=bitsum;\n182         }\n183\n184         while (bitsum != NELLY_DETAIL_BITS && j <= 19) {\n185             off = (big_off+small_off)>>1;\n186             bitsum = sum_bits(sbuf, shift_saved, off);\n187             if (bitsum > NELLY_DETAIL_BITS) {\n188                 big_off=off;\n189                 big_bitsum=bitsum;\n190             } else {\n191                 small_off = off;\n192                 small_bitsum=bitsum;\n193             }\n194             j++;\n195         }\n196\n197         if (abs(big_bitsum-NELLY_DETAIL_BITS) >=\n198             abs(small_bitsum-NELLY_DETAIL_BITS)) {\n199             bitsum = small_bitsum;\n200         } else {\n201             small_off = big_off;\n202             bitsum = big_bitsum;\n203         }\n204     }\n205\n206     for (i = 0; i < NELLY_FILL_LEN; i++) {\n207         tmp = sbuf[i]-small_off;\n208         tmp = ((tmp>>(shift_saved-1))+1)>>1;\n209         bits[i] = av_clip(tmp, 0, NELLY_BIT_CAP);\n210     }\n211\n212     if (bitsum > NELLY_DETAIL_BITS) {\n213         tmp = i = 0;\n214         while (tmp < NELLY_DETAIL_BITS) {\n215             tmp += bits[i];\n216             i++;\n217         }\n218\n219         bits[i-1] -= tmp - NELLY_DETAIL_BITS;\n220         for(; i < NELLY_FILL_LEN; i++)\n221             bits[i] = 0;\n222     }\n223 }"
                    },
                    {
                        "file_path": "/libavcodec/nellymoserdec.c",
                        "function_body": "60 static void nelly_decode_block(NellyMoserDecodeContext *s,\n61                                const unsigned char block[NELLY_BLOCK_LEN],\n62                                float audio[NELLY_SAMPLES])\n63 {\n64     int i,j;\n65     float buf[NELLY_FILL_LEN], pows[NELLY_FILL_LEN];\n66     float *aptr, *bptr, *pptr, val, pval;\n67     int bits[NELLY_BUF_LEN];\n68     unsigned char v;\n69\n70     bitstream_init8(&s->bc, block, NELLY_BLOCK_LEN);\n71\n72     bptr = buf;\n73     pptr = pows;\n74     val = ff_nelly_init_table[bitstream_read(&s->bc, 6)];\n75     for (i=0 ; i<NELLY_BANDS ; i++) {\n76         if (i > 0)\n77             val += ff_nelly_delta_table[bitstream_read(&s->bc, 5)];\n78         pval = -pow(2, val/2048) * s->scale_bias;\n79         for (j = 0; j < ff_nelly_band_sizes_table[i]; j++) {\n80             *bptr++ = val;\n81             *pptr++ = pval;\n82         }\n83\n84     }\n85\n86     ff_nelly_get_sample_bits(buf, bits);\n87\n88     for (i = 0; i < 2; i++) {\n89         aptr = audio + i * NELLY_BUF_LEN;\n90\n91         bitstream_init8(&s->bc, block, NELLY_BLOCK_LEN);\n92         bitstream_skip(&s->bc, NELLY_HEADER_BITS + i * NELLY_DETAIL_BITS);\n93\n94         for (j = 0; j < NELLY_FILL_LEN; j++) {\n95             if (bits[j] <= 0) {\n96                 aptr[j] = M_SQRT1_2*pows[j];\n97                 if (av_lfg_get(&s->random_state) & 1)\n98                     aptr[j] *= -1.0;\n99             } else {\n100                 v = bitstream_read(&s->bc, bits[j]);\n101                 aptr[j] = ff_nelly_dequantization_table[(1<<bits[j])-1+v]*pows[j];\n102             }\n103         }\n104         memset(&aptr[NELLY_FILL_LEN], 0,\n105                (NELLY_BUF_LEN - NELLY_FILL_LEN) * sizeof(float));\n106\n107         s->imdct_ctx.imdct_half(&s->imdct_ctx, s->imdct_out, aptr);\n108         s->fdsp.vector_fmul_window(aptr, s->imdct_prev + NELLY_BUF_LEN / 2,\n109                                    s->imdct_out, ff_sine_128,\n110                                    NELLY_BUF_LEN / 2);\n111         FFSWAP(float *, s->imdct_out, s->imdct_prev);\n112     }\n113 }"
                    }
                ]
            }
        ],
        "sink": "big_off = last_off;",
        "final_sink": "big_off = last_off;"
    },
    {
        "prt": "duration",
        "function_call": [
            "static int mov_write_sidx_tag(AVIOContext *pb,\n                              MOVTrack *track, int ref_size, int total_sidx_size)\n{\n    int64_t pos = avio_tell(pb), offset_pos, end_pos;\n    int64_t presentation_time, duration, offset;\n    int starts_with_SAP, i, entries;\n\n    if (track->entry) {\n        entries = 1;\n        presentation_time = track->start_dts + track->frag_start +\n                            track->cluster[0].cts;\n        duration = track->end_pts -\n                   (track->cluster[0].dts + track->cluster[0].cts);\n        starts_with_SAP = track->cluster[0].flags & MOV_SYNC_SAMPLE;\n\n        // pts<0 should be cut away using edts\n        if (presentation_time < 0) {\n            duration += presentation_time;\n            presentation_time = 0;\n        }\n    } else {\n        entries = track->nb_frag_info;\n        if (entries <= 0)\n            return 0;\n        presentation_time = track->frag_info[0].time;\n    }\n\n    avio_wb32(pb, 0); /* size */\n    ffio_wfourcc(pb, \"sidx\");\n    avio_w8(pb, 1); /* version */\n    avio_wb24(pb, 0);\n    avio_wb32(pb, track->track_id); /* reference_ID */\n    avio_wb32(pb, track->timescale); /* timescale */\n    avio_wb64(pb, presentation_time); /* earliest_presentation_time */\n    offset_pos = avio_tell(pb);\n    avio_wb64(pb, 0); /* first_offset (offset to referenced moof) */\n    avio_wb16(pb, 0); /* reserved */\n\n    avio_wb16(pb, entries); /* reference_count */\n    for (i = 0; i < entries; i++) {\n        if (!track->entry) {\n            if (i > 1 && track->frag_info[i].offset != track->frag_info[i - 1].offset + track->frag_info[i - 1].size) {\n               av_log(NULL, AV_LOG_ERROR, \"Non-consecutive fragments, writing incorrect sidx\\n\");\n            }\n            duration = track->frag_info[i].duration;\n            ref_size = track->frag_info[i].size;\n            starts_with_SAP = 1;\n        }\n        avio_wb32(pb, (0 << 31) | (ref_size & 0x7fffffff)); /* reference_type (0 = media) | referenced_size */\n        avio_wb32(pb, duration); /* subsegment_duration */\n        avio_wb32(pb, (starts_with_SAP << 31) | (0 << 28) | 0); /* starts_with_SAP | SAP_type | SAP_delta_time */\n    }\n\n    end_pos = avio_tell(pb);\n    offset = pos + total_sidx_size - end_pos;\n    avio_seek(pb, offset_pos, SEEK_SET);\n    avio_wb64(pb, offset);\n    avio_seek(pb, end_pos, SEEK_SET);\n    return update_size(pb, pos);\n}"
        ],
        "source": [
            "    int64_t presentation_time, duration, offset;"
        ],
        "index": 42,
        "location": {
            "file_path": "libavformat/movenc.c",
            "region": {
                "startLine": 2821,
                "startColumn": 9,
                "endColumn": 17
            },
            "context": {
                "startLine": 2819,
                "endLine": 2823,
                "snippet": {
                    "text": "avio_wb32(pb, duration); /* subsegment_duration */"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/libavformat/aviobuf.c",
                        "function_body": "336 void avio_wb32(AVIOContext *s, unsigned int val)\n337 {\n338     avio_w8(s, val >> 24);\n339     avio_w8(s, val >> 16);\n340     avio_w8(s, val >> 8);\n341     avio_w8(s, val);\n342 }"
                    },
                    {
                        "file_path": "/libavformat/movenc.c",
                        "function_body": "2772 static int mov_write_sidx_tag(AVIOContext *pb,\n2773                               MOVTrack *track, int ref_size, int total_sidx_size)\n2774 {\n2775     int64_t pos = avio_tell(pb), offset_pos, end_pos;\n2776     int64_t presentation_time, duration, offset;\n2777     int starts_with_SAP, i, entries;\n2778\n2779     if (track->entry) {\n2780         entries = 1;\n2781         presentation_time = track->start_dts + track->frag_start +\n2782                             track->cluster[0].cts;\n2783         duration = track->end_pts -\n2784                    (track->cluster[0].dts + track->cluster[0].cts);\n2785         starts_with_SAP = track->cluster[0].flags & MOV_SYNC_SAMPLE;\n2786\n2787         // pts<0 should be cut away using edts\n2788         if (presentation_time < 0) {\n2789             duration += presentation_time;\n2790             presentation_time = 0;\n2791         }\n2792     } else {\n2793         entries = track->nb_frag_info;\n2794         if (entries <= 0)\n2795             return 0;\n2796         presentation_time = track->frag_info[0].time;\n2797     }\n2798\n2799     avio_wb32(pb, 0); /* size */\n2800     ffio_wfourcc(pb, \"sidx\");\n2801     avio_w8(pb, 1); /* version */\n2802     avio_wb24(pb, 0);\n2803     avio_wb32(pb, track->track_id); /* reference_ID */\n2804     avio_wb32(pb, track->timescale); /* timescale */\n2805     avio_wb64(pb, presentation_time); /* earliest_presentation_time */\n2806     offset_pos = avio_tell(pb);\n2807     avio_wb64(pb, 0); /* first_offset (offset to referenced moof) */\n2808     avio_wb16(pb, 0); /* reserved */\n2809\n2810     avio_wb16(pb, entries); /* reference_count */\n2811     for (i = 0; i < entries; i++) {\n2812         if (!track->entry) {\n2813             if (i > 1 && track->frag_info[i].offset != track->frag_info[i - 1].offset + track->frag_info[i - 1].size) {\n2814                av_log(NULL, AV_LOG_ERROR, \"Non-consecutive fragments, writing incorrect sidx\\n\");\n2815             }\n2816             duration = track->frag_info[i].duration;\n2817             ref_size = track->frag_info[i].size;\n2818             starts_with_SAP = 1;\n2819         }\n2820         avio_wb32(pb, (0 << 31) | (ref_size & 0x7fffffff)); /* reference_type (0 = media) | referenced_size */\n2821         avio_wb32(pb, duration); /* subsegment_duration */\n2822         avio_wb32(pb, (starts_with_SAP << 31) | (0 << 28) | 0); /* starts_with_SAP | SAP_type | SAP_delta_time */\n2823     }\n2824\n2825     end_pos = avio_tell(pb);\n2826     offset = pos + total_sidx_size - end_pos;\n2827     avio_seek(pb, offset_pos, SEEK_SET);\n2828     avio_wb64(pb, offset);\n2829     avio_seek(pb, end_pos, SEEK_SET);\n2830     return update_size(pb, pos);\n2831 }"
                    },
                    {
                        "file_path": "/libavformat/movenc.c",
                        "function_body": "2833 static int mov_write_sidx_tags(AVIOContext *pb, MOVMuxContext *mov,\n2834                                int tracks, int ref_size)\n2835 {\n2836     int i, round, ret;\n2837     AVIOContext *avio_buf;\n2838     int total_size = 0;\n2839     for (round = 0; round < 2; round++) {\n2840         // First run one round to calculate the total size of all\n2841         // sidx atoms.\n2842         // This would be much simpler if we'd only write one sidx\n2843         // atom, for the first track in the moof.\n2844         if (round == 0) {\n2845             if ((ret = ffio_open_null_buf(&avio_buf)) < 0)\n2846                 return ret;\n2847         } else {\n2848             avio_buf = pb;\n2849         }\n2850         for (i = 0; i < mov->nb_streams; i++) {\n2851             MOVTrack *track = &mov->tracks[i];\n2852             if (tracks >= 0 && i != tracks)\n2853                 continue;\n2854             // When writing a sidx for the full file, entry is 0, but\n2855             // we want to include all tracks. ref_size is 0 in this case,\n2856             // since we read it from frag_info instead.\n2857             if (!track->entry && ref_size > 0)\n2858                 continue;\n2859             total_size -= mov_write_sidx_tag(avio_buf, track, ref_size,\n2860                                              total_size);\n2861         }\n2862         if (round == 0)\n2863             total_size = ffio_close_null_buf(avio_buf);\n2864     }\n2865     return 0;\n2866 }"
                    }
                ]
            }
        ],
        "sink": "avio_wb32(pb, duration); /* subsegment_duration */",
        "final_sink": "avio_wb32(pb, duration); /* subsegment_duration */"
    },
    {
        "prt": "res",
        "function_call": [
            "int ossl_crypto_xts128gb_encrypt(const XTS128_CONTEXT *ctx,\n                                 const unsigned char iv[16],\n                                 const unsigned char *inp, unsigned char *out,\n                                 size_t len, int enc)\n{\n    DECLARE_IS_ENDIAN;\n    union {\n        u64 u[2];\n        u32 d[4];\n        u8 c[16];\n    } tweak, scratch;\n    unsigned int i;\n\n    if (len < 16)\n        return -1;\n\n    memcpy(tweak.c, iv, 16);\n\n    (*ctx->block2) (tweak.c, tweak.c, ctx->key2);\n\n    if (!enc && (len % 16))\n        len -= 16;\n\n    while (len >= 16) {\n#if defined(STRICT_ALIGNMENT)\n        memcpy(scratch.c, inp, 16);\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n#else\n        scratch.u[0] = ((u64_a1 *)inp)[0] ^ tweak.u[0];\n        scratch.u[1] = ((u64_a1 *)inp)[1] ^ tweak.u[1];\n#endif\n        (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n#if defined(STRICT_ALIGNMENT)\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        memcpy(out, scratch.c, 16);\n#else\n        ((u64_a1 *)out)[0] = scratch.u[0] ^= tweak.u[0];\n        ((u64_a1 *)out)[1] = scratch.u[1] ^= tweak.u[1];\n#endif\n        inp += 16;\n        out += 16;\n        len -= 16;\n\n        if (len == 0)\n            return 0;\n\n        if (IS_LITTLE_ENDIAN) {\n            u8 res;\n            u64 hi, lo;\n#ifdef BSWAP8\n            hi = BSWAP8(tweak.u[0]);\n            lo = BSWAP8(tweak.u[1]);\n#else\n            u8 *p = tweak.c;\n\n            hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n            lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n#endif\n            res = (u8)lo & 1;\n            tweak.u[0] = (lo >> 1) | (hi << 63);\n            tweak.u[1] = hi >> 1;\n            if (res)\n                tweak.c[15] ^= 0xe1;\n#ifdef BSWAP8\n            hi = BSWAP8(tweak.u[0]);\n            lo = BSWAP8(tweak.u[1]);\n#else\n            p = tweak.c;\n\n            hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n            lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n#endif\n            tweak.u[0] = lo;\n            tweak.u[1] = hi;\n        } else {\n            u8 carry, res;\n            carry = 0;\n            for (i = 0; i < 16; ++i) {\n                res = (tweak.c[i] << 7) & 0x80;\n                tweak.c[i] = ((tweak.c[i] >> 1) + carry) & 0xff;\n                carry = res;\n            }\n            if (res)\n                tweak.c[0] ^= 0xe1;\n        }\n    }\n    if (enc) {\n        for (i = 0; i < len; ++i) {\n            u8 c = inp[i];\n            out[i] = scratch.c[i];\n            scratch.c[i] = c;\n        }\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        memcpy(out - 16, scratch.c, 16);\n    } else {\n        union {\n            u64 u[2];\n            u8 c[16];\n        } tweak1;\n\n        if (IS_LITTLE_ENDIAN) {\n            u8 res;\n            u64 hi, lo;\n#ifdef BSWAP8\n            hi = BSWAP8(tweak.u[0]);\n            lo = BSWAP8(tweak.u[1]);\n#else\n            u8 *p = tweak.c;\n\n            hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n            lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n#endif\n            res = (u8)lo & 1;\n            tweak1.u[0] = (lo >> 1) | (hi << 63);\n            tweak1.u[1] = hi >> 1;\n            if (res)\n                tweak1.c[15] ^= 0xe1;\n#ifdef BSWAP8\n            hi = BSWAP8(tweak1.u[0]);\n            lo = BSWAP8(tweak1.u[1]);\n#else\n            p = tweak1.c;\n\n            hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n            lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n#endif\n            tweak1.u[0] = lo;\n            tweak1.u[1] = hi;\n        } else {\n            u8 carry, res;\n            carry = 0;\n            for (i = 0; i < 16; ++i) {\n                res = (tweak.c[i] << 7) & 0x80;\n                tweak1.c[i] = ((tweak.c[i] >> 1) + carry) & 0xff;\n                carry = res;\n            }\n            if (res)\n                tweak1.c[0] ^= 0xe1;\n        }\n#if defined(STRICT_ALIGNMENT)\n        memcpy(scratch.c, inp, 16);\n        scratch.u[0] ^= tweak1.u[0];\n        scratch.u[1] ^= tweak1.u[1];\n#else\n        scratch.u[0] = ((u64_a1 *)inp)[0] ^ tweak1.u[0];\n        scratch.u[1] = ((u64_a1 *)inp)[1] ^ tweak1.u[1];\n#endif\n        (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n        scratch.u[0] ^= tweak1.u[0];\n        scratch.u[1] ^= tweak1.u[1];\n\n        for (i = 0; i < len; ++i) {\n            u8 c = inp[16 + i];\n            out[16 + i] = scratch.c[i];\n            scratch.c[i] = c;\n        }\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n#if defined(STRICT_ALIGNMENT)\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        memcpy(out, scratch.c, 16);\n#else\n        ((u64_a1 *)out)[0] = scratch.u[0] ^ tweak.u[0];\n        ((u64_a1 *)out)[1] = scratch.u[1] ^ tweak.u[1];\n#endif\n    }\n\n    return 0;\n}"
        ],
        "source": "            u8 carry, res;",
        "index": 43,
        "location": {
            "file_path": "crypto/modes/xts128gb.c",
            "region": {
                "startLine": 107,
                "startColumn": 17,
                "endColumn": 20
            },
            "context": {
                "startLine": 105,
                "endLine": 109,
                "snippet": {
                    "text": "if (res)"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/crypto/modes/xts128gb.c",
                        "function_body": "23  int ossl_crypto_xts128gb_encrypt(const XTS128_CONTEXT *ctx,\n24                                   const unsigned char iv[16],\n25                                   const unsigned char *inp, unsigned char *out,\n26                                   size_t len, int enc)\n27  {\n28      DECLARE_IS_ENDIAN;\n29      union {\n30          u64 u[2];\n31          u32 d[4];\n32          u8 c[16];\n33      } tweak, scratch;\n34      unsigned int i;\n35\n36      if (len < 16)\n37          return -1;\n38\n39      memcpy(tweak.c, iv, 16);\n40\n41      (*ctx->block2) (tweak.c, tweak.c, ctx->key2);\n42\n43      if (!enc && (len % 16))\n44          len -= 16;\n45\n46      while (len >= 16) {\n47  #if defined(STRICT_ALIGNMENT)\n48          memcpy(scratch.c, inp, 16);\n49          scratch.u[0] ^= tweak.u[0];\n50          scratch.u[1] ^= tweak.u[1];\n51  #else\n52          scratch.u[0] = ((u64_a1 *)inp)[0] ^ tweak.u[0];\n53          scratch.u[1] = ((u64_a1 *)inp)[1] ^ tweak.u[1];\n54  #endif\n55          (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n56  #if defined(STRICT_ALIGNMENT)\n57          scratch.u[0] ^= tweak.u[0];\n58          scratch.u[1] ^= tweak.u[1];\n59          memcpy(out, scratch.c, 16);\n60  #else\n61          ((u64_a1 *)out)[0] = scratch.u[0] ^= tweak.u[0];\n62          ((u64_a1 *)out)[1] = scratch.u[1] ^= tweak.u[1];\n63  #endif\n64          inp += 16;\n65          out += 16;\n66          len -= 16;\n67\n68          if (len == 0)\n69              return 0;\n70\n71          if (IS_LITTLE_ENDIAN) {\n72              u8 res;\n73              u64 hi, lo;\n74  #ifdef BSWAP8\n75              hi = BSWAP8(tweak.u[0]);\n76              lo = BSWAP8(tweak.u[1]);\n77  #else\n78              u8 *p = tweak.c;\n79\n80              hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n81              lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n82  #endif\n83              res = (u8)lo & 1;\n84              tweak.u[0] = (lo >> 1) | (hi << 63);\n85              tweak.u[1] = hi >> 1;\n86              if (res)\n87                  tweak.c[15] ^= 0xe1;\n88  #ifdef BSWAP8\n89              hi = BSWAP8(tweak.u[0]);\n90              lo = BSWAP8(tweak.u[1]);\n91  #else\n92              p = tweak.c;\n93\n94              hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n95              lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n96  #endif\n97              tweak.u[0] = lo;\n98              tweak.u[1] = hi;\n99          } else {\n100             u8 carry, res;\n101             carry = 0;\n102             for (i = 0; i < 16; ++i) {\n103                 res = (tweak.c[i] << 7) & 0x80;\n104                 tweak.c[i] = ((tweak.c[i] >> 1) + carry) & 0xff;\n105                 carry = res;\n106             }\n107             if (res)\n108                 tweak.c[0] ^= 0xe1;\n109         }\n110     }\n111     if (enc) {\n112         for (i = 0; i < len; ++i) {\n113             u8 c = inp[i];\n114             out[i] = scratch.c[i];\n115             scratch.c[i] = c;\n116         }\n117         scratch.u[0] ^= tweak.u[0];\n118         scratch.u[1] ^= tweak.u[1];\n119         (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n120         scratch.u[0] ^= tweak.u[0];\n121         scratch.u[1] ^= tweak.u[1];\n122         memcpy(out - 16, scratch.c, 16);\n123     } else {\n124         union {\n125             u64 u[2];\n126             u8 c[16];\n127         } tweak1;\n128\n129         if (IS_LITTLE_ENDIAN) {\n130             u8 res;\n131             u64 hi, lo;\n132 #ifdef BSWAP8\n133             hi = BSWAP8(tweak.u[0]);\n134             lo = BSWAP8(tweak.u[1]);\n135 #else\n136             u8 *p = tweak.c;\n137\n138             hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n139             lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n140 #endif\n141             res = (u8)lo & 1;\n142             tweak1.u[0] = (lo >> 1) | (hi << 63);\n143             tweak1.u[1] = hi >> 1;\n144             if (res)\n145                 tweak1.c[15] ^= 0xe1;\n146 #ifdef BSWAP8\n147             hi = BSWAP8(tweak1.u[0]);\n148             lo = BSWAP8(tweak1.u[1]);\n149 #else\n150             p = tweak1.c;\n151\n152             hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n153             lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n154 #endif\n155             tweak1.u[0] = lo;\n156             tweak1.u[1] = hi;\n157         } else {\n158             u8 carry, res;\n159             carry = 0;\n160             for (i = 0; i < 16; ++i) {\n161                 res = (tweak.c[i] << 7) & 0x80;\n162                 tweak1.c[i] = ((tweak.c[i] >> 1) + carry) & 0xff;\n163                 carry = res;\n164             }\n165             if (res)\n166                 tweak1.c[0] ^= 0xe1;\n167         }\n168 #if defined(STRICT_ALIGNMENT)\n169         memcpy(scratch.c, inp, 16);\n170         scratch.u[0] ^= tweak1.u[0];\n171         scratch.u[1] ^= tweak1.u[1];\n172 #else\n173         scratch.u[0] = ((u64_a1 *)inp)[0] ^ tweak1.u[0];\n174         scratch.u[1] = ((u64_a1 *)inp)[1] ^ tweak1.u[1];\n175 #endif\n176         (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n177         scratch.u[0] ^= tweak1.u[0];\n178         scratch.u[1] ^= tweak1.u[1];\n179\n180         for (i = 0; i < len; ++i) {\n181             u8 c = inp[16 + i];\n182             out[16 + i] = scratch.c[i];\n183             scratch.c[i] = c;\n184         }\n185         scratch.u[0] ^= tweak.u[0];\n186         scratch.u[1] ^= tweak.u[1];\n187         (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n188 #if defined(STRICT_ALIGNMENT)\n189         scratch.u[0] ^= tweak.u[0];\n190         scratch.u[1] ^= tweak.u[1];\n191         memcpy(out, scratch.c, 16);\n192 #else\n193         ((u64_a1 *)out)[0] = scratch.u[0] ^ tweak.u[0];\n194         ((u64_a1 *)out)[1] = scratch.u[1] ^ tweak.u[1];\n195 #endif\n196     }\n197\n198     return 0;\n199 }"
                    },
                    {
                        "file_path": "/providers/implementations/ciphers/cipher_sm4_xts.c",
                        "function_body": "121 static int sm4_xts_cipher(void *vctx, unsigned char *out, size_t *outl,\n122                           size_t outsize, const unsigned char *in, size_t inl)\n123 {\n124     PROV_SM4_XTS_CTX *ctx = (PROV_SM4_XTS_CTX *)vctx;\n125\n126     if (!ossl_prov_is_running()\n127             || ctx->xts.key1 == NULL\n128             || ctx->xts.key2 == NULL\n129             || !ctx->base.iv_set\n130             || out == NULL\n131             || in == NULL\n132             || inl < SM4_BLOCK_SIZE)\n133         return 0;\n134\n135     /*\n136      * Impose a limit of 2^20 blocks per data unit as specified by\n137      * IEEE Std 1619-2018.  The earlier and obsolete IEEE Std 1619-2007\n138      * indicated that this was a SHOULD NOT rather than a MUST NOT.\n139      * NIST SP 800-38E mandates the same limit.\n140      */\n141     if (inl > XTS_MAX_BLOCKS_PER_DATA_UNIT * SM4_BLOCK_SIZE) {\n142         ERR_raise(ERR_LIB_PROV, PROV_R_XTS_DATA_UNIT_IS_TOO_LARGE);\n143         return 0;\n144     }\n145     if (ctx->xts_standard) {\n146         if (ctx->stream != NULL)\n147             (*ctx->stream)(in, out, inl, ctx->xts.key1, ctx->xts.key2,\n148                            ctx->base.iv, ctx->base.enc);\n149         else if (CRYPTO_xts128_encrypt(&ctx->xts, ctx->base.iv, in, out, inl,\n150                                        ctx->base.enc))\n151             return 0;\n152     } else {\n153         if (ctx->stream_gb != NULL)\n154             (*ctx->stream_gb)(in, out, inl, ctx->xts.key1, ctx->xts.key2,\n155                               ctx->base.iv, ctx->base.enc);\n156         else if (ossl_crypto_xts128gb_encrypt(&ctx->xts, ctx->base.iv, in, out,\n157                                               inl, ctx->base.enc))\n158             return 0;\n159     }\n160     *outl = inl;\n161     return 1;\n162 }"
                    }
                ]
            }
        ],
        "sink": "if (res)",
        "final_sink": "if (res)"
    },
    {
        "prt": "res",
        "function_call": [
            "int ossl_crypto_xts128gb_encrypt(const XTS128_CONTEXT *ctx,\n                                 const unsigned char iv[16],\n                                 const unsigned char *inp, unsigned char *out,\n                                 size_t len, int enc)\n{\n    DECLARE_IS_ENDIAN;\n    union {\n        u64 u[2];\n        u32 d[4];\n        u8 c[16];\n    } tweak, scratch;\n    unsigned int i;\n\n    if (len < 16)\n        return -1;\n\n    memcpy(tweak.c, iv, 16);\n\n    (*ctx->block2) (tweak.c, tweak.c, ctx->key2);\n\n    if (!enc && (len % 16))\n        len -= 16;\n\n    while (len >= 16) {\n#if defined(STRICT_ALIGNMENT)\n        memcpy(scratch.c, inp, 16);\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n#else\n        scratch.u[0] = ((u64_a1 *)inp)[0] ^ tweak.u[0];\n        scratch.u[1] = ((u64_a1 *)inp)[1] ^ tweak.u[1];\n#endif\n        (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n#if defined(STRICT_ALIGNMENT)\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        memcpy(out, scratch.c, 16);\n#else\n        ((u64_a1 *)out)[0] = scratch.u[0] ^= tweak.u[0];\n        ((u64_a1 *)out)[1] = scratch.u[1] ^= tweak.u[1];\n#endif\n        inp += 16;\n        out += 16;\n        len -= 16;\n\n        if (len == 0)\n            return 0;\n\n        if (IS_LITTLE_ENDIAN) {\n            u8 res;\n            u64 hi, lo;\n#ifdef BSWAP8\n            hi = BSWAP8(tweak.u[0]);\n            lo = BSWAP8(tweak.u[1]);\n#else\n            u8 *p = tweak.c;\n\n            hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n            lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n#endif\n            res = (u8)lo & 1;\n            tweak.u[0] = (lo >> 1) | (hi << 63);\n            tweak.u[1] = hi >> 1;\n            if (res)\n                tweak.c[15] ^= 0xe1;\n#ifdef BSWAP8\n            hi = BSWAP8(tweak.u[0]);\n            lo = BSWAP8(tweak.u[1]);\n#else\n            p = tweak.c;\n\n            hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n            lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n#endif\n            tweak.u[0] = lo;\n            tweak.u[1] = hi;\n        } else {\n            u8 carry, res;\n            carry = 0;\n            for (i = 0; i < 16; ++i) {\n                res = (tweak.c[i] << 7) & 0x80;\n                tweak.c[i] = ((tweak.c[i] >> 1) + carry) & 0xff;\n                carry = res;\n            }\n            if (res)\n                tweak.c[0] ^= 0xe1;\n        }\n    }\n    if (enc) {\n        for (i = 0; i < len; ++i) {\n            u8 c = inp[i];\n            out[i] = scratch.c[i];\n            scratch.c[i] = c;\n        }\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        memcpy(out - 16, scratch.c, 16);\n    } else {\n        union {\n            u64 u[2];\n            u8 c[16];\n        } tweak1;\n\n        if (IS_LITTLE_ENDIAN) {\n            u8 res;\n            u64 hi, lo;\n#ifdef BSWAP8\n            hi = BSWAP8(tweak.u[0]);\n            lo = BSWAP8(tweak.u[1]);\n#else\n            u8 *p = tweak.c;\n\n            hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n            lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n#endif\n            res = (u8)lo & 1;\n            tweak1.u[0] = (lo >> 1) | (hi << 63);\n            tweak1.u[1] = hi >> 1;\n            if (res)\n                tweak1.c[15] ^= 0xe1;\n#ifdef BSWAP8\n            hi = BSWAP8(tweak1.u[0]);\n            lo = BSWAP8(tweak1.u[1]);\n#else\n            p = tweak1.c;\n\n            hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n            lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n#endif\n            tweak1.u[0] = lo;\n            tweak1.u[1] = hi;\n        } else {\n            u8 carry, res;\n            carry = 0;\n            for (i = 0; i < 16; ++i) {\n                res = (tweak.c[i] << 7) & 0x80;\n                tweak1.c[i] = ((tweak.c[i] >> 1) + carry) & 0xff;\n                carry = res;\n            }\n            if (res)\n                tweak1.c[0] ^= 0xe1;\n        }\n#if defined(STRICT_ALIGNMENT)\n        memcpy(scratch.c, inp, 16);\n        scratch.u[0] ^= tweak1.u[0];\n        scratch.u[1] ^= tweak1.u[1];\n#else\n        scratch.u[0] = ((u64_a1 *)inp)[0] ^ tweak1.u[0];\n        scratch.u[1] = ((u64_a1 *)inp)[1] ^ tweak1.u[1];\n#endif\n        (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n        scratch.u[0] ^= tweak1.u[0];\n        scratch.u[1] ^= tweak1.u[1];\n\n        for (i = 0; i < len; ++i) {\n            u8 c = inp[16 + i];\n            out[16 + i] = scratch.c[i];\n            scratch.c[i] = c;\n        }\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n#if defined(STRICT_ALIGNMENT)\n        scratch.u[0] ^= tweak.u[0];\n        scratch.u[1] ^= tweak.u[1];\n        memcpy(out, scratch.c, 16);\n#else\n        ((u64_a1 *)out)[0] = scratch.u[0] ^ tweak.u[0];\n        ((u64_a1 *)out)[1] = scratch.u[1] ^ tweak.u[1];\n#endif\n    }\n\n    return 0;\n}"
        ],
        "source": "            u8 carry, res;",
        "index": 44,
        "location": {
            "file_path": "crypto/modes/xts128gb.c",
            "region": {
                "startLine": 165,
                "startColumn": 17,
                "endColumn": 20
            },
            "context": {
                "startLine": 163,
                "endLine": 167,
                "snippet": {
                    "text": "if (res)"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/crypto/modes/xts128gb.c",
                        "function_body": "23  int ossl_crypto_xts128gb_encrypt(const XTS128_CONTEXT *ctx,\n24                                   const unsigned char iv[16],\n25                                   const unsigned char *inp, unsigned char *out,\n26                                   size_t len, int enc)\n27  {\n28      DECLARE_IS_ENDIAN;\n29      union {\n30          u64 u[2];\n31          u32 d[4];\n32          u8 c[16];\n33      } tweak, scratch;\n34      unsigned int i;\n35\n36      if (len < 16)\n37          return -1;\n38\n39      memcpy(tweak.c, iv, 16);\n40\n41      (*ctx->block2) (tweak.c, tweak.c, ctx->key2);\n42\n43      if (!enc && (len % 16))\n44          len -= 16;\n45\n46      while (len >= 16) {\n47  #if defined(STRICT_ALIGNMENT)\n48          memcpy(scratch.c, inp, 16);\n49          scratch.u[0] ^= tweak.u[0];\n50          scratch.u[1] ^= tweak.u[1];\n51  #else\n52          scratch.u[0] = ((u64_a1 *)inp)[0] ^ tweak.u[0];\n53          scratch.u[1] = ((u64_a1 *)inp)[1] ^ tweak.u[1];\n54  #endif\n55          (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n56  #if defined(STRICT_ALIGNMENT)\n57          scratch.u[0] ^= tweak.u[0];\n58          scratch.u[1] ^= tweak.u[1];\n59          memcpy(out, scratch.c, 16);\n60  #else\n61          ((u64_a1 *)out)[0] = scratch.u[0] ^= tweak.u[0];\n62          ((u64_a1 *)out)[1] = scratch.u[1] ^= tweak.u[1];\n63  #endif\n64          inp += 16;\n65          out += 16;\n66          len -= 16;\n67\n68          if (len == 0)\n69              return 0;\n70\n71          if (IS_LITTLE_ENDIAN) {\n72              u8 res;\n73              u64 hi, lo;\n74  #ifdef BSWAP8\n75              hi = BSWAP8(tweak.u[0]);\n76              lo = BSWAP8(tweak.u[1]);\n77  #else\n78              u8 *p = tweak.c;\n79\n80              hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n81              lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n82  #endif\n83              res = (u8)lo & 1;\n84              tweak.u[0] = (lo >> 1) | (hi << 63);\n85              tweak.u[1] = hi >> 1;\n86              if (res)\n87                  tweak.c[15] ^= 0xe1;\n88  #ifdef BSWAP8\n89              hi = BSWAP8(tweak.u[0]);\n90              lo = BSWAP8(tweak.u[1]);\n91  #else\n92              p = tweak.c;\n93\n94              hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n95              lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n96  #endif\n97              tweak.u[0] = lo;\n98              tweak.u[1] = hi;\n99          } else {\n100             u8 carry, res;\n101             carry = 0;\n102             for (i = 0; i < 16; ++i) {\n103                 res = (tweak.c[i] << 7) & 0x80;\n104                 tweak.c[i] = ((tweak.c[i] >> 1) + carry) & 0xff;\n105                 carry = res;\n106             }\n107             if (res)\n108                 tweak.c[0] ^= 0xe1;\n109         }\n110     }\n111     if (enc) {\n112         for (i = 0; i < len; ++i) {\n113             u8 c = inp[i];\n114             out[i] = scratch.c[i];\n115             scratch.c[i] = c;\n116         }\n117         scratch.u[0] ^= tweak.u[0];\n118         scratch.u[1] ^= tweak.u[1];\n119         (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n120         scratch.u[0] ^= tweak.u[0];\n121         scratch.u[1] ^= tweak.u[1];\n122         memcpy(out - 16, scratch.c, 16);\n123     } else {\n124         union {\n125             u64 u[2];\n126             u8 c[16];\n127         } tweak1;\n128\n129         if (IS_LITTLE_ENDIAN) {\n130             u8 res;\n131             u64 hi, lo;\n132 #ifdef BSWAP8\n133             hi = BSWAP8(tweak.u[0]);\n134             lo = BSWAP8(tweak.u[1]);\n135 #else\n136             u8 *p = tweak.c;\n137\n138             hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n139             lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n140 #endif\n141             res = (u8)lo & 1;\n142             tweak1.u[0] = (lo >> 1) | (hi << 63);\n143             tweak1.u[1] = hi >> 1;\n144             if (res)\n145                 tweak1.c[15] ^= 0xe1;\n146 #ifdef BSWAP8\n147             hi = BSWAP8(tweak1.u[0]);\n148             lo = BSWAP8(tweak1.u[1]);\n149 #else\n150             p = tweak1.c;\n151\n152             hi = (u64)GETU32(p) << 32 | GETU32(p + 4);\n153             lo = (u64)GETU32(p + 8) << 32 | GETU32(p + 12);\n154 #endif\n155             tweak1.u[0] = lo;\n156             tweak1.u[1] = hi;\n157         } else {\n158             u8 carry, res;\n159             carry = 0;\n160             for (i = 0; i < 16; ++i) {\n161                 res = (tweak.c[i] << 7) & 0x80;\n162                 tweak1.c[i] = ((tweak.c[i] >> 1) + carry) & 0xff;\n163                 carry = res;\n164             }\n165             if (res)\n166                 tweak1.c[0] ^= 0xe1;\n167         }\n168 #if defined(STRICT_ALIGNMENT)\n169         memcpy(scratch.c, inp, 16);\n170         scratch.u[0] ^= tweak1.u[0];\n171         scratch.u[1] ^= tweak1.u[1];\n172 #else\n173         scratch.u[0] = ((u64_a1 *)inp)[0] ^ tweak1.u[0];\n174         scratch.u[1] = ((u64_a1 *)inp)[1] ^ tweak1.u[1];\n175 #endif\n176         (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n177         scratch.u[0] ^= tweak1.u[0];\n178         scratch.u[1] ^= tweak1.u[1];\n179\n180         for (i = 0; i < len; ++i) {\n181             u8 c = inp[16 + i];\n182             out[16 + i] = scratch.c[i];\n183             scratch.c[i] = c;\n184         }\n185         scratch.u[0] ^= tweak.u[0];\n186         scratch.u[1] ^= tweak.u[1];\n187         (*ctx->block1) (scratch.c, scratch.c, ctx->key1);\n188 #if defined(STRICT_ALIGNMENT)\n189         scratch.u[0] ^= tweak.u[0];\n190         scratch.u[1] ^= tweak.u[1];\n191         memcpy(out, scratch.c, 16);\n192 #else\n193         ((u64_a1 *)out)[0] = scratch.u[0] ^ tweak.u[0];\n194         ((u64_a1 *)out)[1] = scratch.u[1] ^ tweak.u[1];\n195 #endif\n196     }\n197\n198     return 0;\n199 }"
                    },
                    {
                        "file_path": "/providers/implementations/ciphers/cipher_sm4_xts.c",
                        "function_body": "121 static int sm4_xts_cipher(void *vctx, unsigned char *out, size_t *outl,\n122                           size_t outsize, const unsigned char *in, size_t inl)\n123 {\n124     PROV_SM4_XTS_CTX *ctx = (PROV_SM4_XTS_CTX *)vctx;\n125\n126     if (!ossl_prov_is_running()\n127             || ctx->xts.key1 == NULL\n128             || ctx->xts.key2 == NULL\n129             || !ctx->base.iv_set\n130             || out == NULL\n131             || in == NULL\n132             || inl < SM4_BLOCK_SIZE)\n133         return 0;\n134\n135     /*\n136      * Impose a limit of 2^20 blocks per data unit as specified by\n137      * IEEE Std 1619-2018.  The earlier and obsolete IEEE Std 1619-2007\n138      * indicated that this was a SHOULD NOT rather than a MUST NOT.\n139      * NIST SP 800-38E mandates the same limit.\n140      */\n141     if (inl > XTS_MAX_BLOCKS_PER_DATA_UNIT * SM4_BLOCK_SIZE) {\n142         ERR_raise(ERR_LIB_PROV, PROV_R_XTS_DATA_UNIT_IS_TOO_LARGE);\n143         return 0;\n144     }\n145     if (ctx->xts_standard) {\n146         if (ctx->stream != NULL)\n147             (*ctx->stream)(in, out, inl, ctx->xts.key1, ctx->xts.key2,\n148                            ctx->base.iv, ctx->base.enc);\n149         else if (CRYPTO_xts128_encrypt(&ctx->xts, ctx->base.iv, in, out, inl,\n150                                        ctx->base.enc))\n151             return 0;\n152     } else {\n153         if (ctx->stream_gb != NULL)\n154             (*ctx->stream_gb)(in, out, inl, ctx->xts.key1, ctx->xts.key2,\n155                               ctx->base.iv, ctx->base.enc);\n156         else if (ossl_crypto_xts128gb_encrypt(&ctx->xts, ctx->base.iv, in, out,\n157                                               inl, ctx->base.enc))\n158             return 0;\n159     }\n160     *outl = inl;\n161     return 1;\n162 }"
                    }
                ]
            }
        ],
        "sink": "if (res)",
        "final_sink": "if (res)"
    },
    {
        "prt": "aa[_]",
        "function_call": [
            "void ossl_gf_mul(gf_s * RESTRICT cs, const gf as, const gf bs)\n{\n    const uint64_t *a = as->limb, *b = bs->limb;\n    uint64_t *c = cs->limb;\n    uint128_t accum0 = 0, accum1 = 0, accum2;\n    uint64_t mask = (1ULL << 56) - 1;\n    uint64_t aa[4], bb[4], bbb[4];\n    unsigned int i, j;\n\n    for (i = 0; i < 4; i++) {\n        aa[i] = a[i] + a[i + 4];\n        bb[i] = b[i] + b[i + 4];\n        bbb[i] = bb[i] + b[i + 4];\n    }\n\n    for (i = 0; i < 4; i++) {\n        accum2 = 0;\n\n        for (j = 0; j <= i; j++) {\n            accum2 += widemul(a[j], b[i - j]);\n            accum1 += widemul(aa[j], bb[i - j]);\n            accum0 += widemul(a[j + 4], b[i - j + 4]);\n        }\n        for (; j < 4; j++) {\n            accum2 += widemul(a[j], b[i + 8 - j]);\n            accum1 += widemul(aa[j], bbb[i + 4 - j]);\n            accum0 += widemul(a[j + 4], bb[i + 4 - j]);\n        }\n\n        accum1 -= accum2;\n        accum0 += accum2;\n\n        c[i] = ((uint64_t)(accum0)) & mask;\n        c[i + 4] = ((uint64_t)(accum1)) & mask;\n\n        accum0 >>= 56;\n        accum1 >>= 56;\n    }\n\n    accum0 += accum1;\n    accum0 += c[4];\n    accum1 += c[0];\n    c[4] = ((uint64_t)(accum0)) & mask;\n    c[0] = ((uint64_t)(accum1)) & mask;\n\n    accum0 >>= 56;\n    accum1 >>= 56;\n\n    c[5] += ((uint64_t)(accum0));\n    c[1] += ((uint64_t)(accum1));\n}"
        ],
        "source": [
            "    uint64_t aa[4], bb[4], bbb[4];"
        ],
        "index": 45,
        "location": {
            "file_path": "crypto/ec/curve448/arch_64/f_impl64.c",
            "region": {
                "startLine": 44,
                "startColumn": 23,
                "endColumn": 28
            },
            "context": {
                "startLine": 42,
                "endLine": 46,
                "snippet": {
                    "text": "accum1 += widemul(aa[j], bb[i - j]);"
                }
            }
        },
        "result": 0,
        "baseline_context": [],
        "sink": "accum1 += widemul(aa[j], bb[i - j]);",
        "final_sink": "accum1 += widemul(aa[j], bb[i - j]);"
    },
    {
        "prt": "aa[_]",
        "function_call": [
            "void ossl_gf_mul(gf_s * RESTRICT cs, const gf as, const gf bs)\n{\n    const uint64_t *a = as->limb, *b = bs->limb;\n    uint64_t *c = cs->limb;\n    uint128_t accum0 = 0, accum1 = 0, accum2;\n    uint64_t mask = (1ULL << 56) - 1;\n    uint64_t aa[4], bb[4], bbb[4];\n    unsigned int i, j;\n\n    for (i = 0; i < 4; i++) {\n        aa[i] = a[i] + a[i + 4];\n        bb[i] = b[i] + b[i + 4];\n        bbb[i] = bb[i] + b[i + 4];\n    }\n\n    for (i = 0; i < 4; i++) {\n        accum2 = 0;\n\n        for (j = 0; j <= i; j++) {\n            accum2 += widemul(a[j], b[i - j]);\n            accum1 += widemul(aa[j], bb[i - j]);\n            accum0 += widemul(a[j + 4], b[i - j + 4]);\n        }\n        for (; j < 4; j++) {\n            accum2 += widemul(a[j], b[i + 8 - j]);\n            accum1 += widemul(aa[j], bbb[i + 4 - j]);\n            accum0 += widemul(a[j + 4], bb[i + 4 - j]);\n        }\n\n        accum1 -= accum2;\n        accum0 += accum2;\n\n        c[i] = ((uint64_t)(accum0)) & mask;\n        c[i + 4] = ((uint64_t)(accum1)) & mask;\n\n        accum0 >>= 56;\n        accum1 >>= 56;\n    }\n\n    accum0 += accum1;\n    accum0 += c[4];\n    accum1 += c[0];\n    c[4] = ((uint64_t)(accum0)) & mask;\n    c[0] = ((uint64_t)(accum1)) & mask;\n\n    accum0 >>= 56;\n    accum1 >>= 56;\n\n    c[5] += ((uint64_t)(accum0));\n    c[1] += ((uint64_t)(accum1));\n}"
        ],
        "source": [
            "    uint64_t aa[4], bb[4], bbb[4];"
        ],
        "index": 46,
        "location": {
            "file_path": "crypto/ec/curve448/arch_64/f_impl64.c",
            "region": {
                "startLine": 49,
                "startColumn": 23,
                "endColumn": 28
            },
            "context": {
                "startLine": 47,
                "endLine": 51,
                "snippet": {
                    "text": "accum1 += widemul(aa[j], bbb[i + 4 - j]);"
                }
            }
        },
        "result": 0,
        "baseline_context": [],
        "sink": "accum1 += widemul(aa[j], bbb[i + 4 - j]);",
        "final_sink": "accum1 += widemul(aa[j], bbb[i + 4 - j]);"
    },
    {
        "prt": "bb[_]",
        "function_call": [
            "void ossl_gf_mul(gf_s * RESTRICT cs, const gf as, const gf bs)\n{\n    const uint64_t *a = as->limb, *b = bs->limb;\n    uint64_t *c = cs->limb;\n    uint128_t accum0 = 0, accum1 = 0, accum2;\n    uint64_t mask = (1ULL << 56) - 1;\n    uint64_t aa[4], bb[4], bbb[4];\n    unsigned int i, j;\n\n    for (i = 0; i < 4; i++) {\n        aa[i] = a[i] + a[i + 4];\n        bb[i] = b[i] + b[i + 4];\n        bbb[i] = bb[i] + b[i + 4];\n    }\n\n    for (i = 0; i < 4; i++) {\n        accum2 = 0;\n\n        for (j = 0; j <= i; j++) {\n            accum2 += widemul(a[j], b[i - j]);\n            accum1 += widemul(aa[j], bb[i - j]);\n            accum0 += widemul(a[j + 4], b[i - j + 4]);\n        }\n        for (; j < 4; j++) {\n            accum2 += widemul(a[j], b[i + 8 - j]);\n            accum1 += widemul(aa[j], bbb[i + 4 - j]);\n            accum0 += widemul(a[j + 4], bb[i + 4 - j]);\n        }\n\n        accum1 -= accum2;\n        accum0 += accum2;\n\n        c[i] = ((uint64_t)(accum0)) & mask;\n        c[i + 4] = ((uint64_t)(accum1)) & mask;\n\n        accum0 >>= 56;\n        accum1 >>= 56;\n    }\n\n    accum0 += accum1;\n    accum0 += c[4];\n    accum1 += c[0];\n    c[4] = ((uint64_t)(accum0)) & mask;\n    c[0] = ((uint64_t)(accum1)) & mask;\n\n    accum0 >>= 56;\n    accum1 >>= 56;\n\n    c[5] += ((uint64_t)(accum0));\n    c[1] += ((uint64_t)(accum1));\n}"
        ],
        "source": [
            "    uint64_t aa[4], bb[4], bbb[4];"
        ],
        "index": 47,
        "location": {
            "file_path": "crypto/ec/curve448/arch_64/f_impl64.c",
            "region": {
                "startLine": 44,
                "startColumn": 23,
                "endColumn": 28
            },
            "context": {
                "startLine": 42,
                "endLine": 46,
                "snippet": {
                    "text": "accum1 += widemul(aa[j], bb[i - j]);"
                }
            }
        },
        "result": 0,
        "baseline_context": [],
        "sink": "accum1 += widemul(aa[j], bb[i - j]);",
        "final_sink": "accum1 += widemul(aa[j], bb[i - j]);"
    },
    {
        "prt": "mtus[_]",
        "function_call": [
            "static int mtu_test(SSL_CTX *ctx, const char *cs, int no_etm)\n{\n    SSL *srvr_ssl = NULL, *clnt_ssl = NULL;\n    BIO *sc_bio = NULL;\n    int i;\n    size_t s;\n    size_t mtus[30];\n    unsigned char buf[600];\n    int rv = 0;\n    SSL_CONNECTION *clnt_sc;\n\n    memset(buf, 0x5a, sizeof(buf));\n\n    if (!TEST_true(create_ssl_objects(ctx, ctx, &srvr_ssl, &clnt_ssl,\n                                      NULL, NULL)))\n        goto end;\n\n    if (no_etm)\n        SSL_set_options(srvr_ssl, SSL_OP_NO_ENCRYPT_THEN_MAC);\n\n    if (!TEST_true(SSL_set_cipher_list(srvr_ssl, cs))\n            || !TEST_true(SSL_set_cipher_list(clnt_ssl, cs))\n            || !TEST_ptr(sc_bio = SSL_get_rbio(srvr_ssl))\n            || !TEST_true(create_ssl_connection(clnt_ssl, srvr_ssl,\n                                                SSL_ERROR_NONE)))\n        goto end;\n\n    if (debug)\n        TEST_info(\"Channel established\");\n\n    /* For record MTU values between 500 and 539, call DTLS_get_data_mtu()\n     * to query the payload MTU which will fit. */\n    for (i = 0; i < 30; i++) {\n        SSL_set_mtu(clnt_ssl, 500 + i);\n        mtus[i] = DTLS_get_data_mtu(clnt_ssl);\n        if (debug)\n            TEST_info(\"%s%s MTU for record mtu %d = %lu\",\n                      cs, no_etm ? \"-noEtM\" : \"\",\n                      500 + i, (unsigned long)mtus[i]);\n        if (!TEST_size_t_ne(mtus[i], 0)) {\n            TEST_info(\"Cipher %s MTU %d\", cs, 500 + i);\n            goto end;\n        }\n    }\n\n    /* Now get out of the way */\n    SSL_set_mtu(clnt_ssl, 1000);\n\n    /*\n     * Now for all values in the range of payload MTUs, send a payload of\n     * that size and see what actual record size we end up with.\n     */\n    for (s = mtus[0]; s <= mtus[29]; s++) {\n        size_t reclen;\n\n        if (!TEST_int_eq(SSL_write(clnt_ssl, buf, s), (int)s))\n            goto end;\n        reclen = BIO_read(sc_bio, buf, sizeof(buf));\n        if (debug)\n            TEST_info(\"record %zu for payload %zu\", reclen, s);\n\n        for (i = 0; i < 30; i++) {\n            /* DTLS_get_data_mtu() with record MTU 500+i returned mtus[i] ... */\n\n            if (!TEST_false(s <= mtus[i] && reclen > (size_t)(500 + i))) {\n                /*\n                 * We sent a packet smaller than or equal to mtus[j] and\n                 * that made a record *larger* than the record MTU 500+j!\n                 */\n                TEST_error(\"%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d\",\n                           cs, (unsigned long)s, (unsigned long)mtus[i],\n                           (unsigned long)reclen, 500 + i);\n                goto end;\n            }\n            if (!TEST_false(s > mtus[i] && reclen <= (size_t)(500 + i))) {\n                /*\n                 * We sent a *larger* packet than mtus[i] and that *still*\n                 * fits within the record MTU 500+i, so DTLS_get_data_mtu()\n                 * was overly pessimistic.\n                 */\n                TEST_error(\"%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d\",\n                           cs, (unsigned long)s, (unsigned long)mtus[i],\n                           (unsigned long)reclen, 500 + i);\n                goto end;\n            }\n        }\n    }\n    if (!TEST_ptr(clnt_sc = SSL_CONNECTION_FROM_SSL_ONLY(clnt_ssl)))\n        goto end;\n    rv = 1;\n    if (SSL_READ_ETM(clnt_sc))\n        rv = 2;\n end:\n    SSL_free(clnt_ssl);\n    SSL_free(srvr_ssl);\n    return rv;\n}"
        ],
        "source": [
            "    size_t mtus[30];"
        ],
        "index": 48,
        "location": {
            "file_path": "test/dtls_mtu_test.c",
            "region": {
                "startLine": 102,
                "startColumn": 10,
                "endColumn": 17
            },
            "context": {
                "startLine": 100,
                "endLine": 104,
                "snippet": {
                    "text": "for (s = mtus[0]; s <= mtus[29]; s++) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/test/dtls_mtu_test.c",
                        "function_body": "50 static int mtu_test(SSL_CTX *ctx, const char *cs, int no_etm)\n51 {\n52     SSL *srvr_ssl = NULL, *clnt_ssl = NULL;\n53     BIO *sc_bio = NULL;\n54     int i;\n55     size_t s;\n56     size_t mtus[30];\n57     unsigned char buf[600];\n58     int rv = 0;\n59     SSL_CONNECTION *clnt_sc;\n60\n61     memset(buf, 0x5a, sizeof(buf));\n62\n63     if (!TEST_true(create_ssl_objects(ctx, ctx, &srvr_ssl, &clnt_ssl,\n64                                       NULL, NULL)))\n65         goto end;\n66\n67     if (no_etm)\n68         SSL_set_options(srvr_ssl, SSL_OP_NO_ENCRYPT_THEN_MAC);\n69\n70     if (!TEST_true(SSL_set_cipher_list(srvr_ssl, cs))\n71             || !TEST_true(SSL_set_cipher_list(clnt_ssl, cs))\n72             || !TEST_ptr(sc_bio = SSL_get_rbio(srvr_ssl))\n73             || !TEST_true(create_ssl_connection(clnt_ssl, srvr_ssl,\n74                                                 SSL_ERROR_NONE)))\n75         goto end;\n76\n77     if (debug)\n78         TEST_info(\"Channel established\");\n79\n80     /* For record MTU values between 500 and 539, call DTLS_get_data_mtu()\n81      * to query the payload MTU which will fit. */\n82     for (i = 0; i < 30; i++) {\n83         SSL_set_mtu(clnt_ssl, 500 + i);\n84         mtus[i] = DTLS_get_data_mtu(clnt_ssl);\n85         if (debug)\n86             TEST_info(\"%s%s MTU for record mtu %d = %lu\",\n87                       cs, no_etm ? \"-noEtM\" : \"\",\n88                       500 + i, (unsigned long)mtus[i]);\n89         if (!TEST_size_t_ne(mtus[i], 0)) {\n90             TEST_info(\"Cipher %s MTU %d\", cs, 500 + i);\n91             goto end;\n92         }\n93     }\n94\n95     /* Now get out of the way */\n96     SSL_set_mtu(clnt_ssl, 1000);\n97\n98     /*\n99      * Now for all values in the range of payload MTUs, send a payload of\n100      * that size and see what actual record size we end up with.\n101      */\n102     for (s = mtus[0]; s <= mtus[29]; s++) {\n103         size_t reclen;\n104\n105         if (!TEST_int_eq(SSL_write(clnt_ssl, buf, s), (int)s))\n106             goto end;\n107         reclen = BIO_read(sc_bio, buf, sizeof(buf));\n108         if (debug)\n109             TEST_info(\"record %zu for payload %zu\", reclen, s);\n110\n111         for (i = 0; i < 30; i++) {\n112             /* DTLS_get_data_mtu() with record MTU 500+i returned mtus[i] ... */\n113\n114             if (!TEST_false(s <= mtus[i] && reclen > (size_t)(500 + i))) {\n115                 /*\n116                  * We sent a packet smaller than or equal to mtus[j] and\n117                  * that made a record *larger* than the record MTU 500+j!\n118                  */\n119                 TEST_error(\"%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d\",\n120                            cs, (unsigned long)s, (unsigned long)mtus[i],\n121                            (unsigned long)reclen, 500 + i);\n122                 goto end;\n123             }\n124             if (!TEST_false(s > mtus[i] && reclen <= (size_t)(500 + i))) {\n125                 /*\n126                  * We sent a *larger* packet than mtus[i] and that *still*\n127                  * fits within the record MTU 500+i, so DTLS_get_data_mtu()\n128                  * was overly pessimistic.\n129                  */\n130                 TEST_error(\"%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d\",\n131                            cs, (unsigned long)s, (unsigned long)mtus[i],\n132                            (unsigned long)reclen, 500 + i);\n133                 goto end;\n134             }\n135         }\n136     }\n137     if (!TEST_ptr(clnt_sc = SSL_CONNECTION_FROM_SSL_ONLY(clnt_ssl)))\n138         goto end;\n139     rv = 1;\n140     if (SSL_READ_ETM(clnt_sc))\n141         rv = 2;\n142  end:\n143     SSL_free(clnt_ssl);\n144     SSL_free(srvr_ssl);\n145     return rv;\n146 }"
                    },
                    {
                        "file_path": "/test/dtls_mtu_test.c",
                        "function_body": "148 static int run_mtu_tests(void)\n149 {\n150     SSL_CTX *ctx = NULL;\n151     STACK_OF(SSL_CIPHER) *ciphers;\n152     int i, ret = 0;\n153\n154     if (!TEST_ptr(ctx = SSL_CTX_new(DTLS_method())))\n155         goto end;\n156\n157     SSL_CTX_set_psk_server_callback(ctx, srvr_psk_callback);\n158     SSL_CTX_set_psk_client_callback(ctx, clnt_psk_callback);\n159     SSL_CTX_set_security_level(ctx, 0);\n160\n161     /*\n162      * We only care about iterating over each enc/mac; we don't want to\n163      * repeat the test for each auth/kx variant. So keep life simple and\n164      * only do (non-DH) PSK.\n165      */\n166     if (!TEST_true(SSL_CTX_set_cipher_list(ctx, \"PSK\")))\n167         goto end;\n168\n169     ciphers = SSL_CTX_get_ciphers(ctx);\n170     for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {\n171         const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(ciphers, i);\n172         const char *cipher_name = SSL_CIPHER_get_name(cipher);\n173\n174         /* As noted above, only one test for each enc/mac variant. */\n175         if (!HAS_PREFIX(cipher_name, \"PSK-\"))\n176             continue;\n177\n178         if (!TEST_int_gt(ret = mtu_test(ctx, cipher_name, 0), 0))\n179             break;\n180         TEST_info(\"%s OK\", cipher_name);\n181         if (ret == 1)\n182             continue;\n183\n184         /* mtu_test() returns 2 if it used Encrypt-then-MAC */\n185         if (!TEST_int_gt(ret = mtu_test(ctx, cipher_name, 1), 0))\n186             break;\n187         TEST_info(\"%s without EtM OK\", cipher_name);\n188     }\n189\n190  end:\n191     SSL_CTX_free(ctx);\n192     return ret;\n193 }"
                    }
                ]
            }
        ],
        "sink": "for (s = mtus[0]; s <= mtus[29]; s++) {",
        "final_sink": "for (s = mtus[0]; s <= mtus[29]; s++) {"
    },
    {
        "prt": "mtus[_]",
        "function_call": [
            "static int mtu_test(SSL_CTX *ctx, const char *cs, int no_etm)\n{\n    SSL *srvr_ssl = NULL, *clnt_ssl = NULL;\n    BIO *sc_bio = NULL;\n    int i;\n    size_t s;\n    size_t mtus[30];\n    unsigned char buf[600];\n    int rv = 0;\n    SSL_CONNECTION *clnt_sc;\n\n    memset(buf, 0x5a, sizeof(buf));\n\n    if (!TEST_true(create_ssl_objects(ctx, ctx, &srvr_ssl, &clnt_ssl,\n                                      NULL, NULL)))\n        goto end;\n\n    if (no_etm)\n        SSL_set_options(srvr_ssl, SSL_OP_NO_ENCRYPT_THEN_MAC);\n\n    if (!TEST_true(SSL_set_cipher_list(srvr_ssl, cs))\n            || !TEST_true(SSL_set_cipher_list(clnt_ssl, cs))\n            || !TEST_ptr(sc_bio = SSL_get_rbio(srvr_ssl))\n            || !TEST_true(create_ssl_connection(clnt_ssl, srvr_ssl,\n                                                SSL_ERROR_NONE)))\n        goto end;\n\n    if (debug)\n        TEST_info(\"Channel established\");\n\n    /* For record MTU values between 500 and 539, call DTLS_get_data_mtu()\n     * to query the payload MTU which will fit. */\n    for (i = 0; i < 30; i++) {\n        SSL_set_mtu(clnt_ssl, 500 + i);\n        mtus[i] = DTLS_get_data_mtu(clnt_ssl);\n        if (debug)\n            TEST_info(\"%s%s MTU for record mtu %d = %lu\",\n                      cs, no_etm ? \"-noEtM\" : \"\",\n                      500 + i, (unsigned long)mtus[i]);\n        if (!TEST_size_t_ne(mtus[i], 0)) {\n            TEST_info(\"Cipher %s MTU %d\", cs, 500 + i);\n            goto end;\n        }\n    }\n\n    /* Now get out of the way */\n    SSL_set_mtu(clnt_ssl, 1000);\n\n    /*\n     * Now for all values in the range of payload MTUs, send a payload of\n     * that size and see what actual record size we end up with.\n     */\n    for (s = mtus[0]; s <= mtus[29]; s++) {\n        size_t reclen;\n\n        if (!TEST_int_eq(SSL_write(clnt_ssl, buf, s), (int)s))\n            goto end;\n        reclen = BIO_read(sc_bio, buf, sizeof(buf));\n        if (debug)\n            TEST_info(\"record %zu for payload %zu\", reclen, s);\n\n        for (i = 0; i < 30; i++) {\n            /* DTLS_get_data_mtu() with record MTU 500+i returned mtus[i] ... */\n\n            if (!TEST_false(s <= mtus[i] && reclen > (size_t)(500 + i))) {\n                /*\n                 * We sent a packet smaller than or equal to mtus[j] and\n                 * that made a record *larger* than the record MTU 500+j!\n                 */\n                TEST_error(\"%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d\",\n                           cs, (unsigned long)s, (unsigned long)mtus[i],\n                           (unsigned long)reclen, 500 + i);\n                goto end;\n            }\n            if (!TEST_false(s > mtus[i] && reclen <= (size_t)(500 + i))) {\n                /*\n                 * We sent a *larger* packet than mtus[i] and that *still*\n                 * fits within the record MTU 500+i, so DTLS_get_data_mtu()\n                 * was overly pessimistic.\n                 */\n                TEST_error(\"%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d\",\n                           cs, (unsigned long)s, (unsigned long)mtus[i],\n                           (unsigned long)reclen, 500 + i);\n                goto end;\n            }\n        }\n    }\n    if (!TEST_ptr(clnt_sc = SSL_CONNECTION_FROM_SSL_ONLY(clnt_ssl)))\n        goto end;\n    rv = 1;\n    if (SSL_READ_ETM(clnt_sc))\n        rv = 2;\n end:\n    SSL_free(clnt_ssl);\n    SSL_free(srvr_ssl);\n    return rv;\n}"
        ],
        "source": [
            "    size_t mtus[30];"
        ],
        "index": 49,
        "location": {
            "file_path": "test/dtls_mtu_test.c",
            "region": {
                "startLine": 102,
                "startColumn": 23,
                "endColumn": 30
            },
            "context": {
                "startLine": 100,
                "endLine": 104,
                "snippet": {
                    "text": "for (s = mtus[0]; s <= mtus[29]; s++) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/test/dtls_mtu_test.c",
                        "function_body": "50 static int mtu_test(SSL_CTX *ctx, const char *cs, int no_etm)\n51 {\n52     SSL *srvr_ssl = NULL, *clnt_ssl = NULL;\n53     BIO *sc_bio = NULL;\n54     int i;\n55     size_t s;\n56     size_t mtus[30];\n57     unsigned char buf[600];\n58     int rv = 0;\n59     SSL_CONNECTION *clnt_sc;\n60\n61     memset(buf, 0x5a, sizeof(buf));\n62\n63     if (!TEST_true(create_ssl_objects(ctx, ctx, &srvr_ssl, &clnt_ssl,\n64                                       NULL, NULL)))\n65         goto end;\n66\n67     if (no_etm)\n68         SSL_set_options(srvr_ssl, SSL_OP_NO_ENCRYPT_THEN_MAC);\n69\n70     if (!TEST_true(SSL_set_cipher_list(srvr_ssl, cs))\n71             || !TEST_true(SSL_set_cipher_list(clnt_ssl, cs))\n72             || !TEST_ptr(sc_bio = SSL_get_rbio(srvr_ssl))\n73             || !TEST_true(create_ssl_connection(clnt_ssl, srvr_ssl,\n74                                                 SSL_ERROR_NONE)))\n75         goto end;\n76\n77     if (debug)\n78         TEST_info(\"Channel established\");\n79\n80     /* For record MTU values between 500 and 539, call DTLS_get_data_mtu()\n81      * to query the payload MTU which will fit. */\n82     for (i = 0; i < 30; i++) {\n83         SSL_set_mtu(clnt_ssl, 500 + i);\n84         mtus[i] = DTLS_get_data_mtu(clnt_ssl);\n85         if (debug)\n86             TEST_info(\"%s%s MTU for record mtu %d = %lu\",\n87                       cs, no_etm ? \"-noEtM\" : \"\",\n88                       500 + i, (unsigned long)mtus[i]);\n89         if (!TEST_size_t_ne(mtus[i], 0)) {\n90             TEST_info(\"Cipher %s MTU %d\", cs, 500 + i);\n91             goto end;\n92         }\n93     }\n94\n95     /* Now get out of the way */\n96     SSL_set_mtu(clnt_ssl, 1000);\n97\n98     /*\n99      * Now for all values in the range of payload MTUs, send a payload of\n100      * that size and see what actual record size we end up with.\n101      */\n102     for (s = mtus[0]; s <= mtus[29]; s++) {\n103         size_t reclen;\n104\n105         if (!TEST_int_eq(SSL_write(clnt_ssl, buf, s), (int)s))\n106             goto end;\n107         reclen = BIO_read(sc_bio, buf, sizeof(buf));\n108         if (debug)\n109             TEST_info(\"record %zu for payload %zu\", reclen, s);\n110\n111         for (i = 0; i < 30; i++) {\n112             /* DTLS_get_data_mtu() with record MTU 500+i returned mtus[i] ... */\n113\n114             if (!TEST_false(s <= mtus[i] && reclen > (size_t)(500 + i))) {\n115                 /*\n116                  * We sent a packet smaller than or equal to mtus[j] and\n117                  * that made a record *larger* than the record MTU 500+j!\n118                  */\n119                 TEST_error(\"%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d\",\n120                            cs, (unsigned long)s, (unsigned long)mtus[i],\n121                            (unsigned long)reclen, 500 + i);\n122                 goto end;\n123             }\n124             if (!TEST_false(s > mtus[i] && reclen <= (size_t)(500 + i))) {\n125                 /*\n126                  * We sent a *larger* packet than mtus[i] and that *still*\n127                  * fits within the record MTU 500+i, so DTLS_get_data_mtu()\n128                  * was overly pessimistic.\n129                  */\n130                 TEST_error(\"%s: s=%lu, mtus[i]=%lu, reclen=%lu, i=%d\",\n131                            cs, (unsigned long)s, (unsigned long)mtus[i],\n132                            (unsigned long)reclen, 500 + i);\n133                 goto end;\n134             }\n135         }\n136     }\n137     if (!TEST_ptr(clnt_sc = SSL_CONNECTION_FROM_SSL_ONLY(clnt_ssl)))\n138         goto end;\n139     rv = 1;\n140     if (SSL_READ_ETM(clnt_sc))\n141         rv = 2;\n142  end:\n143     SSL_free(clnt_ssl);\n144     SSL_free(srvr_ssl);\n145     return rv;\n146 }"
                    },
                    {
                        "file_path": "/test/dtls_mtu_test.c",
                        "function_body": "148 static int run_mtu_tests(void)\n149 {\n150     SSL_CTX *ctx = NULL;\n151     STACK_OF(SSL_CIPHER) *ciphers;\n152     int i, ret = 0;\n153\n154     if (!TEST_ptr(ctx = SSL_CTX_new(DTLS_method())))\n155         goto end;\n156\n157     SSL_CTX_set_psk_server_callback(ctx, srvr_psk_callback);\n158     SSL_CTX_set_psk_client_callback(ctx, clnt_psk_callback);\n159     SSL_CTX_set_security_level(ctx, 0);\n160\n161     /*\n162      * We only care about iterating over each enc/mac; we don't want to\n163      * repeat the test for each auth/kx variant. So keep life simple and\n164      * only do (non-DH) PSK.\n165      */\n166     if (!TEST_true(SSL_CTX_set_cipher_list(ctx, \"PSK\")))\n167         goto end;\n168\n169     ciphers = SSL_CTX_get_ciphers(ctx);\n170     for (i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {\n171         const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(ciphers, i);\n172         const char *cipher_name = SSL_CIPHER_get_name(cipher);\n173\n174         /* As noted above, only one test for each enc/mac variant. */\n175         if (!HAS_PREFIX(cipher_name, \"PSK-\"))\n176             continue;\n177\n178         if (!TEST_int_gt(ret = mtu_test(ctx, cipher_name, 0), 0))\n179             break;\n180         TEST_info(\"%s OK\", cipher_name);\n181         if (ret == 1)\n182             continue;\n183\n184         /* mtu_test() returns 2 if it used Encrypt-then-MAC */\n185         if (!TEST_int_gt(ret = mtu_test(ctx, cipher_name, 1), 0))\n186             break;\n187         TEST_info(\"%s without EtM OK\", cipher_name);\n188     }\n189\n190  end:\n191     SSL_CTX_free(ctx);\n192     return ret;\n193 }"
                    }
                ]
            }
        ],
        "sink": "for (s = mtus[0]; s <= mtus[29]; s++) {",
        "final_sink": "for (s = mtus[0]; s <= mtus[29]; s++) {"
    },
    {
        "prt": "t",
        "function_call": [
            "const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\n{\n    const EVP_PKEY_ASN1_METHOD *t;\n\n    for (;;) {\n        t = pkey_asn1_find(type);\n        if (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\n            break;\n        type = t->pkey_base_id;\n    }\n    if (pe) {\n#ifndef OPENSSL_NO_ENGINE\n        ENGINE *e;\n        /* type will contain the final unaliased type */\n        e = ENGINE_get_pkey_asn1_meth_engine(type);\n        if (e) {\n            *pe = e;\n            return ENGINE_get_pkey_asn1_meth(e, type);\n        }\n#endif\n        *pe = NULL;\n    }\n    return t;\n}"
        ],
        "source": [
            "    const EVP_PKEY_ASN1_METHOD *t;"
        ],
        "index": 50,
        "location": {
            "file_path": "crypto/asn1/ameth_lib.c",
            "region": {
                "startLine": 103,
                "startColumn": 5,
                "endColumn": 6
            },
            "context": {
                "startLine": 101,
                "endLine": 105,
                "snippet": {
                    "text": "return t;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/ameth_lib.c",
                        "function_body": "81 const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\n82 {\n83     const EVP_PKEY_ASN1_METHOD *t;\n84\n85     for (;;) {\n86         t = pkey_asn1_find(type);\n87         if (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\n88             break;\n89         type = t->pkey_base_id;\n90     }\n91     if (pe) {\n92 #ifndef OPENSSL_NO_ENGINE\n93         ENGINE *e;\n94         /* type will contain the final unaliased type */\n95         e = ENGINE_get_pkey_asn1_meth_engine(type);\n96         if (e) {\n97             *pe = e;\n98             return ENGINE_get_pkey_asn1_meth(e, type);\n99         }\n100 #endif\n101         *pe = NULL;\n102     }\n103     return t;\n104 }"
                    },
                    {
                        "file_path": "/crypto/x509/v3_ac_tgt.c",
                        "function_body": "101 static int i2r_OBJECT_DIGEST_INFO(X509V3_EXT_METHOD *method,\n102                            OSSL_OBJECT_DIGEST_INFO *odi,\n103                            BIO *out, int indent)\n104 {\n105     int64_t dot = 0;\n106     int sig_nid;\n107     X509_ALGOR *digalg;\n108     ASN1_STRING *sig;\n109\n110     if (odi == NULL) {\n111         ERR_raise(ERR_LIB_ASN1, ERR_R_PASSED_NULL_PARAMETER);\n112         return 0;\n113     }\n114     digalg = &odi->digestAlgorithm;\n115     sig = &odi->objectDigest;\n116     if (!ASN1_ENUMERATED_get_int64(&dot, &odi->digestedObjectType)) {\n117         return 0;\n118     }\n119     switch (dot) {\n120     case OSSL_ODI_TYPE_PUBLIC_KEY:\n121         BIO_printf(out, \"%*sDigest Type: Public Key\\n\", indent, \"\");\n122         break;\n123     case OSSL_ODI_TYPE_PUBLIC_KEY_CERT:\n124         BIO_printf(out, \"%*sDigest Type: Public Key Certificate\\n\", indent, \"\");\n125         break;\n126     case OSSL_ODI_TYPE_OTHER:\n127         BIO_printf(out, \"%*sDigest Type: Other\\n\", indent, \"\");\n128         break;\n129     }\n130     if (odi->otherObjectTypeID != NULL) {\n131         BIO_printf(out, \"%*sDigest Type Identifier: \", indent, \"\");\n132         i2a_ASN1_OBJECT(out, odi->otherObjectTypeID);\n133         BIO_puts(out, \"\\n\");\n134     }\n135     if (BIO_printf(out, \"%*sSignature Algorithm: \", indent, \"\") <= 0)\n136         return 0;\n137     if (i2a_ASN1_OBJECT(out, odi->digestAlgorithm.algorithm) <= 0)\n138         return 0;\n139     BIO_puts(out, \"\\n\");\n140     if (BIO_printf(out, \"\\n%*sSignature Value: \", indent, \"\") <= 0)\n141         return 0;\n142     sig_nid = OBJ_obj2nid(odi->digestAlgorithm.algorithm);\n143     if (sig_nid != NID_undef) {\n144         int pkey_nid, dig_nid;\n145         const EVP_PKEY_ASN1_METHOD *ameth;\n146         if (OBJ_find_sigid_algs(sig_nid, &dig_nid, &pkey_nid)) {\n147             ameth = EVP_PKEY_asn1_find(NULL, pkey_nid);\n148             if (ameth && ameth->sig_print)\n149                 return ameth->sig_print(out, digalg, sig, indent + 4, 0);\n150         }\n151     }\n152     if (BIO_write(out, \"\\n\", 1) != 1)\n153         return 0;\n154     if (sig)\n155         return X509_signature_dump(out, sig, indent + 4);\n156     return 1;\n157 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/ameth_lib.c",
                        "function_body": "81 const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\n82 {\n83     const EVP_PKEY_ASN1_METHOD *t;\n84\n85     for (;;) {\n86         t = pkey_asn1_find(type);\n87         if (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\n88             break;\n89         type = t->pkey_base_id;\n90     }\n91     if (pe) {\n92 #ifndef OPENSSL_NO_ENGINE\n93         ENGINE *e;\n94         /* type will contain the final unaliased type */\n95         e = ENGINE_get_pkey_asn1_meth_engine(type);\n96         if (e) {\n97             *pe = e;\n98             return ENGINE_get_pkey_asn1_meth(e, type);\n99         }\n100 #endif\n101         *pe = NULL;\n102     }\n103     return t;\n104 }"
                    },
                    {
                        "file_path": "/crypto/evp/p_lib.c",
                        "function_body": "1792 void evp_pkey_free_legacy(EVP_PKEY *x)\n1793 {\n1794     const EVP_PKEY_ASN1_METHOD *ameth = x->ameth;\n1795     ENGINE *tmpe = NULL;\n1796\n1797     if (ameth == NULL && x->legacy_cache_pkey.ptr != NULL)\n1798         ameth = EVP_PKEY_asn1_find(&tmpe, x->type);\n1799\n1800     if (ameth != NULL) {\n1801         if (x->legacy_cache_pkey.ptr != NULL) {\n1802             /*\n1803              * We should never have both a legacy origin key, and a key in the\n1804              * legacy cache.\n1805              */\n1806             assert(x->pkey.ptr == NULL);\n1807             /*\n1808              * For the purposes of freeing we make the legacy cache look like\n1809              * a legacy origin key.\n1810              */\n1811             x->pkey = x->legacy_cache_pkey;\n1812             x->legacy_cache_pkey.ptr = NULL;\n1813         }\n1814         if (ameth->pkey_free != NULL)\n1815             ameth->pkey_free(x);\n1816         x->pkey.ptr = NULL;\n1817     }\n1818 # ifndef OPENSSL_NO_ENGINE\n1819     ENGINE_finish(tmpe);\n1820     ENGINE_finish(x->engine);\n1821     x->engine = NULL;\n1822     ENGINE_finish(x->pmeth_engine);\n1823     x->pmeth_engine = NULL;\n1824 # endif\n1825 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/ameth_lib.c",
                        "function_body": "81 const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\n82 {\n83     const EVP_PKEY_ASN1_METHOD *t;\n84\n85     for (;;) {\n86         t = pkey_asn1_find(type);\n87         if (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\n88             break;\n89         type = t->pkey_base_id;\n90     }\n91     if (pe) {\n92 #ifndef OPENSSL_NO_ENGINE\n93         ENGINE *e;\n94         /* type will contain the final unaliased type */\n95         e = ENGINE_get_pkey_asn1_meth_engine(type);\n96         if (e) {\n97             *pe = e;\n98             return ENGINE_get_pkey_asn1_meth(e, type);\n99         }\n100 #endif\n101         *pe = NULL;\n102     }\n103     return t;\n104 }"
                    },
                    {
                        "file_path": "/crypto/evp/p_lib.c",
                        "function_body": "1020 int EVP_PKEY_type(int type)\n1021 {\n1022     int ret;\n1023     const EVP_PKEY_ASN1_METHOD *ameth;\n1024     ENGINE *e;\n1025     ameth = EVP_PKEY_asn1_find(&e, type);\n1026     if (ameth)\n1027         ret = ameth->pkey_id;\n1028     else\n1029         ret = NID_undef;\n1030 # ifndef OPENSSL_NO_ENGINE\n1031     ENGINE_finish(e);\n1032 # endif\n1033     return ret;\n1034 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/ameth_lib.c",
                        "function_body": "81 const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\n82 {\n83     const EVP_PKEY_ASN1_METHOD *t;\n84\n85     for (;;) {\n86         t = pkey_asn1_find(type);\n87         if (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\n88             break;\n89         type = t->pkey_base_id;\n90     }\n91     if (pe) {\n92 #ifndef OPENSSL_NO_ENGINE\n93         ENGINE *e;\n94         /* type will contain the final unaliased type */\n95         e = ENGINE_get_pkey_asn1_meth_engine(type);\n96         if (e) {\n97             *pe = e;\n98             return ENGINE_get_pkey_asn1_meth(e, type);\n99         }\n100 #endif\n101         *pe = NULL;\n102     }\n103     return t;\n104 }"
                    },
                    {
                        "file_path": "/crypto/evp/p_lib.c",
                        "function_body": "1551 static int pkey_set_type(EVP_PKEY *pkey, ENGINE *e, int type, const char *str,\n1552                          int len, EVP_KEYMGMT *keymgmt)\n1553 {\n1554 #ifndef FIPS_MODULE\n1555     const EVP_PKEY_ASN1_METHOD *ameth = NULL;\n1556     ENGINE **eptr = (e == NULL) ? &e :  NULL;\n1557 #endif\n1558\n1559     /*\n1560      * The setups can't set both legacy and provider side methods.\n1561      * It is forbidden\n1562      */\n1563     if (!ossl_assert(type == EVP_PKEY_NONE || keymgmt == NULL)\n1564         || !ossl_assert(e == NULL || keymgmt == NULL)) {\n1565         ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);\n1566         return 0;\n1567     }\n1568\n1569     if (pkey != NULL) {\n1570         int free_it = 0;\n1571\n1572 #ifndef FIPS_MODULE\n1573         free_it = free_it || pkey->pkey.ptr != NULL;\n1574 #endif\n1575         free_it = free_it || pkey->keydata != NULL;\n1576         if (free_it)\n1577             evp_pkey_free_it(pkey);\n1578 #ifndef FIPS_MODULE\n1579         /*\n1580          * If key type matches and a method exists then this lookup has\n1581          * succeeded once so just indicate success.\n1582          */\n1583         if (pkey->type != EVP_PKEY_NONE\n1584             && type == pkey->save_type\n1585             && pkey->ameth != NULL)\n1586             return 1;\n1587 # ifndef OPENSSL_NO_ENGINE\n1588         /* If we have ENGINEs release them */\n1589         ENGINE_finish(pkey->engine);\n1590         pkey->engine = NULL;\n1591         ENGINE_finish(pkey->pmeth_engine);\n1592         pkey->pmeth_engine = NULL;\n1593 # endif\n1594 #endif\n1595     }\n1596 #ifndef FIPS_MODULE\n1597     if (str != NULL)\n1598         ameth = EVP_PKEY_asn1_find_str(eptr, str, len);\n1599     else if (type != EVP_PKEY_NONE)\n1600         ameth = EVP_PKEY_asn1_find(eptr, type);\n1601 # ifndef OPENSSL_NO_ENGINE\n1602     if (pkey == NULL && eptr != NULL)\n1603         ENGINE_finish(e);\n1604 # endif\n1605 #endif\n1606\n1607\n1608     {\n1609         int check = 1;\n1610\n1611 #ifndef FIPS_MODULE\n1612         check = check && ameth == NULL;\n1613 #endif\n1614         check = check && keymgmt == NULL;\n1615         if (check) {\n1616             ERR_raise(ERR_LIB_EVP, EVP_R_UNSUPPORTED_ALGORITHM);\n1617             return 0;\n1618         }\n1619     }\n1620     if (pkey != NULL) {\n1621         if (keymgmt != NULL && !EVP_KEYMGMT_up_ref(keymgmt)) {\n1622             ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);\n1623             return 0;\n1624         }\n1625\n1626         pkey->keymgmt = keymgmt;\n1627\n1628         pkey->save_type = type;\n1629         pkey->type = type;\n1630\n1631 #ifndef FIPS_MODULE\n1632         /*\n1633          * If the internal \"origin\" key is provider side, don't save |ameth|.\n1634          * The main reason is that |ameth| is one factor to detect that the\n1635          * internal \"origin\" key is a legacy one.\n1636          */\n1637         if (keymgmt == NULL)\n1638             pkey->ameth = ameth;\n1639\n1640         /*\n1641          * The EVP_PKEY_ASN1_METHOD |pkey_id| retains its legacy key purpose\n1642          * for any key type that has a legacy implementation, regardless of\n1643          * if the internal key is a legacy or a provider side one.  When\n1644          * there is no legacy implementation for the key, the type becomes\n1645          * EVP_PKEY_KEYMGMT, which indicates that one should be cautious\n1646          * with functions that expect legacy internal keys.\n1647          */\n1648         if (ameth != NULL) {\n1649             if (type == EVP_PKEY_NONE)\n1650                 pkey->type = ameth->pkey_id;\n1651         } else {\n1652             pkey->type = EVP_PKEY_KEYMGMT;\n1653         }\n1654 # ifndef OPENSSL_NO_ENGINE\n1655         if (eptr == NULL && e != NULL && !ENGINE_init(e)) {\n1656             ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);\n1657             return 0;\n1658         }\n1659 # endif\n1660         pkey->engine = e;\n1661 #endif\n1662     }\n1663     return 1;\n1664 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/ameth_lib.c",
                        "function_body": "81 const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\n82 {\n83     const EVP_PKEY_ASN1_METHOD *t;\n84\n85     for (;;) {\n86         t = pkey_asn1_find(type);\n87         if (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\n88             break;\n89         type = t->pkey_base_id;\n90     }\n91     if (pe) {\n92 #ifndef OPENSSL_NO_ENGINE\n93         ENGINE *e;\n94         /* type will contain the final unaliased type */\n95         e = ENGINE_get_pkey_asn1_meth_engine(type);\n96         if (e) {\n97             *pe = e;\n98             return ENGINE_get_pkey_asn1_meth(e, type);\n99         }\n100 #endif\n101         *pe = NULL;\n102     }\n103     return t;\n104 }"
                    },
                    {
                        "file_path": "/crypto/x509/x509_set.c",
                        "function_body": "212 static int x509_sig_info_init(X509_SIG_INFO *siginf, const X509_ALGOR *alg,\n213                               const ASN1_STRING *sig, const EVP_PKEY *pubkey)\n214 {\n215     int pknid, mdnid, md_size;\n216     const EVP_MD *md;\n217     const EVP_PKEY_ASN1_METHOD *ameth;\n218\n219     siginf->mdnid = NID_undef;\n220     siginf->pknid = NID_undef;\n221     siginf->secbits = -1;\n222     siginf->flags = 0;\n223     if (!OBJ_find_sigid_algs(OBJ_obj2nid(alg->algorithm), &mdnid, &pknid)\n224             || pknid == NID_undef) {\n225         ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_SIGID_ALGS);\n226         return 0;\n227     }\n228     siginf->mdnid = mdnid;\n229     siginf->pknid = pknid;\n230\n231     switch (mdnid) {\n232     case NID_undef:\n233         /* If we have one, use a custom handler for this algorithm */\n234         ameth = EVP_PKEY_asn1_find(NULL, pknid);\n235         if (ameth != NULL && ameth->siginf_set != NULL\n236                 && ameth->siginf_set(siginf, alg, sig))\n237            break;\n238         if (pubkey != NULL) {\n239             int secbits;\n240\n241             secbits = EVP_PKEY_get_security_bits(pubkey);\n242             if (secbits != 0) {\n243                 siginf->secbits = secbits;\n244                 break;\n245             }\n246         }\n247         ERR_raise(ERR_LIB_X509, X509_R_ERROR_USING_SIGINF_SET);\n248         return 0;\n249         /*\n250          * SHA1 and MD5 are known to be broken. Reduce security bits so that\n251          * they're no longer accepted at security level 1.\n252          * The real values don't really matter as long as they're lower than 80,\n253          * which is our security level 1.\n254          */\n255     case NID_sha1:\n256         /*\n257          * https://eprint.iacr.org/2020/014 puts a chosen-prefix attack\n258          * for SHA1 at2^63.4\n259          */\n260         siginf->secbits = 63;\n261         break;\n262     case NID_md5:\n263         /*\n264          * https://documents.epfl.ch/users/l/le/lenstra/public/papers/lat.pdf\n265          * puts a chosen-prefix attack for MD5 at 2^39.\n266          */\n267         siginf->secbits = 39;\n268         break;\n269     case NID_id_GostR3411_94:\n270         /*\n271          * There is a collision attack on GOST R 34.11-94 at 2^105, see\n272          * https://link.springer.com/chapter/10.1007%2F978-3-540-85174-5_10\n273          */\n274         siginf->secbits = 105;\n275         break;\n276     default:\n277         /* Security bits: half number of bits in digest */\n278         if ((md = EVP_get_digestbynid(mdnid)) == NULL) {\n279             ERR_raise(ERR_LIB_X509, X509_R_ERROR_GETTING_MD_BY_NID);\n280             return 0;\n281         }\n282         md_size = EVP_MD_get_size(md);\n283         if (md_size <= 0)\n284             return 0;\n285         siginf->secbits = md_size * 4;\n286         break;\n287     }\n288     switch (mdnid) {\n289     case NID_sha1:\n290     case NID_sha256:\n291     case NID_sha384:\n292     case NID_sha512:\n293         siginf->flags |= X509_SIG_INFO_TLS;\n294     }\n295     siginf->flags |= X509_SIG_INFO_VALID;\n296     return 1;\n297 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/ameth_lib.c",
                        "function_body": "81 const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\n82 {\n83     const EVP_PKEY_ASN1_METHOD *t;\n84\n85     for (;;) {\n86         t = pkey_asn1_find(type);\n87         if (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\n88             break;\n89         type = t->pkey_base_id;\n90     }\n91     if (pe) {\n92 #ifndef OPENSSL_NO_ENGINE\n93         ENGINE *e;\n94         /* type will contain the final unaliased type */\n95         e = ENGINE_get_pkey_asn1_meth_engine(type);\n96         if (e) {\n97             *pe = e;\n98             return ENGINE_get_pkey_asn1_meth(e, type);\n99         }\n100 #endif\n101         *pe = NULL;\n102     }\n103     return t;\n104 }"
                    },
                    {
                        "file_path": "/crypto/x509/t_x509.c",
                        "function_body": "287 int X509_signature_print(BIO *bp, const X509_ALGOR *sigalg,\n288                          const ASN1_STRING *sig)\n289 {\n290     int sig_nid;\n291     int indent = 4;\n292     if (BIO_printf(bp, \"%*sSignature Algorithm: \", indent, \"\") <= 0)\n293         return 0;\n294     if (i2a_ASN1_OBJECT(bp, sigalg->algorithm) <= 0)\n295         return 0;\n296\n297     if (sig && BIO_printf(bp, \"\\n%*sSignature Value:\", indent, \"\") <= 0)\n298         return 0;\n299     sig_nid = OBJ_obj2nid(sigalg->algorithm);\n300     if (sig_nid != NID_undef) {\n301         int pkey_nid, dig_nid;\n302         const EVP_PKEY_ASN1_METHOD *ameth;\n303         if (OBJ_find_sigid_algs(sig_nid, &dig_nid, &pkey_nid)) {\n304             ameth = EVP_PKEY_asn1_find(NULL, pkey_nid);\n305             if (ameth && ameth->sig_print)\n306                 return ameth->sig_print(bp, sigalg, sig, indent + 4, 0);\n307         }\n308     }\n309     if (BIO_write(bp, \"\\n\", 1) != 1)\n310         return 0;\n311     if (sig)\n312         return X509_signature_dump(bp, sig, indent + 4);\n313     return 1;\n314 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/ameth_lib.c",
                        "function_body": "81 const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type)\n82 {\n83     const EVP_PKEY_ASN1_METHOD *t;\n84\n85     for (;;) {\n86         t = pkey_asn1_find(type);\n87         if (!t || !(t->pkey_flags & ASN1_PKEY_ALIAS))\n88             break;\n89         type = t->pkey_base_id;\n90     }\n91     if (pe) {\n92 #ifndef OPENSSL_NO_ENGINE\n93         ENGINE *e;\n94         /* type will contain the final unaliased type */\n95         e = ENGINE_get_pkey_asn1_meth_engine(type);\n96         if (e) {\n97             *pe = e;\n98             return ENGINE_get_pkey_asn1_meth(e, type);\n99         }\n100 #endif\n101         *pe = NULL;\n102     }\n103     return t;\n104 }"
                    },
                    {
                        "file_path": "/crypto/evp/p_lib.c",
                        "function_body": "413 static EVP_PKEY *new_raw_key_int(OSSL_LIB_CTX *libctx,\n414                                  const char *strtype,\n415                                  const char *propq,\n416                                  int nidtype,\n417                                  ENGINE *e,\n418                                  const unsigned char *key,\n419                                  size_t len,\n420                                  int key_is_priv)\n421 {\n422     EVP_PKEY *pkey = NULL;\n423     EVP_PKEY_CTX *ctx = NULL;\n424     const EVP_PKEY_ASN1_METHOD *ameth = NULL;\n425     int result = 0;\n426\n427 # ifndef OPENSSL_NO_ENGINE\n428     /* Check if there is an Engine for this type */\n429     if (e == NULL) {\n430         ENGINE *tmpe = NULL;\n431\n432         if (strtype != NULL)\n433             ameth = EVP_PKEY_asn1_find_str(&tmpe, strtype, -1);\n434         else if (nidtype != EVP_PKEY_NONE)\n435             ameth = EVP_PKEY_asn1_find(&tmpe, nidtype);\n436\n437         /* If tmpe is NULL then no engine is claiming to support this type */\n438         if (tmpe == NULL)\n439             ameth = NULL;\n440\n441         ENGINE_finish(tmpe);\n442     }\n443 # endif\n444\n445     if (e == NULL && ameth == NULL) {\n446         /*\n447          * No engine is claiming to support this type, so lets see if we have\n448          * a provider.\n449          */\n450         ctx = EVP_PKEY_CTX_new_from_name(libctx,\n451                                          strtype != NULL ? strtype\n452                                                          : OBJ_nid2sn(nidtype),\n453                                          propq);\n454         if (ctx == NULL)\n455             goto err;\n456         /* May fail if no provider available */\n457         ERR_set_mark();\n458         if (EVP_PKEY_fromdata_init(ctx) == 1) {\n459             OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n460\n461             ERR_clear_last_mark();\n462             params[0] = OSSL_PARAM_construct_octet_string(\n463                             key_is_priv ? OSSL_PKEY_PARAM_PRIV_KEY\n464                                         : OSSL_PKEY_PARAM_PUB_KEY,\n465                             (void *)key, len);\n466\n467             if (EVP_PKEY_fromdata(ctx, &pkey, EVP_PKEY_KEYPAIR, params) != 1) {\n468                 ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);\n469                 goto err;\n470             }\n471\n472             EVP_PKEY_CTX_free(ctx);\n473\n474             return pkey;\n475         }\n476         ERR_pop_to_mark();\n477         /* else not supported so fallback to legacy */\n478     }\n479\n480     /* Legacy code path */\n481\n482     pkey = EVP_PKEY_new();\n483     if (pkey == NULL) {\n484         ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);\n485         goto err;\n486     }\n487\n488     if (!pkey_set_type(pkey, e, nidtype, strtype, -1, NULL)) {\n489         /* ERR_raise(ERR_LIB_EVP, ...) already called */\n490         goto err;\n491     }\n492\n493     if (!ossl_assert(pkey->ameth != NULL))\n494         goto err;\n495\n496     if (key_is_priv) {\n497         if (pkey->ameth->set_priv_key == NULL) {\n498             ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n499             goto err;\n500         }\n501\n502         if (!pkey->ameth->set_priv_key(pkey, key, len)) {\n503             ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);\n504             goto err;\n505         }\n506     } else {\n507         if (pkey->ameth->set_pub_key == NULL) {\n508             ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n509             goto err;\n510         }\n511\n512         if (!pkey->ameth->set_pub_key(pkey, key, len)) {\n513             ERR_raise(ERR_LIB_EVP, EVP_R_KEY_SETUP_FAILED);\n514             goto err;\n515         }\n516     }\n517\n518     result = 1;\n519  err:\n520     if (!result) {\n521         EVP_PKEY_free(pkey);\n522         pkey = NULL;\n523     }\n524     EVP_PKEY_CTX_free(ctx);\n525     return pkey;\n526 }"
                    }
                ]
            }
        ],
        "sink": "return t;",
        "final_sink": "return t;"
    },
    {
        "prt": "reclen[_]",
        "function_call": [
            "static int tls1_cipher(OSSL_RECORD_LAYER *rl, TLS_RL_RECORD *recs,\n                       size_t n_recs, int sending, SSL_MAC_BUF *macs,\n                       size_t macsize)\n{\n    EVP_CIPHER_CTX *ds;\n    size_t reclen[SSL_MAX_PIPELINES];\n    unsigned char buf[SSL_MAX_PIPELINES][EVP_AEAD_TLS1_AAD_LEN];\n    unsigned char *data[SSL_MAX_PIPELINES];\n    int pad = 0, tmpr, provided;\n    size_t bs, ctr, padnum, loop;\n    unsigned char padval;\n    const EVP_CIPHER *enc;\n\n    if (n_recs == 0) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (EVP_MD_CTX_get0_md(rl->md_ctx)) {\n        int n = EVP_MD_CTX_get_size(rl->md_ctx);\n\n        if (!ossl_assert(n >= 0)) {\n            RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n    ds = rl->enc_ctx;\n    if (!ossl_assert(rl->enc_ctx != NULL)) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    enc = EVP_CIPHER_CTX_get0_cipher(rl->enc_ctx);\n\n    if (sending) {\n        int ivlen;\n\n        /* For TLSv1.1 and later explicit IV */\n        if (RLAYER_USE_EXPLICIT_IV(rl)\n            && EVP_CIPHER_get_mode(enc) == EVP_CIPH_CBC_MODE)\n            ivlen = EVP_CIPHER_get_iv_length(enc);\n        else\n            ivlen = 0;\n        if (ivlen > 1) {\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                if (recs[ctr].data != recs[ctr].input) {\n                    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n                    return 0;\n                } else if (RAND_bytes_ex(rl->libctx, recs[ctr].input,\n                                         ivlen, 0) <= 0) {\n                    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n                    return 0;\n                }\n            }\n        }\n    }\n    if (!ossl_assert(enc != NULL)) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    provided = (EVP_CIPHER_get0_provider(enc) != NULL);\n\n    bs = EVP_CIPHER_get_block_size(EVP_CIPHER_CTX_get0_cipher(ds));\n\n    if (bs == 0) {\n        RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_CIPHER);\n        return 0;\n    }\n\n    if (n_recs > 1) {\n        if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))\n                 & EVP_CIPH_FLAG_PIPELINE) == 0) {\n            /*\n             * We shouldn't have been called with pipeline data if the\n             * cipher doesn't support pipelining\n             */\n            RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_PIPELINE_FAILURE);\n            return 0;\n        }\n    }\n    for (ctr = 0; ctr < n_recs; ctr++) {\n        reclen[ctr] = recs[ctr].length;\n\n        if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))\n                 & EVP_CIPH_FLAG_AEAD_CIPHER) != 0) {\n            unsigned char *seq;\n\n            seq = rl->sequence;\n\n            if (rl->isdtls) {\n                unsigned char dtlsseq[8], *p = dtlsseq;\n\n                s2n(rl->epoch, p);\n                memcpy(p, &seq[2], 6);\n                memcpy(buf[ctr], dtlsseq, 8);\n            } else {\n                memcpy(buf[ctr], seq, 8);\n                if (!tls_increment_sequence_ctr(rl)) {\n                    /* RLAYERfatal already called */\n                    return 0;\n                }\n            }\n\n            buf[ctr][8] = recs[ctr].type;\n            buf[ctr][9] = (unsigned char)(rl->version >> 8);\n            buf[ctr][10] = (unsigned char)(rl->version);\n            buf[ctr][11] = (unsigned char)(recs[ctr].length >> 8);\n            buf[ctr][12] = (unsigned char)(recs[ctr].length & 0xff);\n            pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD,\n                                      EVP_AEAD_TLS1_AAD_LEN, buf[ctr]);\n            if (pad <= 0) {\n                RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n\n            if (sending) {\n                reclen[ctr] += pad;\n                recs[ctr].length += pad;\n            }\n        } else if ((bs != 1) && sending && !provided) {\n            /*\n             * We only do this for legacy ciphers. Provided ciphers add the\n             * padding on the provider side.\n             */\n            padnum = bs - (reclen[ctr] % bs);\n\n            /* Add weird padding of up to 256 bytes */\n\n            if (padnum > MAX_PADDING) {\n                RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n                return 0;\n            }\n            /* we need to add 'padnum' padding bytes of value padval */\n            padval = (unsigned char)(padnum - 1);\n            for (loop = reclen[ctr]; loop < reclen[ctr] + padnum; loop++)\n                recs[ctr].input[loop] = padval;\n            reclen[ctr] += padnum;\n            recs[ctr].length += padnum;\n        }\n\n        if (!sending) {\n            if (reclen[ctr] == 0 || reclen[ctr] % bs != 0) {\n                /* Publicly invalid */\n                return 0;\n            }\n        }\n    }\n    if (n_recs > 1) {\n        /* Set the output buffers */\n        for (ctr = 0; ctr < n_recs; ctr++)\n            data[ctr] = recs[ctr].data;\n\n        if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS,\n                                (int)n_recs, data) <= 0) {\n            RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_PIPELINE_FAILURE);\n            return 0;\n        }\n        /* Set the input buffers */\n        for (ctr = 0; ctr < n_recs; ctr++)\n            data[ctr] = recs[ctr].input;\n\n        if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_BUFS,\n                                (int)n_recs, data) <= 0\n            || EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_LENS,\n                                   (int)n_recs, reclen) <= 0) {\n            RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_PIPELINE_FAILURE);\n            return 0;\n        }\n    }\n\n    if (!rl->isdtls && rl->tlstree) {\n        int decrement_seq = 0;\n\n        /*\n         * When sending, seq is incremented after MAC calculation.\n         * So if we are in ETM mode, we use seq 'as is' in the ctrl-function.\n         * Otherwise we have to decrease it in the implementation\n         */\n        if (sending && !rl->use_etm)\n            decrement_seq = 1;\n\n        if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_TLSTREE, decrement_seq,\n                                rl->sequence) <= 0) {\n\n            RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n    }\n\n    if (provided) {\n        int outlen;\n\n        /* Provided cipher - we do not support pipelining on this path */\n        if (n_recs > 1) {\n            RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n\n        if (!EVP_CipherUpdate(ds, recs[0].data, &outlen, recs[0].input,\n                              (unsigned int)reclen[0]))\n            return 0;\n        recs[0].length = outlen;\n\n        /*\n         * The length returned from EVP_CipherUpdate above is the actual\n         * payload length. We need to adjust the data/input ptr to skip over\n         * any explicit IV\n         */\n        if (!sending) {\n            if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_GCM_MODE) {\n                recs[0].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                recs[0].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n            } else if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_CCM_MODE) {\n                recs[0].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                recs[0].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n            } else if (bs != 1 && RLAYER_USE_EXPLICIT_IV(rl)) {\n                recs[0].data += bs;\n                recs[0].input += bs;\n                recs[0].orig_len -= bs;\n            }\n\n            /* Now get a pointer to the MAC (if applicable) */\n            if (macs != NULL) {\n                OSSL_PARAM params[2], *p = params;\n\n                /* Get the MAC */\n                macs[0].alloced = 0;\n\n                *p++ = OSSL_PARAM_construct_octet_ptr(OSSL_CIPHER_PARAM_TLS_MAC,\n                                                      (void **)&macs[0].mac,\n                                                      macsize);\n                *p = OSSL_PARAM_construct_end();\n\n                if (!EVP_CIPHER_CTX_get_params(ds, params)) {\n                    /* Shouldn't normally happen */\n                    RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR,\n                                ERR_R_INTERNAL_ERROR);\n                    return 0;\n                }\n            }\n        }\n    } else {\n        /* Legacy cipher */\n\n        tmpr = EVP_Cipher(ds, recs[0].data, recs[0].input,\n                          (unsigned int)reclen[0]);\n        if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))\n                 & EVP_CIPH_FLAG_CUSTOM_CIPHER) != 0\n            ? (tmpr < 0)\n            : (tmpr == 0)) {\n            /* AEAD can fail to verify MAC */\n            return 0;\n        }\n\n        if (!sending) {\n            for (ctr = 0; ctr < n_recs; ctr++) {\n                /* Adjust the record to remove the explicit IV/MAC/Tag */\n                if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_GCM_MODE) {\n                    recs[ctr].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n                } else if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_CCM_MODE) {\n                    recs[ctr].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                    recs[ctr].length -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n                } else if (bs != 1 && RLAYER_USE_EXPLICIT_IV(rl)) {\n                    if (recs[ctr].length < bs)\n                        return 0;\n                    recs[ctr].data += bs;\n                    recs[ctr].input += bs;\n                    recs[ctr].length -= bs;\n                    recs[ctr].orig_len -= bs;\n                }\n\n                /*\n                 * If using Mac-then-encrypt, then this will succeed but\n                 * with a random MAC if padding is invalid\n                 */\n                if (!tls1_cbc_remove_padding_and_mac(&recs[ctr].length,\n                                        recs[ctr].orig_len,\n                                        recs[ctr].data,\n                                        (macs != NULL) ? &macs[ctr].mac : NULL,\n                                        (macs != NULL) ? &macs[ctr].alloced\n                                                       : NULL,\n                                        bs,\n                                        pad ? (size_t)pad : macsize,\n                                        (EVP_CIPHER_get_flags(enc)\n                                        & EVP_CIPH_FLAG_AEAD_CIPHER) != 0,\n                                        rl->libctx))\n                    return 0;\n            }\n        }\n    }\n    return 1;\n}"
        ],
        "source": [
            "    size_t reclen[SSL_MAX_PIPELINES];"
        ],
        "index": 51,
        "location": {
            "file_path": "ssl/record/methods/tls1_meth.c",
            "region": {
                "startLine": 412,
                "startColumn": 16,
                "endColumn": 25
            },
            "context": {
                "startLine": 410,
                "endLine": 414,
                "snippet": {
                    "text": "tmpr = EVP_Cipher(ds, recs[0].data, recs[0].input,"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/engines/e_ossltest.c",
                        "function_body": "778 # define data(ctx) ((EVP_AES_HMAC_SHA1 *)EVP_CIPHER_CTX_get_cipher_data(ctx))"
                    },
                    {
                        "file_path": "/crypto/evp/e_xcbc_d.c",
                        "function_body": "38 # define data(ctx) EVP_C_DATA(DESX_CBC_KEY,ctx)"
                    },
                    {
                        "file_path": "/crypto/evp/e_rc5.c",
                        "function_body": "36 # define data(ctx)       EVP_C_DATA(EVP_RC5_KEY,ctx)"
                    },
                    {
                        "file_path": "/crypto/evp/e_rc4_hmac_md5.c",
                        "function_body": "42 # define data(ctx) ((EVP_RC4_HMAC_MD5 *)EVP_CIPHER_CTX_get_cipher_data(ctx))"
                    },
                    {
                        "file_path": "/crypto/evp/e_rc4.c",
                        "function_body": "31 # define data(ctx) ((EVP_RC4_KEY *)EVP_CIPHER_CTX_get_cipher_data(ctx))"
                    },
                    {
                        "file_path": "/crypto/evp/e_rc2.c",
                        "function_body": "40 # define data(ctx)       EVP_C_DATA(EVP_RC2_KEY,ctx)"
                    },
                    {
                        "file_path": "/crypto/evp/e_des3.c",
                        "function_body": "62 # define data(ctx) EVP_C_DATA(DES_EDE_KEY,ctx)"
                    },
                    {
                        "file_path": "/crypto/evp/e_chacha20_poly1305.c",
                        "function_body": "32 #define data(ctx)   ((EVP_CHACHA_KEY *)(ctx)->cipher_data)"
                    },
                    {
                        "file_path": "/crypto/evp/e_cast.c",
                        "function_body": "33 # define data(ctx)       EVP_C_DATA(EVP_CAST_KEY,ctx)"
                    },
                    {
                        "file_path": "/crypto/evp/e_camellia.c",
                        "function_body": "44 #define data(ctx)       EVP_C_DATA(EVP_CAMELLIA_KEY,ctx)"
                    },
                    {
                        "file_path": "/crypto/evp/e_bf.c",
                        "function_body": "32 # define data(ctx)       EVP_C_DATA(EVP_BF_KEY,ctx)"
                    },
                    {
                        "file_path": "/crypto/evp/e_aes_cbc_hmac_sha256.c",
                        "function_body": "63 # define data(ctx) ((EVP_AES_HMAC_SHA256 *)EVP_CIPHER_CTX_get_cipher_data(ctx))"
                    },
                    {
                        "file_path": "/crypto/evp/e_aes_cbc_hmac_sha1.c",
                        "function_body": "67 # define data(ctx) ((EVP_AES_HMAC_SHA1 *)EVP_CIPHER_CTX_get_cipher_data(ctx))"
                    },
                    {
                        "file_path": "/crypto/evp/evp_lib.c",
                        "function_body": "387 int EVP_Cipher(EVP_CIPHER_CTX *ctx, unsigned char *out,\n388                const unsigned char *in, unsigned int inl)\n389 {\n390     if (ctx == NULL || ctx->cipher == NULL)\n391         return 0;\n392\n393     if (ctx->cipher->prov != NULL) {\n394         /*\n395          * If the provided implementation has a ccipher function, we use it,\n396          * and translate its return value like this: 0 => -1, 1 => outlen\n397          *\n398          * Otherwise, we call the cupdate function if in != NULL, or cfinal\n399          * if in == NULL.  Regardless of which, we return what we got.\n400          */\n401         int ret = -1;\n402         size_t outl = 0;\n403         size_t blocksize = EVP_CIPHER_CTX_get_block_size(ctx);\n404\n405         if (blocksize == 0)\n406             return 0;\n407\n408         if (ctx->cipher->ccipher != NULL)\n409             ret =  ctx->cipher->ccipher(ctx->algctx, out, &outl,\n410                                         inl + (blocksize == 1 ? 0 : blocksize),\n411                                         in, (size_t)inl)\n412                 ? (int)outl : -1;\n413         else if (in != NULL)\n414             ret = ctx->cipher->cupdate(ctx->algctx, out, &outl,\n415                                        inl + (blocksize == 1 ? 0 : blocksize),\n416                                        in, (size_t)inl);\n417         else\n418             ret = ctx->cipher->cfinal(ctx->algctx, out, &outl,\n419                                       blocksize == 1 ? 0 : blocksize);\n420\n421         return ret;\n422     }\n423\n424     return ctx->cipher->do_cipher(ctx, out, in, inl);\n425 }"
                    },
                    {
                        "file_path": "/ssl/record/methods/tls1_meth.c",
                        "function_body": "167 static int tls1_cipher(OSSL_RECORD_LAYER *rl, TLS_RL_RECORD *recs,\n168                        size_t n_recs, int sending, SSL_MAC_BUF *macs,\n169                        size_t macsize)\n170 {\n171     EVP_CIPHER_CTX *ds;\n172     size_t reclen[SSL_MAX_PIPELINES];\n173     unsigned char buf[SSL_MAX_PIPELINES][EVP_AEAD_TLS1_AAD_LEN];\n174     unsigned char *data[SSL_MAX_PIPELINES];\n175     int pad = 0, tmpr, provided;\n176     size_t bs, ctr, padnum, loop;\n177     unsigned char padval;\n178     const EVP_CIPHER *enc;\n179\n180     if (n_recs == 0) {\n181         RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n182         return 0;\n183     }\n184\n185     if (EVP_MD_CTX_get0_md(rl->md_ctx)) {\n186         int n = EVP_MD_CTX_get_size(rl->md_ctx);\n187\n188         if (!ossl_assert(n >= 0)) {\n189             RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n190             return 0;\n191         }\n192     }\n193     ds = rl->enc_ctx;\n194     if (!ossl_assert(rl->enc_ctx != NULL)) {\n195         RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n196         return 0;\n197     }\n198\n199     enc = EVP_CIPHER_CTX_get0_cipher(rl->enc_ctx);\n200\n201     if (sending) {\n202         int ivlen;\n203\n204         /* For TLSv1.1 and later explicit IV */\n205         if (RLAYER_USE_EXPLICIT_IV(rl)\n206             && EVP_CIPHER_get_mode(enc) == EVP_CIPH_CBC_MODE)\n207             ivlen = EVP_CIPHER_get_iv_length(enc);\n208         else\n209             ivlen = 0;\n210         if (ivlen > 1) {\n211             for (ctr = 0; ctr < n_recs; ctr++) {\n212                 if (recs[ctr].data != recs[ctr].input) {\n213                     RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n214                     return 0;\n215                 } else if (RAND_bytes_ex(rl->libctx, recs[ctr].input,\n216                                          ivlen, 0) <= 0) {\n217                     RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n218                     return 0;\n219                 }\n220             }\n221         }\n222     }\n223     if (!ossl_assert(enc != NULL)) {\n224         RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n225         return 0;\n226     }\n227\n228     provided = (EVP_CIPHER_get0_provider(enc) != NULL);\n229\n230     bs = EVP_CIPHER_get_block_size(EVP_CIPHER_CTX_get0_cipher(ds));\n231\n232     if (bs == 0) {\n233         RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_BAD_CIPHER);\n234         return 0;\n235     }\n236\n237     if (n_recs > 1) {\n238         if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))\n239                  & EVP_CIPH_FLAG_PIPELINE) == 0) {\n240             /*\n241              * We shouldn't have been called with pipeline data if the\n242              * cipher doesn't support pipelining\n243              */\n244             RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_PIPELINE_FAILURE);\n245             return 0;\n246         }\n247     }\n248     for (ctr = 0; ctr < n_recs; ctr++) {\n249         reclen[ctr] = recs[ctr].length;\n250\n251         if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))\n252                  & EVP_CIPH_FLAG_AEAD_CIPHER) != 0) {\n253             unsigned char *seq;\n254\n255             seq = rl->sequence;\n256\n257             if (rl->isdtls) {\n258                 unsigned char dtlsseq[8], *p = dtlsseq;\n259\n260                 s2n(rl->epoch, p);\n261                 memcpy(p, &seq[2], 6);\n262                 memcpy(buf[ctr], dtlsseq, 8);\n263             } else {\n264                 memcpy(buf[ctr], seq, 8);\n265                 if (!tls_increment_sequence_ctr(rl)) {\n266                     /* RLAYERfatal already called */\n267                     return 0;\n268                 }\n269             }\n270\n271             buf[ctr][8] = recs[ctr].type;\n272             buf[ctr][9] = (unsigned char)(rl->version >> 8);\n273             buf[ctr][10] = (unsigned char)(rl->version);\n274             buf[ctr][11] = (unsigned char)(recs[ctr].length >> 8);\n275             buf[ctr][12] = (unsigned char)(recs[ctr].length & 0xff);\n276             pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD,\n277                                       EVP_AEAD_TLS1_AAD_LEN, buf[ctr]);\n278             if (pad <= 0) {\n279                 RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n280                 return 0;\n281             }\n282\n283             if (sending) {\n284                 reclen[ctr] += pad;\n285                 recs[ctr].length += pad;\n286             }\n287         } else if ((bs != 1) && sending && !provided) {\n288             /*\n289              * We only do this for legacy ciphers. Provided ciphers add the\n290              * padding on the provider side.\n291              */\n292             padnum = bs - (reclen[ctr] % bs);\n293\n294             /* Add weird padding of up to 256 bytes */\n295\n296             if (padnum > MAX_PADDING) {\n297                 RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n298                 return 0;\n299             }\n300             /* we need to add 'padnum' padding bytes of value padval */\n301             padval = (unsigned char)(padnum - 1);\n302             for (loop = reclen[ctr]; loop < reclen[ctr] + padnum; loop++)\n303                 recs[ctr].input[loop] = padval;\n304             reclen[ctr] += padnum;\n305             recs[ctr].length += padnum;\n306         }\n307\n308         if (!sending) {\n309             if (reclen[ctr] == 0 || reclen[ctr] % bs != 0) {\n310                 /* Publicly invalid */\n311                 return 0;\n312             }\n313         }\n314     }\n315     if (n_recs > 1) {\n316         /* Set the output buffers */\n317         for (ctr = 0; ctr < n_recs; ctr++)\n318             data[ctr] = recs[ctr].data;\n319\n320         if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS,\n321                                 (int)n_recs, data) <= 0) {\n322             RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_PIPELINE_FAILURE);\n323             return 0;\n324         }\n325         /* Set the input buffers */\n326         for (ctr = 0; ctr < n_recs; ctr++)\n327             data[ctr] = recs[ctr].input;\n328\n329         if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_BUFS,\n330                                 (int)n_recs, data) <= 0\n331             || EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_SET_PIPELINE_INPUT_LENS,\n332                                    (int)n_recs, reclen) <= 0) {\n333             RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, SSL_R_PIPELINE_FAILURE);\n334             return 0;\n335         }\n336     }\n337\n338     if (!rl->isdtls && rl->tlstree) {\n339         int decrement_seq = 0;\n340\n341         /*\n342          * When sending, seq is incremented after MAC calculation.\n343          * So if we are in ETM mode, we use seq 'as is' in the ctrl-function.\n344          * Otherwise we have to decrease it in the implementation\n345          */\n346         if (sending && !rl->use_etm)\n347             decrement_seq = 1;\n348\n349         if (EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_TLSTREE, decrement_seq,\n350                                 rl->sequence) <= 0) {\n351\n352             RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n353             return 0;\n354         }\n355     }\n356\n357     if (provided) {\n358         int outlen;\n359\n360         /* Provided cipher - we do not support pipelining on this path */\n361         if (n_recs > 1) {\n362             RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n363             return 0;\n364         }\n365\n366         if (!EVP_CipherUpdate(ds, recs[0].data, &outlen, recs[0].input,\n367                               (unsigned int)reclen[0]))\n368             return 0;\n369         recs[0].length = outlen;\n370\n371         /*\n372          * The length returned from EVP_CipherUpdate above is the actual\n373          * payload length. We need to adjust the data/input ptr to skip over\n374          * any explicit IV\n375          */\n376         if (!sending) {\n377             if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_GCM_MODE) {\n378                 recs[0].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n379                 recs[0].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n380             } else if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_CCM_MODE) {\n381                 recs[0].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n382                 recs[0].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n383             } else if (bs != 1 && RLAYER_USE_EXPLICIT_IV(rl)) {\n384                 recs[0].data += bs;\n385                 recs[0].input += bs;\n386                 recs[0].orig_len -= bs;\n387             }\n388\n389             /* Now get a pointer to the MAC (if applicable) */\n390             if (macs != NULL) {\n391                 OSSL_PARAM params[2], *p = params;\n392\n393                 /* Get the MAC */\n394                 macs[0].alloced = 0;\n395\n396                 *p++ = OSSL_PARAM_construct_octet_ptr(OSSL_CIPHER_PARAM_TLS_MAC,\n397                                                       (void **)&macs[0].mac,\n398                                                       macsize);\n399                 *p = OSSL_PARAM_construct_end();\n400\n401                 if (!EVP_CIPHER_CTX_get_params(ds, params)) {\n402                     /* Shouldn't normally happen */\n403                     RLAYERfatal(rl, SSL_AD_INTERNAL_ERROR,\n404                                 ERR_R_INTERNAL_ERROR);\n405                     return 0;\n406                 }\n407             }\n408         }\n409     } else {\n410         /* Legacy cipher */\n411\n412         tmpr = EVP_Cipher(ds, recs[0].data, recs[0].input,\n413                           (unsigned int)reclen[0]);\n414         if ((EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(ds))\n415                  & EVP_CIPH_FLAG_CUSTOM_CIPHER) != 0\n416             ? (tmpr < 0)\n417             : (tmpr == 0)) {\n418             /* AEAD can fail to verify MAC */\n419             return 0;\n420         }\n421\n422         if (!sending) {\n423             for (ctr = 0; ctr < n_recs; ctr++) {\n424                 /* Adjust the record to remove the explicit IV/MAC/Tag */\n425                 if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_GCM_MODE) {\n426                     recs[ctr].data += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n427                     recs[ctr].input += EVP_GCM_TLS_EXPLICIT_IV_LEN;\n428                     recs[ctr].length -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n429                 } else if (EVP_CIPHER_get_mode(enc) == EVP_CIPH_CCM_MODE) {\n430                     recs[ctr].data += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n431                     recs[ctr].input += EVP_CCM_TLS_EXPLICIT_IV_LEN;\n432                     recs[ctr].length -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n433                 } else if (bs != 1 && RLAYER_USE_EXPLICIT_IV(rl)) {\n434                     if (recs[ctr].length < bs)\n435                         return 0;\n436                     recs[ctr].data += bs;\n437                     recs[ctr].input += bs;\n438                     recs[ctr].length -= bs;\n439                     recs[ctr].orig_len -= bs;\n440                 }\n441\n442                 /*\n443                  * If using Mac-then-encrypt, then this will succeed but\n444                  * with a random MAC if padding is invalid\n445                  */\n446                 if (!tls1_cbc_remove_padding_and_mac(&recs[ctr].length,\n447                                         recs[ctr].orig_len,\n448                                         recs[ctr].data,\n449                                         (macs != NULL) ? &macs[ctr].mac : NULL,\n450                                         (macs != NULL) ? &macs[ctr].alloced\n451                                                        : NULL,\n452                                         bs,\n453                                         pad ? (size_t)pad : macsize,\n454                                         (EVP_CIPHER_get_flags(enc)\n455                                         & EVP_CIPH_FLAG_AEAD_CIPHER) != 0,\n456                                         rl->libctx))\n457                     return 0;\n458             }\n459         }\n460     }\n461     return 1;\n462 }"
                    }
                ]
            }
        ],
        "sink": "tmpr = EVP_Cipher(ds, recs[0].data, recs[0].input,",
        "final_sink": "tmpr = EVP_Cipher(ds, recs[0].data, recs[0].input,"
    },
    {
        "prt": "ret",
        "function_call": [
            "static int asn1_bio_flush_ex(BIO *b, BIO_ASN1_BUF_CTX *ctx,\n                             asn1_ps_func *cleanup, asn1_bio_state_t next)\n{\n    int ret;\n\n    if (ctx->ex_len <= 0)\n        return 1;\n    for (;;) {\n        ret = BIO_write(BIO_next(b), ctx->ex_buf + ctx->ex_pos, ctx->ex_len);\n        if (ret <= 0)\n            break;\n        ctx->ex_len -= ret;\n        if (ctx->ex_len > 0)\n            ctx->ex_pos += ret;\n        else {\n            if (cleanup)\n                cleanup(b, &ctx->ex_buf, &ctx->ex_len, &ctx->ex_arg);\n            ctx->state = next;\n            ctx->ex_pos = 0;\n            break;\n        }\n    }\n    return ret;\n}"
        ],
        "source": [
            "    int ret;"
        ],
        "index": 52,
        "location": {
            "file_path": "crypto/asn1/bio_asn1.c",
            "region": {
                "startLine": 276,
                "startColumn": 5,
                "endColumn": 8
            },
            "context": {
                "startLine": 274,
                "endLine": 278,
                "snippet": {
                    "text": "return ret;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/bio_asn1.c",
                        "function_body": "254 static int asn1_bio_flush_ex(BIO *b, BIO_ASN1_BUF_CTX *ctx,\n255                              asn1_ps_func *cleanup, asn1_bio_state_t next)\n256 {\n257     int ret;\n258\n259     if (ctx->ex_len <= 0)\n260         return 1;\n261     for (;;) {\n262         ret = BIO_write(BIO_next(b), ctx->ex_buf + ctx->ex_pos, ctx->ex_len);\n263         if (ret <= 0)\n264             break;\n265         ctx->ex_len -= ret;\n266         if (ctx->ex_len > 0)\n267             ctx->ex_pos += ret;\n268         else {\n269             if (cleanup)\n270                 cleanup(b, &ctx->ex_buf, &ctx->ex_len, &ctx->ex_arg);\n271             ctx->state = next;\n272             ctx->ex_pos = 0;\n273             break;\n274         }\n275     }\n276     return ret;\n277 }"
                    },
                    {
                        "file_path": "/crypto/asn1/bio_asn1.c",
                        "function_body": "154 static int asn1_bio_write(BIO *b, const char *in, int inl)\n155 {\n156     BIO_ASN1_BUF_CTX *ctx;\n157     int wrmax, wrlen, ret;\n158     unsigned char *p;\n159     BIO *next;\n160\n161     ctx = BIO_get_data(b);\n162     next = BIO_next(b);\n163     if (in == NULL || inl < 0 || ctx == NULL || next == NULL)\n164         return 0;\n165\n166     wrlen = 0;\n167     ret = -1;\n168\n169     for (;;) {\n170         switch (ctx->state) {\n171             /* Setup prefix data, call it */\n172         case ASN1_STATE_START:\n173             if (!asn1_bio_setup_ex(b, ctx, ctx->prefix,\n174                                    ASN1_STATE_PRE_COPY, ASN1_STATE_HEADER))\n175                 return -1;\n176             break;\n177\n178             /* Copy any pre data first */\n179         case ASN1_STATE_PRE_COPY:\n180\n181             ret = asn1_bio_flush_ex(b, ctx, ctx->prefix_free,\n182                                     ASN1_STATE_HEADER);\n183\n184             if (ret <= 0)\n185                 goto done;\n186\n187             break;\n188\n189         case ASN1_STATE_HEADER:\n190             ctx->buflen = ASN1_object_size(0, inl, ctx->asn1_tag) - inl;\n191             if (!ossl_assert(ctx->buflen <= ctx->bufsize))\n192                 return -1;\n193             p = ctx->buf;\n194             ASN1_put_object(&p, 0, inl, ctx->asn1_tag, ctx->asn1_class);\n195             ctx->copylen = inl;\n196             ctx->state = ASN1_STATE_HEADER_COPY;\n197\n198             break;\n199\n200         case ASN1_STATE_HEADER_COPY:\n201             ret = BIO_write(next, ctx->buf + ctx->bufpos, ctx->buflen);\n202             if (ret <= 0)\n203                 goto done;\n204\n205             ctx->buflen -= ret;\n206             if (ctx->buflen)\n207                 ctx->bufpos += ret;\n208             else {\n209                 ctx->bufpos = 0;\n210                 ctx->state = ASN1_STATE_DATA_COPY;\n211             }\n212\n213             break;\n214\n215         case ASN1_STATE_DATA_COPY:\n216\n217             if (inl > ctx->copylen)\n218                 wrmax = ctx->copylen;\n219             else\n220                 wrmax = inl;\n221             ret = BIO_write(next, in, wrmax);\n222             if (ret <= 0)\n223                 goto done;\n224             wrlen += ret;\n225             ctx->copylen -= ret;\n226             in += ret;\n227             inl -= ret;\n228\n229             if (ctx->copylen == 0)\n230                 ctx->state = ASN1_STATE_HEADER;\n231\n232             if (inl == 0)\n233                 goto done;\n234\n235             break;\n236\n237         case ASN1_STATE_POST_COPY:\n238         case ASN1_STATE_DONE:\n239             BIO_clear_retry_flags(b);\n240             return 0;\n241\n242         }\n243\n244     }\n245\n246  done:\n247     BIO_clear_retry_flags(b);\n248     BIO_copy_next_retry(b);\n249\n250     return (wrlen > 0) ? wrlen : ret;\n251\n252 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/asn1/bio_asn1.c",
                        "function_body": "254 static int asn1_bio_flush_ex(BIO *b, BIO_ASN1_BUF_CTX *ctx,\n255                              asn1_ps_func *cleanup, asn1_bio_state_t next)\n256 {\n257     int ret;\n258\n259     if (ctx->ex_len <= 0)\n260         return 1;\n261     for (;;) {\n262         ret = BIO_write(BIO_next(b), ctx->ex_buf + ctx->ex_pos, ctx->ex_len);\n263         if (ret <= 0)\n264             break;\n265         ctx->ex_len -= ret;\n266         if (ctx->ex_len > 0)\n267             ctx->ex_pos += ret;\n268         else {\n269             if (cleanup)\n270                 cleanup(b, &ctx->ex_buf, &ctx->ex_len, &ctx->ex_arg);\n271             ctx->state = next;\n272             ctx->ex_pos = 0;\n273             break;\n274         }\n275     }\n276     return ret;\n277 }"
                    },
                    {
                        "file_path": "/crypto/asn1/bio_asn1.c",
                        "function_body": "324 static long asn1_bio_ctrl(BIO *b, int cmd, long arg1, void *arg2)\n325 {\n326     BIO_ASN1_BUF_CTX *ctx;\n327     BIO_ASN1_EX_FUNCS *ex_func;\n328     long ret = 1;\n329     BIO *next;\n330\n331     ctx = BIO_get_data(b);\n332     if (ctx == NULL)\n333         return 0;\n334     next = BIO_next(b);\n335     switch (cmd) {\n336\n337     case BIO_C_SET_PREFIX:\n338         ex_func = arg2;\n339         ctx->prefix = ex_func->ex_func;\n340         ctx->prefix_free = ex_func->ex_free_func;\n341         break;\n342\n343     case BIO_C_GET_PREFIX:\n344         ex_func = arg2;\n345         ex_func->ex_func = ctx->prefix;\n346         ex_func->ex_free_func = ctx->prefix_free;\n347         break;\n348\n349     case BIO_C_SET_SUFFIX:\n350         ex_func = arg2;\n351         ctx->suffix = ex_func->ex_func;\n352         ctx->suffix_free = ex_func->ex_free_func;\n353         break;\n354\n355     case BIO_C_GET_SUFFIX:\n356         ex_func = arg2;\n357         ex_func->ex_func = ctx->suffix;\n358         ex_func->ex_free_func = ctx->suffix_free;\n359         break;\n360\n361     case BIO_C_SET_EX_ARG:\n362         ctx->ex_arg = arg2;\n363         break;\n364\n365     case BIO_C_GET_EX_ARG:\n366         *(void **)arg2 = ctx->ex_arg;\n367         break;\n368\n369     case BIO_CTRL_FLUSH:\n370         if (next == NULL)\n371             return 0;\n372\n373         /* Call post function if possible */\n374         if (ctx->state == ASN1_STATE_HEADER) {\n375             if (!asn1_bio_setup_ex(b, ctx, ctx->suffix,\n376                                    ASN1_STATE_POST_COPY, ASN1_STATE_DONE))\n377                 return 0;\n378         }\n379\n380         if (ctx->state == ASN1_STATE_POST_COPY) {\n381             ret = asn1_bio_flush_ex(b, ctx, ctx->suffix_free,\n382                                     ASN1_STATE_DONE);\n383             if (ret <= 0)\n384                 return ret;\n385         }\n386\n387         if (ctx->state == ASN1_STATE_DONE)\n388             return BIO_ctrl(next, cmd, arg1, arg2);\n389         else {\n390             BIO_clear_retry_flags(b);\n391             return 0;\n392         }\n393\n394     default:\n395         if (next == NULL)\n396             return 0;\n397         return BIO_ctrl(next, cmd, arg1, arg2);\n398\n399     }\n400\n401     return ret;\n402 }"
                    }
                ]
            }
        ],
        "sink": "return ret;",
        "final_sink": "return ret;"
    },
    {
        "prt": "permute[_]",
        "function_call": [
            "int run_tests(const char *test_prog_name)\n{\n    int num_failed = 0;\n    int verdict = 1;\n    int ii, i, jj, j, jstep;\n    int test_case_count = 0;\n    int subtest_case_count = 0;\n    int permute[OSSL_NELEM(all_tests)];\n\n    i = process_shared_options();\n    if (i == 0)\n        return EXIT_SUCCESS;\n    if (i == -1)\n        return EXIT_FAILURE;\n\n    if (num_tests < 1) {\n        test_printf_tapout(\"1..0 # Skipped: %s\\n\", test_prog_name);\n    } else if (show_list == 0 && single_test == -1) {\n        if (level > 0) {\n            test_printf_stdout(\"Subtest: %s\\n\", test_prog_name);\n            test_flush_stdout();\n        }\n        test_printf_tapout(\"1..%d\\n\", num_test_cases);\n    }\n\n    test_flush_tapout();\n\n    for (i = 0; i < num_tests; i++)\n        permute[i] = i;\n    if (rand_order != 0)\n        for (i = num_tests - 1; i >= 1; i--) {\n            j = test_random() % (1 + i);\n            ii = permute[j];\n            permute[j] = permute[i];\n            permute[i] = ii;\n        }\n\n    for (ii = 0; ii != num_tests; ++ii) {\n        i = permute[ii];\n\n        if (single_test != -1 && ((i+1) != single_test)) {\n            continue;\n        }\n        else if (show_list) {\n            if (all_tests[i].num != -1) {\n                test_printf_tapout(\"%d - %s (%d..%d)\\n\", ii + 1,\n                                   all_tests[i].test_case_name, 1,\n                                   all_tests[i].num);\n            } else {\n                test_printf_tapout(\"%d - %s\\n\", ii + 1,\n                                   all_tests[i].test_case_name);\n            }\n            test_flush_tapout();\n        } else if (all_tests[i].num == -1) {\n            set_test_title(all_tests[i].test_case_name);\n            ERR_clear_error();\n            verdict = all_tests[i].test_fn();\n            finalize(verdict != 0);\n            test_verdict(verdict, \"%d - %s\", test_case_count + 1, test_title);\n            if (verdict == 0)\n                num_failed++;\n            test_case_count++;\n        } else {\n            verdict = TEST_SKIP_CODE;\n            set_test_title(all_tests[i].test_case_name);\n            if (all_tests[i].subtest) {\n                level += 4;\n                test_adjust_streams_tap_level(level);\n                if (single_iter == -1) {\n                    test_printf_stdout(\"Subtest: %s\\n\", test_title);\n                    test_printf_tapout(\"%d..%d\\n\", 1, all_tests[i].num);\n                    test_flush_stdout();\n                    test_flush_tapout();\n                }\n            }\n\n            j = -1;\n            if (rand_order == 0 || all_tests[i].num < 3)\n                jstep = 1;\n            else\n                do\n                    jstep = test_random() % all_tests[i].num;\n                while (jstep == 0 || gcd(all_tests[i].num, jstep) != 1);\n\n            for (jj = 0; jj < all_tests[i].num; jj++) {\n                int v;\n\n                j = (j + jstep) % all_tests[i].num;\n                if (single_iter != -1 && ((jj + 1) != single_iter))\n                    continue;\n                ERR_clear_error();\n                v = all_tests[i].param_test_fn(j);\n\n                if (v == 0) {\n                    verdict = 0;\n                } else if (v != TEST_SKIP_CODE && verdict != 0) {\n                    verdict = 1;\n                }\n\n                finalize(v != 0);\n\n                if (all_tests[i].subtest)\n                    test_verdict(v, \"%d - iteration %d\",\n                                 subtest_case_count + 1, j + 1);\n                else\n                    test_verdict(v, \"%d - %s - iteration %d\",\n                                 test_case_count + subtest_case_count + 1,\n                                 test_title, j + 1);\n                subtest_case_count++;\n            }\n\n            if (all_tests[i].subtest) {\n                level -= 4;\n                test_adjust_streams_tap_level(level);\n            }\n            if (verdict == 0)\n                ++num_failed;\n            if (all_tests[i].num == -1 || all_tests[i].subtest)\n                test_verdict(verdict, \"%d - %s\", test_case_count + 1,\n                             all_tests[i].test_case_name);\n            test_case_count++;\n        }\n    }\n    if (num_failed != 0)\n        return EXIT_FAILURE;\n    return EXIT_SUCCESS;\n}"
        ],
        "source": [
            "    int permute[OSSL_NELEM(all_tests)];"
        ],
        "index": 53,
        "location": {
            "file_path": "test/testutil/driver.c",
            "region": {
                "startLine": 319,
                "startColumn": 13,
                "endColumn": 23
            },
            "context": {
                "startLine": 317,
                "endLine": 321,
                "snippet": {
                    "text": "permute[j] = permute[i];"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/test/testutil/driver.c",
                        "function_body": "286 int run_tests(const char *test_prog_name)\n287 {\n288     int num_failed = 0;\n289     int verdict = 1;\n290     int ii, i, jj, j, jstep;\n291     int test_case_count = 0;\n292     int subtest_case_count = 0;\n293     int permute[OSSL_NELEM(all_tests)];\n294\n295     i = process_shared_options();\n296     if (i == 0)\n297         return EXIT_SUCCESS;\n298     if (i == -1)\n299         return EXIT_FAILURE;\n300\n301     if (num_tests < 1) {\n302         test_printf_tapout(\"1..0 # Skipped: %s\\n\", test_prog_name);\n303     } else if (show_list == 0 && single_test == -1) {\n304         if (level > 0) {\n305             test_printf_stdout(\"Subtest: %s\\n\", test_prog_name);\n306             test_flush_stdout();\n307         }\n308         test_printf_tapout(\"1..%d\\n\", num_test_cases);\n309     }\n310\n311     test_flush_tapout();\n312\n313     for (i = 0; i < num_tests; i++)\n314         permute[i] = i;\n315     if (rand_order != 0)\n316         for (i = num_tests - 1; i >= 1; i--) {\n317             j = test_random() % (1 + i);\n318             ii = permute[j];\n319             permute[j] = permute[i];\n320             permute[i] = ii;\n321         }\n322\n323     for (ii = 0; ii != num_tests; ++ii) {\n324         i = permute[ii];\n325\n326         if (single_test != -1 && ((i+1) != single_test)) {\n327             continue;\n328         }\n329         else if (show_list) {\n330             if (all_tests[i].num != -1) {\n331                 test_printf_tapout(\"%d - %s (%d..%d)\\n\", ii + 1,\n332                                    all_tests[i].test_case_name, 1,\n333                                    all_tests[i].num);\n334             } else {\n335                 test_printf_tapout(\"%d - %s\\n\", ii + 1,\n336                                    all_tests[i].test_case_name);\n337             }\n338             test_flush_tapout();\n339         } else if (all_tests[i].num == -1) {\n340             set_test_title(all_tests[i].test_case_name);\n341             ERR_clear_error();\n342             verdict = all_tests[i].test_fn();\n343             finalize(verdict != 0);\n344             test_verdict(verdict, \"%d - %s\", test_case_count + 1, test_title);\n345             if (verdict == 0)\n346                 num_failed++;\n347             test_case_count++;\n348         } else {\n349             verdict = TEST_SKIP_CODE;\n350             set_test_title(all_tests[i].test_case_name);\n351             if (all_tests[i].subtest) {\n352                 level += 4;\n353                 test_adjust_streams_tap_level(level);\n354                 if (single_iter == -1) {\n355                     test_printf_stdout(\"Subtest: %s\\n\", test_title);\n356                     test_printf_tapout(\"%d..%d\\n\", 1, all_tests[i].num);\n357                     test_flush_stdout();\n358                     test_flush_tapout();\n359                 }\n360             }\n361\n362             j = -1;\n363             if (rand_order == 0 || all_tests[i].num < 3)\n364                 jstep = 1;\n365             else\n366                 do\n367                     jstep = test_random() % all_tests[i].num;\n368                 while (jstep == 0 || gcd(all_tests[i].num, jstep) != 1);\n369\n370             for (jj = 0; jj < all_tests[i].num; jj++) {\n371                 int v;\n372\n373                 j = (j + jstep) % all_tests[i].num;\n374                 if (single_iter != -1 && ((jj + 1) != single_iter))\n375                     continue;\n376                 ERR_clear_error();\n377                 v = all_tests[i].param_test_fn(j);\n378\n379                 if (v == 0) {\n380                     verdict = 0;\n381                 } else if (v != TEST_SKIP_CODE && verdict != 0) {\n382                     verdict = 1;\n383                 }\n384\n385                 finalize(v != 0);\n386\n387                 if (all_tests[i].subtest)\n388                     test_verdict(v, \"%d - iteration %d\",\n389                                  subtest_case_count + 1, j + 1);\n390                 else\n391                     test_verdict(v, \"%d - %s - iteration %d\",\n392                                  test_case_count + subtest_case_count + 1,\n393                                  test_title, j + 1);\n394                 subtest_case_count++;\n395             }\n396\n397             if (all_tests[i].subtest) {\n398                 level -= 4;\n399                 test_adjust_streams_tap_level(level);\n400             }\n401             if (verdict == 0)\n402                 ++num_failed;\n403             if (all_tests[i].num == -1 || all_tests[i].subtest)\n404                 test_verdict(verdict, \"%d - %s\", test_case_count + 1,\n405                              all_tests[i].test_case_name);\n406             test_case_count++;\n407         }\n408     }\n409     if (num_failed != 0)\n410         return EXIT_FAILURE;\n411     return EXIT_SUCCESS;\n412 }"
                    },
                    {
                        "file_path": "/test/testutil/main.c",
                        "function_body": "15 int main(int argc, char *argv[])\n16 {\n17     int ret = EXIT_FAILURE;\n18     int setup_res;\n19\n20     test_open_streams();\n21\n22     if (!global_init()) {\n23         test_printf_stderr(\"Global init failed - aborting\\n\");\n24         return ret;\n25     }\n26\n27     if (!setup_test_framework(argc, argv))\n28         goto end;\n29\n30     if ((setup_res = setup_tests()) > 0) {\n31         ret = run_tests(argv[0]);\n32         cleanup_tests();\n33         opt_check_usage();\n34     } else if (setup_res == 0) {\n35         opt_help(test_get_options());\n36     }\n37 end:\n38     ret = pulldown_test_framework(ret);\n39     test_close_streams();\n40     return ret;\n41 }"
                    }
                ]
            }
        ],
        "sink": "permute[j] = permute[i];",
        "final_sink": "permute[j] = permute[i];"
    },
    {
        "prt": "permute[_]",
        "function_call": [
            "int run_tests(const char *test_prog_name)\n{\n    int num_failed = 0;\n    int verdict = 1;\n    int ii, i, jj, j, jstep;\n    int test_case_count = 0;\n    int subtest_case_count = 0;\n    int permute[OSSL_NELEM(all_tests)];\n\n    i = process_shared_options();\n    if (i == 0)\n        return EXIT_SUCCESS;\n    if (i == -1)\n        return EXIT_FAILURE;\n\n    if (num_tests < 1) {\n        test_printf_tapout(\"1..0 # Skipped: %s\\n\", test_prog_name);\n    } else if (show_list == 0 && single_test == -1) {\n        if (level > 0) {\n            test_printf_stdout(\"Subtest: %s\\n\", test_prog_name);\n            test_flush_stdout();\n        }\n        test_printf_tapout(\"1..%d\\n\", num_test_cases);\n    }\n\n    test_flush_tapout();\n\n    for (i = 0; i < num_tests; i++)\n        permute[i] = i;\n    if (rand_order != 0)\n        for (i = num_tests - 1; i >= 1; i--) {\n            j = test_random() % (1 + i);\n            ii = permute[j];\n            permute[j] = permute[i];\n            permute[i] = ii;\n        }\n\n    for (ii = 0; ii != num_tests; ++ii) {\n        i = permute[ii];\n\n        if (single_test != -1 && ((i+1) != single_test)) {\n            continue;\n        }\n        else if (show_list) {\n            if (all_tests[i].num != -1) {\n                test_printf_tapout(\"%d - %s (%d..%d)\\n\", ii + 1,\n                                   all_tests[i].test_case_name, 1,\n                                   all_tests[i].num);\n            } else {\n                test_printf_tapout(\"%d - %s\\n\", ii + 1,\n                                   all_tests[i].test_case_name);\n            }\n            test_flush_tapout();\n        } else if (all_tests[i].num == -1) {\n            set_test_title(all_tests[i].test_case_name);\n            ERR_clear_error();\n            verdict = all_tests[i].test_fn();\n            finalize(verdict != 0);\n            test_verdict(verdict, \"%d - %s\", test_case_count + 1, test_title);\n            if (verdict == 0)\n                num_failed++;\n            test_case_count++;\n        } else {\n            verdict = TEST_SKIP_CODE;\n            set_test_title(all_tests[i].test_case_name);\n            if (all_tests[i].subtest) {\n                level += 4;\n                test_adjust_streams_tap_level(level);\n                if (single_iter == -1) {\n                    test_printf_stdout(\"Subtest: %s\\n\", test_title);\n                    test_printf_tapout(\"%d..%d\\n\", 1, all_tests[i].num);\n                    test_flush_stdout();\n                    test_flush_tapout();\n                }\n            }\n\n            j = -1;\n            if (rand_order == 0 || all_tests[i].num < 3)\n                jstep = 1;\n            else\n                do\n                    jstep = test_random() % all_tests[i].num;\n                while (jstep == 0 || gcd(all_tests[i].num, jstep) != 1);\n\n            for (jj = 0; jj < all_tests[i].num; jj++) {\n                int v;\n\n                j = (j + jstep) % all_tests[i].num;\n                if (single_iter != -1 && ((jj + 1) != single_iter))\n                    continue;\n                ERR_clear_error();\n                v = all_tests[i].param_test_fn(j);\n\n                if (v == 0) {\n                    verdict = 0;\n                } else if (v != TEST_SKIP_CODE && verdict != 0) {\n                    verdict = 1;\n                }\n\n                finalize(v != 0);\n\n                if (all_tests[i].subtest)\n                    test_verdict(v, \"%d - iteration %d\",\n                                 subtest_case_count + 1, j + 1);\n                else\n                    test_verdict(v, \"%d - %s - iteration %d\",\n                                 test_case_count + subtest_case_count + 1,\n                                 test_title, j + 1);\n                subtest_case_count++;\n            }\n\n            if (all_tests[i].subtest) {\n                level -= 4;\n                test_adjust_streams_tap_level(level);\n            }\n            if (verdict == 0)\n                ++num_failed;\n            if (all_tests[i].num == -1 || all_tests[i].subtest)\n                test_verdict(verdict, \"%d - %s\", test_case_count + 1,\n                             all_tests[i].test_case_name);\n            test_case_count++;\n        }\n    }\n    if (num_failed != 0)\n        return EXIT_FAILURE;\n    return EXIT_SUCCESS;\n}"
        ],
        "source": [
            "    int permute[OSSL_NELEM(all_tests)];"
        ],
        "index": 54,
        "location": {
            "file_path": "test/testutil/driver.c",
            "region": {
                "startLine": 324,
                "startColumn": 9,
                "endColumn": 19
            },
            "context": {
                "startLine": 322,
                "endLine": 326,
                "snippet": {
                    "text": "i = permute[ii];"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/test/testutil/driver.c",
                        "function_body": "286 int run_tests(const char *test_prog_name)\n287 {\n288     int num_failed = 0;\n289     int verdict = 1;\n290     int ii, i, jj, j, jstep;\n291     int test_case_count = 0;\n292     int subtest_case_count = 0;\n293     int permute[OSSL_NELEM(all_tests)];\n294\n295     i = process_shared_options();\n296     if (i == 0)\n297         return EXIT_SUCCESS;\n298     if (i == -1)\n299         return EXIT_FAILURE;\n300\n301     if (num_tests < 1) {\n302         test_printf_tapout(\"1..0 # Skipped: %s\\n\", test_prog_name);\n303     } else if (show_list == 0 && single_test == -1) {\n304         if (level > 0) {\n305             test_printf_stdout(\"Subtest: %s\\n\", test_prog_name);\n306             test_flush_stdout();\n307         }\n308         test_printf_tapout(\"1..%d\\n\", num_test_cases);\n309     }\n310\n311     test_flush_tapout();\n312\n313     for (i = 0; i < num_tests; i++)\n314         permute[i] = i;\n315     if (rand_order != 0)\n316         for (i = num_tests - 1; i >= 1; i--) {\n317             j = test_random() % (1 + i);\n318             ii = permute[j];\n319             permute[j] = permute[i];\n320             permute[i] = ii;\n321         }\n322\n323     for (ii = 0; ii != num_tests; ++ii) {\n324         i = permute[ii];\n325\n326         if (single_test != -1 && ((i+1) != single_test)) {\n327             continue;\n328         }\n329         else if (show_list) {\n330             if (all_tests[i].num != -1) {\n331                 test_printf_tapout(\"%d - %s (%d..%d)\\n\", ii + 1,\n332                                    all_tests[i].test_case_name, 1,\n333                                    all_tests[i].num);\n334             } else {\n335                 test_printf_tapout(\"%d - %s\\n\", ii + 1,\n336                                    all_tests[i].test_case_name);\n337             }\n338             test_flush_tapout();\n339         } else if (all_tests[i].num == -1) {\n340             set_test_title(all_tests[i].test_case_name);\n341             ERR_clear_error();\n342             verdict = all_tests[i].test_fn();\n343             finalize(verdict != 0);\n344             test_verdict(verdict, \"%d - %s\", test_case_count + 1, test_title);\n345             if (verdict == 0)\n346                 num_failed++;\n347             test_case_count++;\n348         } else {\n349             verdict = TEST_SKIP_CODE;\n350             set_test_title(all_tests[i].test_case_name);\n351             if (all_tests[i].subtest) {\n352                 level += 4;\n353                 test_adjust_streams_tap_level(level);\n354                 if (single_iter == -1) {\n355                     test_printf_stdout(\"Subtest: %s\\n\", test_title);\n356                     test_printf_tapout(\"%d..%d\\n\", 1, all_tests[i].num);\n357                     test_flush_stdout();\n358                     test_flush_tapout();\n359                 }\n360             }\n361\n362             j = -1;\n363             if (rand_order == 0 || all_tests[i].num < 3)\n364                 jstep = 1;\n365             else\n366                 do\n367                     jstep = test_random() % all_tests[i].num;\n368                 while (jstep == 0 || gcd(all_tests[i].num, jstep) != 1);\n369\n370             for (jj = 0; jj < all_tests[i].num; jj++) {\n371                 int v;\n372\n373                 j = (j + jstep) % all_tests[i].num;\n374                 if (single_iter != -1 && ((jj + 1) != single_iter))\n375                     continue;\n376                 ERR_clear_error();\n377                 v = all_tests[i].param_test_fn(j);\n378\n379                 if (v == 0) {\n380                     verdict = 0;\n381                 } else if (v != TEST_SKIP_CODE && verdict != 0) {\n382                     verdict = 1;\n383                 }\n384\n385                 finalize(v != 0);\n386\n387                 if (all_tests[i].subtest)\n388                     test_verdict(v, \"%d - iteration %d\",\n389                                  subtest_case_count + 1, j + 1);\n390                 else\n391                     test_verdict(v, \"%d - %s - iteration %d\",\n392                                  test_case_count + subtest_case_count + 1,\n393                                  test_title, j + 1);\n394                 subtest_case_count++;\n395             }\n396\n397             if (all_tests[i].subtest) {\n398                 level -= 4;\n399                 test_adjust_streams_tap_level(level);\n400             }\n401             if (verdict == 0)\n402                 ++num_failed;\n403             if (all_tests[i].num == -1 || all_tests[i].subtest)\n404                 test_verdict(verdict, \"%d - %s\", test_case_count + 1,\n405                              all_tests[i].test_case_name);\n406             test_case_count++;\n407         }\n408     }\n409     if (num_failed != 0)\n410         return EXIT_FAILURE;\n411     return EXIT_SUCCESS;\n412 }"
                    },
                    {
                        "file_path": "/test/testutil/main.c",
                        "function_body": "15 int main(int argc, char *argv[])\n16 {\n17     int ret = EXIT_FAILURE;\n18     int setup_res;\n19\n20     test_open_streams();\n21\n22     if (!global_init()) {\n23         test_printf_stderr(\"Global init failed - aborting\\n\");\n24         return ret;\n25     }\n26\n27     if (!setup_test_framework(argc, argv))\n28         goto end;\n29\n30     if ((setup_res = setup_tests()) > 0) {\n31         ret = run_tests(argv[0]);\n32         cleanup_tests();\n33         opt_check_usage();\n34     } else if (setup_res == 0) {\n35         opt_help(test_get_options());\n36     }\n37 end:\n38     ret = pulldown_test_framework(ret);\n39     test_close_streams();\n40     return ret;\n41 }"
                    }
                ]
            }
        ],
        "sink": "i = permute[ii];",
        "final_sink": "i = permute[ii];"
    },
    {
        "prt": "counter",
        "function_call": [
            "static int aes_gcm_siv_ctr32(PROV_AES_GCM_SIV_CTX *ctx, const unsigned char *init_counter,\n                             unsigned char *out, const unsigned char *in, size_t len)\n{\n    uint8_t keystream[BLOCK_SIZE];\n    int out_len;\n    size_t i;\n    size_t j;\n    size_t todo;\n    uint32_t counter;\n    int error = 0;\n    union {\n        uint32_t x32[BLOCK_SIZE / sizeof(uint32_t)];\n        uint8_t x8[BLOCK_SIZE];\n    } block;\n    DECLARE_IS_ENDIAN;\n\n    memcpy(&block, init_counter, sizeof(block));\n    if (IS_BIG_ENDIAN) {\n        counter = GSWAP4(block.x32[0]);\n    }\n\n    for (i = 0; i < len; i += sizeof(block)) {\n        out_len = BLOCK_SIZE;\n        error |= !EVP_EncryptUpdate(ctx->ecb_ctx, keystream, &out_len, (uint8_t*)&block, sizeof(block));\n        if (IS_LITTLE_ENDIAN) {\n            block.x32[0]++;\n        } else {\n            counter++;\n            block.x32[0] = GSWAP4(counter);\n        }\n        todo = len - i;\n        if (todo > sizeof(keystream))\n            todo = sizeof(keystream);\n        /* Non optimal, but avoids alignment issues */\n        for (j = 0; j < todo; j++)\n            out[i + j] = in[i + j] ^ keystream[j];\n    }\n    return !error;\n}"
        ],
        "source": [
            "    uint32_t counter;"
        ],
        "index": 55,
        "location": {
            "file_path": "providers/implementations/ciphers/cipher_aes_gcm_siv_hw.c",
            "region": {
                "startLine": 361,
                "startColumn": 13,
                "endColumn": 20
            },
            "context": {
                "startLine": 359,
                "endLine": 363,
                "snippet": {
                    "text": "counter++;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/providers/implementations/ciphers/cipher_aes_gcm_siv_hw.c",
                        "function_body": "334 static int aes_gcm_siv_ctr32(PROV_AES_GCM_SIV_CTX *ctx, const unsigned char *init_counter,\n335                              unsigned char *out, const unsigned char *in, size_t len)\n336 {\n337     uint8_t keystream[BLOCK_SIZE];\n338     int out_len;\n339     size_t i;\n340     size_t j;\n341     size_t todo;\n342     uint32_t counter;\n343     int error = 0;\n344     union {\n345         uint32_t x32[BLOCK_SIZE / sizeof(uint32_t)];\n346         uint8_t x8[BLOCK_SIZE];\n347     } block;\n348     DECLARE_IS_ENDIAN;\n349\n350     memcpy(&block, init_counter, sizeof(block));\n351     if (IS_BIG_ENDIAN) {\n352         counter = GSWAP4(block.x32[0]);\n353     }\n354\n355     for (i = 0; i < len; i += sizeof(block)) {\n356         out_len = BLOCK_SIZE;\n357         error |= !EVP_EncryptUpdate(ctx->ecb_ctx, keystream, &out_len, (uint8_t*)&block, sizeof(block));\n358         if (IS_LITTLE_ENDIAN) {\n359             block.x32[0]++;\n360         } else {\n361             counter++;\n362             block.x32[0] = GSWAP4(counter);\n363         }\n364         todo = len - i;\n365         if (todo > sizeof(keystream))\n366             todo = sizeof(keystream);\n367         /* Non optimal, but avoids alignment issues */\n368         for (j = 0; j < todo; j++)\n369             out[i + j] = in[i + j] ^ keystream[j];\n370     }\n371     return !error;\n372 }"
                    },
                    {
                        "file_path": "/providers/implementations/ciphers/cipher_aes_gcm_siv_hw.c",
                        "function_body": "209 static int aes_gcm_siv_decrypt(PROV_AES_GCM_SIV_CTX *ctx, const unsigned char *in,\n210                                unsigned char *out, size_t len)\n211 {\n212     uint8_t counter_block[TAG_SIZE];\n213     uint64_t len_blk[2];\n214     uint8_t S_s[TAG_SIZE];\n215     size_t i;\n216     uint64_t padding[2];\n217     int64_t len64 = len;\n218     int out_len;\n219     int error = 0;\n220     DECLARE_IS_ENDIAN;\n221\n222     ctx->generated_tag = 0;\n223     if (!ctx->speed && ctx->used_dec)\n224         return 0;\n225     /* need to check the size of the input! */\n226     if (len64 > ((int64_t)1 << 36))\n227         return 0;\n228\n229     memcpy(counter_block, ctx->user_tag, sizeof(counter_block));\n230     counter_block[TAG_SIZE - 1] |= 0x80;\n231\n232     error |= !aes_gcm_siv_ctr32(ctx, counter_block, out, in, len);\n233\n234     if (IS_LITTLE_ENDIAN) {\n235         len_blk[0] = (uint64_t)ctx->aad_len * 8;\n236         len_blk[1] = (uint64_t)len * 8;\n237     } else {\n238         len_blk[0] = GSWAP8((uint64_t)ctx->aad_len * 8);\n239         len_blk[1] = GSWAP8((uint64_t)len * 8);\n240     }\n241     memset(S_s, 0, TAG_SIZE);\n242     ossl_polyval_ghash_init(ctx->Htable, (const uint64_t*)ctx->msg_auth_key);\n243     if (ctx->aad != NULL) {\n244         /* AAD allocated with padding, but need to adjust length */\n245         ossl_polyval_ghash_hash(ctx->Htable, S_s, ctx->aad, UP16(ctx->aad_len));\n246     }\n247     if (DOWN16(len) > 0)\n248         ossl_polyval_ghash_hash(ctx->Htable, S_s, out, DOWN16(len));\n249     if (!IS16(len)) {\n250         /* deal with padding - probably easier to \"memset\" the padding first rather than calculate */\n251         padding[0] = padding[1] = 0;\n252         memcpy(padding, &out[DOWN16(len)], REMAINDER16(len));\n253         ossl_polyval_ghash_hash(ctx->Htable, S_s, (uint8_t *)padding, sizeof(padding));\n254     }\n255     ossl_polyval_ghash_hash(ctx->Htable, S_s, (uint8_t *)len_blk, TAG_SIZE);\n256\n257     for (i = 0; i < NONCE_SIZE; i++)\n258         S_s[i] ^= ctx->nonce[i];\n259\n260     S_s[TAG_SIZE - 1] &= 0x7f;\n261\n262     /*\n263      * In the ctx, user_tag is the one received/set by the user,\n264      * and tag is generated from the input\n265      */\n266     out_len = sizeof(ctx->tag);\n267     error |= !EVP_EncryptUpdate(ctx->ecb_ctx, ctx->tag, &out_len, S_s, sizeof(S_s));\n268     ctx->generated_tag = !error;\n269     /* Regardless of error */\n270     ctx->used_dec = 1;\n271     return !error;\n272 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/providers/implementations/ciphers/cipher_aes_gcm_siv_hw.c",
                        "function_body": "334 static int aes_gcm_siv_ctr32(PROV_AES_GCM_SIV_CTX *ctx, const unsigned char *init_counter,\n335                              unsigned char *out, const unsigned char *in, size_t len)\n336 {\n337     uint8_t keystream[BLOCK_SIZE];\n338     int out_len;\n339     size_t i;\n340     size_t j;\n341     size_t todo;\n342     uint32_t counter;\n343     int error = 0;\n344     union {\n345         uint32_t x32[BLOCK_SIZE / sizeof(uint32_t)];\n346         uint8_t x8[BLOCK_SIZE];\n347     } block;\n348     DECLARE_IS_ENDIAN;\n349\n350     memcpy(&block, init_counter, sizeof(block));\n351     if (IS_BIG_ENDIAN) {\n352         counter = GSWAP4(block.x32[0]);\n353     }\n354\n355     for (i = 0; i < len; i += sizeof(block)) {\n356         out_len = BLOCK_SIZE;\n357         error |= !EVP_EncryptUpdate(ctx->ecb_ctx, keystream, &out_len, (uint8_t*)&block, sizeof(block));\n358         if (IS_LITTLE_ENDIAN) {\n359             block.x32[0]++;\n360         } else {\n361             counter++;\n362             block.x32[0] = GSWAP4(counter);\n363         }\n364         todo = len - i;\n365         if (todo > sizeof(keystream))\n366             todo = sizeof(keystream);\n367         /* Non optimal, but avoids alignment issues */\n368         for (j = 0; j < todo; j++)\n369             out[i + j] = in[i + j] ^ keystream[j];\n370     }\n371     return !error;\n372 }"
                    },
                    {
                        "file_path": "/providers/implementations/ciphers/cipher_aes_gcm_siv_hw.c",
                        "function_body": "148 static int aes_gcm_siv_encrypt(PROV_AES_GCM_SIV_CTX *ctx, const unsigned char *in,\n149                                unsigned char *out, size_t len)\n150 {\n151     uint64_t len_blk[2];\n152     uint8_t S_s[TAG_SIZE];\n153     uint8_t counter_block[TAG_SIZE];\n154     uint8_t padding[BLOCK_SIZE];\n155     size_t i;\n156     int64_t len64 = len;\n157     int out_len;\n158     int error = 0;\n159     DECLARE_IS_ENDIAN;\n160\n161     ctx->generated_tag = 0;\n162     if (!ctx->speed && ctx->used_enc)\n163         return 0;\n164     /* need to check the size of the input! */\n165     if (len64 > ((int64_t)1 << 36))\n166         return 0;\n167\n168     if (IS_LITTLE_ENDIAN) {\n169         len_blk[0] = (uint64_t)ctx->aad_len * 8;\n170         len_blk[1] = (uint64_t)len * 8;\n171     } else {\n172         len_blk[0] = GSWAP8((uint64_t)ctx->aad_len * 8);\n173         len_blk[1] = GSWAP8((uint64_t)len * 8);\n174     }\n175     memset(S_s, 0, TAG_SIZE);\n176     ossl_polyval_ghash_init(ctx->Htable, (const uint64_t*)ctx->msg_auth_key);\n177\n178     if (ctx->aad != NULL) {\n179         /* AAD is allocated with padding, but need to adjust length */\n180         ossl_polyval_ghash_hash(ctx->Htable, S_s, ctx->aad, UP16(ctx->aad_len));\n181     }\n182     if (DOWN16(len) > 0)\n183         ossl_polyval_ghash_hash(ctx->Htable, S_s, (uint8_t *) in, DOWN16(len));\n184     if (!IS16(len)) {\n185         /* deal with padding - probably easier to memset the padding first rather than calculate */\n186         memset(padding, 0, sizeof(padding));\n187         memcpy(padding, &in[DOWN16(len)], REMAINDER16(len));\n188         ossl_polyval_ghash_hash(ctx->Htable, S_s, padding, sizeof(padding));\n189     }\n190     ossl_polyval_ghash_hash(ctx->Htable, S_s, (uint8_t *) len_blk, sizeof(len_blk));\n191\n192     for (i = 0; i < NONCE_SIZE; i++)\n193         S_s[i] ^= ctx->nonce[i];\n194\n195     S_s[TAG_SIZE - 1] &= 0x7f;\n196     out_len = sizeof(ctx->tag);\n197     error |= !EVP_EncryptUpdate(ctx->ecb_ctx, ctx->tag, &out_len, S_s, sizeof(S_s));\n198     memcpy(counter_block, ctx->tag, TAG_SIZE);\n199     counter_block[TAG_SIZE - 1] |= 0x80;\n200\n201     error |= !aes_gcm_siv_ctr32(ctx, counter_block, out, in, len);\n202\n203     ctx->generated_tag = !error;\n204     /* Regardless of error */\n205     ctx->used_enc = 1;\n206     return !error;\n207 }"
                    }
                ]
            }
        ],
        "sink": "counter++;",
        "final_sink": "counter++;"
    },
    {
        "prt": "res",
        "function_call": [
            "int ossl_quic_reactor_block_until_pred(QUIC_REACTOR *rtor,\n                                       int (*pred)(void *arg), void *pred_arg,\n                                       uint32_t flags)\n{\n    int res, net_read_desired, net_write_desired, notifier_fd;\n    OSSL_TIME tick_deadline;\n\n    notifier_fd\n        = (rtor->have_notifier ? ossl_rio_notifier_as_fd(&rtor->notifier)\n                               : INVALID_SOCKET);\n\n    for (;;) {\n        if ((flags & SKIP_FIRST_TICK) != 0)\n            flags &= ~SKIP_FIRST_TICK;\n        else\n            /* best effort */\n            ossl_quic_reactor_tick(rtor, 0);\n\n        if ((res = pred(pred_arg)) != 0)\n            return res;\n\n        net_read_desired  = ossl_quic_reactor_net_read_desired(rtor);\n        net_write_desired = ossl_quic_reactor_net_write_desired(rtor);\n        tick_deadline     = ossl_quic_reactor_get_tick_deadline(rtor);\n        if (!net_read_desired && !net_write_desired\n            && ossl_time_is_infinite(tick_deadline))\n            /* Can't wait if there is nothing to wait for. */\n            return 0;\n\n        ossl_quic_reactor_enter_blocking_section(rtor);\n\n        res = poll_two_descriptors(ossl_quic_reactor_get_poll_r(rtor),\n                                   net_read_desired,\n                                   ossl_quic_reactor_get_poll_w(rtor),\n                                   net_write_desired,\n                                   notifier_fd,\n                                   tick_deadline,\n                                   rtor->mutex);\n\n        /*\n         * We have now exited the OS poller call. We may have\n         * (rtor->signalled_notifier), and other threads may still be blocking.\n         * This means that cur_blocking_waiters may still be non-zero. As such,\n         * we cannot unsignal the notifier until all threads have had an\n         * opportunity to wake up.\n         *\n         * At the same time, we cannot unsignal in the case where\n         * cur_blocking_waiters is now zero because this condition may not occur\n         * reliably. Consider the following scenario:\n         *\n         *   T1 enters block_until_pred, cur_blocking_waiters -> 1\n         *   T2 enters block_until_pred, cur_blocking_waiters -> 2\n         *   T3 enters block_until_pred, cur_blocking_waiters -> 3\n         *\n         *   T4 enters block_until_pred, does not block, ticks,\n         *     sees that cur_blocking_waiters > 0 and signals the notifier\n         *\n         *   T3 wakes, cur_blocking_waiters -> 2\n         *   T3 predicate is not satisfied, cur_blocking_waiters -> 3, block again\n         *\n         *   Notifier is still signalled, so T3 immediately wakes again\n         *   and is stuck repeating the above steps.\n         *\n         *   T1, T2 are also woken by the notifier but never see\n         *   cur_blocking_waiters drop to 0, so never unsignal the notifier.\n         *\n         * As such, a two phase approach is chosen when designalling the\n         * notifier:\n         *\n         *   First, all of the poll_two_descriptor calls on all threads are\n         *   allowed to exit due to the notifier being signalled.\n         *\n         *   Second, the thread which happened to be the one which decremented\n         *   cur_blocking_waiters to 0 unsignals the notifier and is then\n         *   responsible for broadcasting to a CV to indicate to the other\n         *   threads that the synchronised wakeup has been completed. Other\n         *   threads wait for this CV to be signalled.\n         *\n         */\n        ossl_quic_reactor_leave_blocking_section(rtor);\n\n        if (!res)\n            /*\n             * We don't actually care why the call succeeded (timeout, FD\n             * readiness), we just call reactor_tick and start trying to do I/O\n             * things again. If poll_two_fds returns 0, this is some other\n             * non-timeout failure and we should stop here.\n             *\n             * TODO(QUIC FUTURE): In the future we could avoid unnecessary\n             * syscalls by not retrying network I/O that isn't ready based\n             * on the result of the poll call. However this might be difficult\n             * because it requires we do the call to poll(2) or equivalent\n             * syscall ourselves, whereas in the general case the application\n             * does the polling and just calls SSL_handle_events().\n             * Implementing this optimisation in the future will probably\n             * therefore require API changes.\n             */\n            return 0;\n    }\n\n    return res;\n}"
        ],
        "source": [
            "    int res, net_read_desired, net_write_desired, notifier_fd;"
        ],
        "index": 56,
        "location": {
            "file_path": "ssl/quic/quic_reactor.c",
            "region": {
                "startLine": 561,
                "startColumn": 5,
                "endColumn": 8
            },
            "context": {
                "startLine": 559,
                "endLine": 563,
                "snippet": {
                    "text": "return res;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/ssl/quic/quic_reactor.c",
                        "function_body": "461 int ossl_quic_reactor_block_until_pred(QUIC_REACTOR *rtor,\n462                                        int (*pred)(void *arg), void *pred_arg,\n463                                        uint32_t flags)\n464 {\n465     int res, net_read_desired, net_write_desired, notifier_fd;\n466     OSSL_TIME tick_deadline;\n467\n468     notifier_fd\n469         = (rtor->have_notifier ? ossl_rio_notifier_as_fd(&rtor->notifier)\n470                                : INVALID_SOCKET);\n471\n472     for (;;) {\n473         if ((flags & SKIP_FIRST_TICK) != 0)\n474             flags &= ~SKIP_FIRST_TICK;\n475         else\n476             /* best effort */\n477             ossl_quic_reactor_tick(rtor, 0);\n478\n479         if ((res = pred(pred_arg)) != 0)\n480             return res;\n481\n482         net_read_desired  = ossl_quic_reactor_net_read_desired(rtor);\n483         net_write_desired = ossl_quic_reactor_net_write_desired(rtor);\n484         tick_deadline     = ossl_quic_reactor_get_tick_deadline(rtor);\n485         if (!net_read_desired && !net_write_desired\n486             && ossl_time_is_infinite(tick_deadline))\n487             /* Can't wait if there is nothing to wait for. */\n488             return 0;\n489\n490         ossl_quic_reactor_enter_blocking_section(rtor);\n491\n492         res = poll_two_descriptors(ossl_quic_reactor_get_poll_r(rtor),\n493                                    net_read_desired,\n494                                    ossl_quic_reactor_get_poll_w(rtor),\n495                                    net_write_desired,\n496                                    notifier_fd,\n497                                    tick_deadline,\n498                                    rtor->mutex);\n499\n500         /*\n501          * We have now exited the OS poller call. We may have\n502          * (rtor->signalled_notifier), and other threads may still be blocking.\n503          * This means that cur_blocking_waiters may still be non-zero. As such,\n504          * we cannot unsignal the notifier until all threads have had an\n505          * opportunity to wake up.\n506          *\n507          * At the same time, we cannot unsignal in the case where\n508          * cur_blocking_waiters is now zero because this condition may not occur\n509          * reliably. Consider the following scenario:\n510          *\n511          *   T1 enters block_until_pred, cur_blocking_waiters -> 1\n512          *   T2 enters block_until_pred, cur_blocking_waiters -> 2\n513          *   T3 enters block_until_pred, cur_blocking_waiters -> 3\n514          *\n515          *   T4 enters block_until_pred, does not block, ticks,\n516          *     sees that cur_blocking_waiters > 0 and signals the notifier\n517          *\n518          *   T3 wakes, cur_blocking_waiters -> 2\n519          *   T3 predicate is not satisfied, cur_blocking_waiters -> 3, block again\n520          *\n521          *   Notifier is still signalled, so T3 immediately wakes again\n522          *   and is stuck repeating the above steps.\n523          *\n524          *   T1, T2 are also woken by the notifier but never see\n525          *   cur_blocking_waiters drop to 0, so never unsignal the notifier.\n526          *\n527          * As such, a two phase approach is chosen when designalling the\n528          * notifier:\n529          *\n530          *   First, all of the poll_two_descriptor calls on all threads are\n531          *   allowed to exit due to the notifier being signalled.\n532          *\n533          *   Second, the thread which happened to be the one which decremented\n534          *   cur_blocking_waiters to 0 unsignals the notifier and is then\n535          *   responsible for broadcasting to a CV to indicate to the other\n536          *   threads that the synchronised wakeup has been completed. Other\n537          *   threads wait for this CV to be signalled.\n538          *\n539          */\n540         ossl_quic_reactor_leave_blocking_section(rtor);\n541\n542         if (!res)\n543             /*\n544              * We don't actually care why the call succeeded (timeout, FD\n545              * readiness), we just call reactor_tick and start trying to do I/O\n546              * things again. If poll_two_fds returns 0, this is some other\n547              * non-timeout failure and we should stop here.\n548              *\n549              * TODO(QUIC FUTURE): In the future we could avoid unnecessary\n550              * syscalls by not retrying network I/O that isn't ready based\n551              * on the result of the poll call. However this might be difficult\n552              * because it requires we do the call to poll(2) or equivalent\n553              * syscall ourselves, whereas in the general case the application\n554              * does the polling and just calls SSL_handle_events().\n555              * Implementing this optimisation in the future will probably\n556              * therefore require API changes.\n557              */\n558             return 0;\n559     }\n560\n561     return res;\n562 }"
                    },
                    {
                        "file_path": "/ssl/quic/quic_impl.c",
                        "function_body": "521 static int block_until_pred(QCTX *ctx,\n522                             int (*pred)(void *arg), void *pred_arg,\n523                             uint32_t flags)\n524 {\n525     QUIC_ENGINE *qeng;\n526     QUIC_REACTOR *rtor;\n527\n528     qeng = ossl_quic_obj_get0_engine(ctx->obj);\n529     assert(qeng != NULL);\n530\n531     /*\n532      * Any attempt to block auto-disables tick inhibition as otherwise we will\n533      * hang around forever.\n534      */\n535     ossl_quic_engine_set_inhibit_tick(qeng, 0);\n536\n537     rtor = ossl_quic_engine_get0_reactor(qeng);\n538     return ossl_quic_reactor_block_until_pred(rtor, pred, pred_arg, flags);\n539 }"
                    }
                ]
            }
        ],
        "sink": "return res;",
        "final_sink": "return res;"
    },
    {
        "prt": "buflen",
        "function_call": [
            "static int ssl_cipher_process_rulestr(const char *rule_str,\n                                      CIPHER_ORDER **head_p,\n                                      CIPHER_ORDER **tail_p,\n                                      const SSL_CIPHER **ca_list, CERT *c)\n{\n    uint32_t alg_mkey, alg_auth, alg_enc, alg_mac, algo_strength;\n    int min_tls;\n    const char *l, *buf;\n    int j, multi, found, rule, retval, ok, buflen;\n    uint32_t cipher_id = 0;\n    char ch;\n\n    retval = 1;\n    l = rule_str;\n    for (;;) {\n        ch = *l;\n\n        if (ch == '\\0')\n            break;              /* done */\n        if (ch == '-') {\n            rule = CIPHER_DEL;\n            l++;\n        } else if (ch == '+') {\n            rule = CIPHER_ORD;\n            l++;\n        } else if (ch == '!') {\n            rule = CIPHER_KILL;\n            l++;\n        } else if (ch == '@') {\n            rule = CIPHER_SPECIAL;\n            l++;\n        } else {\n            rule = CIPHER_ADD;\n        }\n\n        if (ITEM_SEP(ch)) {\n            l++;\n            continue;\n        }\n\n        alg_mkey = 0;\n        alg_auth = 0;\n        alg_enc = 0;\n        alg_mac = 0;\n        min_tls = 0;\n        algo_strength = 0;\n\n        for (;;) {\n            ch = *l;\n            buf = l;\n            buflen = 0;\n#ifndef CHARSET_EBCDIC\n            while (((ch >= 'A') && (ch <= 'Z')) ||\n                   ((ch >= '0') && (ch <= '9')) ||\n                   ((ch >= 'a') && (ch <= 'z')) ||\n                   (ch == '-') || (ch == '_') || (ch == '.') || (ch == '='))\n#else\n            while (isalnum((unsigned char)ch) || (ch == '-') || (ch == '_') || (ch == '.')\n                   || (ch == '='))\n#endif\n            {\n                ch = *(++l);\n                buflen++;\n            }\n\n            if (buflen == 0) {\n                /*\n                 * We hit something we cannot deal with,\n                 * it is no command or separator nor\n                 * alphanumeric, so we call this an error.\n                 */\n                ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n                return 0;\n            }\n\n            if (rule == CIPHER_SPECIAL) {\n                found = 0;      /* unused -- avoid compiler warning */\n                break;          /* special treatment */\n            }\n\n            /* check for multi-part specification */\n            if (ch == '+') {\n                multi = 1;\n                l++;\n            } else {\n                multi = 0;\n            }\n\n            /*\n             * Now search for the cipher alias in the ca_list. Be careful\n             * with the strncmp, because the \"buflen\" limitation\n             * will make the rule \"ADH:SOME\" and the cipher\n             * \"ADH-MY-CIPHER\" look like a match for buflen=3.\n             * So additionally check whether the cipher name found\n             * has the correct length. We can save a strlen() call:\n             * just checking for the '\\0' at the right place is\n             * sufficient, we have to strncmp() anyway. (We cannot\n             * use strcmp(), because buf is not '\\0' terminated.)\n             */\n            j = found = 0;\n            cipher_id = 0;\n            while (ca_list[j]) {\n                if (strncmp(buf, ca_list[j]->name, buflen) == 0\n                    && (ca_list[j]->name[buflen] == '\\0')) {\n                    found = 1;\n                    break;\n                } else if (ca_list[j]->stdname != NULL\n                           && strncmp(buf, ca_list[j]->stdname, buflen) == 0\n                           && ca_list[j]->stdname[buflen] == '\\0') {\n                    found = 1;\n                    break;\n                } else\n                    j++;\n            }\n\n            if (!found)\n                break;          /* ignore this entry */\n\n            if (ca_list[j]->algorithm_mkey) {\n                if (alg_mkey) {\n                    alg_mkey &= ca_list[j]->algorithm_mkey;\n                    if (!alg_mkey) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_mkey = ca_list[j]->algorithm_mkey;\n                }\n            }\n\n            if (ca_list[j]->algorithm_auth) {\n                if (alg_auth) {\n                    alg_auth &= ca_list[j]->algorithm_auth;\n                    if (!alg_auth) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_auth = ca_list[j]->algorithm_auth;\n                }\n            }\n\n            if (ca_list[j]->algorithm_enc) {\n                if (alg_enc) {\n                    alg_enc &= ca_list[j]->algorithm_enc;\n                    if (!alg_enc) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_enc = ca_list[j]->algorithm_enc;\n                }\n            }\n\n            if (ca_list[j]->algorithm_mac) {\n                if (alg_mac) {\n                    alg_mac &= ca_list[j]->algorithm_mac;\n                    if (!alg_mac) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_mac = ca_list[j]->algorithm_mac;\n                }\n            }\n\n            if (ca_list[j]->algo_strength & SSL_STRONG_MASK) {\n                if (algo_strength & SSL_STRONG_MASK) {\n                    algo_strength &=\n                        (ca_list[j]->algo_strength & SSL_STRONG_MASK) |\n                        ~SSL_STRONG_MASK;\n                    if (!(algo_strength & SSL_STRONG_MASK)) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    algo_strength = ca_list[j]->algo_strength & SSL_STRONG_MASK;\n                }\n            }\n\n            if (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) {\n                if (algo_strength & SSL_DEFAULT_MASK) {\n                    algo_strength &=\n                        (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) |\n                        ~SSL_DEFAULT_MASK;\n                    if (!(algo_strength & SSL_DEFAULT_MASK)) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    algo_strength |=\n                        ca_list[j]->algo_strength & SSL_DEFAULT_MASK;\n                }\n            }\n\n            if (ca_list[j]->valid) {\n                /*\n                 * explicit ciphersuite found; its protocol version does not\n                 * become part of the search pattern!\n                 */\n\n                cipher_id = ca_list[j]->id;\n            } else {\n                /*\n                 * not an explicit ciphersuite; only in this case, the\n                 * protocol version is considered part of the search pattern\n                 */\n\n                if (ca_list[j]->min_tls) {\n                    if (min_tls != 0 && min_tls != ca_list[j]->min_tls) {\n                        found = 0;\n                        break;\n                    } else {\n                        min_tls = ca_list[j]->min_tls;\n                    }\n                }\n            }\n\n            if (!multi)\n                break;\n        }\n\n        /*\n         * Ok, we have the rule, now apply it\n         */\n        if (rule == CIPHER_SPECIAL) { /* special command */\n            ok = 0;\n            if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {\n                ok = ssl_cipher_strength_sort(head_p, tail_p);\n            } else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {\n                int level = *buf - '0';\n                if (level < 0 || level > 5) {\n                    ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n                } else {\n                    c->sec_level = level;\n                    ok = 1;\n                }\n            } else {\n                ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n            }\n            if (ok == 0)\n                retval = 0;\n            /*\n             * We do not support any \"multi\" options\n             * together with \"@\", so throw away the\n             * rest of the command, if any left, until\n             * end or ':' is found.\n             */\n            while ((*l != '\\0') && !ITEM_SEP(*l))\n                l++;\n        } else if (found) {\n            ssl_cipher_apply_rule(cipher_id,\n                                  alg_mkey, alg_auth, alg_enc, alg_mac,\n                                  min_tls, algo_strength, rule, -1, head_p,\n                                  tail_p);\n        } else {\n            while ((*l != '\\0') && !ITEM_SEP(*l))\n                l++;\n        }\n        if (*l == '\\0')\n            break;              /* done */\n    }\n\n    return retval;\n}"
        ],
        "source": [
            "    int j, multi, found, rule, retval, ok, buflen;"
        ],
        "index": 57,
        "location": {
            "file_path": "ssl/ssl_ciph.c",
            "region": {
                "startLine": 1192,
                "startColumn": 18,
                "endColumn": 24
            },
            "context": {
                "startLine": 1190,
                "endLine": 1194,
                "snippet": {
                    "text": "if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/include/internal/common.h",
                        "function_body": "58 #define HAS_PREFIX(str, pre) (strncmp(str, pre \"\", sizeof(pre) - 1) == 0)"
                    },
                    {
                        "file_path": "/ssl/ssl_ciph.c",
                        "function_body": "965  static int ssl_cipher_process_rulestr(const char *rule_str,\n966                                        CIPHER_ORDER **head_p,\n967                                        CIPHER_ORDER **tail_p,\n968                                        const SSL_CIPHER **ca_list, CERT *c)\n969  {\n970      uint32_t alg_mkey, alg_auth, alg_enc, alg_mac, algo_strength;\n971      int min_tls;\n972      const char *l, *buf;\n973      int j, multi, found, rule, retval, ok, buflen;\n974      uint32_t cipher_id = 0;\n975      char ch;\n976\n977      retval = 1;\n978      l = rule_str;\n979      for (;;) {\n980          ch = *l;\n981\n982          if (ch == '\\0')\n983              break;              /* done */\n984          if (ch == '-') {\n985              rule = CIPHER_DEL;\n986              l++;\n987          } else if (ch == '+') {\n988              rule = CIPHER_ORD;\n989              l++;\n990          } else if (ch == '!') {\n991              rule = CIPHER_KILL;\n992              l++;\n993          } else if (ch == '@') {\n994              rule = CIPHER_SPECIAL;\n995              l++;\n996          } else {\n997              rule = CIPHER_ADD;\n998          }\n999\n1000         if (ITEM_SEP(ch)) {\n1001             l++;\n1002             continue;\n1003         }\n1004\n1005         alg_mkey = 0;\n1006         alg_auth = 0;\n1007         alg_enc = 0;\n1008         alg_mac = 0;\n1009         min_tls = 0;\n1010         algo_strength = 0;\n1011\n1012         for (;;) {\n1013             ch = *l;\n1014             buf = l;\n1015             buflen = 0;\n1016 #ifndef CHARSET_EBCDIC\n1017             while (((ch >= 'A') && (ch <= 'Z')) ||\n1018                    ((ch >= '0') && (ch <= '9')) ||\n1019                    ((ch >= 'a') && (ch <= 'z')) ||\n1020                    (ch == '-') || (ch == '_') || (ch == '.') || (ch == '='))\n1021 #else\n1022             while (isalnum((unsigned char)ch) || (ch == '-') || (ch == '_') || (ch == '.')\n1023                    || (ch == '='))\n1024 #endif\n1025             {\n1026                 ch = *(++l);\n1027                 buflen++;\n1028             }\n1029\n1030             if (buflen == 0) {\n1031                 /*\n1032                  * We hit something we cannot deal with,\n1033                  * it is no command or separator nor\n1034                  * alphanumeric, so we call this an error.\n1035                  */\n1036                 ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1037                 return 0;\n1038             }\n1039\n1040             if (rule == CIPHER_SPECIAL) {\n1041                 found = 0;      /* unused -- avoid compiler warning */\n1042                 break;          /* special treatment */\n1043             }\n1044\n1045             /* check for multi-part specification */\n1046             if (ch == '+') {\n1047                 multi = 1;\n1048                 l++;\n1049             } else {\n1050                 multi = 0;\n1051             }\n1052\n1053             /*\n1054              * Now search for the cipher alias in the ca_list. Be careful\n1055              * with the strncmp, because the \"buflen\" limitation\n1056              * will make the rule \"ADH:SOME\" and the cipher\n1057              * \"ADH-MY-CIPHER\" look like a match for buflen=3.\n1058              * So additionally check whether the cipher name found\n1059              * has the correct length. We can save a strlen() call:\n1060              * just checking for the '\\0' at the right place is\n1061              * sufficient, we have to strncmp() anyway. (We cannot\n1062              * use strcmp(), because buf is not '\\0' terminated.)\n1063              */\n1064             j = found = 0;\n1065             cipher_id = 0;\n1066             while (ca_list[j]) {\n1067                 if (strncmp(buf, ca_list[j]->name, buflen) == 0\n1068                     && (ca_list[j]->name[buflen] == '\\0')) {\n1069                     found = 1;\n1070                     break;\n1071                 } else if (ca_list[j]->stdname != NULL\n1072                            && strncmp(buf, ca_list[j]->stdname, buflen) == 0\n1073                            && ca_list[j]->stdname[buflen] == '\\0') {\n1074                     found = 1;\n1075                     break;\n1076                 } else\n1077                     j++;\n1078             }\n1079\n1080             if (!found)\n1081                 break;          /* ignore this entry */\n1082\n1083             if (ca_list[j]->algorithm_mkey) {\n1084                 if (alg_mkey) {\n1085                     alg_mkey &= ca_list[j]->algorithm_mkey;\n1086                     if (!alg_mkey) {\n1087                         found = 0;\n1088                         break;\n1089                     }\n1090                 } else {\n1091                     alg_mkey = ca_list[j]->algorithm_mkey;\n1092                 }\n1093             }\n1094\n1095             if (ca_list[j]->algorithm_auth) {\n1096                 if (alg_auth) {\n1097                     alg_auth &= ca_list[j]->algorithm_auth;\n1098                     if (!alg_auth) {\n1099                         found = 0;\n1100                         break;\n1101                     }\n1102                 } else {\n1103                     alg_auth = ca_list[j]->algorithm_auth;\n1104                 }\n1105             }\n1106\n1107             if (ca_list[j]->algorithm_enc) {\n1108                 if (alg_enc) {\n1109                     alg_enc &= ca_list[j]->algorithm_enc;\n1110                     if (!alg_enc) {\n1111                         found = 0;\n1112                         break;\n1113                     }\n1114                 } else {\n1115                     alg_enc = ca_list[j]->algorithm_enc;\n1116                 }\n1117             }\n1118\n1119             if (ca_list[j]->algorithm_mac) {\n1120                 if (alg_mac) {\n1121                     alg_mac &= ca_list[j]->algorithm_mac;\n1122                     if (!alg_mac) {\n1123                         found = 0;\n1124                         break;\n1125                     }\n1126                 } else {\n1127                     alg_mac = ca_list[j]->algorithm_mac;\n1128                 }\n1129             }\n1130\n1131             if (ca_list[j]->algo_strength & SSL_STRONG_MASK) {\n1132                 if (algo_strength & SSL_STRONG_MASK) {\n1133                     algo_strength &=\n1134                         (ca_list[j]->algo_strength & SSL_STRONG_MASK) |\n1135                         ~SSL_STRONG_MASK;\n1136                     if (!(algo_strength & SSL_STRONG_MASK)) {\n1137                         found = 0;\n1138                         break;\n1139                     }\n1140                 } else {\n1141                     algo_strength = ca_list[j]->algo_strength & SSL_STRONG_MASK;\n1142                 }\n1143             }\n1144\n1145             if (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) {\n1146                 if (algo_strength & SSL_DEFAULT_MASK) {\n1147                     algo_strength &=\n1148                         (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) |\n1149                         ~SSL_DEFAULT_MASK;\n1150                     if (!(algo_strength & SSL_DEFAULT_MASK)) {\n1151                         found = 0;\n1152                         break;\n1153                     }\n1154                 } else {\n1155                     algo_strength |=\n1156                         ca_list[j]->algo_strength & SSL_DEFAULT_MASK;\n1157                 }\n1158             }\n1159\n1160             if (ca_list[j]->valid) {\n1161                 /*\n1162                  * explicit ciphersuite found; its protocol version does not\n1163                  * become part of the search pattern!\n1164                  */\n1165\n1166                 cipher_id = ca_list[j]->id;\n1167             } else {\n1168                 /*\n1169                  * not an explicit ciphersuite; only in this case, the\n1170                  * protocol version is considered part of the search pattern\n1171                  */\n1172\n1173                 if (ca_list[j]->min_tls) {\n1174                     if (min_tls != 0 && min_tls != ca_list[j]->min_tls) {\n1175                         found = 0;\n1176                         break;\n1177                     } else {\n1178                         min_tls = ca_list[j]->min_tls;\n1179                     }\n1180                 }\n1181             }\n1182\n1183             if (!multi)\n1184                 break;\n1185         }\n1186\n1187         /*\n1188          * Ok, we have the rule, now apply it\n1189          */\n1190         if (rule == CIPHER_SPECIAL) { /* special command */\n1191             ok = 0;\n1192             if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {\n1193                 ok = ssl_cipher_strength_sort(head_p, tail_p);\n1194             } else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {\n1195                 int level = *buf - '0';\n1196                 if (level < 0 || level > 5) {\n1197                     ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1198                 } else {\n1199                     c->sec_level = level;\n1200                     ok = 1;\n1201                 }\n1202             } else {\n1203                 ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1204             }\n1205             if (ok == 0)\n1206                 retval = 0;\n1207             /*\n1208              * We do not support any \"multi\" options\n1209              * together with \"@\", so throw away the\n1210              * rest of the command, if any left, until\n1211              * end or ':' is found.\n1212              */\n1213             while ((*l != '\\0') && !ITEM_SEP(*l))\n1214                 l++;\n1215         } else if (found) {\n1216             ssl_cipher_apply_rule(cipher_id,\n1217                                   alg_mkey, alg_auth, alg_enc, alg_mac,\n1218                                   min_tls, algo_strength, rule, -1, head_p,\n1219                                   tail_p);\n1220         } else {\n1221             while ((*l != '\\0') && !ITEM_SEP(*l))\n1222                 l++;\n1223         }\n1224         if (*l == '\\0')\n1225             break;              /* done */\n1226     }\n1227\n1228     return retval;\n1229 }"
                    }
                ]
            }
        ],
        "sink": "if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {",
        "final_sink": "if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {"
    },
    {
        "prt": "buflen",
        "function_call": [
            "static int ssl_cipher_process_rulestr(const char *rule_str,\n                                      CIPHER_ORDER **head_p,\n                                      CIPHER_ORDER **tail_p,\n                                      const SSL_CIPHER **ca_list, CERT *c)\n{\n    uint32_t alg_mkey, alg_auth, alg_enc, alg_mac, algo_strength;\n    int min_tls;\n    const char *l, *buf;\n    int j, multi, found, rule, retval, ok, buflen;\n    uint32_t cipher_id = 0;\n    char ch;\n\n    retval = 1;\n    l = rule_str;\n    for (;;) {\n        ch = *l;\n\n        if (ch == '\\0')\n            break;              /* done */\n        if (ch == '-') {\n            rule = CIPHER_DEL;\n            l++;\n        } else if (ch == '+') {\n            rule = CIPHER_ORD;\n            l++;\n        } else if (ch == '!') {\n            rule = CIPHER_KILL;\n            l++;\n        } else if (ch == '@') {\n            rule = CIPHER_SPECIAL;\n            l++;\n        } else {\n            rule = CIPHER_ADD;\n        }\n\n        if (ITEM_SEP(ch)) {\n            l++;\n            continue;\n        }\n\n        alg_mkey = 0;\n        alg_auth = 0;\n        alg_enc = 0;\n        alg_mac = 0;\n        min_tls = 0;\n        algo_strength = 0;\n\n        for (;;) {\n            ch = *l;\n            buf = l;\n            buflen = 0;\n#ifndef CHARSET_EBCDIC\n            while (((ch >= 'A') && (ch <= 'Z')) ||\n                   ((ch >= '0') && (ch <= '9')) ||\n                   ((ch >= 'a') && (ch <= 'z')) ||\n                   (ch == '-') || (ch == '_') || (ch == '.') || (ch == '='))\n#else\n            while (isalnum((unsigned char)ch) || (ch == '-') || (ch == '_') || (ch == '.')\n                   || (ch == '='))\n#endif\n            {\n                ch = *(++l);\n                buflen++;\n            }\n\n            if (buflen == 0) {\n                /*\n                 * We hit something we cannot deal with,\n                 * it is no command or separator nor\n                 * alphanumeric, so we call this an error.\n                 */\n                ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n                return 0;\n            }\n\n            if (rule == CIPHER_SPECIAL) {\n                found = 0;      /* unused -- avoid compiler warning */\n                break;          /* special treatment */\n            }\n\n            /* check for multi-part specification */\n            if (ch == '+') {\n                multi = 1;\n                l++;\n            } else {\n                multi = 0;\n            }\n\n            /*\n             * Now search for the cipher alias in the ca_list. Be careful\n             * with the strncmp, because the \"buflen\" limitation\n             * will make the rule \"ADH:SOME\" and the cipher\n             * \"ADH-MY-CIPHER\" look like a match for buflen=3.\n             * So additionally check whether the cipher name found\n             * has the correct length. We can save a strlen() call:\n             * just checking for the '\\0' at the right place is\n             * sufficient, we have to strncmp() anyway. (We cannot\n             * use strcmp(), because buf is not '\\0' terminated.)\n             */\n            j = found = 0;\n            cipher_id = 0;\n            while (ca_list[j]) {\n                if (strncmp(buf, ca_list[j]->name, buflen) == 0\n                    && (ca_list[j]->name[buflen] == '\\0')) {\n                    found = 1;\n                    break;\n                } else if (ca_list[j]->stdname != NULL\n                           && strncmp(buf, ca_list[j]->stdname, buflen) == 0\n                           && ca_list[j]->stdname[buflen] == '\\0') {\n                    found = 1;\n                    break;\n                } else\n                    j++;\n            }\n\n            if (!found)\n                break;          /* ignore this entry */\n\n            if (ca_list[j]->algorithm_mkey) {\n                if (alg_mkey) {\n                    alg_mkey &= ca_list[j]->algorithm_mkey;\n                    if (!alg_mkey) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_mkey = ca_list[j]->algorithm_mkey;\n                }\n            }\n\n            if (ca_list[j]->algorithm_auth) {\n                if (alg_auth) {\n                    alg_auth &= ca_list[j]->algorithm_auth;\n                    if (!alg_auth) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_auth = ca_list[j]->algorithm_auth;\n                }\n            }\n\n            if (ca_list[j]->algorithm_enc) {\n                if (alg_enc) {\n                    alg_enc &= ca_list[j]->algorithm_enc;\n                    if (!alg_enc) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_enc = ca_list[j]->algorithm_enc;\n                }\n            }\n\n            if (ca_list[j]->algorithm_mac) {\n                if (alg_mac) {\n                    alg_mac &= ca_list[j]->algorithm_mac;\n                    if (!alg_mac) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_mac = ca_list[j]->algorithm_mac;\n                }\n            }\n\n            if (ca_list[j]->algo_strength & SSL_STRONG_MASK) {\n                if (algo_strength & SSL_STRONG_MASK) {\n                    algo_strength &=\n                        (ca_list[j]->algo_strength & SSL_STRONG_MASK) |\n                        ~SSL_STRONG_MASK;\n                    if (!(algo_strength & SSL_STRONG_MASK)) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    algo_strength = ca_list[j]->algo_strength & SSL_STRONG_MASK;\n                }\n            }\n\n            if (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) {\n                if (algo_strength & SSL_DEFAULT_MASK) {\n                    algo_strength &=\n                        (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) |\n                        ~SSL_DEFAULT_MASK;\n                    if (!(algo_strength & SSL_DEFAULT_MASK)) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    algo_strength |=\n                        ca_list[j]->algo_strength & SSL_DEFAULT_MASK;\n                }\n            }\n\n            if (ca_list[j]->valid) {\n                /*\n                 * explicit ciphersuite found; its protocol version does not\n                 * become part of the search pattern!\n                 */\n\n                cipher_id = ca_list[j]->id;\n            } else {\n                /*\n                 * not an explicit ciphersuite; only in this case, the\n                 * protocol version is considered part of the search pattern\n                 */\n\n                if (ca_list[j]->min_tls) {\n                    if (min_tls != 0 && min_tls != ca_list[j]->min_tls) {\n                        found = 0;\n                        break;\n                    } else {\n                        min_tls = ca_list[j]->min_tls;\n                    }\n                }\n            }\n\n            if (!multi)\n                break;\n        }\n\n        /*\n         * Ok, we have the rule, now apply it\n         */\n        if (rule == CIPHER_SPECIAL) { /* special command */\n            ok = 0;\n            if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {\n                ok = ssl_cipher_strength_sort(head_p, tail_p);\n            } else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {\n                int level = *buf - '0';\n                if (level < 0 || level > 5) {\n                    ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n                } else {\n                    c->sec_level = level;\n                    ok = 1;\n                }\n            } else {\n                ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n            }\n            if (ok == 0)\n                retval = 0;\n            /*\n             * We do not support any \"multi\" options\n             * together with \"@\", so throw away the\n             * rest of the command, if any left, until\n             * end or ':' is found.\n             */\n            while ((*l != '\\0') && !ITEM_SEP(*l))\n                l++;\n        } else if (found) {\n            ssl_cipher_apply_rule(cipher_id,\n                                  alg_mkey, alg_auth, alg_enc, alg_mac,\n                                  min_tls, algo_strength, rule, -1, head_p,\n                                  tail_p);\n        } else {\n            while ((*l != '\\0') && !ITEM_SEP(*l))\n                l++;\n        }\n        if (*l == '\\0')\n            break;              /* done */\n    }\n\n    return retval;\n}"
        ],
        "source": [
            "    int j, multi, found, rule, retval, ok, buflen;"
        ],
        "index": 58,
        "location": {
            "file_path": "ssl/ssl_ciph.c",
            "region": {
                "startLine": 1194,
                "startColumn": 24,
                "endColumn": 30
            },
            "context": {
                "startLine": 1192,
                "endLine": 1196,
                "snippet": {
                    "text": "} else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/include/internal/common.h",
                        "function_body": "60 #define CHECK_AND_SKIP_PREFIX(str, pre) \\\n61     (HAS_PREFIX(str, pre) ? ((str) += sizeof(pre) - 1, 1) : 0)"
                    },
                    {
                        "file_path": "/ssl/ssl_ciph.c",
                        "function_body": "965  static int ssl_cipher_process_rulestr(const char *rule_str,\n966                                        CIPHER_ORDER **head_p,\n967                                        CIPHER_ORDER **tail_p,\n968                                        const SSL_CIPHER **ca_list, CERT *c)\n969  {\n970      uint32_t alg_mkey, alg_auth, alg_enc, alg_mac, algo_strength;\n971      int min_tls;\n972      const char *l, *buf;\n973      int j, multi, found, rule, retval, ok, buflen;\n974      uint32_t cipher_id = 0;\n975      char ch;\n976\n977      retval = 1;\n978      l = rule_str;\n979      for (;;) {\n980          ch = *l;\n981\n982          if (ch == '\\0')\n983              break;              /* done */\n984          if (ch == '-') {\n985              rule = CIPHER_DEL;\n986              l++;\n987          } else if (ch == '+') {\n988              rule = CIPHER_ORD;\n989              l++;\n990          } else if (ch == '!') {\n991              rule = CIPHER_KILL;\n992              l++;\n993          } else if (ch == '@') {\n994              rule = CIPHER_SPECIAL;\n995              l++;\n996          } else {\n997              rule = CIPHER_ADD;\n998          }\n999\n1000         if (ITEM_SEP(ch)) {\n1001             l++;\n1002             continue;\n1003         }\n1004\n1005         alg_mkey = 0;\n1006         alg_auth = 0;\n1007         alg_enc = 0;\n1008         alg_mac = 0;\n1009         min_tls = 0;\n1010         algo_strength = 0;\n1011\n1012         for (;;) {\n1013             ch = *l;\n1014             buf = l;\n1015             buflen = 0;\n1016 #ifndef CHARSET_EBCDIC\n1017             while (((ch >= 'A') && (ch <= 'Z')) ||\n1018                    ((ch >= '0') && (ch <= '9')) ||\n1019                    ((ch >= 'a') && (ch <= 'z')) ||\n1020                    (ch == '-') || (ch == '_') || (ch == '.') || (ch == '='))\n1021 #else\n1022             while (isalnum((unsigned char)ch) || (ch == '-') || (ch == '_') || (ch == '.')\n1023                    || (ch == '='))\n1024 #endif\n1025             {\n1026                 ch = *(++l);\n1027                 buflen++;\n1028             }\n1029\n1030             if (buflen == 0) {\n1031                 /*\n1032                  * We hit something we cannot deal with,\n1033                  * it is no command or separator nor\n1034                  * alphanumeric, so we call this an error.\n1035                  */\n1036                 ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1037                 return 0;\n1038             }\n1039\n1040             if (rule == CIPHER_SPECIAL) {\n1041                 found = 0;      /* unused -- avoid compiler warning */\n1042                 break;          /* special treatment */\n1043             }\n1044\n1045             /* check for multi-part specification */\n1046             if (ch == '+') {\n1047                 multi = 1;\n1048                 l++;\n1049             } else {\n1050                 multi = 0;\n1051             }\n1052\n1053             /*\n1054              * Now search for the cipher alias in the ca_list. Be careful\n1055              * with the strncmp, because the \"buflen\" limitation\n1056              * will make the rule \"ADH:SOME\" and the cipher\n1057              * \"ADH-MY-CIPHER\" look like a match for buflen=3.\n1058              * So additionally check whether the cipher name found\n1059              * has the correct length. We can save a strlen() call:\n1060              * just checking for the '\\0' at the right place is\n1061              * sufficient, we have to strncmp() anyway. (We cannot\n1062              * use strcmp(), because buf is not '\\0' terminated.)\n1063              */\n1064             j = found = 0;\n1065             cipher_id = 0;\n1066             while (ca_list[j]) {\n1067                 if (strncmp(buf, ca_list[j]->name, buflen) == 0\n1068                     && (ca_list[j]->name[buflen] == '\\0')) {\n1069                     found = 1;\n1070                     break;\n1071                 } else if (ca_list[j]->stdname != NULL\n1072                            && strncmp(buf, ca_list[j]->stdname, buflen) == 0\n1073                            && ca_list[j]->stdname[buflen] == '\\0') {\n1074                     found = 1;\n1075                     break;\n1076                 } else\n1077                     j++;\n1078             }\n1079\n1080             if (!found)\n1081                 break;          /* ignore this entry */\n1082\n1083             if (ca_list[j]->algorithm_mkey) {\n1084                 if (alg_mkey) {\n1085                     alg_mkey &= ca_list[j]->algorithm_mkey;\n1086                     if (!alg_mkey) {\n1087                         found = 0;\n1088                         break;\n1089                     }\n1090                 } else {\n1091                     alg_mkey = ca_list[j]->algorithm_mkey;\n1092                 }\n1093             }\n1094\n1095             if (ca_list[j]->algorithm_auth) {\n1096                 if (alg_auth) {\n1097                     alg_auth &= ca_list[j]->algorithm_auth;\n1098                     if (!alg_auth) {\n1099                         found = 0;\n1100                         break;\n1101                     }\n1102                 } else {\n1103                     alg_auth = ca_list[j]->algorithm_auth;\n1104                 }\n1105             }\n1106\n1107             if (ca_list[j]->algorithm_enc) {\n1108                 if (alg_enc) {\n1109                     alg_enc &= ca_list[j]->algorithm_enc;\n1110                     if (!alg_enc) {\n1111                         found = 0;\n1112                         break;\n1113                     }\n1114                 } else {\n1115                     alg_enc = ca_list[j]->algorithm_enc;\n1116                 }\n1117             }\n1118\n1119             if (ca_list[j]->algorithm_mac) {\n1120                 if (alg_mac) {\n1121                     alg_mac &= ca_list[j]->algorithm_mac;\n1122                     if (!alg_mac) {\n1123                         found = 0;\n1124                         break;\n1125                     }\n1126                 } else {\n1127                     alg_mac = ca_list[j]->algorithm_mac;\n1128                 }\n1129             }\n1130\n1131             if (ca_list[j]->algo_strength & SSL_STRONG_MASK) {\n1132                 if (algo_strength & SSL_STRONG_MASK) {\n1133                     algo_strength &=\n1134                         (ca_list[j]->algo_strength & SSL_STRONG_MASK) |\n1135                         ~SSL_STRONG_MASK;\n1136                     if (!(algo_strength & SSL_STRONG_MASK)) {\n1137                         found = 0;\n1138                         break;\n1139                     }\n1140                 } else {\n1141                     algo_strength = ca_list[j]->algo_strength & SSL_STRONG_MASK;\n1142                 }\n1143             }\n1144\n1145             if (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) {\n1146                 if (algo_strength & SSL_DEFAULT_MASK) {\n1147                     algo_strength &=\n1148                         (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) |\n1149                         ~SSL_DEFAULT_MASK;\n1150                     if (!(algo_strength & SSL_DEFAULT_MASK)) {\n1151                         found = 0;\n1152                         break;\n1153                     }\n1154                 } else {\n1155                     algo_strength |=\n1156                         ca_list[j]->algo_strength & SSL_DEFAULT_MASK;\n1157                 }\n1158             }\n1159\n1160             if (ca_list[j]->valid) {\n1161                 /*\n1162                  * explicit ciphersuite found; its protocol version does not\n1163                  * become part of the search pattern!\n1164                  */\n1165\n1166                 cipher_id = ca_list[j]->id;\n1167             } else {\n1168                 /*\n1169                  * not an explicit ciphersuite; only in this case, the\n1170                  * protocol version is considered part of the search pattern\n1171                  */\n1172\n1173                 if (ca_list[j]->min_tls) {\n1174                     if (min_tls != 0 && min_tls != ca_list[j]->min_tls) {\n1175                         found = 0;\n1176                         break;\n1177                     } else {\n1178                         min_tls = ca_list[j]->min_tls;\n1179                     }\n1180                 }\n1181             }\n1182\n1183             if (!multi)\n1184                 break;\n1185         }\n1186\n1187         /*\n1188          * Ok, we have the rule, now apply it\n1189          */\n1190         if (rule == CIPHER_SPECIAL) { /* special command */\n1191             ok = 0;\n1192             if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {\n1193                 ok = ssl_cipher_strength_sort(head_p, tail_p);\n1194             } else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {\n1195                 int level = *buf - '0';\n1196                 if (level < 0 || level > 5) {\n1197                     ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1198                 } else {\n1199                     c->sec_level = level;\n1200                     ok = 1;\n1201                 }\n1202             } else {\n1203                 ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1204             }\n1205             if (ok == 0)\n1206                 retval = 0;\n1207             /*\n1208              * We do not support any \"multi\" options\n1209              * together with \"@\", so throw away the\n1210              * rest of the command, if any left, until\n1211              * end or ':' is found.\n1212              */\n1213             while ((*l != '\\0') && !ITEM_SEP(*l))\n1214                 l++;\n1215         } else if (found) {\n1216             ssl_cipher_apply_rule(cipher_id,\n1217                                   alg_mkey, alg_auth, alg_enc, alg_mac,\n1218                                   min_tls, algo_strength, rule, -1, head_p,\n1219                                   tail_p);\n1220         } else {\n1221             while ((*l != '\\0') && !ITEM_SEP(*l))\n1222                 l++;\n1223         }\n1224         if (*l == '\\0')\n1225             break;              /* done */\n1226     }\n1227\n1228     return retval;\n1229 }"
                    }
                ]
            }
        ],
        "sink": "} else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {",
        "final_sink": "} else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {"
    },
    {
        "prt": "found",
        "function_call": [
            "static int ssl_cipher_process_rulestr(const char *rule_str,\n                                      CIPHER_ORDER **head_p,\n                                      CIPHER_ORDER **tail_p,\n                                      const SSL_CIPHER **ca_list, CERT *c)\n{\n    uint32_t alg_mkey, alg_auth, alg_enc, alg_mac, algo_strength;\n    int min_tls;\n    const char *l, *buf;\n    int j, multi, found, rule, retval, ok, buflen;\n    uint32_t cipher_id = 0;\n    char ch;\n\n    retval = 1;\n    l = rule_str;\n    for (;;) {\n        ch = *l;\n\n        if (ch == '\\0')\n            break;              /* done */\n        if (ch == '-') {\n            rule = CIPHER_DEL;\n            l++;\n        } else if (ch == '+') {\n            rule = CIPHER_ORD;\n            l++;\n        } else if (ch == '!') {\n            rule = CIPHER_KILL;\n            l++;\n        } else if (ch == '@') {\n            rule = CIPHER_SPECIAL;\n            l++;\n        } else {\n            rule = CIPHER_ADD;\n        }\n\n        if (ITEM_SEP(ch)) {\n            l++;\n            continue;\n        }\n\n        alg_mkey = 0;\n        alg_auth = 0;\n        alg_enc = 0;\n        alg_mac = 0;\n        min_tls = 0;\n        algo_strength = 0;\n\n        for (;;) {\n            ch = *l;\n            buf = l;\n            buflen = 0;\n#ifndef CHARSET_EBCDIC\n            while (((ch >= 'A') && (ch <= 'Z')) ||\n                   ((ch >= '0') && (ch <= '9')) ||\n                   ((ch >= 'a') && (ch <= 'z')) ||\n                   (ch == '-') || (ch == '_') || (ch == '.') || (ch == '='))\n#else\n            while (isalnum((unsigned char)ch) || (ch == '-') || (ch == '_') || (ch == '.')\n                   || (ch == '='))\n#endif\n            {\n                ch = *(++l);\n                buflen++;\n            }\n\n            if (buflen == 0) {\n                /*\n                 * We hit something we cannot deal with,\n                 * it is no command or separator nor\n                 * alphanumeric, so we call this an error.\n                 */\n                ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n                return 0;\n            }\n\n            if (rule == CIPHER_SPECIAL) {\n                found = 0;      /* unused -- avoid compiler warning */\n                break;          /* special treatment */\n            }\n\n            /* check for multi-part specification */\n            if (ch == '+') {\n                multi = 1;\n                l++;\n            } else {\n                multi = 0;\n            }\n\n            /*\n             * Now search for the cipher alias in the ca_list. Be careful\n             * with the strncmp, because the \"buflen\" limitation\n             * will make the rule \"ADH:SOME\" and the cipher\n             * \"ADH-MY-CIPHER\" look like a match for buflen=3.\n             * So additionally check whether the cipher name found\n             * has the correct length. We can save a strlen() call:\n             * just checking for the '\\0' at the right place is\n             * sufficient, we have to strncmp() anyway. (We cannot\n             * use strcmp(), because buf is not '\\0' terminated.)\n             */\n            j = found = 0;\n            cipher_id = 0;\n            while (ca_list[j]) {\n                if (strncmp(buf, ca_list[j]->name, buflen) == 0\n                    && (ca_list[j]->name[buflen] == '\\0')) {\n                    found = 1;\n                    break;\n                } else if (ca_list[j]->stdname != NULL\n                           && strncmp(buf, ca_list[j]->stdname, buflen) == 0\n                           && ca_list[j]->stdname[buflen] == '\\0') {\n                    found = 1;\n                    break;\n                } else\n                    j++;\n            }\n\n            if (!found)\n                break;          /* ignore this entry */\n\n            if (ca_list[j]->algorithm_mkey) {\n                if (alg_mkey) {\n                    alg_mkey &= ca_list[j]->algorithm_mkey;\n                    if (!alg_mkey) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_mkey = ca_list[j]->algorithm_mkey;\n                }\n            }\n\n            if (ca_list[j]->algorithm_auth) {\n                if (alg_auth) {\n                    alg_auth &= ca_list[j]->algorithm_auth;\n                    if (!alg_auth) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_auth = ca_list[j]->algorithm_auth;\n                }\n            }\n\n            if (ca_list[j]->algorithm_enc) {\n                if (alg_enc) {\n                    alg_enc &= ca_list[j]->algorithm_enc;\n                    if (!alg_enc) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_enc = ca_list[j]->algorithm_enc;\n                }\n            }\n\n            if (ca_list[j]->algorithm_mac) {\n                if (alg_mac) {\n                    alg_mac &= ca_list[j]->algorithm_mac;\n                    if (!alg_mac) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    alg_mac = ca_list[j]->algorithm_mac;\n                }\n            }\n\n            if (ca_list[j]->algo_strength & SSL_STRONG_MASK) {\n                if (algo_strength & SSL_STRONG_MASK) {\n                    algo_strength &=\n                        (ca_list[j]->algo_strength & SSL_STRONG_MASK) |\n                        ~SSL_STRONG_MASK;\n                    if (!(algo_strength & SSL_STRONG_MASK)) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    algo_strength = ca_list[j]->algo_strength & SSL_STRONG_MASK;\n                }\n            }\n\n            if (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) {\n                if (algo_strength & SSL_DEFAULT_MASK) {\n                    algo_strength &=\n                        (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) |\n                        ~SSL_DEFAULT_MASK;\n                    if (!(algo_strength & SSL_DEFAULT_MASK)) {\n                        found = 0;\n                        break;\n                    }\n                } else {\n                    algo_strength |=\n                        ca_list[j]->algo_strength & SSL_DEFAULT_MASK;\n                }\n            }\n\n            if (ca_list[j]->valid) {\n                /*\n                 * explicit ciphersuite found; its protocol version does not\n                 * become part of the search pattern!\n                 */\n\n                cipher_id = ca_list[j]->id;\n            } else {\n                /*\n                 * not an explicit ciphersuite; only in this case, the\n                 * protocol version is considered part of the search pattern\n                 */\n\n                if (ca_list[j]->min_tls) {\n                    if (min_tls != 0 && min_tls != ca_list[j]->min_tls) {\n                        found = 0;\n                        break;\n                    } else {\n                        min_tls = ca_list[j]->min_tls;\n                    }\n                }\n            }\n\n            if (!multi)\n                break;\n        }\n\n        /*\n         * Ok, we have the rule, now apply it\n         */\n        if (rule == CIPHER_SPECIAL) { /* special command */\n            ok = 0;\n            if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {\n                ok = ssl_cipher_strength_sort(head_p, tail_p);\n            } else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {\n                int level = *buf - '0';\n                if (level < 0 || level > 5) {\n                    ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n                } else {\n                    c->sec_level = level;\n                    ok = 1;\n                }\n            } else {\n                ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n            }\n            if (ok == 0)\n                retval = 0;\n            /*\n             * We do not support any \"multi\" options\n             * together with \"@\", so throw away the\n             * rest of the command, if any left, until\n             * end or ':' is found.\n             */\n            while ((*l != '\\0') && !ITEM_SEP(*l))\n                l++;\n        } else if (found) {\n            ssl_cipher_apply_rule(cipher_id,\n                                  alg_mkey, alg_auth, alg_enc, alg_mac,\n                                  min_tls, algo_strength, rule, -1, head_p,\n                                  tail_p);\n        } else {\n            while ((*l != '\\0') && !ITEM_SEP(*l))\n                l++;\n        }\n        if (*l == '\\0')\n            break;              /* done */\n    }\n\n    return retval;\n}"
        ],
        "source": [
            "    int j, multi, found, rule, retval, ok, buflen;"
        ],
        "index": 59,
        "location": {
            "file_path": "ssl/ssl_ciph.c",
            "region": {
                "startLine": 1215,
                "startColumn": 20,
                "endColumn": 25
            },
            "context": {
                "startLine": 1213,
                "endLine": 1217,
                "snippet": {
                    "text": "} else if (found) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/ssl/ssl_ciph.c",
                        "function_body": "965  static int ssl_cipher_process_rulestr(const char *rule_str,\n966                                        CIPHER_ORDER **head_p,\n967                                        CIPHER_ORDER **tail_p,\n968                                        const SSL_CIPHER **ca_list, CERT *c)\n969  {\n970      uint32_t alg_mkey, alg_auth, alg_enc, alg_mac, algo_strength;\n971      int min_tls;\n972      const char *l, *buf;\n973      int j, multi, found, rule, retval, ok, buflen;\n974      uint32_t cipher_id = 0;\n975      char ch;\n976\n977      retval = 1;\n978      l = rule_str;\n979      for (;;) {\n980          ch = *l;\n981\n982          if (ch == '\\0')\n983              break;              /* done */\n984          if (ch == '-') {\n985              rule = CIPHER_DEL;\n986              l++;\n987          } else if (ch == '+') {\n988              rule = CIPHER_ORD;\n989              l++;\n990          } else if (ch == '!') {\n991              rule = CIPHER_KILL;\n992              l++;\n993          } else if (ch == '@') {\n994              rule = CIPHER_SPECIAL;\n995              l++;\n996          } else {\n997              rule = CIPHER_ADD;\n998          }\n999\n1000         if (ITEM_SEP(ch)) {\n1001             l++;\n1002             continue;\n1003         }\n1004\n1005         alg_mkey = 0;\n1006         alg_auth = 0;\n1007         alg_enc = 0;\n1008         alg_mac = 0;\n1009         min_tls = 0;\n1010         algo_strength = 0;\n1011\n1012         for (;;) {\n1013             ch = *l;\n1014             buf = l;\n1015             buflen = 0;\n1016 #ifndef CHARSET_EBCDIC\n1017             while (((ch >= 'A') && (ch <= 'Z')) ||\n1018                    ((ch >= '0') && (ch <= '9')) ||\n1019                    ((ch >= 'a') && (ch <= 'z')) ||\n1020                    (ch == '-') || (ch == '_') || (ch == '.') || (ch == '='))\n1021 #else\n1022             while (isalnum((unsigned char)ch) || (ch == '-') || (ch == '_') || (ch == '.')\n1023                    || (ch == '='))\n1024 #endif\n1025             {\n1026                 ch = *(++l);\n1027                 buflen++;\n1028             }\n1029\n1030             if (buflen == 0) {\n1031                 /*\n1032                  * We hit something we cannot deal with,\n1033                  * it is no command or separator nor\n1034                  * alphanumeric, so we call this an error.\n1035                  */\n1036                 ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1037                 return 0;\n1038             }\n1039\n1040             if (rule == CIPHER_SPECIAL) {\n1041                 found = 0;      /* unused -- avoid compiler warning */\n1042                 break;          /* special treatment */\n1043             }\n1044\n1045             /* check for multi-part specification */\n1046             if (ch == '+') {\n1047                 multi = 1;\n1048                 l++;\n1049             } else {\n1050                 multi = 0;\n1051             }\n1052\n1053             /*\n1054              * Now search for the cipher alias in the ca_list. Be careful\n1055              * with the strncmp, because the \"buflen\" limitation\n1056              * will make the rule \"ADH:SOME\" and the cipher\n1057              * \"ADH-MY-CIPHER\" look like a match for buflen=3.\n1058              * So additionally check whether the cipher name found\n1059              * has the correct length. We can save a strlen() call:\n1060              * just checking for the '\\0' at the right place is\n1061              * sufficient, we have to strncmp() anyway. (We cannot\n1062              * use strcmp(), because buf is not '\\0' terminated.)\n1063              */\n1064             j = found = 0;\n1065             cipher_id = 0;\n1066             while (ca_list[j]) {\n1067                 if (strncmp(buf, ca_list[j]->name, buflen) == 0\n1068                     && (ca_list[j]->name[buflen] == '\\0')) {\n1069                     found = 1;\n1070                     break;\n1071                 } else if (ca_list[j]->stdname != NULL\n1072                            && strncmp(buf, ca_list[j]->stdname, buflen) == 0\n1073                            && ca_list[j]->stdname[buflen] == '\\0') {\n1074                     found = 1;\n1075                     break;\n1076                 } else\n1077                     j++;\n1078             }\n1079\n1080             if (!found)\n1081                 break;          /* ignore this entry */\n1082\n1083             if (ca_list[j]->algorithm_mkey) {\n1084                 if (alg_mkey) {\n1085                     alg_mkey &= ca_list[j]->algorithm_mkey;\n1086                     if (!alg_mkey) {\n1087                         found = 0;\n1088                         break;\n1089                     }\n1090                 } else {\n1091                     alg_mkey = ca_list[j]->algorithm_mkey;\n1092                 }\n1093             }\n1094\n1095             if (ca_list[j]->algorithm_auth) {\n1096                 if (alg_auth) {\n1097                     alg_auth &= ca_list[j]->algorithm_auth;\n1098                     if (!alg_auth) {\n1099                         found = 0;\n1100                         break;\n1101                     }\n1102                 } else {\n1103                     alg_auth = ca_list[j]->algorithm_auth;\n1104                 }\n1105             }\n1106\n1107             if (ca_list[j]->algorithm_enc) {\n1108                 if (alg_enc) {\n1109                     alg_enc &= ca_list[j]->algorithm_enc;\n1110                     if (!alg_enc) {\n1111                         found = 0;\n1112                         break;\n1113                     }\n1114                 } else {\n1115                     alg_enc = ca_list[j]->algorithm_enc;\n1116                 }\n1117             }\n1118\n1119             if (ca_list[j]->algorithm_mac) {\n1120                 if (alg_mac) {\n1121                     alg_mac &= ca_list[j]->algorithm_mac;\n1122                     if (!alg_mac) {\n1123                         found = 0;\n1124                         break;\n1125                     }\n1126                 } else {\n1127                     alg_mac = ca_list[j]->algorithm_mac;\n1128                 }\n1129             }\n1130\n1131             if (ca_list[j]->algo_strength & SSL_STRONG_MASK) {\n1132                 if (algo_strength & SSL_STRONG_MASK) {\n1133                     algo_strength &=\n1134                         (ca_list[j]->algo_strength & SSL_STRONG_MASK) |\n1135                         ~SSL_STRONG_MASK;\n1136                     if (!(algo_strength & SSL_STRONG_MASK)) {\n1137                         found = 0;\n1138                         break;\n1139                     }\n1140                 } else {\n1141                     algo_strength = ca_list[j]->algo_strength & SSL_STRONG_MASK;\n1142                 }\n1143             }\n1144\n1145             if (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) {\n1146                 if (algo_strength & SSL_DEFAULT_MASK) {\n1147                     algo_strength &=\n1148                         (ca_list[j]->algo_strength & SSL_DEFAULT_MASK) |\n1149                         ~SSL_DEFAULT_MASK;\n1150                     if (!(algo_strength & SSL_DEFAULT_MASK)) {\n1151                         found = 0;\n1152                         break;\n1153                     }\n1154                 } else {\n1155                     algo_strength |=\n1156                         ca_list[j]->algo_strength & SSL_DEFAULT_MASK;\n1157                 }\n1158             }\n1159\n1160             if (ca_list[j]->valid) {\n1161                 /*\n1162                  * explicit ciphersuite found; its protocol version does not\n1163                  * become part of the search pattern!\n1164                  */\n1165\n1166                 cipher_id = ca_list[j]->id;\n1167             } else {\n1168                 /*\n1169                  * not an explicit ciphersuite; only in this case, the\n1170                  * protocol version is considered part of the search pattern\n1171                  */\n1172\n1173                 if (ca_list[j]->min_tls) {\n1174                     if (min_tls != 0 && min_tls != ca_list[j]->min_tls) {\n1175                         found = 0;\n1176                         break;\n1177                     } else {\n1178                         min_tls = ca_list[j]->min_tls;\n1179                     }\n1180                 }\n1181             }\n1182\n1183             if (!multi)\n1184                 break;\n1185         }\n1186\n1187         /*\n1188          * Ok, we have the rule, now apply it\n1189          */\n1190         if (rule == CIPHER_SPECIAL) { /* special command */\n1191             ok = 0;\n1192             if ((buflen == 8) && HAS_PREFIX(buf, \"STRENGTH\")) {\n1193                 ok = ssl_cipher_strength_sort(head_p, tail_p);\n1194             } else if (buflen == 10 && CHECK_AND_SKIP_PREFIX(buf, \"SECLEVEL=\")) {\n1195                 int level = *buf - '0';\n1196                 if (level < 0 || level > 5) {\n1197                     ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1198                 } else {\n1199                     c->sec_level = level;\n1200                     ok = 1;\n1201                 }\n1202             } else {\n1203                 ERR_raise(ERR_LIB_SSL, SSL_R_INVALID_COMMAND);\n1204             }\n1205             if (ok == 0)\n1206                 retval = 0;\n1207             /*\n1208              * We do not support any \"multi\" options\n1209              * together with \"@\", so throw away the\n1210              * rest of the command, if any left, until\n1211              * end or ':' is found.\n1212              */\n1213             while ((*l != '\\0') && !ITEM_SEP(*l))\n1214                 l++;\n1215         } else if (found) {\n1216             ssl_cipher_apply_rule(cipher_id,\n1217                                   alg_mkey, alg_auth, alg_enc, alg_mac,\n1218                                   min_tls, algo_strength, rule, -1, head_p,\n1219                                   tail_p);\n1220         } else {\n1221             while ((*l != '\\0') && !ITEM_SEP(*l))\n1222                 l++;\n1223         }\n1224         if (*l == '\\0')\n1225             break;              /* done */\n1226     }\n1227\n1228     return retval;\n1229 }"
                    }
                ]
            }
        ],
        "sink": "} else if (found) {",
        "final_sink": "} else if (found) {"
    },
    {
        "prt": "rv",
        "function_call": [
            "BIO *OSSL_HTTP_REQ_CTX_exchange(OSSL_HTTP_REQ_CTX *rctx)\n{\n    int rv;\n\n    if (rctx == NULL) {\n        ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);\n        return NULL;\n    }\n\n    for (;;) {\n        rv = OSSL_HTTP_REQ_CTX_nbio(rctx);\n        if (rv != -1)\n            break;\n        /* BIO_should_retry was true */\n        /* will not actually wait if rctx->max_time == 0 */\n        if (BIO_wait(rctx->rbio, rctx->max_time, 100 /* milliseconds */) <= 0)\n            return NULL;\n    }\n\n    if (rv == 0) {\n        if (rctx->redirection_url == NULL) { /* an error occurred */\n            if (rctx->len_to_send > 0)\n                ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_SENDING);\n            else\n                ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_RECEIVING);\n        }\n        return NULL;\n    }\n    return rctx->state == OHS_STREAM ? rctx->rbio : rctx->mem;\n}"
        ],
        "source": [
            "    int rv;"
        ],
        "index": 60,
        "location": {
            "file_path": "crypto/http/http_client.c",
            "region": {
                "startLine": 1040,
                "startColumn": 9,
                "endColumn": 11
            },
            "context": {
                "startLine": 1038,
                "endLine": 1042,
                "snippet": {
                    "text": "if (rv == 0) {"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/crypto/http/http_client.c",
                        "function_body": "1021 BIO *OSSL_HTTP_REQ_CTX_exchange(OSSL_HTTP_REQ_CTX *rctx)\n1022 {\n1023     int rv;\n1024\n1025     if (rctx == NULL) {\n1026         ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);\n1027         return NULL;\n1028     }\n1029\n1030     for (;;) {\n1031         rv = OSSL_HTTP_REQ_CTX_nbio(rctx);\n1032         if (rv != -1)\n1033             break;\n1034         /* BIO_should_retry was true */\n1035         /* will not actually wait if rctx->max_time == 0 */\n1036         if (BIO_wait(rctx->rbio, rctx->max_time, 100 /* milliseconds */) <= 0)\n1037             return NULL;\n1038     }\n1039\n1040     if (rv == 0) {\n1041         if (rctx->redirection_url == NULL) { /* an error occurred */\n1042             if (rctx->len_to_send > 0)\n1043                 ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_SENDING);\n1044             else\n1045                 ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_RECEIVING);\n1046         }\n1047         return NULL;\n1048     }\n1049     return rctx->state == OHS_STREAM ? rctx->rbio : rctx->mem;\n1050 }"
                    },
                    {
                        "file_path": "/crypto/ocsp/ocsp_http.c",
                        "function_body": "51 OCSP_RESPONSE *OCSP_sendreq_bio(BIO *b, const char *path, OCSP_REQUEST *req)\n52 {\n53     OCSP_RESPONSE *resp = NULL;\n54     OSSL_HTTP_REQ_CTX *ctx;\n55     BIO *mem;\n56\n57     ctx = OCSP_sendreq_new(b, path, req, 0 /* default buf_size */);\n58     if (ctx == NULL)\n59         return NULL;\n60     mem = OSSL_HTTP_REQ_CTX_exchange(ctx);\n61     /* ASN1_item_d2i_bio handles NULL bio gracefully */\n62     resp = (OCSP_RESPONSE *)ASN1_item_d2i_bio(ASN1_ITEM_rptr(OCSP_RESPONSE),\n63                                               mem, NULL);\n64\n65     OSSL_HTTP_REQ_CTX_free(ctx);\n66     return resp;\n67 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/http/http_client.c",
                        "function_body": "1021 BIO *OSSL_HTTP_REQ_CTX_exchange(OSSL_HTTP_REQ_CTX *rctx)\n1022 {\n1023     int rv;\n1024\n1025     if (rctx == NULL) {\n1026         ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);\n1027         return NULL;\n1028     }\n1029\n1030     for (;;) {\n1031         rv = OSSL_HTTP_REQ_CTX_nbio(rctx);\n1032         if (rv != -1)\n1033             break;\n1034         /* BIO_should_retry was true */\n1035         /* will not actually wait if rctx->max_time == 0 */\n1036         if (BIO_wait(rctx->rbio, rctx->max_time, 100 /* milliseconds */) <= 0)\n1037             return NULL;\n1038     }\n1039\n1040     if (rv == 0) {\n1041         if (rctx->redirection_url == NULL) { /* an error occurred */\n1042             if (rctx->len_to_send > 0)\n1043                 ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_SENDING);\n1044             else\n1045                 ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_RECEIVING);\n1046         }\n1047         return NULL;\n1048     }\n1049     return rctx->state == OHS_STREAM ? rctx->rbio : rctx->mem;\n1050 }"
                    },
                    {
                        "file_path": "/test/http_test.c",
                        "function_body": "492 static int test_http_resp_hdr_limit(size_t limit)\n493 {\n494     BIO *wbio = BIO_new(BIO_s_mem());\n495     BIO *rbio = BIO_new(BIO_s_mem());\n496     BIO *mem = NULL;\n497     server_args mock_args = { NULL, NULL, NULL, '0', 0 };\n498     int res = 0;\n499     OSSL_HTTP_REQ_CTX *rctx = NULL;\n500\n501     if (TEST_ptr(wbio) == 0 || TEST_ptr(rbio) == 0)\n502         goto err;\n503\n504     mock_args.txt = text1;\n505     mock_args.content_type = \"text/plain\";\n506     mock_args.version = '1';\n507     mock_args.out = rbio;\n508\n509     BIO_set_callback_ex(wbio, http_bio_cb_ex);\n510     BIO_set_callback_arg(wbio, (char *)&mock_args);\n511\n512     rctx = OSSL_HTTP_REQ_CTX_new(wbio, rbio, 8192);\n513     if (TEST_ptr(rctx) == 0)\n514         goto err;\n515\n516     if (!TEST_true(OSSL_HTTP_REQ_CTX_set_request_line(rctx, 0 /* GET */,\n517                                                       NULL, NULL, RPATH)))\n518         goto err;\n519\n520     OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines(rctx, limit);\n521     mem = OSSL_HTTP_REQ_CTX_exchange(rctx);\n522\n523     /*\n524      * Note the server sends 4 http response headers, thus we expect to\n525      * see failure here when we set header limit in http response to 1.\n526      */\n527     if (limit == 1)\n528         res = TEST_ptr_null(mem);\n529     else\n530         res = TEST_ptr(mem);\n531\n532  err:\n533     BIO_free(wbio);\n534     BIO_free(rbio);\n535     OSSL_HTTP_REQ_CTX_free(rctx);\n536\n537     return res;\n538 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/http/http_client.c",
                        "function_body": "1021 BIO *OSSL_HTTP_REQ_CTX_exchange(OSSL_HTTP_REQ_CTX *rctx)\n1022 {\n1023     int rv;\n1024\n1025     if (rctx == NULL) {\n1026         ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);\n1027         return NULL;\n1028     }\n1029\n1030     for (;;) {\n1031         rv = OSSL_HTTP_REQ_CTX_nbio(rctx);\n1032         if (rv != -1)\n1033             break;\n1034         /* BIO_should_retry was true */\n1035         /* will not actually wait if rctx->max_time == 0 */\n1036         if (BIO_wait(rctx->rbio, rctx->max_time, 100 /* milliseconds */) <= 0)\n1037             return NULL;\n1038     }\n1039\n1040     if (rv == 0) {\n1041         if (rctx->redirection_url == NULL) { /* an error occurred */\n1042             if (rctx->len_to_send > 0)\n1043                 ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_SENDING);\n1044             else\n1045                 ERR_raise(ERR_LIB_HTTP, HTTP_R_ERROR_RECEIVING);\n1046         }\n1047         return NULL;\n1048     }\n1049     return rctx->state == OHS_STREAM ? rctx->rbio : rctx->mem;\n1050 }"
                    },
                    {
                        "file_path": "/crypto/http/http_client.c",
                        "function_body": "1179 BIO *OSSL_HTTP_exchange(OSSL_HTTP_REQ_CTX *rctx, char **redirection_url)\n1180 {\n1181     BIO *resp;\n1182\n1183     if (rctx == NULL) {\n1184         ERR_raise(ERR_LIB_HTTP, ERR_R_PASSED_NULL_PARAMETER);\n1185         return NULL;\n1186     }\n1187\n1188     if (redirection_url != NULL)\n1189         *redirection_url = NULL; /* do this beforehand to prevent dbl free */\n1190\n1191     resp = OSSL_HTTP_REQ_CTX_exchange(rctx);\n1192     if (resp == NULL) {\n1193         if (rctx->redirection_url != NULL) {\n1194             if (redirection_url == NULL)\n1195                 ERR_raise(ERR_LIB_HTTP, HTTP_R_REDIRECTION_NOT_ENABLED);\n1196             else\n1197                 /* may be NULL if out of memory: */\n1198                 *redirection_url = OPENSSL_strdup(rctx->redirection_url);\n1199         } else {\n1200             char buf[200];\n1201             unsigned long err = ERR_peek_error();\n1202             int lib = ERR_GET_LIB(err);\n1203             int reason = ERR_GET_REASON(err);\n1204\n1205             if (lib == ERR_LIB_SSL || lib == ERR_LIB_HTTP\n1206                     || (lib == ERR_LIB_BIO && reason == BIO_R_CONNECT_TIMEOUT)\n1207                     || (lib == ERR_LIB_BIO && reason == BIO_R_CONNECT_ERROR)\n1208 #ifndef OPENSSL_NO_CMP\n1209                     || (lib == ERR_LIB_CMP\n1210                         && reason == CMP_R_POTENTIALLY_INVALID_CERTIFICATE)\n1211 #endif\n1212                 ) {\n1213                 if (rctx->server != NULL && *rctx->server != '\\0') {\n1214                     BIO_snprintf(buf, sizeof(buf), \"server=http%s://%s%s%s\",\n1215                                  rctx->use_ssl ? \"s\" : \"\", rctx->server,\n1216                                  rctx->port != NULL ? \":\" : \"\",\n1217                                  rctx->port != NULL ? rctx->port : \"\");\n1218                     ERR_add_error_data(1, buf);\n1219                 }\n1220                 if (rctx->proxy != NULL)\n1221                     ERR_add_error_data(2, \" proxy=\", rctx->proxy);\n1222                 if (err == 0) {\n1223                     BIO_snprintf(buf, sizeof(buf), \" peer has disconnected%s\",\n1224                                  rctx->use_ssl ? \" violating the protocol\" :\n1225                                  \", likely because it requires the use of TLS\");\n1226                     ERR_add_error_data(1, buf);\n1227                 }\n1228             }\n1229         }\n1230     }\n1231\n1232     if (resp != NULL && !BIO_up_ref(resp))\n1233         resp = NULL;\n1234     return resp;\n1235 }"
                    }
                ]
            }
        ],
        "sink": "if (rv == 0) {",
        "final_sink": "if (rv == 0) {"
    },
    {
        "prt": "e[_]",
        "function_call": [
            "static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n{\n    signed char e[64];\n    signed char carry;\n    ge_p1p1 r;\n    ge_p2 s;\n    ge_precomp t;\n    int i;\n\n    for (i = 0; i < 32; ++i) {\n        e[2 * i + 0] = (a[i] >> 0) & 15;\n        e[2 * i + 1] = (a[i] >> 4) & 15;\n    }\n    /* each e[i] is between 0 and 15 */\n    /* e[63] is between 0 and 7 */\n\n    carry = 0;\n    for (i = 0; i < 63; ++i) {\n        e[i] += carry;\n        carry = e[i] + 8;\n        carry >>= 4;\n        e[i] -= carry << 4;\n    }\n    e[63] += carry;\n    /* each e[i] is between -8 and 8 */\n\n    ge_p3_0(h);\n    for (i = 1; i < 64; i += 2) {\n        table_select(&t, i / 2, e[i]);\n        ge_madd(&r, h, &t);\n        ge_p1p1_to_p3(h, &r);\n    }\n\n    ge_p3_dbl(&r, h);\n    ge_p1p1_to_p2(&s, &r);\n    ge_p2_dbl(&r, &s);\n    ge_p1p1_to_p2(&s, &r);\n    ge_p2_dbl(&r, &s);\n    ge_p1p1_to_p2(&s, &r);\n    ge_p2_dbl(&r, &s);\n    ge_p1p1_to_p3(h, &r);\n\n    for (i = 0; i < 64; i += 2) {\n        table_select(&t, i / 2, e[i]);\n        ge_madd(&r, h, &t);\n        ge_p1p1_to_p3(h, &r);\n    }\n\n    OPENSSL_cleanse(e, sizeof(e));\n}"
        ],
        "source": [
            "    signed char e[64];"
        ],
        "index": 61,
        "location": {
            "file_path": "crypto/ec/curve25519.c",
            "region": {
                "startLine": 4251,
                "startColumn": 9,
                "endColumn": 13
            },
            "context": {
                "startLine": 4249,
                "endLine": 4253,
                "snippet": {
                    "text": "e[i] += carry;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "4233 static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n4234 {\n4235     signed char e[64];\n4236     signed char carry;\n4237     ge_p1p1 r;\n4238     ge_p2 s;\n4239     ge_precomp t;\n4240     int i;\n4241\n4242     for (i = 0; i < 32; ++i) {\n4243         e[2 * i + 0] = (a[i] >> 0) & 15;\n4244         e[2 * i + 1] = (a[i] >> 4) & 15;\n4245     }\n4246     /* each e[i] is between 0 and 15 */\n4247     /* e[63] is between 0 and 7 */\n4248\n4249     carry = 0;\n4250     for (i = 0; i < 63; ++i) {\n4251         e[i] += carry;\n4252         carry = e[i] + 8;\n4253         carry >>= 4;\n4254         e[i] -= carry << 4;\n4255     }\n4256     e[63] += carry;\n4257     /* each e[i] is between -8 and 8 */\n4258\n4259     ge_p3_0(h);\n4260     for (i = 1; i < 64; i += 2) {\n4261         table_select(&t, i / 2, e[i]);\n4262         ge_madd(&r, h, &t);\n4263         ge_p1p1_to_p3(h, &r);\n4264     }\n4265\n4266     ge_p3_dbl(&r, h);\n4267     ge_p1p1_to_p2(&s, &r);\n4268     ge_p2_dbl(&r, &s);\n4269     ge_p1p1_to_p2(&s, &r);\n4270     ge_p2_dbl(&r, &s);\n4271     ge_p1p1_to_p2(&s, &r);\n4272     ge_p2_dbl(&r, &s);\n4273     ge_p1p1_to_p3(h, &r);\n4274\n4275     for (i = 0; i < 64; i += 2) {\n4276         table_select(&t, i / 2, e[i]);\n4277         ge_madd(&r, h, &t);\n4278         ge_p1p1_to_p3(h, &r);\n4279     }\n4280\n4281     OPENSSL_cleanse(e, sizeof(e));\n4282 }"
                    },
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "5706 ossl_x25519_public_from_private(uint8_t out_public_value[32],\n5707                                 const uint8_t private_key[32])\n5708 {\n5709     uint8_t e[32];\n5710     ge_p3 A;\n5711     fe zplusy, zminusy, zminusy_inv;\n5712\n5713     memcpy(e, private_key, 32);\n5714     e[0] &= 248;\n5715     e[31] &= 127;\n5716     e[31] |= 64;\n5717\n5718     ge_scalarmult_base(&A, e);\n5719\n5720     /*\n5721      * We only need the u-coordinate of the curve25519 point.\n5722      * The map is u=(y+1)/(1-y). Since y=Y/Z, this gives\n5723      * u=(Z+Y)/(Z-Y).\n5724      */\n5725     fe_add(zplusy, A.Z, A.Y);\n5726     fe_sub(zminusy, A.Z, A.Y);\n5727     fe_invert(zminusy_inv, zminusy);\n5728     fe_mul(zplusy, zplusy, zminusy_inv);\n5729     fe_tobytes(out_public_value, zplusy);\n5730\n5731     OPENSSL_cleanse(e, sizeof(e));\n5732 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "4233 static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n4234 {\n4235     signed char e[64];\n4236     signed char carry;\n4237     ge_p1p1 r;\n4238     ge_p2 s;\n4239     ge_precomp t;\n4240     int i;\n4241\n4242     for (i = 0; i < 32; ++i) {\n4243         e[2 * i + 0] = (a[i] >> 0) & 15;\n4244         e[2 * i + 1] = (a[i] >> 4) & 15;\n4245     }\n4246     /* each e[i] is between 0 and 15 */\n4247     /* e[63] is between 0 and 7 */\n4248\n4249     carry = 0;\n4250     for (i = 0; i < 63; ++i) {\n4251         e[i] += carry;\n4252         carry = e[i] + 8;\n4253         carry >>= 4;\n4254         e[i] -= carry << 4;\n4255     }\n4256     e[63] += carry;\n4257     /* each e[i] is between -8 and 8 */\n4258\n4259     ge_p3_0(h);\n4260     for (i = 1; i < 64; i += 2) {\n4261         table_select(&t, i / 2, e[i]);\n4262         ge_madd(&r, h, &t);\n4263         ge_p1p1_to_p3(h, &r);\n4264     }\n4265\n4266     ge_p3_dbl(&r, h);\n4267     ge_p1p1_to_p2(&s, &r);\n4268     ge_p2_dbl(&r, &s);\n4269     ge_p1p1_to_p2(&s, &r);\n4270     ge_p2_dbl(&r, &s);\n4271     ge_p1p1_to_p2(&s, &r);\n4272     ge_p2_dbl(&r, &s);\n4273     ge_p1p1_to_p3(h, &r);\n4274\n4275     for (i = 0; i < 64; i += 2) {\n4276         table_select(&t, i / 2, e[i]);\n4277         ge_madd(&r, h, &t);\n4278         ge_p1p1_to_p3(h, &r);\n4279     }\n4280\n4281     OPENSSL_cleanse(e, sizeof(e));\n4282 }"
                    },
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "5665 ossl_ed25519_public_from_private(OSSL_LIB_CTX *ctx, uint8_t out_public_key[32],\n5666                                  const uint8_t private_key[32],\n5667                                  const char *propq)\n5668 {\n5669     uint8_t az[SHA512_DIGEST_LENGTH];\n5670     ge_p3 A;\n5671     int r;\n5672     EVP_MD *sha512 = NULL;\n5673\n5674     sha512 = EVP_MD_fetch(ctx, SN_sha512, propq);\n5675     if (sha512 == NULL)\n5676         return 0;\n5677     r = EVP_Digest(private_key, 32, az, NULL, sha512, NULL);\n5678     EVP_MD_free(sha512);\n5679     if (!r) {\n5680         OPENSSL_cleanse(az, sizeof(az));\n5681         return 0;\n5682     }\n5683\n5684     az[0] &= 248;\n5685     az[31] &= 63;\n5686     az[31] |= 64;\n5687\n5688     ge_scalarmult_base(&A, az);\n5689     ge_p3_tobytes(out_public_key, &A);\n5690\n5691     OPENSSL_cleanse(az, sizeof(az));\n5692     return 1;\n5693 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "4233 static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n4234 {\n4235     signed char e[64];\n4236     signed char carry;\n4237     ge_p1p1 r;\n4238     ge_p2 s;\n4239     ge_precomp t;\n4240     int i;\n4241\n4242     for (i = 0; i < 32; ++i) {\n4243         e[2 * i + 0] = (a[i] >> 0) & 15;\n4244         e[2 * i + 1] = (a[i] >> 4) & 15;\n4245     }\n4246     /* each e[i] is between 0 and 15 */\n4247     /* e[63] is between 0 and 7 */\n4248\n4249     carry = 0;\n4250     for (i = 0; i < 63; ++i) {\n4251         e[i] += carry;\n4252         carry = e[i] + 8;\n4253         carry >>= 4;\n4254         e[i] -= carry << 4;\n4255     }\n4256     e[63] += carry;\n4257     /* each e[i] is between -8 and 8 */\n4258\n4259     ge_p3_0(h);\n4260     for (i = 1; i < 64; i += 2) {\n4261         table_select(&t, i / 2, e[i]);\n4262         ge_madd(&r, h, &t);\n4263         ge_p1p1_to_p3(h, &r);\n4264     }\n4265\n4266     ge_p3_dbl(&r, h);\n4267     ge_p1p1_to_p2(&s, &r);\n4268     ge_p2_dbl(&r, &s);\n4269     ge_p1p1_to_p2(&s, &r);\n4270     ge_p2_dbl(&r, &s);\n4271     ge_p1p1_to_p2(&s, &r);\n4272     ge_p2_dbl(&r, &s);\n4273     ge_p1p1_to_p3(h, &r);\n4274\n4275     for (i = 0; i < 64; i += 2) {\n4276         table_select(&t, i / 2, e[i]);\n4277         ge_madd(&r, h, &t);\n4278         ge_p1p1_to_p3(h, &r);\n4279     }\n4280\n4281     OPENSSL_cleanse(e, sizeof(e));\n4282 }"
                    },
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "5474 ossl_ed25519_sign(uint8_t *out_sig, const uint8_t *tbs, size_t tbs_len,\n5475                   const uint8_t public_key[32], const uint8_t private_key[32],\n5476                   const uint8_t dom2flag, const uint8_t phflag, const uint8_t csflag,\n5477                   const uint8_t *context, size_t context_len,\n5478                   OSSL_LIB_CTX *libctx, const char *propq)\n5479 {\n5480     uint8_t az[SHA512_DIGEST_LENGTH];\n5481     uint8_t nonce[SHA512_DIGEST_LENGTH];\n5482     ge_p3 R;\n5483     uint8_t hram[SHA512_DIGEST_LENGTH];\n5484     EVP_MD *sha512 = EVP_MD_fetch(libctx, SN_sha512, propq);\n5485     EVP_MD_CTX *hash_ctx = EVP_MD_CTX_new();\n5486     unsigned int sz;\n5487     int res = 0;\n5488\n5489     if (context == NULL)\n5490         context_len = 0;\n5491\n5492     /* if csflag is set, then a non-empty context-string is required */\n5493     if (csflag && context_len == 0)\n5494         goto err;\n5495\n5496     /* if dom2flag is not set, then an empty context-string is required */\n5497     if (!dom2flag && context_len > 0)\n5498         goto err;\n5499\n5500     if (sha512 == NULL || hash_ctx == NULL)\n5501         goto err;\n5502\n5503     if (!EVP_DigestInit_ex(hash_ctx, sha512, NULL)\n5504         || !EVP_DigestUpdate(hash_ctx, private_key, 32)\n5505         || !EVP_DigestFinal_ex(hash_ctx, az, &sz))\n5506         goto err;\n5507\n5508     az[0] &= 248;\n5509     az[31] &= 63;\n5510     az[31] |= 64;\n5511\n5512     if (!hash_init_with_dom(hash_ctx, sha512, dom2flag, phflag, context, context_len)\n5513         || !EVP_DigestUpdate(hash_ctx, az + 32, 32)\n5514         || !EVP_DigestUpdate(hash_ctx, tbs, tbs_len)\n5515         || !EVP_DigestFinal_ex(hash_ctx, nonce, &sz))\n5516         goto err;\n5517\n5518     x25519_sc_reduce(nonce);\n5519     ge_scalarmult_base(&R, nonce);\n5520     ge_p3_tobytes(out_sig, &R);\n5521\n5522     if (!hash_init_with_dom(hash_ctx, sha512, dom2flag, phflag, context, context_len)\n5523         || !EVP_DigestUpdate(hash_ctx, out_sig, 32)\n5524         || !EVP_DigestUpdate(hash_ctx, public_key, 32)\n5525         || !EVP_DigestUpdate(hash_ctx, tbs, tbs_len)\n5526         || !EVP_DigestFinal_ex(hash_ctx, hram, &sz))\n5527         goto err;\n5528\n5529     x25519_sc_reduce(hram);\n5530     sc_muladd(out_sig + 32, hram, az, nonce);\n5531\n5532     res = 1;\n5533 err:\n5534     OPENSSL_cleanse(nonce, sizeof(nonce));\n5535     OPENSSL_cleanse(az, sizeof(az));\n5536     EVP_MD_free(sha512);\n5537     EVP_MD_CTX_free(hash_ctx);\n5538     return res;\n5539 }"
                    }
                ]
            }
        ],
        "sink": "e[i] += carry;",
        "final_sink": "e[i] += carry;"
    },
    {
        "prt": "e[_]",
        "function_call": [
            "static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n{\n    signed char e[64];\n    signed char carry;\n    ge_p1p1 r;\n    ge_p2 s;\n    ge_precomp t;\n    int i;\n\n    for (i = 0; i < 32; ++i) {\n        e[2 * i + 0] = (a[i] >> 0) & 15;\n        e[2 * i + 1] = (a[i] >> 4) & 15;\n    }\n    /* each e[i] is between 0 and 15 */\n    /* e[63] is between 0 and 7 */\n\n    carry = 0;\n    for (i = 0; i < 63; ++i) {\n        e[i] += carry;\n        carry = e[i] + 8;\n        carry >>= 4;\n        e[i] -= carry << 4;\n    }\n    e[63] += carry;\n    /* each e[i] is between -8 and 8 */\n\n    ge_p3_0(h);\n    for (i = 1; i < 64; i += 2) {\n        table_select(&t, i / 2, e[i]);\n        ge_madd(&r, h, &t);\n        ge_p1p1_to_p3(h, &r);\n    }\n\n    ge_p3_dbl(&r, h);\n    ge_p1p1_to_p2(&s, &r);\n    ge_p2_dbl(&r, &s);\n    ge_p1p1_to_p2(&s, &r);\n    ge_p2_dbl(&r, &s);\n    ge_p1p1_to_p2(&s, &r);\n    ge_p2_dbl(&r, &s);\n    ge_p1p1_to_p3(h, &r);\n\n    for (i = 0; i < 64; i += 2) {\n        table_select(&t, i / 2, e[i]);\n        ge_madd(&r, h, &t);\n        ge_p1p1_to_p3(h, &r);\n    }\n\n    OPENSSL_cleanse(e, sizeof(e));\n}"
        ],
        "source": [
            "    signed char e[64];"
        ],
        "index": 62,
        "location": {
            "file_path": "crypto/ec/curve25519.c",
            "region": {
                "startLine": 4256,
                "startColumn": 5,
                "endColumn": 9
            },
            "context": {
                "startLine": 4254,
                "endLine": 4258,
                "snippet": {
                    "text": "e[63] += carry;"
                }
            }
        },
        "result": 0,
        "baseline_context": [
            {
                "text": [
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "4233 static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n4234 {\n4235     signed char e[64];\n4236     signed char carry;\n4237     ge_p1p1 r;\n4238     ge_p2 s;\n4239     ge_precomp t;\n4240     int i;\n4241\n4242     for (i = 0; i < 32; ++i) {\n4243         e[2 * i + 0] = (a[i] >> 0) & 15;\n4244         e[2 * i + 1] = (a[i] >> 4) & 15;\n4245     }\n4246     /* each e[i] is between 0 and 15 */\n4247     /* e[63] is between 0 and 7 */\n4248\n4249     carry = 0;\n4250     for (i = 0; i < 63; ++i) {\n4251         e[i] += carry;\n4252         carry = e[i] + 8;\n4253         carry >>= 4;\n4254         e[i] -= carry << 4;\n4255     }\n4256     e[63] += carry;\n4257     /* each e[i] is between -8 and 8 */\n4258\n4259     ge_p3_0(h);\n4260     for (i = 1; i < 64; i += 2) {\n4261         table_select(&t, i / 2, e[i]);\n4262         ge_madd(&r, h, &t);\n4263         ge_p1p1_to_p3(h, &r);\n4264     }\n4265\n4266     ge_p3_dbl(&r, h);\n4267     ge_p1p1_to_p2(&s, &r);\n4268     ge_p2_dbl(&r, &s);\n4269     ge_p1p1_to_p2(&s, &r);\n4270     ge_p2_dbl(&r, &s);\n4271     ge_p1p1_to_p2(&s, &r);\n4272     ge_p2_dbl(&r, &s);\n4273     ge_p1p1_to_p3(h, &r);\n4274\n4275     for (i = 0; i < 64; i += 2) {\n4276         table_select(&t, i / 2, e[i]);\n4277         ge_madd(&r, h, &t);\n4278         ge_p1p1_to_p3(h, &r);\n4279     }\n4280\n4281     OPENSSL_cleanse(e, sizeof(e));\n4282 }"
                    },
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "5474 ossl_ed25519_sign(uint8_t *out_sig, const uint8_t *tbs, size_t tbs_len,\n5475                   const uint8_t public_key[32], const uint8_t private_key[32],\n5476                   const uint8_t dom2flag, const uint8_t phflag, const uint8_t csflag,\n5477                   const uint8_t *context, size_t context_len,\n5478                   OSSL_LIB_CTX *libctx, const char *propq)\n5479 {\n5480     uint8_t az[SHA512_DIGEST_LENGTH];\n5481     uint8_t nonce[SHA512_DIGEST_LENGTH];\n5482     ge_p3 R;\n5483     uint8_t hram[SHA512_DIGEST_LENGTH];\n5484     EVP_MD *sha512 = EVP_MD_fetch(libctx, SN_sha512, propq);\n5485     EVP_MD_CTX *hash_ctx = EVP_MD_CTX_new();\n5486     unsigned int sz;\n5487     int res = 0;\n5488\n5489     if (context == NULL)\n5490         context_len = 0;\n5491\n5492     /* if csflag is set, then a non-empty context-string is required */\n5493     if (csflag && context_len == 0)\n5494         goto err;\n5495\n5496     /* if dom2flag is not set, then an empty context-string is required */\n5497     if (!dom2flag && context_len > 0)\n5498         goto err;\n5499\n5500     if (sha512 == NULL || hash_ctx == NULL)\n5501         goto err;\n5502\n5503     if (!EVP_DigestInit_ex(hash_ctx, sha512, NULL)\n5504         || !EVP_DigestUpdate(hash_ctx, private_key, 32)\n5505         || !EVP_DigestFinal_ex(hash_ctx, az, &sz))\n5506         goto err;\n5507\n5508     az[0] &= 248;\n5509     az[31] &= 63;\n5510     az[31] |= 64;\n5511\n5512     if (!hash_init_with_dom(hash_ctx, sha512, dom2flag, phflag, context, context_len)\n5513         || !EVP_DigestUpdate(hash_ctx, az + 32, 32)\n5514         || !EVP_DigestUpdate(hash_ctx, tbs, tbs_len)\n5515         || !EVP_DigestFinal_ex(hash_ctx, nonce, &sz))\n5516         goto err;\n5517\n5518     x25519_sc_reduce(nonce);\n5519     ge_scalarmult_base(&R, nonce);\n5520     ge_p3_tobytes(out_sig, &R);\n5521\n5522     if (!hash_init_with_dom(hash_ctx, sha512, dom2flag, phflag, context, context_len)\n5523         || !EVP_DigestUpdate(hash_ctx, out_sig, 32)\n5524         || !EVP_DigestUpdate(hash_ctx, public_key, 32)\n5525         || !EVP_DigestUpdate(hash_ctx, tbs, tbs_len)\n5526         || !EVP_DigestFinal_ex(hash_ctx, hram, &sz))\n5527         goto err;\n5528\n5529     x25519_sc_reduce(hram);\n5530     sc_muladd(out_sig + 32, hram, az, nonce);\n5531\n5532     res = 1;\n5533 err:\n5534     OPENSSL_cleanse(nonce, sizeof(nonce));\n5535     OPENSSL_cleanse(az, sizeof(az));\n5536     EVP_MD_free(sha512);\n5537     EVP_MD_CTX_free(hash_ctx);\n5538     return res;\n5539 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "4233 static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n4234 {\n4235     signed char e[64];\n4236     signed char carry;\n4237     ge_p1p1 r;\n4238     ge_p2 s;\n4239     ge_precomp t;\n4240     int i;\n4241\n4242     for (i = 0; i < 32; ++i) {\n4243         e[2 * i + 0] = (a[i] >> 0) & 15;\n4244         e[2 * i + 1] = (a[i] >> 4) & 15;\n4245     }\n4246     /* each e[i] is between 0 and 15 */\n4247     /* e[63] is between 0 and 7 */\n4248\n4249     carry = 0;\n4250     for (i = 0; i < 63; ++i) {\n4251         e[i] += carry;\n4252         carry = e[i] + 8;\n4253         carry >>= 4;\n4254         e[i] -= carry << 4;\n4255     }\n4256     e[63] += carry;\n4257     /* each e[i] is between -8 and 8 */\n4258\n4259     ge_p3_0(h);\n4260     for (i = 1; i < 64; i += 2) {\n4261         table_select(&t, i / 2, e[i]);\n4262         ge_madd(&r, h, &t);\n4263         ge_p1p1_to_p3(h, &r);\n4264     }\n4265\n4266     ge_p3_dbl(&r, h);\n4267     ge_p1p1_to_p2(&s, &r);\n4268     ge_p2_dbl(&r, &s);\n4269     ge_p1p1_to_p2(&s, &r);\n4270     ge_p2_dbl(&r, &s);\n4271     ge_p1p1_to_p2(&s, &r);\n4272     ge_p2_dbl(&r, &s);\n4273     ge_p1p1_to_p3(h, &r);\n4274\n4275     for (i = 0; i < 64; i += 2) {\n4276         table_select(&t, i / 2, e[i]);\n4277         ge_madd(&r, h, &t);\n4278         ge_p1p1_to_p3(h, &r);\n4279     }\n4280\n4281     OPENSSL_cleanse(e, sizeof(e));\n4282 }"
                    },
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "5665 ossl_ed25519_public_from_private(OSSL_LIB_CTX *ctx, uint8_t out_public_key[32],\n5666                                  const uint8_t private_key[32],\n5667                                  const char *propq)\n5668 {\n5669     uint8_t az[SHA512_DIGEST_LENGTH];\n5670     ge_p3 A;\n5671     int r;\n5672     EVP_MD *sha512 = NULL;\n5673\n5674     sha512 = EVP_MD_fetch(ctx, SN_sha512, propq);\n5675     if (sha512 == NULL)\n5676         return 0;\n5677     r = EVP_Digest(private_key, 32, az, NULL, sha512, NULL);\n5678     EVP_MD_free(sha512);\n5679     if (!r) {\n5680         OPENSSL_cleanse(az, sizeof(az));\n5681         return 0;\n5682     }\n5683\n5684     az[0] &= 248;\n5685     az[31] &= 63;\n5686     az[31] |= 64;\n5687\n5688     ge_scalarmult_base(&A, az);\n5689     ge_p3_tobytes(out_public_key, &A);\n5690\n5691     OPENSSL_cleanse(az, sizeof(az));\n5692     return 1;\n5693 }"
                    }
                ]
            },
            {
                "text": [
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "4233 static void ge_scalarmult_base(ge_p3 *h, const uint8_t *a)\n4234 {\n4235     signed char e[64];\n4236     signed char carry;\n4237     ge_p1p1 r;\n4238     ge_p2 s;\n4239     ge_precomp t;\n4240     int i;\n4241\n4242     for (i = 0; i < 32; ++i) {\n4243         e[2 * i + 0] = (a[i] >> 0) & 15;\n4244         e[2 * i + 1] = (a[i] >> 4) & 15;\n4245     }\n4246     /* each e[i] is between 0 and 15 */\n4247     /* e[63] is between 0 and 7 */\n4248\n4249     carry = 0;\n4250     for (i = 0; i < 63; ++i) {\n4251         e[i] += carry;\n4252         carry = e[i] + 8;\n4253         carry >>= 4;\n4254         e[i] -= carry << 4;\n4255     }\n4256     e[63] += carry;\n4257     /* each e[i] is between -8 and 8 */\n4258\n4259     ge_p3_0(h);\n4260     for (i = 1; i < 64; i += 2) {\n4261         table_select(&t, i / 2, e[i]);\n4262         ge_madd(&r, h, &t);\n4263         ge_p1p1_to_p3(h, &r);\n4264     }\n4265\n4266     ge_p3_dbl(&r, h);\n4267     ge_p1p1_to_p2(&s, &r);\n4268     ge_p2_dbl(&r, &s);\n4269     ge_p1p1_to_p2(&s, &r);\n4270     ge_p2_dbl(&r, &s);\n4271     ge_p1p1_to_p2(&s, &r);\n4272     ge_p2_dbl(&r, &s);\n4273     ge_p1p1_to_p3(h, &r);\n4274\n4275     for (i = 0; i < 64; i += 2) {\n4276         table_select(&t, i / 2, e[i]);\n4277         ge_madd(&r, h, &t);\n4278         ge_p1p1_to_p3(h, &r);\n4279     }\n4280\n4281     OPENSSL_cleanse(e, sizeof(e));\n4282 }"
                    },
                    {
                        "file_path": "/crypto/ec/curve25519.c",
                        "function_body": "5706 ossl_x25519_public_from_private(uint8_t out_public_value[32],\n5707                                 const uint8_t private_key[32])\n5708 {\n5709     uint8_t e[32];\n5710     ge_p3 A;\n5711     fe zplusy, zminusy, zminusy_inv;\n5712\n5713     memcpy(e, private_key, 32);\n5714     e[0] &= 248;\n5715     e[31] &= 127;\n5716     e[31] |= 64;\n5717\n5718     ge_scalarmult_base(&A, e);\n5719\n5720     /*\n5721      * We only need the u-coordinate of the curve25519 point.\n5722      * The map is u=(y+1)/(1-y). Since y=Y/Z, this gives\n5723      * u=(Z+Y)/(Z-Y).\n5724      */\n5725     fe_add(zplusy, A.Z, A.Y);\n5726     fe_sub(zminusy, A.Z, A.Y);\n5727     fe_invert(zminusy_inv, zminusy);\n5728     fe_mul(zplusy, zplusy, zminusy_inv);\n5729     fe_tobytes(out_public_value, zplusy);\n5730\n5731     OPENSSL_cleanse(e, sizeof(e));\n5732 }"
                    }
                ]
            }
        ],
        "sink": "e[63] += carry;",
        "final_sink": "e[63] += carry;"
    }
]