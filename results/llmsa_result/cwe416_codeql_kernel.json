[
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->mode = IEEE80211_CONN_MODE_LEGACY;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition of a wireless connection based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (representing the channel definition) and a pointer to a `ieee80211_conn_settings` structure (representing connection settings).\n\n1. **Null Pointer Handling**: The function allows the `conn` parameter to be `NULL`. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that the function can operate without a valid `conn` pointer, effectively treating it as a no-op in such cases.\n\n2. **Channel Width Handling**: The function checks the width of the channel (`c->width`) and performs different actions based on its value. It uses a switch statement to handle various channel widths, including downgrading the channel width and setting connection modes and bandwidth limits accordingly.\n\n3. **Connection Mode Assignment**: The line in question from the bug report (`conn->mode = IEEE80211_CONN_MODE_LEGACY;`) is executed when the channel width is `NL80211_CHAN_WIDTH_20`. This line assigns a specific connection mode to the `conn` structure.\n\n4. **Potential Dereferencing Issue**: The bug report raises a concern that `conn` may be `NULL` when dereferenced, which could lead to undefined behavior. However, the function has a mechanism to handle `NULL` pointers by assigning `_ignored` to `conn` if it is `NULL`.\n\n### Bug Report Analysis\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` and assigns a default value to `conn` if it is `NULL`. This effectively prevents any dereferencing of a `NULL` pointer within the function.\n\n### Conclusion\n\nGiven the explanation above, the code is designed to handle the case where `conn` is `NULL` by using a fallback mechanism. Therefore, the concern raised in the bug report does not indicate a real bug in the code.\n\n**Final Label**: @@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (`c`) and a pointer to a `ieee80211_conn_settings` structure (`conn`). \n\n1. **Null Check for `conn`:** \n   - The function allows the `conn` parameter to be `NULL`. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that the function can operate without a valid `conn` pointer, effectively treating it as if it were a valid pointer pointing to a default state.\n\n2. **Channel Width Handling:**\n   - The function uses a switch statement to handle different channel widths defined in the `cfg80211_chan_def` structure. Depending on the width, it modifies the properties of both `c` and `conn`.\n\n3. **Setting Bandwidth Limits:**\n   - For various cases of channel widths, the function sets the `bw_limit` of the `conn` structure to predefined constants (e.g., `IEEE80211_CONN_BW_LIMIT_20`, `IEEE80211_CONN_BW_LIMIT_40`, etc.). \n\n4. **Warnings:**\n   - The function includes several `WARN_ON_ONCE` statements that trigger warnings if certain conditions are met, indicating potential issues during execution.\n\n5. **Final Validations:**\n   - At the end of the function, it checks if the channel definition is valid and may trigger a warning if it is not.\n\n### Bug Report Analysis\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis effectively prevents any dereferencing of a `NULL` pointer because if `conn` is `NULL`, it is assigned to point to a valid `_ignored` structure. Therefore, all subsequent accesses to `conn` (like `conn->mode` and `conn->bw_limit`) are safe because `conn` will never be `NULL` after this check.\n\n### Conclusion\n\nGiven that the code already handles the potential `NULL` dereference by assigning a valid structure to `conn` when it is `NULL`, the bug report is a false alarm. The code is designed to handle the situation correctly.\n\nLabel: `@@@ false alarm @@@`",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'if (conn->mode == IEEE80211_CONN_MODE_VHT)'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (which holds channel definition information) and a pointer to a `ieee80211_conn_settings` structure (which holds connection settings).\n\n1. **Null Check for `conn`:** \n   - The function allows the `conn` parameter to be `NULL`. If it is `NULL`, the function assigns a pointer to a local static variable `_ignored`, which is an empty `ieee80211_conn_settings` structure. This means that if the caller does not care about the connection settings, the function can still operate without crashing.\n\n2. **Channel Width Handling:**\n   - The function uses a switch statement to handle different channel widths defined in the `cfg80211_chan_def` structure. Depending on the width, it modifies the channel definition and the connection settings.\n   - For example, if the width is `NL80211_CHAN_WIDTH_40`, it checks if the connection mode is `IEEE80211_CONN_MODE_VHT`. If it is, it changes the mode to `IEEE80211_CONN_MODE_HT`.\n\n3. **Warnings and Validations:**\n   - The function contains several `WARN_ON_ONCE` statements that trigger warnings if certain conditions are met, indicating potential issues during execution.\n   - At the end of the function, it checks if the channel definition is valid and issues a warning if it is not.\n\n### Evaluation of the Bug Report\n\nThe bug report states that the variable `conn` may be `NULL` and should be checked before dereferencing it. However, the code already includes a check for `NULL` at the beginning of the function:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned to a valid address of `_ignored`, which is a local variable. Therefore, any subsequent dereferencing of `conn` is safe because it will either point to a valid `ieee80211_conn_settings` structure or the `_ignored` structure.\n\n### Conclusion\n\nGiven that the code already handles the potential `NULL` dereference by assigning a valid structure when `conn` is `NULL`, the bug report is a false alarm. The function is designed to safely handle the case where `conn` is not provided.\n\nThus, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->mode = IEEE80211_CONN_MODE_HT;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet is a function named `ieee80211_chandef_downgrade`, which is designed to downgrade the channel definition of a wireless connection based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (representing the channel definition) and a pointer to an `ieee80211_conn_settings` structure (representing connection settings).\n\n1. **Null Pointer Handling**: The function allows the `conn` parameter to be `NULL`. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that the function can operate without a valid `conn` pointer, effectively treating it as if it were a default or ignored connection setting.\n\n2. **Channel Width Handling**: The function uses a switch statement to handle different channel widths defined in the `cfg80211_chan_def` structure. Depending on the width, it modifies the channel definition and the connection settings.\n\n3. **Connection Mode Updates**: The function updates the `mode` and `bw_limit` fields of the `conn` structure based on the current channel width and other conditions. For example, if the channel width is `NL80211_CHAN_WIDTH_40` and the connection mode is `IEEE80211_CONN_MODE_VHT`, it changes the mode to `IEEE80211_CONN_MODE_HT`.\n\n4. **Warnings**: The function includes several `WARN_ON_ONCE` statements that trigger warnings if certain unexpected conditions occur, such as unsupported channel widths.\n\n5. **Final Checks**: At the end of the function, it checks if the new primary width is valid and updates the channel definition accordingly.\n\n### Bug Report Analysis\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned to a local static structure `_ignored`, which prevents any dereferencing of a `NULL` pointer later in the function. Therefore, the function can safely use `conn` without the risk of dereferencing a `NULL` pointer.\n\n### Conclusion\n\nGiven the explanation above, the bug report is a false positive. The code correctly handles the case where `conn` is `NULL` by providing a fallback mechanism. \n\nThus, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on the current channel width and connection settings. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (representing the channel definition) and a pointer to an `ieee80211_conn_settings` structure (representing connection settings).\n\n1. **Null Check for `conn`:** The function allows the caller to pass a `NULL` pointer for `conn`. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that if the caller does not care about the connection settings, the function can still operate without crashing.\n\n2. **Channel Width Handling:** The function uses a switch statement to handle different channel widths. Depending on the width of the channel (`c->width`), it modifies the channel definition and the connection settings accordingly. For example:\n   - If the width is `NL80211_CHAN_WIDTH_20`, it sets the connection mode to `IEEE80211_CONN_MODE_LEGACY` and the bandwidth limit to `IEEE80211_CONN_BW_LIMIT_20`.\n   - Similar adjustments are made for other widths (e.g., `NL80211_CHAN_WIDTH_40`, `NL80211_CHAN_WIDTH_80`, etc.).\n\n3. **Dereferencing `conn`:** The function dereferences `conn` multiple times to set its `mode` and `bw_limit`. If `conn` were `NULL` and the caller did not provide a valid pointer, this would lead to undefined behavior (likely a segmentation fault).\n\n### Bug Report Analysis\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis effectively prevents dereferencing a `NULL` pointer by ensuring that `conn` is always valid within the function, either pointing to the caller's provided structure or to the local `_ignored` structure.\n\n### Conclusion\n\nGiven that the code handles the potential `NULL` pointer for `conn` appropriately by assigning it to a valid structure when `NULL`, the bug report is a false positive. The function is designed to handle the case where `conn` is `NULL` without causing a crash.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'if (conn->mode == IEEE80211_CONN_MODE_VHT)'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (which holds channel information) and a pointer to a `ieee80211_conn_settings` structure (which holds connection settings).\n\n1. **Null Check for `conn`:** \n   - The function checks if the `conn` pointer is `NULL`. If it is, it assigns `conn` to point to a local static variable `_ignored`, which is initialized to zero. This allows the function to proceed without a valid `conn` pointer if the caller does not care about connection settings.\n\n2. **Channel Width Handling:**\n   - The function uses a switch statement to handle different channel widths defined in `c->width`. Depending on the width, it modifies the channel definition and the connection settings accordingly.\n   - For example, if the width is `NL80211_CHAN_WIDTH_40`, it checks if the connection mode is `IEEE80211_CONN_MODE_VHT` and potentially downgrades it to `IEEE80211_CONN_MODE_HT`.\n\n3. **Dereferencing `conn`:**\n   - The function dereferences `conn` multiple times to access its members (like `conn->mode` and `conn->bw_limit`). This is safe because of the initial null check, which ensures that if `conn` is `NULL`, it will point to `_ignored`, which is a valid object.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value conn may be null; it should be checked before dereferencing.\" \n\n- **True Positive or False Positive?**\n  - The code already includes a check for `conn` being `NULL` at the beginning of the function. If `conn` is `NULL`, it assigns it to a valid local variable `_ignored`, which means that all subsequent dereferences of `conn` are safe.\n  - Therefore, the dereferencing of `conn` is protected by the initial check, and the code will not attempt to dereference a `NULL` pointer.\n\n### Conclusion\n\nGiven the explanation above, the bug report is a false alarm because the code correctly handles the potential `NULL` value of `conn` before any dereferencing occurs.\n\nLabel: `@@@ false alarm @@@`",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->mode = IEEE80211_CONN_MODE_HT;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet is a function named `ieee80211_chandef_downgrade`, which is designed to downgrade the channel definition of a wireless connection based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (representing the channel definition) and a pointer to an `ieee80211_conn_settings` structure (representing connection settings).\n\n1. **Null Check for `conn`:** The function allows the `conn` parameter to be `NULL`. If it is `NULL`, the function assigns a pointer to a local static variable `_ignored`, which is initialized to zero. This means that if the caller does not care about the connection settings, the function can still operate without crashing.\n\n2. **Channel Width Handling:** The function uses a switch statement to handle different channel widths defined in the `cfg80211_chan_def` structure. Depending on the width, it modifies the channel definition and the connection settings accordingly.\n\n3. **Connection Mode Updates:** The function updates the `mode` and `bw_limit` fields of the `conn` structure based on the current channel width and other conditions. For example, if the channel width is 40 MHz and the connection mode is VHT, it changes the mode to HT.\n\n4. **Warnings:** The function includes several `WARN_ON_ONCE` statements that trigger warnings if certain unexpected conditions occur, such as unsupported channel widths.\n\n5. **Final Checks:** At the end of the function, it checks if the new primary width is valid and updates the channel definition accordingly.\n\n### Bug Report Analysis\n\nThe bug report states that `conn` may be null and should be checked before dereferencing. However, the code already includes a check for `conn` being `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned to a valid address (`&_ignored`), which is a local variable. Therefore, any subsequent dereferencing of `conn` is safe because it will never be `NULL` after this check.\n\n### Conclusion\n\nGiven that the code already handles the potential null dereference by assigning a valid address to `conn` when it is `NULL`, the bug report is a false positive. The code is designed to handle the case where `conn` is not provided, and it does so correctly.\n\nThus, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (which represents the channel definition) and a pointer to a `ieee80211_conn_settings` structure (which contains connection settings).\n\n1. **Null Check for `conn`:** \n   - The function allows the caller to pass `NULL` for the `conn` parameter. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that the function can safely operate even if `conn` is not provided.\n\n2. **Channel Width Handling:**\n   - The function checks the width of the channel (`c->width`) and performs different actions based on its value. It has a switch-case structure that handles various channel widths (20, 40, 80, etc.).\n   - For each case, it modifies the `conn` settings, such as `conn->mode` and `conn->bw_limit`, based on the current channel width.\n\n3. **Warnings and Validations:**\n   - The function uses `WARN_ON_ONCE` to log warnings if certain unexpected conditions occur, such as unsupported channel widths.\n   - It also checks the validity of the channel definition at the end of the function.\n\n### Evaluation of the Bug Report\n\nThe bug report states that `conn` may be null and should be checked before dereferencing. However, the code already includes a check for `conn` being `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned a valid pointer to `_ignored`, which is a local static structure. Therefore, the dereferencing of `conn` later in the function is safe because it will never be `NULL` after this check.\n\n### Conclusion\n\nGiven that the code already handles the potential `NULL` dereference by assigning a valid pointer when `conn` is `NULL`, the bug report is not valid. The code is designed to handle the case where `conn` is `NULL` appropriately.\n\nThus, the label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on the current channel width and connection settings. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (representing the channel definition) and a pointer to an `ieee80211_conn_settings` structure (representing the connection settings).\n\n1. **Null Check for `conn`:** The function allows the `conn` parameter to be `NULL`. If it is `NULL`, the function assigns a pointer to a local static structure `_ignored` to `conn`. This means that if the caller does not care about the connection settings, the function can still operate without crashing.\n\n2. **Channel Width Handling:** The function uses a switch statement to handle different channel widths. Depending on the width of the channel (`c->width`), it modifies the properties of the `conn` structure, such as `conn->mode` and `conn->bw_limit`.\n\n3. **Setting Bandwidth Limits:** The function sets the bandwidth limits based on the channel width. For example, if the width is `NL80211_CHAN_WIDTH_80`, it sets `conn->bw_limit` to `IEEE80211_CONN_BW_LIMIT_80`.\n\n4. **Warnings:** The function includes several `WARN_ON_ONCE` statements that trigger warnings if certain conditions are met, such as unsupported channel widths.\n\n5. **Final Validations:** At the end of the function, it checks if the channel definition is valid and issues a warning if it is not.\n\n### Bug Report Analysis\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned to a valid local structure `_ignored`, preventing any dereferencing of a `NULL` pointer later in the function.\n\n### Conclusion\n\nSince the code already handles the potential `NULL` dereference by assigning a valid structure to `conn` when it is `NULL`, the bug report is a false positive. The function is designed to safely handle the case where `conn` is not provided.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on the current channel width and connection settings. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (representing the channel definition) and a pointer to an `ieee80211_conn_settings` structure (representing the connection settings).\n\n1. **Null Check for `conn`:** \n   - The function allows the `conn` parameter to be `NULL`. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that if the caller does not care about the connection settings, the function can still operate without crashing.\n\n2. **Channel Width Handling:**\n   - The function uses a switch statement to handle different channel widths defined in the `cfg80211_chan_def` structure. Depending on the width, it modifies the channel definition and the connection settings accordingly.\n\n3. **Setting Bandwidth Limits:**\n   - For various cases (like `NL80211_CHAN_WIDTH_20`, `NL80211_CHAN_WIDTH_40`, etc.), the function sets the `bw_limit` field of the `conn` structure to specific values based on the channel width.\n\n4. **Warnings:**\n   - The function includes several `WARN_ON_ONCE` statements that trigger warnings if certain conditions are met, indicating potential issues in the logic or unexpected states.\n\n### Evaluation of the Bug Report\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned to a valid local structure `_ignored`, preventing any dereferencing of a `NULL` pointer later in the function.\n\n### Conclusion\n\nSince the code already handles the potential `NULL` dereference by assigning a valid structure when `conn` is `NULL`, the bug report is a false positive. The function is designed to safely handle the case where `conn` is not provided.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on the current channel width and connection settings. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (representing the channel definition) and a pointer to a `ieee80211_conn_settings` structure (representing connection settings).\n\n1. **Null Check for `conn`:** The function allows the `conn` parameter to be `NULL`. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that the function can operate without a valid `conn` pointer, effectively treating it as if it were a default or ignored connection setting.\n\n2. **Channel Width Handling:** The function uses a switch statement to handle different channel widths defined in the `cfg80211_chan_def` structure. Depending on the width, it modifies the `conn` settings, such as `mode` and `bw_limit`, and updates the channel definition accordingly.\n\n3. **Warnings and Validations:** The function includes several `WARN_ON_ONCE` statements that trigger warnings if certain conditions are met, such as unsupported channel widths. It also performs validations on the channel definition at the end of the function.\n\n### Bug Report Analysis\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned a pointer to a local static structure `_ignored`, which prevents any dereferencing of a `NULL` pointer later in the function. \n\n### Conclusion\n\nSince the code already handles the potential `NULL` dereference by assigning a default value to `conn`, the bug report is not valid. The code is designed to safely handle the case where `conn` is `NULL`.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->mode = IEEE80211_CONN_MODE_S1G;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function `ieee80211_chandef_downgrade`, which is responsible for downgrading the channel definition based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (`c`) and a pointer to a `ieee80211_conn_settings` structure (`conn`).\n\n1. **Null Check for `conn`:** \n   - The function allows the `conn` parameter to be `NULL`. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that the function can operate without a valid `conn` pointer, which is a design choice that allows flexibility in how the function is called.\n\n2. **Switch Statement:**\n   - The function uses a switch statement to handle different channel widths defined in `c->width`. Depending on the width, it modifies the `conn->mode` and `conn->bw_limit` accordingly.\n   - For certain cases (like `NL80211_CHAN_WIDTH_1` to `NL80211_CHAN_WIDTH_16`), it sets `conn->mode` to `IEEE80211_CONN_MODE_S1G` and `conn->bw_limit` to `IEEE80211_CONN_BW_LIMIT_20`.\n\n3. **Warnings:**\n   - The function uses `WARN_ON_ONCE` to log warnings if certain conditions are met, such as when the width is not expected.\n\n4. **Final Checks:**\n   - After modifying the channel definition, the function checks if the new primary width is valid and updates the channel definition accordingly.\n\n### Evaluation of the Bug Report\n\nThe bug report states that `conn` may be null and should be checked before dereferencing. However, the code already includes a check for `conn` being `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned to a valid local structure `_ignored`, thus preventing any dereferencing of a `NULL` pointer later in the function.\n\n### Conclusion\n\nSince the code already handles the case where `conn` can be `NULL` by assigning it to a valid structure, the bug report is a false alarm. The function is designed to work correctly even if `conn` is not provided (i.e., is `NULL`).\n\nTherefore, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on the current channel width and connection settings. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (`c`) and a pointer to a `ieee80211_conn_settings` structure (`conn`).\n\n1. **Null Check for `conn`:** \n   - The function allows the caller to pass a `NULL` pointer for `conn`. If `conn` is `NULL`, it assigns a local static variable `_ignored` to `conn`. This means that the function can safely operate even if `conn` is not provided.\n\n2. **Channel Width Handling:**\n   - The function uses a switch statement to handle different channel widths defined in the `cfg80211_chan_def` structure. Depending on the width, it modifies the properties of both `c` and `conn`.\n\n3. **Setting Bandwidth Limits:**\n   - For various cases of channel widths (20, 40, 80, etc.), the function sets the `bw_limit` of the `conn` structure to predefined constants (e.g., `IEEE80211_CONN_BW_LIMIT_20`, `IEEE80211_CONN_BW_LIMIT_40`, etc.).\n\n4. **Warnings:**\n   - The function includes several `WARN_ON_ONCE` statements that trigger warnings if certain conditions are met, such as unsupported channel widths.\n\n5. **Final Validations:**\n   - At the end of the function, it checks if the channel definition is valid and may trigger a warning if it is not.\n\n### Evaluation of the Bug Report\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` at line 3507:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is assigned to a local variable `_ignored`, which is a valid instance of `ieee80211_conn_settings`. Therefore, the dereferencing of `conn` later in the function is safe because it will never be `NULL` after this check.\n\n### Conclusion\n\nGiven that the code already handles the potential `NULL` dereference by assigning a valid object to `conn`, the bug report is a false positive. The code is designed to safely handle the case where `conn` is `NULL`.\n\nThus, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->mode = IEEE80211_CONN_MODE_LEGACY;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (which represents the channel definition) and a pointer to a `ieee80211_conn_settings` structure (which holds connection settings).\n\n1. **Null Check for `conn`:** \n   - The function allows the `conn` parameter to be `NULL`. If `conn` is `NULL`, it assigns a pointer to a local static structure `_ignored` to `conn`. This means that the function can operate without a valid `conn` pointer, effectively treating it as if the caller does not care about the connection settings.\n\n2. **Channel Width Handling:**\n   - The function checks the width of the channel (`c->width`) and performs different actions based on its value. It has a switch-case structure that handles various channel widths (e.g., `NL80211_CHAN_WIDTH_20`, `NL80211_CHAN_WIDTH_40`, etc.).\n   - For each case, it modifies the `conn->mode` and `conn->bw_limit` based on the channel width.\n\n3. **Warnings and Validations:**\n   - The function uses `WARN_ON_ONCE` to trigger warnings if certain conditions are met (e.g., unexpected channel widths).\n   - It also checks if the channel definition is valid at the end of the function.\n\n### Evaluation of the Bug Report\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. However, the code already includes a check for `NULL` at the beginning of the function:\n\n```c\nif (!conn)\n    conn = &_ignored;\n```\n\nThis line ensures that if `conn` is `NULL`, it is replaced with a pointer to a local static structure `_ignored`, which is safe to dereference. Therefore, the dereferencing of `conn` later in the function (e.g., `conn->mode`, `conn->bw_limit`) is safe because it will never be `NULL` after this check.\n\n### Conclusion\n\nGiven the explanation above, the bug report is a false positive. The code correctly handles the case where `conn` is `NULL` by assigning it to a valid structure, thus preventing any dereferencing of a `NULL` pointer.\n\nLabel: `@@@ false alarm @@@`",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': 'conn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;'}\nValue conn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/spectmgmt.c",
                                "function_body": "221 int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,\n222 \t\t\t\t struct ieee802_11_elems *elems,\n223 \t\t\t\t enum nl80211_band current_band,\n224 \t\t\t\t u32 vht_cap_info,\n225 \t\t\t\t struct ieee80211_conn_settings *conn,\n226 \t\t\t\t u8 *bssid,\n227 \t\t\t\t struct ieee80211_csa_ie *csa_ie)\n228 {\n229 \tenum nl80211_band new_band = current_band;\n230 \tint new_freq;\n231 \tu8 new_chan_no = 0, new_op_class = 0;\n232 \tstruct ieee80211_channel *new_chan;\n233 \tstruct cfg80211_chan_def new_chandef = {};\n234 \tconst struct ieee80211_sec_chan_offs_ie *sec_chan_offs;\n235 \tconst struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;\n236 \tconst struct ieee80211_bandwidth_indication *bwi;\n237 \tconst struct ieee80211_ext_chansw_ie *ext_chansw_elem;\n238 \tint secondary_channel_offset = -1;\n239\n240 \tmemset(csa_ie, 0, sizeof(*csa_ie));\n241\n242 \tsec_chan_offs = elems->sec_chan_offs;\n243 \twide_bw_chansw_ie = elems->wide_bw_chansw_ie;\n244 \tbwi = elems->bandwidth_indication;\n245 \text_chansw_elem = elems->ext_chansw_ie;\n246\n247 \tif (conn->mode < IEEE80211_CONN_MODE_HT ||\n248 \t    conn->bw_limit < IEEE80211_CONN_BW_LIMIT_40) {\n249 \t\tsec_chan_offs = NULL;\n250 \t\twide_bw_chansw_ie = NULL;\n251 \t}\n252\n253 \tif (conn->mode < IEEE80211_CONN_MODE_VHT)\n254 \t\twide_bw_chansw_ie = NULL;\n255\n256 \tif (ext_chansw_elem) {\n257 \t\tnew_op_class = ext_chansw_elem->new_operating_class;\n258\n259 \t\tif (!ieee80211_operating_class_to_band(new_op_class, &new_band)) {\n260 \t\t\tnew_op_class = 0;\n261 \t\t\tsdata_info(sdata, \"cannot understand ECSA IE operating class, %d, ignoring\\n\",\n262 \t\t\t\t   ext_chansw_elem->new_operating_class);\n263 \t\t} else {\n264 \t\t\tnew_chan_no = ext_chansw_elem->new_ch_num;\n265 \t\t\tcsa_ie->count = ext_chansw_elem->count;\n266 \t\t\tcsa_ie->mode = ext_chansw_elem->mode;\n267 \t\t}\n268 \t}\n269\n270 \tif (!new_op_class && elems->ch_switch_ie) {\n271 \t\tnew_chan_no = elems->ch_switch_ie->new_ch_num;\n272 \t\tcsa_ie->count = elems->ch_switch_ie->count;\n273 \t\tcsa_ie->mode = elems->ch_switch_ie->mode;\n274 \t}\n275\n276 \t/* nothing here we understand */\n277 \tif (!new_chan_no)\n278 \t\treturn 1;\n279\n280 \t/* Mesh Channel Switch Parameters Element */\n281 \tif (elems->mesh_chansw_params_ie) {\n282 \t\tcsa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;\n283 \t\tcsa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;\n284 \t\tcsa_ie->pre_value = le16_to_cpu(\n285 \t\t\t\telems->mesh_chansw_params_ie->mesh_pre_value);\n286\n287 \t\tif (elems->mesh_chansw_params_ie->mesh_flags &\n288 \t\t\t\tWLAN_EID_CHAN_SWITCH_PARAM_REASON)\n289 \t\t\tcsa_ie->reason_code = le16_to_cpu(\n290 \t\t\t\telems->mesh_chansw_params_ie->mesh_reason);\n291 \t}\n292\n293 \tnew_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);\n294 \tnew_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);\n295 \tif (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {\n296 \t\tsdata_info(sdata,\n297 \t\t\t   \"BSS %pM switches to unsupported channel (%d MHz), disconnecting\\n\",\n298 \t\t\t   bssid, new_freq);\n299 \t\treturn -EINVAL;\n300 \t}\n301\n302 \tif (sec_chan_offs) {\n303 \t\tsecondary_channel_offset = sec_chan_offs->sec_chan_offs;\n304 \t} else if (conn->mode >= IEEE80211_CONN_MODE_HT) {\n305 \t\t/* If the secondary channel offset IE is not present,\n306 \t\t * we can't know what's the post-CSA offset, so the\n307 \t\t * best we can do is use 20MHz.\n308 \t\t*/\n309 \t\tsecondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n310 \t}\n311\n312 \tswitch (secondary_channel_offset) {\n313 \tdefault:\n314 \t\t/* secondary_channel_offset was present but is invalid */\n315 \tcase IEEE80211_HT_PARAM_CHA_SEC_NONE:\n316 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n317 \t\t\t\t\tNL80211_CHAN_HT20);\n318 \t\tbreak;\n319 \tcase IEEE80211_HT_PARAM_CHA_SEC_ABOVE:\n320 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n321 \t\t\t\t\tNL80211_CHAN_HT40PLUS);\n322 \t\tbreak;\n323 \tcase IEEE80211_HT_PARAM_CHA_SEC_BELOW:\n324 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n325 \t\t\t\t\tNL80211_CHAN_HT40MINUS);\n326 \t\tbreak;\n327 \tcase -1:\n328 \t\tcfg80211_chandef_create(&csa_ie->chanreq.oper, new_chan,\n329 \t\t\t\t\tNL80211_CHAN_NO_HT);\n330 \t\t/* keep width for 5/10 MHz channels */\n331 \t\tswitch (sdata->vif.bss_conf.chanreq.oper.width) {\n332 \t\tcase NL80211_CHAN_WIDTH_5:\n333 \t\tcase NL80211_CHAN_WIDTH_10:\n334 \t\t\tcsa_ie->chanreq.oper.width =\n335 \t\t\t\tsdata->vif.bss_conf.chanreq.oper.width;\n336 \t\t\tbreak;\n337 \t\tdefault:\n338 \t\t\tbreak;\n339 \t\t}\n340 \t\tbreak;\n341 \t}\n342\n343 \t/* parse one of the Elements to build a new chandef */\n344 \tmemset(&new_chandef, 0, sizeof(new_chandef));\n345 \tnew_chandef.chan = new_chan;\n346 \tif (bwi) {\n347 \t\t/* start with the CSA one */\n348 \t\tnew_chandef = csa_ie->chanreq.oper;\n349 \t\t/* and update the width accordingly */\n350 \t\tieee80211_chandef_eht_oper(&bwi->info, &new_chandef);\n351 \t} else if (!wide_bw_chansw_ie || !wbcs_elem_to_chandef(wide_bw_chansw_ie,\n352 \t\t\t\t\t\t\t       &new_chandef)) {\n353 \t\tif (!ieee80211_operating_class_to_chandef(new_op_class, new_chan,\n354 \t\t\t\t\t\t\t  &new_chandef))\n355 \t\t\tnew_chandef = csa_ie->chanreq.oper;\n356 \t}\n357\n358 \t/* check if the new chandef fits the capabilities */\n359 \tif (new_band == NL80211_BAND_6GHZ)\n360 \t\tvalidate_chandef_by_6ghz_he_eht_oper(sdata, conn, &new_chandef);\n361 \telse\n362 \t\tvalidate_chandef_by_ht_vht_oper(sdata, conn, vht_cap_info,\n363 \t\t\t\t\t\t&new_chandef);\n364\n365 \t/* if data is there validate the bandwidth & use it */\n366 \tif (new_chandef.chan) {\n367 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_320 &&\n368 \t\t    new_chandef.width == NL80211_CHAN_WIDTH_320)\n369 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n370\n371 \t\tif (conn->bw_limit < IEEE80211_CONN_BW_LIMIT_160 &&\n372 \t\t    (new_chandef.width == NL80211_CHAN_WIDTH_80P80 ||\n373 \t\t     new_chandef.width == NL80211_CHAN_WIDTH_160))\n374 \t\t\tieee80211_chandef_downgrade(&new_chandef, NULL);\n375\n376 \t\tif (!cfg80211_chandef_compatible(&new_chandef,\n377 \t\t\t\t\t\t &csa_ie->chanreq.oper)) {\n378 \t\t\tsdata_info(sdata,\n379 \t\t\t\t   \"BSS %pM: CSA has inconsistent channel data, disconnecting\\n\",\n380 \t\t\t\t   bssid);\n381 \t\t\treturn -EINVAL;\n382 \t\t}\n383\n384 \t\tcsa_ie->chanreq.oper = new_chandef;\n385 \t}\n386\n387 \tif (elems->max_channel_switch_time)\n388 \t\tcsa_ie->max_switch_time =\n389 \t\t\t(elems->max_channel_switch_time[0] << 0) |\n390 \t\t\t(elems->max_channel_switch_time[1] <<  8) |\n391 \t\t\t(elems->max_channel_switch_time[2] << 16);\n392\n393 \treturn 0;\n394 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/ieee80211_i.h",
                                "function_body": "2539 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,\n2540 \t\t\t    struct ieee80211_conn_settings *conn)\n2541 {\n2542 \tieee80211_chandef_downgrade(&chanreq->oper, conn);\n2543 \tif (WARN_ON(!conn))\n2544 \t\treturn;\n2545 \tif (conn->mode < IEEE80211_CONN_MODE_EHT)\n2546 \t\tchanreq->ap.chan = NULL;\n2547 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/tdls.c",
                                "function_body": "308 ieee80211_tdls_chandef_vht_upgrade(struct ieee80211_sub_if_data *sdata,\n309 \t\t\t\t   struct sta_info *sta)\n310 {\n311 \t/* IEEE802.11ac-2013 Table E-4 */\n312 \tstatic const u16 centers_80mhz[] = { 5210, 5290, 5530, 5610, 5690, 5775 };\n313 \tstruct cfg80211_chan_def uc = sta->tdls_chandef;\n314 \tenum nl80211_chan_width max_width =\n315 \t\tieee80211_sta_cap_chan_bw(&sta->deflink);\n316 \tint i;\n317\n318 \t/* only support upgrading non-narrow channels up to 80Mhz */\n319 \tif (max_width == NL80211_CHAN_WIDTH_5 ||\n320 \t    max_width == NL80211_CHAN_WIDTH_10)\n321 \t\treturn;\n322\n323 \tif (max_width > NL80211_CHAN_WIDTH_80)\n324 \t\tmax_width = NL80211_CHAN_WIDTH_80;\n325\n326 \tif (uc.width >= max_width)\n327 \t\treturn;\n328 \t/*\n329 \t * Channel usage constrains in the IEEE802.11ac-2013 specification only\n330 \t * allow expanding a 20MHz channel to 80MHz in a single way. In\n331 \t * addition, there are no 40MHz allowed channels that are not part of\n332 \t * the allowed 80MHz range in the 5GHz spectrum (the relevant one here).\n333 \t */\n334 \tfor (i = 0; i < ARRAY_SIZE(centers_80mhz); i++)\n335 \t\tif (abs(uc.chan->center_freq - centers_80mhz[i]) <= 30) {\n336 \t\t\tuc.center_freq1 = centers_80mhz[i];\n337 \t\t\tuc.center_freq2 = 0;\n338 \t\t\tuc.width = NL80211_CHAN_WIDTH_80;\n339 \t\t\tbreak;\n340 \t\t}\n341\n342 \tif (!uc.center_freq1)\n343 \t\treturn;\n344\n345 \t/* proceed to downgrade the chandef until usable or the same as AP BW */\n346 \twhile (uc.width > max_width ||\n347 \t       (uc.width > sta->tdls_chandef.width &&\n348 \t\t!cfg80211_reg_can_beacon_relax(sdata->local->hw.wiphy, &uc,\n349 \t\t\t\t\t       sdata->wdev.iftype)))\n350 \t\tieee80211_chandef_downgrade(&uc, NULL);\n351\n352 \tif (!cfg80211_chandef_identical(&uc, &sta->tdls_chandef)) {\n353 \t\ttdls_dbg(sdata, \"TDLS ch width upgraded %d -> %d\\n\",\n354 \t\t\t sta->tdls_chandef.width, uc.width);\n355\n356 \t\t/*\n357 \t\t * the station is not yet authorized when BW upgrade is done,\n358 \t\t * locking is not required\n359 \t\t */\n360 \t\tsta->tdls_chandef = uc;\n361 \t}\n362 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/mlme.c",
                                "function_body": "782 static int ieee80211_config_bw(struct ieee80211_link_data *link,\n783 \t\t\t       struct ieee802_11_elems *elems,\n784 \t\t\t       bool update, u64 *changed)\n785 {\n786 \tstruct ieee80211_channel *channel = link->conf->chanreq.oper.chan;\n787 \tstruct ieee80211_sub_if_data *sdata = link->sdata;\n788 \tstruct ieee80211_chan_req chanreq = {};\n789 \tenum ieee80211_conn_mode ap_mode;\n790 \tu32 vht_cap_info = 0;\n791 \tu16 ht_opmode;\n792 \tint ret;\n793\n794 \t/* don't track any bandwidth changes in legacy/S1G modes */\n795 \tif (link->u.mgd.conn.mode == IEEE80211_CONN_MODE_LEGACY ||\n796 \t    link->u.mgd.conn.mode == IEEE80211_CONN_MODE_S1G)\n797 \t\treturn 0;\n798\n799 \tif (elems->vht_cap_elem)\n800 \t\tvht_cap_info = le32_to_cpu(elems->vht_cap_elem->vht_cap_info);\n801\n802 \tap_mode = ieee80211_determine_ap_chan(sdata, channel, vht_cap_info,\n803 \t\t\t\t\t      elems, true, &link->u.mgd.conn,\n804 \t\t\t\t\t      &chanreq.ap);\n805\n806 \tif (ap_mode != link->u.mgd.conn.mode) {\n807 \t\tlink_info(link,\n808 \t\t\t  \"AP appears to change mode (expected %s, found %s), disconnect\\n\",\n809 \t\t\t  ieee80211_conn_mode_str(link->u.mgd.conn.mode),\n810 \t\t\t  ieee80211_conn_mode_str(ap_mode));\n811 \t\treturn -EINVAL;\n812 \t}\n813\n814 \tchanreq.oper = chanreq.ap;\n815 \tif (link->u.mgd.conn.mode < IEEE80211_CONN_MODE_EHT ||\n816 \t    sdata->vif.driver_flags & IEEE80211_VIF_IGNORE_OFDMA_WIDER_BW)\n817 \t\tchanreq.ap.chan = NULL;\n818\n819 \t/*\n820 \t * if HT operation mode changed store the new one -\n821 \t * this may be applicable even if channel is identical\n822 \t */\n823 \tif (elems->ht_operation) {\n824 \t\tht_opmode = le16_to_cpu(elems->ht_operation->operation_mode);\n825 \t\tif (link->conf->ht_operation_mode != ht_opmode) {\n826 \t\t\t*changed |= BSS_CHANGED_HT;\n827 \t\t\tlink->conf->ht_operation_mode = ht_opmode;\n828 \t\t}\n829 \t}\n830\n831 \t/*\n832 \t * Downgrade the new channel if we associated with restricted\n833 \t * bandwidth capabilities. For example, if we associated as a\n834 \t * 20 MHz STA to a 40 MHz AP (due to regulatory, capabilities\n835 \t * or config reasons) then switching to a 40 MHz channel now\n836 \t * won't do us any good -- we couldn't use it with the AP.\n837 \t */\n838 \twhile (link->u.mgd.conn.bw_limit <\n839 \t\t\tieee80211_min_bw_limit_from_chandef(&chanreq.oper))\n840 \t\tieee80211_chandef_downgrade(&chanreq.oper, NULL);\n841\n842 \tif (ieee80211_chanreq_identical(&chanreq, &link->conf->chanreq))\n843 \t\treturn 0;\n844\n845 \tlink_info(link,\n846 \t\t  \"AP %pM changed bandwidth, new used config is %d.%03d MHz, width %d (%d.%03d/%d MHz)\\n\",\n847 \t\t  link->u.mgd.bssid, chanreq.oper.chan->center_freq,\n848 \t\t  chanreq.oper.chan->freq_offset, chanreq.oper.width,\n849 \t\t  chanreq.oper.center_freq1, chanreq.oper.freq1_offset,\n850 \t\t  chanreq.oper.center_freq2);\n851\n852 \tif (!cfg80211_chandef_valid(&chanreq.oper)) {\n853 \t\tsdata_info(sdata,\n854 \t\t\t   \"AP %pM changed caps/bw in a way we can't support - disconnect\\n\",\n855 \t\t\t   link->u.mgd.bssid);\n856 \t\treturn -EINVAL;\n857 \t}\n858\n859 \tif (!update) {\n860 \t\tlink->conf->chanreq = chanreq;\n861 \t\treturn 0;\n862 \t}\n863\n864 \t/*\n865 \t * We're tracking the current AP here, so don't do any further checks\n866 \t * here. This keeps us from playing ping-pong with regulatory, without\n867 \t * it the following can happen (for example):\n868 \t *  - connect to an AP with 80 MHz, world regdom allows 80 MHz\n869 \t *  - AP advertises regdom US\n870 \t *  - CRDA loads regdom US with 80 MHz prohibited (old database)\n871 \t *  - we detect an unsupported channel and disconnect\n872 \t *  - disconnect causes CRDA to reload world regdomain and the game\n873 \t *    starts anew.\n874 \t * (see https://bugzilla.kernel.org/show_bug.cgi?id=70881)\n875 \t *\n876 \t * It seems possible that there are still scenarios with CSA or real\n877 \t * bandwidth changes where a this could happen, but those cases are\n878 \t * less common and wouldn't completely prevent using the AP.\n879 \t */\n880\n881 \tret = ieee80211_link_change_chanreq(link, &chanreq, changed);\n882 \tif (ret) {\n883 \t\tsdata_info(sdata,\n884 \t\t\t   \"AP %pM changed bandwidth to incompatible one - disconnect\\n\",\n885 \t\t\t   link->u.mgd.bssid);\n886 \t\treturn ret;\n887 \t}\n888\n889 \tcfg80211_schedule_channels_check(&sdata->wdev);\n890 \treturn 0;\n891 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/net/mac80211/util.c",
                                "function_body": "3500 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *c,\n3501 \t\t\t\t struct ieee80211_conn_settings *conn)\n3502 {\n3503 \tenum nl80211_chan_width new_primary_width;\n3504 \tstruct ieee80211_conn_settings _ignored = {};\n3505\n3506 \t/* allow passing NULL if caller doesn't care */\n3507 \tif (!conn)\n3508 \t\tconn = &_ignored;\n3509\n3510 again:\n3511 \t/* no-HT indicates nothing to do */\n3512 \tnew_primary_width = NL80211_CHAN_WIDTH_20_NOHT;\n3513\n3514 \tswitch (c->width) {\n3515 \tdefault:\n3516 \tcase NL80211_CHAN_WIDTH_20_NOHT:\n3517 \t\tWARN_ON_ONCE(1);\n3518 \t\tfallthrough;\n3519 \tcase NL80211_CHAN_WIDTH_20:\n3520 \t\tc->width = NL80211_CHAN_WIDTH_20_NOHT;\n3521 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3522 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3523 \t\tc->punctured = 0;\n3524 \t\tbreak;\n3525 \tcase NL80211_CHAN_WIDTH_40:\n3526 \t\tc->width = NL80211_CHAN_WIDTH_20;\n3527 \t\tc->center_freq1 = c->chan->center_freq;\n3528 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3529 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3530 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3531 \t\tc->punctured = 0;\n3532 \t\tbreak;\n3533 \tcase NL80211_CHAN_WIDTH_80:\n3534 \t\tnew_primary_width = NL80211_CHAN_WIDTH_40;\n3535 \t\tif (conn->mode == IEEE80211_CONN_MODE_VHT)\n3536 \t\t\tconn->mode = IEEE80211_CONN_MODE_HT;\n3537 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_40;\n3538 \t\tbreak;\n3539 \tcase NL80211_CHAN_WIDTH_80P80:\n3540 \t\tc->center_freq2 = 0;\n3541 \t\tc->width = NL80211_CHAN_WIDTH_80;\n3542 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3543 \t\tbreak;\n3544 \tcase NL80211_CHAN_WIDTH_160:\n3545 \t\tnew_primary_width = NL80211_CHAN_WIDTH_80;\n3546 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_80;\n3547 \t\tbreak;\n3548 \tcase NL80211_CHAN_WIDTH_320:\n3549 \t\tnew_primary_width = NL80211_CHAN_WIDTH_160;\n3550 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_160;\n3551 \t\tbreak;\n3552 \tcase NL80211_CHAN_WIDTH_1:\n3553 \tcase NL80211_CHAN_WIDTH_2:\n3554 \tcase NL80211_CHAN_WIDTH_4:\n3555 \tcase NL80211_CHAN_WIDTH_8:\n3556 \tcase NL80211_CHAN_WIDTH_16:\n3557 \t\tWARN_ON_ONCE(1);\n3558 \t\t/* keep c->width */\n3559 \t\tconn->mode = IEEE80211_CONN_MODE_S1G;\n3560 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3561 \t\tbreak;\n3562 \tcase NL80211_CHAN_WIDTH_5:\n3563 \tcase NL80211_CHAN_WIDTH_10:\n3564 \t\tWARN_ON_ONCE(1);\n3565 \t\t/* keep c->width */\n3566 \t\tconn->mode = IEEE80211_CONN_MODE_LEGACY;\n3567 \t\tconn->bw_limit = IEEE80211_CONN_BW_LIMIT_20;\n3568 \t\tbreak;\n3569 \t}\n3570\n3571 \tif (new_primary_width != NL80211_CHAN_WIDTH_20_NOHT) {\n3572 \t\tc->center_freq1 = cfg80211_chandef_primary(c, new_primary_width,\n3573 \t\t\t\t\t\t\t   &c->punctured);\n3574 \t\tc->width = new_primary_width;\n3575 \t}\n3576\n3577 \t/*\n3578 \t * With an 80 MHz channel, we might have the puncturing in the primary\n3579 \t * 40 Mhz channel, but that's not valid when downgraded to 40 MHz width.\n3580 \t * In that case, downgrade again.\n3581 \t */\n3582 \tif (!cfg80211_chandef_valid(c) && c->punctured)\n3583 \t\tgoto again;\n3584\n3585 \tWARN_ON_ONCE(!cfg80211_chandef_valid(c));\n3586 }"
                            },
                            {
                                "file_path": "/net/mac80211/chan.c",
                                "function_body": "360 _ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,\n361 \t\t\t\t  struct ieee80211_chanctx *ctx,\n362 \t\t\t\t  struct ieee80211_link_data *rsvd_for)\n363 {\n364 \tenum nl80211_chan_width max_bw;\n365 \tstruct cfg80211_chan_def min_def;\n366\n367 \tlockdep_assert_wiphy(local->hw.wiphy);\n368\n369 \t/* don't optimize non-20MHz based and radar_enabled confs */\n370 \tif (ctx->conf.def.width == NL80211_CHAN_WIDTH_5 ||\n371 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_10 ||\n372 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_1 ||\n373 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_2 ||\n374 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_4 ||\n375 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_8 ||\n376 \t    ctx->conf.def.width == NL80211_CHAN_WIDTH_16 ||\n377 \t    ctx->conf.radar_enabled) {\n378 \t\tctx->conf.min_def = ctx->conf.def;\n379 \t\treturn 0;\n380 \t}\n381\n382 \tmax_bw = ieee80211_get_chanctx_max_required_bw(local, ctx, rsvd_for);\n383\n384 \t/* downgrade chandef up to max_bw */\n385 \tmin_def = ctx->conf.def;\n386 \twhile (min_def.width > max_bw)\n387 \t\tieee80211_chandef_downgrade(&min_def, NULL);\n388\n389 \tif (cfg80211_chandef_identical(&ctx->conf.min_def, &min_def))\n390 \t\treturn 0;\n391\n392 \tctx->conf.min_def = min_def;\n393 \tif (!ctx->driver_present)\n394 \t\treturn 0;\n395\n396 \treturn IEEE80211_CHANCTX_CHANGE_MIN_WIDTH;\n397 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `ieee80211_chandef_downgrade` that is responsible for downgrading the channel definition based on certain conditions. The function takes two parameters: a pointer to a `cfg80211_chan_def` structure (`c`) and a pointer to a `ieee80211_conn_settings` structure (`conn`). \n\n1. **Null Check for `conn`:** \n   - The function allows the `conn` parameter to be `NULL`. If it is `NULL`, the function assigns it to a local static variable `_ignored`, which is initialized to zero. This means that if the caller does not care about the connection settings, the function can still operate without crashing.\n\n2. **Channel Width Handling:**\n   - The function checks the width of the channel (`c->width`) and performs different actions based on its value. It uses a switch statement to handle various channel widths (e.g., 20 MHz, 40 MHz, etc.).\n   - For each case, it modifies the `conn` structure's `mode` and `bw_limit` based on the current channel width.\n\n3. **Potential Dereferencing:**\n   - The code dereferences `conn` multiple times (e.g., `conn->mode`, `conn->bw_limit`). If `conn` were to be `NULL` and the caller did not provide a valid connection settings structure, this would lead to undefined behavior (likely a segmentation fault).\n\n### Bug Report Analysis\n\nThe bug report states that `conn` may be `NULL` and should be checked before dereferencing. \n\n- **True Positive or False Positive?**\n  - The code already includes a check for `NULL` at line 3507, where it assigns `conn` to `_ignored` if it is `NULL`. This means that the dereferencing of `conn` later in the function will always be safe because it will either point to a valid `ieee80211_conn_settings` structure or to `_ignored`, which is initialized to zero.\n  \n- **Conclusion:**\n  - Since the code handles the potential `NULL` case appropriately by using a fallback mechanism, the bug report is a **false positive**. The dereferencing of `conn` is safe due to the initial check and assignment.\n\n### Final Label\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '       rb_wait_cond(rbwork, buffer, cpu, full, cond, data));'}\nValue data may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/kernel/trace/ring_buffer.c",
                                "function_body": "851 rb_wait_cond(struct rb_irq_work *rbwork, struct trace_buffer *buffer,\n852 \t     int cpu, int full, ring_buffer_cond_fn cond, void *data)\n853 {\n854 \tif (rb_watermark_hit(buffer, cpu, full))\n855 \t\treturn true;\n856\n857 \tif (cond(data))\n858 \t\treturn true;\n859\n860 \t/*\n861 \t * The events can happen in critical sections where\n862 \t * checking a work queue can cause deadlocks.\n863 \t * After adding a task to the queue, this flag is set\n864 \t * only to notify events to try to wake up the queue\n865 \t * using irq_work.\n866 \t *\n867 \t * We don't clear it even if the buffer is no longer\n868 \t * empty. The flag only causes the next event to run\n869 \t * irq_work to do the work queue wake up. The worse\n870 \t * that can happen if we race with !trace_empty() is that\n871 \t * an event will cause an irq_work to try to wake up\n872 \t * an empty queue.\n873 \t *\n874 \t * There's no reason to protect this flag either, as\n875 \t * the work queue and irq_work logic will do the necessary\n876 \t * synchronization for the wake ups. The only thing\n877 \t * that is necessary is that the wake up happens after\n878 \t * a task has been queued. It's OK for spurious wake ups.\n879 \t */\n880 \tif (full)\n881 \t\trbwork->full_waiters_pending = true;\n882 \telse\n883 \t\trbwork->waiters_pending = true;\n884\n885 \treturn false;\n886 }"
                            },
                            {
                                "file_path": "/kernel/trace/ring_buffer.c",
                                "function_body": "917 int ring_buffer_wait(struct trace_buffer *buffer, int cpu, int full,\n918 \t\t     ring_buffer_cond_fn cond, void *data)\n919 {\n920 \tstruct ring_buffer_per_cpu *cpu_buffer;\n921 \tstruct wait_queue_head *waitq;\n922 \tstruct rb_irq_work *rbwork;\n923 \tstruct rb_wait_data rdata;\n924 \tint ret = 0;\n925\n926 \t/*\n927 \t * Depending on what the caller is waiting for, either any\n928 \t * data in any cpu buffer, or a specific buffer, put the\n929 \t * caller on the appropriate wait queue.\n930 \t */\n931 \tif (cpu == RING_BUFFER_ALL_CPUS) {\n932 \t\trbwork = &buffer->irq_work;\n933 \t\t/* Full only makes sense on per cpu reads */\n934 \t\tfull = 0;\n935 \t} else {\n936 \t\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n937 \t\t\treturn -ENODEV;\n938 \t\tcpu_buffer = buffer->buffers[cpu];\n939 \t\trbwork = &cpu_buffer->irq_work;\n940 \t}\n941\n942 \tif (full)\n943 \t\twaitq = &rbwork->full_waiters;\n944 \telse\n945 \t\twaitq = &rbwork->waiters;\n946\n947 \t/* Set up to exit loop as soon as it is woken */\n948 \tif (!cond) {\n949 \t\tcond = rb_wait_once;\n950 \t\trdata.irq_work = rbwork;\n951 \t\trdata.seq = atomic_read_acquire(&rbwork->seq);\n952 \t\tdata = &rdata;\n953 \t}\n954\n955 \tret = wait_event_interruptible((*waitq),\n956 \t\t\t\trb_wait_cond(rbwork, buffer, cpu, full, cond, data));\n957\n958 \treturn ret;\n959 }"
                            },
                            {
                                "file_path": "/kernel/trace/trace.c",
                                "function_body": "2036 static int wait_on_pipe(struct trace_iterator *iter, int full)\n2037 {\n2038 \tstruct pipe_wait pwait;\n2039 \tint ret;\n2040\n2041 \t/* Iterators are static, they should be filled or empty */\n2042 \tif (trace_buffer_iter(iter, iter->cpu_file))\n2043 \t\treturn 0;\n2044\n2045 \tpwait.wait_index = atomic_read_acquire(&iter->wait_index);\n2046 \tpwait.iter = iter;\n2047\n2048 \tret = ring_buffer_wait(iter->array_buffer->buffer, iter->cpu_file, full,\n2049 \t\t\t       wait_pipe_cond, &pwait);\n2050\n2051 #ifdef CONFIG_TRACER_MAX_TRACE\n2052 \t/*\n2053 \t * Make sure this is still the snapshot buffer, as if a snapshot were\n2054 \t * to happen, this would now be the main buffer.\n2055 \t */\n2056 \tif (iter->snapshot)\n2057 \t\titer->array_buffer = &iter->tr->max_buffer;\n2058 #endif\n2059 \treturn ret;\n2060 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet consists of several functions related to a ring buffer implementation, specifically for handling wait conditions in a multi-threaded environment. \n\n1. **Function `rb_wait_cond`**:\n   - This function checks if a certain condition is met to determine whether to return `true` or `false`.\n   - It first checks if a watermark condition is hit using `rb_watermark_hit(buffer, cpu, full)`. If this condition is met, it returns `true`.\n   - Next, it evaluates a condition function `cond(data)`. If this condition returns `true`, it also returns `true`.\n   - If neither condition is satisfied, it sets flags on the `rbwork` structure to indicate that waiters are pending and returns `false`.\n\n2. **Function `ring_buffer_wait`**:\n   - This function sets up the necessary structures and calls `rb_wait_cond`.\n   - It checks if the `cond` function pointer is `NULL`. If it is, it assigns a default condition function `rb_wait_once` and prepares a `rdata` structure to pass to `rb_wait_cond`.\n   - The function then calls `wait_event_interruptible`, which waits for a condition to be met, using the result of `rb_wait_cond`.\n\n### Analysis of the Bug Report\n\nThe bug report states that the `data` parameter may be `NULL` and should be checked before dereferencing. \n\n- In the `rb_wait_cond` function, `data` is passed to the `cond` function without any prior check for `NULL`. If `data` is `NULL`, calling `cond(data)` could lead to undefined behavior, depending on how `cond` is implemented.\n- The `ring_buffer_wait` function does not explicitly check if `data` is `NULL` before passing it to `rb_wait_cond`. However, it does prepare `data` in a way that it could potentially be `NULL` if the caller does not provide a valid pointer.\n\n### Conclusion\n\nGiven that the code does not check if `data` is `NULL` before dereferencing it in the `cond(data)` call, this is indeed a potential source of a bug. The dereferencing of a `NULL` pointer can lead to crashes or undefined behavior, making this a valid concern.\n\nThus, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    }
]