[
    {
        "result": [
            {
                "bug_report": "{'text': '        nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);'}\nValue buf.bn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/bn/bn_nist.c",
                                "function_body": "476 #define nist_set_224(to, from, a1, a2, a3, a4, a5, a6, a7) \\\n477         { \\\n478         bn_cp_32(to, 0, from, (a7) - 7) \\\n479         bn_cp_32(to, 1, from, (a6) - 7) \\\n480         bn_cp_32(to, 2, from, (a5) - 7) \\\n481         bn_cp_32(to, 3, from, (a4) - 7) \\\n482         bn_cp_32(to, 4, from, (a3) - 7) \\\n483         bn_cp_32(to, 5, from, (a2) - 7) \\\n484         bn_cp_32(to, 6, from, (a1) - 7) \\\n485         }"
                            },
                            {
                                "file_path": "/crypto/bn/bn_nist.c",
                                "function_body": "487 int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\n488                     BN_CTX *ctx)\n489 {\n490     int top = a->top, i;\n491     int carry;\n492     BN_ULONG *r_d, *a_d = a->d;\n493     union {\n494         BN_ULONG bn[BN_NIST_224_TOP];\n495         unsigned int ui[BN_NIST_224_TOP * sizeof(BN_ULONG) /\n496                         sizeof(unsigned int)];\n497     } buf;\n498     BN_ULONG c_d[BN_NIST_224_TOP], *res;\n499     bn_addsub_f adjust;\n500     static const BIGNUM ossl_bignum_nist_p_224_sqr = {\n501         (BN_ULONG *)_nist_p_224_sqr,\n502         OSSL_NELEM(_nist_p_224_sqr),\n503         OSSL_NELEM(_nist_p_224_sqr),\n504         0, BN_FLG_STATIC_DATA\n505     };\n506\n507     field = &ossl_bignum_nist_p_224; /* just to make sure */\n508\n509     if (BN_is_negative(a) || BN_ucmp(a, &ossl_bignum_nist_p_224_sqr) >= 0)\n510         return BN_nnmod(r, a, field, ctx);\n511\n512     i = BN_ucmp(field, a);\n513     if (i == 0) {\n514         BN_zero(r);\n515         return 1;\n516     } else if (i > 0)\n517         return (r == a) ? 1 : (BN_copy(r, a) != NULL);\n518\n519     if (r != a) {\n520         if (!bn_wexpand(r, BN_NIST_224_TOP))\n521             return 0;\n522         r_d = r->d;\n523         nist_cp_bn(r_d, a_d, BN_NIST_224_TOP);\n524     } else\n525         r_d = a_d;\n526\n527 #if BN_BITS2==64\n528     /* copy upper 256 bits of 448 bit number ... */\n529     nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP - 1),\n530                  top - (BN_NIST_224_TOP - 1), BN_NIST_224_TOP);\n531     /* ... and right shift by 32 to obtain upper 224 bits */\n532     nist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);\n533     /* truncate lower part to 224 bits too */\n534     r_d[BN_NIST_224_TOP - 1] &= BN_MASK2l;\n535 #else\n536     nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP,\n537                  BN_NIST_224_TOP);\n538 #endif\n539\n540 #if defined(NIST_INT64) && BN_BITS2!=64\n541     {\n542         NIST_INT64 acc;         /* accumulator */\n543         unsigned int *rp = (unsigned int *)r_d;\n544         const unsigned int *bp = (const unsigned int *)buf.ui;\n545\n546         acc = rp[0];\n547         acc -= bp[7 - 7];\n548         acc -= bp[11 - 7];\n549         rp[0] = (unsigned int)acc;\n550         acc >>= 32;\n551\n552         acc += rp[1];\n553         acc -= bp[8 - 7];\n554         acc -= bp[12 - 7];\n555         rp[1] = (unsigned int)acc;\n556         acc >>= 32;\n557\n558         acc += rp[2];\n559         acc -= bp[9 - 7];\n560         acc -= bp[13 - 7];\n561         rp[2] = (unsigned int)acc;\n562         acc >>= 32;\n563\n564         acc += rp[3];\n565         acc += bp[7 - 7];\n566         acc += bp[11 - 7];\n567         acc -= bp[10 - 7];\n568         rp[3] = (unsigned int)acc;\n569         acc >>= 32;\n570\n571         acc += rp[4];\n572         acc += bp[8 - 7];\n573         acc += bp[12 - 7];\n574         acc -= bp[11 - 7];\n575         rp[4] = (unsigned int)acc;\n576         acc >>= 32;\n577\n578         acc += rp[5];\n579         acc += bp[9 - 7];\n580         acc += bp[13 - 7];\n581         acc -= bp[12 - 7];\n582         rp[5] = (unsigned int)acc;\n583         acc >>= 32;\n584\n585         acc += rp[6];\n586         acc += bp[10 - 7];\n587         acc -= bp[13 - 7];\n588         rp[6] = (unsigned int)acc;\n589\n590         carry = (int)(acc >> 32);\n591 # if BN_BITS2==64\n592         rp[7] = carry;\n593 # endif\n594     }\n595 #else\n596     {\n597         BN_ULONG t_d[BN_NIST_224_TOP];\n598\n599         nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);\n600         carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n601         nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);\n602         carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n603         nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);\n604         carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n605         nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);\n606         carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n607\n608 # if BN_BITS2==64\n609         carry = (int)(r_d[BN_NIST_224_TOP - 1] >> 32);\n610 # endif\n611     }\n612 #endif\n613     adjust = bn_sub_words;\n614     if (carry > 0) {\n615         carry =\n616             (int)bn_sub_words(r_d, r_d, _nist_p_224[carry - 1],\n617                               BN_NIST_224_TOP);\n618 #if BN_BITS2==64\n619         carry = (int)(~(r_d[BN_NIST_224_TOP - 1] >> 32)) & 1;\n620 #endif\n621     } else if (carry < 0) {\n622         /*\n623          * it's a bit more complicated logic in this case. if bn_add_words\n624          * yields no carry, then result has to be adjusted by unconditionally\n625          * *adding* the modulus. but if it does, then result has to be\n626          * compared to the modulus and conditionally adjusted by\n627          * *subtracting* the latter.\n628          */\n629         carry =\n630             (int)bn_add_words(r_d, r_d, _nist_p_224[-carry - 1],\n631                               BN_NIST_224_TOP);\n632         adjust = carry ? bn_sub_words : bn_add_words;\n633     } else\n634         carry = 1;\n635\n636     /* otherwise it's effectively same as in BN_nist_mod_192... */\n637     res = ((*adjust) (c_d, r_d, _nist_p_224[0], BN_NIST_224_TOP) && carry)\n638         ? r_d\n639         : c_d;\n640     nist_cp_bn(r_d, res, BN_NIST_224_TOP);\n641     r->top = BN_NIST_224_TOP;\n642     bn_correct_top(r);\n643\n644     return 1;\n645 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function `BN_nist_mod_224`, which appears to be implementing a modular reduction operation for a specific elliptic curve (NIST P-224). The function takes three parameters: `r`, `a`, and `field`, which are pointers to `BIGNUM` structures, and a `BN_CTX` context.\n\n1. **Buffer Declaration**: The code defines a union `buf` that contains an array `bn` of `BN_ULONG` type, which is used to hold intermediate values during calculations.\n\n2. **Function Logic**:\n   - The function first checks if the input `a` is negative or greater than a certain threshold (`ossl_bignum_nist_p_224_sqr`). If so, it calls `BN_nnmod` to perform a modular operation.\n   - It then compares `a` with `field` and handles cases where they are equal or where `a` is less than `field`.\n   - If `r` is not the same as `a`, it ensures that `r` has enough space allocated and copies the necessary data.\n   - The function then performs a series of operations involving the `nist_set_224` macro, which is defined to copy values from one buffer to another.\n\n3. **Potential Null Dereference**: The bug report specifically points out that `buf.bn` may be null and should be checked before dereferencing. However, `buf.bn` is an array defined within a union and is not explicitly initialized to null. The concern arises from the fact that if `buf` is not properly set up before being used, dereferencing `buf.bn` could lead to undefined behavior.\n\n### Bug Report Analysis\n\nThe bug report states that `buf.bn` may be null and should be checked before dereferencing. However, in the context of the code:\n\n- `buf.bn` is an array of `BN_ULONG`, which is a type that typically represents an unsigned long integer. Arrays in C/C++ are not null by default; they occupy a block of memory.\n- The concern about `buf.bn` being null is somewhat misplaced because it is not a pointer but an array. The real issue would be if the `buf` union was not properly initialized or if the data being copied into `buf.bn` was invalid.\n\n### Conclusion\n\nGiven the nature of the code and the definition of `buf.bn`, the bug report seems to be a misunderstanding of how arrays work in C/C++. The dereference of `buf.bn` itself is not inherently unsafe unless the data being copied into it is invalid or if the union is not properly initialized. Therefore, the bug report does not accurately reflect a true bug in the code.\n\nThus, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '        nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);'}\nValue buf.bn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/bn/bn_nist.c",
                                "function_body": "476 #define nist_set_224(to, from, a1, a2, a3, a4, a5, a6, a7) \\\n477         { \\\n478         bn_cp_32(to, 0, from, (a7) - 7) \\\n479         bn_cp_32(to, 1, from, (a6) - 7) \\\n480         bn_cp_32(to, 2, from, (a5) - 7) \\\n481         bn_cp_32(to, 3, from, (a4) - 7) \\\n482         bn_cp_32(to, 4, from, (a3) - 7) \\\n483         bn_cp_32(to, 5, from, (a2) - 7) \\\n484         bn_cp_32(to, 6, from, (a1) - 7) \\\n485         }"
                            },
                            {
                                "file_path": "/crypto/bn/bn_nist.c",
                                "function_body": "487 int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\n488                     BN_CTX *ctx)\n489 {\n490     int top = a->top, i;\n491     int carry;\n492     BN_ULONG *r_d, *a_d = a->d;\n493     union {\n494         BN_ULONG bn[BN_NIST_224_TOP];\n495         unsigned int ui[BN_NIST_224_TOP * sizeof(BN_ULONG) /\n496                         sizeof(unsigned int)];\n497     } buf;\n498     BN_ULONG c_d[BN_NIST_224_TOP], *res;\n499     bn_addsub_f adjust;\n500     static const BIGNUM ossl_bignum_nist_p_224_sqr = {\n501         (BN_ULONG *)_nist_p_224_sqr,\n502         OSSL_NELEM(_nist_p_224_sqr),\n503         OSSL_NELEM(_nist_p_224_sqr),\n504         0, BN_FLG_STATIC_DATA\n505     };\n506\n507     field = &ossl_bignum_nist_p_224; /* just to make sure */\n508\n509     if (BN_is_negative(a) || BN_ucmp(a, &ossl_bignum_nist_p_224_sqr) >= 0)\n510         return BN_nnmod(r, a, field, ctx);\n511\n512     i = BN_ucmp(field, a);\n513     if (i == 0) {\n514         BN_zero(r);\n515         return 1;\n516     } else if (i > 0)\n517         return (r == a) ? 1 : (BN_copy(r, a) != NULL);\n518\n519     if (r != a) {\n520         if (!bn_wexpand(r, BN_NIST_224_TOP))\n521             return 0;\n522         r_d = r->d;\n523         nist_cp_bn(r_d, a_d, BN_NIST_224_TOP);\n524     } else\n525         r_d = a_d;\n526\n527 #if BN_BITS2==64\n528     /* copy upper 256 bits of 448 bit number ... */\n529     nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP - 1),\n530                  top - (BN_NIST_224_TOP - 1), BN_NIST_224_TOP);\n531     /* ... and right shift by 32 to obtain upper 224 bits */\n532     nist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);\n533     /* truncate lower part to 224 bits too */\n534     r_d[BN_NIST_224_TOP - 1] &= BN_MASK2l;\n535 #else\n536     nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP,\n537                  BN_NIST_224_TOP);\n538 #endif\n539\n540 #if defined(NIST_INT64) && BN_BITS2!=64\n541     {\n542         NIST_INT64 acc;         /* accumulator */\n543         unsigned int *rp = (unsigned int *)r_d;\n544         const unsigned int *bp = (const unsigned int *)buf.ui;\n545\n546         acc = rp[0];\n547         acc -= bp[7 - 7];\n548         acc -= bp[11 - 7];\n549         rp[0] = (unsigned int)acc;\n550         acc >>= 32;\n551\n552         acc += rp[1];\n553         acc -= bp[8 - 7];\n554         acc -= bp[12 - 7];\n555         rp[1] = (unsigned int)acc;\n556         acc >>= 32;\n557\n558         acc += rp[2];\n559         acc -= bp[9 - 7];\n560         acc -= bp[13 - 7];\n561         rp[2] = (unsigned int)acc;\n562         acc >>= 32;\n563\n564         acc += rp[3];\n565         acc += bp[7 - 7];\n566         acc += bp[11 - 7];\n567         acc -= bp[10 - 7];\n568         rp[3] = (unsigned int)acc;\n569         acc >>= 32;\n570\n571         acc += rp[4];\n572         acc += bp[8 - 7];\n573         acc += bp[12 - 7];\n574         acc -= bp[11 - 7];\n575         rp[4] = (unsigned int)acc;\n576         acc >>= 32;\n577\n578         acc += rp[5];\n579         acc += bp[9 - 7];\n580         acc += bp[13 - 7];\n581         acc -= bp[12 - 7];\n582         rp[5] = (unsigned int)acc;\n583         acc >>= 32;\n584\n585         acc += rp[6];\n586         acc += bp[10 - 7];\n587         acc -= bp[13 - 7];\n588         rp[6] = (unsigned int)acc;\n589\n590         carry = (int)(acc >> 32);\n591 # if BN_BITS2==64\n592         rp[7] = carry;\n593 # endif\n594     }\n595 #else\n596     {\n597         BN_ULONG t_d[BN_NIST_224_TOP];\n598\n599         nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);\n600         carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n601         nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);\n602         carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n603         nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);\n604         carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n605         nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);\n606         carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n607\n608 # if BN_BITS2==64\n609         carry = (int)(r_d[BN_NIST_224_TOP - 1] >> 32);\n610 # endif\n611     }\n612 #endif\n613     adjust = bn_sub_words;\n614     if (carry > 0) {\n615         carry =\n616             (int)bn_sub_words(r_d, r_d, _nist_p_224[carry - 1],\n617                               BN_NIST_224_TOP);\n618 #if BN_BITS2==64\n619         carry = (int)(~(r_d[BN_NIST_224_TOP - 1] >> 32)) & 1;\n620 #endif\n621     } else if (carry < 0) {\n622         /*\n623          * it's a bit more complicated logic in this case. if bn_add_words\n624          * yields no carry, then result has to be adjusted by unconditionally\n625          * *adding* the modulus. but if it does, then result has to be\n626          * compared to the modulus and conditionally adjusted by\n627          * *subtracting* the latter.\n628          */\n629         carry =\n630             (int)bn_add_words(r_d, r_d, _nist_p_224[-carry - 1],\n631                               BN_NIST_224_TOP);\n632         adjust = carry ? bn_sub_words : bn_add_words;\n633     } else\n634         carry = 1;\n635\n636     /* otherwise it's effectively same as in BN_nist_mod_192... */\n637     res = ((*adjust) (c_d, r_d, _nist_p_224[0], BN_NIST_224_TOP) && carry)\n638         ? r_d\n639         : c_d;\n640     nist_cp_bn(r_d, res, BN_NIST_224_TOP);\n641     r->top = BN_NIST_224_TOP;\n642     bn_correct_top(r);\n643\n644     return 1;\n645 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a cryptographic library, specifically dealing with operations on big numbers (BIGNUM) in the context of NIST P-224 elliptic curve cryptography. The function `BN_nist_mod_224` performs modular reduction of a BIGNUM `a` with respect to a predefined field, and it uses a buffer `buf` to hold intermediate results.\n\nThe relevant part of the code for the bug report is the use of `buf.bn`, which is defined as part of a union that contains an array of `BN_ULONG`. The function `nist_set_224` is called multiple times, including the line mentioned in the bug report:\n\n```c\nnist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);\n```\n\nThe bug report indicates that `buf.bn` may be null and should be checked before dereferencing. However, `buf.bn` is an array defined within a union, which means it is allocated on the stack and cannot be null. The union `buf` is declared as follows:\n\n```c\nunion {\n    BN_ULONG bn[BN_NIST_224_TOP];\n    unsigned int ui[BN_NIST_224_TOP * sizeof(BN_ULONG) / sizeof(unsigned int)];\n} buf;\n```\n\nSince `buf` is a local variable, `buf.bn` will always point to a valid memory location as long as `buf` itself is in scope. The only way `buf.bn` could be considered \"null\" is if `buf` were not properly initialized, but in this context, it is always initialized when `buf` is declared.\n\n### Conclusion on the Bug Report\n\nGiven that `buf.bn` is part of a union that is allocated on the stack and cannot be null, the bug report's assertion that `buf.bn` may be null is incorrect. Therefore, the dereferencing of `buf.bn` in the function `nist_set_224` is safe and does not require a null check.\n\nThus, the conclusion is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '        nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);'}\nValue buf.bn may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/bn/bn_nist.c",
                                "function_body": "476 #define nist_set_224(to, from, a1, a2, a3, a4, a5, a6, a7) \\\n477         { \\\n478         bn_cp_32(to, 0, from, (a7) - 7) \\\n479         bn_cp_32(to, 1, from, (a6) - 7) \\\n480         bn_cp_32(to, 2, from, (a5) - 7) \\\n481         bn_cp_32(to, 3, from, (a4) - 7) \\\n482         bn_cp_32(to, 4, from, (a3) - 7) \\\n483         bn_cp_32(to, 5, from, (a2) - 7) \\\n484         bn_cp_32(to, 6, from, (a1) - 7) \\\n485         }"
                            },
                            {
                                "file_path": "/crypto/bn/bn_nist.c",
                                "function_body": "487 int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *field,\n488                     BN_CTX *ctx)\n489 {\n490     int top = a->top, i;\n491     int carry;\n492     BN_ULONG *r_d, *a_d = a->d;\n493     union {\n494         BN_ULONG bn[BN_NIST_224_TOP];\n495         unsigned int ui[BN_NIST_224_TOP * sizeof(BN_ULONG) /\n496                         sizeof(unsigned int)];\n497     } buf;\n498     BN_ULONG c_d[BN_NIST_224_TOP], *res;\n499     bn_addsub_f adjust;\n500     static const BIGNUM ossl_bignum_nist_p_224_sqr = {\n501         (BN_ULONG *)_nist_p_224_sqr,\n502         OSSL_NELEM(_nist_p_224_sqr),\n503         OSSL_NELEM(_nist_p_224_sqr),\n504         0, BN_FLG_STATIC_DATA\n505     };\n506\n507     field = &ossl_bignum_nist_p_224; /* just to make sure */\n508\n509     if (BN_is_negative(a) || BN_ucmp(a, &ossl_bignum_nist_p_224_sqr) >= 0)\n510         return BN_nnmod(r, a, field, ctx);\n511\n512     i = BN_ucmp(field, a);\n513     if (i == 0) {\n514         BN_zero(r);\n515         return 1;\n516     } else if (i > 0)\n517         return (r == a) ? 1 : (BN_copy(r, a) != NULL);\n518\n519     if (r != a) {\n520         if (!bn_wexpand(r, BN_NIST_224_TOP))\n521             return 0;\n522         r_d = r->d;\n523         nist_cp_bn(r_d, a_d, BN_NIST_224_TOP);\n524     } else\n525         r_d = a_d;\n526\n527 #if BN_BITS2==64\n528     /* copy upper 256 bits of 448 bit number ... */\n529     nist_cp_bn_0(c_d, a_d + (BN_NIST_224_TOP - 1),\n530                  top - (BN_NIST_224_TOP - 1), BN_NIST_224_TOP);\n531     /* ... and right shift by 32 to obtain upper 224 bits */\n532     nist_set_224(buf.bn, c_d, 14, 13, 12, 11, 10, 9, 8);\n533     /* truncate lower part to 224 bits too */\n534     r_d[BN_NIST_224_TOP - 1] &= BN_MASK2l;\n535 #else\n536     nist_cp_bn_0(buf.bn, a_d + BN_NIST_224_TOP, top - BN_NIST_224_TOP,\n537                  BN_NIST_224_TOP);\n538 #endif\n539\n540 #if defined(NIST_INT64) && BN_BITS2!=64\n541     {\n542         NIST_INT64 acc;         /* accumulator */\n543         unsigned int *rp = (unsigned int *)r_d;\n544         const unsigned int *bp = (const unsigned int *)buf.ui;\n545\n546         acc = rp[0];\n547         acc -= bp[7 - 7];\n548         acc -= bp[11 - 7];\n549         rp[0] = (unsigned int)acc;\n550         acc >>= 32;\n551\n552         acc += rp[1];\n553         acc -= bp[8 - 7];\n554         acc -= bp[12 - 7];\n555         rp[1] = (unsigned int)acc;\n556         acc >>= 32;\n557\n558         acc += rp[2];\n559         acc -= bp[9 - 7];\n560         acc -= bp[13 - 7];\n561         rp[2] = (unsigned int)acc;\n562         acc >>= 32;\n563\n564         acc += rp[3];\n565         acc += bp[7 - 7];\n566         acc += bp[11 - 7];\n567         acc -= bp[10 - 7];\n568         rp[3] = (unsigned int)acc;\n569         acc >>= 32;\n570\n571         acc += rp[4];\n572         acc += bp[8 - 7];\n573         acc += bp[12 - 7];\n574         acc -= bp[11 - 7];\n575         rp[4] = (unsigned int)acc;\n576         acc >>= 32;\n577\n578         acc += rp[5];\n579         acc += bp[9 - 7];\n580         acc += bp[13 - 7];\n581         acc -= bp[12 - 7];\n582         rp[5] = (unsigned int)acc;\n583         acc >>= 32;\n584\n585         acc += rp[6];\n586         acc += bp[10 - 7];\n587         acc -= bp[13 - 7];\n588         rp[6] = (unsigned int)acc;\n589\n590         carry = (int)(acc >> 32);\n591 # if BN_BITS2==64\n592         rp[7] = carry;\n593 # endif\n594     }\n595 #else\n596     {\n597         BN_ULONG t_d[BN_NIST_224_TOP];\n598\n599         nist_set_224(t_d, buf.bn, 10, 9, 8, 7, 0, 0, 0);\n600         carry = (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n601         nist_set_224(t_d, buf.bn, 0, 13, 12, 11, 0, 0, 0);\n602         carry += (int)bn_add_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n603         nist_set_224(t_d, buf.bn, 13, 12, 11, 10, 9, 8, 7);\n604         carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n605         nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);\n606         carry -= (int)bn_sub_words(r_d, r_d, t_d, BN_NIST_224_TOP);\n607\n608 # if BN_BITS2==64\n609         carry = (int)(r_d[BN_NIST_224_TOP - 1] >> 32);\n610 # endif\n611     }\n612 #endif\n613     adjust = bn_sub_words;\n614     if (carry > 0) {\n615         carry =\n616             (int)bn_sub_words(r_d, r_d, _nist_p_224[carry - 1],\n617                               BN_NIST_224_TOP);\n618 #if BN_BITS2==64\n619         carry = (int)(~(r_d[BN_NIST_224_TOP - 1] >> 32)) & 1;\n620 #endif\n621     } else if (carry < 0) {\n622         /*\n623          * it's a bit more complicated logic in this case. if bn_add_words\n624          * yields no carry, then result has to be adjusted by unconditionally\n625          * *adding* the modulus. but if it does, then result has to be\n626          * compared to the modulus and conditionally adjusted by\n627          * *subtracting* the latter.\n628          */\n629         carry =\n630             (int)bn_add_words(r_d, r_d, _nist_p_224[-carry - 1],\n631                               BN_NIST_224_TOP);\n632         adjust = carry ? bn_sub_words : bn_add_words;\n633     } else\n634         carry = 1;\n635\n636     /* otherwise it's effectively same as in BN_nist_mod_192... */\n637     res = ((*adjust) (c_d, r_d, _nist_p_224[0], BN_NIST_224_TOP) && carry)\n638         ? r_d\n639         : c_d;\n640     nist_cp_bn(r_d, res, BN_NIST_224_TOP);\n641     r->top = BN_NIST_224_TOP;\n642     bn_correct_top(r);\n643\n644     return 1;\n645 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet is part of a cryptographic library, specifically dealing with operations related to the NIST P-224 elliptic curve. The function `BN_nist_mod_224` performs modular arithmetic on a BIGNUM structure, which is a representation of large integers used in cryptographic computations.\n\n1. **Function Definition**: The function `BN_nist_mod_224` takes three parameters: a pointer to a result BIGNUM (`r`), a pointer to an input BIGNUM (`a`), and a pointer to a field BIGNUM (`field`), along with a context (`ctx`).\n\n2. **Variable Initialization**: The function initializes several variables, including pointers to the data of the BIGNUMs (`r_d`, `a_d`), and a buffer (`buf`) that can hold multiple BIGNUM values.\n\n3. **Input Validation**: The function checks if the input BIGNUM `a` is negative or greater than a predefined constant (`ossl_bignum_nist_p_224_sqr`). If so, it calls `BN_nnmod` to handle the modular reduction.\n\n4. **Buffer Usage**: The buffer `buf` is used to store intermediate results. The specific line in question is:\n   ```c\n   nist_set_224(t_d, buf.bn, 0, 0, 0, 0, 13, 12, 11);\n   ```\n   Here, `buf.bn` is being passed to the `nist_set_224` function. The concern raised in the bug report is that `buf.bn` may be null, which would lead to dereferencing a null pointer.\n\n5. **Potential Null Dereference**: The code does not explicitly check if `buf.bn` is null before it is used in the `nist_set_224` function. If `buf.bn` is indeed null, this would result in undefined behavior, typically leading to a crash or memory access violation.\n\n### Bug Report Evaluation\n\nThe bug report states that `buf.bn` may be null and should be checked before dereferencing. Given the explanation of the code behavior, it is clear that:\n\n- The code does not perform a null check on `buf.bn` before it is passed to `nist_set_224`.\n- If `buf.bn` is null, dereferencing it will lead to a runtime error.\n\n### Conclusion\n\nBased on the analysis, the bug report correctly identifies a potential issue in the code where `buf.bn` could be null, leading to a dereference of a null pointer. Therefore, this is a legitimate concern that should be addressed in the code.\n\nThus, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |'}\nValue p.p.X may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "403 #define X  1          + 1"
                            },
                            {
                                "file_path": "/ssl/quic/quic_wire.c",
                                "function_body": "1056 #define X(name) case OSSL_QUIC_ERR_##name: return #name;"
                            },
                            {
                                "file_path": "/ssl/quic/quic_wire.c",
                                "function_body": "1015 #define X(name) case OSSL_QUIC_FRAME_TYPE_##name: return #name;"
                            },
                            {
                                "file_path": "/crypto/sha/sha_local.h",
                                "function_body": "133 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/sha/sha_local.h",
                                "function_body": "126 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/ripemd/rmd_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/ripemd/rmd_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/md5/md5_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/md5/md5_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/md4/md4_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/md4/md4_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "82 #define X(I) (&((char *)point_array)[3*(I) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication using precomputed values. The relevant section of the code involves checking if certain points are at infinity and manipulating their coordinates.\n\n1. **Data Structures**: The code uses structures like `P256_POINT` and `EC_POINT`, which likely represent points on an elliptic curve. The `p.p` structure contains fields `X`, `Y`, and `Z`, which are arrays or pointers to hold the coordinates of the point.\n\n2. **Infinity Check**: The code checks if the point is at infinity by examining the `X` and `Y` coordinates. Specifically, it computes a value `infty` by performing bitwise OR operations on the first four elements of `p.p.X` and `p.p.Y`, and if `P256_LIMBS` is 8, it also checks the next four elements.\n\n3. **Dereferencing**: The bug report indicates that `p.p.X` may be null, which means that if `p.p` is not properly initialized or if it points to a null value, dereferencing `p.p.X` could lead to undefined behavior, such as a segmentation fault.\n\n### Bug Report Analysis\n\nThe bug report states that `p.p.X` may be null and should be checked before dereferencing. Given the explanation of the code's behavior:\n\n- **True Positive**: The bug report is a true positive because if `p.p` is null or if `p.p.X` is null, dereferencing it (as done in lines 1064-1068) will lead to undefined behavior. The code does not currently check if `p.p` or `p.p.X` is null before attempting to access its elements.\n\n### Conclusion\n\nSince the code does not perform a null check on `p.p` or `p.p.X` before dereferencing, this can lead to runtime errors if those pointers are null. Therefore, the bug report is valid.\n\nLabel: **@@@ real bug @@@**",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |'}\nValue p.p.X may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "403 #define X  1          + 1"
                            },
                            {
                                "file_path": "/ssl/quic/quic_wire.c",
                                "function_body": "1056 #define X(name) case OSSL_QUIC_ERR_##name: return #name;"
                            },
                            {
                                "file_path": "/ssl/quic/quic_wire.c",
                                "function_body": "1015 #define X(name) case OSSL_QUIC_FRAME_TYPE_##name: return #name;"
                            },
                            {
                                "file_path": "/crypto/sha/sha_local.h",
                                "function_body": "133 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/sha/sha_local.h",
                                "function_body": "126 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/ripemd/rmd_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/ripemd/rmd_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/md5/md5_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/md5/md5_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/md4/md4_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/md4/md4_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "82 #define X(I) (&((char *)point_array)[3*(I) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet is part of a function that performs elliptic curve point multiplication using precomputed values. The specific lines of interest in the bug report involve dereferencing the `p.p.X` and `p.p.Y` arrays, which are likely part of a structure representing a point on the elliptic curve.\n\n### Code Behavior Explanation\n\n1. **Structure and Context**: The code appears to be dealing with elliptic curve cryptography, specifically using a point represented in Jacobian coordinates. The `p` variable is likely an instance of a structure that contains the coordinates of a point on the elliptic curve, where `p.p.X`, `p.p.Y`, and `p.p.Z` are arrays representing the X, Y, and Z coordinates, respectively.\n\n2. **Dereferencing**: The lines in question:\n   ```c\n   infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n             p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n   ```\n   Here, the code is performing a bitwise OR operation on the elements of the `p.p.X` and `p.p.Y` arrays. This operation is used to determine if the point is at infinity (i.e., if all coordinates are zero).\n\n3. **Potential Null Dereference**: The bug report indicates that `p.p.X` may be null, which would lead to undefined behavior if dereferenced. If `p.p` is a pointer to a structure that has not been properly initialized or allocated, accessing `p.p.X` or `p.p.Y` could indeed cause a segmentation fault or crash.\n\n4. **Contextual Checks**: The code does not show any checks to ensure that `p.p` is valid (i.e., not null) before dereferencing its members. This is a critical oversight, especially in C/C++ where pointers can be null, leading to potential runtime errors.\n\n### Bug Analysis\n\nGiven the explanation above, the bug report is valid. The code does not check if `p.p` is null before attempting to access its members, which can lead to dereferencing a null pointer. This is a common source of bugs in C/C++ programming.\n\n### Conclusion\n\nBased on the analysis, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |'}\nValue p.p.X may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "403 #define X  1          + 1"
                            },
                            {
                                "file_path": "/ssl/quic/quic_wire.c",
                                "function_body": "1056 #define X(name) case OSSL_QUIC_ERR_##name: return #name;"
                            },
                            {
                                "file_path": "/ssl/quic/quic_wire.c",
                                "function_body": "1015 #define X(name) case OSSL_QUIC_FRAME_TYPE_##name: return #name;"
                            },
                            {
                                "file_path": "/crypto/sha/sha_local.h",
                                "function_body": "133 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/sha/sha_local.h",
                                "function_body": "126 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/ripemd/rmd_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/ripemd/rmd_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/md5/md5_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/md5/md5_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/md4/md4_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/md4/md4_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "82 #define X(I) (&((char *)point_array)[3*(I) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet is part of a function that performs elliptic curve point multiplication using precomputed values. The specific lines of interest in the bug report are those that access the `p.p.X` and `p.p.Y` arrays, which are likely part of a structure representing a point on the elliptic curve.\n\n### Explanation of the Code Behavior\n\n1. **Data Structures**: The code uses a structure `P256_POINT` (not fully defined in the snippet) that likely contains arrays `X`, `Y`, and `Z`, which represent the coordinates of a point in projective space. The arrays are accessed using indices, which suggests they are expected to be of a fixed size.\n\n2. **Infinity Check**: The code checks if the point is at infinity by examining the values in `p.p.X` and `p.p.Y`. Specifically, it computes a value `infty` based on the logical OR of the first four elements of `p.p.X` and `p.p.Y`, and if `P256_LIMBS` equals 8, it also checks the next four elements.\n\n3. **Potential Null Dereference**: The bug report indicates that `p.p.X` may be null, which would lead to undefined behavior when dereferencing it. If `p.p` is not properly initialized or if it is set to null before this point in the code, accessing `p.p.X` or `p.p.Y` would indeed cause a crash or other unintended behavior.\n\n### Bug Report Analysis\n\nThe bug report states that `p.p.X` may be null and should be checked before dereferencing. Given the context of the code:\n\n- If `p.p` is not initialized or if it is set to null before this function is called, then dereferencing `p.p.X` and `p.p.Y` will lead to a null pointer dereference, which is a real bug.\n- However, if the code guarantees that `p.p` is always initialized properly before this point (which should be ensured by the logic of the function), then the bug report could be considered a false alarm.\n\n### Conclusion\n\nWithout additional context about how `p.p` is initialized and used throughout the code, it is difficult to definitively label the bug report. However, given that the report raises a valid concern about potential null dereferencing, and considering the critical nature of pointer dereferencing in C/C++, it is prudent to treat this as a potential issue.\n\nThus, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |'}\nValue p.p.X may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "403 #define X  1          + 1"
                            },
                            {
                                "file_path": "/ssl/quic/quic_wire.c",
                                "function_body": "1056 #define X(name) case OSSL_QUIC_ERR_##name: return #name;"
                            },
                            {
                                "file_path": "/ssl/quic/quic_wire.c",
                                "function_body": "1015 #define X(name) case OSSL_QUIC_FRAME_TYPE_##name: return #name;"
                            },
                            {
                                "file_path": "/crypto/sha/sha_local.h",
                                "function_body": "133 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/sha/sha_local.h",
                                "function_body": "126 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/ripemd/rmd_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/ripemd/rmd_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/md5/md5_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/md5/md5_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/md4/md4_dgst.c",
                                "function_body": "54 #  define X(i)   XX[i]"
                            },
                            {
                                "file_path": "/crypto/md4/md4_dgst.c",
                                "function_body": "51 #  define X(i)   XX##i"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "82 #define X(I) (&((char *)point_array)[3*(I) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet is part of a function that performs elliptic curve point multiplication using precomputed values. The specific lines of interest in the bug report involve dereferencing the `p.p.X` and `p.p.Y` arrays, which are likely part of a structure representing a point on the elliptic curve.\n\n### Explanation of the Code Behavior\n\n1. **Context**: The function `ecp_nistz256_points_mul` is designed to multiply a point on an elliptic curve by a scalar. It uses precomputed values for efficiency.\n\n2. **Point Representation**: The variable `p` is a union that contains two representations of a point: `P256_POINT` and `P256_POINT_AFFINE`. The `p.p` likely refers to the projective coordinates of the point.\n\n3. **Infinity Check**: The code checks if the point is at infinity (which is a special case in elliptic curve arithmetic). The infinity condition is determined by checking if the coordinates are zero.\n\n4. **Dereferencing**: The lines in question:\n   ```c\n   infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n   ```\n   Here, the code dereferences `p.p.X` and `p.p.Y` arrays to check their values. If `p.p` is not properly initialized or if it points to a null value, dereferencing it would lead to undefined behavior, potentially causing a crash or memory access violation.\n\n5. **Potential Null Pointer**: The bug report indicates that `p.p.X` may be null, which means that before dereferencing these pointers, there should be a check to ensure they are valid (not null).\n\n### Bug Analysis\n\nGiven the explanation above, the bug report correctly identifies a potential issue in the code. If `p.p` is not initialized or if it points to an invalid memory location, dereferencing `p.p.X` or `p.p.Y` will lead to undefined behavior. Therefore, the absence of a null check before dereferencing these pointers is indeed a bug.\n\n### Conclusion\n\nBased on the analysis, the bug report is valid. The code should include checks to ensure that `p.p.X` and `p.p.Y` are not null before dereferencing them.\n\nLabel: `@@@ real bug @@@`",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);'}\nValue p.p.Y may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "404 #define Y  /* .. */ 2 + 2"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "83 #define Y(I) (&((char *)point_array)[(3*(I) + 1) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication using the NIST P-256 curve. The relevant section of the code is concerned with determining whether a point is at infinity (the identity element in elliptic curve cryptography) and involves manipulating the coordinates of points represented in a specific format.\n\n1. **Point Representation**: The points are represented in a structure `P256_POINT`, which contains arrays `X`, `Y`, and `Z` that hold the coordinates of the point.\n\n2. **Infinity Check**: The code checks if the point is at infinity by evaluating the coordinates:\n   - The variable `infty` is computed using bitwise OR operations on the `X` and `Y` coordinates of the point `p.p`. Specifically, it checks the first four limbs of both `X` and `Y` arrays.\n   - If the number of limbs (`P256_LIMBS`) is 8, it also checks the next four limbs.\n\n3. **Dereferencing Potential Null Pointers**: The bug report indicates that `p.p.Y` may be null, which would lead to dereferencing a null pointer when accessing `p.p.Y[4]`, `p.p.Y[5]`, `p.p.Y[6]`, and `p.p.Y[7]`. If `p.p` is not properly initialized or if `Y` is not allocated, this would indeed cause a runtime error.\n\n### Bug Report Evaluation\n\nThe bug report states that `p.p.Y` may be null and should be checked before dereferencing. Given the explanation of the code behavior:\n\n- **True Positive**: The code does not perform any checks to ensure that `p.p.Y` is not null before accessing its elements. If `p.p.Y` is null, dereferencing it will lead to undefined behavior, which is a legitimate bug.\n\n### Conclusion\n\nBased on the analysis, the bug report correctly identifies a potential issue in the code. Therefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);'}\nValue p.p.Y may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "404 #define Y  /* .. */ 2 + 2"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "83 #define Y(I) (&((char *)point_array)[(3*(I) + 1) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication using the NIST P-256 curve. The relevant section of the code involves handling points in affine and Jacobian coordinates, particularly focusing on the `p.p` structure, which likely represents a point on the elliptic curve.\n\n1. **Point Representation**: The `p.p` structure contains coordinates `X`, `Y`, and `Z`. The `Z` coordinate is used to determine if the point is at infinity (the identity element in elliptic curve arithmetic). The `X` and `Y` coordinates are used for calculations.\n\n2. **Infinity Check**: The code checks if the point is at infinity by evaluating the `X` and `Y` coordinates. Specifically, it computes a variable `infty` by performing bitwise OR operations on the `X` and `Y` coordinates:\n   ```c\n   infty |= (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n             p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n   if (P256_LIMBS == 8)\n       infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n                 p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n   ```\n\n3. **Potential Null Dereference**: The bug report indicates that `p.p.Y` may be null, which would lead to dereferencing a null pointer when accessing `p.p.Y[4]`, `p.p.Y[5]`, etc. If `p.p.Y` is indeed null, this would cause undefined behavior, likely resulting in a crash or memory access violation.\n\n### Bug Analysis\n\nThe bug report suggests that there is a potential null dereference when accessing `p.p.Y`. The code does not explicitly check if `p.p.Y` is null before dereferencing it. If `p.p.Y` is null, the dereference will lead to a runtime error.\n\n### Conclusion\n\nGiven the explanation of the code and the potential for dereferencing a null pointer, the bug report is valid. The absence of a null check for `p.p.Y` before accessing its elements constitutes a real bug.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);'}\nValue p.p.Y may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "404 #define Y  /* .. */ 2 + 2"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "83 #define Y(I) (&((char *)point_array)[(3*(I) + 1) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication using precomputed values. The relevant section of the code is concerned with handling the coordinates of points in a specific format (affine or Jacobian) and checking for conditions that determine if a point is at infinity.\n\n1. **Point Representation**: The points are represented in a structure `P256_POINT`, which contains arrays for the X, Y, and Z coordinates. The Z coordinate is used to determine if the point is at infinity (when Z is zero).\n\n2. **Infinity Check**: The code checks if the point is at infinity by evaluating the X and Y coordinates. Specifically, it computes a variable `infty` that combines the values of the X and Y coordinates:\n   ```c\n   infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n   ```\n   This line checks if any of the specified coordinates are non-zero, which would indicate that the point is not at infinity.\n\n3. **Dereferencing Potential Null Pointer**: The bug report indicates that `p.p.Y` may be null, and thus should be checked before dereferencing. If `p.p.Y` is indeed null, attempting to access its elements (like `p.p.Y[4]`, `p.p.Y[5]`, etc.) would lead to undefined behavior, likely causing a segmentation fault or crash.\n\n### Bug Analysis\n\nGiven the explanation of the code's behavior, the bug report raises a valid concern. If `p.p.Y` is null, dereferencing it to access its elements will lead to a runtime error. The code does not currently check if `p.p.Y` is null before attempting to access its elements, which confirms that there is a potential for a null pointer dereference.\n\n### Conclusion\n\nBased on the analysis, the bug report is accurate, and the code does indeed have a potential issue with dereferencing a null pointer. Therefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tinfty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);'}\nValue p.p.Y may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "404 #define Y  /* .. */ 2 + 2"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "83 #define Y(I) (&((char *)point_array)[(3*(I) + 1) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet is part of a function that performs elliptic curve point multiplication using the NIST P-256 curve. The specific lines of interest in the bug report involve dereferencing the `p.p.Y` array, which is part of a structure that represents a point on the elliptic curve.\n\n### Explanation of the Code Behavior\n\n1. **Data Structures**: The code uses a structure `P256_POINT` (not fully shown in the snippet) that likely contains arrays `X`, `Y`, and `Z`, which represent the coordinates of a point in projective space. The `p` variable is an instance of this structure.\n\n2. **Infinity Check**: The code is checking if the point represented by `p.p` is at infinity. In elliptic curve cryptography, the point at infinity is often represented by the coordinates (0, 0) in affine coordinates or by setting the Z coordinate to 0 in projective coordinates.\n\n3. **Dereferencing**: The lines in question:\n   ```c\n   infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] | p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n   ```\n   Here, the code is performing a bitwise OR operation on the elements of the `X` and `Y` arrays of the `p.p` structure. The purpose of this operation is to determine if any of the coordinates are non-zero, which would indicate that the point is not at infinity.\n\n4. **Potential Null Dereference**: The bug report states that `p.p.Y` may be null and should be checked before dereferencing. This implies that there is a possibility that the `Y` array (or the entire `p.p` structure) has not been properly initialized or allocated, leading to a potential null dereference when accessing its elements.\n\n### Bug Analysis\n\n- **True Positive or False Positive**: The bug report raises a valid concern. If `p.p` or `p.p.Y` is null, dereferencing it will lead to undefined behavior, likely causing a crash or memory access violation. The code does not currently check if `p.p` or `p.p.Y` is null before attempting to access its elements.\n\n### Conclusion\n\nGiven the explanation above, the bug report correctly identifies a potential issue in the code. Therefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tp.p.Z[4] = ONE[4] & infty;'}\nValue p.p.Z may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "405 #define Z  3          + 3 * (*a++)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "84 #define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet is part of a function `ecp_nistz256_points_mul`, which is likely involved in elliptic curve cryptography operations. The function performs a multiplication of points on the elliptic curve, which is a common operation in cryptographic algorithms.\n\n### Explanation of the Code Behavior\n\n1. **Function Purpose**: The function `ecp_nistz256_points_mul` is designed to multiply a point on an elliptic curve by a scalar value. It takes several parameters, including the elliptic curve group, the result point, the scalar, and arrays of points and scalars.\n\n2. **Point Representation**: The points on the elliptic curve are represented using a structure `P256_POINT`, which contains fields like `X`, `Y`, and `Z`. The `Z` field is used in Jacobian coordinates, which allows for more efficient point addition and doubling.\n\n3. **Handling Precomputed Tables**: The function checks if there are precomputed multiples of the generator point available. If so, it uses these to speed up the multiplication process.\n\n4. **Infinity Check**: The code checks if the point is at infinity (a special case in elliptic curves) and handles it accordingly.\n\n5. **Setting Values**: The lines in question (specifically `p.p.Z[4] = ONE[4] & infty;`) are part of a block that sets the `Z` coordinates of the point `p.p` based on whether the point is at infinity or not. The variable `infty` is computed based on the values of `X` and `Y` coordinates.\n\n### Bug Report Analysis\n\nThe bug report states that `p.p.Z` may be null and should be checked before dereferencing. \n\n- **Potential Null Dereference**: The concern is that if `p.p` is not properly initialized or if `p.p.Z` is not allocated, dereferencing `p.p.Z` to assign values could lead to undefined behavior (e.g., segmentation fault).\n\n- **Initialization**: In the provided code, `p` is initialized with `memset(&p, 0, sizeof(p));`, which sets all bytes of `p` to zero. However, this does not guarantee that `p.p.Z` points to a valid memory location. The structure `P256_POINT` must have its `Z` field allocated properly before it can be used.\n\n### Conclusion\n\nGiven the analysis, the bug report is valid. The code does not check if `p.p.Z` is a valid pointer before dereferencing it, which could lead to a null pointer dereference if `p.p` is not properly initialized or if `Z` is not allocated.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tp.p.Z[4] = ONE[4] & infty;'}\nValue ONE may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "405 #define Z  3          + 3 * (*a++)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "84 #define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication, specifically for the NIST P-256 curve. The relevant section of the code deals with the handling of a variable named `ONE`, which is defined as a constant:\n\n```c\n#define ONE ((size_t)1)\n```\n\nThis means that `ONE` is a constant value of `1` of type `size_t`. The code then uses this constant in the following lines:\n\n```c\np.p.Z[0] = ONE[0] & infty;\np.p.Z[1] = ONE[1] & infty;\np.p.Z[2] = ONE[2] & infty;\np.p.Z[3] = ONE[3] & infty;\nif (P256_LIMBS == 8) {\n    p.p.Z[4] = ONE[4] & infty;\n    p.p.Z[5] = ONE[5] & infty;\n    p.p.Z[6] = ONE[6] & infty;\n    p.p.Z[7] = ONE[7] & infty;\n}\n```\n\nHere, `ONE` is being treated as an array, which is incorrect because `ONE` is defined as a single `size_t` value, not an array. This leads to an attempt to access elements of `ONE` using indexing (e.g., `ONE[4]`), which is undefined behavior in C/C++.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value ONE may be null; it should be checked before dereferencing.\" However, since `ONE` is defined as a constant value of `1`, it cannot be null. The issue lies in the fact that `ONE` is being incorrectly treated as an array, which is a programming error.\n\n### Conclusion\n\nGiven the analysis, the bug report is based on a misunderstanding of the code. The actual issue is not about `ONE` being null, but rather about the incorrect usage of `ONE` as an array. Therefore, the bug report does not accurately describe the problem.\n\nThus, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tp.Z[5] = ONE[5] & infty;'}\nValue p.p.Z may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "405 #define Z  3          + 3 * (*a++)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "84 #define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication using the NIST P-256 curve. The specific lines of interest are those that manipulate the `p.p.Z` array, which is part of a structure representing a point in projective coordinates.\n\n1. **Understanding `p.p.Z`**: \n   - The `p.p.Z` array is intended to hold the Z-coordinate of a point in projective space. In projective coordinates, the Z-coordinate is used to represent points at infinity and to facilitate certain arithmetic operations without needing to convert to affine coordinates.\n\n2. **Setting Values in `p.p.Z`**:\n   - The lines in question (`p.p.Z[0] = ONE[0] & infty;` through `p.p.Z[5] = ONE[5] & infty;`) are setting the values of the Z-coordinate based on the `infty` variable, which is determined by checking if the X and Y coordinates of the point are zero (indicating a point at infinity).\n   - The `ONE` macro is defined as a constant array of size_t values, which is used to initialize the Z-coordinate based on whether the point is at infinity or not.\n\n3. **Potential Null Dereference**:\n   - The bug report indicates that `p.p.Z` may be null and should be checked before dereferencing. This is a concern because if `p.p.Z` is indeed null, attempting to access `p.p.Z[5]` would lead to undefined behavior (likely a segmentation fault).\n\n### Determining the Bug Status\n\nTo determine whether the bug report is a true positive or a false positive, we need to analyze the context in which `p.p.Z` is used:\n\n- **Initialization**: The variable `p` is defined as a union that contains a structure `P256_POINT`, which includes the `Z` array. The code initializes `p` with `memset(&p, 0, sizeof(p));`, which sets all bytes of `p` to zero. This means that `p.p.Z` is initialized to point to a valid memory location (though all values will be zero).\n\n- **Subsequent Logic**: The code does not show any explicit checks for whether `p.p.Z` is null before accessing it. However, since it is initialized to zero, it is not null at the point of access unless there is a logic flaw elsewhere in the code that could lead to `p` being improperly initialized or modified.\n\n- **Conclusion**: Given that `p.p.Z` is initialized to a valid memory location and the code does not indicate any scenario where it could become null before the dereference, the bug report appears to be a false alarm.\n\n### Final Label\n\nBased on the analysis, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tp.p.Z[5] = ONE[5] & infty;'}\nValue ONE may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "405 #define Z  3          + 3 * (*a++)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "84 #define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication, specifically for the NIST P-256 curve. The relevant section of the code deals with the handling of a point's Z-coordinate, which is crucial in the context of projective coordinates used in elliptic curve cryptography.\n\n1. **Definitions and Context**:\n   - `ONE` is defined as a constant with a value of `1` (specifically, it is a size_t type).\n   - The Z-coordinate of a point in projective coordinates is used to represent the point in a way that avoids division by the Z-coordinate when converting to affine coordinates.\n\n2. **Handling of Infinity**:\n   - The code checks if the point is at infinity (i.e., the identity element in elliptic curve terms). This is done by evaluating the X and Y coordinates of the point.\n   - If the point is at infinity, the Z-coordinate is set to `0`, otherwise, it is set to `1`.\n\n3. **Bitwise Operations**:\n   - The lines in question (`p.p.Z[5] = ONE[5] & infty;`) are performing a bitwise AND operation between the `ONE` constant and the `infty` variable, which indicates whether the point is at infinity or not.\n   - The `ONE` constant is treated as an array, which suggests that it is expected to be an array of size_t values. However, in the provided code, `ONE` is defined as a single size_t value, which could lead to undefined behavior if accessed as an array.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value ONE may be null; it should be checked before dereferencing.\" \n\n1. **Understanding the Bug Report**:\n   - The report implies that `ONE` could potentially be null, which would lead to dereferencing a null pointer when accessing `ONE[5]`.\n   - However, since `ONE` is defined as a constant with a value of `1`, it is not a pointer and cannot be null. \n\n2. **Accessing `ONE`**:\n   - The code attempts to access `ONE[5]`, which is incorrect because `ONE` is not an array but a single value. This will lead to an out-of-bounds access if `ONE` is treated as an array.\n\n### Conclusion\n\nGiven the analysis, the bug report is based on a misunderstanding of the definition of `ONE`. The actual issue is that `ONE` is incorrectly treated as an array, which will lead to undefined behavior when accessing indices beyond its defined size. Therefore, the bug report is valid in the sense that there is a real issue with the code, but it mischaracterizes the nature of the problem.\n\nThus, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tp.Z[6] = ONE[6] & infty;'}\nValue p.p.Z may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "405 #define Z  3          + 3 * (*a++)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "84 #define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication using the NIST P-256 curve. The specific lines of interest in the bug report involve the manipulation of the `p.p.Z` array, which is part of a structure representing a point in projective coordinates.\n\n1. **Structure and Definitions**:\n   - The code uses a union to define `P256_POINT` and `P256_POINT_AFFINE`, which likely represent points in different coordinate systems.\n   - The `p` variable is an instance of this union, and `p.p.Z` is an array that holds the Z-coordinate of the point in projective coordinates.\n\n2. **Setting the Z-coordinate**:\n   - The lines in question (`p.p.Z[6] = ONE[6] & infty;`) are setting the Z-coordinate of the point based on the value of `infty`, which is determined by checking if the X and Y coordinates of the point are zero (indicating the point at infinity).\n   - The `ONE` macro is defined as a constant array with a size of `size_t`, and it is used to set the Z-coordinate conditionally based on whether the point is at infinity.\n\n3. **Potential Null Dereference**:\n   - The bug report indicates that `p.p.Z` may be null and should be checked before dereferencing. This suggests that there is a concern that the `p` variable (or specifically `p.p`) might not have been properly initialized before accessing `p.p.Z`.\n\n### Determining the Bug Status\n\nTo determine whether the bug is a true positive or a false positive, we need to analyze the initialization and usage of `p`:\n\n- **Initialization**: The code initializes `p` with `memset(&p, 0, sizeof(p));`, which sets all bytes of `p` to zero. This means that all pointers and arrays within `p` are initialized to null or zero.\n- **Usage**: The code later accesses `p.p.Z` without any prior checks to ensure that it has been allocated or initialized properly. If `p.p` is a structure that contains a pointer to `Z`, and if that pointer is null, dereferencing it would lead to undefined behavior.\n\n### Conclusion\n\nGiven that the code does not explicitly check if `p.p.Z` is valid before dereferencing it, and considering that `p` is initialized to zero (which could imply that `p.p.Z` is also null), the bug report correctly identifies a potential issue. Therefore, the bug is a true positive.\n\n### Final Label\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tp.p.Z[6] = ONE[6] & infty;'}\nValue ONE may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "405 #define Z  3          + 3 * (*a++)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "84 #define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication, specifically for the NIST P-256 curve. The relevant section of the code deals with the initialization of the `Z` coordinate of a point in projective coordinates.\n\n1. **Definitions and Context**:\n   - The `ONE` macro is defined as `((size_t)1)`, which means it is a constant value representing the integer 1.\n   - The `p.p.Z` array is used to store the Z coordinates of points in projective space.\n\n2. **Setting the Z Coordinates**:\n   - The code initializes the Z coordinates of a point based on whether the point is at infinity or not. The Z coordinate is set to either `ONE` or zero, depending on the value of `infty`, which is computed based on the X and Y coordinates of the point.\n   - The lines in question are:\n     ```c\n     p.p.Z[0] = ONE[0] & infty;\n     p.p.Z[1] = ONE[1] & infty;\n     p.p.Z[2] = ONE[2] & infty;\n     p.p.Z[3] = ONE[3] & infty;\n     if (P256_LIMBS == 8) {\n         p.p.Z[4] = ONE[4] & infty;\n         p.p.Z[5] = ONE[5] & infty;\n         p.p.Z[6] = ONE[6] & infty;\n         p.p.Z[7] = ONE[7] & infty;\n     }\n     ```\n   - Here, `infty` is a computed value that indicates whether the point is at infinity (0) or not (1). The `&` operator is used to conditionally set the Z coordinates based on the value of `infty`.\n\n### Analysis of the Bug Report\n\nThe bug report states that \"Value ONE may be null; it should be checked before dereferencing.\" \n\n1. **Understanding the Macro**:\n   - The `ONE` macro is defined as `((size_t)1)`, which is a constant value and not a pointer or an array that could be null. It is a compile-time constant representing the integer 1.\n   - Therefore, `ONE` cannot be null, and dereferencing it (as implied by the bug report) is not applicable because it is not a pointer.\n\n2. **Dereferencing Context**:\n   - The code does not dereference `ONE` as if it were a pointer. Instead, it accesses its elements as if it were an array. However, since `ONE` is defined as a single constant value, the indexing (e.g., `ONE[0]`) is not valid and would lead to a compilation error if `ONE` were treated as an array.\n\n### Conclusion\n\nGiven the analysis, the bug report is based on a misunderstanding of the `ONE` macro. It is not a pointer or an array that could be null, and thus there is no need for a null check. The code is correctly using `ONE` as a constant value.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tp.Z[7] = ONE[7] & infty;'}\nValue p.p.Z may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "405 #define Z  3          + 3 * (*a++)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "84 #define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication using the NIST P-256 curve. The specific lines of interest in the bug report involve the manipulation of the `p.p.Z` array, which is part of a structure representing a point in projective coordinates.\n\n1. **Structure and Definitions**:\n   - The code uses a union `t` that contains two types of points: `P256_POINT` and `P256_POINT_AFFINE`. The `p` variable is of type `P256_POINT`, which likely contains the coordinates of a point on the elliptic curve.\n   - The `Z` coordinate is used in projective coordinates to avoid the need for division in calculations.\n\n2. **Potential Null Dereference**:\n   - The bug report indicates that `p.p.Z` may be null and should be checked before dereferencing. This suggests that there is a concern that the `Z` array might not have been properly initialized or allocated before it is accessed.\n   - The lines in question (`p.p.Z[7] = ONE[7] & infty;`) are attempting to assign a value to the 8th element of the `Z` array. If `p.p.Z` is indeed null, this would lead to undefined behavior (likely a segmentation fault) when trying to dereference it.\n\n3. **Initialization**:\n   - The code initializes the union `t` and the variable `p` with `memset(&p, 0, sizeof(p));`, which sets all bytes of `p` to zero. This means that if `p.p.Z` is a pointer, it will be initialized to `NULL`.\n   - However, the code does not show any explicit allocation for `p.p.Z`, which raises the question of whether it is safe to access its elements.\n\n### Bug Analysis\n\nGiven the explanation above, the bug report is valid. The code does not ensure that `p.p.Z` is allocated before it is accessed. If `p.p.Z` is indeed null (which it would be after the `memset`), dereferencing it to assign values will lead to a runtime error.\n\n### Conclusion\n\nBased on the analysis, the bug report correctly identifies a potential issue in the code. Therefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\t\\tp.p.Z[7] = ONE[7] & infty;'}\nValue ONE may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/util/check-format-test-negatives.c",
                                "function_body": "405 #define Z  3          + 3 * (*a++)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistputil.c",
                                "function_body": "84 #define Z(I) (&((char *)point_array)[(3*(I) + 2) * felem_size])"
                            },
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a function that performs elliptic curve point multiplication, specifically for the NIST P-256 curve. The relevant section of the code deals with the handling of a point's Z-coordinate, which is crucial in the context of projective coordinates used in elliptic curve cryptography.\n\n1. **Definitions and Initializations**:\n   - The code defines a constant `ONE` as a size_t value of 1. This is used to set the Z-coordinate of a point in projective coordinates.\n   - The Z-coordinate is initialized based on whether the point is at infinity or not.\n\n2. **Infinity Check**:\n   - The variable `infty` is computed based on the X and Y coordinates of the point `p.p`. If all components are zero, `infty` will be set to a value that indicates the point is at infinity.\n\n3. **Setting the Z-coordinate**:\n   - The Z-coordinate `p.p.Z` is set using the expression `p.p.Z[i] = ONE[i] & infty;`. This means that if `infty` is zero (indicating the point is at infinity), the Z-coordinate will also be set to zero. If `infty` is non-zero, the Z-coordinate will be set to 1 (since `ONE` is defined as 1).\n\n### Analysis of the Bug Report\n\nThe bug report states that \"Value ONE may be null; it should be checked before dereferencing.\" However, in the provided code, `ONE` is defined as a constant value of 1, which is not a pointer and cannot be null. Therefore, there is no dereferencing happening with `ONE`, and it is not possible for `ONE` to be null.\n\n### Conclusion\n\nGiven the explanation of the code and the nature of the bug report, it is clear that the bug report is incorrect. The code does not dereference `ONE`, and it is not possible for `ONE` to be null. Thus, the bug report is a false alarm.\n\nLabel: `@@@ false alarm @@@`",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\tres |= a[4] ^ ONE[4];'}\nValue ONE may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "427 static void ecp_sm2p256_point_get_affine(P256_POINT_AFFINE *R,\n428                                          const P256_POINT *P)\n429 {\n430     ALIGN32 BN_ULONG z_inv3[P256_LIMBS] = {0};\n431     ALIGN32 BN_ULONG z_inv2[P256_LIMBS] = {0};\n432\n433     if (is_one(P->Z)) {\n434         memcpy(R->X, P->X, 32);\n435         memcpy(R->Y, P->Y, 32);\n436         return;\n437     }\n438\n439     ecp_sm2p256_mod_inverse(z_inv3, P->Z);\n440     ecp_sm2p256_sqr(z_inv2, z_inv3);\n441     ecp_sm2p256_mul(R->X, P->X, z_inv2);\n442     ecp_sm2p256_mul(z_inv3, z_inv3, z_inv2);\n443     ecp_sm2p256_mul(R->Y, P->Y, z_inv3);\n444 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `is_one` that checks if a given `BIGNUM` (represented by the pointer `z`) is equal to one. The function does the following:\n\n1. It retrieves the words of the `BIGNUM` using `bn_get_words(z)`, which returns a pointer to an array of `BN_ULONG` values.\n2. It checks if the number of significant words in `z` (obtained via `bn_get_top(z)`) matches a specific condition related to `P256_LIMBS`.\n3. If the condition is met, it performs bitwise XOR operations between the words of `z` and a predefined constant `ONE`, which is defined as `#define ONE ((size_t)1)`. This constant is treated as an array of size `size_t`, but it is effectively just a single value of `1`.\n4. The results of these XOR operations are accumulated in the variable `res`, which is then checked for zero using the `is_zero` function before being returned.\n\n### Analysis of the Bug Report\n\nThe bug report states that \"Value ONE may be null; it should be checked before dereferencing.\" \n\n1. **Understanding `ONE`:** The definition of `ONE` is `#define ONE ((size_t)1)`, which means `ONE` is not a pointer but a constant value of type `size_t`. Therefore, it cannot be null. It is simply an integer value representing `1`.\n2. **Dereferencing Concern:** The code does not dereference `ONE` as if it were a pointer. Instead, it uses `ONE[0]`, which is syntactically incorrect because `ONE` is not an array or pointer. This would lead to a compilation error rather than a runtime null dereference.\n\n### Conclusion\n\nGiven that `ONE` is a constant value and not a pointer, the concern raised in the bug report about it being null and needing a check before dereferencing is unfounded. The code does not actually dereference a potentially null pointer, and the usage of `ONE` is incorrect in the context of array indexing.\n\nThus, the bug report is a false alarm.\n\n### Final Label\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '    \\t\\tres |= a[5] ^ ONE[5];'}\nValue ONE may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "427 static void ecp_sm2p256_point_get_affine(P256_POINT_AFFINE *R,\n428                                          const P256_POINT *P)\n429 {\n430     ALIGN32 BN_ULONG z_inv3[P256_LIMBS] = {0};\n431     ALIGN32 BN_ULONG z_inv2[P256_LIMBS] = {0};\n432\n433     if (is_one(P->Z)) {\n434         memcpy(R->X, P->X, 32);\n435         memcpy(R->Y, P->Y, 32);\n436         return;\n437     }\n438\n439     ecp_sm2p256_mod_inverse(z_inv3, P->Z);\n440     ecp_sm2p256_sqr(z_inv2, z_inv3);\n441     ecp_sm2p256_mul(R->X, P->X, z_inv2);\n442     ecp_sm2p256_mul(z_inv3, z_inv3, z_inv2);\n443     ecp_sm2p256_mul(R->Y, P->Y, z_inv3);\n444 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet is part of a cryptographic library that deals with elliptic curve operations. The specific function in question is `is_one`, which checks if a given `BIGNUM` (a large integer used in cryptography) is equal to one.\n\n1. **Macro Definition**: \n   ```c\n   #define ONE ((size_t)1)\n   ```\n   This defines `ONE` as a constant value of `1` of type `size_t`.\n\n2. **Function `is_one`**:\n   - The function takes a pointer to a `BIGNUM` structure (`const BIGNUM *z`).\n   - It retrieves the words of the `BIGNUM` using `bn_get_words(z)`, which returns a pointer to an array of `BN_ULONG` (unsigned long integers).\n   - It checks if the number of limbs (the number of `BN_ULONG` words) in `z` is equal to a specific value (`P256_LIMBS - P256_LIMBS / 8`).\n   - If the condition is met, it performs bitwise XOR operations between the words of `z` and the constant `ONE` to determine if `z` is equal to one.\n   - The result is then passed to the `is_zero` function, which presumably checks if the result of the XOR operations is zero (indicating that `z` is indeed one).\n\n### Bug Report Analysis\n\nThe bug report states:\n```\nValue ONE may be null; it should be checked before dereferencing.\n```\n\n#### Evaluation of the Bug Report\n\n1. **Nature of `ONE`**: \n   - `ONE` is defined as a constant value of `1` and is not a pointer or an array. It is a simple integer value. Therefore, it cannot be null.\n   - The code does not dereference `ONE` as if it were a pointer; instead, it uses it directly in bitwise operations.\n\n2. **Dereferencing Context**:\n   - The code does not attempt to dereference `ONE` in any way that would lead to a null pointer dereference. The operations involving `ONE` are safe because they are performed on the constant value itself.\n\n### Conclusion\n\nGiven the analysis above, the bug report is based on a misunderstanding of the nature of `ONE`. It is not a pointer and cannot be null, thus the code does not require a null check for `ONE`.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\t\\tres |= a[6] ^ ONE[6];'}\nValue ONE may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/mem_sec.c",
                                "function_body": "312 #define ONE ((size_t)1)"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "213 static BN_ULONG is_one(const BIGNUM *z)\n214 {\n215     BN_ULONG res = 0;\n216     BN_ULONG *a = bn_get_words(z);\n217\n218     if (bn_get_top(z) == (P256_LIMBS - P256_LIMBS / 8)) {\n219         res = a[0] ^ ONE[0];\n220         res |= a[1] ^ ONE[1];\n221         res |= a[2] ^ ONE[2];\n222         res |= a[3] ^ ONE[3];\n223         if (P256_LIMBS == 8) {\n224             res |= a[4] ^ ONE[4];\n225             res |= a[5] ^ ONE[5];\n226             res |= a[6] ^ ONE[6];\n227             /*\n228              * no check for a[7] (being zero) on 32-bit platforms,\n229              * because value of \"one\" takes only 7 limbs.\n230              */\n231         }\n232         res = is_zero(res);\n233     }\n234\n235     return res;\n236 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "427 static void ecp_sm2p256_point_get_affine(P256_POINT_AFFINE *R,\n428                                          const P256_POINT *P)\n429 {\n430     ALIGN32 BN_ULONG z_inv3[P256_LIMBS] = {0};\n431     ALIGN32 BN_ULONG z_inv2[P256_LIMBS] = {0};\n432\n433     if (is_one(P->Z)) {\n434         memcpy(R->X, P->X, 32);\n435         memcpy(R->Y, P->Y, 32);\n436         return;\n437     }\n438\n439     ecp_sm2p256_mod_inverse(z_inv3, P->Z);\n440     ecp_sm2p256_sqr(z_inv2, z_inv3);\n441     ecp_sm2p256_mul(R->X, P->X, z_inv2);\n442     ecp_sm2p256_mul(z_inv3, z_inv3, z_inv2);\n443     ecp_sm2p256_mul(R->Y, P->Y, z_inv3);\n444 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `is_one` that checks if a given `BIGNUM` (represented by the pointer `z`) is equal to the constant value defined by `ONE`. The constant `ONE` is defined as `((size_t)1)`, which is a single value, not an array. However, the code attempts to access `ONE` as if it were an array (e.g., `ONE[0]`, `ONE[1]`, etc.). This is a critical point because it indicates a misunderstanding of the type of `ONE`.\n\nThe function works as follows:\n1. It retrieves the words of the `BIGNUM` `z` using `bn_get_words(z)`, which returns a pointer to an array of `BN_ULONG`.\n2. It checks if the number of significant words in `z` (obtained via `bn_get_top(z)`) matches a specific condition.\n3. If the condition is met, it performs bitwise XOR operations between the words of `z` and the values of `ONE` (which is incorrectly treated as an array).\n4. The results of these operations are combined into the variable `res`, which is then checked for zero using the `is_zero` function.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value ONE may be null; it should be checked before dereferencing.\" However, this is misleading because `ONE` is not a pointer or an array that can be null; it is a defined constant with a fixed value. The real issue lies in the fact that `ONE` is being accessed as if it were an array, which will lead to undefined behavior when the code attempts to access indices beyond the bounds of a single value.\n\n### Conclusion\n\nGiven the explanation above, the bug report is not accurately identifying a null dereference issue. Instead, it highlights a misuse of the constant `ONE` as an array. Therefore, the bug report is a false alarm regarding null dereferencing.\n\nFinal label: **@@@ false alarm @@@**",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tres |= a[4] ^ b[4];'}\nValue a may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "447 static int ecp_sm2p256_is_affine_G(const EC_POINT *generator)\n448 {\n449     return (bn_get_top(generator->X) == P256_LIMBS)\n450             && (bn_get_top(generator->Y) == P256_LIMBS)\n451             && is_equal(bn_get_words(generator->X), def_xG)\n452             && is_equal(bn_get_words(generator->Y), def_yG)\n453             && (generator->Z_is_one == 1);\n454 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "566 static int ecp_sm2p256_points_mul(const EC_GROUP *group,\n567                                   EC_POINT *r,\n568                                   const BIGNUM *scalar,\n569                                   size_t num,\n570                                   const EC_POINT *points[],\n571                                   const BIGNUM *scalars[], BN_CTX *ctx)\n572 {\n573     int ret = 0, p_is_infinity = 0;\n574     const EC_POINT *generator = NULL;\n575     ALIGN32 BN_ULONG k[P256_LIMBS] = {0};\n576     ALIGN32 union {\n577         P256_POINT p;\n578         P256_POINT_AFFINE a;\n579     } t, p;\n580\n581     if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n582         ECerr(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n583         goto err;\n584     }\n585\n586     BN_CTX_start(ctx);\n587\n588     if (scalar) {\n589         generator = EC_GROUP_get0_generator(group);\n590         if (generator == NULL) {\n591             ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n592             goto err;\n593         }\n594\n595         if (!ecp_sm2p256_bignum_field_elem(k, scalar)) {\n596             ECerr(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n597             goto err;\n598         }\n599 #if !defined(OPENSSL_NO_SM2_PRECOMP)\n600         if (ecp_sm2p256_is_affine_G(generator)) {\n601             ecp_sm2p256_point_G_mul_by_scalar(&p.p, k);\n602         } else\n603 #endif\n604         {\n605             /* if no precomputed table */\n606             const EC_POINT *new_generator[1];\n607             const BIGNUM *g_scalars[1];\n608\n609             new_generator[0] = generator;\n610             g_scalars[0] = scalar;\n611\n612             if (!ecp_sm2p256_windowed_mul(group, &p.p, g_scalars, new_generator,\n613                                           (new_generator[0] != NULL\n614                                            && g_scalars[0] != NULL), ctx))\n615                 goto err;\n616         }\n617     } else {\n618         p_is_infinity = 1;\n619     }\n620     if (num) {\n621         P256_POINT *out = &t.p;\n622\n623         if (p_is_infinity)\n624             out = &p.p;\n625\n626         if (!ecp_sm2p256_windowed_mul(group, out, scalars, points, num, ctx))\n627             goto err;\n628\n629         if (!p_is_infinity)\n630             ecp_sm2p256_point_add(&p.p, &p.p, out);\n631     }\n632\n633     /* Not constant-time, but we're only operating on the public output. */\n634     if (!bn_set_words(r->X, p.p.X, P256_LIMBS)\n635         || !bn_set_words(r->Y, p.p.Y, P256_LIMBS)\n636         || !bn_set_words(r->Z, p.p.Z, P256_LIMBS))\n637         goto err;\n638     r->Z_is_one = is_equal(bn_get_words(r->Z), ONE) & 1;\n639\n640     ret = 1;\n641 err:\n642     BN_CTX_end(ctx);\n643     return ret;\n644 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `is_equal` that compares two arrays of `BN_ULONG` values, `a` and `b`, each of size `P256_LIMBS`. The function performs a bitwise XOR operation between corresponding elements of the two arrays and accumulates the results into a variable `res`. If any of the XOR results are non-zero, `res` will be non-zero, indicating that the two arrays are not equal.\n\nThe specific line in question from the bug report is:\n```c\nres |= a[4] ^ b[4];\n```\nThis line is executed only if `P256_LIMBS` is equal to 8, which means that the arrays `a` and `b` are expected to have at least 8 elements. The concern raised in the bug report is that `a` may be null, which would lead to dereferencing a null pointer when accessing `a[4]`.\n\n### Analysis of the Bug Report\n\n1. **Null Pointer Dereference**: The bug report suggests that `a` may be null, which would indeed cause a dereference error if `a` is accessed without checking if it is null. If `a` is null, attempting to access `a[4]` would lead to undefined behavior.\n\n2. **Context of Use**: The function `is_equal` is called in various places, including the `ecp_nistz256_point_add` function. The context in which `is_equal` is called should ensure that `a` and `b` are valid pointers. However, if there are scenarios where `is_equal` could be called with a null pointer, then the bug is valid.\n\n3. **Guarding Against Null Pointers**: The code does not currently check if `a` or `b` is null before dereferencing them. This is a potential oversight, especially in a cryptographic context where robustness is critical.\n\n### Conclusion\n\nGiven the analysis, the bug report correctly identifies a potential issue with dereferencing a null pointer in the `is_equal` function. Since there is no check for null pointers before accessing the elements of `a`, this can lead to undefined behavior if `a` is indeed null.\n\nThus, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tres |= a[4] ^ b[4];'}\nValue b may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "566 static int ecp_sm2p256_points_mul(const EC_GROUP *group,\n567                                   EC_POINT *r,\n568                                   const BIGNUM *scalar,\n569                                   size_t num,\n570                                   const EC_POINT *points[],\n571                                   const BIGNUM *scalars[], BN_CTX *ctx)\n572 {\n573     int ret = 0, p_is_infinity = 0;\n574     const EC_POINT *generator = NULL;\n575     ALIGN32 BN_ULONG k[P256_LIMBS] = {0};\n576     ALIGN32 union {\n577         P256_POINT p;\n578         P256_POINT_AFFINE a;\n579     } t, p;\n580\n581     if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n582         ECerr(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n583         goto err;\n584     }\n585\n586     BN_CTX_start(ctx);\n587\n588     if (scalar) {\n589         generator = EC_GROUP_get0_generator(group);\n590         if (generator == NULL) {\n591             ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n592             goto err;\n593         }\n594\n595         if (!ecp_sm2p256_bignum_field_elem(k, scalar)) {\n596             ECerr(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n597             goto err;\n598         }\n599 #if !defined(OPENSSL_NO_SM2_PRECOMP)\n600         if (ecp_sm2p256_is_affine_G(generator)) {\n601             ecp_sm2p256_point_G_mul_by_scalar(&p.p, k);\n602         } else\n603 #endif\n604         {\n605             /* if no precomputed table */\n606             const EC_POINT *new_generator[1];\n607             const BIGNUM *g_scalars[1];\n608\n609             new_generator[0] = generator;\n610             g_scalars[0] = scalar;\n611\n612             if (!ecp_sm2p256_windowed_mul(group, &p.p, g_scalars, new_generator,\n613                                           (new_generator[0] != NULL\n614                                            && g_scalars[0] != NULL), ctx))\n615                 goto err;\n616         }\n617     } else {\n618         p_is_infinity = 1;\n619     }\n620     if (num) {\n621         P256_POINT *out = &t.p;\n622\n623         if (p_is_infinity)\n624             out = &p.p;\n625\n626         if (!ecp_sm2p256_windowed_mul(group, out, scalars, points, num, ctx))\n627             goto err;\n628\n629         if (!p_is_infinity)\n630             ecp_sm2p256_point_add(&p.p, &p.p, out);\n631     }\n632\n633     /* Not constant-time, but we're only operating on the public output. */\n634     if (!bn_set_words(r->X, p.p.X, P256_LIMBS)\n635         || !bn_set_words(r->Y, p.p.Y, P256_LIMBS)\n636         || !bn_set_words(r->Z, p.p.Z, P256_LIMBS))\n637         goto err;\n638     r->Z_is_one = is_equal(bn_get_words(r->Z), ONE) & 1;\n639\n640     ret = 1;\n641 err:\n642     BN_CTX_end(ctx);\n643     return ret;\n644 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "447 static int ecp_sm2p256_is_affine_G(const EC_POINT *generator)\n448 {\n449     return (bn_get_top(generator->X) == P256_LIMBS)\n450             && (bn_get_top(generator->Y) == P256_LIMBS)\n451             && is_equal(bn_get_words(generator->X), def_xG)\n452             && is_equal(bn_get_words(generator->Y), def_yG)\n453             && (generator->Z_is_one == 1);\n454 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains two functions: `is_equal` and `ecp_nistz256_point_add`. \n\n1. **Function `is_equal`**:\n   - This function takes two arrays `a` and `b`, each of size `P256_LIMBS`, which is presumably defined elsewhere in the code.\n   - It computes a bitwise XOR between corresponding elements of the two arrays and accumulates the result in the variable `res`.\n   - If `P256_LIMBS` is equal to 8, it also processes the next four elements of the arrays.\n   - Finally, it returns the result of the `is_zero` function applied to `res`, which likely checks if `res` is zero (indicating that the two arrays are equal).\n\n2. **Function `ecp_nistz256_point_add`**:\n   - This function performs point addition on elliptic curves, specifically for points represented in Jacobian coordinates.\n   - It checks if the input points are at infinity and performs various calculations based on the coordinates of the points.\n   - The function uses `is_equal` to check if certain intermediate results (U1, U2, S1, S2) are equal, which is crucial for determining if the points are the same or inverses of each other.\n\n### Analysis of the Bug Report\n\nThe bug report states that \"Value b may be null; it should be checked before dereferencing.\" This refers to the line in the `is_equal` function where `b` is dereferenced to access its elements. \n\nIn the context of the `is_equal` function:\n- The parameters `a` and `b` are expected to be arrays of `BN_ULONG` with a size defined by `P256_LIMBS`.\n- The function does not perform any null checks on `b` before accessing its elements. If `b` is indeed null, dereferencing it (e.g., `b[0]`, `b[1]`, etc.) would lead to undefined behavior, likely causing a segmentation fault or access violation.\n\n### Conclusion\n\nGiven that the bug report correctly identifies a potential issue with dereferencing a null pointer, and since the `is_equal` function does not check for null pointers before accessing the elements of `b`, this constitutes a real bug in the code.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tres |= a[5] ^ b[5];'}\nValue a may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "447 static int ecp_sm2p256_is_affine_G(const EC_POINT *generator)\n448 {\n449     return (bn_get_top(generator->X) == P256_LIMBS)\n450             && (bn_get_top(generator->Y) == P256_LIMBS)\n451             && is_equal(bn_get_words(generator->X), def_xG)\n452             && is_equal(bn_get_words(generator->Y), def_yG)\n453             && (generator->Z_is_one == 1);\n454 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "566 static int ecp_sm2p256_points_mul(const EC_GROUP *group,\n567                                   EC_POINT *r,\n568                                   const BIGNUM *scalar,\n569                                   size_t num,\n570                                   const EC_POINT *points[],\n571                                   const BIGNUM *scalars[], BN_CTX *ctx)\n572 {\n573     int ret = 0, p_is_infinity = 0;\n574     const EC_POINT *generator = NULL;\n575     ALIGN32 BN_ULONG k[P256_LIMBS] = {0};\n576     ALIGN32 union {\n577         P256_POINT p;\n578         P256_POINT_AFFINE a;\n579     } t, p;\n580\n581     if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n582         ECerr(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n583         goto err;\n584     }\n585\n586     BN_CTX_start(ctx);\n587\n588     if (scalar) {\n589         generator = EC_GROUP_get0_generator(group);\n590         if (generator == NULL) {\n591             ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n592             goto err;\n593         }\n594\n595         if (!ecp_sm2p256_bignum_field_elem(k, scalar)) {\n596             ECerr(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n597             goto err;\n598         }\n599 #if !defined(OPENSSL_NO_SM2_PRECOMP)\n600         if (ecp_sm2p256_is_affine_G(generator)) {\n601             ecp_sm2p256_point_G_mul_by_scalar(&p.p, k);\n602         } else\n603 #endif\n604         {\n605             /* if no precomputed table */\n606             const EC_POINT *new_generator[1];\n607             const BIGNUM *g_scalars[1];\n608\n609             new_generator[0] = generator;\n610             g_scalars[0] = scalar;\n611\n612             if (!ecp_sm2p256_windowed_mul(group, &p.p, g_scalars, new_generator,\n613                                           (new_generator[0] != NULL\n614                                            && g_scalars[0] != NULL), ctx))\n615                 goto err;\n616         }\n617     } else {\n618         p_is_infinity = 1;\n619     }\n620     if (num) {\n621         P256_POINT *out = &t.p;\n622\n623         if (p_is_infinity)\n624             out = &p.p;\n625\n626         if (!ecp_sm2p256_windowed_mul(group, out, scalars, points, num, ctx))\n627             goto err;\n628\n629         if (!p_is_infinity)\n630             ecp_sm2p256_point_add(&p.p, &p.p, out);\n631     }\n632\n633     /* Not constant-time, but we're only operating on the public output. */\n634     if (!bn_set_words(r->X, p.p.X, P256_LIMBS)\n635         || !bn_set_words(r->Y, p.p.Y, P256_LIMBS)\n636         || !bn_set_words(r->Z, p.p.Z, P256_LIMBS))\n637         goto err;\n638     r->Z_is_one = is_equal(bn_get_words(r->Z), ONE) & 1;\n639\n640     ret = 1;\n641 err:\n642     BN_CTX_end(ctx);\n643     return ret;\n644 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `is_equal` that compares two arrays of `BN_ULONG` values, `a` and `b`, each of size `P256_LIMBS`. The function performs a bitwise XOR operation between corresponding elements of the two arrays and accumulates the results into a variable `res`. The function checks if the size of the arrays is 8 (i.e., `P256_LIMBS == 8`), and if so, it includes additional elements in the comparison. Finally, it returns the result of the `is_zero` function applied to `res`, which presumably checks if `res` is zero, indicating that the two arrays are equal.\n\nThe specific line in question from the bug report is:\n```c\nres |= a[5] ^ b[5];\n```\nThis line accesses the 6th element of the array `a` (and `b`) without checking if `a` is `NULL`. If `a` is `NULL`, dereferencing it will lead to undefined behavior, likely causing a segmentation fault or crash.\n\n### Evaluation of the Bug Report\n\nThe bug report states that \"Value a may be null; it should be checked before dereferencing.\" This is a valid concern because if `a` is indeed `NULL`, any attempt to access `a[5]` will result in dereferencing a null pointer, which is a serious error in C/C++ programming.\n\nIn the context of the function `is_equal`, there are no checks to ensure that `a` and `b` are not `NULL` before accessing their elements. This oversight can lead to runtime errors if the function is called with `NULL` pointers.\n\n### Conclusion\n\nGiven the explanation of the code and the evaluation of the bug report, it is clear that the bug report accurately identifies a potential issue in the code. The absence of checks for `NULL` pointers before dereferencing them constitutes a real bug.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tres |= a[5] ^ b[5];'}\nValue b may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "566 static int ecp_sm2p256_points_mul(const EC_GROUP *group,\n567                                   EC_POINT *r,\n568                                   const BIGNUM *scalar,\n569                                   size_t num,\n570                                   const EC_POINT *points[],\n571                                   const BIGNUM *scalars[], BN_CTX *ctx)\n572 {\n573     int ret = 0, p_is_infinity = 0;\n574     const EC_POINT *generator = NULL;\n575     ALIGN32 BN_ULONG k[P256_LIMBS] = {0};\n576     ALIGN32 union {\n577         P256_POINT p;\n578         P256_POINT_AFFINE a;\n579     } t, p;\n580\n581     if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n582         ECerr(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n583         goto err;\n584     }\n585\n586     BN_CTX_start(ctx);\n587\n588     if (scalar) {\n589         generator = EC_GROUP_get0_generator(group);\n590         if (generator == NULL) {\n591             ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n592             goto err;\n593         }\n594\n595         if (!ecp_sm2p256_bignum_field_elem(k, scalar)) {\n596             ECerr(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n597             goto err;\n598         }\n599 #if !defined(OPENSSL_NO_SM2_PRECOMP)\n600         if (ecp_sm2p256_is_affine_G(generator)) {\n601             ecp_sm2p256_point_G_mul_by_scalar(&p.p, k);\n602         } else\n603 #endif\n604         {\n605             /* if no precomputed table */\n606             const EC_POINT *new_generator[1];\n607             const BIGNUM *g_scalars[1];\n608\n609             new_generator[0] = generator;\n610             g_scalars[0] = scalar;\n611\n612             if (!ecp_sm2p256_windowed_mul(group, &p.p, g_scalars, new_generator,\n613                                           (new_generator[0] != NULL\n614                                            && g_scalars[0] != NULL), ctx))\n615                 goto err;\n616         }\n617     } else {\n618         p_is_infinity = 1;\n619     }\n620     if (num) {\n621         P256_POINT *out = &t.p;\n622\n623         if (p_is_infinity)\n624             out = &p.p;\n625\n626         if (!ecp_sm2p256_windowed_mul(group, out, scalars, points, num, ctx))\n627             goto err;\n628\n629         if (!p_is_infinity)\n630             ecp_sm2p256_point_add(&p.p, &p.p, out);\n631     }\n632\n633     /* Not constant-time, but we're only operating on the public output. */\n634     if (!bn_set_words(r->X, p.p.X, P256_LIMBS)\n635         || !bn_set_words(r->Y, p.p.Y, P256_LIMBS)\n636         || !bn_set_words(r->Z, p.p.Z, P256_LIMBS))\n637         goto err;\n638     r->Z_is_one = is_equal(bn_get_words(r->Z), ONE) & 1;\n639\n640     ret = 1;\n641 err:\n642     BN_CTX_end(ctx);\n643     return ret;\n644 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "447 static int ecp_sm2p256_is_affine_G(const EC_POINT *generator)\n448 {\n449     return (bn_get_top(generator->X) == P256_LIMBS)\n450             && (bn_get_top(generator->Y) == P256_LIMBS)\n451             && is_equal(bn_get_words(generator->X), def_xG)\n452             && is_equal(bn_get_words(generator->Y), def_yG)\n453             && (generator->Z_is_one == 1);\n454 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains two functions: `is_equal` and `ecp_sm2p256_points_mul`. \n\n1. **Function `is_equal`**:\n   - This function takes two arrays `a` and `b`, each of size `P256_LIMBS`, which is presumably defined elsewhere in the code.\n   - It computes a bitwise XOR between corresponding elements of the two arrays and accumulates the results into a variable `res`.\n   - If `P256_LIMBS` equals 8, it also processes additional elements (from index 4 to 7).\n   - Finally, it returns the result of `is_zero(res)`, which likely checks if `res` is zero, indicating that the two arrays are equal.\n\n2. **Function `ecp_sm2p256_points_mul`**:\n   - This function performs point multiplication on elliptic curves, which involves several checks and operations on points represented in projective coordinates.\n   - It checks if the `scalar` is non-null and retrieves the generator point from the `group`.\n   - The function also checks if the `points` and `scalars` arrays are valid before proceeding with the multiplication.\n   - The function uses `is_equal` to compare certain values, specifically in the context of elliptic curve point operations.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value b may be null; it should be checked before dereferencing.\" This refers to the line in the `is_equal` function where `b` is accessed:\n\n```c\nres |= a[5] ^ b[5];\n```\n\n### Determining True Positive or False Positive\n\n- The `is_equal` function is designed to operate on two arrays of `BN_ULONG`. The bug report suggests that `b` could be null, which would lead to dereferencing a null pointer when accessing `b[5]`.\n- However, the context in which `is_equal` is called (specifically in `ecp_sm2p256_points_mul`) indicates that `b` is derived from `bn_get_words(generator->Z)`, which is expected to return a valid pointer to an array of `BN_ULONG` values. \n- The function `bn_get_words` should ideally handle the case where `generator->Z` is null or invalid, ensuring that `b` is not null when passed to `is_equal`.\n- Additionally, the `ecp_sm2p256_points_mul` function checks if `scalar` is non-null and retrieves the generator point, which implies that the function is designed to avoid null dereferences.\n\n### Conclusion\n\nGiven the context and the checks in place, it appears that the dereferencing of `b` in the `is_equal` function is safe, as it is called under conditions that should guarantee `b` is valid. Therefore, the bug report is likely a false alarm.\n\nFinal label: **@@@ false alarm @@@**",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tres |= a[6] ^ b[6];'}\nValue a may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "566 static int ecp_sm2p256_points_mul(const EC_GROUP *group,\n567                                   EC_POINT *r,\n568                                   const BIGNUM *scalar,\n569                                   size_t num,\n570                                   const EC_POINT *points[],\n571                                   const BIGNUM *scalars[], BN_CTX *ctx)\n572 {\n573     int ret = 0, p_is_infinity = 0;\n574     const EC_POINT *generator = NULL;\n575     ALIGN32 BN_ULONG k[P256_LIMBS] = {0};\n576     ALIGN32 union {\n577         P256_POINT p;\n578         P256_POINT_AFFINE a;\n579     } t, p;\n580\n581     if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n582         ECerr(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n583         goto err;\n584     }\n585\n586     BN_CTX_start(ctx);\n587\n588     if (scalar) {\n589         generator = EC_GROUP_get0_generator(group);\n590         if (generator == NULL) {\n591             ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n592             goto err;\n593         }\n594\n595         if (!ecp_sm2p256_bignum_field_elem(k, scalar)) {\n596             ECerr(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n597             goto err;\n598         }\n599 #if !defined(OPENSSL_NO_SM2_PRECOMP)\n600         if (ecp_sm2p256_is_affine_G(generator)) {\n601             ecp_sm2p256_point_G_mul_by_scalar(&p.p, k);\n602         } else\n603 #endif\n604         {\n605             /* if no precomputed table */\n606             const EC_POINT *new_generator[1];\n607             const BIGNUM *g_scalars[1];\n608\n609             new_generator[0] = generator;\n610             g_scalars[0] = scalar;\n611\n612             if (!ecp_sm2p256_windowed_mul(group, &p.p, g_scalars, new_generator,\n613                                           (new_generator[0] != NULL\n614                                            && g_scalars[0] != NULL), ctx))\n615                 goto err;\n616         }\n617     } else {\n618         p_is_infinity = 1;\n619     }\n620     if (num) {\n621         P256_POINT *out = &t.p;\n622\n623         if (p_is_infinity)\n624             out = &p.p;\n625\n626         if (!ecp_sm2p256_windowed_mul(group, out, scalars, points, num, ctx))\n627             goto err;\n628\n629         if (!p_is_infinity)\n630             ecp_sm2p256_point_add(&p.p, &p.p, out);\n631     }\n632\n633     /* Not constant-time, but we're only operating on the public output. */\n634     if (!bn_set_words(r->X, p.p.X, P256_LIMBS)\n635         || !bn_set_words(r->Y, p.p.Y, P256_LIMBS)\n636         || !bn_set_words(r->Z, p.p.Z, P256_LIMBS))\n637         goto err;\n638     r->Z_is_one = is_equal(bn_get_words(r->Z), ONE) & 1;\n639\n640     ret = 1;\n641 err:\n642     BN_CTX_end(ctx);\n643     return ret;\n644 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "447 static int ecp_sm2p256_is_affine_G(const EC_POINT *generator)\n448 {\n449     return (bn_get_top(generator->X) == P256_LIMBS)\n450             && (bn_get_top(generator->Y) == P256_LIMBS)\n451             && is_equal(bn_get_words(generator->X), def_xG)\n452             && is_equal(bn_get_words(generator->Y), def_yG)\n453             && (generator->Z_is_one == 1);\n454 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function `is_equal` that compares two arrays of `BN_ULONG` values, `a` and `b`, which are expected to have a size defined by `P256_LIMBS`. The function performs a bitwise XOR operation between corresponding elements of the two arrays and accumulates the results into a variable `res`. If any of the XOR results are non-zero, it indicates that the two arrays are not equal.\n\nThe specific line in question from the bug report is:\n```c\nres |= a[6] ^ b[6];\n```\nThis line is executed only if `P256_LIMBS` is equal to 8, which means that both arrays `a` and `b` are expected to have at least 8 elements. The function does not explicitly check if `a` or `b` is `NULL` before dereferencing them, which could lead to undefined behavior if either pointer is `NULL`.\n\n### Evaluation of the Bug Report\n\nThe bug report states that \"Value a may be null; it should be checked before dereferencing.\" This is a valid concern because if `a` is `NULL`, dereferencing it (e.g., accessing `a[6]`) will lead to a segmentation fault or other undefined behavior.\n\nHowever, the context in which `is_equal` is called is crucial. The function `is_equal` is likely called from other parts of the code where the pointers `a` and `b` are expected to be valid and properly initialized. If there are guarantees in the calling code that `a` and `b` will never be `NULL` when passed to `is_equal`, then the bug report could be considered a false alarm.\n\n### Conclusion\n\nGiven that the function does not check for `NULL` pointers before dereferencing, and without additional context confirming that `a` and `b` are always valid, the bug report highlights a legitimate concern. Therefore, it is prudent to consider this a real bug.\n\nLabel: `@@@ real bug @@@`",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tres |= a[6] ^ b[6];'}\nValue b may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "566 static int ecp_sm2p256_points_mul(const EC_GROUP *group,\n567                                   EC_POINT *r,\n568                                   const BIGNUM *scalar,\n569                                   size_t num,\n570                                   const EC_POINT *points[],\n571                                   const BIGNUM *scalars[], BN_CTX *ctx)\n572 {\n573     int ret = 0, p_is_infinity = 0;\n574     const EC_POINT *generator = NULL;\n575     ALIGN32 BN_ULONG k[P256_LIMBS] = {0};\n576     ALIGN32 union {\n577         P256_POINT p;\n578         P256_POINT_AFFINE a;\n579     } t, p;\n580\n581     if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n582         ECerr(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n583         goto err;\n584     }\n585\n586     BN_CTX_start(ctx);\n587\n588     if (scalar) {\n589         generator = EC_GROUP_get0_generator(group);\n590         if (generator == NULL) {\n591             ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n592             goto err;\n593         }\n594\n595         if (!ecp_sm2p256_bignum_field_elem(k, scalar)) {\n596             ECerr(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n597             goto err;\n598         }\n599 #if !defined(OPENSSL_NO_SM2_PRECOMP)\n600         if (ecp_sm2p256_is_affine_G(generator)) {\n601             ecp_sm2p256_point_G_mul_by_scalar(&p.p, k);\n602         } else\n603 #endif\n604         {\n605             /* if no precomputed table */\n606             const EC_POINT *new_generator[1];\n607             const BIGNUM *g_scalars[1];\n608\n609             new_generator[0] = generator;\n610             g_scalars[0] = scalar;\n611\n612             if (!ecp_sm2p256_windowed_mul(group, &p.p, g_scalars, new_generator,\n613                                           (new_generator[0] != NULL\n614                                            && g_scalars[0] != NULL), ctx))\n615                 goto err;\n616         }\n617     } else {\n618         p_is_infinity = 1;\n619     }\n620     if (num) {\n621         P256_POINT *out = &t.p;\n622\n623         if (p_is_infinity)\n624             out = &p.p;\n625\n626         if (!ecp_sm2p256_windowed_mul(group, out, scalars, points, num, ctx))\n627             goto err;\n628\n629         if (!p_is_infinity)\n630             ecp_sm2p256_point_add(&p.p, &p.p, out);\n631     }\n632\n633     /* Not constant-time, but we're only operating on the public output. */\n634     if (!bn_set_words(r->X, p.p.X, P256_LIMBS)\n635         || !bn_set_words(r->Y, p.p.Y, P256_LIMBS)\n636         || !bn_set_words(r->Z, p.p.Z, P256_LIMBS))\n637         goto err;\n638     r->Z_is_one = is_equal(bn_get_words(r->Z), ONE) & 1;\n639\n640     ret = 1;\n641 err:\n642     BN_CTX_end(ctx);\n643     return ret;\n644 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "447 static int ecp_sm2p256_is_affine_G(const EC_POINT *generator)\n448 {\n449     return (bn_get_top(generator->X) == P256_LIMBS)\n450             && (bn_get_top(generator->Y) == P256_LIMBS)\n451             && is_equal(bn_get_words(generator->X), def_xG)\n452             && is_equal(bn_get_words(generator->Y), def_yG)\n453             && (generator->Z_is_one == 1);\n454 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `is_equal` that compares two arrays of `BN_ULONG` values, `a` and `b`, each of size `P256_LIMBS`. The function performs a bitwise XOR operation between corresponding elements of the two arrays and accumulates the results into a variable `res`. If any of the XOR results are non-zero, `res` will be non-zero, indicating that the two arrays are not equal.\n\nThe specific line in question from the bug report is:\n```c\nres |= a[6] ^ b[6];\n```\nThis line is executed only if `P256_LIMBS` is equal to 8, which means that both arrays `a` and `b` are expected to have at least 8 elements. The function ultimately returns the result of `is_zero(res)`, which checks if `res` is zero, indicating that the two arrays are equal.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value b may be null; it should be checked before dereferencing.\" This implies that there is a concern that the pointer `b` could be null, leading to a dereference of a null pointer when accessing `b[6]`.\n\nHowever, looking at the function `is_equal`, we can see that it is defined to take two parameters of type `const BN_ULONG a[P256_LIMBS]` and `const BN_ULONG b[P256_LIMBS]`. This suggests that the function expects valid arrays of `BN_ULONG` to be passed to it. The function does not perform any null checks on the pointers `a` or `b`.\n\n### Conclusion\n\nGiven that the function `is_equal` does not check for null pointers before dereferencing them, and assuming that the function is called with valid pointers (as expected in a well-structured codebase), the bug report raises a valid concern. If `b` were to be null when passed to `is_equal`, it would indeed lead to undefined behavior due to dereferencing a null pointer.\n\nThus, the bug report identifies a potential issue that could lead to a crash or unexpected behavior if the function is called with a null pointer. Therefore, this is a true positive bug.\n\n### Final Label\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tres |= a[7] ^ b[7];'}\nValue a may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "566 static int ecp_sm2p256_points_mul(const EC_GROUP *group,\n567                                   EC_POINT *r,\n568                                   const BIGNUM *scalar,\n569                                   size_t num,\n570                                   const EC_POINT *points[],\n571                                   const BIGNUM *scalars[], BN_CTX *ctx)\n572 {\n573     int ret = 0, p_is_infinity = 0;\n574     const EC_POINT *generator = NULL;\n575     ALIGN32 BN_ULONG k[P256_LIMBS] = {0};\n576     ALIGN32 union {\n577         P256_POINT p;\n578         P256_POINT_AFFINE a;\n579     } t, p;\n580\n581     if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n582         ECerr(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n583         goto err;\n584     }\n585\n586     BN_CTX_start(ctx);\n587\n588     if (scalar) {\n589         generator = EC_GROUP_get0_generator(group);\n590         if (generator == NULL) {\n591             ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n592             goto err;\n593         }\n594\n595         if (!ecp_sm2p256_bignum_field_elem(k, scalar)) {\n596             ECerr(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n597             goto err;\n598         }\n599 #if !defined(OPENSSL_NO_SM2_PRECOMP)\n600         if (ecp_sm2p256_is_affine_G(generator)) {\n601             ecp_sm2p256_point_G_mul_by_scalar(&p.p, k);\n602         } else\n603 #endif\n604         {\n605             /* if no precomputed table */\n606             const EC_POINT *new_generator[1];\n607             const BIGNUM *g_scalars[1];\n608\n609             new_generator[0] = generator;\n610             g_scalars[0] = scalar;\n611\n612             if (!ecp_sm2p256_windowed_mul(group, &p.p, g_scalars, new_generator,\n613                                           (new_generator[0] != NULL\n614                                            && g_scalars[0] != NULL), ctx))\n615                 goto err;\n616         }\n617     } else {\n618         p_is_infinity = 1;\n619     }\n620     if (num) {\n621         P256_POINT *out = &t.p;\n622\n623         if (p_is_infinity)\n624             out = &p.p;\n625\n626         if (!ecp_sm2p256_windowed_mul(group, out, scalars, points, num, ctx))\n627             goto err;\n628\n629         if (!p_is_infinity)\n630             ecp_sm2p256_point_add(&p.p, &p.p, out);\n631     }\n632\n633     /* Not constant-time, but we're only operating on the public output. */\n634     if (!bn_set_words(r->X, p.p.X, P256_LIMBS)\n635         || !bn_set_words(r->Y, p.p.Y, P256_LIMBS)\n636         || !bn_set_words(r->Z, p.p.Z, P256_LIMBS))\n637         goto err;\n638     r->Z_is_one = is_equal(bn_get_words(r->Z), ONE) & 1;\n639\n640     ret = 1;\n641 err:\n642     BN_CTX_end(ctx);\n643     return ret;\n644 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "447 static int ecp_sm2p256_is_affine_G(const EC_POINT *generator)\n448 {\n449     return (bn_get_top(generator->X) == P256_LIMBS)\n450             && (bn_get_top(generator->Y) == P256_LIMBS)\n451             && is_equal(bn_get_words(generator->X), def_xG)\n452             && is_equal(bn_get_words(generator->Y), def_yG)\n453             && (generator->Z_is_one == 1);\n454 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet contains a function `is_equal` that compares two arrays of `BN_ULONG` values, `a` and `b`, each of size `P256_LIMBS`. The function performs a bitwise XOR operation between corresponding elements of the two arrays and accumulates the results into a variable `res`. If any of the XOR results are non-zero, it indicates that the two arrays are not equal. The function returns the result of `is_zero(res)`, which presumably checks if `res` is zero, indicating that the two arrays are equal.\n\nThe specific line in the bug report is:\n```c\nres |= a[7] ^ b[7];\n```\nThis line is executed only if `P256_LIMBS` is equal to 8, meaning that the function is designed to handle arrays of size 8 in this case.\n\n### Analysis of the Bug Report\nThe bug report states that \"Value a may be null; it should be checked before dereferencing.\" This is a valid concern because if `a` is a null pointer, dereferencing it (i.e., accessing `a[7]`) would lead to undefined behavior, typically resulting in a segmentation fault or crash.\n\n### Determining the Nature of the Bug\n1. **Null Pointer Check**: The function `is_equal` does not perform any checks to ensure that `a` and `b` are not null before dereferencing them. If either `a` or `b` is null, the function will attempt to access memory that it shouldn't, leading to a crash.\n\n2. **Context of Use**: The function is likely called in contexts where the pointers `a` and `b` are expected to be valid. However, without explicit checks, there is a risk that they could be null, especially if the function is used in a broader context where the validity of these pointers cannot be guaranteed.\n\n### Conclusion\nGiven that the code does not check for null pointers before dereferencing them, and considering the potential for a null pointer to cause a crash, the bug report accurately identifies a real issue in the code.\n\nTherefore, I label this as:\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tres |= a[7] ^ b[7];'}\nValue b may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "447 static int ecp_sm2p256_is_affine_G(const EC_POINT *generator)\n448 {\n449     return (bn_get_top(generator->X) == P256_LIMBS)\n450             && (bn_get_top(generator->Y) == P256_LIMBS)\n451             && is_equal(bn_get_words(generator->X), def_xG)\n452             && is_equal(bn_get_words(generator->Y), def_yG)\n453             && (generator->Z_is_one == 1);\n454 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "793 static int ecp_nistz256_is_affine_G(const EC_POINT *generator)\n794 {\n795     return (bn_get_top(generator->X) == P256_LIMBS) &&\n796         (bn_get_top(generator->Y) == P256_LIMBS) &&\n797         is_equal(bn_get_words(generator->X), def_xG) &&\n798         is_equal(bn_get_words(generator->Y), def_yG) &&\n799         is_one(generator->Z);\n800 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_sm2p256.c",
                                "function_body": "566 static int ecp_sm2p256_points_mul(const EC_GROUP *group,\n567                                   EC_POINT *r,\n568                                   const BIGNUM *scalar,\n569                                   size_t num,\n570                                   const EC_POINT *points[],\n571                                   const BIGNUM *scalars[], BN_CTX *ctx)\n572 {\n573     int ret = 0, p_is_infinity = 0;\n574     const EC_POINT *generator = NULL;\n575     ALIGN32 BN_ULONG k[P256_LIMBS] = {0};\n576     ALIGN32 union {\n577         P256_POINT p;\n578         P256_POINT_AFFINE a;\n579     } t, p;\n580\n581     if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n582         ECerr(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);\n583         goto err;\n584     }\n585\n586     BN_CTX_start(ctx);\n587\n588     if (scalar) {\n589         generator = EC_GROUP_get0_generator(group);\n590         if (generator == NULL) {\n591             ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n592             goto err;\n593         }\n594\n595         if (!ecp_sm2p256_bignum_field_elem(k, scalar)) {\n596             ECerr(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n597             goto err;\n598         }\n599 #if !defined(OPENSSL_NO_SM2_PRECOMP)\n600         if (ecp_sm2p256_is_affine_G(generator)) {\n601             ecp_sm2p256_point_G_mul_by_scalar(&p.p, k);\n602         } else\n603 #endif\n604         {\n605             /* if no precomputed table */\n606             const EC_POINT *new_generator[1];\n607             const BIGNUM *g_scalars[1];\n608\n609             new_generator[0] = generator;\n610             g_scalars[0] = scalar;\n611\n612             if (!ecp_sm2p256_windowed_mul(group, &p.p, g_scalars, new_generator,\n613                                           (new_generator[0] != NULL\n614                                            && g_scalars[0] != NULL), ctx))\n615                 goto err;\n616         }\n617     } else {\n618         p_is_infinity = 1;\n619     }\n620     if (num) {\n621         P256_POINT *out = &t.p;\n622\n623         if (p_is_infinity)\n624             out = &p.p;\n625\n626         if (!ecp_sm2p256_windowed_mul(group, out, scalars, points, num, ctx))\n627             goto err;\n628\n629         if (!p_is_infinity)\n630             ecp_sm2p256_point_add(&p.p, &p.p, out);\n631     }\n632\n633     /* Not constant-time, but we're only operating on the public output. */\n634     if (!bn_set_words(r->X, p.p.X, P256_LIMBS)\n635         || !bn_set_words(r->Y, p.p.Y, P256_LIMBS)\n636         || !bn_set_words(r->Z, p.p.Z, P256_LIMBS))\n637         goto err;\n638     r->Z_is_one = is_equal(bn_get_words(r->Z), ONE) & 1;\n639\n640     ret = 1;\n641 err:\n642     BN_CTX_end(ctx);\n643     return ret;\n644 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "194 static BN_ULONG is_equal(const BN_ULONG a[P256_LIMBS],\n195                          const BN_ULONG b[P256_LIMBS])\n196 {\n197     BN_ULONG res;\n198\n199     res = a[0] ^ b[0];\n200     res |= a[1] ^ b[1];\n201     res |= a[2] ^ b[2];\n202     res |= a[3] ^ b[3];\n203     if (P256_LIMBS == 8) {\n204         res |= a[4] ^ b[4];\n205         res |= a[5] ^ b[5];\n206         res |= a[6] ^ b[6];\n207         res |= a[7] ^ b[7];\n208     }\n209\n210     return is_zero(res);\n211 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function `is_equal` that compares two arrays of `BN_ULONG` values, `a` and `b`, which are expected to have a size defined by `P256_LIMBS`. The function performs a bitwise XOR operation between corresponding elements of the two arrays and accumulates the results into a variable `res`. If any of the XOR results are non-zero, it indicates that the two arrays are not equal.\n\nThe relevant lines of code are:\n```c\nres = a[0] ^ b[0];\nres |= a[1] ^ b[1];\nres |= a[2] ^ b[2];\nres |= a[3] ^ b[3];\nif (P256_LIMBS == 8) {\n    res |= a[4] ^ b[4];\n    res |= a[5] ^ b[5];\n    res |= a[6] ^ b[6];\n    res |= a[7] ^ b[7];\n}\n```\n\nThe function returns the result of `is_zero(res)`, which presumably checks if `res` is zero, indicating that the two arrays are equal.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value b may be null; it should be checked before dereferencing.\" This implies that there is a concern that the pointer `b` could be null when the function `is_equal` is called, leading to dereferencing a null pointer, which would cause undefined behavior.\n\n### Determining True Positive or False Positive\n\nTo determine whether this is a true bug or a false alarm, we need to analyze the context in which `is_equal` is called. The function is called in the following lines:\n```c\nis_equal(bn_get_words(generator->X), def_xG)\nis_equal(bn_get_words(generator->Y), def_yG)\n```\n\nHere, `bn_get_words(generator->X)` and `bn_get_words(generator->Y)` are the arguments passed to `is_equal`. The bug report suggests that `b` (which corresponds to the second argument of `is_equal`) may be null. \n\nHowever, we need to check if `bn_get_words(generator->X)` or `bn_get_words(generator->Y)` can return null. The preceding code checks if `generator` is null:\n```c\nif (generator == NULL) {\n    ECerr(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n    goto err;\n}\n```\n\nThis check ensures that `generator` is not null before accessing its members `X` and `Y`. If `generator` is not null, it is reasonable to assume that `bn_get_words(generator->X)` and `bn_get_words(generator->Y)` should also not return null, as they are likely to return valid pointers to the internal representation of the `EC_POINT`.\n\n### Conclusion\n\nGiven that the code checks for the nullity of `generator` before dereferencing it, and assuming that `bn_get_words` does not return null for valid `generator->X` and `generator->Y`, the bug report does not indicate a true bug. Therefore, the dereferencing of `b` in the `is_equal` function is safe under the current logic.\n\nThus, the conclusion is:\n@@@ false alarm @@@",
                "final_answer": "false alarm"
            }
        ],
        "final_answer": "false alarm"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);'}\nValue dst may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet defines a function `copy_conditional` that performs a conditional copy of values from a source array (`src`) to a destination array (`dst`) based on a `move` parameter. The function operates on arrays of type `BN_ULONG`, which is typically a type used for large integers in cryptographic applications.\n\nHere's a breakdown of the function:\n\n1. **Parameters**:\n   - `dst[P256_LIMBS]`: An array where the result will be stored.\n   - `src[P256_LIMBS]`: An array from which values will be copied.\n   - `move`: A value that determines whether to copy from `src` or retain the current value in `dst`.\n\n2. **Mask Calculation**:\n   - `mask1` is calculated as `0 - move`. If `move` is non-zero (true), `mask1` will be all bits set to 1 (i.e., `-1`), otherwise it will be 0.\n   - `mask2` is the bitwise negation of `mask1`, which will be all bits set to 0 if `move` is true, and all bits set to 1 if `move` is false.\n\n3. **Conditional Copy**:\n   - The function uses bitwise operations to conditionally copy values:\n     - If `move` is true, it copies the value from `src` to `dst`.\n     - If `move` is false, it retains the current value in `dst`.\n   - This is done for each element in the arrays, and if `P256_LIMBS` equals 8, it processes additional elements.\n\n### Evaluation of the Bug Report\n\nThe bug report states that \"Value dst may be null; it should be checked before dereferencing.\" \n\n1. **Null Check**: The code does not explicitly check if `dst` is null before dereferencing it. If `dst` were to be null, dereferencing it would lead to undefined behavior, potentially causing a crash or memory corruption.\n\n2. **Context of Use**: The function is likely used in a context where `dst` is expected to be a valid pointer to an array of `BN_ULONG`. However, without proper checks, if `dst` is indeed null, it would lead to a serious issue.\n\n### Conclusion\n\nGiven the analysis, the bug report correctly identifies a potential issue in the code. The absence of a null check for `dst` before dereferencing it is a valid concern, as it could lead to undefined behavior if `dst` is null.\n\nThus, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);'}\nValue src may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet contains a function named `copy_conditional`, which is designed to conditionally copy values from a source array (`src`) to a destination array (`dst`) based on a `move` parameter. The function operates as follows:\n\n1. **Mask Calculation**:\n   - `mask1` is calculated as `0 - move`, which will be `0` if `move` is `0` and `-1` (or all bits set) if `move` is `1`.\n   - `mask2` is the bitwise negation of `mask1`.\n\n2. **Conditional Copying**:\n   - The function uses bitwise operations to copy values from `src` to `dst` based on the value of `move`. If `move` is `1`, it copies the values from `src` to `dst`; if `move` is `0`, it retains the existing values in `dst`.\n   - The copying is done for the first four elements of the arrays, and if `P256_LIMBS` equals `8`, it also copies the next four elements.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value src may be null; it should be checked before dereferencing.\" This implies that there is a concern that the `src` pointer could be `NULL`, leading to dereferencing a null pointer when accessing `src[i]`.\n\n### Determining True Positive or False Positive\n\nIn the context of the `copy_conditional` function:\n- The function does not check if `src` is `NULL` before dereferencing it. If `src` is `NULL`, any attempt to access `src[i]` will lead to undefined behavior, typically resulting in a segmentation fault or crash.\n- The function assumes that `src` is valid and does not handle the case where it might be `NULL`.\n\n### Conclusion\n\nGiven that the code does not perform a null check on the `src` pointer before dereferencing it, this is indeed a valid concern. Therefore, the bug report is accurate.\n\n**Label**: `@@@ real bug @@@`",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[4] = (src[4] & mask1) ^ (dst[4] & mask2);'}\nValue dst may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function named `copy_conditional`, which is designed to conditionally copy values from a source array (`src`) to a destination array (`dst`) based on a `move` parameter. The function operates on arrays of type `BN_ULONG`, which is typically a type used for large integers in cryptographic applications.\n\nHere's a breakdown of how the function works:\n\n1. **Mask Calculation**:\n   - The function calculates two masks: `mask1` and `mask2`.\n   - `mask1` is computed as `0 - move`, which will be `0` if `move` is `0` and `-1` (or all bits set to `1`) if `move` is `1`.\n   - `mask2` is the bitwise negation of `mask1`.\n\n2. **Conditional Copying**:\n   - The function then uses these masks to conditionally copy values from `src` to `dst`.\n   - For each index from `0` to `3`, it computes:\n     ```c\n     dst[i] = (src[i] & mask1) ^ (dst[i] & mask2);\n     ```\n   - This means:\n     - If `move` is `1`, `mask1` will be `-1`, and the value from `src[i]` will be copied to `dst[i]`.\n     - If `move` is `0`, `mask1` will be `0`, and the value in `dst[i]` will remain unchanged.\n\n3. **Handling Larger Arrays**:\n   - If `P256_LIMBS` is `8`, the function performs the same operation for indices `4` to `7`.\n\n### Evaluation of the Bug Report\n\nThe bug report states that \"Value dst may be null; it should be checked before dereferencing.\" \n\n1. **Null Pointer Check**:\n   - The function does not perform any checks to ensure that `dst` is not a null pointer before attempting to dereference it. If `dst` is null, dereferencing it will lead to undefined behavior, typically resulting in a segmentation fault or crash.\n\n2. **Potential for Null Pointers**:\n   - The function assumes that valid pointers are passed to it. However, if the calling code does not ensure that `dst` is allocated and initialized properly, this could lead to a situation where `dst` is null.\n\n### Conclusion\n\nGiven the analysis, the bug report correctly identifies a potential issue in the code. The absence of a null check for the `dst` pointer before dereferencing it is indeed a significant oversight that could lead to runtime errors.\n\nThus, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);'}\nValue dst may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet contains a function named `copy_conditional`, which is designed to conditionally copy values from a source array (`src`) to a destination array (`dst`) based on a `move` parameter. The function operates on arrays of type `BN_ULONG`, which is typically a type used for large integers in cryptographic applications.\n\n### Explanation of the Code Behavior\n\n1. **Parameters**:\n   - `dst[P256_LIMBS]`: An array where the result will be stored.\n   - `src[P256_LIMBS]`: An array from which values may be copied.\n   - `move`: A value that determines whether to copy from `src` to `dst`.\n\n2. **Mask Calculation**:\n   - `mask1` is calculated as `0 - move`. If `move` is non-zero (true), `mask1` will be all bits set to 1 (i.e., `-1`), otherwise it will be 0.\n   - `mask2` is the bitwise negation of `mask1`, which will be all bits set to 0 if `move` is true, and all bits set to 1 if `move` is false.\n\n3. **Conditional Copying**:\n   - The function uses bitwise operations to conditionally copy values:\n     - If `move` is true, it copies values from `src` to `dst`.\n     - If `move` is false, it retains the existing values in `dst`.\n   - This is done for the first four elements of the arrays, and if `P256_LIMBS` is equal to 8, it continues to copy for the next four elements.\n\n### Analysis of the Bug Report\n\nThe bug report states that \"Value dst may be null; it should be checked before dereferencing.\" This implies that there is a concern that the `dst` pointer could be null, leading to a dereference error when attempting to access `dst[5]`.\n\n### Determining the Nature of the Bug\n\n1. **Null Pointer Check**:\n   - The function does not perform any checks to ensure that `dst` is not null before attempting to access its elements. If `dst` is null, dereferencing it will lead to undefined behavior, typically resulting in a segmentation fault or access violation.\n\n2. **Context of Use**:\n   - The function is likely used in a cryptographic context where the integrity of the data is crucial. If `dst` is null, it could lead to serious security vulnerabilities or crashes.\n\n### Conclusion\n\nGiven that the code does not check for a null pointer before dereferencing `dst`, and considering the potential consequences of such an oversight, the bug report accurately identifies a real issue in the code.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);'}\nValue src may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet defines a function `copy_conditional` that takes three parameters: `dst`, `src`, and `move`. The purpose of this function is to conditionally copy values from the `src` array to the `dst` array based on the value of `move`. \n\n1. **Parameters**:\n   - `dst[P256_LIMBS]`: An array where the result will be stored.\n   - `const BN_ULONG src[P256_LIMBS]`: An array from which values may be copied.\n   - `BN_ULONG move`: A value that determines whether to copy from `src` to `dst`.\n\n2. **Logic**:\n   - The function calculates two masks:\n     - `mask1 = 0 - move`: This will be `0` if `move` is `0`, and `-1` (or all bits set) if `move` is non-zero.\n     - `mask2 = ~mask1`: This will be `-1` if `move` is `0`, and `0` if `move` is non-zero.\n   - The function then uses these masks to conditionally copy values:\n     - If `move` is `0`, it will copy the values from `dst` to `dst` (effectively leaving them unchanged).\n     - If `move` is non-zero, it will copy values from `src` to `dst`.\n\n3. **Array Access**:\n   - The function accesses elements of the `src` array directly using indices (e.g., `src[0]`, `src[1]`, etc.). This is done without any null checks or bounds checking.\n\n### Bug Report Analysis\n\nThe bug report states: \"Value src may be null; it should be checked before dereferencing.\"\n\n### Determining the Bug\n\n1. **Null Pointer Dereference**:\n   - The code does not check if `src` is `NULL` before dereferencing it. If `src` is `NULL`, accessing `src[0]`, `src[1]`, etc., will lead to undefined behavior, typically resulting in a segmentation fault or access violation.\n\n2. **True Positive or False Positive**:\n   - Since the code directly dereferences `src` without checking for `NULL`, this is indeed a potential bug. If `src` is `NULL`, it will cause a runtime error.\n\n### Conclusion\n\nGiven the analysis, the bug report is valid. The absence of a null check for the `src` pointer before dereferencing it constitutes a real bug.\n\n**Label**: @@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[5] = (src[5] & mask1) ^ (dst[5] & mask2);'}\nValue dst may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    }
                ],
                "response": "### Code Behavior Explanation\n\nThe provided code snippet defines a function `copy_conditional` that performs a conditional copy of values from a source array (`src`) to a destination array (`dst`) based on a `move` parameter. The function uses bitwise operations to determine which values to copy based on the value of `move`.\n\n1. **Parameters**:\n   - `dst[P256_LIMBS]`: An array where the result will be stored.\n   - `src[P256_LIMBS]`: An array from which values may be copied.\n   - `move`: A value that determines whether to copy from `src` or retain the current value in `dst`.\n\n2. **Logic**:\n   - The function calculates two masks:\n     - `mask1 = 0 - move`: This will be `0` if `move` is `0`, and `-1` (or `0xFFFFFFFF...`) if `move` is `1`.\n     - `mask2 = ~mask1`: This will be `0xFFFFFFFF...` if `move` is `0`, and `0` if `move` is `1`.\n   - For each index in the arrays, it computes:\n     - `dst[i] = (src[i] & mask1) ^ (dst[i] & mask2)`: This means if `move` is `1`, it copies from `src`, otherwise it retains the value in `dst`.\n\n3. **Conditional Copy**:\n   - If `move` is `1`, the corresponding value from `src` is copied to `dst`.\n   - If `move` is `0`, the value in `dst` remains unchanged.\n\n### Bug Report Analysis\n\nThe bug report states that \"Value dst may be null; it should be checked before dereferencing.\" This implies that there is a concern that the `dst` pointer could be `NULL`, leading to a dereference error when trying to access `dst[i]`.\n\n### Determining True Positive or False Positive\n\n1. **Null Check**: The function does not perform any checks to ensure that `dst` is not `NULL` before attempting to access its elements. If `dst` is `NULL`, dereferencing it will lead to undefined behavior, likely causing a segmentation fault.\n\n2. **Function Usage Context**: The function is designed to be used in contexts where `dst` is expected to be a valid pointer to an array of `BN_ULONG`. However, without explicit checks, if it is called with a `NULL` pointer, it will indeed cause a crash.\n\n### Conclusion\n\nGiven that the code does not check for a `NULL` pointer before dereferencing `dst`, and that this could lead to a runtime error, the bug report is valid.\n\n**Label**: `@@@ real bug @@@`",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);'}\nValue dst may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet defines a function `copy_conditional` that takes three parameters: `dst`, `src`, and `move`. The purpose of this function is to conditionally copy values from the `src` array to the `dst` array based on the value of `move`. \n\n1. **Parameters**:\n   - `dst[P256_LIMBS]`: An array where the result will be stored.\n   - `src[P256_LIMBS]`: An array from which values may be copied.\n   - `move`: A value that determines whether to copy from `src` to `dst`.\n\n2. **Logic**:\n   - The function calculates two masks:\n     - `mask1 = 0 - move`: This will be `0` if `move` is `0`, and `-1` (or `0xFFFFFFFFFFFFFFFF` for unsigned types) if `move` is `1`.\n     - `mask2 = ~mask1`: This will be `-1` if `move` is `0`, and `0` if `move` is `1`.\n   - The function then uses these masks to conditionally copy values:\n     - If `move` is `1`, it copies values from `src` to `dst`.\n     - If `move` is `0`, it retains the existing values in `dst`.\n\n3. **Array Access**:\n   - The function accesses elements of `dst` and `src` arrays directly using indices. The code checks if `P256_LIMBS` is `8` to handle an additional set of elements.\n\n### Evaluation of the Bug Report\n\nThe bug report states that \"Value dst may be null; it should be checked before dereferencing.\" \n\n1. **Null Check**: \n   - The code does not perform any checks to ensure that `dst` is not null before dereferencing it. If `dst` is null, accessing `dst[0]`, `dst[1]`, etc., would lead to undefined behavior, likely causing a segmentation fault or access violation.\n\n2. **Context**:\n   - The function is designed to operate on arrays, and it is expected that the caller ensures that valid pointers are passed. However, the absence of checks for null pointers can lead to runtime errors if the function is called with a null pointer.\n\n### Conclusion\n\nGiven the analysis, the bug report correctly identifies a potential issue in the code. The lack of a null check for the `dst` pointer before dereferencing it is a genuine concern that could lead to crashes if `dst` is null.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);'}\nValue src may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet contains a function named `copy_conditional`, which is designed to conditionally copy values from a source array (`src`) to a destination array (`dst`) based on a `move` flag. The function operates on arrays of type `BN_ULONG`, which is typically a type used for large integers in cryptographic applications.\n\n### Code Behavior Explanation\n\n1. **Parameters**:\n   - `dst[P256_LIMBS]`: An array where the result will be stored.\n   - `src[P256_LIMBS]`: An array from which values will be copied.\n   - `move`: A flag that determines whether to copy values from `src` to `dst`.\n\n2. **Logic**:\n   - The function calculates two masks:\n     - `mask1 = 0 - move`: This will be `0` if `move` is `0`, and `-1` (or all bits set) if `move` is `1`.\n     - `mask2 = ~mask1`: This will be `-1` if `move` is `0`, and `0` if `move` is `1`.\n   - The function then uses these masks to conditionally copy values:\n     - If `move` is `1`, it copies values from `src` to `dst`.\n     - If `move` is `0`, it retains the existing values in `dst`.\n\n3. **Potential Issue**:\n   - The bug report states that the `src` pointer may be null and should be checked before dereferencing. If `src` is null, dereferencing it (as done in the lines like `dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);`) will lead to undefined behavior, likely causing a crash or memory access violation.\n\n### Bug Report Evaluation\n\nGiven the explanation of the code's behavior, the bug report is valid. The function does not check if `src` is null before attempting to access its elements. This oversight can lead to dereferencing a null pointer, which is a serious issue in C/C++ programming.\n\n### Conclusion\n\nBased on the analysis, the bug report is a true positive. The code should include a check to ensure that `src` is not null before proceeding with the dereferencing operations.\n\nLabel: `@@@ real bug @@@`",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[6] = (src[6] & mask1) ^ (dst[6] & mask2);'}\nValue dst may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet contains a function named `copy_conditional`, which is designed to conditionally copy values from a source array (`src`) to a destination array (`dst`) based on a `move` parameter. The function operates on arrays of type `BN_ULONG`, which is typically a type used for large integers in cryptographic applications.\n\n### Explanation of the Code Behavior\n\n1. **Parameters**:\n   - `dst[P256_LIMBS]`: An array where the result will be stored.\n   - `src[P256_LIMBS]`: An array from which values may be copied.\n   - `move`: A value that determines whether to copy from `src` to `dst`.\n\n2. **Mask Calculation**:\n   - `mask1` is calculated as `0 - move`. If `move` is non-zero (true), `mask1` will be all bits set to 1 (assuming a two's complement representation). If `move` is zero (false), `mask1` will be zero.\n   - `mask2` is the bitwise negation of `mask1`, which will be all bits set to 0 if `move` is true and all bits set to 1 if `move` is false.\n\n3. **Conditional Copying**:\n   - The function iterates over the elements of the `src` and `dst` arrays. For each index `i`, it computes:\n     ```c\n     dst[i] = (src[i] & mask1) ^ (dst[i] & mask2);\n     ```\n   - This means:\n     - If `move` is true (non-zero), `mask1` is all 1s, so `src[i]` is copied to `dst[i]`.\n     - If `move` is false (zero), `mask2` is all 1s, so `dst[i]` remains unchanged.\n\n4. **Handling of Array Size**:\n   - The function checks if `P256_LIMBS` is equal to 8 to handle an 8-element array. If so, it performs the same operation for the additional elements.\n\n### Evaluation of the Bug Report\n\nThe bug report states that \"Value dst may be null; it should be checked before dereferencing.\" \n\n1. **Null Pointer Check**:\n   - The function does not perform any checks to ensure that `dst` is not null before dereferencing it. If `dst` is null, dereferencing it will lead to undefined behavior, likely causing a segmentation fault or crash.\n\n2. **True Positive or False Positive**:\n   - Given that the function does not check for null pointers before dereferencing `dst`, this is indeed a potential source of runtime errors. Therefore, the bug report correctly identifies a real issue in the code.\n\n### Conclusion\n\nBased on the analysis, the bug report is valid, and the absence of a null check for the `dst` pointer is a genuine concern that could lead to crashes or undefined behavior.\n\nLabel: `@@@ real bug @@@`",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);'}\nValue dst may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet contains a function named `copy_conditional`, which is designed to conditionally copy values from a source array (`src`) to a destination array (`dst`) based on a `move` parameter. The function operates on arrays of type `BN_ULONG`, which is typically a type used for large integers in cryptographic applications.\n\n### Explanation of the Code Behavior\n\n1. **Parameters**:\n   - `dst[P256_LIMBS]`: An array where the result will be stored.\n   - `src[P256_LIMBS]`: An array from which values will be copied.\n   - `move`: A flag that determines whether to copy from `src` or retain the current value in `dst`.\n\n2. **Mask Calculation**:\n   - `mask1` is calculated as `0 - move`. If `move` is `1`, `mask1` becomes `-1` (which is all bits set to 1). If `move` is `0`, `mask1` becomes `0` (all bits set to 0).\n   - `mask2` is the bitwise negation of `mask1`, which means if `mask1` is all bits set to 1, `mask2` will be all bits set to 0, and vice versa.\n\n3. **Conditional Copying**:\n   - The function iterates over the elements of the `dst` and `src` arrays. For each index `i`, it computes:\n     ```c\n     dst[i] = (src[i] & mask1) ^ (dst[i] & mask2);\n     ```\n   - This means:\n     - If `move` is `1`, `mask1` is `-1`, so `src[i]` is copied to `dst[i]`.\n     - If `move` is `0`, `mask1` is `0`, so `dst[i]` retains its original value.\n\n4. **Handling of P256_LIMBS**:\n   - The function checks if `P256_LIMBS` is equal to `8` to handle additional elements in the arrays.\n\n### Bug Report Analysis\n\nThe bug report states: \"Value dst may be null; it should be checked before dereferencing.\"\n\n### Evaluation of the Bug Report\n\n1. **Null Check**: The code does not explicitly check if `dst` is `NULL` before dereferencing it. If `dst` is `NULL`, dereferencing it will lead to undefined behavior (likely a segmentation fault).\n\n2. **True Positive or False Positive**: \n   - The absence of a null check for `dst` is indeed a potential issue, as it can lead to dereferencing a null pointer if `dst` is not properly initialized before calling `copy_conditional`.\n   - Therefore, this is a valid concern and indicates a real bug in the code.\n\n### Conclusion\n\nGiven the analysis, the bug report correctly identifies a potential issue in the code. The lack of a null check for the `dst` pointer before dereferencing it is a genuine concern that could lead to runtime errors.\n\nThus, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);'}\nValue src may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    }
                ],
                "response": "The provided code snippet contains a function named `copy_conditional`, which is designed to conditionally copy values from a source array (`src`) to a destination array (`dst`) based on a `move` flag. The function operates on arrays of type `BN_ULONG`, which is typically a type used for large integers in cryptographic applications.\n\n### Explanation of the Code Behavior\n\n1. **Function Signature**: \n   ```c\n   static void copy_conditional(BN_ULONG dst[P256_LIMBS], const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n   ```\n   - `dst`: The destination array where values will be copied.\n   - `src`: The source array from which values will be copied.\n   - `move`: A flag that determines whether to copy values from `src` to `dst`.\n\n2. **Mask Calculation**:\n   ```c\n   BN_ULONG mask1 = 0 - move;\n   BN_ULONG mask2 = ~mask1;\n   ```\n   - `mask1` will be `0` if `move` is `0`, and `-1` (or all bits set) if `move` is `1`.\n   - `mask2` is the bitwise negation of `mask1`, which will be `-1` if `move` is `0` and `0` if `move` is `1`.\n\n3. **Conditional Copying**:\n   The function then performs the following operations:\n   ```c\n   dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n   dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n   dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n   dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n   if (P256_LIMBS == 8) {\n       dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n       dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n       dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n       dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n   }\n   ```\n   - For each element in the arrays, if `move` is `1`, the corresponding element from `src` is copied to `dst`. If `move` is `0`, the existing value in `dst` remains unchanged.\n\n### Evaluation of the Bug Report\n\nThe bug report states:\n```\nValue src may be null; it should be checked before dereferencing.\n```\n\n### Analysis of the Bug Report\n\n1. **Null Check**: The code does not check if `src` is `NULL` before dereferencing it. If `src` is `NULL`, attempting to access `src[i]` will lead to undefined behavior, likely causing a segmentation fault or access violation.\n\n2. **True Positive**: The absence of a null check for `src` is indeed a potential bug. If `src` is `NULL`, the function will attempt to dereference it, leading to a crash.\n\n### Conclusion\n\nGiven the analysis, the bug report correctly identifies a potential issue in the code. The lack of a null check for the `src` pointer before dereferencing it is a genuine concern that could lead to runtime errors.\n\nTherefore, the appropriate label for this situation is:\n```\n@@@ real bug @@@\n```",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    },
    {
        "result": [
            {
                "bug_report": "{'text': '\\t\\tdst[7] = (src[7] & mask1) ^ (dst[7] & mask2);'}\nValue dst may be null; it should be checked before dereferencing.",
                "code_snippet": [
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "433 static void ecp_nistz256_point_add_affine(P256_POINT *r,\n434                                           const P256_POINT *a,\n435                                           const P256_POINT_AFFINE *b)\n436 {\n437     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n438     BN_ULONG Z1sqr[P256_LIMBS];\n439     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n440     BN_ULONG Hsqr[P256_LIMBS];\n441     BN_ULONG Rsqr[P256_LIMBS];\n442     BN_ULONG Hcub[P256_LIMBS];\n443\n444     BN_ULONG res_x[P256_LIMBS];\n445     BN_ULONG res_y[P256_LIMBS];\n446     BN_ULONG res_z[P256_LIMBS];\n447\n448     BN_ULONG in1infty, in2infty;\n449\n450     const BN_ULONG *in1_x = a->X;\n451     const BN_ULONG *in1_y = a->Y;\n452     const BN_ULONG *in1_z = a->Z;\n453\n454     const BN_ULONG *in2_x = b->X;\n455     const BN_ULONG *in2_y = b->Y;\n456\n457     /*\n458      * Infinity in encoded as (,,0)\n459      */\n460     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n461     if (P256_LIMBS == 8)\n462         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n463\n464     /*\n465      * In affine representation we encode infinity as (0,0), which is\n466      * not on the curve, so it is OK\n467      */\n468     in2infty = (in2_x[0] | in2_x[1] | in2_x[2] | in2_x[3] |\n469                 in2_y[0] | in2_y[1] | in2_y[2] | in2_y[3]);\n470     if (P256_LIMBS == 8)\n471         in2infty |= (in2_x[4] | in2_x[5] | in2_x[6] | in2_x[7] |\n472                      in2_y[4] | in2_y[5] | in2_y[6] | in2_y[7]);\n473\n474     in1infty = is_zero(in1infty);\n475     in2infty = is_zero(in2infty);\n476\n477     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n478\n479     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n480     ecp_nistz256_sub(H, U2, in1_x);             /* H = U2 - U1 */\n481\n482     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n483\n484     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n485\n486     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n487     ecp_nistz256_sub(R, S2, in1_y);             /* R = S2 - S1 */\n488\n489     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n490     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n491     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n492\n493     ecp_nistz256_mul_mont(U2, in1_x, Hsqr);     /* U1*H^2 */\n494     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n495\n496     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n497     ecp_nistz256_sub(res_x, res_x, Hcub);\n498     ecp_nistz256_sub(H, U2, res_x);\n499\n500     ecp_nistz256_mul_mont(S2, in1_y, Hcub);\n501     ecp_nistz256_mul_mont(H, H, R);\n502     ecp_nistz256_sub(res_y, H, S2);\n503\n504     copy_conditional(res_x, in2_x, in1infty);\n505     copy_conditional(res_x, in1_x, in2infty);\n506\n507     copy_conditional(res_y, in2_y, in1infty);\n508     copy_conditional(res_y, in1_y, in2infty);\n509\n510     copy_conditional(res_z, ONE, in1infty);\n511     copy_conditional(res_z, in1_z, in2infty);\n512\n513     memcpy(r->X, res_x, sizeof(res_x));\n514     memcpy(r->Y, res_y, sizeof(res_y));\n515     memcpy(r->Z, res_z, sizeof(res_z));\n516 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1373 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1374                       const felem_bytearray scalars[],\n1375                       const unsigned int num_points, const u8 *g_scalar,\n1376                       const int mixed, const felem pre_comp[][17][3],\n1377                       const felem g_pre_comp[16][3])\n1378 {\n1379     int i, skip;\n1380     unsigned int num, gen_mul = (g_scalar != NULL);\n1381     felem nq[3], tmp[4];\n1382     limb bits;\n1383     u8 sign, digit;\n1384\n1385     /* set nq to the point at infinity */\n1386     memset(nq, 0, sizeof(nq));\n1387\n1388     /*\n1389      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1390      * of the generator (last quarter of rounds) and additions of other\n1391      * points multiples (every 5th round).\n1392      */\n1393     skip = 1;                   /* save two point operations in the first\n1394                                  * round */\n1395     for (i = (num_points ? 380 : 98); i >= 0; --i) {\n1396         /* double */\n1397         if (!skip)\n1398             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1399\n1400         /* add multiples of the generator */\n1401         if (gen_mul && (i <= 98)) {\n1402             bits = get_bit(g_scalar, i + 285) << 3;\n1403             if (i < 95) {\n1404                 bits |= get_bit(g_scalar, i + 190) << 2;\n1405                 bits |= get_bit(g_scalar, i + 95) << 1;\n1406                 bits |= get_bit(g_scalar, i);\n1407             }\n1408             /* select the point to add, in constant time */\n1409             select_point(bits, 16, g_pre_comp, tmp);\n1410             if (!skip) {\n1411                 /* The 1 argument below is for \"mixed\" */\n1412                 point_add(nq[0],  nq[1],  nq[2],\n1413                           nq[0],  nq[1],  nq[2], 1,\n1414                           tmp[0], tmp[1], tmp[2]);\n1415             } else {\n1416                 memcpy(nq, tmp, 3 * sizeof(felem));\n1417                 skip = 0;\n1418             }\n1419         }\n1420\n1421         /* do other additions every 5 doublings */\n1422         if (num_points && (i % 5 == 0)) {\n1423             /* loop over all scalars */\n1424             for (num = 0; num < num_points; ++num) {\n1425                 bits = get_bit(scalars[num], i + 4) << 5;\n1426                 bits |= get_bit(scalars[num], i + 3) << 4;\n1427                 bits |= get_bit(scalars[num], i + 2) << 3;\n1428                 bits |= get_bit(scalars[num], i + 1) << 2;\n1429                 bits |= get_bit(scalars[num], i) << 1;\n1430                 bits |= get_bit(scalars[num], i - 1);\n1431                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1432\n1433                 /*\n1434                  * select the point to add or subtract, in constant time\n1435                  */\n1436                 select_point(digit, 17, pre_comp[num], tmp);\n1437                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1438                                             * point */\n1439                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1440\n1441                 if (!skip) {\n1442                     point_add(nq[0],  nq[1],  nq[2],\n1443                               nq[0],  nq[1],  nq[2], mixed,\n1444                               tmp[0], tmp[1], tmp[2]);\n1445                 } else {\n1446                     memcpy(nq, tmp, 3 * sizeof(felem));\n1447                     skip = 0;\n1448                 }\n1449             }\n1450         }\n1451     }\n1452     felem_assign(x_out, nq[0]);\n1453     felem_assign(y_out, nq[1]);\n1454     felem_assign(z_out, nq[2]);\n1455 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "607 __owur static int ecp_nistz256_windowed_mul(const EC_GROUP *group,\n608                                             P256_POINT *r,\n609                                             const BIGNUM **scalar,\n610                                             const EC_POINT **point,\n611                                             size_t num, BN_CTX *ctx)\n612 {\n613     size_t i;\n614     int j, ret = 0;\n615     unsigned int idx;\n616     unsigned char (*p_str)[33] = NULL;\n617     const unsigned int window_size = 5;\n618     const unsigned int mask = (1 << (window_size + 1)) - 1;\n619     unsigned int wvalue;\n620     P256_POINT *temp;           /* place for 5 temporary points */\n621     const BIGNUM **scalars = NULL;\n622     P256_POINT (*table)[16] = NULL;\n623     void *table_storage = NULL;\n624\n625     if ((num * 16 + 6) > OPENSSL_MALLOC_MAX_NELEMS(P256_POINT)\n626         || (table_storage =\n627             OPENSSL_malloc((num * 16 + 5) * sizeof(P256_POINT) + 64)) == NULL\n628         || (p_str =\n629             OPENSSL_malloc(num * 33 * sizeof(unsigned char))) == NULL\n630         || (scalars = OPENSSL_malloc(num * sizeof(BIGNUM *))) == NULL)\n631         goto err;\n632\n633     table = (void *)ALIGNPTR(table_storage, 64);\n634     temp = (P256_POINT *)(table + num);\n635\n636     for (i = 0; i < num; i++) {\n637         P256_POINT *row = table[i];\n638\n639         /* This is an unusual input, we don't guarantee constant-timeness. */\n640         if ((BN_num_bits(scalar[i]) > 256) || BN_is_negative(scalar[i])) {\n641             BIGNUM *mod;\n642\n643             if ((mod = BN_CTX_get(ctx)) == NULL)\n644                 goto err;\n645             if (!BN_nnmod(mod, scalar[i], group->order, ctx)) {\n646                 ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n647                 goto err;\n648             }\n649             scalars[i] = mod;\n650         } else\n651             scalars[i] = scalar[i];\n652\n653         for (j = 0; j < bn_get_top(scalars[i]) * BN_BYTES; j += BN_BYTES) {\n654             BN_ULONG d = bn_get_words(scalars[i])[j / BN_BYTES];\n655\n656             p_str[i][j + 0] = (unsigned char)d;\n657             p_str[i][j + 1] = (unsigned char)(d >> 8);\n658             p_str[i][j + 2] = (unsigned char)(d >> 16);\n659             p_str[i][j + 3] = (unsigned char)(d >>= 24);\n660             if (BN_BYTES == 8) {\n661                 d >>= 8;\n662                 p_str[i][j + 4] = (unsigned char)d;\n663                 p_str[i][j + 5] = (unsigned char)(d >> 8);\n664                 p_str[i][j + 6] = (unsigned char)(d >> 16);\n665                 p_str[i][j + 7] = (unsigned char)(d >> 24);\n666             }\n667         }\n668         for (; j < 33; j++)\n669             p_str[i][j] = 0;\n670\n671         if (!ecp_nistz256_bignum_to_field_elem(temp[0].X, point[i]->X)\n672             || !ecp_nistz256_bignum_to_field_elem(temp[0].Y, point[i]->Y)\n673             || !ecp_nistz256_bignum_to_field_elem(temp[0].Z, point[i]->Z)) {\n674             ERR_raise(ERR_LIB_EC, EC_R_COORDINATES_OUT_OF_RANGE);\n675             goto err;\n676         }\n677\n678         /*\n679          * row[0] is implicitly (0,0,0) (the point at infinity), therefore it\n680          * is not stored. All other values are actually stored with an offset\n681          * of -1 in table.\n682          */\n683\n684         ecp_nistz256_scatter_w5  (row, &temp[0], 1);\n685         ecp_nistz256_point_double(&temp[1], &temp[0]);              /*1+1=2  */\n686         ecp_nistz256_scatter_w5  (row, &temp[1], 2);\n687         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*2+1=3  */\n688         ecp_nistz256_scatter_w5  (row, &temp[2], 3);\n689         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*2=4  */\n690         ecp_nistz256_scatter_w5  (row, &temp[1], 4);\n691         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*3=6  */\n692         ecp_nistz256_scatter_w5  (row, &temp[2], 6);\n693         ecp_nistz256_point_add   (&temp[3], &temp[1], &temp[0]);    /*4+1=5  */\n694         ecp_nistz256_scatter_w5  (row, &temp[3], 5);\n695         ecp_nistz256_point_add   (&temp[4], &temp[2], &temp[0]);    /*6+1=7  */\n696         ecp_nistz256_scatter_w5  (row, &temp[4], 7);\n697         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*4=8  */\n698         ecp_nistz256_scatter_w5  (row, &temp[1], 8);\n699         ecp_nistz256_point_double(&temp[2], &temp[2]);              /*2*6=12 */\n700         ecp_nistz256_scatter_w5  (row, &temp[2], 12);\n701         ecp_nistz256_point_double(&temp[3], &temp[3]);              /*2*5=10 */\n702         ecp_nistz256_scatter_w5  (row, &temp[3], 10);\n703         ecp_nistz256_point_double(&temp[4], &temp[4]);              /*2*7=14 */\n704         ecp_nistz256_scatter_w5  (row, &temp[4], 14);\n705         ecp_nistz256_point_add   (&temp[2], &temp[2], &temp[0]);    /*12+1=13*/\n706         ecp_nistz256_scatter_w5  (row, &temp[2], 13);\n707         ecp_nistz256_point_add   (&temp[3], &temp[3], &temp[0]);    /*10+1=11*/\n708         ecp_nistz256_scatter_w5  (row, &temp[3], 11);\n709         ecp_nistz256_point_add   (&temp[4], &temp[4], &temp[0]);    /*14+1=15*/\n710         ecp_nistz256_scatter_w5  (row, &temp[4], 15);\n711         ecp_nistz256_point_add   (&temp[2], &temp[1], &temp[0]);    /*8+1=9  */\n712         ecp_nistz256_scatter_w5  (row, &temp[2], 9);\n713         ecp_nistz256_point_double(&temp[1], &temp[1]);              /*2*8=16 */\n714         ecp_nistz256_scatter_w5  (row, &temp[1], 16);\n715     }\n716\n717     idx = 255;\n718\n719     wvalue = p_str[0][(idx - 1) / 8];\n720     wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n721\n722     /*\n723      * We gather to temp[0], because we know it's position relative\n724      * to table\n725      */\n726     ecp_nistz256_gather_w5(&temp[0], table[0], _booth_recode_w5(wvalue) >> 1);\n727     memcpy(r, &temp[0], sizeof(temp[0]));\n728\n729     while (idx >= 5) {\n730         for (i = (idx == 255 ? 1 : 0); i < num; i++) {\n731             unsigned int off = (idx - 1) / 8;\n732\n733             wvalue = p_str[i][off] | p_str[i][off + 1] << 8;\n734             wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n735\n736             wvalue = _booth_recode_w5(wvalue);\n737\n738             ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n739\n740             ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n741             copy_conditional(temp[0].Y, temp[1].Y, (wvalue & 1));\n742\n743             ecp_nistz256_point_add(r, r, &temp[0]);\n744         }\n745\n746         idx -= window_size;\n747\n748         ecp_nistz256_point_double(r, r);\n749         ecp_nistz256_point_double(r, r);\n750         ecp_nistz256_point_double(r, r);\n751         ecp_nistz256_point_double(r, r);\n752         ecp_nistz256_point_double(r, r);\n753     }\n754\n755     /* Final window */\n756     for (i = 0; i < num; i++) {\n757         wvalue = p_str[i][0];\n758         wvalue = (wvalue << 1) & mask;\n759\n760         wvalue = _booth_recode_w5(wvalue);\n761\n762         ecp_nistz256_gather_w5(&temp[0], table[i], wvalue >> 1);\n763\n764         ecp_nistz256_neg(temp[1].Y, temp[0].Y);\n765         copy_conditional(temp[0].Y, temp[1].Y, wvalue & 1);\n766\n767         ecp_nistz256_point_add(r, r, &temp[0]);\n768     }\n769\n770     ret = 1;\n771  err:\n772     OPENSSL_free(table_storage);\n773     OPENSSL_free(p_str);\n774     OPENSSL_free(scalars);\n775     return ret;\n776 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "939  __owur static int ecp_nistz256_points_mul(const EC_GROUP *group,\n940                                            EC_POINT *r,\n941                                            const BIGNUM *scalar,\n942                                            size_t num,\n943                                            const EC_POINT *points[],\n944                                            const BIGNUM *scalars[], BN_CTX *ctx)\n945  {\n946      int i = 0, ret = 0, no_precomp_for_generator = 0, p_is_infinity = 0;\n947      unsigned char p_str[33] = { 0 };\n948      const PRECOMP256_ROW *preComputedTable = NULL;\n949      const NISTZ256_PRE_COMP *pre_comp = NULL;\n950      const EC_POINT *generator = NULL;\n951      const BIGNUM **new_scalars = NULL;\n952      const EC_POINT **new_points = NULL;\n953      unsigned int idx = 0;\n954      const unsigned int window_size = 7;\n955      const unsigned int mask = (1 << (window_size + 1)) - 1;\n956      unsigned int wvalue;\n957      ALIGN32 union {\n958          P256_POINT p;\n959          P256_POINT_AFFINE a;\n960      } t, p;\n961      BIGNUM *tmp_scalar;\n962\n963      if ((num + 1) == 0 || (num + 1) > OPENSSL_MALLOC_MAX_NELEMS(void *)) {\n964          ERR_raise(ERR_LIB_EC, ERR_R_PASSED_INVALID_ARGUMENT);\n965          return 0;\n966      }\n967\n968      memset(&p, 0, sizeof(p));\n969      BN_CTX_start(ctx);\n970\n971      if (scalar) {\n972          generator = EC_GROUP_get0_generator(group);\n973          if (generator == NULL) {\n974              ERR_raise(ERR_LIB_EC, EC_R_UNDEFINED_GENERATOR);\n975              goto err;\n976          }\n977\n978          /* look if we can use precomputed multiples of generator */\n979          pre_comp = group->pre_comp.nistz256;\n980\n981          if (pre_comp) {\n982              /*\n983               * If there is a precomputed table for the generator, check that\n984               * it was generated with the same generator.\n985               */\n986              EC_POINT *pre_comp_generator = EC_POINT_new(group);\n987              if (pre_comp_generator == NULL)\n988                  goto err;\n989\n990              ecp_nistz256_gather_w7(&p.a, pre_comp->precomp[0], 1);\n991              if (!ecp_nistz256_set_from_affine(pre_comp_generator,\n992                                                group, &p.a, ctx)) {\n993                  EC_POINT_free(pre_comp_generator);\n994                  goto err;\n995              }\n996\n997              if (0 == EC_POINT_cmp(group, generator, pre_comp_generator, ctx))\n998                  preComputedTable = (const PRECOMP256_ROW *)pre_comp->precomp;\n999\n1000             EC_POINT_free(pre_comp_generator);\n1001         }\n1002\n1003         if (preComputedTable == NULL && ecp_nistz256_is_affine_G(generator)) {\n1004             /*\n1005              * If there is no precomputed data, but the generator is the\n1006              * default, a hardcoded table of precomputed data is used. This\n1007              * is because applications, such as Apache, do not use\n1008              * EC_KEY_precompute_mult.\n1009              */\n1010             preComputedTable = ecp_nistz256_precomputed;\n1011         }\n1012\n1013         if (preComputedTable) {\n1014             BN_ULONG infty;\n1015\n1016             if ((BN_num_bits(scalar) > 256)\n1017                 || BN_is_negative(scalar)) {\n1018                 if ((tmp_scalar = BN_CTX_get(ctx)) == NULL)\n1019                     goto err;\n1020\n1021                 if (!BN_nnmod(tmp_scalar, scalar, group->order, ctx)) {\n1022                     ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);\n1023                     goto err;\n1024                 }\n1025                 scalar = tmp_scalar;\n1026             }\n1027\n1028             for (i = 0; i < bn_get_top(scalar) * BN_BYTES; i += BN_BYTES) {\n1029                 BN_ULONG d = bn_get_words(scalar)[i / BN_BYTES];\n1030\n1031                 p_str[i + 0] = (unsigned char)d;\n1032                 p_str[i + 1] = (unsigned char)(d >> 8);\n1033                 p_str[i + 2] = (unsigned char)(d >> 16);\n1034                 p_str[i + 3] = (unsigned char)(d >>= 24);\n1035                 if (BN_BYTES == 8) {\n1036                     d >>= 8;\n1037                     p_str[i + 4] = (unsigned char)d;\n1038                     p_str[i + 5] = (unsigned char)(d >> 8);\n1039                     p_str[i + 6] = (unsigned char)(d >> 16);\n1040                     p_str[i + 7] = (unsigned char)(d >> 24);\n1041                 }\n1042             }\n1043\n1044             for (; i < 33; i++)\n1045                 p_str[i] = 0;\n1046\n1047             /* First window */\n1048             wvalue = (p_str[0] << 1) & mask;\n1049             idx += window_size;\n1050\n1051             wvalue = _booth_recode_w7(wvalue);\n1052\n1053             ecp_nistz256_gather_w7(&p.a, preComputedTable[0],\n1054                                    wvalue >> 1);\n1055\n1056             ecp_nistz256_neg(p.p.Z, p.p.Y);\n1057             copy_conditional(p.p.Y, p.p.Z, wvalue & 1);\n1058\n1059             /*\n1060              * Since affine infinity is encoded as (0,0) and\n1061              * Jacobian is (,,0), we need to harmonize them\n1062              * by assigning \"one\" or zero to Z.\n1063              */\n1064             infty = (p.p.X[0] | p.p.X[1] | p.p.X[2] | p.p.X[3] |\n1065                      p.p.Y[0] | p.p.Y[1] | p.p.Y[2] | p.p.Y[3]);\n1066             if (P256_LIMBS == 8)\n1067                 infty |= (p.p.X[4] | p.p.X[5] | p.p.X[6] | p.p.X[7] |\n1068                           p.p.Y[4] | p.p.Y[5] | p.p.Y[6] | p.p.Y[7]);\n1069\n1070             infty = 0 - is_zero(infty);\n1071             infty = ~infty;\n1072\n1073             p.p.Z[0] = ONE[0] & infty;\n1074             p.p.Z[1] = ONE[1] & infty;\n1075             p.p.Z[2] = ONE[2] & infty;\n1076             p.p.Z[3] = ONE[3] & infty;\n1077             if (P256_LIMBS == 8) {\n1078                 p.p.Z[4] = ONE[4] & infty;\n1079                 p.p.Z[5] = ONE[5] & infty;\n1080                 p.p.Z[6] = ONE[6] & infty;\n1081                 p.p.Z[7] = ONE[7] & infty;\n1082             }\n1083\n1084             for (i = 1; i < 37; i++) {\n1085                 unsigned int off = (idx - 1) / 8;\n1086                 wvalue = p_str[off] | p_str[off + 1] << 8;\n1087                 wvalue = (wvalue >> ((idx - 1) % 8)) & mask;\n1088                 idx += window_size;\n1089\n1090                 wvalue = _booth_recode_w7(wvalue);\n1091\n1092                 ecp_nistz256_gather_w7(&t.a,\n1093                                        preComputedTable[i], wvalue >> 1);\n1094\n1095                 ecp_nistz256_neg(t.p.Z, t.a.Y);\n1096                 copy_conditional(t.a.Y, t.p.Z, wvalue & 1);\n1097\n1098                 ecp_nistz256_point_add_affine(&p.p, &p.p, &t.a);\n1099             }\n1100         } else {\n1101             p_is_infinity = 1;\n1102             no_precomp_for_generator = 1;\n1103         }\n1104     } else\n1105         p_is_infinity = 1;\n1106\n1107     if (no_precomp_for_generator) {\n1108         /*\n1109          * Without a precomputed table for the generator, it has to be\n1110          * handled like a normal point.\n1111          */\n1112         new_scalars = OPENSSL_malloc((num + 1) * sizeof(BIGNUM *));\n1113         if (new_scalars == NULL)\n1114             goto err;\n1115\n1116         new_points = OPENSSL_malloc((num + 1) * sizeof(EC_POINT *));\n1117         if (new_points == NULL)\n1118             goto err;\n1119\n1120         memcpy(new_scalars, scalars, num * sizeof(BIGNUM *));\n1121         new_scalars[num] = scalar;\n1122         memcpy(new_points, points, num * sizeof(EC_POINT *));\n1123         new_points[num] = generator;\n1124\n1125         scalars = new_scalars;\n1126         points = new_points;\n1127         num++;\n1128     }\n1129\n1130     if (num) {\n1131         P256_POINT *out = &t.p;\n1132         if (p_is_infinity)\n1133             out = &p.p;\n1134\n1135         if (!ecp_nistz256_windowed_mul(group, out, scalars, points, num, ctx))\n1136             goto err;\n1137\n1138         if (!p_is_infinity)\n1139             ecp_nistz256_point_add(&p.p, &p.p, out);\n1140     }\n1141\n1142     /* Not constant-time, but we're only operating on the public output. */\n1143     if (!bn_set_words(r->X, p.p.X, P256_LIMBS) ||\n1144         !bn_set_words(r->Y, p.p.Y, P256_LIMBS) ||\n1145         !bn_set_words(r->Z, p.p.Z, P256_LIMBS)) {\n1146         goto err;\n1147     }\n1148     r->Z_is_one = is_one(r->Z) & 1;\n1149\n1150     ret = 1;\n1151\n1152 err:\n1153     BN_CTX_end(ctx);\n1154     OPENSSL_free(new_points);\n1155     OPENSSL_free(new_scalars);\n1156     return ret;\n1157 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1205 static void point_add(felem x3, felem y3, felem z3,\n1206                       const felem x1, const felem y1, const felem z1,\n1207                       const int mixed, const felem x2, const felem y2,\n1208                       const felem z2)\n1209 {\n1210     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1211     largefelem tmp, tmp2;\n1212     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1213     limb points_equal;\n1214\n1215     z1_is_zero = felem_is_zero(z1);\n1216     z2_is_zero = felem_is_zero(z2);\n1217\n1218     /* ftmp = z1z1 = z1**2 */\n1219     felem_square(tmp, z1);\n1220     felem_reduce(ftmp, tmp);\n1221\n1222     if (!mixed) {\n1223         /* ftmp2 = z2z2 = z2**2 */\n1224         felem_square(tmp, z2);\n1225         felem_reduce(ftmp2, tmp);\n1226\n1227         /* u1 = ftmp3 = x1*z2z2 */\n1228         felem_mul(tmp, x1, ftmp2);\n1229         felem_reduce(ftmp3, tmp);\n1230\n1231         /* ftmp5 = z1 + z2 */\n1232         felem_assign(ftmp5, z1);\n1233         felem_sum64(ftmp5, z2);\n1234         /* ftmp5[i] < 2^61 */\n1235\n1236         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1237         felem_square(tmp, ftmp5);\n1238         /* tmp[i] < 17*2^122 */\n1239         felem_diff_128_64(tmp, ftmp);\n1240         /* tmp[i] < 17*2^122 + 2^63 */\n1241         felem_diff_128_64(tmp, ftmp2);\n1242         /* tmp[i] < 17*2^122 + 2^64 */\n1243         felem_reduce(ftmp5, tmp);\n1244\n1245         /* ftmp2 = z2 * z2z2 */\n1246         felem_mul(tmp, ftmp2, z2);\n1247         felem_reduce(ftmp2, tmp);\n1248\n1249         /* s1 = ftmp6 = y1 * z2**3 */\n1250         felem_mul(tmp, y1, ftmp2);\n1251         felem_reduce(ftmp6, tmp);\n1252     } else {\n1253         /*\n1254          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1255          */\n1256\n1257         /* u1 = ftmp3 = x1*z2z2 */\n1258         felem_assign(ftmp3, x1);\n1259\n1260         /* ftmp5 = 2*z1z2 */\n1261         felem_scalar(ftmp5, z1, 2);\n1262\n1263         /* s1 = ftmp6 = y1 * z2**3 */\n1264         felem_assign(ftmp6, y1);\n1265     }\n1266\n1267     /* u2 = x2*z1z1 */\n1268     felem_mul(tmp, x2, ftmp);\n1269     /* tmp[i] < 17*2^120 */\n1270\n1271     /* h = ftmp4 = u2 - u1 */\n1272     felem_diff_128_64(tmp, ftmp3);\n1273     /* tmp[i] < 17*2^120 + 2^63 */\n1274     felem_reduce(ftmp4, tmp);\n1275\n1276     x_equal = felem_is_zero(ftmp4);\n1277\n1278     /* z_out = ftmp5 * h */\n1279     felem_mul(tmp, ftmp5, ftmp4);\n1280     felem_reduce(z_out, tmp);\n1281\n1282     /* ftmp = z1 * z1z1 */\n1283     felem_mul(tmp, ftmp, z1);\n1284     felem_reduce(ftmp, tmp);\n1285\n1286     /* s2 = tmp = y2 * z1**3 */\n1287     felem_mul(tmp, y2, ftmp);\n1288     /* tmp[i] < 17*2^120 */\n1289\n1290     /* r = ftmp5 = (s2 - s1)*2 */\n1291     felem_diff_128_64(tmp, ftmp6);\n1292     /* tmp[i] < 17*2^120 + 2^63 */\n1293     felem_reduce(ftmp5, tmp);\n1294     y_equal = felem_is_zero(ftmp5);\n1295     felem_scalar64(ftmp5, 2);\n1296     /* ftmp5[i] < 2^61 */\n1297\n1298     /*\n1299      * The formulae are incorrect if the points are equal, in affine coordinates\n1300      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1301      * happens.\n1302      *\n1303      * We use bitwise operations to avoid potential side-channels introduced by\n1304      * the short-circuiting behaviour of boolean operators.\n1305      *\n1306      * The special case of either point being the point at infinity (z1 and/or\n1307      * z2 are zero), is handled separately later on in this function, so we\n1308      * avoid jumping to point_double here in those special cases.\n1309      *\n1310      * Notice the comment below on the implications of this branching for timing\n1311      * leaks and why it is considered practically irrelevant.\n1312      */\n1313     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1314\n1315     if (points_equal) {\n1316         /*\n1317          * This is obviously not constant-time but it will almost-never happen\n1318          * for ECDH / ECDSA. The case where it can happen is during scalar-mult\n1319          * where the intermediate value gets very close to the group order.\n1320          * Since |ossl_ec_GFp_nistp_recode_scalar_bits| produces signed digits\n1321          * for the scalar, it's possible for the intermediate value to be a small\n1322          * negative multiple of the base point, and for the final signed digit\n1323          * to be the same value. We believe that this only occurs for the scalar\n1324          * 1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n1325          * ffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb\n1326          * 71e913863f7, in that case the penultimate intermediate is -9G and\n1327          * the final digit is also -9G. Since this only happens for a single\n1328          * scalar, the timing leak is irrelevant. (Any attacker who wanted to\n1329          * check whether a secret scalar was that exact value, can already do\n1330          * so.)\n1331          */\n1332         point_double(x3, y3, z3, x1, y1, z1);\n1333         return;\n1334     }\n1335\n1336     /* I = ftmp = (2h)**2 */\n1337     felem_assign(ftmp, ftmp4);\n1338     felem_scalar64(ftmp, 2);\n1339     /* ftmp[i] < 2^61 */\n1340     felem_square(tmp, ftmp);\n1341     /* tmp[i] < 17*2^122 */\n1342     felem_reduce(ftmp, tmp);\n1343\n1344     /* J = ftmp2 = h * I */\n1345     felem_mul(tmp, ftmp4, ftmp);\n1346     felem_reduce(ftmp2, tmp);\n1347\n1348     /* V = ftmp4 = U1 * I */\n1349     felem_mul(tmp, ftmp3, ftmp);\n1350     felem_reduce(ftmp4, tmp);\n1351\n1352     /* x_out = r**2 - J - 2V */\n1353     felem_square(tmp, ftmp5);\n1354     /* tmp[i] < 17*2^122 */\n1355     felem_diff_128_64(tmp, ftmp2);\n1356     /* tmp[i] < 17*2^122 + 2^63 */\n1357     felem_assign(ftmp3, ftmp4);\n1358     felem_scalar64(ftmp4, 2);\n1359     /* ftmp4[i] < 2^61 */\n1360     felem_diff_128_64(tmp, ftmp4);\n1361     /* tmp[i] < 17*2^122 + 2^64 */\n1362     felem_reduce(x_out, tmp);\n1363\n1364     /* y_out = r(V-x_out) - 2 * s1 * J */\n1365     felem_diff64(ftmp3, x_out);\n1366     /*\n1367      * ftmp3[i] < 2^60 + 2^60 = 2^61\n1368      */\n1369     felem_mul(tmp, ftmp5, ftmp3);\n1370     /* tmp[i] < 17*2^122 */\n1371     felem_mul(tmp2, ftmp6, ftmp2);\n1372     /* tmp2[i] < 17*2^120 */\n1373     felem_scalar128(tmp2, 2);\n1374     /* tmp2[i] < 17*2^121 */\n1375     felem_diff128(tmp, tmp2);\n1376         /*-\n1377          * tmp[i] < 2^127 - 2^69 + 17*2^122\n1378          *        = 2^126 - 2^122 - 2^6 - 2^2 - 1\n1379          *        < 2^127\n1380          */\n1381     felem_reduce(y_out, tmp);\n1382\n1383     copy_conditional(x_out, x2, z1_is_zero);\n1384     copy_conditional(x_out, x1, z2_is_zero);\n1385     copy_conditional(y_out, y2, z1_is_zero);\n1386     copy_conditional(y_out, y1, z2_is_zero);\n1387     copy_conditional(z_out, z2, z1_is_zero);\n1388     copy_conditional(z_out, z1, z2_is_zero);\n1389     felem_assign(x3, x_out);\n1390     felem_assign(y3, y_out);\n1391     felem_assign(z3, z_out);\n1392 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "1138 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1139                       const felem_bytearray scalars[],\n1140                       const unsigned num_points, const u8 *g_scalar,\n1141                       const int mixed, const felem pre_comp[][17][3],\n1142                       const felem g_pre_comp[2][16][3])\n1143 {\n1144     int i, skip;\n1145     unsigned num;\n1146     unsigned gen_mul = (g_scalar != NULL);\n1147     felem nq[3], tmp[4];\n1148     u64 bits;\n1149     u8 sign, digit;\n1150\n1151     /* set nq to the point at infinity */\n1152     memset(nq, 0, sizeof(nq));\n1153\n1154     /*\n1155      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1156      * of the generator (two in each of the last 28 rounds) and additions of\n1157      * other points multiples (every 5th round).\n1158      */\n1159     skip = 1;                   /* save two point operations in the first\n1160                                  * round */\n1161     for (i = (num_points ? 220 : 27); i >= 0; --i) {\n1162         /* double */\n1163         if (!skip)\n1164             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1165\n1166         /* add multiples of the generator */\n1167         if (gen_mul && (i <= 27)) {\n1168             /* first, look 28 bits upwards */\n1169             bits = get_bit(g_scalar, i + 196) << 3;\n1170             bits |= get_bit(g_scalar, i + 140) << 2;\n1171             bits |= get_bit(g_scalar, i + 84) << 1;\n1172             bits |= get_bit(g_scalar, i + 28);\n1173             /* select the point to add, in constant time */\n1174             select_point(bits, 16, g_pre_comp[1], tmp);\n1175\n1176             if (!skip) {\n1177                 /* value 1 below is argument for \"mixed\" */\n1178                 point_add(nq[0], nq[1], nq[2],\n1179                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1180             } else {\n1181                 memcpy(nq, tmp, 3 * sizeof(felem));\n1182                 skip = 0;\n1183             }\n1184\n1185             /* second, look at the current position */\n1186             bits = get_bit(g_scalar, i + 168) << 3;\n1187             bits |= get_bit(g_scalar, i + 112) << 2;\n1188             bits |= get_bit(g_scalar, i + 56) << 1;\n1189             bits |= get_bit(g_scalar, i);\n1190             /* select the point to add, in constant time */\n1191             select_point(bits, 16, g_pre_comp[0], tmp);\n1192             point_add(nq[0], nq[1], nq[2],\n1193                       nq[0], nq[1], nq[2],\n1194                       1 /* mixed */ , tmp[0], tmp[1], tmp[2]);\n1195         }\n1196\n1197         /* do other additions every 5 doublings */\n1198         if (num_points && (i % 5 == 0)) {\n1199             /* loop over all scalars */\n1200             for (num = 0; num < num_points; ++num) {\n1201                 bits = get_bit(scalars[num], i + 4) << 5;\n1202                 bits |= get_bit(scalars[num], i + 3) << 4;\n1203                 bits |= get_bit(scalars[num], i + 2) << 3;\n1204                 bits |= get_bit(scalars[num], i + 1) << 2;\n1205                 bits |= get_bit(scalars[num], i) << 1;\n1206                 bits |= get_bit(scalars[num], i - 1);\n1207                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1208\n1209                 /* select the point to add or subtract */\n1210                 select_point(digit, 17, pre_comp[num], tmp);\n1211                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1212                                             * point */\n1213                 copy_conditional(tmp[1], tmp[3], sign);\n1214\n1215                 if (!skip) {\n1216                     point_add(nq[0], nq[1], nq[2],\n1217                               nq[0], nq[1], nq[2],\n1218                               mixed, tmp[0], tmp[1], tmp[2]);\n1219                 } else {\n1220                     memcpy(nq, tmp, 3 * sizeof(felem));\n1221                     skip = 0;\n1222                 }\n1223             }\n1224         }\n1225     }\n1226     felem_assign(x_out, nq[0]);\n1227     felem_assign(y_out, nq[1]);\n1228     felem_assign(z_out, nq[2]);\n1229 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp224.c",
                                "function_body": "906  static void point_add(felem x3, felem y3, felem z3,\n907                        const felem x1, const felem y1, const felem z1,\n908                        const int mixed, const felem x2, const felem y2,\n909                        const felem z2)\n910  {\n911      felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, x_out, y_out, z_out;\n912      widefelem tmp, tmp2;\n913      limb z1_is_zero, z2_is_zero, x_equal, y_equal;\n914      limb points_equal;\n915\n916      if (!mixed) {\n917          /* ftmp2 = z2^2 */\n918          felem_square(tmp, z2);\n919          felem_reduce(ftmp2, tmp);\n920\n921          /* ftmp4 = z2^3 */\n922          felem_mul(tmp, ftmp2, z2);\n923          felem_reduce(ftmp4, tmp);\n924\n925          /* ftmp4 = z2^3*y1 */\n926          felem_mul(tmp2, ftmp4, y1);\n927          felem_reduce(ftmp4, tmp2);\n928\n929          /* ftmp2 = z2^2*x1 */\n930          felem_mul(tmp2, ftmp2, x1);\n931          felem_reduce(ftmp2, tmp2);\n932      } else {\n933          /*\n934           * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n935           */\n936\n937          /* ftmp4 = z2^3*y1 */\n938          felem_assign(ftmp4, y1);\n939\n940          /* ftmp2 = z2^2*x1 */\n941          felem_assign(ftmp2, x1);\n942      }\n943\n944      /* ftmp = z1^2 */\n945      felem_square(tmp, z1);\n946      felem_reduce(ftmp, tmp);\n947\n948      /* ftmp3 = z1^3 */\n949      felem_mul(tmp, ftmp, z1);\n950      felem_reduce(ftmp3, tmp);\n951\n952      /* tmp = z1^3*y2 */\n953      felem_mul(tmp, ftmp3, y2);\n954      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n955\n956      /* ftmp3 = z1^3*y2 - z2^3*y1 */\n957      felem_diff_128_64(tmp, ftmp4);\n958      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n959      felem_reduce(ftmp3, tmp);\n960\n961      /* tmp = z1^2*x2 */\n962      felem_mul(tmp, ftmp, x2);\n963      /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n964\n965      /* ftmp = z1^2*x2 - z2^2*x1 */\n966      felem_diff_128_64(tmp, ftmp2);\n967      /* tmp[i] < 2^116 + 2^64 + 8 < 2^117 */\n968      felem_reduce(ftmp, tmp);\n969\n970      /*\n971       * The formulae are incorrect if the points are equal, in affine coordinates\n972       * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n973       * happens.\n974       *\n975       * We use bitwise operations to avoid potential side-channels introduced by\n976       * the short-circuiting behaviour of boolean operators.\n977       */\n978      x_equal = felem_is_zero(ftmp);\n979      y_equal = felem_is_zero(ftmp3);\n980      /*\n981       * The special case of either point being the point at infinity (z1 and/or\n982       * z2 are zero), is handled separately later on in this function, so we\n983       * avoid jumping to point_double here in those special cases.\n984       */\n985      z1_is_zero = felem_is_zero(z1);\n986      z2_is_zero = felem_is_zero(z2);\n987\n988      /*\n989       * Compared to `ecp_nistp256.c` and `ecp_nistp521.c`, in this\n990       * specific implementation `felem_is_zero()` returns truth as `0x1`\n991       * (rather than `0xff..ff`).\n992       *\n993       * This implies that `~true` in this implementation becomes\n994       * `0xff..fe` (rather than `0x0`): for this reason, to be used in\n995       * the if expression, we mask out only the last bit in the next\n996       * line.\n997       */\n998      points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero)) & 1;\n999\n1000     if (points_equal) {\n1001         /*\n1002          * This is obviously not constant-time but, as mentioned before, this\n1003          * case never happens during single point multiplication, so there is no\n1004          * timing leak for ECDH or ECDSA signing.\n1005          */\n1006         point_double(x3, y3, z3, x1, y1, z1);\n1007         return;\n1008     }\n1009\n1010     /* ftmp5 = z1*z2 */\n1011     if (!mixed) {\n1012         felem_mul(tmp, z1, z2);\n1013         felem_reduce(ftmp5, tmp);\n1014     } else {\n1015         /* special case z2 = 0 is handled later */\n1016         felem_assign(ftmp5, z1);\n1017     }\n1018\n1019     /* z_out = (z1^2*x2 - z2^2*x1)*(z1*z2) */\n1020     felem_mul(tmp, ftmp, ftmp5);\n1021     felem_reduce(z_out, tmp);\n1022\n1023     /* ftmp = (z1^2*x2 - z2^2*x1)^2 */\n1024     felem_assign(ftmp5, ftmp);\n1025     felem_square(tmp, ftmp);\n1026     felem_reduce(ftmp, tmp);\n1027\n1028     /* ftmp5 = (z1^2*x2 - z2^2*x1)^3 */\n1029     felem_mul(tmp, ftmp, ftmp5);\n1030     felem_reduce(ftmp5, tmp);\n1031\n1032     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1033     felem_mul(tmp, ftmp2, ftmp);\n1034     felem_reduce(ftmp2, tmp);\n1035\n1036     /* tmp = z2^3*y1*(z1^2*x2 - z2^2*x1)^3 */\n1037     felem_mul(tmp, ftmp4, ftmp5);\n1038     /* tmp[i] < 4 * 2^57 * 2^57 = 2^116 */\n1039\n1040     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 */\n1041     felem_square(tmp2, ftmp3);\n1042     /* tmp2[i] < 4 * 2^57 * 2^57 < 2^116 */\n1043\n1044     /* tmp2 = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 */\n1045     felem_diff_128_64(tmp2, ftmp5);\n1046     /* tmp2[i] < 2^116 + 2^64 + 8 < 2^117 */\n1047\n1048     /* ftmp5 = 2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2 */\n1049     felem_assign(ftmp5, ftmp2);\n1050     felem_scalar(ftmp5, 2);\n1051     /* ftmp5[i] < 2 * 2^57 = 2^58 */\n1052\n1053     /*-\n1054      * x_out = (z1^3*y2 - z2^3*y1)^2 - (z1^2*x2 - z2^2*x1)^3 -\n1055      *  2*z2^2*x1*(z1^2*x2 - z2^2*x1)^2\n1056      */\n1057     felem_diff_128_64(tmp2, ftmp5);\n1058     /* tmp2[i] < 2^117 + 2^64 + 8 < 2^118 */\n1059     felem_reduce(x_out, tmp2);\n1060\n1061     /* ftmp2 = z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out */\n1062     felem_diff(ftmp2, x_out);\n1063     /* ftmp2[i] < 2^57 + 2^58 + 2 < 2^59 */\n1064\n1065     /*\n1066      * tmp2 = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out)\n1067      */\n1068     felem_mul(tmp2, ftmp3, ftmp2);\n1069     /* tmp2[i] < 4 * 2^57 * 2^59 = 2^118 */\n1070\n1071     /*-\n1072      * y_out = (z1^3*y2 - z2^3*y1)*(z2^2*x1*(z1^2*x2 - z2^2*x1)^2 - x_out) -\n1073      *  z2^3*y1*(z1^2*x2 - z2^2*x1)^3\n1074      */\n1075     widefelem_diff(tmp2, tmp);\n1076     /* tmp2[i] < 2^118 + 2^120 < 2^121 */\n1077     felem_reduce(y_out, tmp2);\n1078\n1079     /*\n1080      * the result (x_out, y_out, z_out) is incorrect if one of the inputs is\n1081      * the point at infinity, so we need to check for this separately\n1082      */\n1083\n1084     /*\n1085      * if point 1 is at infinity, copy point 2 to output, and vice versa\n1086      */\n1087     copy_conditional(x_out, x2, z1_is_zero);\n1088     copy_conditional(x_out, x1, z2_is_zero);\n1089     copy_conditional(y_out, y2, z1_is_zero);\n1090     copy_conditional(y_out, y1, z2_is_zero);\n1091     copy_conditional(z_out, z2, z1_is_zero);\n1092     copy_conditional(z_out, z1, z2_is_zero);\n1093     felem_assign(x3, x_out);\n1094     felem_assign(y3, y_out);\n1095     felem_assign(z3, z_out);\n1096 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp256.c",
                                "function_body": "1237 static void point_add(felem x3, felem y3, felem z3,\n1238                       const felem x1, const felem y1, const felem z1,\n1239                       const int mixed, const smallfelem x2,\n1240                       const smallfelem y2, const smallfelem z2)\n1241 {\n1242     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1243     longfelem tmp, tmp2;\n1244     smallfelem small1, small2, small3, small4, small5;\n1245     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1246     limb points_equal;\n1247\n1248     felem_shrink(small3, z1);\n1249\n1250     z1_is_zero = smallfelem_is_zero(small3);\n1251     z2_is_zero = smallfelem_is_zero(z2);\n1252\n1253     /* ftmp = z1z1 = z1**2 */\n1254     smallfelem_square(tmp, small3);\n1255     felem_reduce(ftmp, tmp);\n1256     /* ftmp[i] < 2^101 */\n1257     felem_shrink(small1, ftmp);\n1258\n1259     if (!mixed) {\n1260         /* ftmp2 = z2z2 = z2**2 */\n1261         smallfelem_square(tmp, z2);\n1262         felem_reduce(ftmp2, tmp);\n1263         /* ftmp2[i] < 2^101 */\n1264         felem_shrink(small2, ftmp2);\n1265\n1266         felem_shrink(small5, x1);\n1267\n1268         /* u1 = ftmp3 = x1*z2z2 */\n1269         smallfelem_mul(tmp, small5, small2);\n1270         felem_reduce(ftmp3, tmp);\n1271         /* ftmp3[i] < 2^101 */\n1272\n1273         /* ftmp5 = z1 + z2 */\n1274         felem_assign(ftmp5, z1);\n1275         felem_small_sum(ftmp5, z2);\n1276         /* ftmp5[i] < 2^107 */\n1277\n1278         /* ftmp5 = (z1 + z2)**2 - (z1z1 + z2z2) = 2z1z2 */\n1279         felem_square(tmp, ftmp5);\n1280         felem_reduce(ftmp5, tmp);\n1281         /* ftmp2 = z2z2 + z1z1 */\n1282         felem_sum(ftmp2, ftmp);\n1283         /* ftmp2[i] < 2^101 + 2^101 = 2^102 */\n1284         felem_diff(ftmp5, ftmp2);\n1285         /* ftmp5[i] < 2^105 + 2^101 < 2^106 */\n1286\n1287         /* ftmp2 = z2 * z2z2 */\n1288         smallfelem_mul(tmp, small2, z2);\n1289         felem_reduce(ftmp2, tmp);\n1290\n1291         /* s1 = ftmp2 = y1 * z2**3 */\n1292         felem_mul(tmp, y1, ftmp2);\n1293         felem_reduce(ftmp6, tmp);\n1294         /* ftmp6[i] < 2^101 */\n1295     } else {\n1296         /*\n1297          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1298          */\n1299\n1300         /* u1 = ftmp3 = x1*z2z2 */\n1301         felem_assign(ftmp3, x1);\n1302         /* ftmp3[i] < 2^106 */\n1303\n1304         /* ftmp5 = 2z1z2 */\n1305         felem_assign(ftmp5, z1);\n1306         felem_scalar(ftmp5, 2);\n1307         /* ftmp5[i] < 2*2^106 = 2^107 */\n1308\n1309         /* s1 = ftmp2 = y1 * z2**3 */\n1310         felem_assign(ftmp6, y1);\n1311         /* ftmp6[i] < 2^106 */\n1312     }\n1313\n1314     /* u2 = x2*z1z1 */\n1315     smallfelem_mul(tmp, x2, small1);\n1316     felem_reduce(ftmp4, tmp);\n1317\n1318     /* h = ftmp4 = u2 - u1 */\n1319     felem_diff_zero107(ftmp4, ftmp3);\n1320     /* ftmp4[i] < 2^107 + 2^101 < 2^108 */\n1321     felem_shrink(small4, ftmp4);\n1322\n1323     x_equal = smallfelem_is_zero(small4);\n1324\n1325     /* z_out = ftmp5 * h */\n1326     felem_small_mul(tmp, small4, ftmp5);\n1327     felem_reduce(z_out, tmp);\n1328     /* z_out[i] < 2^101 */\n1329\n1330     /* ftmp = z1 * z1z1 */\n1331     smallfelem_mul(tmp, small1, small3);\n1332     felem_reduce(ftmp, tmp);\n1333\n1334     /* s2 = tmp = y2 * z1**3 */\n1335     felem_small_mul(tmp, y2, ftmp);\n1336     felem_reduce(ftmp5, tmp);\n1337\n1338     /* r = ftmp5 = (s2 - s1)*2 */\n1339     felem_diff_zero107(ftmp5, ftmp6);\n1340     /* ftmp5[i] < 2^107 + 2^107 = 2^108 */\n1341     felem_scalar(ftmp5, 2);\n1342     /* ftmp5[i] < 2^109 */\n1343     felem_shrink(small1, ftmp5);\n1344     y_equal = smallfelem_is_zero(small1);\n1345\n1346     /*\n1347      * The formulae are incorrect if the points are equal, in affine coordinates\n1348      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1349      * happens.\n1350      *\n1351      * We use bitwise operations to avoid potential side-channels introduced by\n1352      * the short-circuiting behaviour of boolean operators.\n1353      *\n1354      * The special case of either point being the point at infinity (z1 and/or\n1355      * z2 are zero), is handled separately later on in this function, so we\n1356      * avoid jumping to point_double here in those special cases.\n1357      */\n1358     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1359\n1360     if (points_equal) {\n1361         /*\n1362          * This is obviously not constant-time but, as mentioned before, this\n1363          * case never happens during single point multiplication, so there is no\n1364          * timing leak for ECDH or ECDSA signing.\n1365          */\n1366         point_double(x3, y3, z3, x1, y1, z1);\n1367         return;\n1368     }\n1369\n1370     /* I = ftmp = (2h)**2 */\n1371     felem_assign(ftmp, ftmp4);\n1372     felem_scalar(ftmp, 2);\n1373     /* ftmp[i] < 2*2^108 = 2^109 */\n1374     felem_square(tmp, ftmp);\n1375     felem_reduce(ftmp, tmp);\n1376\n1377     /* J = ftmp2 = h * I */\n1378     felem_mul(tmp, ftmp4, ftmp);\n1379     felem_reduce(ftmp2, tmp);\n1380\n1381     /* V = ftmp4 = U1 * I */\n1382     felem_mul(tmp, ftmp3, ftmp);\n1383     felem_reduce(ftmp4, tmp);\n1384\n1385     /* x_out = r**2 - J - 2V */\n1386     smallfelem_square(tmp, small1);\n1387     felem_reduce(x_out, tmp);\n1388     felem_assign(ftmp3, ftmp4);\n1389     felem_scalar(ftmp4, 2);\n1390     felem_sum(ftmp4, ftmp2);\n1391     /* ftmp4[i] < 2*2^101 + 2^101 < 2^103 */\n1392     felem_diff(x_out, ftmp4);\n1393     /* x_out[i] < 2^105 + 2^101 */\n1394\n1395     /* y_out = r(V-x_out) - 2 * s1 * J */\n1396     felem_diff_zero107(ftmp3, x_out);\n1397     /* ftmp3[i] < 2^107 + 2^101 < 2^108 */\n1398     felem_small_mul(tmp, small1, ftmp3);\n1399     felem_mul(tmp2, ftmp6, ftmp2);\n1400     longfelem_scalar(tmp2, 2);\n1401     /* tmp2[i] < 2*2^67 = 2^68 */\n1402     longfelem_diff(tmp, tmp2);\n1403     /* tmp[i] < 2^67 + 2^70 + 2^40 < 2^71 */\n1404     felem_reduce_zero105(y_out, tmp);\n1405     /* y_out[i] < 2^106 */\n1406\n1407     copy_small_conditional(x_out, x2, z1_is_zero);\n1408     copy_conditional(x_out, x1, z2_is_zero);\n1409     copy_small_conditional(y_out, y2, z1_is_zero);\n1410     copy_conditional(y_out, y1, z2_is_zero);\n1411     copy_small_conditional(z_out, z2, z1_is_zero);\n1412     copy_conditional(z_out, z1, z2_is_zero);\n1413     felem_assign(x3, x_out);\n1414     felem_assign(y3, y_out);\n1415     felem_assign(z3, z_out);\n1416 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp384.c",
                                "function_body": "1071 static void point_add(felem x3, felem y3, felem z3,\n1072                       const felem x1, const felem y1, const felem z1,\n1073                       const int mixed, const felem x2, const felem y2,\n1074                       const felem z2)\n1075 {\n1076     felem ftmp, ftmp2, ftmp3, ftmp4, ftmp5, ftmp6, x_out, y_out, z_out;\n1077     widefelem tmp, tmp2;\n1078     limb x_equal, y_equal, z1_is_zero, z2_is_zero;\n1079     limb points_equal;\n1080\n1081     z1_is_zero = felem_is_zero(z1);\n1082     z2_is_zero = felem_is_zero(z2);\n1083\n1084     /* ftmp = z1z1 = z1**2 */\n1085     felem_square_reduce(ftmp, z1);      /* ftmp[i] < 2^56 */\n1086\n1087     if (!mixed) {\n1088         /* ftmp2 = z2z2 = z2**2 */\n1089         felem_square_reduce(ftmp2, z2); /* ftmp2[i] < 2^56 */\n1090\n1091         /* u1 = ftmp3 = x1*z2z2 */\n1092         felem_mul_reduce(ftmp3, x1, ftmp2); /* ftmp3[i] < 2^56 */\n1093\n1094         /* ftmp5 = z1 + z2 */\n1095         felem_assign(ftmp5, z1);       /* ftmp5[i] < 2^56 */\n1096         felem_sum64(ftmp5, z2);        /* ftmp5[i] < 2^57 */\n1097\n1098         /* ftmp5 = (z1 + z2)**2 - z1z1 - z2z2 = 2*z1z2 */\n1099         felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1100         felem_diff_128_64(tmp, ftmp);  /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1101         felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1102         felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1103\n1104         /* ftmp2 = z2 * z2z2 */\n1105         felem_mul_reduce(ftmp2, ftmp2, z2); /* ftmp2[i] < 2^56 */\n1106\n1107         /* s1 = ftmp6 = y1 * z2**3 */\n1108         felem_mul_reduce(ftmp6, y1, ftmp2); /* ftmp6[i] < 2^56 */\n1109     } else {\n1110         /*\n1111          * We'll assume z2 = 1 (special case z2 = 0 is handled later)\n1112          */\n1113\n1114         /* u1 = ftmp3 = x1*z2z2 */\n1115         felem_assign(ftmp3, x1);     /* ftmp3[i] < 2^56 */\n1116\n1117         /* ftmp5 = 2*z1z2 */\n1118         felem_scalar(ftmp5, z1, 2);  /* ftmp5[i] < 2^57 */\n1119\n1120         /* s1 = ftmp6 = y1 * z2**3 */\n1121         felem_assign(ftmp6, y1);     /* ftmp6[i] < 2^56 */\n1122     }\n1123     /* ftmp3[i] < 2^56, ftmp5[i] < 2^57, ftmp6[i] < 2^56 */\n1124\n1125     /* u2 = x2*z1z1 */\n1126     felem_mul(tmp, x2, ftmp);        /* tmp[i] < 2^115 */\n1127\n1128     /* h = ftmp4 = u2 - u1 */\n1129     felem_diff_128_64(tmp, ftmp3);   /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1130     felem_reduce(ftmp4, tmp);        /* ftmp[4] < 2^56 */\n1131\n1132     x_equal = felem_is_zero(ftmp4);\n1133\n1134     /* z_out = ftmp5 * h */\n1135     felem_mul_reduce(z_out, ftmp5, ftmp4);  /* z_out[i] < 2^56 */\n1136\n1137     /* ftmp = z1 * z1z1 */\n1138     felem_mul_reduce(ftmp, ftmp, z1);  /* ftmp[i] < 2^56 */\n1139\n1140     /* s2 = tmp = y2 * z1**3 */\n1141     felem_mul(tmp, y2, ftmp);      /* tmp[i] < 2^115 */\n1142\n1143     /* r = ftmp5 = (s2 - s1)*2 */\n1144     felem_diff_128_64(tmp, ftmp6); /* tmp[i] < 2^115 + 2^64 + 2^48 */\n1145     felem_reduce(ftmp5, tmp);      /* ftmp5[i] < 2^56 */\n1146     y_equal = felem_is_zero(ftmp5);\n1147     felem_scalar64(ftmp5, 2);      /* ftmp5[i] < 2^57 */\n1148\n1149     /*\n1150      * The formulae are incorrect if the points are equal, in affine coordinates\n1151      * (X_1, Y_1) == (X_2, Y_2), so we check for this and do doubling if this\n1152      * happens.\n1153      *\n1154      * We use bitwise operations to avoid potential side-channels introduced by\n1155      * the short-circuiting behaviour of boolean operators.\n1156      *\n1157      * The special case of either point being the point at infinity (z1 and/or\n1158      * z2 are zero), is handled separately later on in this function, so we\n1159      * avoid jumping to point_double here in those special cases.\n1160      *\n1161      * Notice the comment below on the implications of this branching for timing\n1162      * leaks and why it is considered practically irrelevant.\n1163      */\n1164     points_equal = (x_equal & y_equal & (~z1_is_zero) & (~z2_is_zero));\n1165\n1166     if (points_equal) {\n1167         /*\n1168          * This is obviously not constant-time but it will almost-never happen\n1169          * for ECDH / ECDSA.\n1170          */\n1171         point_double(x3, y3, z3, x1, y1, z1);\n1172         return;\n1173     }\n1174\n1175     /* I = ftmp = (2h)**2 */\n1176     felem_assign(ftmp, ftmp4);        /* ftmp[i] < 2^56 */\n1177     felem_scalar64(ftmp, 2);          /* ftmp[i] < 2^57 */\n1178     felem_square_reduce(ftmp, ftmp);  /* ftmp[i] < 2^56 */\n1179\n1180     /* J = ftmp2 = h * I */\n1181     felem_mul_reduce(ftmp2, ftmp4, ftmp); /* ftmp2[i] < 2^56 */\n1182\n1183     /* V = ftmp4 = U1 * I */\n1184     felem_mul_reduce(ftmp4, ftmp3, ftmp); /* ftmp4[i] < 2^56 */\n1185\n1186     /* x_out = r**2 - J - 2V */\n1187     felem_square(tmp, ftmp5);      /* tmp[i] < 2^117 */\n1188     felem_diff_128_64(tmp, ftmp2); /* tmp[i] < 2^117 + 2^64 + 2^48 */\n1189     felem_assign(ftmp3, ftmp4);    /* ftmp3[i] < 2^56 */\n1190     felem_scalar64(ftmp4, 2);      /* ftmp4[i] < 2^57 */\n1191     felem_diff_128_64(tmp, ftmp4); /* tmp[i] < 2^117 + 2^65 + 2^49 */\n1192     felem_reduce(x_out, tmp);      /* x_out[i] < 2^56 */\n1193\n1194     /* y_out = r(V-x_out) - 2 * s1 * J */\n1195     felem_diff64(ftmp3, x_out);    /* ftmp3[i] < 2^60 + 2^56 + 2^44 */\n1196     felem_mul(tmp, ftmp5, ftmp3);  /* tmp[i] < 2^116 */\n1197     felem_mul(tmp2, ftmp6, ftmp2); /* tmp2[i] < 2^115 */\n1198     felem_scalar128(tmp2, 2);      /* tmp2[i] < 2^116 */\n1199     felem_diff128(tmp, tmp2);      /* tmp[i] < 2^127 + 2^116 + 2^111 */\n1200     felem_reduce(y_out, tmp);      /* y_out[i] < 2^56 */\n1201\n1202     copy_conditional(x_out, x2, z1_is_zero);\n1203     copy_conditional(x_out, x1, z2_is_zero);\n1204     copy_conditional(y_out, y2, z1_is_zero);\n1205     copy_conditional(y_out, y1, z2_is_zero);\n1206     copy_conditional(z_out, z2, z1_is_zero);\n1207     copy_conditional(z_out, z1, z2_is_zero);\n1208     felem_assign(x3, x_out);\n1209     felem_assign(y3, y_out);\n1210     felem_assign(z3, z_out);\n1211 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "303 static void ecp_nistz256_point_add(P256_POINT *r,\n304                                    const P256_POINT *a, const P256_POINT *b)\n305 {\n306     BN_ULONG U2[P256_LIMBS], S2[P256_LIMBS];\n307     BN_ULONG U1[P256_LIMBS], S1[P256_LIMBS];\n308     BN_ULONG Z1sqr[P256_LIMBS];\n309     BN_ULONG Z2sqr[P256_LIMBS];\n310     BN_ULONG H[P256_LIMBS], R[P256_LIMBS];\n311     BN_ULONG Hsqr[P256_LIMBS];\n312     BN_ULONG Rsqr[P256_LIMBS];\n313     BN_ULONG Hcub[P256_LIMBS];\n314\n315     BN_ULONG res_x[P256_LIMBS];\n316     BN_ULONG res_y[P256_LIMBS];\n317     BN_ULONG res_z[P256_LIMBS];\n318\n319     BN_ULONG in1infty, in2infty;\n320\n321     const BN_ULONG *in1_x = a->X;\n322     const BN_ULONG *in1_y = a->Y;\n323     const BN_ULONG *in1_z = a->Z;\n324\n325     const BN_ULONG *in2_x = b->X;\n326     const BN_ULONG *in2_y = b->Y;\n327     const BN_ULONG *in2_z = b->Z;\n328\n329     /*\n330      * Infinity in encoded as (,,0)\n331      */\n332     in1infty = (in1_z[0] | in1_z[1] | in1_z[2] | in1_z[3]);\n333     if (P256_LIMBS == 8)\n334         in1infty |= (in1_z[4] | in1_z[5] | in1_z[6] | in1_z[7]);\n335\n336     in2infty = (in2_z[0] | in2_z[1] | in2_z[2] | in2_z[3]);\n337     if (P256_LIMBS == 8)\n338         in2infty |= (in2_z[4] | in2_z[5] | in2_z[6] | in2_z[7]);\n339\n340     in1infty = is_zero(in1infty);\n341     in2infty = is_zero(in2infty);\n342\n343     ecp_nistz256_sqr_mont(Z2sqr, in2_z);        /* Z2^2 */\n344     ecp_nistz256_sqr_mont(Z1sqr, in1_z);        /* Z1^2 */\n345\n346     ecp_nistz256_mul_mont(S1, Z2sqr, in2_z);    /* S1 = Z2^3 */\n347     ecp_nistz256_mul_mont(S2, Z1sqr, in1_z);    /* S2 = Z1^3 */\n348\n349     ecp_nistz256_mul_mont(S1, S1, in1_y);       /* S1 = Y1*Z2^3 */\n350     ecp_nistz256_mul_mont(S2, S2, in2_y);       /* S2 = Y2*Z1^3 */\n351     ecp_nistz256_sub(R, S2, S1);                /* R = S2 - S1 */\n352\n353     ecp_nistz256_mul_mont(U1, in1_x, Z2sqr);    /* U1 = X1*Z2^2 */\n354     ecp_nistz256_mul_mont(U2, in2_x, Z1sqr);    /* U2 = X2*Z1^2 */\n355     ecp_nistz256_sub(H, U2, U1);                /* H = U2 - U1 */\n356\n357     /*\n358      * The formulae are incorrect if the points are equal so we check for\n359      * this and do doubling if this happens.\n360      *\n361      * Points here are in Jacobian projective coordinates (Xi, Yi, Zi)\n362      * that are bound to the affine coordinates (xi, yi) by the following\n363      * equations:\n364      *     - xi = Xi / (Zi)^2\n365      *     - y1 = Yi / (Zi)^3\n366      *\n367      * For the sake of optimization, the algorithm operates over\n368      * intermediate variables U1, U2 and S1, S2 that are derived from\n369      * the projective coordinates:\n370      *     - U1 = X1 * (Z2)^2 ; U2 = X2 * (Z1)^2\n371      *     - S1 = Y1 * (Z2)^3 ; S2 = Y2 * (Z1)^3\n372      *\n373      * It is easy to prove that is_equal(U1, U2) implies that the affine\n374      * x-coordinates are equal, or either point is at infinity.\n375      * Likewise is_equal(S1, S2) implies that the affine y-coordinates are\n376      * equal, or either point is at infinity.\n377      *\n378      * The special case of either point being the point at infinity (Z1 or Z2\n379      * is zero), is handled separately later on in this function, so we avoid\n380      * jumping to point_double here in those special cases.\n381      *\n382      * When both points are inverse of each other, we know that the affine\n383      * x-coordinates are equal, and the y-coordinates have different sign.\n384      * Therefore since U1 = U2, we know H = 0, and therefore Z3 = H*Z1*Z2\n385      * will equal 0, thus the result is infinity, if we simply let this\n386      * function continue normally.\n387      *\n388      * We use bitwise operations to avoid potential side-channels introduced by\n389      * the short-circuiting behaviour of boolean operators.\n390      */\n391     if (is_equal(U1, U2) & ~in1infty & ~in2infty & is_equal(S1, S2)) {\n392         /*\n393          * This is obviously not constant-time but it should never happen during\n394          * single point multiplication, so there is no timing leak for ECDH or\n395          * ECDSA signing.\n396          */\n397         ecp_nistz256_point_double(r, a);\n398         return;\n399     }\n400\n401     ecp_nistz256_sqr_mont(Rsqr, R);             /* R^2 */\n402     ecp_nistz256_mul_mont(res_z, H, in1_z);     /* Z3 = H*Z1*Z2 */\n403     ecp_nistz256_sqr_mont(Hsqr, H);             /* H^2 */\n404     ecp_nistz256_mul_mont(res_z, res_z, in2_z); /* Z3 = H*Z1*Z2 */\n405     ecp_nistz256_mul_mont(Hcub, Hsqr, H);       /* H^3 */\n406\n407     ecp_nistz256_mul_mont(U2, U1, Hsqr);        /* U1*H^2 */\n408     ecp_nistz256_mul_by_2(Hsqr, U2);            /* 2*U1*H^2 */\n409\n410     ecp_nistz256_sub(res_x, Rsqr, Hsqr);\n411     ecp_nistz256_sub(res_x, res_x, Hcub);\n412\n413     ecp_nistz256_sub(res_y, U2, res_x);\n414\n415     ecp_nistz256_mul_mont(S2, S1, Hcub);\n416     ecp_nistz256_mul_mont(res_y, R, res_y);\n417     ecp_nistz256_sub(res_y, res_y, S2);\n418\n419     copy_conditional(res_x, in2_x, in1infty);\n420     copy_conditional(res_y, in2_y, in1infty);\n421     copy_conditional(res_z, in2_z, in1infty);\n422\n423     copy_conditional(res_x, in1_x, in2infty);\n424     copy_conditional(res_y, in1_y, in2infty);\n425     copy_conditional(res_z, in1_z, in2infty);\n426\n427     memcpy(r->X, res_x, sizeof(res_x));\n428     memcpy(r->Y, res_y, sizeof(res_y));\n429     memcpy(r->Z, res_z, sizeof(res_z));\n430 }"
                            }
                        ]
                    },
                    {
                        "text": [
                            {
                                "file_path": "/crypto/ec/ecp_nistz256.c",
                                "function_body": "168 static void copy_conditional(BN_ULONG dst[P256_LIMBS],\n169                              const BN_ULONG src[P256_LIMBS], BN_ULONG move)\n170 {\n171     BN_ULONG mask1 = 0-move;\n172     BN_ULONG mask2 = ~mask1;\n173\n174     dst[0] = (src[0] & mask1) ^ (dst[0] & mask2);\n175     dst[1] = (src[1] & mask1) ^ (dst[1] & mask2);\n176     dst[2] = (src[2] & mask1) ^ (dst[2] & mask2);\n177     dst[3] = (src[3] & mask1) ^ (dst[3] & mask2);\n178     if (P256_LIMBS == 8) {\n179         dst[4] = (src[4] & mask1) ^ (dst[4] & mask2);\n180         dst[5] = (src[5] & mask1) ^ (dst[5] & mask2);\n181         dst[6] = (src[6] & mask1) ^ (dst[6] & mask2);\n182         dst[7] = (src[7] & mask1) ^ (dst[7] & mask2);\n183     }\n184 }"
                            },
                            {
                                "file_path": "/crypto/ec/ecp_nistp521.c",
                                "function_body": "1581 static void batch_mul(felem x_out, felem y_out, felem z_out,\n1582                       const felem_bytearray scalars[],\n1583                       const unsigned num_points, const u8 *g_scalar,\n1584                       const int mixed, const felem pre_comp[][17][3],\n1585                       const felem g_pre_comp[16][3])\n1586 {\n1587     int i, skip;\n1588     unsigned num, gen_mul = (g_scalar != NULL);\n1589     felem nq[3], tmp[4];\n1590     limb bits;\n1591     u8 sign, digit;\n1592\n1593     /* set nq to the point at infinity */\n1594     memset(nq, 0, sizeof(nq));\n1595\n1596     /*\n1597      * Loop over all scalars msb-to-lsb, interleaving additions of multiples\n1598      * of the generator (last quarter of rounds) and additions of other\n1599      * points multiples (every 5th round).\n1600      */\n1601     skip = 1;                   /* save two point operations in the first\n1602                                  * round */\n1603     for (i = (num_points ? 520 : 130); i >= 0; --i) {\n1604         /* double */\n1605         if (!skip)\n1606             point_double(nq[0], nq[1], nq[2], nq[0], nq[1], nq[2]);\n1607\n1608         /* add multiples of the generator */\n1609         if (gen_mul && (i <= 130)) {\n1610             bits = get_bit(g_scalar, i + 390) << 3;\n1611             if (i < 130) {\n1612                 bits |= get_bit(g_scalar, i + 260) << 2;\n1613                 bits |= get_bit(g_scalar, i + 130) << 1;\n1614                 bits |= get_bit(g_scalar, i);\n1615             }\n1616             /* select the point to add, in constant time */\n1617             select_point(bits, 16, g_pre_comp, tmp);\n1618             if (!skip) {\n1619                 /* The 1 argument below is for \"mixed\" */\n1620                 point_add(nq[0], nq[1], nq[2],\n1621                           nq[0], nq[1], nq[2], 1, tmp[0], tmp[1], tmp[2]);\n1622             } else {\n1623                 memcpy(nq, tmp, 3 * sizeof(felem));\n1624                 skip = 0;\n1625             }\n1626         }\n1627\n1628         /* do other additions every 5 doublings */\n1629         if (num_points && (i % 5 == 0)) {\n1630             /* loop over all scalars */\n1631             for (num = 0; num < num_points; ++num) {\n1632                 bits = get_bit(scalars[num], i + 4) << 5;\n1633                 bits |= get_bit(scalars[num], i + 3) << 4;\n1634                 bits |= get_bit(scalars[num], i + 2) << 3;\n1635                 bits |= get_bit(scalars[num], i + 1) << 2;\n1636                 bits |= get_bit(scalars[num], i) << 1;\n1637                 bits |= get_bit(scalars[num], i - 1);\n1638                 ossl_ec_GFp_nistp_recode_scalar_bits(&sign, &digit, bits);\n1639\n1640                 /*\n1641                  * select the point to add or subtract, in constant time\n1642                  */\n1643                 select_point(digit, 17, pre_comp[num], tmp);\n1644                 felem_neg(tmp[3], tmp[1]); /* (X, -Y, Z) is the negative\n1645                                             * point */\n1646                 copy_conditional(tmp[1], tmp[3], (-(limb) sign));\n1647\n1648                 if (!skip) {\n1649                     point_add(nq[0], nq[1], nq[2],\n1650                               nq[0], nq[1], nq[2],\n1651                               mixed, tmp[0], tmp[1], tmp[2]);\n1652                 } else {\n1653                     memcpy(nq, tmp, 3 * sizeof(felem));\n1654                     skip = 0;\n1655                 }\n1656             }\n1657         }\n1658     }\n1659     felem_assign(x_out, nq[0]);\n1660     felem_assign(y_out, nq[1]);\n1661     felem_assign(z_out, nq[2]);\n1662 }"
                            }
                        ]
                    }
                ],
                "response": "### Explanation of the Code Behavior\n\nThe provided code snippet contains a function named `copy_conditional`, which is designed to conditionally copy values from a source array (`src`) to a destination array (`dst`) based on a control variable (`move`). The function operates on arrays of type `BN_ULONG`, which is typically a type used for large integers in cryptographic applications.\n\nHere's a breakdown of how the function works:\n\n1. **Mask Calculation**:\n   - `mask1` is calculated as `0 - move`. This will be `0` if `move` is `0`, and `-1` (or all bits set) if `move` is non-zero (typically `1`).\n   - `mask2` is the bitwise negation of `mask1`, which will be `-1` if `move` is `0` and `0` if `move` is non-zero.\n\n2. **Conditional Copying**:\n   - The function then performs a bitwise operation to conditionally copy values:\n     - For each index `i` in the arrays, it computes `dst[i] = (src[i] & mask1) ^ (dst[i] & mask2)`.\n     - If `move` is `0`, `mask1` is `0`, and thus `src[i] & mask1` will be `0`, meaning `dst[i]` will retain its original value.\n     - If `move` is non-zero, `mask1` will be `-1`, and `src[i]` will be copied to `dst[i]`.\n\n3. **Handling Different Sizes**:\n   - The function checks if `P256_LIMBS` is `8` to handle arrays of size `8` specifically, performing the same conditional copy for the additional indices.\n\n### Evaluation of the Bug Report\n\nThe bug report states that \"Value dst may be null; it should be checked before dereferencing.\" This implies that there is a concern that the `dst` pointer could be `NULL`, leading to dereferencing a null pointer when attempting to access `dst[i]`.\n\n#### Analysis:\n- The function does not include any checks to verify if `dst` is `NULL` before attempting to access its elements. If `dst` is indeed `NULL`, any attempt to access `dst[i]` will lead to undefined behavior, typically resulting in a segmentation fault or crash.\n\n### Conclusion\n\nGiven the analysis, the bug report accurately identifies a potential issue in the code. The absence of a null check for the `dst` pointer before dereferencing it is a genuine concern that could lead to runtime errors.\n\nTherefore, the appropriate label for this situation is:\n\n@@@ real bug @@@",
                "final_answer": "real bug"
            }
        ],
        "final_answer": "real bug"
    }
]