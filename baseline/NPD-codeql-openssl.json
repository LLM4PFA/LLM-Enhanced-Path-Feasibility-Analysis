[
    {
        "prt": "pktmp",
        "function_call": [
            "static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509,\n                   const char *dgst, STACK_OF(OPENSSL_STRING) *sigopts,\n                   STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial,\n                   const char *subj, unsigned long chtype, int multirdn,\n                   int email_dn, const char *startdate, const char *enddate, long days,\n                   int batch, int verbose, X509_REQ *req, const char *ext_sect,\n                   CONF *lconf, unsigned long certopt, unsigned long nameopt,\n                   int default_op, int ext_copy, int selfsign, unsigned long dateopt)\n{\n    const X509_NAME *name = NULL;\n    X509_NAME *CAname = NULL, *subject = NULL;\n    const ASN1_TIME *tm;\n    ASN1_STRING *str, *str2;\n    ASN1_OBJECT *obj;\n    X509 *ret = NULL;\n    X509_NAME_ENTRY *ne, *tne;\n    EVP_PKEY *pktmp;\n    int ok = -1, i, j, last, nid;\n    const char *p;\n    CONF_VALUE *cv;\n    OPENSSL_STRING row[DB_NUMBER];\n    OPENSSL_STRING *irow = NULL;\n    OPENSSL_STRING *rrow = NULL;\n    char buf[25];\n    X509V3_CTX ext_ctx;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n\n    if (subj) {\n        X509_NAME *n = parse_name(subj, chtype, multirdn, \"subject\");\n\n        if (!n)\n            goto end;\n        X509_REQ_set_subject_name(req, n);\n        X509_NAME_free(n);\n    }\n\n    if (default_op)\n        BIO_printf(bio_err, \"The Subject's Distinguished Name is as follows\\n\");\n\n    name = X509_REQ_get_subject_name(req);\n    for (i = 0; i < X509_NAME_entry_count(name); i++) {\n        ne = X509_NAME_get_entry(name, i);\n        str = X509_NAME_ENTRY_get_data(ne);\n        obj = X509_NAME_ENTRY_get_object(ne);\n        nid = OBJ_obj2nid(obj);\n\n        if (msie_hack) {\n            /* assume all type should be strings */\n\n            if (str->type == V_ASN1_UNIVERSALSTRING)\n                ASN1_UNIVERSALSTRING_to_string(str);\n\n            if (str->type == V_ASN1_IA5STRING && nid != NID_pkcs9_emailAddress)\n                str->type = V_ASN1_T61STRING;\n\n            if (nid == NID_pkcs9_emailAddress\n                && str->type == V_ASN1_PRINTABLESTRING)\n                str->type = V_ASN1_IA5STRING;\n        }\n\n        /* If no EMAIL is wanted in the subject */\n        if (nid == NID_pkcs9_emailAddress && !email_dn)\n            continue;\n\n        /* check some things */\n        if (nid == NID_pkcs9_emailAddress && str->type != V_ASN1_IA5STRING) {\n            BIO_printf(bio_err,\n                       \"\\nemailAddress type needs to be of type IA5STRING\\n\");\n            goto end;\n        }\n        if (str->type != V_ASN1_BMPSTRING && str->type != V_ASN1_UTF8STRING) {\n            j = ASN1_PRINTABLE_type(str->data, str->length);\n            if ((j == V_ASN1_T61STRING && str->type != V_ASN1_T61STRING) ||\n                (j == V_ASN1_IA5STRING && str->type == V_ASN1_PRINTABLESTRING))\n            {\n                BIO_printf(bio_err,\n                           \"\\nThe string contains characters that are illegal for the ASN.1 type\\n\");\n                goto end;\n            }\n        }\n\n        if (default_op)\n            old_entry_print(obj, str);\n    }\n\n    /* Ok, now we check the 'policy' stuff. */\n    if ((subject = X509_NAME_new()) == NULL) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n\n    /* take a copy of the issuer name before we mess with it. */\n    if (selfsign)\n        CAname = X509_NAME_dup(name);\n    else\n        CAname = X509_NAME_dup(X509_get_subject_name(x509));\n    if (CAname == NULL)\n        goto end;\n    str = str2 = NULL;\n\n    for (i = 0; i < sk_CONF_VALUE_num(policy); i++) {\n        cv = sk_CONF_VALUE_value(policy, i); /* get the object id */\n        if ((j = OBJ_txt2nid(cv->name)) == NID_undef) {\n            BIO_printf(bio_err,\n                       \"%s:unknown object type in 'policy' configuration\\n\",\n                       cv->name);\n            goto end;\n        }\n        obj = OBJ_nid2obj(j);\n\n        last = -1;\n        for (;;) {\n            X509_NAME_ENTRY *push = NULL;\n\n            /* lookup the object in the supplied name list */\n            j = X509_NAME_get_index_by_OBJ(name, obj, last);\n            if (j < 0) {\n                if (last != -1)\n                    break;\n                tne = NULL;\n            } else {\n                tne = X509_NAME_get_entry(name, j);\n            }\n            last = j;\n\n            /* depending on the 'policy', decide what to do. */\n            if (strcmp(cv->value, \"optional\") == 0) {\n                if (tne != NULL)\n                    push = tne;\n            } else if (strcmp(cv->value, \"supplied\") == 0) {\n                if (tne == NULL) {\n                    BIO_printf(bio_err,\n                               \"The %s field needed to be supplied and was missing\\n\",\n                               cv->name);\n                    goto end;\n                } else {\n                    push = tne;\n                }\n            } else if (strcmp(cv->value, \"match\") == 0) {\n                int last2;\n\n                if (tne == NULL) {\n                    BIO_printf(bio_err,\n                               \"The mandatory %s field was missing\\n\",\n                               cv->name);\n                    goto end;\n                }\n\n                last2 = -1;\n\n again2:\n                j = X509_NAME_get_index_by_OBJ(CAname, obj, last2);\n                if ((j < 0) && (last2 == -1)) {\n                    BIO_printf(bio_err,\n                               \"The %s field does not exist in the CA certificate,\\n\"\n                               \"the 'policy' is misconfigured\\n\", cv->name);\n                    goto end;\n                }\n                if (j >= 0) {\n                    push = X509_NAME_get_entry(CAname, j);\n                    str = X509_NAME_ENTRY_get_data(tne);\n                    str2 = X509_NAME_ENTRY_get_data(push);\n                    last2 = j;\n                    if (ASN1_STRING_cmp(str, str2) != 0)\n                        goto again2;\n                }\n                if (j < 0) {\n                    BIO_printf(bio_err,\n                               \"The %s field is different between\\n\"\n                               \"CA certificate (%s) and the request (%s)\\n\",\n                               cv->name,\n                               ((str2 == NULL) ? \"NULL\" : (char *)str2->data),\n                               ((str == NULL) ? \"NULL\" : (char *)str->data));\n                    goto end;\n                }\n            } else {\n                BIO_printf(bio_err,\n                           \"%s:invalid type in 'policy' configuration\\n\",\n                           cv->value);\n                goto end;\n            }\n\n            if (push != NULL) {\n                if (!X509_NAME_add_entry(subject, push, -1, 0)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n            if (j < 0)\n                break;\n        }\n    }\n\n    if (preserve) {\n        X509_NAME_free(subject);\n        /* subject=X509_NAME_dup(X509_REQ_get_subject_name(req)); */\n        subject = X509_NAME_dup(name);\n        if (subject == NULL)\n            goto end;\n    }\n\n    /* We are now totally happy, lets make and sign the certificate */\n    if (verbose)\n        BIO_printf(bio_err,\n                   \"Everything appears to be ok, creating and signing the certificate\\n\");\n\n    if ((ret = X509_new_ex(app_get0_libctx(), app_get0_propq())) == NULL)\n        goto end;\n\n    if (BN_to_ASN1_INTEGER(serial, X509_get_serialNumber(ret)) == NULL)\n        goto end;\n    if (selfsign) {\n        if (!X509_set_issuer_name(ret, subject))\n            goto end;\n    } else {\n        if (!X509_set_issuer_name(ret, X509_get_subject_name(x509)))\n            goto end;\n    }\n\n    if (!set_cert_times(ret, startdate, enddate, days, 0))\n        goto end;\n\n    if (enddate != NULL) {\n        int tdays;\n\n        if (!ASN1_TIME_diff(&tdays, NULL, NULL, X509_get0_notAfter(ret)))\n            goto end;\n        days = tdays;\n    }\n\n    if (!X509_set_subject_name(ret, subject))\n        goto end;\n\n    pktmp = X509_REQ_get0_pubkey(req);\n    i = X509_set_pubkey(ret, pktmp);\n    if (!i)\n        goto end;\n\n    /* Initialize the context structure */\n    X509V3_set_ctx(&ext_ctx, selfsign ? ret : x509,\n                   ret, NULL /* no need to give req, needed info is in ret */,\n                   NULL, X509V3_CTX_REPLACE);\n    /* prepare fallback for AKID, but only if issuer cert equals subject cert */\n    if (selfsign) {\n        if (!X509V3_set_issuer_pkey(&ext_ctx, pkey))\n            goto end;\n        if (!cert_matches_key(ret, pkey))\n            BIO_printf(bio_err,\n                       \"Warning: Signature key and public key of cert do not match\\n\");\n    }\n\n    /* Lets add the extensions, if there are any */\n    if (ext_sect) {\n        if (extfile_conf != NULL) {\n            if (verbose)\n                BIO_printf(bio_err, \"Extra configuration file found\\n\");\n\n            /* Use the extfile_conf configuration db LHASH */\n            X509V3_set_nconf(&ext_ctx, extfile_conf);\n\n            /* Adds exts contained in the configuration file */\n            if (!X509V3_EXT_add_nconf(extfile_conf, &ext_ctx, ext_sect, ret)) {\n                BIO_printf(bio_err,\n                           \"Error adding certificate extensions from extfile section %s\\n\",\n                           ext_sect);\n                goto end;\n            }\n            if (verbose)\n                BIO_printf(bio_err,\n                           \"Successfully added extensions from file.\\n\");\n        } else if (ext_sect) {\n            /* We found extensions to be set from config file */\n            X509V3_set_nconf(&ext_ctx, lconf);\n\n            if (!X509V3_EXT_add_nconf(lconf, &ext_ctx, ext_sect, ret)) {\n                BIO_printf(bio_err,\n                           \"Error adding certificate extensions from config section %s\\n\",\n                           ext_sect);\n                goto end;\n            }\n\n            if (verbose)\n                BIO_printf(bio_err,\n                           \"Successfully added extensions from config\\n\");\n        }\n    }\n\n    /* Copy extensions from request (if any) */\n\n    if (!copy_extensions(ret, req, ext_copy)) {\n        BIO_printf(bio_err, \"ERROR: adding extensions from request\\n\");\n        goto end;\n    }\n\n    if (verbose)\n        BIO_printf(bio_err,\n                   \"The subject name appears to be ok, checking database for clashes\\n\");\n\n    /* Build the correct Subject if no e-mail is wanted in the subject. */\n    if (!email_dn) {\n        X509_NAME_ENTRY *tmpne;\n        X509_NAME *dn_subject;\n\n        /*\n         * Its best to dup the subject DN and then delete any email addresses\n         * because this retains its structure.\n         */\n        if ((dn_subject = X509_NAME_dup(subject)) == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n        i = -1;\n        while ((i = X509_NAME_get_index_by_NID(dn_subject,\n                                               NID_pkcs9_emailAddress,\n                                               i)) >= 0) {\n            tmpne = X509_NAME_delete_entry(dn_subject, i--);\n            X509_NAME_ENTRY_free(tmpne);\n        }\n\n        if (!X509_set_subject_name(ret, dn_subject)) {\n            X509_NAME_free(dn_subject);\n            goto end;\n        }\n        X509_NAME_free(dn_subject);\n    }\n\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(ret), NULL, 0);\n    if (row[DB_name] == NULL) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n\n    if (BN_is_zero(serial))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(serial);\n    if (row[DB_serial] == NULL) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n\n    if (row[DB_name][0] == '\\0') {\n        /*\n         * An empty subject! We'll use the serial number instead. If\n         * unique_subject is in use then we don't want different entries with\n         * empty subjects matching each other.\n         */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n        if (row[DB_name] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n    }\n\n    if (db->attributes.unique_subject) {\n        OPENSSL_STRING *crow = row;\n\n        rrow = TXT_DB_get_by_index(db->db, DB_name, crow);\n        if (rrow != NULL) {\n            BIO_printf(bio_err,\n                       \"ERROR:There is already a certificate for %s\\n\",\n                       row[DB_name]);\n        }\n    }\n    if (rrow == NULL) {\n        rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n        if (rrow != NULL) {\n            BIO_printf(bio_err,\n                       \"ERROR:Serial number %s has already been issued,\\n\",\n                       row[DB_serial]);\n            BIO_printf(bio_err,\n                       \"      check the database/serial_file for corruption\\n\");\n        }\n    }\n\n    if (rrow != NULL) {\n        BIO_printf(bio_err, \"The matching entry has the following details\\n\");\n        if (rrow[DB_type][0] == DB_TYPE_EXP)\n            p = \"Expired\";\n        else if (rrow[DB_type][0] == DB_TYPE_REV)\n            p = \"Revoked\";\n        else if (rrow[DB_type][0] == DB_TYPE_VAL)\n            p = \"Valid\";\n        else\n            p = \"\\ninvalid type, Database error\\n\";\n        BIO_printf(bio_err, \"Type          :%s\\n\", p);\n        if (rrow[DB_type][0] == DB_TYPE_REV) {\n            p = rrow[DB_exp_date];\n            if (p == NULL)\n                p = \"undef\";\n            BIO_printf(bio_err, \"Was revoked on:%s\\n\", p);\n        }\n        p = rrow[DB_exp_date];\n        if (p == NULL)\n            p = \"undef\";\n        BIO_printf(bio_err, \"Expires on    :%s\\n\", p);\n        p = rrow[DB_serial];\n        if (p == NULL)\n            p = \"undef\";\n        BIO_printf(bio_err, \"Serial Number :%s\\n\", p);\n        p = rrow[DB_file];\n        if (p == NULL)\n            p = \"undef\";\n        BIO_printf(bio_err, \"File name     :%s\\n\", p);\n        p = rrow[DB_name];\n        if (p == NULL)\n            p = \"undef\";\n        BIO_printf(bio_err, \"Subject Name  :%s\\n\", p);\n        ok = -1;                /* This is now a 'bad' error. */\n        goto end;\n    }\n\n    if (!default_op) {\n        BIO_printf(bio_err, \"Certificate Details:\\n\");\n        /*\n         * Never print signature details because signature not present\n         */\n        certopt |= X509_FLAG_NO_SIGDUMP | X509_FLAG_NO_SIGNAME;\n        X509_print_ex(bio_err, ret, nameopt, certopt);\n    }\n\n    BIO_printf(bio_err, \"Certificate is to be certified until \");\n    ASN1_TIME_print_ex(bio_err, X509_get0_notAfter(ret), dateopt);\n    if (days)\n        BIO_printf(bio_err, \" (%ld days)\", days);\n    BIO_printf(bio_err, \"\\n\");\n\n    if (!batch) {\n\n        BIO_printf(bio_err, \"Sign the certificate? [y/n]:\");\n        (void)BIO_flush(bio_err);\n        buf[0] = '\\0';\n        if (fgets(buf, sizeof(buf), stdin) == NULL) {\n            BIO_printf(bio_err,\n                       \"CERTIFICATE WILL NOT BE CERTIFIED: I/O error\\n\");\n            ok = 0;\n            goto end;\n        }\n        if (!(buf[0] == 'y' || buf[0] == 'Y')) {\n            BIO_printf(bio_err, \"CERTIFICATE WILL NOT BE CERTIFIED\\n\");\n            ok = 0;\n            goto end;\n        }\n    }\n\n    pktmp = X509_get0_pubkey(ret);\n    if (EVP_PKEY_missing_parameters(pktmp) &&\n        !EVP_PKEY_missing_parameters(pkey))\n        EVP_PKEY_copy_parameters(pktmp, pkey);\n\n    if (!do_X509_sign(ret, 0, pkey, dgst, sigopts, &ext_ctx))\n        goto end;\n\n    /* We now just add it to the database as DB_TYPE_VAL('V') */\n    row[DB_type] = OPENSSL_strdup(\"V\");\n    tm = X509_get0_notAfter(ret);\n    row[DB_exp_date] = app_malloc(tm->length + 1, \"row expdate\");\n    memcpy(row[DB_exp_date], tm->data, tm->length);\n    row[DB_exp_date][tm->length] = '\\0';\n    row[DB_rev_date] = NULL;\n    row[DB_file] = OPENSSL_strdup(\"unknown\");\n    if ((row[DB_type] == NULL) || (row[DB_file] == NULL)\n        || (row[DB_name] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n\n    irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row space\");\n    for (i = 0; i < DB_NUMBER; i++)\n        irow[i] = row[i];\n    irow[DB_NUMBER] = NULL;\n\n    if (!TXT_DB_insert(db->db, irow)) {\n        BIO_printf(bio_err, \"failed to update database\\n\");\n        BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n        goto end;\n    }\n    irow = NULL;\n    ok = 1;\n end:\n    if (ok != 1) {\n        for (i = 0; i < DB_NUMBER; i++)\n            OPENSSL_free(row[i]);\n    }\n    OPENSSL_free(irow);\n\n    X509_NAME_free(CAname);\n    X509_NAME_free(subject);\n    if (ok <= 0)\n        X509_free(ret);\n    else\n        *xret = ret;\n    return ok;\n}",
            "int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from)\n{\n    /*\n     * Clean up legacy stuff from this function when legacy support is gone.\n     */\n\n    EVP_PKEY *downgraded_from = NULL;\n    int ok = 0;\n\n    /*\n     * If |to| is a legacy key and |from| isn't, we must make a downgraded\n     * copy of |from|.  If that fails, this function fails.\n     */\n    if (evp_pkey_is_legacy(to) && evp_pkey_is_provided(from)) {\n        if (!evp_pkey_copy_downgraded(&downgraded_from, from))\n            goto end;\n        from = downgraded_from;\n    }\n\n    /*\n     * Make sure |to| is typed.  Content is less important at this early\n     * stage.\n     *\n     * 1.  If |to| is untyped, assign |from|'s key type to it.\n     * 2.  If |to| contains a legacy key, compare its |type| to |from|'s.\n     *     (|from| was already downgraded above)\n     *\n     * If |to| is a provided key, there's nothing more to do here, functions\n     * like evp_keymgmt_util_copy() and evp_pkey_export_to_provider() called\n     * further down help us find out if they are the same or not.\n     */\n    if (evp_pkey_is_blank(to)) {\n        if (evp_pkey_is_legacy(from)) {\n            if (EVP_PKEY_set_type(to, from->type) == 0)\n                goto end;\n        } else {\n            if (EVP_PKEY_set_type_by_keymgmt(to, from->keymgmt) == 0)\n                goto end;\n        }\n    } else if (evp_pkey_is_legacy(to)) {\n        if (to->type != from->type) {\n            ERR_raise(ERR_LIB_EVP, EVP_R_DIFFERENT_KEY_TYPES);\n            goto end;\n        }\n    }\n\n    if (EVP_PKEY_missing_parameters(from)) {\n        ERR_raise(ERR_LIB_EVP, EVP_R_MISSING_PARAMETERS);\n        goto end;\n    }\n\n    if (!EVP_PKEY_missing_parameters(to)) {\n        if (EVP_PKEY_parameters_eq(to, from) == 1)\n            ok = 1;\n        else\n            ERR_raise(ERR_LIB_EVP, EVP_R_DIFFERENT_PARAMETERS);\n        goto end;\n    }\n\n    /* For purely provided keys, we just call the keymgmt utility */\n    if (to->keymgmt != NULL && from->keymgmt != NULL) {\n        ok = evp_keymgmt_util_copy(to, (EVP_PKEY *)from, SELECT_PARAMETERS);\n        goto end;\n    }\n\n    /*\n     * If |to| is provided, we know that |from| is legacy at this point.\n     * Try exporting |from| to |to|'s keymgmt, then use evp_keymgmt_dup()\n     * to copy the appropriate data to |to|'s keydata.\n     * We cannot override existing data so do it only if there is no keydata\n     * in |to| yet.\n     */\n    if (to->keymgmt != NULL && to->keydata == NULL) {\n        EVP_KEYMGMT *to_keymgmt = to->keymgmt;\n        void *from_keydata =\n            evp_pkey_export_to_provider((EVP_PKEY *)from, NULL, &to_keymgmt,\n                                        NULL);\n\n        /*\n         * If we get a NULL, it could be an internal error, or it could be\n         * that there's a key mismatch.  We're pretending the latter...\n         */\n        if (from_keydata == NULL)\n            ERR_raise(ERR_LIB_EVP, EVP_R_DIFFERENT_KEY_TYPES);\n        else\n            ok = (to->keydata = evp_keymgmt_dup(to->keymgmt,\n                                                from_keydata,\n                                                SELECT_PARAMETERS)) != NULL;\n        goto end;\n    }\n\n    /* Both keys are legacy */\n    if (from->ameth != NULL && from->ameth->param_copy != NULL)\n        ok = from->ameth->param_copy(to, from);\n end:\n    EVP_PKEY_free(downgraded_from);\n    return ok;\n}"
        ],
        "sink": "EVP_PKEY_copy_parameters(pktmp, pkey);",
        "final_sink": "    if (evp_pkey_is_legacy(to) && evp_pkey_is_provided(from)) {",
        "source": [
            "    str = app_malloc(i, \"revocation reason\");"
        ],
        "index": 0
    },
    {
        "prt": "outdir",
        "function_call": [
            "int ca_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ENGINE *e = NULL;\n    BIGNUM *crlnumber = NULL, *serial = NULL;\n    EVP_PKEY *pkey = NULL;\n    BIO *in = NULL, *out = NULL, *Sout = NULL;\n    ASN1_INTEGER *tmpser;\n    CA_DB *db = NULL;\n    DB_ATTR db_attr;\n    STACK_OF(CONF_VALUE) *attribs = NULL;\n    STACK_OF(OPENSSL_STRING) *sigopts = NULL, *vfyopts = NULL;\n    STACK_OF(X509) *cert_sk = NULL;\n    X509_CRL *crl = NULL;\n    char *configfile = default_config_file, *section = NULL;\n    char def_dgst[80] = \"\";\n    char *dgst = NULL, *policy = NULL, *keyfile = NULL;\n    char *certfile = NULL, *crl_ext = NULL, *crlnumberfile = NULL;\n    int certformat = FORMAT_UNDEF, informat = FORMAT_UNDEF;\n    unsigned long dateopt = ASN1_DTFLGS_RFC822;\n    const char *infile = NULL, *spkac_file = NULL, *ss_cert_file = NULL;\n    const char *extensions = NULL, *extfile = NULL, *passinarg = NULL;\n    char *passin = NULL;\n    char *outdir = NULL, *outfile = NULL, *rev_arg = NULL, *ser_status = NULL;\n    const char *serialfile = NULL, *subj = NULL;\n    char *prog, *startdate = NULL, *enddate = NULL;\n    char *dbfile = NULL, *f;\n    char new_cert[PATH_MAX];\n    char tmp[10 + 1] = \"\\0\";\n    char *const *pp;\n    const char *p;\n    size_t outdirlen = 0;\n    int create_ser = 0, free_passin = 0, total = 0, total_done = 0;\n    int batch = 0, default_op = 1, doupdatedb = 0, ext_copy = EXT_COPY_NONE;\n    int keyformat = FORMAT_UNDEF, multirdn = 1, notext = 0, output_der = 0;\n    int ret = 1, email_dn = 1, req = 0, verbose = 0, gencrl = 0, dorevoke = 0;\n    int rand_ser = 0, i, j, selfsign = 0, def_ret;\n    char *crl_lastupdate = NULL, *crl_nextupdate = NULL;\n    long crldays = 0, crlhours = 0, crlsec = 0, days = 0;\n    unsigned long chtype = MBSTRING_ASC, certopt = 0;\n    X509 *x509 = NULL, *x509p = NULL, *x = NULL;\n    REVINFO_TYPE rev_type = REV_NONE;\n    X509_REVOKED *r = NULL;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, ca_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\nopthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ca_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            req = 1;\n            infile = opt_arg();\n            break;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_DATEOPT:\n            if (!set_dateopt(&dateopt, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_VERBOSE:\n            verbose = 1;\n            break;\n        case OPT_QUIET:\n            verbose = 0;\n            break;\n        case OPT_CONFIG:\n            configfile = opt_arg();\n            break;\n        case OPT_NAME:\n            section = opt_arg();\n            break;\n        case OPT_SUBJ:\n            subj = opt_arg();\n            /* preserve=1; */\n            break;\n        case OPT_UTF8:\n            chtype = MBSTRING_UTF8;\n            break;\n        case OPT_RAND_SERIAL:\n            rand_ser = 1;\n            break;\n        case OPT_CREATE_SERIAL:\n            create_ser = 1;\n            break;\n        case OPT_MULTIVALUE_RDN:\n            /* obsolete */\n            break;\n        case OPT_STARTDATE:\n        case OPT_NOT_BEFORE:\n            startdate = opt_arg();\n            break;\n        case OPT_ENDDATE:\n        case OPT_NOT_AFTER:\n            enddate = opt_arg();\n            break;\n        case OPT_DAYS:\n            days = atoi(opt_arg());\n            break;\n        case OPT_MD:\n            dgst = opt_arg();\n            break;\n        case OPT_POLICY:\n            policy = opt_arg();\n            break;\n        case OPT_KEYFILE:\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyformat))\n                goto opthelp;\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_KEY:\n            passin = opt_arg();\n            break;\n        case OPT_CERT:\n            certfile = opt_arg();\n            break;\n        case OPT_CERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &certformat))\n                goto opthelp;\n            break;\n        case OPT_SELFSIGN:\n            selfsign = 1;\n            break;\n        case OPT_OUTDIR:\n            outdir = opt_arg();\n            break;\n        case OPT_SIGOPT:\n            if (sigopts == NULL)\n                sigopts = sk_OPENSSL_STRING_new_null();\n            if (sigopts == NULL || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_VFYOPT:\n            if (vfyopts == NULL)\n                vfyopts = sk_OPENSSL_STRING_new_null();\n            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_NOTEXT:\n            notext = 1;\n            break;\n        case OPT_BATCH:\n            batch = 1;\n            break;\n        case OPT_PRESERVEDN:\n            preserve = 1;\n            break;\n        case OPT_NOEMAILDN:\n            email_dn = 0;\n            break;\n        case OPT_GENCRL:\n            gencrl = 1;\n            break;\n        case OPT_MSIE_HACK:\n            msie_hack = 1;\n            break;\n        case OPT_CRL_LASTUPDATE:\n            crl_lastupdate = opt_arg();\n            break;\n        case OPT_CRL_NEXTUPDATE:\n            crl_nextupdate = opt_arg();\n            break;\n        case OPT_CRLDAYS:\n            crldays = atol(opt_arg());\n            break;\n        case OPT_CRLHOURS:\n            crlhours = atol(opt_arg());\n            break;\n        case OPT_CRLSEC:\n            crlsec = atol(opt_arg());\n            break;\n        case OPT_INFILES:\n            req = 1;\n            goto end_of_options;\n        case OPT_SS_CERT:\n            ss_cert_file = opt_arg();\n            req = 1;\n            break;\n        case OPT_SPKAC:\n            spkac_file = opt_arg();\n            req = 1;\n            break;\n        case OPT_REVOKE:\n            infile = opt_arg();\n            dorevoke = 1;\n            break;\n        case OPT_VALID:\n            infile = opt_arg();\n            dorevoke = 2;\n            break;\n        case OPT_EXTENSIONS:\n            extensions = opt_arg();\n            break;\n        case OPT_EXTFILE:\n            extfile = opt_arg();\n            break;\n        case OPT_STATUS:\n            ser_status = opt_arg();\n            break;\n        case OPT_UPDATEDB:\n            doupdatedb = 1;\n            break;\n        case OPT_CRLEXTS:\n            crl_ext = opt_arg();\n            break;\n        case OPT_CRL_REASON:   /* := REV_CRL_REASON */\n        case OPT_CRL_HOLD:\n        case OPT_CRL_COMPROMISE:\n        case OPT_CRL_CA_COMPROMISE:\n            rev_arg = opt_arg();\n            rev_type = (o - OPT_CRL_REASON) + REV_CRL_REASON;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n\nend_of_options:\n    /* Remaining args are files to certify. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((conf = app_load_config_verbose(configfile, 1)) == NULL)\n        goto end;\n    if (configfile != default_config_file && !app_load_modules(conf))\n        goto end;\n\n    /* Lets get the config section we are using */\n    if (section == NULL\n        && (section = lookup_conf(conf, BASE_SECTION, ENV_DEFAULT_CA)) == NULL)\n        goto end;\n\n    p = app_conf_try_string(conf, NULL, \"oid_file\");\n    if (p != NULL) {\n        BIO *oid_bio = BIO_new_file(p, \"r\");\n\n        if (oid_bio == NULL) {\n            ERR_clear_error();\n        } else {\n            OBJ_create_objects(oid_bio);\n            BIO_free(oid_bio);\n        }\n    }\n    if (!add_oid_section(conf))\n        goto end;\n\n    app_RAND_load_conf(conf, BASE_SECTION);\n    if (!app_RAND_load())\n        goto end;\n\n    f = app_conf_try_string(conf, section, STRING_MASK);\n    if (f != NULL && !ASN1_STRING_set_default_mask_asc(f)) {\n        BIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", f);\n        goto end;\n    }\n\n    if (chtype != MBSTRING_UTF8) {\n        f = app_conf_try_string(conf, section, UTF8_IN);\n        if (f != NULL && strcmp(f, \"yes\") == 0)\n            chtype = MBSTRING_UTF8;\n    }\n\n    db_attr.unique_subject = 1;\n    p = app_conf_try_string(conf, section, ENV_UNIQUE_SUBJECT);\n    if (p != NULL)\n        db_attr.unique_subject = parse_yesno(p, 1);\n\n    /*****************************************************************/\n    /* report status of cert with serial number given on command line */\n    if (ser_status) {\n        dbfile = lookup_conf(conf, section, ENV_DATABASE);\n        if (dbfile == NULL)\n            goto end;\n\n        db = load_index(dbfile, &db_attr);\n        if (db == NULL) {\n            BIO_printf(bio_err, \"Problem with index file: %s (could not load/parse file)\\n\", dbfile);\n            goto end;\n        }\n\n        if (index_index(db) <= 0)\n            goto end;\n\n        if (get_certificate_status(ser_status, db) != 1)\n            BIO_printf(bio_err, \"Error verifying serial %s!\\n\", ser_status);\n        goto end;\n    }\n\n    /*****************************************************************/\n    /* we definitely need a private key, so let's get it */\n\n    if (keyfile == NULL\n        && (keyfile = lookup_conf(conf, section, ENV_PRIVATE_KEY)) == NULL)\n        goto end;\n\n    if (passin == NULL) {\n        free_passin = 1;\n        if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n            BIO_printf(bio_err, \"Error getting password\\n\");\n            goto end;\n        }\n    }\n    pkey = load_key(keyfile, keyformat, 0, passin, e, \"CA private key\");\n    cleanse(passin);\n    if (pkey == NULL)\n        /* load_key() has already printed an appropriate message */\n        goto end;\n\n    /*****************************************************************/\n    /* we need a certificate */\n    if (!selfsign || spkac_file || ss_cert_file || gencrl) {\n        if (certfile == NULL\n            && (certfile = lookup_conf(conf, section, ENV_CERTIFICATE)) == NULL)\n            goto end;\n\n        x509 = load_cert_pass(certfile, certformat, 1, passin, \"CA certificate\");\n        if (x509 == NULL)\n            goto end;\n\n        if (!X509_check_private_key(x509, pkey)) {\n            BIO_printf(bio_err,\n                       \"CA certificate and CA private key do not match\\n\");\n            goto end;\n        }\n    }\n    if (!selfsign)\n        x509p = x509;\n\n    f = app_conf_try_string(conf, BASE_SECTION, ENV_PRESERVE);\n    if (f != NULL && (*f == 'y' || *f == 'Y'))\n        preserve = 1;\n    f = app_conf_try_string(conf, BASE_SECTION, ENV_MSIE_HACK);\n    if (f != NULL && (*f == 'y' || *f == 'Y'))\n        msie_hack = 1;\n\n    f = app_conf_try_string(conf, section, ENV_NAMEOPT);\n    if (f != NULL) {\n        if (!set_nameopt(f)) {\n            BIO_printf(bio_err, \"Invalid name options: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n        default_op = 0;\n    }\n\n    f = app_conf_try_string(conf, section, ENV_CERTOPT);\n    if (f != NULL) {\n        if (!set_cert_ex(&certopt, f)) {\n            BIO_printf(bio_err, \"Invalid certificate options: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n        default_op = 0;\n    }\n\n    f = app_conf_try_string(conf, section, ENV_EXTCOPY);\n    if (f != NULL) {\n        if (!set_ext_copy(&ext_copy, f)) {\n            BIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n    }\n\n    /*****************************************************************/\n    /* lookup where to write new certificates */\n    if ((outdir == NULL) && (req)) {\n\n        outdir = NCONF_get_string(conf, section, ENV_NEW_CERTS_DIR);\n        if (outdir == NULL) {\n            BIO_printf(bio_err,\n                       \"there needs to be defined a directory for new certificate to be placed in\\n\");\n            goto end;\n        }\n#ifndef OPENSSL_SYS_VMS\n        /*\n         * outdir is a directory spec, but access() for VMS demands a\n         * filename.  We could use the DEC C routine to convert the\n         * directory syntax to Unix, and give that to app_isdir,\n         * but for now the fopen will catch the error if it's not a\n         * directory\n         */\n        if (app_isdir(outdir) <= 0) {\n            BIO_printf(bio_err, \"%s: %s is not a directory\\n\", prog, outdir);\n            perror(outdir);\n            goto end;\n        }\n#endif\n    }\n\n    /*****************************************************************/\n    /* we need to load the database file */\n    dbfile = lookup_conf(conf, section, ENV_DATABASE);\n    if (dbfile == NULL)\n        goto end;\n\n    db = load_index(dbfile, &db_attr);\n    if (db == NULL) {\n        BIO_printf(bio_err, \"Problem with index file: %s (could not load/parse file)\\n\", dbfile);\n        goto end;\n    }\n\n    /* Lets check some fields */\n    for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\n        pp = sk_OPENSSL_PSTRING_value(db->db->data, i);\n        if ((pp[DB_type][0] != DB_TYPE_REV) && (pp[DB_rev_date][0] != '\\0')) {\n            BIO_printf(bio_err,\n                       \"entry %d: not revoked yet, but has a revocation date\\n\",\n                       i + 1);\n            goto end;\n        }\n        if ((pp[DB_type][0] == DB_TYPE_REV) &&\n            !make_revoked(NULL, pp[DB_rev_date])) {\n            BIO_printf(bio_err, \" in entry %d\\n\", i + 1);\n            goto end;\n        }\n        if (!check_time_format((char *)pp[DB_exp_date])) {\n            BIO_printf(bio_err, \"entry %d: invalid expiry date\\n\", i + 1);\n            goto end;\n        }\n        p = pp[DB_serial];\n        j = strlen(p);\n        if (*p == '-') {\n            p++;\n            j--;\n        }\n        if ((j & 1) || (j < 2)) {\n            BIO_printf(bio_err, \"entry %d: bad serial number length (%d)\\n\",\n                       i + 1, j);\n            goto end;\n        }\n        for ( ; *p; p++) {\n            if (!isxdigit(_UC(*p))) {\n                BIO_printf(bio_err,\n                           \"entry %d: bad char 0%o '%c' in serial number\\n\",\n                           i + 1, *p, *p);\n                goto end;\n            }\n        }\n    }\n    if (verbose) {\n        TXT_DB_write(bio_out, db->db);\n        BIO_printf(bio_err, \"%d entries loaded from the database\\n\",\n                   sk_OPENSSL_PSTRING_num(db->db->data));\n        BIO_printf(bio_err, \"generating index\\n\");\n    }\n\n    if (index_index(db) <= 0)\n        goto end;\n\n    /*****************************************************************/\n    /* Update the db file for expired certificates */\n    if (doupdatedb) {\n        if (verbose)\n            BIO_printf(bio_err, \"Updating %s ...\\n\", dbfile);\n\n        i = do_updatedb(db, NULL);\n        if (i == -1) {\n            BIO_printf(bio_err, \"Malloc failure\\n\");\n            goto end;\n        } else if (i == 0) {\n            if (verbose)\n                BIO_printf(bio_err, \"No entries found to mark expired\\n\");\n        } else {\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            if (verbose)\n                BIO_printf(bio_err, \"Done. %d entries marked as expired\\n\", i);\n        }\n    }\n\n    /*****************************************************************/\n    /* Read extensions config file                                   */\n    if (extfile) {\n        if ((extfile_conf = app_load_config(extfile)) == NULL) {\n            ret = 1;\n            goto end;\n        }\n\n        if (verbose)\n            BIO_printf(bio_err, \"Successfully loaded extensions file %s\\n\",\n                       extfile);\n\n        /* We can have sections in the ext file */\n        if (extensions == NULL) {\n            extensions =\n                app_conf_try_string(extfile_conf, \"default\", \"extensions\");\n            if (extensions == NULL)\n                extensions = \"default\";\n        }\n    }\n\n    /*****************************************************************/\n    if (req || gencrl) {\n        if (spkac_file != NULL && outfile != NULL) {\n            output_der = 1;\n            batch = 1;\n        }\n    }\n\n    def_ret = EVP_PKEY_get_default_digest_name(pkey, def_dgst, sizeof(def_dgst));\n    /*\n     * EVP_PKEY_get_default_digest_name() returns 2 if the digest is\n     * mandatory for this algorithm.\n     *\n     * That call may give back the name \"UNDEF\", which has these meanings:\n     *\n     * when def_ret == 2: the user MUST leave the digest unspecified\n     * when def_ret == 1: the user MAY leave the digest unspecified\n     */\n    if (def_ret == 2 && strcmp(def_dgst, \"UNDEF\") == 0) {\n        dgst = NULL;\n    } else if (dgst == NULL\n               && (dgst = lookup_conf(conf, section, ENV_DEFAULT_MD)) == NULL\n               && strcmp(def_dgst, \"UNDEF\") != 0) {\n        goto end;\n    } else {\n        if (strcmp(dgst, \"default\") == 0 || strcmp(def_dgst, \"UNDEF\") == 0) {\n            if (def_ret <= 0) {\n                BIO_puts(bio_err, \"no default digest\\n\");\n                goto end;\n            }\n            dgst = def_dgst;\n        }\n    }\n\n    if (req) {\n        if (email_dn == 1) {\n            char *tmp_email_dn = NULL;\n\n            tmp_email_dn =\n                app_conf_try_string(conf, section, ENV_DEFAULT_EMAIL_DN);\n            if (tmp_email_dn != NULL && strcmp(tmp_email_dn, \"no\") == 0)\n                email_dn = 0;\n        }\n        if (verbose)\n            BIO_printf(bio_err, \"message digest is %s\\n\", dgst);\n        if (policy == NULL\n            && (policy = lookup_conf(conf, section, ENV_POLICY)) == NULL)\n            goto end;\n\n        if (verbose)\n            BIO_printf(bio_err, \"policy is %s\\n\", policy);\n\n        if (app_conf_try_string(conf, section, ENV_RAND_SERIAL) != NULL) {\n            rand_ser = 1;\n        } else {\n            serialfile = lookup_conf(conf, section, ENV_SERIAL);\n            if (serialfile == NULL)\n                goto end;\n        }\n\n        if (extfile_conf != NULL) {\n            /* Check syntax of extfile */\n            X509V3_CTX ctx;\n\n            X509V3_set_ctx_test(&ctx);\n            X509V3_set_nconf(&ctx, extfile_conf);\n            if (!X509V3_EXT_add_nconf(extfile_conf, &ctx, extensions, NULL)) {\n                BIO_printf(bio_err,\n                           \"Error checking certificate extensions from extfile section %s\\n\",\n                           extensions);\n                ret = 1;\n                goto end;\n            }\n        } else {\n            /*\n             * no '-extfile' option, so we look for extensions in the main\n             * configuration file\n             */\n            if (extensions == NULL)\n                extensions = app_conf_try_string(conf, section, ENV_EXTENSIONS);\n            if (extensions != NULL) {\n                /* Check syntax of config file section */\n                X509V3_CTX ctx;\n\n                X509V3_set_ctx_test(&ctx);\n                X509V3_set_nconf(&ctx, conf);\n                if (!X509V3_EXT_add_nconf(conf, &ctx, extensions, NULL)) {\n                    BIO_printf(bio_err,\n                               \"Error checking certificate extension config section %s\\n\",\n                               extensions);\n                    ret = 1;\n                    goto end;\n                }\n            }\n        }\n\n        if (startdate == NULL)\n            startdate =\n                app_conf_try_string(conf, section, ENV_DEFAULT_STARTDATE);\n        if (enddate == NULL)\n            enddate = app_conf_try_string(conf, section, ENV_DEFAULT_ENDDATE);\n        if (days == 0) {\n            if (!app_conf_try_number(conf, section, ENV_DEFAULT_DAYS, &days))\n                days = 0;\n        }\n        if (enddate == NULL && days == 0) {\n            BIO_printf(bio_err, \"cannot lookup how many days to certify for\\n\");\n            goto end;\n        }\n        if (days != 0 && enddate != NULL)\n            BIO_printf(bio_err,\n                       \"Warning: -enddate or -not_after option overriding -days option\\n\");\n\n        if (rand_ser) {\n            if ((serial = BN_new()) == NULL || !rand_serial(serial, NULL)) {\n                BIO_printf(bio_err, \"error generating serial number\\n\");\n                goto end;\n            }\n        } else {\n            serial = load_serial(serialfile, NULL, create_ser, NULL);\n            if (serial == NULL) {\n                BIO_printf(bio_err, \"error while loading serial number\\n\");\n                goto end;\n            }\n            if (verbose) {\n                if (BN_is_zero(serial)) {\n                    BIO_printf(bio_err, \"next serial number is 00\\n\");\n                } else {\n                    if ((f = BN_bn2hex(serial)) == NULL)\n                        goto end;\n                    BIO_printf(bio_err, \"next serial number is %s\\n\", f);\n                    OPENSSL_free(f);\n                }\n            }\n        }\n\n        if ((attribs = NCONF_get_section(conf, policy)) == NULL) {\n            BIO_printf(bio_err, \"unable to find 'section' for %s\\n\", policy);\n            goto end;\n        }\n\n        if ((cert_sk = sk_X509_new_null()) == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n        if (spkac_file != NULL) {\n            total++;\n            j = certify_spkac(&x, spkac_file, pkey, x509, dgst, sigopts,\n                              attribs, db, serial, subj, chtype, multirdn,\n                              email_dn, startdate, enddate, days, extensions,\n                              conf, verbose, certopt, get_nameopt(), default_op,\n                              ext_copy, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        if (ss_cert_file != NULL) {\n            total++;\n            j = certify_cert(&x, ss_cert_file, certformat, passin, pkey,\n                             x509, dgst, sigopts, vfyopts, attribs,\n                             db, serial, subj, chtype, multirdn, email_dn,\n                             startdate, enddate, days, batch, extensions,\n                             conf, verbose, certopt, get_nameopt(), default_op,\n                             ext_copy, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        if (infile != NULL) {\n            total++;\n            j = certify(&x, infile, informat, pkey, x509p, dgst,\n                        sigopts, vfyopts, attribs, db,\n                        serial, subj, chtype, multirdn, email_dn, startdate,\n                        enddate, days, batch, extensions, conf, verbose,\n                        certopt, get_nameopt(), default_op, ext_copy, selfsign, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        for (i = 0; i < argc; i++) {\n            total++;\n            j = certify(&x, argv[i], informat, pkey, x509p, dgst,\n                        sigopts, vfyopts,\n                        attribs, db,\n                        serial, subj, chtype, multirdn, email_dn, startdate,\n                        enddate, days, batch, extensions, conf, verbose,\n                        certopt, get_nameopt(), default_op, ext_copy, selfsign, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1)) {\n                    X509_free(x);\n                    goto end;\n                }\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    X509_free(x);\n                    goto end;\n                }\n            }\n        }\n        /*\n         * we have a stack of newly certified certificates and a database\n         * and serial number that need updating\n         */\n\n        if (sk_X509_num(cert_sk) > 0) {\n            if (!batch) {\n                BIO_printf(bio_err,\n                           \"\\n%d out of %d certificate requests certified, commit? [y/n]\",\n                           total_done, total);\n                (void)BIO_flush(bio_err);\n                tmp[0] = '\\0';\n                if (fgets(tmp, sizeof(tmp), stdin) == NULL) {\n                    BIO_printf(bio_err, \"CERTIFICATION CANCELED: I/O error\\n\");\n                    ret = 0;\n                    goto end;\n                }\n                if (tmp[0] != 'y' && tmp[0] != 'Y') {\n                    BIO_printf(bio_err, \"CERTIFICATION CANCELED\\n\");\n                    ret = 0;\n                    goto end;\n                }\n            }\n\n            BIO_printf(bio_err, \"Write out database with %d new entries\\n\",\n                       sk_X509_num(cert_sk));\n\n            if (serialfile != NULL\n                    && !save_serial(serialfile, \"new\", serial, NULL))\n                goto end;\n\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n        }\n\n        outdirlen = OPENSSL_strlcpy(new_cert, outdir, sizeof(new_cert));\n#ifndef OPENSSL_SYS_VMS\n        outdirlen = OPENSSL_strlcat(new_cert, \"/\", sizeof(new_cert));\n#endif\n\n        if (verbose)\n            BIO_printf(bio_err, \"writing new certificates\\n\");\n\n        for (i = 0; i < sk_X509_num(cert_sk); i++) {\n            BIO *Cout = NULL;\n            X509 *xi = sk_X509_value(cert_sk, i);\n            const ASN1_INTEGER *serialNumber = X509_get0_serialNumber(xi);\n            const unsigned char *psn = ASN1_STRING_get0_data(serialNumber);\n            const int snl = ASN1_STRING_length(serialNumber);\n            const int filen_len = 2 * (snl > 0 ? snl : 1) + sizeof(\".pem\");\n            char *n = new_cert + outdirlen;\n\n            if (outdirlen + filen_len > PATH_MAX) {\n                BIO_printf(bio_err, \"certificate file name too long\\n\");\n                goto end;\n            }\n\n            if (snl > 0) {\n                static const char HEX_DIGITS[] = \"0123456789ABCDEF\";\n\n                for (j = 0; j < snl; j++, psn++) {\n                    *n++ = HEX_DIGITS[*psn >> 4];\n                    *n++ = HEX_DIGITS[*psn & 0x0F];\n                }\n            } else {\n                *(n++) = '0';\n                *(n++) = '0';\n            }\n            *(n++) = '.';\n            *(n++) = 'p';\n            *(n++) = 'e';\n            *(n++) = 'm';\n            *n = '\\0';          /* closing new_cert */\n            if (verbose)\n                BIO_printf(bio_err, \"writing %s\\n\", new_cert);\n\n            Sout = bio_open_default(outfile, 'w',\n                                    output_der ? FORMAT_ASN1 : FORMAT_TEXT);\n            if (Sout == NULL)\n                goto end;\n\n            Cout = BIO_new_file(new_cert, \"w\");\n            if (Cout == NULL) {\n                perror(new_cert);\n                goto end;\n            }\n            write_new_certificate(Cout, xi, 0, notext);\n            write_new_certificate(Sout, xi, output_der, notext);\n            BIO_free_all(Cout);\n            BIO_free_all(Sout);\n            Sout = NULL;\n        }\n\n        if (sk_X509_num(cert_sk)) {\n            /* Rename the database and the serial file */\n            if (serialfile != NULL\n                    && !rotate_serial(serialfile, \"new\", \"old\"))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            BIO_printf(bio_err, \"Database updated\\n\");\n        }\n    }\n\n    /*****************************************************************/\n    if (gencrl) {\n        int crl_v2 = 0;\n\n        if (crl_ext == NULL)\n            crl_ext = app_conf_try_string(conf, section, ENV_CRLEXT);\n        if (crl_ext != NULL) {\n            /* Check syntax of file */\n            X509V3_CTX ctx;\n\n            X509V3_set_ctx_test(&ctx);\n            X509V3_set_nconf(&ctx, conf);\n            if (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL)) {\n                BIO_printf(bio_err,\n                           \"Error checking CRL extension section %s\\n\", crl_ext);\n                ret = 1;\n                goto end;\n            }\n        }\n\n        crlnumberfile = app_conf_try_string(conf, section, ENV_CRLNUMBER);\n        if (crlnumberfile != NULL) {\n            if ((crlnumber = load_serial(crlnumberfile, NULL, 0, NULL))\n                == NULL) {\n                BIO_printf(bio_err, \"error while loading CRL number\\n\");\n                goto end;\n            }\n        }\n\n        if (!crldays && !crlhours && !crlsec) {\n            if (!app_conf_try_number(conf, section,\n                                  ENV_DEFAULT_CRL_DAYS, &crldays))\n                crldays = 0;\n            if (!app_conf_try_number(conf, section,\n                                  ENV_DEFAULT_CRL_HOURS, &crlhours))\n                crlhours = 0;\n        }\n        if ((crl_nextupdate == NULL) &&\n                (crldays == 0) && (crlhours == 0) && (crlsec == 0)) {\n            BIO_printf(bio_err,\n                       \"cannot lookup how long until the next CRL is issued\\n\");\n            goto end;\n        }\n\n        if (verbose)\n            BIO_printf(bio_err, \"making CRL\\n\");\n        if ((crl = X509_CRL_new_ex(app_get0_libctx(), app_get0_propq())) == NULL)\n            goto end;\n        if (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509)))\n            goto end;\n\n        if (!set_crl_lastupdate(crl, crl_lastupdate)) {\n            BIO_puts(bio_err, \"error setting CRL lastUpdate\\n\");\n            ret = 1;\n            goto end;\n        }\n\n        if (!set_crl_nextupdate(crl, crl_nextupdate,\n                                crldays, crlhours, crlsec)) {\n            BIO_puts(bio_err, \"error setting CRL nextUpdate\\n\");\n            ret = 1;\n            goto end;\n        }\n\n        for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\n            pp = sk_OPENSSL_PSTRING_value(db->db->data, i);\n            if (pp[DB_type][0] == DB_TYPE_REV) {\n                if ((r = X509_REVOKED_new()) == NULL)\n                    goto end;\n                j = make_revoked(r, pp[DB_rev_date]);\n                if (!j)\n                    goto end;\n                if (j == 2)\n                    crl_v2 = 1;\n                if (!BN_hex2bn(&serial, pp[DB_serial]))\n                    goto end;\n                tmpser = BN_to_ASN1_INTEGER(serial, NULL);\n                BN_free(serial);\n                serial = NULL;\n                if (!tmpser)\n                    goto end;\n                X509_REVOKED_set_serialNumber(r, tmpser);\n                ASN1_INTEGER_free(tmpser);\n                X509_CRL_add0_revoked(crl, r);\n            }\n        }\n\n        /*\n         * sort the data so it will be written in serial number order\n         */\n        X509_CRL_sort(crl);\n\n        /* we now have a CRL */\n        if (verbose)\n            BIO_printf(bio_err, \"signing CRL\\n\");\n\n        /* Add any extensions asked for */\n\n        if (crl_ext != NULL || crlnumberfile != NULL) {\n            X509V3_CTX crlctx;\n\n            X509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);\n            X509V3_set_nconf(&crlctx, conf);\n\n            if (crl_ext != NULL)\n                if (!X509V3_EXT_CRL_add_nconf(conf, &crlctx, crl_ext, crl)) {\n                    BIO_printf(bio_err,\n                               \"Error adding CRL extensions from section %s\\n\", crl_ext);\n                    goto end;\n                }\n            if (crlnumberfile != NULL) {\n                tmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);\n                if (!tmpser)\n                    goto end;\n                X509_CRL_add1_ext_i2d(crl, NID_crl_number, tmpser, 0, 0);\n                ASN1_INTEGER_free(tmpser);\n                crl_v2 = 1;\n                if (!BN_add_word(crlnumber, 1))\n                    goto end;\n            }\n        }\n        if (crl_ext != NULL || crl_v2) {\n            if (!X509_CRL_set_version(crl, X509_CRL_VERSION_2))\n                goto end;\n        }\n\n        /* we have a CRL number that need updating */\n        if (crlnumberfile != NULL\n                && !save_serial(crlnumberfile, \"new\", crlnumber, NULL))\n            goto end;\n\n        BN_free(crlnumber);\n        crlnumber = NULL;\n\n        if (!do_X509_CRL_sign(crl, pkey, dgst, sigopts))\n            goto end;\n\n        Sout = bio_open_default(outfile, 'w',\n                                output_der ? FORMAT_ASN1 : FORMAT_TEXT);\n        if (Sout == NULL)\n            goto end;\n\n        PEM_write_bio_X509_CRL(Sout, crl);\n\n        /* Rename the crlnumber file */\n        if (crlnumberfile != NULL\n                && !rotate_serial(crlnumberfile, \"new\", \"old\"))\n            goto end;\n\n    }\n    /*****************************************************************/\n    if (dorevoke) {\n        if (infile == NULL) {\n            BIO_printf(bio_err, \"no input files\\n\");\n            goto end;\n        } else {\n            X509 *revcert;\n\n            revcert = load_cert_pass(infile, informat, 1, passin,\n                                     \"certificate to be revoked\");\n            if (revcert == NULL)\n                goto end;\n            if (dorevoke == 2)\n                rev_type = REV_VALID;\n            j = do_revoke(revcert, db, rev_type, rev_arg);\n            if (j <= 0)\n                goto end;\n            X509_free(revcert);\n\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            BIO_printf(bio_err, \"Database updated\\n\");\n        }\n    }\n    ret = 0;\n\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    BIO_free_all(Sout);\n    BIO_free_all(out);\n    BIO_free_all(in);\n    OSSL_STACK_OF_X509_free(cert_sk);\n\n    cleanse(passin);\n    if (free_passin)\n        OPENSSL_free(passin);\n    BN_free(serial);\n    BN_free(crlnumber);\n    free_index(db);\n    sk_OPENSSL_STRING_free(sigopts);\n    sk_OPENSSL_STRING_free(vfyopts);\n    EVP_PKEY_free(pkey);\n    X509_free(x509);\n    X509_CRL_free(crl);\n    NCONF_free(conf);\n    NCONF_free(extfile_conf);\n    release_engine(e);\n    return ret;\n}",
            "size_t OPENSSL_strlcpy(char *dst, const char *src, size_t size)\n{\n    size_t l = 0;\n    for (; size > 1 && *src; size--) {\n        *dst++ = *src++;\n        l++;\n    }\n    if (size)\n        *dst = CH_ZERO;\n    return l + strlen(src);\n}"
        ],
        "sink": "outdirlen = OPENSSL_strlcpy(new_cert, outdir, sizeof(new_cert));",
        "final_sink": "    for (; size > 1 && *src; size--) {",
        "source": [
            "        rrow = sk_OPENSSL_PSTRING_value(db->db->data, i);"
        ],
        "index": 1
    },
    {
        "prt": "crlnumber",
        "function_call": [
            "int ca_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ENGINE *e = NULL;\n    BIGNUM *crlnumber = NULL, *serial = NULL;\n    EVP_PKEY *pkey = NULL;\n    BIO *in = NULL, *out = NULL, *Sout = NULL;\n    ASN1_INTEGER *tmpser;\n    CA_DB *db = NULL;\n    DB_ATTR db_attr;\n    STACK_OF(CONF_VALUE) *attribs = NULL;\n    STACK_OF(OPENSSL_STRING) *sigopts = NULL, *vfyopts = NULL;\n    STACK_OF(X509) *cert_sk = NULL;\n    X509_CRL *crl = NULL;\n    char *configfile = default_config_file, *section = NULL;\n    char def_dgst[80] = \"\";\n    char *dgst = NULL, *policy = NULL, *keyfile = NULL;\n    char *certfile = NULL, *crl_ext = NULL, *crlnumberfile = NULL;\n    int certformat = FORMAT_UNDEF, informat = FORMAT_UNDEF;\n    unsigned long dateopt = ASN1_DTFLGS_RFC822;\n    const char *infile = NULL, *spkac_file = NULL, *ss_cert_file = NULL;\n    const char *extensions = NULL, *extfile = NULL, *passinarg = NULL;\n    char *passin = NULL;\n    char *outdir = NULL, *outfile = NULL, *rev_arg = NULL, *ser_status = NULL;\n    const char *serialfile = NULL, *subj = NULL;\n    char *prog, *startdate = NULL, *enddate = NULL;\n    char *dbfile = NULL, *f;\n    char new_cert[PATH_MAX];\n    char tmp[10 + 1] = \"\\0\";\n    char *const *pp;\n    const char *p;\n    size_t outdirlen = 0;\n    int create_ser = 0, free_passin = 0, total = 0, total_done = 0;\n    int batch = 0, default_op = 1, doupdatedb = 0, ext_copy = EXT_COPY_NONE;\n    int keyformat = FORMAT_UNDEF, multirdn = 1, notext = 0, output_der = 0;\n    int ret = 1, email_dn = 1, req = 0, verbose = 0, gencrl = 0, dorevoke = 0;\n    int rand_ser = 0, i, j, selfsign = 0, def_ret;\n    char *crl_lastupdate = NULL, *crl_nextupdate = NULL;\n    long crldays = 0, crlhours = 0, crlsec = 0, days = 0;\n    unsigned long chtype = MBSTRING_ASC, certopt = 0;\n    X509 *x509 = NULL, *x509p = NULL, *x = NULL;\n    REVINFO_TYPE rev_type = REV_NONE;\n    X509_REVOKED *r = NULL;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, ca_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\nopthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ca_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            req = 1;\n            infile = opt_arg();\n            break;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_DATEOPT:\n            if (!set_dateopt(&dateopt, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_VERBOSE:\n            verbose = 1;\n            break;\n        case OPT_QUIET:\n            verbose = 0;\n            break;\n        case OPT_CONFIG:\n            configfile = opt_arg();\n            break;\n        case OPT_NAME:\n            section = opt_arg();\n            break;\n        case OPT_SUBJ:\n            subj = opt_arg();\n            /* preserve=1; */\n            break;\n        case OPT_UTF8:\n            chtype = MBSTRING_UTF8;\n            break;\n        case OPT_RAND_SERIAL:\n            rand_ser = 1;\n            break;\n        case OPT_CREATE_SERIAL:\n            create_ser = 1;\n            break;\n        case OPT_MULTIVALUE_RDN:\n            /* obsolete */\n            break;\n        case OPT_STARTDATE:\n        case OPT_NOT_BEFORE:\n            startdate = opt_arg();\n            break;\n        case OPT_ENDDATE:\n        case OPT_NOT_AFTER:\n            enddate = opt_arg();\n            break;\n        case OPT_DAYS:\n            days = atoi(opt_arg());\n            break;\n        case OPT_MD:\n            dgst = opt_arg();\n            break;\n        case OPT_POLICY:\n            policy = opt_arg();\n            break;\n        case OPT_KEYFILE:\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyformat))\n                goto opthelp;\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_KEY:\n            passin = opt_arg();\n            break;\n        case OPT_CERT:\n            certfile = opt_arg();\n            break;\n        case OPT_CERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &certformat))\n                goto opthelp;\n            break;\n        case OPT_SELFSIGN:\n            selfsign = 1;\n            break;\n        case OPT_OUTDIR:\n            outdir = opt_arg();\n            break;\n        case OPT_SIGOPT:\n            if (sigopts == NULL)\n                sigopts = sk_OPENSSL_STRING_new_null();\n            if (sigopts == NULL || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_VFYOPT:\n            if (vfyopts == NULL)\n                vfyopts = sk_OPENSSL_STRING_new_null();\n            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_NOTEXT:\n            notext = 1;\n            break;\n        case OPT_BATCH:\n            batch = 1;\n            break;\n        case OPT_PRESERVEDN:\n            preserve = 1;\n            break;\n        case OPT_NOEMAILDN:\n            email_dn = 0;\n            break;\n        case OPT_GENCRL:\n            gencrl = 1;\n            break;\n        case OPT_MSIE_HACK:\n            msie_hack = 1;\n            break;\n        case OPT_CRL_LASTUPDATE:\n            crl_lastupdate = opt_arg();\n            break;\n        case OPT_CRL_NEXTUPDATE:\n            crl_nextupdate = opt_arg();\n            break;\n        case OPT_CRLDAYS:\n            crldays = atol(opt_arg());\n            break;\n        case OPT_CRLHOURS:\n            crlhours = atol(opt_arg());\n            break;\n        case OPT_CRLSEC:\n            crlsec = atol(opt_arg());\n            break;\n        case OPT_INFILES:\n            req = 1;\n            goto end_of_options;\n        case OPT_SS_CERT:\n            ss_cert_file = opt_arg();\n            req = 1;\n            break;\n        case OPT_SPKAC:\n            spkac_file = opt_arg();\n            req = 1;\n            break;\n        case OPT_REVOKE:\n            infile = opt_arg();\n            dorevoke = 1;\n            break;\n        case OPT_VALID:\n            infile = opt_arg();\n            dorevoke = 2;\n            break;\n        case OPT_EXTENSIONS:\n            extensions = opt_arg();\n            break;\n        case OPT_EXTFILE:\n            extfile = opt_arg();\n            break;\n        case OPT_STATUS:\n            ser_status = opt_arg();\n            break;\n        case OPT_UPDATEDB:\n            doupdatedb = 1;\n            break;\n        case OPT_CRLEXTS:\n            crl_ext = opt_arg();\n            break;\n        case OPT_CRL_REASON:   /* := REV_CRL_REASON */\n        case OPT_CRL_HOLD:\n        case OPT_CRL_COMPROMISE:\n        case OPT_CRL_CA_COMPROMISE:\n            rev_arg = opt_arg();\n            rev_type = (o - OPT_CRL_REASON) + REV_CRL_REASON;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n\nend_of_options:\n    /* Remaining args are files to certify. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((conf = app_load_config_verbose(configfile, 1)) == NULL)\n        goto end;\n    if (configfile != default_config_file && !app_load_modules(conf))\n        goto end;\n\n    /* Lets get the config section we are using */\n    if (section == NULL\n        && (section = lookup_conf(conf, BASE_SECTION, ENV_DEFAULT_CA)) == NULL)\n        goto end;\n\n    p = app_conf_try_string(conf, NULL, \"oid_file\");\n    if (p != NULL) {\n        BIO *oid_bio = BIO_new_file(p, \"r\");\n\n        if (oid_bio == NULL) {\n            ERR_clear_error();\n        } else {\n            OBJ_create_objects(oid_bio);\n            BIO_free(oid_bio);\n        }\n    }\n    if (!add_oid_section(conf))\n        goto end;\n\n    app_RAND_load_conf(conf, BASE_SECTION);\n    if (!app_RAND_load())\n        goto end;\n\n    f = app_conf_try_string(conf, section, STRING_MASK);\n    if (f != NULL && !ASN1_STRING_set_default_mask_asc(f)) {\n        BIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", f);\n        goto end;\n    }\n\n    if (chtype != MBSTRING_UTF8) {\n        f = app_conf_try_string(conf, section, UTF8_IN);\n        if (f != NULL && strcmp(f, \"yes\") == 0)\n            chtype = MBSTRING_UTF8;\n    }\n\n    db_attr.unique_subject = 1;\n    p = app_conf_try_string(conf, section, ENV_UNIQUE_SUBJECT);\n    if (p != NULL)\n        db_attr.unique_subject = parse_yesno(p, 1);\n\n    /*****************************************************************/\n    /* report status of cert with serial number given on command line */\n    if (ser_status) {\n        dbfile = lookup_conf(conf, section, ENV_DATABASE);\n        if (dbfile == NULL)\n            goto end;\n\n        db = load_index(dbfile, &db_attr);\n        if (db == NULL) {\n            BIO_printf(bio_err, \"Problem with index file: %s (could not load/parse file)\\n\", dbfile);\n            goto end;\n        }\n\n        if (index_index(db) <= 0)\n            goto end;\n\n        if (get_certificate_status(ser_status, db) != 1)\n            BIO_printf(bio_err, \"Error verifying serial %s!\\n\", ser_status);\n        goto end;\n    }\n\n    /*****************************************************************/\n    /* we definitely need a private key, so let's get it */\n\n    if (keyfile == NULL\n        && (keyfile = lookup_conf(conf, section, ENV_PRIVATE_KEY)) == NULL)\n        goto end;\n\n    if (passin == NULL) {\n        free_passin = 1;\n        if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n            BIO_printf(bio_err, \"Error getting password\\n\");\n            goto end;\n        }\n    }\n    pkey = load_key(keyfile, keyformat, 0, passin, e, \"CA private key\");\n    cleanse(passin);\n    if (pkey == NULL)\n        /* load_key() has already printed an appropriate message */\n        goto end;\n\n    /*****************************************************************/\n    /* we need a certificate */\n    if (!selfsign || spkac_file || ss_cert_file || gencrl) {\n        if (certfile == NULL\n            && (certfile = lookup_conf(conf, section, ENV_CERTIFICATE)) == NULL)\n            goto end;\n\n        x509 = load_cert_pass(certfile, certformat, 1, passin, \"CA certificate\");\n        if (x509 == NULL)\n            goto end;\n\n        if (!X509_check_private_key(x509, pkey)) {\n            BIO_printf(bio_err,\n                       \"CA certificate and CA private key do not match\\n\");\n            goto end;\n        }\n    }\n    if (!selfsign)\n        x509p = x509;\n\n    f = app_conf_try_string(conf, BASE_SECTION, ENV_PRESERVE);\n    if (f != NULL && (*f == 'y' || *f == 'Y'))\n        preserve = 1;\n    f = app_conf_try_string(conf, BASE_SECTION, ENV_MSIE_HACK);\n    if (f != NULL && (*f == 'y' || *f == 'Y'))\n        msie_hack = 1;\n\n    f = app_conf_try_string(conf, section, ENV_NAMEOPT);\n    if (f != NULL) {\n        if (!set_nameopt(f)) {\n            BIO_printf(bio_err, \"Invalid name options: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n        default_op = 0;\n    }\n\n    f = app_conf_try_string(conf, section, ENV_CERTOPT);\n    if (f != NULL) {\n        if (!set_cert_ex(&certopt, f)) {\n            BIO_printf(bio_err, \"Invalid certificate options: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n        default_op = 0;\n    }\n\n    f = app_conf_try_string(conf, section, ENV_EXTCOPY);\n    if (f != NULL) {\n        if (!set_ext_copy(&ext_copy, f)) {\n            BIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n    }\n\n    /*****************************************************************/\n    /* lookup where to write new certificates */\n    if ((outdir == NULL) && (req)) {\n\n        outdir = NCONF_get_string(conf, section, ENV_NEW_CERTS_DIR);\n        if (outdir == NULL) {\n            BIO_printf(bio_err,\n                       \"there needs to be defined a directory for new certificate to be placed in\\n\");\n            goto end;\n        }\n#ifndef OPENSSL_SYS_VMS\n        /*\n         * outdir is a directory spec, but access() for VMS demands a\n         * filename.  We could use the DEC C routine to convert the\n         * directory syntax to Unix, and give that to app_isdir,\n         * but for now the fopen will catch the error if it's not a\n         * directory\n         */\n        if (app_isdir(outdir) <= 0) {\n            BIO_printf(bio_err, \"%s: %s is not a directory\\n\", prog, outdir);\n            perror(outdir);\n            goto end;\n        }\n#endif\n    }\n\n    /*****************************************************************/\n    /* we need to load the database file */\n    dbfile = lookup_conf(conf, section, ENV_DATABASE);\n    if (dbfile == NULL)\n        goto end;\n\n    db = load_index(dbfile, &db_attr);\n    if (db == NULL) {\n        BIO_printf(bio_err, \"Problem with index file: %s (could not load/parse file)\\n\", dbfile);\n        goto end;\n    }\n\n    /* Lets check some fields */\n    for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\n        pp = sk_OPENSSL_PSTRING_value(db->db->data, i);\n        if ((pp[DB_type][0] != DB_TYPE_REV) && (pp[DB_rev_date][0] != '\\0')) {\n            BIO_printf(bio_err,\n                       \"entry %d: not revoked yet, but has a revocation date\\n\",\n                       i + 1);\n            goto end;\n        }\n        if ((pp[DB_type][0] == DB_TYPE_REV) &&\n            !make_revoked(NULL, pp[DB_rev_date])) {\n            BIO_printf(bio_err, \" in entry %d\\n\", i + 1);\n            goto end;\n        }\n        if (!check_time_format((char *)pp[DB_exp_date])) {\n            BIO_printf(bio_err, \"entry %d: invalid expiry date\\n\", i + 1);\n            goto end;\n        }\n        p = pp[DB_serial];\n        j = strlen(p);\n        if (*p == '-') {\n            p++;\n            j--;\n        }\n        if ((j & 1) || (j < 2)) {\n            BIO_printf(bio_err, \"entry %d: bad serial number length (%d)\\n\",\n                       i + 1, j);\n            goto end;\n        }\n        for ( ; *p; p++) {\n            if (!isxdigit(_UC(*p))) {\n                BIO_printf(bio_err,\n                           \"entry %d: bad char 0%o '%c' in serial number\\n\",\n                           i + 1, *p, *p);\n                goto end;\n            }\n        }\n    }\n    if (verbose) {\n        TXT_DB_write(bio_out, db->db);\n        BIO_printf(bio_err, \"%d entries loaded from the database\\n\",\n                   sk_OPENSSL_PSTRING_num(db->db->data));\n        BIO_printf(bio_err, \"generating index\\n\");\n    }\n\n    if (index_index(db) <= 0)\n        goto end;\n\n    /*****************************************************************/\n    /* Update the db file for expired certificates */\n    if (doupdatedb) {\n        if (verbose)\n            BIO_printf(bio_err, \"Updating %s ...\\n\", dbfile);\n\n        i = do_updatedb(db, NULL);\n        if (i == -1) {\n            BIO_printf(bio_err, \"Malloc failure\\n\");\n            goto end;\n        } else if (i == 0) {\n            if (verbose)\n                BIO_printf(bio_err, \"No entries found to mark expired\\n\");\n        } else {\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            if (verbose)\n                BIO_printf(bio_err, \"Done. %d entries marked as expired\\n\", i);\n        }\n    }\n\n    /*****************************************************************/\n    /* Read extensions config file                                   */\n    if (extfile) {\n        if ((extfile_conf = app_load_config(extfile)) == NULL) {\n            ret = 1;\n            goto end;\n        }\n\n        if (verbose)\n            BIO_printf(bio_err, \"Successfully loaded extensions file %s\\n\",\n                       extfile);\n\n        /* We can have sections in the ext file */\n        if (extensions == NULL) {\n            extensions =\n                app_conf_try_string(extfile_conf, \"default\", \"extensions\");\n            if (extensions == NULL)\n                extensions = \"default\";\n        }\n    }\n\n    /*****************************************************************/\n    if (req || gencrl) {\n        if (spkac_file != NULL && outfile != NULL) {\n            output_der = 1;\n            batch = 1;\n        }\n    }\n\n    def_ret = EVP_PKEY_get_default_digest_name(pkey, def_dgst, sizeof(def_dgst));\n    /*\n     * EVP_PKEY_get_default_digest_name() returns 2 if the digest is\n     * mandatory for this algorithm.\n     *\n     * That call may give back the name \"UNDEF\", which has these meanings:\n     *\n     * when def_ret == 2: the user MUST leave the digest unspecified\n     * when def_ret == 1: the user MAY leave the digest unspecified\n     */\n    if (def_ret == 2 && strcmp(def_dgst, \"UNDEF\") == 0) {\n        dgst = NULL;\n    } else if (dgst == NULL\n               && (dgst = lookup_conf(conf, section, ENV_DEFAULT_MD)) == NULL\n               && strcmp(def_dgst, \"UNDEF\") != 0) {\n        goto end;\n    } else {\n        if (strcmp(dgst, \"default\") == 0 || strcmp(def_dgst, \"UNDEF\") == 0) {\n            if (def_ret <= 0) {\n                BIO_puts(bio_err, \"no default digest\\n\");\n                goto end;\n            }\n            dgst = def_dgst;\n        }\n    }\n\n    if (req) {\n        if (email_dn == 1) {\n            char *tmp_email_dn = NULL;\n\n            tmp_email_dn =\n                app_conf_try_string(conf, section, ENV_DEFAULT_EMAIL_DN);\n            if (tmp_email_dn != NULL && strcmp(tmp_email_dn, \"no\") == 0)\n                email_dn = 0;\n        }\n        if (verbose)\n            BIO_printf(bio_err, \"message digest is %s\\n\", dgst);\n        if (policy == NULL\n            && (policy = lookup_conf(conf, section, ENV_POLICY)) == NULL)\n            goto end;\n\n        if (verbose)\n            BIO_printf(bio_err, \"policy is %s\\n\", policy);\n\n        if (app_conf_try_string(conf, section, ENV_RAND_SERIAL) != NULL) {\n            rand_ser = 1;\n        } else {\n            serialfile = lookup_conf(conf, section, ENV_SERIAL);\n            if (serialfile == NULL)\n                goto end;\n        }\n\n        if (extfile_conf != NULL) {\n            /* Check syntax of extfile */\n            X509V3_CTX ctx;\n\n            X509V3_set_ctx_test(&ctx);\n            X509V3_set_nconf(&ctx, extfile_conf);\n            if (!X509V3_EXT_add_nconf(extfile_conf, &ctx, extensions, NULL)) {\n                BIO_printf(bio_err,\n                           \"Error checking certificate extensions from extfile section %s\\n\",\n                           extensions);\n                ret = 1;\n                goto end;\n            }\n        } else {\n            /*\n             * no '-extfile' option, so we look for extensions in the main\n             * configuration file\n             */\n            if (extensions == NULL)\n                extensions = app_conf_try_string(conf, section, ENV_EXTENSIONS);\n            if (extensions != NULL) {\n                /* Check syntax of config file section */\n                X509V3_CTX ctx;\n\n                X509V3_set_ctx_test(&ctx);\n                X509V3_set_nconf(&ctx, conf);\n                if (!X509V3_EXT_add_nconf(conf, &ctx, extensions, NULL)) {\n                    BIO_printf(bio_err,\n                               \"Error checking certificate extension config section %s\\n\",\n                               extensions);\n                    ret = 1;\n                    goto end;\n                }\n            }\n        }\n\n        if (startdate == NULL)\n            startdate =\n                app_conf_try_string(conf, section, ENV_DEFAULT_STARTDATE);\n        if (enddate == NULL)\n            enddate = app_conf_try_string(conf, section, ENV_DEFAULT_ENDDATE);\n        if (days == 0) {\n            if (!app_conf_try_number(conf, section, ENV_DEFAULT_DAYS, &days))\n                days = 0;\n        }\n        if (enddate == NULL && days == 0) {\n            BIO_printf(bio_err, \"cannot lookup how many days to certify for\\n\");\n            goto end;\n        }\n        if (days != 0 && enddate != NULL)\n            BIO_printf(bio_err,\n                       \"Warning: -enddate or -not_after option overriding -days option\\n\");\n\n        if (rand_ser) {\n            if ((serial = BN_new()) == NULL || !rand_serial(serial, NULL)) {\n                BIO_printf(bio_err, \"error generating serial number\\n\");\n                goto end;\n            }\n        } else {\n            serial = load_serial(serialfile, NULL, create_ser, NULL);\n            if (serial == NULL) {\n                BIO_printf(bio_err, \"error while loading serial number\\n\");\n                goto end;\n            }\n            if (verbose) {\n                if (BN_is_zero(serial)) {\n                    BIO_printf(bio_err, \"next serial number is 00\\n\");\n                } else {\n                    if ((f = BN_bn2hex(serial)) == NULL)\n                        goto end;\n                    BIO_printf(bio_err, \"next serial number is %s\\n\", f);\n                    OPENSSL_free(f);\n                }\n            }\n        }\n\n        if ((attribs = NCONF_get_section(conf, policy)) == NULL) {\n            BIO_printf(bio_err, \"unable to find 'section' for %s\\n\", policy);\n            goto end;\n        }\n\n        if ((cert_sk = sk_X509_new_null()) == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n        if (spkac_file != NULL) {\n            total++;\n            j = certify_spkac(&x, spkac_file, pkey, x509, dgst, sigopts,\n                              attribs, db, serial, subj, chtype, multirdn,\n                              email_dn, startdate, enddate, days, extensions,\n                              conf, verbose, certopt, get_nameopt(), default_op,\n                              ext_copy, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        if (ss_cert_file != NULL) {\n            total++;\n            j = certify_cert(&x, ss_cert_file, certformat, passin, pkey,\n                             x509, dgst, sigopts, vfyopts, attribs,\n                             db, serial, subj, chtype, multirdn, email_dn,\n                             startdate, enddate, days, batch, extensions,\n                             conf, verbose, certopt, get_nameopt(), default_op,\n                             ext_copy, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        if (infile != NULL) {\n            total++;\n            j = certify(&x, infile, informat, pkey, x509p, dgst,\n                        sigopts, vfyopts, attribs, db,\n                        serial, subj, chtype, multirdn, email_dn, startdate,\n                        enddate, days, batch, extensions, conf, verbose,\n                        certopt, get_nameopt(), default_op, ext_copy, selfsign, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        for (i = 0; i < argc; i++) {\n            total++;\n            j = certify(&x, argv[i], informat, pkey, x509p, dgst,\n                        sigopts, vfyopts,\n                        attribs, db,\n                        serial, subj, chtype, multirdn, email_dn, startdate,\n                        enddate, days, batch, extensions, conf, verbose,\n                        certopt, get_nameopt(), default_op, ext_copy, selfsign, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1)) {\n                    X509_free(x);\n                    goto end;\n                }\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    X509_free(x);\n                    goto end;\n                }\n            }\n        }\n        /*\n         * we have a stack of newly certified certificates and a database\n         * and serial number that need updating\n         */\n\n        if (sk_X509_num(cert_sk) > 0) {\n            if (!batch) {\n                BIO_printf(bio_err,\n                           \"\\n%d out of %d certificate requests certified, commit? [y/n]\",\n                           total_done, total);\n                (void)BIO_flush(bio_err);\n                tmp[0] = '\\0';\n                if (fgets(tmp, sizeof(tmp), stdin) == NULL) {\n                    BIO_printf(bio_err, \"CERTIFICATION CANCELED: I/O error\\n\");\n                    ret = 0;\n                    goto end;\n                }\n                if (tmp[0] != 'y' && tmp[0] != 'Y') {\n                    BIO_printf(bio_err, \"CERTIFICATION CANCELED\\n\");\n                    ret = 0;\n                    goto end;\n                }\n            }\n\n            BIO_printf(bio_err, \"Write out database with %d new entries\\n\",\n                       sk_X509_num(cert_sk));\n\n            if (serialfile != NULL\n                    && !save_serial(serialfile, \"new\", serial, NULL))\n                goto end;\n\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n        }\n\n        outdirlen = OPENSSL_strlcpy(new_cert, outdir, sizeof(new_cert));\n#ifndef OPENSSL_SYS_VMS\n        outdirlen = OPENSSL_strlcat(new_cert, \"/\", sizeof(new_cert));\n#endif\n\n        if (verbose)\n            BIO_printf(bio_err, \"writing new certificates\\n\");\n\n        for (i = 0; i < sk_X509_num(cert_sk); i++) {\n            BIO *Cout = NULL;\n            X509 *xi = sk_X509_value(cert_sk, i);\n            const ASN1_INTEGER *serialNumber = X509_get0_serialNumber(xi);\n            const unsigned char *psn = ASN1_STRING_get0_data(serialNumber);\n            const int snl = ASN1_STRING_length(serialNumber);\n            const int filen_len = 2 * (snl > 0 ? snl : 1) + sizeof(\".pem\");\n            char *n = new_cert + outdirlen;\n\n            if (outdirlen + filen_len > PATH_MAX) {\n                BIO_printf(bio_err, \"certificate file name too long\\n\");\n                goto end;\n            }\n\n            if (snl > 0) {\n                static const char HEX_DIGITS[] = \"0123456789ABCDEF\";\n\n                for (j = 0; j < snl; j++, psn++) {\n                    *n++ = HEX_DIGITS[*psn >> 4];\n                    *n++ = HEX_DIGITS[*psn & 0x0F];\n                }\n            } else {\n                *(n++) = '0';\n                *(n++) = '0';\n            }\n            *(n++) = '.';\n            *(n++) = 'p';\n            *(n++) = 'e';\n            *(n++) = 'm';\n            *n = '\\0';          /* closing new_cert */\n            if (verbose)\n                BIO_printf(bio_err, \"writing %s\\n\", new_cert);\n\n            Sout = bio_open_default(outfile, 'w',\n                                    output_der ? FORMAT_ASN1 : FORMAT_TEXT);\n            if (Sout == NULL)\n                goto end;\n\n            Cout = BIO_new_file(new_cert, \"w\");\n            if (Cout == NULL) {\n                perror(new_cert);\n                goto end;\n            }\n            write_new_certificate(Cout, xi, 0, notext);\n            write_new_certificate(Sout, xi, output_der, notext);\n            BIO_free_all(Cout);\n            BIO_free_all(Sout);\n            Sout = NULL;\n        }\n\n        if (sk_X509_num(cert_sk)) {\n            /* Rename the database and the serial file */\n            if (serialfile != NULL\n                    && !rotate_serial(serialfile, \"new\", \"old\"))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            BIO_printf(bio_err, \"Database updated\\n\");\n        }\n    }\n\n    /*****************************************************************/\n    if (gencrl) {\n        int crl_v2 = 0;\n\n        if (crl_ext == NULL)\n            crl_ext = app_conf_try_string(conf, section, ENV_CRLEXT);\n        if (crl_ext != NULL) {\n            /* Check syntax of file */\n            X509V3_CTX ctx;\n\n            X509V3_set_ctx_test(&ctx);\n            X509V3_set_nconf(&ctx, conf);\n            if (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL)) {\n                BIO_printf(bio_err,\n                           \"Error checking CRL extension section %s\\n\", crl_ext);\n                ret = 1;\n                goto end;\n            }\n        }\n\n        crlnumberfile = app_conf_try_string(conf, section, ENV_CRLNUMBER);\n        if (crlnumberfile != NULL) {\n            if ((crlnumber = load_serial(crlnumberfile, NULL, 0, NULL))\n                == NULL) {\n                BIO_printf(bio_err, \"error while loading CRL number\\n\");\n                goto end;\n            }\n        }\n\n        if (!crldays && !crlhours && !crlsec) {\n            if (!app_conf_try_number(conf, section,\n                                  ENV_DEFAULT_CRL_DAYS, &crldays))\n                crldays = 0;\n            if (!app_conf_try_number(conf, section,\n                                  ENV_DEFAULT_CRL_HOURS, &crlhours))\n                crlhours = 0;\n        }\n        if ((crl_nextupdate == NULL) &&\n                (crldays == 0) && (crlhours == 0) && (crlsec == 0)) {\n            BIO_printf(bio_err,\n                       \"cannot lookup how long until the next CRL is issued\\n\");\n            goto end;\n        }\n\n        if (verbose)\n            BIO_printf(bio_err, \"making CRL\\n\");\n        if ((crl = X509_CRL_new_ex(app_get0_libctx(), app_get0_propq())) == NULL)\n            goto end;\n        if (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509)))\n            goto end;\n\n        if (!set_crl_lastupdate(crl, crl_lastupdate)) {\n            BIO_puts(bio_err, \"error setting CRL lastUpdate\\n\");\n            ret = 1;\n            goto end;\n        }\n\n        if (!set_crl_nextupdate(crl, crl_nextupdate,\n                                crldays, crlhours, crlsec)) {\n            BIO_puts(bio_err, \"error setting CRL nextUpdate\\n\");\n            ret = 1;\n            goto end;\n        }\n\n        for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\n            pp = sk_OPENSSL_PSTRING_value(db->db->data, i);\n            if (pp[DB_type][0] == DB_TYPE_REV) {\n                if ((r = X509_REVOKED_new()) == NULL)\n                    goto end;\n                j = make_revoked(r, pp[DB_rev_date]);\n                if (!j)\n                    goto end;\n                if (j == 2)\n                    crl_v2 = 1;\n                if (!BN_hex2bn(&serial, pp[DB_serial]))\n                    goto end;\n                tmpser = BN_to_ASN1_INTEGER(serial, NULL);\n                BN_free(serial);\n                serial = NULL;\n                if (!tmpser)\n                    goto end;\n                X509_REVOKED_set_serialNumber(r, tmpser);\n                ASN1_INTEGER_free(tmpser);\n                X509_CRL_add0_revoked(crl, r);\n            }\n        }\n\n        /*\n         * sort the data so it will be written in serial number order\n         */\n        X509_CRL_sort(crl);\n\n        /* we now have a CRL */\n        if (verbose)\n            BIO_printf(bio_err, \"signing CRL\\n\");\n\n        /* Add any extensions asked for */\n\n        if (crl_ext != NULL || crlnumberfile != NULL) {\n            X509V3_CTX crlctx;\n\n            X509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);\n            X509V3_set_nconf(&crlctx, conf);\n\n            if (crl_ext != NULL)\n                if (!X509V3_EXT_CRL_add_nconf(conf, &crlctx, crl_ext, crl)) {\n                    BIO_printf(bio_err,\n                               \"Error adding CRL extensions from section %s\\n\", crl_ext);\n                    goto end;\n                }\n            if (crlnumberfile != NULL) {\n                tmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);\n                if (!tmpser)\n                    goto end;\n                X509_CRL_add1_ext_i2d(crl, NID_crl_number, tmpser, 0, 0);\n                ASN1_INTEGER_free(tmpser);\n                crl_v2 = 1;\n                if (!BN_add_word(crlnumber, 1))\n                    goto end;\n            }\n        }\n        if (crl_ext != NULL || crl_v2) {\n            if (!X509_CRL_set_version(crl, X509_CRL_VERSION_2))\n                goto end;\n        }\n\n        /* we have a CRL number that need updating */\n        if (crlnumberfile != NULL\n                && !save_serial(crlnumberfile, \"new\", crlnumber, NULL))\n            goto end;\n\n        BN_free(crlnumber);\n        crlnumber = NULL;\n\n        if (!do_X509_CRL_sign(crl, pkey, dgst, sigopts))\n            goto end;\n\n        Sout = bio_open_default(outfile, 'w',\n                                output_der ? FORMAT_ASN1 : FORMAT_TEXT);\n        if (Sout == NULL)\n            goto end;\n\n        PEM_write_bio_X509_CRL(Sout, crl);\n\n        /* Rename the crlnumber file */\n        if (crlnumberfile != NULL\n                && !rotate_serial(crlnumberfile, \"new\", \"old\"))\n            goto end;\n\n    }\n    /*****************************************************************/\n    if (dorevoke) {\n        if (infile == NULL) {\n            BIO_printf(bio_err, \"no input files\\n\");\n            goto end;\n        } else {\n            X509 *revcert;\n\n            revcert = load_cert_pass(infile, informat, 1, passin,\n                                     \"certificate to be revoked\");\n            if (revcert == NULL)\n                goto end;\n            if (dorevoke == 2)\n                rev_type = REV_VALID;\n            j = do_revoke(revcert, db, rev_type, rev_arg);\n            if (j <= 0)\n                goto end;\n            X509_free(revcert);\n\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            BIO_printf(bio_err, \"Database updated\\n\");\n        }\n    }\n    ret = 0;\n\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    BIO_free_all(Sout);\n    BIO_free_all(out);\n    BIO_free_all(in);\n    OSSL_STACK_OF_X509_free(cert_sk);\n\n    cleanse(passin);\n    if (free_passin)\n        OPENSSL_free(passin);\n    BN_free(serial);\n    BN_free(crlnumber);\n    free_index(db);\n    sk_OPENSSL_STRING_free(sigopts);\n    sk_OPENSSL_STRING_free(vfyopts);\n    EVP_PKEY_free(pkey);\n    X509_free(x509);\n    X509_CRL_free(crl);\n    NCONF_free(conf);\n    NCONF_free(extfile_conf);\n    release_engine(e);\n    return ret;\n}",
            "ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai)\n{\n    return bn_to_asn1_string(bn, ai, V_ASN1_INTEGER);\n}",
            "static ASN1_STRING *bn_to_asn1_string(const BIGNUM *bn, ASN1_STRING *ai,\n                                      int atype)\n{\n    ASN1_INTEGER *ret;\n    int len;\n\n    if (ai == NULL) {\n        ret = ASN1_STRING_type_new(atype);\n    } else {\n        ret = ai;\n        ret->type = atype;\n    }\n\n    if (ret == NULL) {\n        ERR_raise(ERR_LIB_ASN1, ERR_R_NESTED_ASN1_ERROR);\n        goto err;\n    }\n\n    if (BN_is_negative(bn) && !BN_is_zero(bn))\n        ret->type |= V_ASN1_NEG_INTEGER;\n\n    len = BN_num_bytes(bn);\n\n    if (len == 0)\n        len = 1;\n\n    if (ASN1_STRING_set(ret, NULL, len) == 0) {\n        ERR_raise(ERR_LIB_ASN1, ERR_R_ASN1_LIB);\n        goto err;\n    }\n\n    /* Correct zero case */\n    if (BN_is_zero(bn))\n        ret->data[0] = 0;\n    else\n        len = BN_bn2bin(bn, ret->data);\n    ret->length = len;\n    return ret;\n err:\n    if (ret != ai)\n        ASN1_INTEGER_free(ret);\n    return NULL;\n}",
            "int BN_bn2bin(const BIGNUM *a, unsigned char *to)\n{\n    return bn2binpad(a, to, -1, BIG, UNSIGNED);\n}",
            "static int bn2binpad(const BIGNUM *a, unsigned char *to, int tolen,\n                     endianness_t endianness, signedness_t signedness)\n{\n    int inc;\n    int n, n8;\n    int xor = 0, carry = 0, ext = 0;\n    size_t i, lasti, j, atop, mask;\n    BN_ULONG l;\n\n    /*\n     * In case |a| is fixed-top, BN_num_bits can return bogus length,\n     * but it's assumed that fixed-top inputs ought to be \"nominated\"\n     * even for padded output, so it works out...\n     */\n    n8 = BN_num_bits(a);\n    n = (n8 + 7) / 8;           /* This is what BN_num_bytes() does */\n\n    /* Take note of the signedness of the bignum */\n    if (signedness == SIGNED) {\n        xor = a->neg ? 0xff : 0x00;\n        carry = a->neg;\n\n        /*\n         * if |n * 8 == n|, then the MSbit is set, otherwise unset.\n         * We must compensate with one extra byte if that doesn't\n         * correspond to the signedness of the bignum with regards\n         * to 2's complement.\n         */\n        ext = (n * 8 == n8)\n            ? !a->neg            /* MSbit set on nonnegative bignum */\n            : a->neg;            /* MSbit unset on negative bignum */\n    }\n\n    if (tolen == -1) {\n        tolen = n + ext;\n    } else if (tolen < n + ext) { /* uncommon/unlike case */\n        BIGNUM temp = *a;\n\n        bn_correct_top(&temp);\n        n8 = BN_num_bits(&temp);\n        n = (n8 + 7) / 8;       /* This is what BN_num_bytes() does */\n        if (tolen < n + ext)\n            return -1;\n    }\n\n    /* Swipe through whole available data and don't give away padded zero. */\n    atop = a->dmax * BN_BYTES;\n    if (atop == 0) {\n        if (tolen != 0)\n            memset(to, '\\0', tolen);\n        return tolen;\n    }\n\n    /*\n     * The loop that does the work iterates from least significant\n     * to most significant BIGNUM limb, so we adapt parameters to\n     * transfer output bytes accordingly.\n     */\n    if (endianness == LITTLE) {\n        inc = 1;\n    } else {\n        inc = -1;\n        to += tolen - 1;         /* Move to the last byte, not beyond */\n    }\n\n    lasti = atop - 1;\n    atop = a->top * BN_BYTES;\n    for (i = 0, j = 0; j < (size_t)tolen; j++) {\n        unsigned char byte, byte_xored;\n\n        l = a->d[i / BN_BYTES];\n        mask = 0 - ((j - atop) >> (8 * sizeof(i) - 1));\n        byte = (unsigned char)(l >> (8 * (i % BN_BYTES)) & mask);\n        byte_xored = byte ^ xor;\n        *to = (unsigned char)(byte_xored + carry);\n        carry = byte_xored > *to; /* Implicit 1 or 0 */\n        to += inc;\n        i += (i - lasti) >> (8 * sizeof(i) - 1); /* stay on last limb */\n    }\n\n    return tolen;\n}"
        ],
        "sink": "tmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);",
        "final_sink": "        BIGNUM temp = *a;",
        "source": [
            "        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");"
        ],
        "index": 2
    },
    {
        "prt": "crlnumber",
        "function_call": [
            "int ca_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ENGINE *e = NULL;\n    BIGNUM *crlnumber = NULL, *serial = NULL;\n    EVP_PKEY *pkey = NULL;\n    BIO *in = NULL, *out = NULL, *Sout = NULL;\n    ASN1_INTEGER *tmpser;\n    CA_DB *db = NULL;\n    DB_ATTR db_attr;\n    STACK_OF(CONF_VALUE) *attribs = NULL;\n    STACK_OF(OPENSSL_STRING) *sigopts = NULL, *vfyopts = NULL;\n    STACK_OF(X509) *cert_sk = NULL;\n    X509_CRL *crl = NULL;\n    char *configfile = default_config_file, *section = NULL;\n    char def_dgst[80] = \"\";\n    char *dgst = NULL, *policy = NULL, *keyfile = NULL;\n    char *certfile = NULL, *crl_ext = NULL, *crlnumberfile = NULL;\n    int certformat = FORMAT_UNDEF, informat = FORMAT_UNDEF;\n    unsigned long dateopt = ASN1_DTFLGS_RFC822;\n    const char *infile = NULL, *spkac_file = NULL, *ss_cert_file = NULL;\n    const char *extensions = NULL, *extfile = NULL, *passinarg = NULL;\n    char *passin = NULL;\n    char *outdir = NULL, *outfile = NULL, *rev_arg = NULL, *ser_status = NULL;\n    const char *serialfile = NULL, *subj = NULL;\n    char *prog, *startdate = NULL, *enddate = NULL;\n    char *dbfile = NULL, *f;\n    char new_cert[PATH_MAX];\n    char tmp[10 + 1] = \"\\0\";\n    char *const *pp;\n    const char *p;\n    size_t outdirlen = 0;\n    int create_ser = 0, free_passin = 0, total = 0, total_done = 0;\n    int batch = 0, default_op = 1, doupdatedb = 0, ext_copy = EXT_COPY_NONE;\n    int keyformat = FORMAT_UNDEF, multirdn = 1, notext = 0, output_der = 0;\n    int ret = 1, email_dn = 1, req = 0, verbose = 0, gencrl = 0, dorevoke = 0;\n    int rand_ser = 0, i, j, selfsign = 0, def_ret;\n    char *crl_lastupdate = NULL, *crl_nextupdate = NULL;\n    long crldays = 0, crlhours = 0, crlsec = 0, days = 0;\n    unsigned long chtype = MBSTRING_ASC, certopt = 0;\n    X509 *x509 = NULL, *x509p = NULL, *x = NULL;\n    REVINFO_TYPE rev_type = REV_NONE;\n    X509_REVOKED *r = NULL;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, ca_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\nopthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ca_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            req = 1;\n            infile = opt_arg();\n            break;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_DATEOPT:\n            if (!set_dateopt(&dateopt, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_VERBOSE:\n            verbose = 1;\n            break;\n        case OPT_QUIET:\n            verbose = 0;\n            break;\n        case OPT_CONFIG:\n            configfile = opt_arg();\n            break;\n        case OPT_NAME:\n            section = opt_arg();\n            break;\n        case OPT_SUBJ:\n            subj = opt_arg();\n            /* preserve=1; */\n            break;\n        case OPT_UTF8:\n            chtype = MBSTRING_UTF8;\n            break;\n        case OPT_RAND_SERIAL:\n            rand_ser = 1;\n            break;\n        case OPT_CREATE_SERIAL:\n            create_ser = 1;\n            break;\n        case OPT_MULTIVALUE_RDN:\n            /* obsolete */\n            break;\n        case OPT_STARTDATE:\n        case OPT_NOT_BEFORE:\n            startdate = opt_arg();\n            break;\n        case OPT_ENDDATE:\n        case OPT_NOT_AFTER:\n            enddate = opt_arg();\n            break;\n        case OPT_DAYS:\n            days = atoi(opt_arg());\n            break;\n        case OPT_MD:\n            dgst = opt_arg();\n            break;\n        case OPT_POLICY:\n            policy = opt_arg();\n            break;\n        case OPT_KEYFILE:\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyformat))\n                goto opthelp;\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_KEY:\n            passin = opt_arg();\n            break;\n        case OPT_CERT:\n            certfile = opt_arg();\n            break;\n        case OPT_CERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &certformat))\n                goto opthelp;\n            break;\n        case OPT_SELFSIGN:\n            selfsign = 1;\n            break;\n        case OPT_OUTDIR:\n            outdir = opt_arg();\n            break;\n        case OPT_SIGOPT:\n            if (sigopts == NULL)\n                sigopts = sk_OPENSSL_STRING_new_null();\n            if (sigopts == NULL || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_VFYOPT:\n            if (vfyopts == NULL)\n                vfyopts = sk_OPENSSL_STRING_new_null();\n            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_NOTEXT:\n            notext = 1;\n            break;\n        case OPT_BATCH:\n            batch = 1;\n            break;\n        case OPT_PRESERVEDN:\n            preserve = 1;\n            break;\n        case OPT_NOEMAILDN:\n            email_dn = 0;\n            break;\n        case OPT_GENCRL:\n            gencrl = 1;\n            break;\n        case OPT_MSIE_HACK:\n            msie_hack = 1;\n            break;\n        case OPT_CRL_LASTUPDATE:\n            crl_lastupdate = opt_arg();\n            break;\n        case OPT_CRL_NEXTUPDATE:\n            crl_nextupdate = opt_arg();\n            break;\n        case OPT_CRLDAYS:\n            crldays = atol(opt_arg());\n            break;\n        case OPT_CRLHOURS:\n            crlhours = atol(opt_arg());\n            break;\n        case OPT_CRLSEC:\n            crlsec = atol(opt_arg());\n            break;\n        case OPT_INFILES:\n            req = 1;\n            goto end_of_options;\n        case OPT_SS_CERT:\n            ss_cert_file = opt_arg();\n            req = 1;\n            break;\n        case OPT_SPKAC:\n            spkac_file = opt_arg();\n            req = 1;\n            break;\n        case OPT_REVOKE:\n            infile = opt_arg();\n            dorevoke = 1;\n            break;\n        case OPT_VALID:\n            infile = opt_arg();\n            dorevoke = 2;\n            break;\n        case OPT_EXTENSIONS:\n            extensions = opt_arg();\n            break;\n        case OPT_EXTFILE:\n            extfile = opt_arg();\n            break;\n        case OPT_STATUS:\n            ser_status = opt_arg();\n            break;\n        case OPT_UPDATEDB:\n            doupdatedb = 1;\n            break;\n        case OPT_CRLEXTS:\n            crl_ext = opt_arg();\n            break;\n        case OPT_CRL_REASON:   /* := REV_CRL_REASON */\n        case OPT_CRL_HOLD:\n        case OPT_CRL_COMPROMISE:\n        case OPT_CRL_CA_COMPROMISE:\n            rev_arg = opt_arg();\n            rev_type = (o - OPT_CRL_REASON) + REV_CRL_REASON;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n\nend_of_options:\n    /* Remaining args are files to certify. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((conf = app_load_config_verbose(configfile, 1)) == NULL)\n        goto end;\n    if (configfile != default_config_file && !app_load_modules(conf))\n        goto end;\n\n    /* Lets get the config section we are using */\n    if (section == NULL\n        && (section = lookup_conf(conf, BASE_SECTION, ENV_DEFAULT_CA)) == NULL)\n        goto end;\n\n    p = app_conf_try_string(conf, NULL, \"oid_file\");\n    if (p != NULL) {\n        BIO *oid_bio = BIO_new_file(p, \"r\");\n\n        if (oid_bio == NULL) {\n            ERR_clear_error();\n        } else {\n            OBJ_create_objects(oid_bio);\n            BIO_free(oid_bio);\n        }\n    }\n    if (!add_oid_section(conf))\n        goto end;\n\n    app_RAND_load_conf(conf, BASE_SECTION);\n    if (!app_RAND_load())\n        goto end;\n\n    f = app_conf_try_string(conf, section, STRING_MASK);\n    if (f != NULL && !ASN1_STRING_set_default_mask_asc(f)) {\n        BIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", f);\n        goto end;\n    }\n\n    if (chtype != MBSTRING_UTF8) {\n        f = app_conf_try_string(conf, section, UTF8_IN);\n        if (f != NULL && strcmp(f, \"yes\") == 0)\n            chtype = MBSTRING_UTF8;\n    }\n\n    db_attr.unique_subject = 1;\n    p = app_conf_try_string(conf, section, ENV_UNIQUE_SUBJECT);\n    if (p != NULL)\n        db_attr.unique_subject = parse_yesno(p, 1);\n\n    /*****************************************************************/\n    /* report status of cert with serial number given on command line */\n    if (ser_status) {\n        dbfile = lookup_conf(conf, section, ENV_DATABASE);\n        if (dbfile == NULL)\n            goto end;\n\n        db = load_index(dbfile, &db_attr);\n        if (db == NULL) {\n            BIO_printf(bio_err, \"Problem with index file: %s (could not load/parse file)\\n\", dbfile);\n            goto end;\n        }\n\n        if (index_index(db) <= 0)\n            goto end;\n\n        if (get_certificate_status(ser_status, db) != 1)\n            BIO_printf(bio_err, \"Error verifying serial %s!\\n\", ser_status);\n        goto end;\n    }\n\n    /*****************************************************************/\n    /* we definitely need a private key, so let's get it */\n\n    if (keyfile == NULL\n        && (keyfile = lookup_conf(conf, section, ENV_PRIVATE_KEY)) == NULL)\n        goto end;\n\n    if (passin == NULL) {\n        free_passin = 1;\n        if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n            BIO_printf(bio_err, \"Error getting password\\n\");\n            goto end;\n        }\n    }\n    pkey = load_key(keyfile, keyformat, 0, passin, e, \"CA private key\");\n    cleanse(passin);\n    if (pkey == NULL)\n        /* load_key() has already printed an appropriate message */\n        goto end;\n\n    /*****************************************************************/\n    /* we need a certificate */\n    if (!selfsign || spkac_file || ss_cert_file || gencrl) {\n        if (certfile == NULL\n            && (certfile = lookup_conf(conf, section, ENV_CERTIFICATE)) == NULL)\n            goto end;\n\n        x509 = load_cert_pass(certfile, certformat, 1, passin, \"CA certificate\");\n        if (x509 == NULL)\n            goto end;\n\n        if (!X509_check_private_key(x509, pkey)) {\n            BIO_printf(bio_err,\n                       \"CA certificate and CA private key do not match\\n\");\n            goto end;\n        }\n    }\n    if (!selfsign)\n        x509p = x509;\n\n    f = app_conf_try_string(conf, BASE_SECTION, ENV_PRESERVE);\n    if (f != NULL && (*f == 'y' || *f == 'Y'))\n        preserve = 1;\n    f = app_conf_try_string(conf, BASE_SECTION, ENV_MSIE_HACK);\n    if (f != NULL && (*f == 'y' || *f == 'Y'))\n        msie_hack = 1;\n\n    f = app_conf_try_string(conf, section, ENV_NAMEOPT);\n    if (f != NULL) {\n        if (!set_nameopt(f)) {\n            BIO_printf(bio_err, \"Invalid name options: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n        default_op = 0;\n    }\n\n    f = app_conf_try_string(conf, section, ENV_CERTOPT);\n    if (f != NULL) {\n        if (!set_cert_ex(&certopt, f)) {\n            BIO_printf(bio_err, \"Invalid certificate options: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n        default_op = 0;\n    }\n\n    f = app_conf_try_string(conf, section, ENV_EXTCOPY);\n    if (f != NULL) {\n        if (!set_ext_copy(&ext_copy, f)) {\n            BIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n    }\n\n    /*****************************************************************/\n    /* lookup where to write new certificates */\n    if ((outdir == NULL) && (req)) {\n\n        outdir = NCONF_get_string(conf, section, ENV_NEW_CERTS_DIR);\n        if (outdir == NULL) {\n            BIO_printf(bio_err,\n                       \"there needs to be defined a directory for new certificate to be placed in\\n\");\n            goto end;\n        }\n#ifndef OPENSSL_SYS_VMS\n        /*\n         * outdir is a directory spec, but access() for VMS demands a\n         * filename.  We could use the DEC C routine to convert the\n         * directory syntax to Unix, and give that to app_isdir,\n         * but for now the fopen will catch the error if it's not a\n         * directory\n         */\n        if (app_isdir(outdir) <= 0) {\n            BIO_printf(bio_err, \"%s: %s is not a directory\\n\", prog, outdir);\n            perror(outdir);\n            goto end;\n        }\n#endif\n    }\n\n    /*****************************************************************/\n    /* we need to load the database file */\n    dbfile = lookup_conf(conf, section, ENV_DATABASE);\n    if (dbfile == NULL)\n        goto end;\n\n    db = load_index(dbfile, &db_attr);\n    if (db == NULL) {\n        BIO_printf(bio_err, \"Problem with index file: %s (could not load/parse file)\\n\", dbfile);\n        goto end;\n    }\n\n    /* Lets check some fields */\n    for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\n        pp = sk_OPENSSL_PSTRING_value(db->db->data, i);\n        if ((pp[DB_type][0] != DB_TYPE_REV) && (pp[DB_rev_date][0] != '\\0')) {\n            BIO_printf(bio_err,\n                       \"entry %d: not revoked yet, but has a revocation date\\n\",\n                       i + 1);\n            goto end;\n        }\n        if ((pp[DB_type][0] == DB_TYPE_REV) &&\n            !make_revoked(NULL, pp[DB_rev_date])) {\n            BIO_printf(bio_err, \" in entry %d\\n\", i + 1);\n            goto end;\n        }\n        if (!check_time_format((char *)pp[DB_exp_date])) {\n            BIO_printf(bio_err, \"entry %d: invalid expiry date\\n\", i + 1);\n            goto end;\n        }\n        p = pp[DB_serial];\n        j = strlen(p);\n        if (*p == '-') {\n            p++;\n            j--;\n        }\n        if ((j & 1) || (j < 2)) {\n            BIO_printf(bio_err, \"entry %d: bad serial number length (%d)\\n\",\n                       i + 1, j);\n            goto end;\n        }\n        for ( ; *p; p++) {\n            if (!isxdigit(_UC(*p))) {\n                BIO_printf(bio_err,\n                           \"entry %d: bad char 0%o '%c' in serial number\\n\",\n                           i + 1, *p, *p);\n                goto end;\n            }\n        }\n    }\n    if (verbose) {\n        TXT_DB_write(bio_out, db->db);\n        BIO_printf(bio_err, \"%d entries loaded from the database\\n\",\n                   sk_OPENSSL_PSTRING_num(db->db->data));\n        BIO_printf(bio_err, \"generating index\\n\");\n    }\n\n    if (index_index(db) <= 0)\n        goto end;\n\n    /*****************************************************************/\n    /* Update the db file for expired certificates */\n    if (doupdatedb) {\n        if (verbose)\n            BIO_printf(bio_err, \"Updating %s ...\\n\", dbfile);\n\n        i = do_updatedb(db, NULL);\n        if (i == -1) {\n            BIO_printf(bio_err, \"Malloc failure\\n\");\n            goto end;\n        } else if (i == 0) {\n            if (verbose)\n                BIO_printf(bio_err, \"No entries found to mark expired\\n\");\n        } else {\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            if (verbose)\n                BIO_printf(bio_err, \"Done. %d entries marked as expired\\n\", i);\n        }\n    }\n\n    /*****************************************************************/\n    /* Read extensions config file                                   */\n    if (extfile) {\n        if ((extfile_conf = app_load_config(extfile)) == NULL) {\n            ret = 1;\n            goto end;\n        }\n\n        if (verbose)\n            BIO_printf(bio_err, \"Successfully loaded extensions file %s\\n\",\n                       extfile);\n\n        /* We can have sections in the ext file */\n        if (extensions == NULL) {\n            extensions =\n                app_conf_try_string(extfile_conf, \"default\", \"extensions\");\n            if (extensions == NULL)\n                extensions = \"default\";\n        }\n    }\n\n    /*****************************************************************/\n    if (req || gencrl) {\n        if (spkac_file != NULL && outfile != NULL) {\n            output_der = 1;\n            batch = 1;\n        }\n    }\n\n    def_ret = EVP_PKEY_get_default_digest_name(pkey, def_dgst, sizeof(def_dgst));\n    /*\n     * EVP_PKEY_get_default_digest_name() returns 2 if the digest is\n     * mandatory for this algorithm.\n     *\n     * That call may give back the name \"UNDEF\", which has these meanings:\n     *\n     * when def_ret == 2: the user MUST leave the digest unspecified\n     * when def_ret == 1: the user MAY leave the digest unspecified\n     */\n    if (def_ret == 2 && strcmp(def_dgst, \"UNDEF\") == 0) {\n        dgst = NULL;\n    } else if (dgst == NULL\n               && (dgst = lookup_conf(conf, section, ENV_DEFAULT_MD)) == NULL\n               && strcmp(def_dgst, \"UNDEF\") != 0) {\n        goto end;\n    } else {\n        if (strcmp(dgst, \"default\") == 0 || strcmp(def_dgst, \"UNDEF\") == 0) {\n            if (def_ret <= 0) {\n                BIO_puts(bio_err, \"no default digest\\n\");\n                goto end;\n            }\n            dgst = def_dgst;\n        }\n    }\n\n    if (req) {\n        if (email_dn == 1) {\n            char *tmp_email_dn = NULL;\n\n            tmp_email_dn =\n                app_conf_try_string(conf, section, ENV_DEFAULT_EMAIL_DN);\n            if (tmp_email_dn != NULL && strcmp(tmp_email_dn, \"no\") == 0)\n                email_dn = 0;\n        }\n        if (verbose)\n            BIO_printf(bio_err, \"message digest is %s\\n\", dgst);\n        if (policy == NULL\n            && (policy = lookup_conf(conf, section, ENV_POLICY)) == NULL)\n            goto end;\n\n        if (verbose)\n            BIO_printf(bio_err, \"policy is %s\\n\", policy);\n\n        if (app_conf_try_string(conf, section, ENV_RAND_SERIAL) != NULL) {\n            rand_ser = 1;\n        } else {\n            serialfile = lookup_conf(conf, section, ENV_SERIAL);\n            if (serialfile == NULL)\n                goto end;\n        }\n\n        if (extfile_conf != NULL) {\n            /* Check syntax of extfile */\n            X509V3_CTX ctx;\n\n            X509V3_set_ctx_test(&ctx);\n            X509V3_set_nconf(&ctx, extfile_conf);\n            if (!X509V3_EXT_add_nconf(extfile_conf, &ctx, extensions, NULL)) {\n                BIO_printf(bio_err,\n                           \"Error checking certificate extensions from extfile section %s\\n\",\n                           extensions);\n                ret = 1;\n                goto end;\n            }\n        } else {\n            /*\n             * no '-extfile' option, so we look for extensions in the main\n             * configuration file\n             */\n            if (extensions == NULL)\n                extensions = app_conf_try_string(conf, section, ENV_EXTENSIONS);\n            if (extensions != NULL) {\n                /* Check syntax of config file section */\n                X509V3_CTX ctx;\n\n                X509V3_set_ctx_test(&ctx);\n                X509V3_set_nconf(&ctx, conf);\n                if (!X509V3_EXT_add_nconf(conf, &ctx, extensions, NULL)) {\n                    BIO_printf(bio_err,\n                               \"Error checking certificate extension config section %s\\n\",\n                               extensions);\n                    ret = 1;\n                    goto end;\n                }\n            }\n        }\n\n        if (startdate == NULL)\n            startdate =\n                app_conf_try_string(conf, section, ENV_DEFAULT_STARTDATE);\n        if (enddate == NULL)\n            enddate = app_conf_try_string(conf, section, ENV_DEFAULT_ENDDATE);\n        if (days == 0) {\n            if (!app_conf_try_number(conf, section, ENV_DEFAULT_DAYS, &days))\n                days = 0;\n        }\n        if (enddate == NULL && days == 0) {\n            BIO_printf(bio_err, \"cannot lookup how many days to certify for\\n\");\n            goto end;\n        }\n        if (days != 0 && enddate != NULL)\n            BIO_printf(bio_err,\n                       \"Warning: -enddate or -not_after option overriding -days option\\n\");\n\n        if (rand_ser) {\n            if ((serial = BN_new()) == NULL || !rand_serial(serial, NULL)) {\n                BIO_printf(bio_err, \"error generating serial number\\n\");\n                goto end;\n            }\n        } else {\n            serial = load_serial(serialfile, NULL, create_ser, NULL);\n            if (serial == NULL) {\n                BIO_printf(bio_err, \"error while loading serial number\\n\");\n                goto end;\n            }\n            if (verbose) {\n                if (BN_is_zero(serial)) {\n                    BIO_printf(bio_err, \"next serial number is 00\\n\");\n                } else {\n                    if ((f = BN_bn2hex(serial)) == NULL)\n                        goto end;\n                    BIO_printf(bio_err, \"next serial number is %s\\n\", f);\n                    OPENSSL_free(f);\n                }\n            }\n        }\n\n        if ((attribs = NCONF_get_section(conf, policy)) == NULL) {\n            BIO_printf(bio_err, \"unable to find 'section' for %s\\n\", policy);\n            goto end;\n        }\n\n        if ((cert_sk = sk_X509_new_null()) == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n        if (spkac_file != NULL) {\n            total++;\n            j = certify_spkac(&x, spkac_file, pkey, x509, dgst, sigopts,\n                              attribs, db, serial, subj, chtype, multirdn,\n                              email_dn, startdate, enddate, days, extensions,\n                              conf, verbose, certopt, get_nameopt(), default_op,\n                              ext_copy, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        if (ss_cert_file != NULL) {\n            total++;\n            j = certify_cert(&x, ss_cert_file, certformat, passin, pkey,\n                             x509, dgst, sigopts, vfyopts, attribs,\n                             db, serial, subj, chtype, multirdn, email_dn,\n                             startdate, enddate, days, batch, extensions,\n                             conf, verbose, certopt, get_nameopt(), default_op,\n                             ext_copy, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        if (infile != NULL) {\n            total++;\n            j = certify(&x, infile, informat, pkey, x509p, dgst,\n                        sigopts, vfyopts, attribs, db,\n                        serial, subj, chtype, multirdn, email_dn, startdate,\n                        enddate, days, batch, extensions, conf, verbose,\n                        certopt, get_nameopt(), default_op, ext_copy, selfsign, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        for (i = 0; i < argc; i++) {\n            total++;\n            j = certify(&x, argv[i], informat, pkey, x509p, dgst,\n                        sigopts, vfyopts,\n                        attribs, db,\n                        serial, subj, chtype, multirdn, email_dn, startdate,\n                        enddate, days, batch, extensions, conf, verbose,\n                        certopt, get_nameopt(), default_op, ext_copy, selfsign, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1)) {\n                    X509_free(x);\n                    goto end;\n                }\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    X509_free(x);\n                    goto end;\n                }\n            }\n        }\n        /*\n         * we have a stack of newly certified certificates and a database\n         * and serial number that need updating\n         */\n\n        if (sk_X509_num(cert_sk) > 0) {\n            if (!batch) {\n                BIO_printf(bio_err,\n                           \"\\n%d out of %d certificate requests certified, commit? [y/n]\",\n                           total_done, total);\n                (void)BIO_flush(bio_err);\n                tmp[0] = '\\0';\n                if (fgets(tmp, sizeof(tmp), stdin) == NULL) {\n                    BIO_printf(bio_err, \"CERTIFICATION CANCELED: I/O error\\n\");\n                    ret = 0;\n                    goto end;\n                }\n                if (tmp[0] != 'y' && tmp[0] != 'Y') {\n                    BIO_printf(bio_err, \"CERTIFICATION CANCELED\\n\");\n                    ret = 0;\n                    goto end;\n                }\n            }\n\n            BIO_printf(bio_err, \"Write out database with %d new entries\\n\",\n                       sk_X509_num(cert_sk));\n\n            if (serialfile != NULL\n                    && !save_serial(serialfile, \"new\", serial, NULL))\n                goto end;\n\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n        }\n\n        outdirlen = OPENSSL_strlcpy(new_cert, outdir, sizeof(new_cert));\n#ifndef OPENSSL_SYS_VMS\n        outdirlen = OPENSSL_strlcat(new_cert, \"/\", sizeof(new_cert));\n#endif\n\n        if (verbose)\n            BIO_printf(bio_err, \"writing new certificates\\n\");\n\n        for (i = 0; i < sk_X509_num(cert_sk); i++) {\n            BIO *Cout = NULL;\n            X509 *xi = sk_X509_value(cert_sk, i);\n            const ASN1_INTEGER *serialNumber = X509_get0_serialNumber(xi);\n            const unsigned char *psn = ASN1_STRING_get0_data(serialNumber);\n            const int snl = ASN1_STRING_length(serialNumber);\n            const int filen_len = 2 * (snl > 0 ? snl : 1) + sizeof(\".pem\");\n            char *n = new_cert + outdirlen;\n\n            if (outdirlen + filen_len > PATH_MAX) {\n                BIO_printf(bio_err, \"certificate file name too long\\n\");\n                goto end;\n            }\n\n            if (snl > 0) {\n                static const char HEX_DIGITS[] = \"0123456789ABCDEF\";\n\n                for (j = 0; j < snl; j++, psn++) {\n                    *n++ = HEX_DIGITS[*psn >> 4];\n                    *n++ = HEX_DIGITS[*psn & 0x0F];\n                }\n            } else {\n                *(n++) = '0';\n                *(n++) = '0';\n            }\n            *(n++) = '.';\n            *(n++) = 'p';\n            *(n++) = 'e';\n            *(n++) = 'm';\n            *n = '\\0';          /* closing new_cert */\n            if (verbose)\n                BIO_printf(bio_err, \"writing %s\\n\", new_cert);\n\n            Sout = bio_open_default(outfile, 'w',\n                                    output_der ? FORMAT_ASN1 : FORMAT_TEXT);\n            if (Sout == NULL)\n                goto end;\n\n            Cout = BIO_new_file(new_cert, \"w\");\n            if (Cout == NULL) {\n                perror(new_cert);\n                goto end;\n            }\n            write_new_certificate(Cout, xi, 0, notext);\n            write_new_certificate(Sout, xi, output_der, notext);\n            BIO_free_all(Cout);\n            BIO_free_all(Sout);\n            Sout = NULL;\n        }\n\n        if (sk_X509_num(cert_sk)) {\n            /* Rename the database and the serial file */\n            if (serialfile != NULL\n                    && !rotate_serial(serialfile, \"new\", \"old\"))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            BIO_printf(bio_err, \"Database updated\\n\");\n        }\n    }\n\n    /*****************************************************************/\n    if (gencrl) {\n        int crl_v2 = 0;\n\n        if (crl_ext == NULL)\n            crl_ext = app_conf_try_string(conf, section, ENV_CRLEXT);\n        if (crl_ext != NULL) {\n            /* Check syntax of file */\n            X509V3_CTX ctx;\n\n            X509V3_set_ctx_test(&ctx);\n            X509V3_set_nconf(&ctx, conf);\n            if (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL)) {\n                BIO_printf(bio_err,\n                           \"Error checking CRL extension section %s\\n\", crl_ext);\n                ret = 1;\n                goto end;\n            }\n        }\n\n        crlnumberfile = app_conf_try_string(conf, section, ENV_CRLNUMBER);\n        if (crlnumberfile != NULL) {\n            if ((crlnumber = load_serial(crlnumberfile, NULL, 0, NULL))\n                == NULL) {\n                BIO_printf(bio_err, \"error while loading CRL number\\n\");\n                goto end;\n            }\n        }\n\n        if (!crldays && !crlhours && !crlsec) {\n            if (!app_conf_try_number(conf, section,\n                                  ENV_DEFAULT_CRL_DAYS, &crldays))\n                crldays = 0;\n            if (!app_conf_try_number(conf, section,\n                                  ENV_DEFAULT_CRL_HOURS, &crlhours))\n                crlhours = 0;\n        }\n        if ((crl_nextupdate == NULL) &&\n                (crldays == 0) && (crlhours == 0) && (crlsec == 0)) {\n            BIO_printf(bio_err,\n                       \"cannot lookup how long until the next CRL is issued\\n\");\n            goto end;\n        }\n\n        if (verbose)\n            BIO_printf(bio_err, \"making CRL\\n\");\n        if ((crl = X509_CRL_new_ex(app_get0_libctx(), app_get0_propq())) == NULL)\n            goto end;\n        if (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509)))\n            goto end;\n\n        if (!set_crl_lastupdate(crl, crl_lastupdate)) {\n            BIO_puts(bio_err, \"error setting CRL lastUpdate\\n\");\n            ret = 1;\n            goto end;\n        }\n\n        if (!set_crl_nextupdate(crl, crl_nextupdate,\n                                crldays, crlhours, crlsec)) {\n            BIO_puts(bio_err, \"error setting CRL nextUpdate\\n\");\n            ret = 1;\n            goto end;\n        }\n\n        for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\n            pp = sk_OPENSSL_PSTRING_value(db->db->data, i);\n            if (pp[DB_type][0] == DB_TYPE_REV) {\n                if ((r = X509_REVOKED_new()) == NULL)\n                    goto end;\n                j = make_revoked(r, pp[DB_rev_date]);\n                if (!j)\n                    goto end;\n                if (j == 2)\n                    crl_v2 = 1;\n                if (!BN_hex2bn(&serial, pp[DB_serial]))\n                    goto end;\n                tmpser = BN_to_ASN1_INTEGER(serial, NULL);\n                BN_free(serial);\n                serial = NULL;\n                if (!tmpser)\n                    goto end;\n                X509_REVOKED_set_serialNumber(r, tmpser);\n                ASN1_INTEGER_free(tmpser);\n                X509_CRL_add0_revoked(crl, r);\n            }\n        }\n\n        /*\n         * sort the data so it will be written in serial number order\n         */\n        X509_CRL_sort(crl);\n\n        /* we now have a CRL */\n        if (verbose)\n            BIO_printf(bio_err, \"signing CRL\\n\");\n\n        /* Add any extensions asked for */\n\n        if (crl_ext != NULL || crlnumberfile != NULL) {\n            X509V3_CTX crlctx;\n\n            X509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);\n            X509V3_set_nconf(&crlctx, conf);\n\n            if (crl_ext != NULL)\n                if (!X509V3_EXT_CRL_add_nconf(conf, &crlctx, crl_ext, crl)) {\n                    BIO_printf(bio_err,\n                               \"Error adding CRL extensions from section %s\\n\", crl_ext);\n                    goto end;\n                }\n            if (crlnumberfile != NULL) {\n                tmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);\n                if (!tmpser)\n                    goto end;\n                X509_CRL_add1_ext_i2d(crl, NID_crl_number, tmpser, 0, 0);\n                ASN1_INTEGER_free(tmpser);\n                crl_v2 = 1;\n                if (!BN_add_word(crlnumber, 1))\n                    goto end;\n            }\n        }\n        if (crl_ext != NULL || crl_v2) {\n            if (!X509_CRL_set_version(crl, X509_CRL_VERSION_2))\n                goto end;\n        }\n\n        /* we have a CRL number that need updating */\n        if (crlnumberfile != NULL\n                && !save_serial(crlnumberfile, \"new\", crlnumber, NULL))\n            goto end;\n\n        BN_free(crlnumber);\n        crlnumber = NULL;\n\n        if (!do_X509_CRL_sign(crl, pkey, dgst, sigopts))\n            goto end;\n\n        Sout = bio_open_default(outfile, 'w',\n                                output_der ? FORMAT_ASN1 : FORMAT_TEXT);\n        if (Sout == NULL)\n            goto end;\n\n        PEM_write_bio_X509_CRL(Sout, crl);\n\n        /* Rename the crlnumber file */\n        if (crlnumberfile != NULL\n                && !rotate_serial(crlnumberfile, \"new\", \"old\"))\n            goto end;\n\n    }\n    /*****************************************************************/\n    if (dorevoke) {\n        if (infile == NULL) {\n            BIO_printf(bio_err, \"no input files\\n\");\n            goto end;\n        } else {\n            X509 *revcert;\n\n            revcert = load_cert_pass(infile, informat, 1, passin,\n                                     \"certificate to be revoked\");\n            if (revcert == NULL)\n                goto end;\n            if (dorevoke == 2)\n                rev_type = REV_VALID;\n            j = do_revoke(revcert, db, rev_type, rev_arg);\n            if (j <= 0)\n                goto end;\n            X509_free(revcert);\n\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            BIO_printf(bio_err, \"Database updated\\n\");\n        }\n    }\n    ret = 0;\n\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    BIO_free_all(Sout);\n    BIO_free_all(out);\n    BIO_free_all(in);\n    OSSL_STACK_OF_X509_free(cert_sk);\n\n    cleanse(passin);\n    if (free_passin)\n        OPENSSL_free(passin);\n    BN_free(serial);\n    BN_free(crlnumber);\n    free_index(db);\n    sk_OPENSSL_STRING_free(sigopts);\n    sk_OPENSSL_STRING_free(vfyopts);\n    EVP_PKEY_free(pkey);\n    X509_free(x509);\n    X509_CRL_free(crl);\n    NCONF_free(conf);\n    NCONF_free(extfile_conf);\n    release_engine(e);\n    return ret;\n}",
            "int save_serial(const char *serialfile, const char *suffix,\n                const BIGNUM *serial, ASN1_INTEGER **retai)\n{\n    char buf[1][BSIZE];\n    BIO *out = NULL;\n    int ret = 0;\n    ASN1_INTEGER *ai = NULL;\n    int j;\n\n    if (suffix == NULL)\n        j = strlen(serialfile);\n    else\n        j = strlen(serialfile) + strlen(suffix) + 1;\n    if (j >= BSIZE) {\n        BIO_printf(bio_err, \"File name too long\\n\");\n        goto err;\n    }\n\n    if (suffix == NULL) {\n        OPENSSL_strlcpy(buf[0], serialfile, BSIZE);\n    } else {\n#ifndef OPENSSL_SYS_VMS\n        BIO_snprintf(buf[0], sizeof(buf[0]), \"%s.%s\", serialfile, suffix);\n#else\n        BIO_snprintf(buf[0], sizeof(buf[0]), \"%s-%s\", serialfile, suffix);\n#endif\n    }\n    out = BIO_new_file(buf[0], \"w\");\n    if (out == NULL) {\n        goto err;\n    }\n\n    if ((ai = BN_to_ASN1_INTEGER(serial, NULL)) == NULL) {\n        BIO_printf(bio_err, \"error converting serial to ASN.1 format\\n\");\n        goto err;\n    }\n    i2a_ASN1_INTEGER(out, ai);\n    BIO_puts(out, \"\\n\");\n    ret = 1;\n    if (retai) {\n        *retai = ai;\n        ai = NULL;\n    }\n err:\n    if (!ret)\n        ERR_print_errors(bio_err);\n    BIO_free_all(out);\n    ASN1_INTEGER_free(ai);\n    return ret;\n}"
        ],
        "sink": "&& !save_serial(crlnumberfile, \"new\", crlnumber, NULL))",
        "final_sink": "    if ((ai = BN_to_ASN1_INTEGER(serial, NULL)) == NULL) {",
        "source": [
            "        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");"
        ],
        "index": 3
    },
    {
        "prt": "rev_arg",
        "function_call": [
            "int ca_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ENGINE *e = NULL;\n    BIGNUM *crlnumber = NULL, *serial = NULL;\n    EVP_PKEY *pkey = NULL;\n    BIO *in = NULL, *out = NULL, *Sout = NULL;\n    ASN1_INTEGER *tmpser;\n    CA_DB *db = NULL;\n    DB_ATTR db_attr;\n    STACK_OF(CONF_VALUE) *attribs = NULL;\n    STACK_OF(OPENSSL_STRING) *sigopts = NULL, *vfyopts = NULL;\n    STACK_OF(X509) *cert_sk = NULL;\n    X509_CRL *crl = NULL;\n    char *configfile = default_config_file, *section = NULL;\n    char def_dgst[80] = \"\";\n    char *dgst = NULL, *policy = NULL, *keyfile = NULL;\n    char *certfile = NULL, *crl_ext = NULL, *crlnumberfile = NULL;\n    int certformat = FORMAT_UNDEF, informat = FORMAT_UNDEF;\n    unsigned long dateopt = ASN1_DTFLGS_RFC822;\n    const char *infile = NULL, *spkac_file = NULL, *ss_cert_file = NULL;\n    const char *extensions = NULL, *extfile = NULL, *passinarg = NULL;\n    char *passin = NULL;\n    char *outdir = NULL, *outfile = NULL, *rev_arg = NULL, *ser_status = NULL;\n    const char *serialfile = NULL, *subj = NULL;\n    char *prog, *startdate = NULL, *enddate = NULL;\n    char *dbfile = NULL, *f;\n    char new_cert[PATH_MAX];\n    char tmp[10 + 1] = \"\\0\";\n    char *const *pp;\n    const char *p;\n    size_t outdirlen = 0;\n    int create_ser = 0, free_passin = 0, total = 0, total_done = 0;\n    int batch = 0, default_op = 1, doupdatedb = 0, ext_copy = EXT_COPY_NONE;\n    int keyformat = FORMAT_UNDEF, multirdn = 1, notext = 0, output_der = 0;\n    int ret = 1, email_dn = 1, req = 0, verbose = 0, gencrl = 0, dorevoke = 0;\n    int rand_ser = 0, i, j, selfsign = 0, def_ret;\n    char *crl_lastupdate = NULL, *crl_nextupdate = NULL;\n    long crldays = 0, crlhours = 0, crlsec = 0, days = 0;\n    unsigned long chtype = MBSTRING_ASC, certopt = 0;\n    X509 *x509 = NULL, *x509p = NULL, *x = NULL;\n    REVINFO_TYPE rev_type = REV_NONE;\n    X509_REVOKED *r = NULL;\n    OPTION_CHOICE o;\n\n    prog = opt_init(argc, argv, ca_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\nopthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ca_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            req = 1;\n            infile = opt_arg();\n            break;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_DATEOPT:\n            if (!set_dateopt(&dateopt, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_VERBOSE:\n            verbose = 1;\n            break;\n        case OPT_QUIET:\n            verbose = 0;\n            break;\n        case OPT_CONFIG:\n            configfile = opt_arg();\n            break;\n        case OPT_NAME:\n            section = opt_arg();\n            break;\n        case OPT_SUBJ:\n            subj = opt_arg();\n            /* preserve=1; */\n            break;\n        case OPT_UTF8:\n            chtype = MBSTRING_UTF8;\n            break;\n        case OPT_RAND_SERIAL:\n            rand_ser = 1;\n            break;\n        case OPT_CREATE_SERIAL:\n            create_ser = 1;\n            break;\n        case OPT_MULTIVALUE_RDN:\n            /* obsolete */\n            break;\n        case OPT_STARTDATE:\n        case OPT_NOT_BEFORE:\n            startdate = opt_arg();\n            break;\n        case OPT_ENDDATE:\n        case OPT_NOT_AFTER:\n            enddate = opt_arg();\n            break;\n        case OPT_DAYS:\n            days = atoi(opt_arg());\n            break;\n        case OPT_MD:\n            dgst = opt_arg();\n            break;\n        case OPT_POLICY:\n            policy = opt_arg();\n            break;\n        case OPT_KEYFILE:\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyformat))\n                goto opthelp;\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_KEY:\n            passin = opt_arg();\n            break;\n        case OPT_CERT:\n            certfile = opt_arg();\n            break;\n        case OPT_CERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &certformat))\n                goto opthelp;\n            break;\n        case OPT_SELFSIGN:\n            selfsign = 1;\n            break;\n        case OPT_OUTDIR:\n            outdir = opt_arg();\n            break;\n        case OPT_SIGOPT:\n            if (sigopts == NULL)\n                sigopts = sk_OPENSSL_STRING_new_null();\n            if (sigopts == NULL || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_VFYOPT:\n            if (vfyopts == NULL)\n                vfyopts = sk_OPENSSL_STRING_new_null();\n            if (vfyopts == NULL || !sk_OPENSSL_STRING_push(vfyopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_NOTEXT:\n            notext = 1;\n            break;\n        case OPT_BATCH:\n            batch = 1;\n            break;\n        case OPT_PRESERVEDN:\n            preserve = 1;\n            break;\n        case OPT_NOEMAILDN:\n            email_dn = 0;\n            break;\n        case OPT_GENCRL:\n            gencrl = 1;\n            break;\n        case OPT_MSIE_HACK:\n            msie_hack = 1;\n            break;\n        case OPT_CRL_LASTUPDATE:\n            crl_lastupdate = opt_arg();\n            break;\n        case OPT_CRL_NEXTUPDATE:\n            crl_nextupdate = opt_arg();\n            break;\n        case OPT_CRLDAYS:\n            crldays = atol(opt_arg());\n            break;\n        case OPT_CRLHOURS:\n            crlhours = atol(opt_arg());\n            break;\n        case OPT_CRLSEC:\n            crlsec = atol(opt_arg());\n            break;\n        case OPT_INFILES:\n            req = 1;\n            goto end_of_options;\n        case OPT_SS_CERT:\n            ss_cert_file = opt_arg();\n            req = 1;\n            break;\n        case OPT_SPKAC:\n            spkac_file = opt_arg();\n            req = 1;\n            break;\n        case OPT_REVOKE:\n            infile = opt_arg();\n            dorevoke = 1;\n            break;\n        case OPT_VALID:\n            infile = opt_arg();\n            dorevoke = 2;\n            break;\n        case OPT_EXTENSIONS:\n            extensions = opt_arg();\n            break;\n        case OPT_EXTFILE:\n            extfile = opt_arg();\n            break;\n        case OPT_STATUS:\n            ser_status = opt_arg();\n            break;\n        case OPT_UPDATEDB:\n            doupdatedb = 1;\n            break;\n        case OPT_CRLEXTS:\n            crl_ext = opt_arg();\n            break;\n        case OPT_CRL_REASON:   /* := REV_CRL_REASON */\n        case OPT_CRL_HOLD:\n        case OPT_CRL_COMPROMISE:\n        case OPT_CRL_CA_COMPROMISE:\n            rev_arg = opt_arg();\n            rev_type = (o - OPT_CRL_REASON) + REV_CRL_REASON;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n\nend_of_options:\n    /* Remaining args are files to certify. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((conf = app_load_config_verbose(configfile, 1)) == NULL)\n        goto end;\n    if (configfile != default_config_file && !app_load_modules(conf))\n        goto end;\n\n    /* Lets get the config section we are using */\n    if (section == NULL\n        && (section = lookup_conf(conf, BASE_SECTION, ENV_DEFAULT_CA)) == NULL)\n        goto end;\n\n    p = app_conf_try_string(conf, NULL, \"oid_file\");\n    if (p != NULL) {\n        BIO *oid_bio = BIO_new_file(p, \"r\");\n\n        if (oid_bio == NULL) {\n            ERR_clear_error();\n        } else {\n            OBJ_create_objects(oid_bio);\n            BIO_free(oid_bio);\n        }\n    }\n    if (!add_oid_section(conf))\n        goto end;\n\n    app_RAND_load_conf(conf, BASE_SECTION);\n    if (!app_RAND_load())\n        goto end;\n\n    f = app_conf_try_string(conf, section, STRING_MASK);\n    if (f != NULL && !ASN1_STRING_set_default_mask_asc(f)) {\n        BIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", f);\n        goto end;\n    }\n\n    if (chtype != MBSTRING_UTF8) {\n        f = app_conf_try_string(conf, section, UTF8_IN);\n        if (f != NULL && strcmp(f, \"yes\") == 0)\n            chtype = MBSTRING_UTF8;\n    }\n\n    db_attr.unique_subject = 1;\n    p = app_conf_try_string(conf, section, ENV_UNIQUE_SUBJECT);\n    if (p != NULL)\n        db_attr.unique_subject = parse_yesno(p, 1);\n\n    /*****************************************************************/\n    /* report status of cert with serial number given on command line */\n    if (ser_status) {\n        dbfile = lookup_conf(conf, section, ENV_DATABASE);\n        if (dbfile == NULL)\n            goto end;\n\n        db = load_index(dbfile, &db_attr);\n        if (db == NULL) {\n            BIO_printf(bio_err, \"Problem with index file: %s (could not load/parse file)\\n\", dbfile);\n            goto end;\n        }\n\n        if (index_index(db) <= 0)\n            goto end;\n\n        if (get_certificate_status(ser_status, db) != 1)\n            BIO_printf(bio_err, \"Error verifying serial %s!\\n\", ser_status);\n        goto end;\n    }\n\n    /*****************************************************************/\n    /* we definitely need a private key, so let's get it */\n\n    if (keyfile == NULL\n        && (keyfile = lookup_conf(conf, section, ENV_PRIVATE_KEY)) == NULL)\n        goto end;\n\n    if (passin == NULL) {\n        free_passin = 1;\n        if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n            BIO_printf(bio_err, \"Error getting password\\n\");\n            goto end;\n        }\n    }\n    pkey = load_key(keyfile, keyformat, 0, passin, e, \"CA private key\");\n    cleanse(passin);\n    if (pkey == NULL)\n        /* load_key() has already printed an appropriate message */\n        goto end;\n\n    /*****************************************************************/\n    /* we need a certificate */\n    if (!selfsign || spkac_file || ss_cert_file || gencrl) {\n        if (certfile == NULL\n            && (certfile = lookup_conf(conf, section, ENV_CERTIFICATE)) == NULL)\n            goto end;\n\n        x509 = load_cert_pass(certfile, certformat, 1, passin, \"CA certificate\");\n        if (x509 == NULL)\n            goto end;\n\n        if (!X509_check_private_key(x509, pkey)) {\n            BIO_printf(bio_err,\n                       \"CA certificate and CA private key do not match\\n\");\n            goto end;\n        }\n    }\n    if (!selfsign)\n        x509p = x509;\n\n    f = app_conf_try_string(conf, BASE_SECTION, ENV_PRESERVE);\n    if (f != NULL && (*f == 'y' || *f == 'Y'))\n        preserve = 1;\n    f = app_conf_try_string(conf, BASE_SECTION, ENV_MSIE_HACK);\n    if (f != NULL && (*f == 'y' || *f == 'Y'))\n        msie_hack = 1;\n\n    f = app_conf_try_string(conf, section, ENV_NAMEOPT);\n    if (f != NULL) {\n        if (!set_nameopt(f)) {\n            BIO_printf(bio_err, \"Invalid name options: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n        default_op = 0;\n    }\n\n    f = app_conf_try_string(conf, section, ENV_CERTOPT);\n    if (f != NULL) {\n        if (!set_cert_ex(&certopt, f)) {\n            BIO_printf(bio_err, \"Invalid certificate options: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n        default_op = 0;\n    }\n\n    f = app_conf_try_string(conf, section, ENV_EXTCOPY);\n    if (f != NULL) {\n        if (!set_ext_copy(&ext_copy, f)) {\n            BIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\", f);\n            goto end;\n        }\n    }\n\n    /*****************************************************************/\n    /* lookup where to write new certificates */\n    if ((outdir == NULL) && (req)) {\n\n        outdir = NCONF_get_string(conf, section, ENV_NEW_CERTS_DIR);\n        if (outdir == NULL) {\n            BIO_printf(bio_err,\n                       \"there needs to be defined a directory for new certificate to be placed in\\n\");\n            goto end;\n        }\n#ifndef OPENSSL_SYS_VMS\n        /*\n         * outdir is a directory spec, but access() for VMS demands a\n         * filename.  We could use the DEC C routine to convert the\n         * directory syntax to Unix, and give that to app_isdir,\n         * but for now the fopen will catch the error if it's not a\n         * directory\n         */\n        if (app_isdir(outdir) <= 0) {\n            BIO_printf(bio_err, \"%s: %s is not a directory\\n\", prog, outdir);\n            perror(outdir);\n            goto end;\n        }\n#endif\n    }\n\n    /*****************************************************************/\n    /* we need to load the database file */\n    dbfile = lookup_conf(conf, section, ENV_DATABASE);\n    if (dbfile == NULL)\n        goto end;\n\n    db = load_index(dbfile, &db_attr);\n    if (db == NULL) {\n        BIO_printf(bio_err, \"Problem with index file: %s (could not load/parse file)\\n\", dbfile);\n        goto end;\n    }\n\n    /* Lets check some fields */\n    for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\n        pp = sk_OPENSSL_PSTRING_value(db->db->data, i);\n        if ((pp[DB_type][0] != DB_TYPE_REV) && (pp[DB_rev_date][0] != '\\0')) {\n            BIO_printf(bio_err,\n                       \"entry %d: not revoked yet, but has a revocation date\\n\",\n                       i + 1);\n            goto end;\n        }\n        if ((pp[DB_type][0] == DB_TYPE_REV) &&\n            !make_revoked(NULL, pp[DB_rev_date])) {\n            BIO_printf(bio_err, \" in entry %d\\n\", i + 1);\n            goto end;\n        }\n        if (!check_time_format((char *)pp[DB_exp_date])) {\n            BIO_printf(bio_err, \"entry %d: invalid expiry date\\n\", i + 1);\n            goto end;\n        }\n        p = pp[DB_serial];\n        j = strlen(p);\n        if (*p == '-') {\n            p++;\n            j--;\n        }\n        if ((j & 1) || (j < 2)) {\n            BIO_printf(bio_err, \"entry %d: bad serial number length (%d)\\n\",\n                       i + 1, j);\n            goto end;\n        }\n        for ( ; *p; p++) {\n            if (!isxdigit(_UC(*p))) {\n                BIO_printf(bio_err,\n                           \"entry %d: bad char 0%o '%c' in serial number\\n\",\n                           i + 1, *p, *p);\n                goto end;\n            }\n        }\n    }\n    if (verbose) {\n        TXT_DB_write(bio_out, db->db);\n        BIO_printf(bio_err, \"%d entries loaded from the database\\n\",\n                   sk_OPENSSL_PSTRING_num(db->db->data));\n        BIO_printf(bio_err, \"generating index\\n\");\n    }\n\n    if (index_index(db) <= 0)\n        goto end;\n\n    /*****************************************************************/\n    /* Update the db file for expired certificates */\n    if (doupdatedb) {\n        if (verbose)\n            BIO_printf(bio_err, \"Updating %s ...\\n\", dbfile);\n\n        i = do_updatedb(db, NULL);\n        if (i == -1) {\n            BIO_printf(bio_err, \"Malloc failure\\n\");\n            goto end;\n        } else if (i == 0) {\n            if (verbose)\n                BIO_printf(bio_err, \"No entries found to mark expired\\n\");\n        } else {\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            if (verbose)\n                BIO_printf(bio_err, \"Done. %d entries marked as expired\\n\", i);\n        }\n    }\n\n    /*****************************************************************/\n    /* Read extensions config file                                   */\n    if (extfile) {\n        if ((extfile_conf = app_load_config(extfile)) == NULL) {\n            ret = 1;\n            goto end;\n        }\n\n        if (verbose)\n            BIO_printf(bio_err, \"Successfully loaded extensions file %s\\n\",\n                       extfile);\n\n        /* We can have sections in the ext file */\n        if (extensions == NULL) {\n            extensions =\n                app_conf_try_string(extfile_conf, \"default\", \"extensions\");\n            if (extensions == NULL)\n                extensions = \"default\";\n        }\n    }\n\n    /*****************************************************************/\n    if (req || gencrl) {\n        if (spkac_file != NULL && outfile != NULL) {\n            output_der = 1;\n            batch = 1;\n        }\n    }\n\n    def_ret = EVP_PKEY_get_default_digest_name(pkey, def_dgst, sizeof(def_dgst));\n    /*\n     * EVP_PKEY_get_default_digest_name() returns 2 if the digest is\n     * mandatory for this algorithm.\n     *\n     * That call may give back the name \"UNDEF\", which has these meanings:\n     *\n     * when def_ret == 2: the user MUST leave the digest unspecified\n     * when def_ret == 1: the user MAY leave the digest unspecified\n     */\n    if (def_ret == 2 && strcmp(def_dgst, \"UNDEF\") == 0) {\n        dgst = NULL;\n    } else if (dgst == NULL\n               && (dgst = lookup_conf(conf, section, ENV_DEFAULT_MD)) == NULL\n               && strcmp(def_dgst, \"UNDEF\") != 0) {\n        goto end;\n    } else {\n        if (strcmp(dgst, \"default\") == 0 || strcmp(def_dgst, \"UNDEF\") == 0) {\n            if (def_ret <= 0) {\n                BIO_puts(bio_err, \"no default digest\\n\");\n                goto end;\n            }\n            dgst = def_dgst;\n        }\n    }\n\n    if (req) {\n        if (email_dn == 1) {\n            char *tmp_email_dn = NULL;\n\n            tmp_email_dn =\n                app_conf_try_string(conf, section, ENV_DEFAULT_EMAIL_DN);\n            if (tmp_email_dn != NULL && strcmp(tmp_email_dn, \"no\") == 0)\n                email_dn = 0;\n        }\n        if (verbose)\n            BIO_printf(bio_err, \"message digest is %s\\n\", dgst);\n        if (policy == NULL\n            && (policy = lookup_conf(conf, section, ENV_POLICY)) == NULL)\n            goto end;\n\n        if (verbose)\n            BIO_printf(bio_err, \"policy is %s\\n\", policy);\n\n        if (app_conf_try_string(conf, section, ENV_RAND_SERIAL) != NULL) {\n            rand_ser = 1;\n        } else {\n            serialfile = lookup_conf(conf, section, ENV_SERIAL);\n            if (serialfile == NULL)\n                goto end;\n        }\n\n        if (extfile_conf != NULL) {\n            /* Check syntax of extfile */\n            X509V3_CTX ctx;\n\n            X509V3_set_ctx_test(&ctx);\n            X509V3_set_nconf(&ctx, extfile_conf);\n            if (!X509V3_EXT_add_nconf(extfile_conf, &ctx, extensions, NULL)) {\n                BIO_printf(bio_err,\n                           \"Error checking certificate extensions from extfile section %s\\n\",\n                           extensions);\n                ret = 1;\n                goto end;\n            }\n        } else {\n            /*\n             * no '-extfile' option, so we look for extensions in the main\n             * configuration file\n             */\n            if (extensions == NULL)\n                extensions = app_conf_try_string(conf, section, ENV_EXTENSIONS);\n            if (extensions != NULL) {\n                /* Check syntax of config file section */\n                X509V3_CTX ctx;\n\n                X509V3_set_ctx_test(&ctx);\n                X509V3_set_nconf(&ctx, conf);\n                if (!X509V3_EXT_add_nconf(conf, &ctx, extensions, NULL)) {\n                    BIO_printf(bio_err,\n                               \"Error checking certificate extension config section %s\\n\",\n                               extensions);\n                    ret = 1;\n                    goto end;\n                }\n            }\n        }\n\n        if (startdate == NULL)\n            startdate =\n                app_conf_try_string(conf, section, ENV_DEFAULT_STARTDATE);\n        if (enddate == NULL)\n            enddate = app_conf_try_string(conf, section, ENV_DEFAULT_ENDDATE);\n        if (days == 0) {\n            if (!app_conf_try_number(conf, section, ENV_DEFAULT_DAYS, &days))\n                days = 0;\n        }\n        if (enddate == NULL && days == 0) {\n            BIO_printf(bio_err, \"cannot lookup how many days to certify for\\n\");\n            goto end;\n        }\n        if (days != 0 && enddate != NULL)\n            BIO_printf(bio_err,\n                       \"Warning: -enddate or -not_after option overriding -days option\\n\");\n\n        if (rand_ser) {\n            if ((serial = BN_new()) == NULL || !rand_serial(serial, NULL)) {\n                BIO_printf(bio_err, \"error generating serial number\\n\");\n                goto end;\n            }\n        } else {\n            serial = load_serial(serialfile, NULL, create_ser, NULL);\n            if (serial == NULL) {\n                BIO_printf(bio_err, \"error while loading serial number\\n\");\n                goto end;\n            }\n            if (verbose) {\n                if (BN_is_zero(serial)) {\n                    BIO_printf(bio_err, \"next serial number is 00\\n\");\n                } else {\n                    if ((f = BN_bn2hex(serial)) == NULL)\n                        goto end;\n                    BIO_printf(bio_err, \"next serial number is %s\\n\", f);\n                    OPENSSL_free(f);\n                }\n            }\n        }\n\n        if ((attribs = NCONF_get_section(conf, policy)) == NULL) {\n            BIO_printf(bio_err, \"unable to find 'section' for %s\\n\", policy);\n            goto end;\n        }\n\n        if ((cert_sk = sk_X509_new_null()) == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n        if (spkac_file != NULL) {\n            total++;\n            j = certify_spkac(&x, spkac_file, pkey, x509, dgst, sigopts,\n                              attribs, db, serial, subj, chtype, multirdn,\n                              email_dn, startdate, enddate, days, extensions,\n                              conf, verbose, certopt, get_nameopt(), default_op,\n                              ext_copy, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        if (ss_cert_file != NULL) {\n            total++;\n            j = certify_cert(&x, ss_cert_file, certformat, passin, pkey,\n                             x509, dgst, sigopts, vfyopts, attribs,\n                             db, serial, subj, chtype, multirdn, email_dn,\n                             startdate, enddate, days, batch, extensions,\n                             conf, verbose, certopt, get_nameopt(), default_op,\n                             ext_copy, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        if (infile != NULL) {\n            total++;\n            j = certify(&x, infile, informat, pkey, x509p, dgst,\n                        sigopts, vfyopts, attribs, db,\n                        serial, subj, chtype, multirdn, email_dn, startdate,\n                        enddate, days, batch, extensions, conf, verbose,\n                        certopt, get_nameopt(), default_op, ext_copy, selfsign, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1))\n                    goto end;\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n        }\n        for (i = 0; i < argc; i++) {\n            total++;\n            j = certify(&x, argv[i], informat, pkey, x509p, dgst,\n                        sigopts, vfyopts,\n                        attribs, db,\n                        serial, subj, chtype, multirdn, email_dn, startdate,\n                        enddate, days, batch, extensions, conf, verbose,\n                        certopt, get_nameopt(), default_op, ext_copy, selfsign, dateopt);\n            if (j < 0)\n                goto end;\n            if (j > 0) {\n                total_done++;\n                BIO_printf(bio_err, \"\\n\");\n                if (!BN_add_word(serial, 1)) {\n                    X509_free(x);\n                    goto end;\n                }\n                if (!sk_X509_push(cert_sk, x)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    X509_free(x);\n                    goto end;\n                }\n            }\n        }\n        /*\n         * we have a stack of newly certified certificates and a database\n         * and serial number that need updating\n         */\n\n        if (sk_X509_num(cert_sk) > 0) {\n            if (!batch) {\n                BIO_printf(bio_err,\n                           \"\\n%d out of %d certificate requests certified, commit? [y/n]\",\n                           total_done, total);\n                (void)BIO_flush(bio_err);\n                tmp[0] = '\\0';\n                if (fgets(tmp, sizeof(tmp), stdin) == NULL) {\n                    BIO_printf(bio_err, \"CERTIFICATION CANCELED: I/O error\\n\");\n                    ret = 0;\n                    goto end;\n                }\n                if (tmp[0] != 'y' && tmp[0] != 'Y') {\n                    BIO_printf(bio_err, \"CERTIFICATION CANCELED\\n\");\n                    ret = 0;\n                    goto end;\n                }\n            }\n\n            BIO_printf(bio_err, \"Write out database with %d new entries\\n\",\n                       sk_X509_num(cert_sk));\n\n            if (serialfile != NULL\n                    && !save_serial(serialfile, \"new\", serial, NULL))\n                goto end;\n\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n        }\n\n        outdirlen = OPENSSL_strlcpy(new_cert, outdir, sizeof(new_cert));\n#ifndef OPENSSL_SYS_VMS\n        outdirlen = OPENSSL_strlcat(new_cert, \"/\", sizeof(new_cert));\n#endif\n\n        if (verbose)\n            BIO_printf(bio_err, \"writing new certificates\\n\");\n\n        for (i = 0; i < sk_X509_num(cert_sk); i++) {\n            BIO *Cout = NULL;\n            X509 *xi = sk_X509_value(cert_sk, i);\n            const ASN1_INTEGER *serialNumber = X509_get0_serialNumber(xi);\n            const unsigned char *psn = ASN1_STRING_get0_data(serialNumber);\n            const int snl = ASN1_STRING_length(serialNumber);\n            const int filen_len = 2 * (snl > 0 ? snl : 1) + sizeof(\".pem\");\n            char *n = new_cert + outdirlen;\n\n            if (outdirlen + filen_len > PATH_MAX) {\n                BIO_printf(bio_err, \"certificate file name too long\\n\");\n                goto end;\n            }\n\n            if (snl > 0) {\n                static const char HEX_DIGITS[] = \"0123456789ABCDEF\";\n\n                for (j = 0; j < snl; j++, psn++) {\n                    *n++ = HEX_DIGITS[*psn >> 4];\n                    *n++ = HEX_DIGITS[*psn & 0x0F];\n                }\n            } else {\n                *(n++) = '0';\n                *(n++) = '0';\n            }\n            *(n++) = '.';\n            *(n++) = 'p';\n            *(n++) = 'e';\n            *(n++) = 'm';\n            *n = '\\0';          /* closing new_cert */\n            if (verbose)\n                BIO_printf(bio_err, \"writing %s\\n\", new_cert);\n\n            Sout = bio_open_default(outfile, 'w',\n                                    output_der ? FORMAT_ASN1 : FORMAT_TEXT);\n            if (Sout == NULL)\n                goto end;\n\n            Cout = BIO_new_file(new_cert, \"w\");\n            if (Cout == NULL) {\n                perror(new_cert);\n                goto end;\n            }\n            write_new_certificate(Cout, xi, 0, notext);\n            write_new_certificate(Sout, xi, output_der, notext);\n            BIO_free_all(Cout);\n            BIO_free_all(Sout);\n            Sout = NULL;\n        }\n\n        if (sk_X509_num(cert_sk)) {\n            /* Rename the database and the serial file */\n            if (serialfile != NULL\n                    && !rotate_serial(serialfile, \"new\", \"old\"))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            BIO_printf(bio_err, \"Database updated\\n\");\n        }\n    }\n\n    /*****************************************************************/\n    if (gencrl) {\n        int crl_v2 = 0;\n\n        if (crl_ext == NULL)\n            crl_ext = app_conf_try_string(conf, section, ENV_CRLEXT);\n        if (crl_ext != NULL) {\n            /* Check syntax of file */\n            X509V3_CTX ctx;\n\n            X509V3_set_ctx_test(&ctx);\n            X509V3_set_nconf(&ctx, conf);\n            if (!X509V3_EXT_add_nconf(conf, &ctx, crl_ext, NULL)) {\n                BIO_printf(bio_err,\n                           \"Error checking CRL extension section %s\\n\", crl_ext);\n                ret = 1;\n                goto end;\n            }\n        }\n\n        crlnumberfile = app_conf_try_string(conf, section, ENV_CRLNUMBER);\n        if (crlnumberfile != NULL) {\n            if ((crlnumber = load_serial(crlnumberfile, NULL, 0, NULL))\n                == NULL) {\n                BIO_printf(bio_err, \"error while loading CRL number\\n\");\n                goto end;\n            }\n        }\n\n        if (!crldays && !crlhours && !crlsec) {\n            if (!app_conf_try_number(conf, section,\n                                  ENV_DEFAULT_CRL_DAYS, &crldays))\n                crldays = 0;\n            if (!app_conf_try_number(conf, section,\n                                  ENV_DEFAULT_CRL_HOURS, &crlhours))\n                crlhours = 0;\n        }\n        if ((crl_nextupdate == NULL) &&\n                (crldays == 0) && (crlhours == 0) && (crlsec == 0)) {\n            BIO_printf(bio_err,\n                       \"cannot lookup how long until the next CRL is issued\\n\");\n            goto end;\n        }\n\n        if (verbose)\n            BIO_printf(bio_err, \"making CRL\\n\");\n        if ((crl = X509_CRL_new_ex(app_get0_libctx(), app_get0_propq())) == NULL)\n            goto end;\n        if (!X509_CRL_set_issuer_name(crl, X509_get_subject_name(x509)))\n            goto end;\n\n        if (!set_crl_lastupdate(crl, crl_lastupdate)) {\n            BIO_puts(bio_err, \"error setting CRL lastUpdate\\n\");\n            ret = 1;\n            goto end;\n        }\n\n        if (!set_crl_nextupdate(crl, crl_nextupdate,\n                                crldays, crlhours, crlsec)) {\n            BIO_puts(bio_err, \"error setting CRL nextUpdate\\n\");\n            ret = 1;\n            goto end;\n        }\n\n        for (i = 0; i < sk_OPENSSL_PSTRING_num(db->db->data); i++) {\n            pp = sk_OPENSSL_PSTRING_value(db->db->data, i);\n            if (pp[DB_type][0] == DB_TYPE_REV) {\n                if ((r = X509_REVOKED_new()) == NULL)\n                    goto end;\n                j = make_revoked(r, pp[DB_rev_date]);\n                if (!j)\n                    goto end;\n                if (j == 2)\n                    crl_v2 = 1;\n                if (!BN_hex2bn(&serial, pp[DB_serial]))\n                    goto end;\n                tmpser = BN_to_ASN1_INTEGER(serial, NULL);\n                BN_free(serial);\n                serial = NULL;\n                if (!tmpser)\n                    goto end;\n                X509_REVOKED_set_serialNumber(r, tmpser);\n                ASN1_INTEGER_free(tmpser);\n                X509_CRL_add0_revoked(crl, r);\n            }\n        }\n\n        /*\n         * sort the data so it will be written in serial number order\n         */\n        X509_CRL_sort(crl);\n\n        /* we now have a CRL */\n        if (verbose)\n            BIO_printf(bio_err, \"signing CRL\\n\");\n\n        /* Add any extensions asked for */\n\n        if (crl_ext != NULL || crlnumberfile != NULL) {\n            X509V3_CTX crlctx;\n\n            X509V3_set_ctx(&crlctx, x509, NULL, NULL, crl, 0);\n            X509V3_set_nconf(&crlctx, conf);\n\n            if (crl_ext != NULL)\n                if (!X509V3_EXT_CRL_add_nconf(conf, &crlctx, crl_ext, crl)) {\n                    BIO_printf(bio_err,\n                               \"Error adding CRL extensions from section %s\\n\", crl_ext);\n                    goto end;\n                }\n            if (crlnumberfile != NULL) {\n                tmpser = BN_to_ASN1_INTEGER(crlnumber, NULL);\n                if (!tmpser)\n                    goto end;\n                X509_CRL_add1_ext_i2d(crl, NID_crl_number, tmpser, 0, 0);\n                ASN1_INTEGER_free(tmpser);\n                crl_v2 = 1;\n                if (!BN_add_word(crlnumber, 1))\n                    goto end;\n            }\n        }\n        if (crl_ext != NULL || crl_v2) {\n            if (!X509_CRL_set_version(crl, X509_CRL_VERSION_2))\n                goto end;\n        }\n\n        /* we have a CRL number that need updating */\n        if (crlnumberfile != NULL\n                && !save_serial(crlnumberfile, \"new\", crlnumber, NULL))\n            goto end;\n\n        BN_free(crlnumber);\n        crlnumber = NULL;\n\n        if (!do_X509_CRL_sign(crl, pkey, dgst, sigopts))\n            goto end;\n\n        Sout = bio_open_default(outfile, 'w',\n                                output_der ? FORMAT_ASN1 : FORMAT_TEXT);\n        if (Sout == NULL)\n            goto end;\n\n        PEM_write_bio_X509_CRL(Sout, crl);\n\n        /* Rename the crlnumber file */\n        if (crlnumberfile != NULL\n                && !rotate_serial(crlnumberfile, \"new\", \"old\"))\n            goto end;\n\n    }\n    /*****************************************************************/\n    if (dorevoke) {\n        if (infile == NULL) {\n            BIO_printf(bio_err, \"no input files\\n\");\n            goto end;\n        } else {\n            X509 *revcert;\n\n            revcert = load_cert_pass(infile, informat, 1, passin,\n                                     \"certificate to be revoked\");\n            if (revcert == NULL)\n                goto end;\n            if (dorevoke == 2)\n                rev_type = REV_VALID;\n            j = do_revoke(revcert, db, rev_type, rev_arg);\n            if (j <= 0)\n                goto end;\n            X509_free(revcert);\n\n            if (!save_index(dbfile, \"new\", db))\n                goto end;\n\n            if (!rotate_index(dbfile, \"new\", \"old\"))\n                goto end;\n\n            BIO_printf(bio_err, \"Database updated\\n\");\n        }\n    }\n    ret = 0;\n\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    BIO_free_all(Sout);\n    BIO_free_all(out);\n    BIO_free_all(in);\n    OSSL_STACK_OF_X509_free(cert_sk);\n\n    cleanse(passin);\n    if (free_passin)\n        OPENSSL_free(passin);\n    BN_free(serial);\n    BN_free(crlnumber);\n    free_index(db);\n    sk_OPENSSL_STRING_free(sigopts);\n    sk_OPENSSL_STRING_free(vfyopts);\n    EVP_PKEY_free(pkey);\n    X509_free(x509);\n    X509_CRL_free(crl);\n    NCONF_free(conf);\n    NCONF_free(extfile_conf);\n    release_engine(e);\n    return ret;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}",
            "static int do_revoke(X509 *x509, CA_DB *db, REVINFO_TYPE rev_type,\n                     const char *value)\n{\n    const ASN1_TIME *tm = NULL;\n    char *row[DB_NUMBER], **rrow, **irow;\n    char *rev_str = NULL;\n    BIGNUM *bn = NULL;\n    int ok = -1, i;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(x509), NULL, 0);\n    bn = ASN1_INTEGER_to_BN(X509_get0_serialNumber(x509), NULL);\n    if (!bn)\n        goto end;\n    if (BN_is_zero(bn))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(bn);\n    BN_free(bn);\n    if (row[DB_name] != NULL && row[DB_name][0] == '\\0') {\n        /* Entries with empty Subjects actually use the serial number instead */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n    }\n    if ((row[DB_name] == NULL) || (row[DB_serial] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n    /*\n     * We have to lookup by serial number because name lookup skips revoked\n     * certs\n     */\n    rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n    if (rrow == NULL) {\n        BIO_printf(bio_err,\n                   \"Adding Entry with serial number %s to DB for %s\\n\",\n                   row[DB_serial], row[DB_name]);\n\n        /* We now just add it to the database as DB_TYPE_REV('V') */\n        row[DB_type] = OPENSSL_strdup(\"V\");\n        tm = X509_get0_notAfter(x509);\n        row[DB_exp_date] = app_malloc(tm->length + 1, \"row exp_data\");\n        memcpy(row[DB_exp_date], tm->data, tm->length);\n        row[DB_exp_date][tm->length] = '\\0';\n        row[DB_rev_date] = NULL;\n        row[DB_file] = OPENSSL_strdup(\"unknown\");\n\n        if (row[DB_type] == NULL || row[DB_file] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n\n        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");\n        for (i = 0; i < DB_NUMBER; i++)\n            irow[i] = row[i];\n        irow[DB_NUMBER] = NULL;\n\n        if (!TXT_DB_insert(db->db, irow)) {\n            BIO_printf(bio_err, \"failed to update database\\n\");\n            BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n            OPENSSL_free(irow);\n            goto end;\n        }\n\n        for (i = 0; i < DB_NUMBER; i++)\n            row[i] = NULL;\n\n        /* Revoke Certificate */\n        if (rev_type == REV_VALID)\n            ok = 1;\n        else\n            /* Retry revocation after DB insertion */\n            ok = do_revoke(x509, db, rev_type, value);\n\n        goto end;\n\n    } else if (index_name_cmp_noconst(row, rrow)) {\n        BIO_printf(bio_err, \"ERROR:name does not match %s\\n\", row[DB_name]);\n        goto end;\n    } else if (rev_type == REV_VALID) {\n        BIO_printf(bio_err, \"ERROR:Already present, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else if (rrow[DB_type][0] == DB_TYPE_REV) {\n        BIO_printf(bio_err, \"ERROR:Already revoked, serial number %s\\n\",\n                   row[DB_serial]);\n        goto end;\n    } else {\n        BIO_printf(bio_err, \"Revoking Certificate %s.\\n\", rrow[DB_serial]);\n        rev_str = make_revocation_str(rev_type, value);\n        if (!rev_str) {\n            BIO_printf(bio_err, \"Error in revocation arguments\\n\");\n            goto end;\n        }\n        rrow[DB_type][0] = DB_TYPE_REV;\n        rrow[DB_type][1] = '\\0';\n        rrow[DB_rev_date] = rev_str;\n    }\n    ok = 1;\n end:\n    for (i = 0; i < DB_NUMBER; i++)\n        OPENSSL_free(row[i]);\n    return ok;\n}"
        ],
        "sink": "j = do_revoke(revcert, db, rev_type, rev_arg);",
        "final_sink": "            ok = do_revoke(x509, db, rev_type, value);",
        "source": [
            "        cv = sk_CONF_VALUE_value(sk, i);"
        ],
        "index": 4
    },
    {
        "prt": "alg",
        "function_call": [
            "static void print_keyspec(OSSL_CMP_ATAVS *keySpec)\n{\n    const char *desc = \"specifications contained in keySpec from genp\";\n    BIO *mem;\n    int i;\n    const char *p;\n    long len;\n\n    if (keySpec == NULL) {\n        CMP_info1(\"No %s\", desc);\n        return;\n    }\n\n    mem = BIO_new(BIO_s_mem());\n    if (mem == NULL) {\n        CMP_err1(\"Out of memory - cannot dump key %s\", desc);\n        return;\n    }\n    BIO_printf(mem, \"Key %s:\\n\", desc);\n\n    for (i = 0; i < sk_OSSL_CMP_ATAV_num(keySpec); i++) {\n        OSSL_CMP_ATAV *atav = sk_OSSL_CMP_ATAV_value(keySpec, i);\n        ASN1_OBJECT *type = OSSL_CMP_ATAV_get0_type(atav /* may be NULL */);\n        int nid = OBJ_obj2nid(type);\n\n        switch (nid) {\n        case NID_id_regCtrl_algId:\n            {\n                X509_ALGOR *alg = OSSL_CMP_ATAV_get0_algId(atav);\n                const ASN1_OBJECT *oid;\n                int paramtype;\n                const void *param;\n\n                X509_ALGOR_get0(&oid, &paramtype, &param, alg);\n                BIO_printf(mem, \"Key algorithm: \");\n                i2a_ASN1_OBJECT(mem, oid);\n                if (paramtype == V_ASN1_UNDEF || alg->parameter == NULL) {\n                    BIO_printf(mem, \"\\n\");\n                } else {\n                    BIO_printf(mem, \" - \");\n                    ASN1_item_print(mem, (ASN1_VALUE *)alg,\n                                    0, ASN1_ITEM_rptr(X509_ALGOR), NULL);\n                }\n            }\n            break;\n        case NID_id_regCtrl_rsaKeyLen:\n            BIO_printf(mem, \"Key algorithm: RSA %d\\n\",\n                       OSSL_CMP_ATAV_get_rsaKeyLen(atav));\n            break;\n        default:\n            BIO_printf(mem, \"Invalid key spec: %s\\n\", nid_name(nid));\n            break;\n        }\n    }\n    BIO_printf(mem, \"End of key %s\", desc);\n\n    len = BIO_get_mem_data(mem, &p);\n    if (len > INT_MAX)\n        CMP_err1(\"Info too large - cannot dump key %s\", desc);\n    else\n        CMP_info2(\"%.*s\", (int)len, p);\n    BIO_free(mem);\n    return;\n}"
        ],
        "sink": "if (paramtype == V_ASN1_UNDEF || alg->parameter == NULL) {",
        "final_sink": "if (paramtype == V_ASN1_UNDEF || alg->parameter == NULL) {",
        "source": [
            "        str = X509_NAME_ENTRY_get_data(ne);"
        ],
        "index": 5
    },
    {
        "prt": "key_param",
        "function_call": [
            "int cms_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ASN1_OBJECT *econtent_type = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\n    CMS_ContentInfo *cms = NULL, *rcms = NULL;\n    CMS_ReceiptRequest *rr = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *key = NULL;\n    EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = sk_X509_new_null(), *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL, *originator = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = X509_VERIFY_PARAM_new();\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *certsoutfile = NULL, *digestname = NULL, *wrapname = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    char *digesthex = NULL;\n    unsigned char *digestbin = NULL;\n    long digestlen = 0;\n    char *infile = NULL, *outfile = NULL, *rctfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *signerfile = NULL;\n    char *originatorfile = NULL, *recipfile = NULL, *ciphername = NULL;\n    char *to = NULL, *from = NULL, *subject = NULL, *prog;\n    cms_key_param *key_first = NULL, *key_param = NULL;\n    int flags = CMS_DETACHED, binary_files = 0;\n    int noout = 0, print = 0, keyidx = -1, vpmtouched = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\n    int operation = 0, ret = 1, rr_print = 0, rr_allorfirst = -1;\n    int verify_retcode = 0, rctformat = FORMAT_SMIME, keyform = FORMAT_UNDEF;\n    size_t secret_keylen = 0, secret_keyidlen = 0;\n    unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\n    unsigned char *secret_key = NULL, *secret_keyid = NULL;\n    long ltmp;\n    const char *mime_eol = \"\\n\";\n    OPTION_CHOICE o;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if (encerts == NULL || vpm == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, cms_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(cms_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n\n        case OPT_ENCRYPT:\n            operation = SMIME_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            operation = SMIME_DECRYPT;\n            break;\n        case OPT_SIGN:\n            operation = SMIME_SIGN;\n            break;\n        case OPT_VERIFY:\n            operation = SMIME_VERIFY;\n            break;\n        case OPT_RESIGN:\n            operation = SMIME_RESIGN;\n            break;\n        case OPT_SIGN_RECEIPT:\n            operation = SMIME_SIGN_RECEIPT;\n            break;\n        case OPT_VERIFY_RECEIPT:\n            operation = SMIME_VERIFY_RECEIPT;\n            rctfile = opt_arg();\n            break;\n        case OPT_VERIFY_RETCODE:\n            verify_retcode = 1;\n            break;\n        case OPT_DIGEST_CREATE:\n            operation = SMIME_DIGEST_CREATE;\n            break;\n        case OPT_DIGEST:\n            digesthex = opt_arg();\n            break;\n        case OPT_DIGEST_VERIFY:\n            operation = SMIME_DIGEST_VERIFY;\n            break;\n        case OPT_COMPRESS:\n            operation = SMIME_COMPRESS;\n            break;\n        case OPT_UNCOMPRESS:\n            operation = SMIME_UNCOMPRESS;\n            break;\n        case OPT_ED_ENCRYPT:\n            operation = SMIME_ENCRYPTED_ENCRYPT;\n            break;\n        case OPT_ED_DECRYPT:\n            operation = SMIME_ENCRYPTED_DECRYPT;\n            break;\n        case OPT_DATA_CREATE:\n            operation = SMIME_DATA_CREATE;\n            break;\n        case OPT_DATA_OUT:\n            operation = SMIME_DATA_OUT;\n            break;\n        case OPT_CMSOUT:\n            operation = SMIME_CMSOUT;\n            break;\n\n        case OPT_DEBUG_DECRYPT:\n            flags |= CMS_DEBUG_DECRYPT;\n            break;\n        case OPT_TEXT:\n            flags |= CMS_TEXT;\n            break;\n        case OPT_ASCIICRLF:\n            flags |= CMS_ASCIICRLF;\n            break;\n        case OPT_NOINTERN:\n            flags |= CMS_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= CMS_NO_SIGNER_CERT_VERIFY;\n            break;\n        case OPT_NOCERTS:\n            flags |= CMS_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= CMS_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~CMS_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= CMS_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= CMS_BINARY;\n            break;\n        case OPT_CADES:\n            flags |= CMS_CADES;\n            break;\n        case OPT_KEYID:\n            flags |= CMS_USE_KEYID;\n            break;\n        case OPT_NOSIGS:\n            flags |= CMS_NOSIGS;\n            break;\n        case OPT_NO_CONTENT_VERIFY:\n            flags |= CMS_NO_CONTENT_VERIFY;\n            break;\n        case OPT_NO_ATTR_VERIFY:\n            flags |= CMS_NO_ATTR_VERIFY;\n            break;\n        case OPT_INDEF:\n            flags |= CMS_STREAM;\n            break;\n        case OPT_NOINDEF:\n            flags &= ~CMS_STREAM;\n            break;\n        case OPT_CRLFEOL:\n            mime_eol = \"\\r\\n\";\n            flags |= CMS_CRLFEOL;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_RR_PRINT:\n            rr_print = 1;\n            break;\n        case OPT_RR_ALL:\n            rr_allorfirst = 0;\n            break;\n        case OPT_RR_FIRST:\n            rr_allorfirst = 1;\n            break;\n        case OPT_RCTFORM:\n            if (!opt_format(opt_arg(),\n                            OPT_FMT_PEMDER | OPT_FMT_SMIME, &rctformat))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_RR_FROM:\n            if (rr_from == NULL\n                && (rr_from = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_from, opt_arg());\n            break;\n        case OPT_RR_TO:\n            if (rr_to == NULL\n                && (rr_to = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_to, opt_arg());\n            break;\n        case OPT_PRINT:\n            noout = print = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SECRETKEY:\n            if (secret_key != NULL) {\n                BIO_printf(bio_err, \"Invalid key (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_key = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_key == NULL) {\n                BIO_printf(bio_err, \"Invalid key %s\\n\", opt_arg());\n                goto end;\n            }\n            secret_keylen = (size_t)ltmp;\n            break;\n        case OPT_SECRETKEYID:\n            if (secret_keyid != NULL) {\n                BIO_printf(bio_err, \"Invalid id (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_keyid = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_keyid == NULL) {\n                BIO_printf(bio_err, \"Invalid id %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            secret_keyidlen = (size_t)ltmp;\n            break;\n        case OPT_PWRI_PASSWORD:\n            pwri_pass = (unsigned char *)opt_arg();\n            break;\n        case OPT_ECONTENT_TYPE:\n            if (econtent_type != NULL) {\n                BIO_printf(bio_err, \"Invalid OID (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            econtent_type = OBJ_txt2obj(opt_arg(), 0);\n            if (econtent_type == NULL) {\n                BIO_printf(bio_err, \"Invalid OID %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_CERTSOUT:\n            certsoutfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_ORIGINATOR:\n            originatorfile = opt_arg();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n                    goto end;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_RECIP:\n            if (operation == SMIME_ENCRYPT) {\n                cert = load_cert(opt_arg(), FORMAT_UNDEF,\n                                 \"recipient certificate file\");\n                if (cert == NULL)\n                    goto end;\n                if (!sk_X509_push(encerts, cert))\n                    goto end;\n                cert = NULL;\n            } else {\n                recipfile = opt_arg();\n            }\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_KEYOPT:\n            keyidx = -1;\n            if (operation == SMIME_ENCRYPT) {\n                if (sk_X509_num(encerts) > 0)\n                    keyidx += sk_X509_num(encerts);\n            } else {\n                if (keyfile != NULL || signerfile != NULL)\n                    keyidx++;\n                if (skkeys != NULL)\n                    keyidx += sk_OPENSSL_STRING_num(skkeys);\n            }\n            if (keyidx < 0) {\n                BIO_printf(bio_err, \"No key specified\\n\");\n                goto opthelp;\n            }\n            if (key_param == NULL || key_param->idx != keyidx) {\n                cms_key_param *nparam;\n                nparam = app_malloc(sizeof(*nparam), \"key param buffer\");\n                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {\n                    OPENSSL_free(nparam);\n                    goto end;\n                }\n                nparam->idx = keyidx;\n                nparam->next = NULL;\n                if (key_first == NULL)\n                    key_first = nparam;\n                else\n                    key_param->next = nparam;\n                key_param = nparam;\n            }\n            sk_OPENSSL_STRING_push(key_param->param, opt_arg());\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_WRAP:\n            wrapname = opt_arg();\n            break;\n        case OPT_AES128_WRAP:\n        case OPT_AES192_WRAP:\n        case OPT_AES256_WRAP:\n        case OPT_3DES_WRAP:\n            wrapname = opt_flag() + 1;\n            break;\n        }\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto end;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n        goto end;\n    if (wrapname != NULL) {\n        if (!opt_cipher_any(wrapname, &wrap_cipher))\n            goto end;\n    }\n\n    /* Remaining args are files to process. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((rr_allorfirst != -1 || rr_from != NULL) && rr_to == NULL) {\n        BIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\n        goto opthelp;\n    }\n\n    if (!(operation & SMIME_SIGNERS) && (rr_to != NULL || rr_from != NULL)) {\n        BIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\n        goto opthelp;\n    }\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n\n    if ((flags & CMS_CADES) != 0) {\n        if ((flags & CMS_NOATTR) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: \"\n                     \"CAdES requires signed attributes\\n\");\n            goto opthelp;\n        }\n        if (operation == SMIME_VERIFY\n                && (flags & (CMS_NO_SIGNER_CERT_VERIFY | CMS_NO_ATTR_VERIFY)) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: CAdES validation requires\"\n                     \" certs and signed attributes validations\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        if (keyfile != NULL && signerfile == NULL) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        /* Check to see if any final signer needs to be appended */\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (skkeys == NULL && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (keyfile == NULL)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL\n            && secret_key == NULL && pwri_pass == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (*argv == NULL && secret_key == NULL\n            && pwri_pass == NULL && sk_X509_num(encerts) <= 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    } else if (!operation) {\n        BIO_printf(bio_err, \"No operation option (-encrypt|-decrypt|-sign|-verify|...) specified.\\n\");\n        goto opthelp;\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if ((operation & SMIME_SIGNERS) == 0) {\n        if ((flags & CMS_DETACHED) == 0)\n            BIO_printf(bio_err,\n                       \"Warning: -nodetach option is ignored for non-signing operation\\n\");\n\n        flags &= ~CMS_DETACHED;\n    }\n    if ((operation & SMIME_IP) == 0 && contfile != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: -contfile option is ignored for the given operation\\n\");\n    if (operation != SMIME_ENCRYPT && *argv != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: recipient certificate file parameters ignored for operation other than -encrypt\\n\");\n\n    if ((flags & CMS_BINARY) != 0) {\n        if (!(operation & SMIME_OP))\n            outformat = FORMAT_BINARY;\n        if (!(operation & SMIME_IP))\n            informat = FORMAT_BINARY;\n        if ((operation & SMIME_SIGNERS) != 0 && (flags & CMS_DETACHED) != 0)\n            binary_files = 1;\n        if ((operation & SMIME_IP) != 0 && contfile == NULL)\n            binary_files = 1;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (!cipher)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        if (secret_key && !secret_keyid) {\n            BIO_printf(bio_err, \"No secret key id\\n\");\n            goto end;\n        }\n\n        for (; *argv != NULL; argv++) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificate file\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (originatorfile != NULL) {\n        if ((originator = load_cert(originatorfile, FORMAT_UNDEF,\n                                    \"originator certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_SIGN_RECEIPT) {\n        if ((signer = load_cert(signerfile, FORMAT_UNDEF,\n                                \"receipt signer certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((operation == SMIME_DECRYPT) || (operation == SMIME_ENCRYPT)) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (digesthex != NULL) {\n        if (operation != SMIME_SIGN) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest for non-signing operation\\n\");\n            goto end;\n        }\n        if (infile != NULL\n            || (flags & CMS_DETACHED) == 0\n            || (flags & CMS_STREAM) != 0) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest when -in, -nodetach or streaming is used\\n\");\n            goto end;\n        }\n        digestbin = OPENSSL_hexstr2buf(digesthex, &digestlen);\n        if (digestbin == NULL) {\n            BIO_printf(bio_err,\n                       \"Invalid hex value after -digest\\n\");\n            goto end;\n        }\n    } else {\n        in = bio_open_default(infile, 'r',\n                              binary_files ? FORMAT_BINARY : informat);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (operation & SMIME_IP) {\n        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");\n        if (cms == NULL)\n            goto end;\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n        if (certsoutfile != NULL) {\n            STACK_OF(X509) *allcerts;\n            allcerts = CMS_get1_certs(cms);\n            if (!save_certs(certsoutfile, allcerts)) {\n                BIO_printf(bio_err,\n                           \"Error writing certs to %s\\n\", certsoutfile);\n                ret = 5;\n                goto end;\n            }\n            OSSL_STACK_OF_X509_free(allcerts);\n        }\n    }\n\n    if (rctfile != NULL) {\n        char *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\n\n        if ((rctin = BIO_new_file(rctfile, rctmode)) == NULL) {\n            BIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\n            goto end;\n        }\n\n        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");\n        if (rcms == NULL)\n            goto end;\n    }\n\n    out = bio_open_default(outfile, 'w',\n                           binary_files ? FORMAT_BINARY : outformat);\n    if (out == NULL)\n        goto end;\n\n    if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, cms_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_DATA_CREATE) {\n        cms = CMS_data_create_ex(in, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_DIGEST_CREATE) {\n        cms = CMS_digest_create_ex(in, sign_md, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_COMPRESS) {\n        cms = CMS_compress(in, -1, flags);\n    } else if (operation == SMIME_ENCRYPT) {\n        int i;\n        flags |= CMS_PARTIAL;\n        cms = CMS_encrypt_ex(NULL, in, cipher, flags, libctx, app_get0_propq());\n        if (cms == NULL)\n            goto end;\n        for (i = 0; i < sk_X509_num(encerts); i++) {\n            CMS_RecipientInfo *ri;\n            cms_key_param *kparam;\n            int tflags = flags | CMS_KEY_PARAM;\n            /* This flag enforces allocating the EVP_PKEY_CTX for the recipient here */\n            EVP_PKEY_CTX *pctx;\n            X509 *x = sk_X509_value(encerts, i);\n            int res;\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    break;\n                }\n            }\n            ri = CMS_add1_recipient(cms, x, key, originator, tflags);\n            if (ri == NULL)\n                goto end;\n\n            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n            if (kparam != NULL) {\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n\n            res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,\n                                    EVP_PKEY_CTRL_CIPHER,\n                                    EVP_CIPHER_get_nid(cipher), NULL);\n            if (res <= 0 && res != -2)\n                goto end;\n\n            if (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\n                    && wrap_cipher != NULL) {\n                EVP_CIPHER_CTX *wctx;\n                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n                if (EVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL) != 1)\n                    goto end;\n            }\n        }\n\n        if (secret_key != NULL) {\n            if (!CMS_add0_recipient_key(cms, NID_undef,\n                                        secret_key, secret_keylen,\n                                        secret_keyid, secret_keyidlen,\n                                        NULL, NULL, NULL))\n                goto end;\n            /* NULL these because call absorbs them */\n            secret_key = NULL;\n            secret_keyid = NULL;\n        }\n        if (pwri_pass != NULL) {\n            pwri_tmp = (unsigned char *)OPENSSL_strdup((char *)pwri_pass);\n            if (pwri_tmp == NULL)\n                goto end;\n            if (CMS_add0_recipient_password(cms,\n                                            -1, NID_undef, NID_undef,\n                                            pwri_tmp, -1, NULL) == NULL)\n                goto end;\n            pwri_tmp = NULL;\n        }\n        if (!(flags & CMS_STREAM)) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\n        cms = CMS_EncryptedData_encrypt_ex(in, cipher, secret_key,\n                                           secret_keylen, flags, libctx, app_get0_propq());\n\n    } else if (operation == SMIME_SIGN_RECEIPT) {\n        CMS_ContentInfo *srcms = NULL;\n        STACK_OF(CMS_SignerInfo) *sis;\n        CMS_SignerInfo *si;\n        sis = CMS_get0_SignerInfos(cms);\n        if (sis == NULL)\n            goto end;\n        si = sk_CMS_SignerInfo_value(sis, 0);\n        srcms = CMS_sign_receipt(si, signer, key, other, flags);\n        if (srcms == NULL)\n            goto end;\n        CMS_ContentInfo_free(cms);\n        cms = srcms;\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content and not signing pre-computed digest, we\n         * enable streaming if S/MIME output format.\n         */\n        if (operation == SMIME_SIGN) {\n\n            if ((flags & CMS_DETACHED) != 0 && digestbin == NULL) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= CMS_STREAM;\n            }\n            flags |= CMS_PARTIAL;\n            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (cms == NULL)\n                goto end;\n            if (econtent_type != NULL)\n                CMS_set1_eContentType(cms, econtent_type);\n\n            if (rr_to != NULL\n                && ((rr = make_receipt_request(rr_to, rr_allorfirst, rr_from))\n                    == NULL)) {\n                BIO_puts(bio_err, \"Signed Receipt Request Creation Error\\n\");\n                goto end;\n            }\n        } else {\n            flags |= CMS_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            CMS_SignerInfo *si;\n            cms_key_param *kparam;\n            int tflags = flags;\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL) {\n                ret = 2;\n                goto end;\n            }\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL) {\n                ret = 2;\n                goto end;\n            }\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    tflags |= CMS_KEY_PARAM;\n                    break;\n                }\n            }\n            si = CMS_add1_signer(cms, signer, key, sign_md, tflags);\n            if (si == NULL)\n                goto end;\n            if (kparam != NULL) {\n                EVP_PKEY_CTX *pctx;\n                pctx = CMS_SignerInfo_get0_pkey_ctx(si);\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n            if (rr != NULL && !CMS_add1_ReceiptRequest(si, rr))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if (operation == SMIME_SIGN && digestbin != NULL\n            && (flags & CMS_STREAM) == 0) {\n            /* Use pre-computed digest instead of content */\n            if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))\n                goto end;\n        } else if (operation == SMIME_SIGN && (flags & CMS_STREAM) == 0) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    }\n\n    if (cms == NULL) {\n        BIO_printf(bio_err, \"Error creating CMS structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (flags & CMS_DEBUG_DECRYPT)\n            CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\n\n        if (secret_key != NULL) {\n            if (!CMS_decrypt_set1_key(cms,\n                                      secret_key, secret_keylen,\n                                      secret_keyid, secret_keyidlen)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\n                goto end;\n            }\n        }\n\n        if (key != NULL) {\n            if (!CMS_decrypt_set1_pkey_and_peer(cms, key, recip, originator)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\n                goto end;\n            }\n        }\n\n        if (pwri_pass != NULL) {\n            if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\n                goto end;\n            }\n        }\n\n        if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_DATA_OUT) {\n        if (!CMS_data(cms, out, flags))\n            goto end;\n    } else if (operation == SMIME_UNCOMPRESS) {\n        if (!CMS_uncompress(cms, indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_DIGEST_VERIFY) {\n        if (CMS_digest_verify(cms, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_DECRYPT) {\n        if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\n                                       indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_VERIFY) {\n        if (CMS_verify(cms, other, store, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"%s Verification successful\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n        } else {\n            BIO_printf(bio_err, \"%s Verification failure\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n            if (verify_retcode)\n                ret = verify_err + 32;\n            goto end;\n        }\n        if (signerfile != NULL) {\n            STACK_OF(X509) *signers = CMS_get0_signers(cms);\n\n            if (!save_certs(signerfile, signers)) {\n                BIO_printf(bio_err,\n                           \"Error writing signers to %s\\n\", signerfile);\n                ret = 5;\n                goto end;\n            }\n            sk_X509_free(signers);\n        }\n        if (rr_print)\n            receipt_request_print(cms);\n\n    } else if (operation == SMIME_VERIFY_RECEIPT) {\n        if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else {\n        if (noout) {\n            if (print) {\n                ASN1_PCTX *pctx = NULL;\n                if (get_nameopt() != XN_FLAG_ONELINE) {\n                    pctx = ASN1_PCTX_new();\n                    if (pctx != NULL) { /* Print anyway if malloc failed */\n                        ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT);\n                        ASN1_PCTX_set_str_flags(pctx, get_nameopt());\n                        ASN1_PCTX_set_nm_flags(pctx, get_nameopt());\n                    }\n                }\n                CMS_ContentInfo_print_ctx(out, cms, 0, pctx);\n                ASN1_PCTX_free(pctx);\n            }\n        } else if (outformat == FORMAT_SMIME) {\n            if (to)\n                BIO_printf(out, \"To: %s%s\", to, mime_eol);\n            if (from)\n                BIO_printf(out, \"From: %s%s\", from, mime_eol);\n            if (subject)\n                BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n            if (operation == SMIME_RESIGN)\n                ret = SMIME_write_CMS(out, cms, indata, flags);\n            else\n                ret = SMIME_write_CMS(out, cms, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            ret = PEM_write_bio_CMS_stream(out, cms, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            ret = i2d_CMS_bio_stream(out, cms, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for CMS file\\n\");\n            goto end;\n        }\n        if (ret <= 0) {\n            ret = 6;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    OPENSSL_free(secret_key);\n    OPENSSL_free(secret_keyid);\n    OPENSSL_free(pwri_tmp);\n    ASN1_OBJECT_free(econtent_type);\n    CMS_ReceiptRequest_free(rr);\n    sk_OPENSSL_STRING_free(rr_to);\n    sk_OPENSSL_STRING_free(rr_from);\n    for (key_param = key_first; key_param;) {\n        cms_key_param *tparam;\n        sk_OPENSSL_STRING_free(key_param->param);\n        tparam = key_param->next;\n        OPENSSL_free(key_param);\n        key_param = tparam;\n    }\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_CIPHER_free(cipher);\n    EVP_CIPHER_free(wrap_cipher);\n    EVP_MD_free(sign_md);\n    CMS_ContentInfo_free(cms);\n    CMS_ContentInfo_free(rcms);\n    release_engine(e);\n    BIO_free(rctin);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(digestbin);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "key_param->next = nparam;",
        "final_sink": "key_param->next = nparam;",
        "source": [
            "        str = X509_NAME_ENTRY_get_data(ne);"
        ],
        "index": 6
    },
    {
        "prt": "pctx",
        "function_call": [
            "int cms_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ASN1_OBJECT *econtent_type = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\n    CMS_ContentInfo *cms = NULL, *rcms = NULL;\n    CMS_ReceiptRequest *rr = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *key = NULL;\n    EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = sk_X509_new_null(), *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL, *originator = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = X509_VERIFY_PARAM_new();\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *certsoutfile = NULL, *digestname = NULL, *wrapname = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    char *digesthex = NULL;\n    unsigned char *digestbin = NULL;\n    long digestlen = 0;\n    char *infile = NULL, *outfile = NULL, *rctfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *signerfile = NULL;\n    char *originatorfile = NULL, *recipfile = NULL, *ciphername = NULL;\n    char *to = NULL, *from = NULL, *subject = NULL, *prog;\n    cms_key_param *key_first = NULL, *key_param = NULL;\n    int flags = CMS_DETACHED, binary_files = 0;\n    int noout = 0, print = 0, keyidx = -1, vpmtouched = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\n    int operation = 0, ret = 1, rr_print = 0, rr_allorfirst = -1;\n    int verify_retcode = 0, rctformat = FORMAT_SMIME, keyform = FORMAT_UNDEF;\n    size_t secret_keylen = 0, secret_keyidlen = 0;\n    unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\n    unsigned char *secret_key = NULL, *secret_keyid = NULL;\n    long ltmp;\n    const char *mime_eol = \"\\n\";\n    OPTION_CHOICE o;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if (encerts == NULL || vpm == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, cms_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(cms_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n\n        case OPT_ENCRYPT:\n            operation = SMIME_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            operation = SMIME_DECRYPT;\n            break;\n        case OPT_SIGN:\n            operation = SMIME_SIGN;\n            break;\n        case OPT_VERIFY:\n            operation = SMIME_VERIFY;\n            break;\n        case OPT_RESIGN:\n            operation = SMIME_RESIGN;\n            break;\n        case OPT_SIGN_RECEIPT:\n            operation = SMIME_SIGN_RECEIPT;\n            break;\n        case OPT_VERIFY_RECEIPT:\n            operation = SMIME_VERIFY_RECEIPT;\n            rctfile = opt_arg();\n            break;\n        case OPT_VERIFY_RETCODE:\n            verify_retcode = 1;\n            break;\n        case OPT_DIGEST_CREATE:\n            operation = SMIME_DIGEST_CREATE;\n            break;\n        case OPT_DIGEST:\n            digesthex = opt_arg();\n            break;\n        case OPT_DIGEST_VERIFY:\n            operation = SMIME_DIGEST_VERIFY;\n            break;\n        case OPT_COMPRESS:\n            operation = SMIME_COMPRESS;\n            break;\n        case OPT_UNCOMPRESS:\n            operation = SMIME_UNCOMPRESS;\n            break;\n        case OPT_ED_ENCRYPT:\n            operation = SMIME_ENCRYPTED_ENCRYPT;\n            break;\n        case OPT_ED_DECRYPT:\n            operation = SMIME_ENCRYPTED_DECRYPT;\n            break;\n        case OPT_DATA_CREATE:\n            operation = SMIME_DATA_CREATE;\n            break;\n        case OPT_DATA_OUT:\n            operation = SMIME_DATA_OUT;\n            break;\n        case OPT_CMSOUT:\n            operation = SMIME_CMSOUT;\n            break;\n\n        case OPT_DEBUG_DECRYPT:\n            flags |= CMS_DEBUG_DECRYPT;\n            break;\n        case OPT_TEXT:\n            flags |= CMS_TEXT;\n            break;\n        case OPT_ASCIICRLF:\n            flags |= CMS_ASCIICRLF;\n            break;\n        case OPT_NOINTERN:\n            flags |= CMS_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= CMS_NO_SIGNER_CERT_VERIFY;\n            break;\n        case OPT_NOCERTS:\n            flags |= CMS_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= CMS_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~CMS_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= CMS_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= CMS_BINARY;\n            break;\n        case OPT_CADES:\n            flags |= CMS_CADES;\n            break;\n        case OPT_KEYID:\n            flags |= CMS_USE_KEYID;\n            break;\n        case OPT_NOSIGS:\n            flags |= CMS_NOSIGS;\n            break;\n        case OPT_NO_CONTENT_VERIFY:\n            flags |= CMS_NO_CONTENT_VERIFY;\n            break;\n        case OPT_NO_ATTR_VERIFY:\n            flags |= CMS_NO_ATTR_VERIFY;\n            break;\n        case OPT_INDEF:\n            flags |= CMS_STREAM;\n            break;\n        case OPT_NOINDEF:\n            flags &= ~CMS_STREAM;\n            break;\n        case OPT_CRLFEOL:\n            mime_eol = \"\\r\\n\";\n            flags |= CMS_CRLFEOL;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_RR_PRINT:\n            rr_print = 1;\n            break;\n        case OPT_RR_ALL:\n            rr_allorfirst = 0;\n            break;\n        case OPT_RR_FIRST:\n            rr_allorfirst = 1;\n            break;\n        case OPT_RCTFORM:\n            if (!opt_format(opt_arg(),\n                            OPT_FMT_PEMDER | OPT_FMT_SMIME, &rctformat))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_RR_FROM:\n            if (rr_from == NULL\n                && (rr_from = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_from, opt_arg());\n            break;\n        case OPT_RR_TO:\n            if (rr_to == NULL\n                && (rr_to = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_to, opt_arg());\n            break;\n        case OPT_PRINT:\n            noout = print = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SECRETKEY:\n            if (secret_key != NULL) {\n                BIO_printf(bio_err, \"Invalid key (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_key = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_key == NULL) {\n                BIO_printf(bio_err, \"Invalid key %s\\n\", opt_arg());\n                goto end;\n            }\n            secret_keylen = (size_t)ltmp;\n            break;\n        case OPT_SECRETKEYID:\n            if (secret_keyid != NULL) {\n                BIO_printf(bio_err, \"Invalid id (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_keyid = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_keyid == NULL) {\n                BIO_printf(bio_err, \"Invalid id %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            secret_keyidlen = (size_t)ltmp;\n            break;\n        case OPT_PWRI_PASSWORD:\n            pwri_pass = (unsigned char *)opt_arg();\n            break;\n        case OPT_ECONTENT_TYPE:\n            if (econtent_type != NULL) {\n                BIO_printf(bio_err, \"Invalid OID (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            econtent_type = OBJ_txt2obj(opt_arg(), 0);\n            if (econtent_type == NULL) {\n                BIO_printf(bio_err, \"Invalid OID %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_CERTSOUT:\n            certsoutfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_ORIGINATOR:\n            originatorfile = opt_arg();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n                    goto end;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_RECIP:\n            if (operation == SMIME_ENCRYPT) {\n                cert = load_cert(opt_arg(), FORMAT_UNDEF,\n                                 \"recipient certificate file\");\n                if (cert == NULL)\n                    goto end;\n                if (!sk_X509_push(encerts, cert))\n                    goto end;\n                cert = NULL;\n            } else {\n                recipfile = opt_arg();\n            }\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_KEYOPT:\n            keyidx = -1;\n            if (operation == SMIME_ENCRYPT) {\n                if (sk_X509_num(encerts) > 0)\n                    keyidx += sk_X509_num(encerts);\n            } else {\n                if (keyfile != NULL || signerfile != NULL)\n                    keyidx++;\n                if (skkeys != NULL)\n                    keyidx += sk_OPENSSL_STRING_num(skkeys);\n            }\n            if (keyidx < 0) {\n                BIO_printf(bio_err, \"No key specified\\n\");\n                goto opthelp;\n            }\n            if (key_param == NULL || key_param->idx != keyidx) {\n                cms_key_param *nparam;\n                nparam = app_malloc(sizeof(*nparam), \"key param buffer\");\n                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {\n                    OPENSSL_free(nparam);\n                    goto end;\n                }\n                nparam->idx = keyidx;\n                nparam->next = NULL;\n                if (key_first == NULL)\n                    key_first = nparam;\n                else\n                    key_param->next = nparam;\n                key_param = nparam;\n            }\n            sk_OPENSSL_STRING_push(key_param->param, opt_arg());\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_WRAP:\n            wrapname = opt_arg();\n            break;\n        case OPT_AES128_WRAP:\n        case OPT_AES192_WRAP:\n        case OPT_AES256_WRAP:\n        case OPT_3DES_WRAP:\n            wrapname = opt_flag() + 1;\n            break;\n        }\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto end;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n        goto end;\n    if (wrapname != NULL) {\n        if (!opt_cipher_any(wrapname, &wrap_cipher))\n            goto end;\n    }\n\n    /* Remaining args are files to process. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((rr_allorfirst != -1 || rr_from != NULL) && rr_to == NULL) {\n        BIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\n        goto opthelp;\n    }\n\n    if (!(operation & SMIME_SIGNERS) && (rr_to != NULL || rr_from != NULL)) {\n        BIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\n        goto opthelp;\n    }\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n\n    if ((flags & CMS_CADES) != 0) {\n        if ((flags & CMS_NOATTR) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: \"\n                     \"CAdES requires signed attributes\\n\");\n            goto opthelp;\n        }\n        if (operation == SMIME_VERIFY\n                && (flags & (CMS_NO_SIGNER_CERT_VERIFY | CMS_NO_ATTR_VERIFY)) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: CAdES validation requires\"\n                     \" certs and signed attributes validations\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        if (keyfile != NULL && signerfile == NULL) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        /* Check to see if any final signer needs to be appended */\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (skkeys == NULL && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (keyfile == NULL)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL\n            && secret_key == NULL && pwri_pass == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (*argv == NULL && secret_key == NULL\n            && pwri_pass == NULL && sk_X509_num(encerts) <= 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    } else if (!operation) {\n        BIO_printf(bio_err, \"No operation option (-encrypt|-decrypt|-sign|-verify|...) specified.\\n\");\n        goto opthelp;\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if ((operation & SMIME_SIGNERS) == 0) {\n        if ((flags & CMS_DETACHED) == 0)\n            BIO_printf(bio_err,\n                       \"Warning: -nodetach option is ignored for non-signing operation\\n\");\n\n        flags &= ~CMS_DETACHED;\n    }\n    if ((operation & SMIME_IP) == 0 && contfile != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: -contfile option is ignored for the given operation\\n\");\n    if (operation != SMIME_ENCRYPT && *argv != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: recipient certificate file parameters ignored for operation other than -encrypt\\n\");\n\n    if ((flags & CMS_BINARY) != 0) {\n        if (!(operation & SMIME_OP))\n            outformat = FORMAT_BINARY;\n        if (!(operation & SMIME_IP))\n            informat = FORMAT_BINARY;\n        if ((operation & SMIME_SIGNERS) != 0 && (flags & CMS_DETACHED) != 0)\n            binary_files = 1;\n        if ((operation & SMIME_IP) != 0 && contfile == NULL)\n            binary_files = 1;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (!cipher)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        if (secret_key && !secret_keyid) {\n            BIO_printf(bio_err, \"No secret key id\\n\");\n            goto end;\n        }\n\n        for (; *argv != NULL; argv++) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificate file\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (originatorfile != NULL) {\n        if ((originator = load_cert(originatorfile, FORMAT_UNDEF,\n                                    \"originator certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_SIGN_RECEIPT) {\n        if ((signer = load_cert(signerfile, FORMAT_UNDEF,\n                                \"receipt signer certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((operation == SMIME_DECRYPT) || (operation == SMIME_ENCRYPT)) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (digesthex != NULL) {\n        if (operation != SMIME_SIGN) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest for non-signing operation\\n\");\n            goto end;\n        }\n        if (infile != NULL\n            || (flags & CMS_DETACHED) == 0\n            || (flags & CMS_STREAM) != 0) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest when -in, -nodetach or streaming is used\\n\");\n            goto end;\n        }\n        digestbin = OPENSSL_hexstr2buf(digesthex, &digestlen);\n        if (digestbin == NULL) {\n            BIO_printf(bio_err,\n                       \"Invalid hex value after -digest\\n\");\n            goto end;\n        }\n    } else {\n        in = bio_open_default(infile, 'r',\n                              binary_files ? FORMAT_BINARY : informat);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (operation & SMIME_IP) {\n        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");\n        if (cms == NULL)\n            goto end;\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n        if (certsoutfile != NULL) {\n            STACK_OF(X509) *allcerts;\n            allcerts = CMS_get1_certs(cms);\n            if (!save_certs(certsoutfile, allcerts)) {\n                BIO_printf(bio_err,\n                           \"Error writing certs to %s\\n\", certsoutfile);\n                ret = 5;\n                goto end;\n            }\n            OSSL_STACK_OF_X509_free(allcerts);\n        }\n    }\n\n    if (rctfile != NULL) {\n        char *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\n\n        if ((rctin = BIO_new_file(rctfile, rctmode)) == NULL) {\n            BIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\n            goto end;\n        }\n\n        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");\n        if (rcms == NULL)\n            goto end;\n    }\n\n    out = bio_open_default(outfile, 'w',\n                           binary_files ? FORMAT_BINARY : outformat);\n    if (out == NULL)\n        goto end;\n\n    if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, cms_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_DATA_CREATE) {\n        cms = CMS_data_create_ex(in, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_DIGEST_CREATE) {\n        cms = CMS_digest_create_ex(in, sign_md, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_COMPRESS) {\n        cms = CMS_compress(in, -1, flags);\n    } else if (operation == SMIME_ENCRYPT) {\n        int i;\n        flags |= CMS_PARTIAL;\n        cms = CMS_encrypt_ex(NULL, in, cipher, flags, libctx, app_get0_propq());\n        if (cms == NULL)\n            goto end;\n        for (i = 0; i < sk_X509_num(encerts); i++) {\n            CMS_RecipientInfo *ri;\n            cms_key_param *kparam;\n            int tflags = flags | CMS_KEY_PARAM;\n            /* This flag enforces allocating the EVP_PKEY_CTX for the recipient here */\n            EVP_PKEY_CTX *pctx;\n            X509 *x = sk_X509_value(encerts, i);\n            int res;\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    break;\n                }\n            }\n            ri = CMS_add1_recipient(cms, x, key, originator, tflags);\n            if (ri == NULL)\n                goto end;\n\n            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n            if (kparam != NULL) {\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n\n            res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,\n                                    EVP_PKEY_CTRL_CIPHER,\n                                    EVP_CIPHER_get_nid(cipher), NULL);\n            if (res <= 0 && res != -2)\n                goto end;\n\n            if (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\n                    && wrap_cipher != NULL) {\n                EVP_CIPHER_CTX *wctx;\n                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n                if (EVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL) != 1)\n                    goto end;\n            }\n        }\n\n        if (secret_key != NULL) {\n            if (!CMS_add0_recipient_key(cms, NID_undef,\n                                        secret_key, secret_keylen,\n                                        secret_keyid, secret_keyidlen,\n                                        NULL, NULL, NULL))\n                goto end;\n            /* NULL these because call absorbs them */\n            secret_key = NULL;\n            secret_keyid = NULL;\n        }\n        if (pwri_pass != NULL) {\n            pwri_tmp = (unsigned char *)OPENSSL_strdup((char *)pwri_pass);\n            if (pwri_tmp == NULL)\n                goto end;\n            if (CMS_add0_recipient_password(cms,\n                                            -1, NID_undef, NID_undef,\n                                            pwri_tmp, -1, NULL) == NULL)\n                goto end;\n            pwri_tmp = NULL;\n        }\n        if (!(flags & CMS_STREAM)) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\n        cms = CMS_EncryptedData_encrypt_ex(in, cipher, secret_key,\n                                           secret_keylen, flags, libctx, app_get0_propq());\n\n    } else if (operation == SMIME_SIGN_RECEIPT) {\n        CMS_ContentInfo *srcms = NULL;\n        STACK_OF(CMS_SignerInfo) *sis;\n        CMS_SignerInfo *si;\n        sis = CMS_get0_SignerInfos(cms);\n        if (sis == NULL)\n            goto end;\n        si = sk_CMS_SignerInfo_value(sis, 0);\n        srcms = CMS_sign_receipt(si, signer, key, other, flags);\n        if (srcms == NULL)\n            goto end;\n        CMS_ContentInfo_free(cms);\n        cms = srcms;\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content and not signing pre-computed digest, we\n         * enable streaming if S/MIME output format.\n         */\n        if (operation == SMIME_SIGN) {\n\n            if ((flags & CMS_DETACHED) != 0 && digestbin == NULL) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= CMS_STREAM;\n            }\n            flags |= CMS_PARTIAL;\n            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (cms == NULL)\n                goto end;\n            if (econtent_type != NULL)\n                CMS_set1_eContentType(cms, econtent_type);\n\n            if (rr_to != NULL\n                && ((rr = make_receipt_request(rr_to, rr_allorfirst, rr_from))\n                    == NULL)) {\n                BIO_puts(bio_err, \"Signed Receipt Request Creation Error\\n\");\n                goto end;\n            }\n        } else {\n            flags |= CMS_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            CMS_SignerInfo *si;\n            cms_key_param *kparam;\n            int tflags = flags;\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL) {\n                ret = 2;\n                goto end;\n            }\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL) {\n                ret = 2;\n                goto end;\n            }\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    tflags |= CMS_KEY_PARAM;\n                    break;\n                }\n            }\n            si = CMS_add1_signer(cms, signer, key, sign_md, tflags);\n            if (si == NULL)\n                goto end;\n            if (kparam != NULL) {\n                EVP_PKEY_CTX *pctx;\n                pctx = CMS_SignerInfo_get0_pkey_ctx(si);\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n            if (rr != NULL && !CMS_add1_ReceiptRequest(si, rr))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if (operation == SMIME_SIGN && digestbin != NULL\n            && (flags & CMS_STREAM) == 0) {\n            /* Use pre-computed digest instead of content */\n            if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))\n                goto end;\n        } else if (operation == SMIME_SIGN && (flags & CMS_STREAM) == 0) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    }\n\n    if (cms == NULL) {\n        BIO_printf(bio_err, \"Error creating CMS structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (flags & CMS_DEBUG_DECRYPT)\n            CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\n\n        if (secret_key != NULL) {\n            if (!CMS_decrypt_set1_key(cms,\n                                      secret_key, secret_keylen,\n                                      secret_keyid, secret_keyidlen)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\n                goto end;\n            }\n        }\n\n        if (key != NULL) {\n            if (!CMS_decrypt_set1_pkey_and_peer(cms, key, recip, originator)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\n                goto end;\n            }\n        }\n\n        if (pwri_pass != NULL) {\n            if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\n                goto end;\n            }\n        }\n\n        if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_DATA_OUT) {\n        if (!CMS_data(cms, out, flags))\n            goto end;\n    } else if (operation == SMIME_UNCOMPRESS) {\n        if (!CMS_uncompress(cms, indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_DIGEST_VERIFY) {\n        if (CMS_digest_verify(cms, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_DECRYPT) {\n        if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\n                                       indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_VERIFY) {\n        if (CMS_verify(cms, other, store, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"%s Verification successful\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n        } else {\n            BIO_printf(bio_err, \"%s Verification failure\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n            if (verify_retcode)\n                ret = verify_err + 32;\n            goto end;\n        }\n        if (signerfile != NULL) {\n            STACK_OF(X509) *signers = CMS_get0_signers(cms);\n\n            if (!save_certs(signerfile, signers)) {\n                BIO_printf(bio_err,\n                           \"Error writing signers to %s\\n\", signerfile);\n                ret = 5;\n                goto end;\n            }\n            sk_X509_free(signers);\n        }\n        if (rr_print)\n            receipt_request_print(cms);\n\n    } else if (operation == SMIME_VERIFY_RECEIPT) {\n        if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else {\n        if (noout) {\n            if (print) {\n                ASN1_PCTX *pctx = NULL;\n                if (get_nameopt() != XN_FLAG_ONELINE) {\n                    pctx = ASN1_PCTX_new();\n                    if (pctx != NULL) { /* Print anyway if malloc failed */\n                        ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT);\n                        ASN1_PCTX_set_str_flags(pctx, get_nameopt());\n                        ASN1_PCTX_set_nm_flags(pctx, get_nameopt());\n                    }\n                }\n                CMS_ContentInfo_print_ctx(out, cms, 0, pctx);\n                ASN1_PCTX_free(pctx);\n            }\n        } else if (outformat == FORMAT_SMIME) {\n            if (to)\n                BIO_printf(out, \"To: %s%s\", to, mime_eol);\n            if (from)\n                BIO_printf(out, \"From: %s%s\", from, mime_eol);\n            if (subject)\n                BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n            if (operation == SMIME_RESIGN)\n                ret = SMIME_write_CMS(out, cms, indata, flags);\n            else\n                ret = SMIME_write_CMS(out, cms, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            ret = PEM_write_bio_CMS_stream(out, cms, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            ret = i2d_CMS_bio_stream(out, cms, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for CMS file\\n\");\n            goto end;\n        }\n        if (ret <= 0) {\n            ret = 6;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    OPENSSL_free(secret_key);\n    OPENSSL_free(secret_keyid);\n    OPENSSL_free(pwri_tmp);\n    ASN1_OBJECT_free(econtent_type);\n    CMS_ReceiptRequest_free(rr);\n    sk_OPENSSL_STRING_free(rr_to);\n    sk_OPENSSL_STRING_free(rr_from);\n    for (key_param = key_first; key_param;) {\n        cms_key_param *tparam;\n        sk_OPENSSL_STRING_free(key_param->param);\n        tparam = key_param->next;\n        OPENSSL_free(key_param);\n        key_param = tparam;\n    }\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_CIPHER_free(cipher);\n    EVP_CIPHER_free(wrap_cipher);\n    EVP_MD_free(sign_md);\n    CMS_ContentInfo_free(cms);\n    CMS_ContentInfo_free(rcms);\n    release_engine(e);\n    BIO_free(rctin);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(digestbin);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "if (!cms_set_pkey_param(pctx, kparam->param))",
        "final_sink": "if (!cms_set_pkey_param(pctx, kparam->param))",
        "source": [
            "        str = X509_NAME_ENTRY_get_data(ne);"
        ],
        "index": 7
    },
    {
        "prt": "cms",
        "function_call": [
            "int cms_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ASN1_OBJECT *econtent_type = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\n    CMS_ContentInfo *cms = NULL, *rcms = NULL;\n    CMS_ReceiptRequest *rr = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *key = NULL;\n    EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = sk_X509_new_null(), *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL, *originator = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = X509_VERIFY_PARAM_new();\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *certsoutfile = NULL, *digestname = NULL, *wrapname = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    char *digesthex = NULL;\n    unsigned char *digestbin = NULL;\n    long digestlen = 0;\n    char *infile = NULL, *outfile = NULL, *rctfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *signerfile = NULL;\n    char *originatorfile = NULL, *recipfile = NULL, *ciphername = NULL;\n    char *to = NULL, *from = NULL, *subject = NULL, *prog;\n    cms_key_param *key_first = NULL, *key_param = NULL;\n    int flags = CMS_DETACHED, binary_files = 0;\n    int noout = 0, print = 0, keyidx = -1, vpmtouched = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\n    int operation = 0, ret = 1, rr_print = 0, rr_allorfirst = -1;\n    int verify_retcode = 0, rctformat = FORMAT_SMIME, keyform = FORMAT_UNDEF;\n    size_t secret_keylen = 0, secret_keyidlen = 0;\n    unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\n    unsigned char *secret_key = NULL, *secret_keyid = NULL;\n    long ltmp;\n    const char *mime_eol = \"\\n\";\n    OPTION_CHOICE o;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if (encerts == NULL || vpm == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, cms_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(cms_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n\n        case OPT_ENCRYPT:\n            operation = SMIME_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            operation = SMIME_DECRYPT;\n            break;\n        case OPT_SIGN:\n            operation = SMIME_SIGN;\n            break;\n        case OPT_VERIFY:\n            operation = SMIME_VERIFY;\n            break;\n        case OPT_RESIGN:\n            operation = SMIME_RESIGN;\n            break;\n        case OPT_SIGN_RECEIPT:\n            operation = SMIME_SIGN_RECEIPT;\n            break;\n        case OPT_VERIFY_RECEIPT:\n            operation = SMIME_VERIFY_RECEIPT;\n            rctfile = opt_arg();\n            break;\n        case OPT_VERIFY_RETCODE:\n            verify_retcode = 1;\n            break;\n        case OPT_DIGEST_CREATE:\n            operation = SMIME_DIGEST_CREATE;\n            break;\n        case OPT_DIGEST:\n            digesthex = opt_arg();\n            break;\n        case OPT_DIGEST_VERIFY:\n            operation = SMIME_DIGEST_VERIFY;\n            break;\n        case OPT_COMPRESS:\n            operation = SMIME_COMPRESS;\n            break;\n        case OPT_UNCOMPRESS:\n            operation = SMIME_UNCOMPRESS;\n            break;\n        case OPT_ED_ENCRYPT:\n            operation = SMIME_ENCRYPTED_ENCRYPT;\n            break;\n        case OPT_ED_DECRYPT:\n            operation = SMIME_ENCRYPTED_DECRYPT;\n            break;\n        case OPT_DATA_CREATE:\n            operation = SMIME_DATA_CREATE;\n            break;\n        case OPT_DATA_OUT:\n            operation = SMIME_DATA_OUT;\n            break;\n        case OPT_CMSOUT:\n            operation = SMIME_CMSOUT;\n            break;\n\n        case OPT_DEBUG_DECRYPT:\n            flags |= CMS_DEBUG_DECRYPT;\n            break;\n        case OPT_TEXT:\n            flags |= CMS_TEXT;\n            break;\n        case OPT_ASCIICRLF:\n            flags |= CMS_ASCIICRLF;\n            break;\n        case OPT_NOINTERN:\n            flags |= CMS_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= CMS_NO_SIGNER_CERT_VERIFY;\n            break;\n        case OPT_NOCERTS:\n            flags |= CMS_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= CMS_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~CMS_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= CMS_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= CMS_BINARY;\n            break;\n        case OPT_CADES:\n            flags |= CMS_CADES;\n            break;\n        case OPT_KEYID:\n            flags |= CMS_USE_KEYID;\n            break;\n        case OPT_NOSIGS:\n            flags |= CMS_NOSIGS;\n            break;\n        case OPT_NO_CONTENT_VERIFY:\n            flags |= CMS_NO_CONTENT_VERIFY;\n            break;\n        case OPT_NO_ATTR_VERIFY:\n            flags |= CMS_NO_ATTR_VERIFY;\n            break;\n        case OPT_INDEF:\n            flags |= CMS_STREAM;\n            break;\n        case OPT_NOINDEF:\n            flags &= ~CMS_STREAM;\n            break;\n        case OPT_CRLFEOL:\n            mime_eol = \"\\r\\n\";\n            flags |= CMS_CRLFEOL;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_RR_PRINT:\n            rr_print = 1;\n            break;\n        case OPT_RR_ALL:\n            rr_allorfirst = 0;\n            break;\n        case OPT_RR_FIRST:\n            rr_allorfirst = 1;\n            break;\n        case OPT_RCTFORM:\n            if (!opt_format(opt_arg(),\n                            OPT_FMT_PEMDER | OPT_FMT_SMIME, &rctformat))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_RR_FROM:\n            if (rr_from == NULL\n                && (rr_from = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_from, opt_arg());\n            break;\n        case OPT_RR_TO:\n            if (rr_to == NULL\n                && (rr_to = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_to, opt_arg());\n            break;\n        case OPT_PRINT:\n            noout = print = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SECRETKEY:\n            if (secret_key != NULL) {\n                BIO_printf(bio_err, \"Invalid key (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_key = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_key == NULL) {\n                BIO_printf(bio_err, \"Invalid key %s\\n\", opt_arg());\n                goto end;\n            }\n            secret_keylen = (size_t)ltmp;\n            break;\n        case OPT_SECRETKEYID:\n            if (secret_keyid != NULL) {\n                BIO_printf(bio_err, \"Invalid id (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_keyid = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_keyid == NULL) {\n                BIO_printf(bio_err, \"Invalid id %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            secret_keyidlen = (size_t)ltmp;\n            break;\n        case OPT_PWRI_PASSWORD:\n            pwri_pass = (unsigned char *)opt_arg();\n            break;\n        case OPT_ECONTENT_TYPE:\n            if (econtent_type != NULL) {\n                BIO_printf(bio_err, \"Invalid OID (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            econtent_type = OBJ_txt2obj(opt_arg(), 0);\n            if (econtent_type == NULL) {\n                BIO_printf(bio_err, \"Invalid OID %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_CERTSOUT:\n            certsoutfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_ORIGINATOR:\n            originatorfile = opt_arg();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n                    goto end;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_RECIP:\n            if (operation == SMIME_ENCRYPT) {\n                cert = load_cert(opt_arg(), FORMAT_UNDEF,\n                                 \"recipient certificate file\");\n                if (cert == NULL)\n                    goto end;\n                if (!sk_X509_push(encerts, cert))\n                    goto end;\n                cert = NULL;\n            } else {\n                recipfile = opt_arg();\n            }\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_KEYOPT:\n            keyidx = -1;\n            if (operation == SMIME_ENCRYPT) {\n                if (sk_X509_num(encerts) > 0)\n                    keyidx += sk_X509_num(encerts);\n            } else {\n                if (keyfile != NULL || signerfile != NULL)\n                    keyidx++;\n                if (skkeys != NULL)\n                    keyidx += sk_OPENSSL_STRING_num(skkeys);\n            }\n            if (keyidx < 0) {\n                BIO_printf(bio_err, \"No key specified\\n\");\n                goto opthelp;\n            }\n            if (key_param == NULL || key_param->idx != keyidx) {\n                cms_key_param *nparam;\n                nparam = app_malloc(sizeof(*nparam), \"key param buffer\");\n                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {\n                    OPENSSL_free(nparam);\n                    goto end;\n                }\n                nparam->idx = keyidx;\n                nparam->next = NULL;\n                if (key_first == NULL)\n                    key_first = nparam;\n                else\n                    key_param->next = nparam;\n                key_param = nparam;\n            }\n            sk_OPENSSL_STRING_push(key_param->param, opt_arg());\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_WRAP:\n            wrapname = opt_arg();\n            break;\n        case OPT_AES128_WRAP:\n        case OPT_AES192_WRAP:\n        case OPT_AES256_WRAP:\n        case OPT_3DES_WRAP:\n            wrapname = opt_flag() + 1;\n            break;\n        }\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto end;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n        goto end;\n    if (wrapname != NULL) {\n        if (!opt_cipher_any(wrapname, &wrap_cipher))\n            goto end;\n    }\n\n    /* Remaining args are files to process. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((rr_allorfirst != -1 || rr_from != NULL) && rr_to == NULL) {\n        BIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\n        goto opthelp;\n    }\n\n    if (!(operation & SMIME_SIGNERS) && (rr_to != NULL || rr_from != NULL)) {\n        BIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\n        goto opthelp;\n    }\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n\n    if ((flags & CMS_CADES) != 0) {\n        if ((flags & CMS_NOATTR) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: \"\n                     \"CAdES requires signed attributes\\n\");\n            goto opthelp;\n        }\n        if (operation == SMIME_VERIFY\n                && (flags & (CMS_NO_SIGNER_CERT_VERIFY | CMS_NO_ATTR_VERIFY)) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: CAdES validation requires\"\n                     \" certs and signed attributes validations\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        if (keyfile != NULL && signerfile == NULL) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        /* Check to see if any final signer needs to be appended */\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (skkeys == NULL && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (keyfile == NULL)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL\n            && secret_key == NULL && pwri_pass == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (*argv == NULL && secret_key == NULL\n            && pwri_pass == NULL && sk_X509_num(encerts) <= 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    } else if (!operation) {\n        BIO_printf(bio_err, \"No operation option (-encrypt|-decrypt|-sign|-verify|...) specified.\\n\");\n        goto opthelp;\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if ((operation & SMIME_SIGNERS) == 0) {\n        if ((flags & CMS_DETACHED) == 0)\n            BIO_printf(bio_err,\n                       \"Warning: -nodetach option is ignored for non-signing operation\\n\");\n\n        flags &= ~CMS_DETACHED;\n    }\n    if ((operation & SMIME_IP) == 0 && contfile != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: -contfile option is ignored for the given operation\\n\");\n    if (operation != SMIME_ENCRYPT && *argv != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: recipient certificate file parameters ignored for operation other than -encrypt\\n\");\n\n    if ((flags & CMS_BINARY) != 0) {\n        if (!(operation & SMIME_OP))\n            outformat = FORMAT_BINARY;\n        if (!(operation & SMIME_IP))\n            informat = FORMAT_BINARY;\n        if ((operation & SMIME_SIGNERS) != 0 && (flags & CMS_DETACHED) != 0)\n            binary_files = 1;\n        if ((operation & SMIME_IP) != 0 && contfile == NULL)\n            binary_files = 1;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (!cipher)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        if (secret_key && !secret_keyid) {\n            BIO_printf(bio_err, \"No secret key id\\n\");\n            goto end;\n        }\n\n        for (; *argv != NULL; argv++) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificate file\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (originatorfile != NULL) {\n        if ((originator = load_cert(originatorfile, FORMAT_UNDEF,\n                                    \"originator certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_SIGN_RECEIPT) {\n        if ((signer = load_cert(signerfile, FORMAT_UNDEF,\n                                \"receipt signer certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((operation == SMIME_DECRYPT) || (operation == SMIME_ENCRYPT)) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (digesthex != NULL) {\n        if (operation != SMIME_SIGN) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest for non-signing operation\\n\");\n            goto end;\n        }\n        if (infile != NULL\n            || (flags & CMS_DETACHED) == 0\n            || (flags & CMS_STREAM) != 0) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest when -in, -nodetach or streaming is used\\n\");\n            goto end;\n        }\n        digestbin = OPENSSL_hexstr2buf(digesthex, &digestlen);\n        if (digestbin == NULL) {\n            BIO_printf(bio_err,\n                       \"Invalid hex value after -digest\\n\");\n            goto end;\n        }\n    } else {\n        in = bio_open_default(infile, 'r',\n                              binary_files ? FORMAT_BINARY : informat);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (operation & SMIME_IP) {\n        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");\n        if (cms == NULL)\n            goto end;\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n        if (certsoutfile != NULL) {\n            STACK_OF(X509) *allcerts;\n            allcerts = CMS_get1_certs(cms);\n            if (!save_certs(certsoutfile, allcerts)) {\n                BIO_printf(bio_err,\n                           \"Error writing certs to %s\\n\", certsoutfile);\n                ret = 5;\n                goto end;\n            }\n            OSSL_STACK_OF_X509_free(allcerts);\n        }\n    }\n\n    if (rctfile != NULL) {\n        char *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\n\n        if ((rctin = BIO_new_file(rctfile, rctmode)) == NULL) {\n            BIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\n            goto end;\n        }\n\n        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");\n        if (rcms == NULL)\n            goto end;\n    }\n\n    out = bio_open_default(outfile, 'w',\n                           binary_files ? FORMAT_BINARY : outformat);\n    if (out == NULL)\n        goto end;\n\n    if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, cms_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_DATA_CREATE) {\n        cms = CMS_data_create_ex(in, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_DIGEST_CREATE) {\n        cms = CMS_digest_create_ex(in, sign_md, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_COMPRESS) {\n        cms = CMS_compress(in, -1, flags);\n    } else if (operation == SMIME_ENCRYPT) {\n        int i;\n        flags |= CMS_PARTIAL;\n        cms = CMS_encrypt_ex(NULL, in, cipher, flags, libctx, app_get0_propq());\n        if (cms == NULL)\n            goto end;\n        for (i = 0; i < sk_X509_num(encerts); i++) {\n            CMS_RecipientInfo *ri;\n            cms_key_param *kparam;\n            int tflags = flags | CMS_KEY_PARAM;\n            /* This flag enforces allocating the EVP_PKEY_CTX for the recipient here */\n            EVP_PKEY_CTX *pctx;\n            X509 *x = sk_X509_value(encerts, i);\n            int res;\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    break;\n                }\n            }\n            ri = CMS_add1_recipient(cms, x, key, originator, tflags);\n            if (ri == NULL)\n                goto end;\n\n            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n            if (kparam != NULL) {\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n\n            res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,\n                                    EVP_PKEY_CTRL_CIPHER,\n                                    EVP_CIPHER_get_nid(cipher), NULL);\n            if (res <= 0 && res != -2)\n                goto end;\n\n            if (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\n                    && wrap_cipher != NULL) {\n                EVP_CIPHER_CTX *wctx;\n                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n                if (EVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL) != 1)\n                    goto end;\n            }\n        }\n\n        if (secret_key != NULL) {\n            if (!CMS_add0_recipient_key(cms, NID_undef,\n                                        secret_key, secret_keylen,\n                                        secret_keyid, secret_keyidlen,\n                                        NULL, NULL, NULL))\n                goto end;\n            /* NULL these because call absorbs them */\n            secret_key = NULL;\n            secret_keyid = NULL;\n        }\n        if (pwri_pass != NULL) {\n            pwri_tmp = (unsigned char *)OPENSSL_strdup((char *)pwri_pass);\n            if (pwri_tmp == NULL)\n                goto end;\n            if (CMS_add0_recipient_password(cms,\n                                            -1, NID_undef, NID_undef,\n                                            pwri_tmp, -1, NULL) == NULL)\n                goto end;\n            pwri_tmp = NULL;\n        }\n        if (!(flags & CMS_STREAM)) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\n        cms = CMS_EncryptedData_encrypt_ex(in, cipher, secret_key,\n                                           secret_keylen, flags, libctx, app_get0_propq());\n\n    } else if (operation == SMIME_SIGN_RECEIPT) {\n        CMS_ContentInfo *srcms = NULL;\n        STACK_OF(CMS_SignerInfo) *sis;\n        CMS_SignerInfo *si;\n        sis = CMS_get0_SignerInfos(cms);\n        if (sis == NULL)\n            goto end;\n        si = sk_CMS_SignerInfo_value(sis, 0);\n        srcms = CMS_sign_receipt(si, signer, key, other, flags);\n        if (srcms == NULL)\n            goto end;\n        CMS_ContentInfo_free(cms);\n        cms = srcms;\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content and not signing pre-computed digest, we\n         * enable streaming if S/MIME output format.\n         */\n        if (operation == SMIME_SIGN) {\n\n            if ((flags & CMS_DETACHED) != 0 && digestbin == NULL) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= CMS_STREAM;\n            }\n            flags |= CMS_PARTIAL;\n            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (cms == NULL)\n                goto end;\n            if (econtent_type != NULL)\n                CMS_set1_eContentType(cms, econtent_type);\n\n            if (rr_to != NULL\n                && ((rr = make_receipt_request(rr_to, rr_allorfirst, rr_from))\n                    == NULL)) {\n                BIO_puts(bio_err, \"Signed Receipt Request Creation Error\\n\");\n                goto end;\n            }\n        } else {\n            flags |= CMS_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            CMS_SignerInfo *si;\n            cms_key_param *kparam;\n            int tflags = flags;\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL) {\n                ret = 2;\n                goto end;\n            }\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL) {\n                ret = 2;\n                goto end;\n            }\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    tflags |= CMS_KEY_PARAM;\n                    break;\n                }\n            }\n            si = CMS_add1_signer(cms, signer, key, sign_md, tflags);\n            if (si == NULL)\n                goto end;\n            if (kparam != NULL) {\n                EVP_PKEY_CTX *pctx;\n                pctx = CMS_SignerInfo_get0_pkey_ctx(si);\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n            if (rr != NULL && !CMS_add1_ReceiptRequest(si, rr))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if (operation == SMIME_SIGN && digestbin != NULL\n            && (flags & CMS_STREAM) == 0) {\n            /* Use pre-computed digest instead of content */\n            if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))\n                goto end;\n        } else if (operation == SMIME_SIGN && (flags & CMS_STREAM) == 0) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    }\n\n    if (cms == NULL) {\n        BIO_printf(bio_err, \"Error creating CMS structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (flags & CMS_DEBUG_DECRYPT)\n            CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\n\n        if (secret_key != NULL) {\n            if (!CMS_decrypt_set1_key(cms,\n                                      secret_key, secret_keylen,\n                                      secret_keyid, secret_keyidlen)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\n                goto end;\n            }\n        }\n\n        if (key != NULL) {\n            if (!CMS_decrypt_set1_pkey_and_peer(cms, key, recip, originator)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\n                goto end;\n            }\n        }\n\n        if (pwri_pass != NULL) {\n            if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\n                goto end;\n            }\n        }\n\n        if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_DATA_OUT) {\n        if (!CMS_data(cms, out, flags))\n            goto end;\n    } else if (operation == SMIME_UNCOMPRESS) {\n        if (!CMS_uncompress(cms, indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_DIGEST_VERIFY) {\n        if (CMS_digest_verify(cms, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_DECRYPT) {\n        if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\n                                       indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_VERIFY) {\n        if (CMS_verify(cms, other, store, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"%s Verification successful\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n        } else {\n            BIO_printf(bio_err, \"%s Verification failure\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n            if (verify_retcode)\n                ret = verify_err + 32;\n            goto end;\n        }\n        if (signerfile != NULL) {\n            STACK_OF(X509) *signers = CMS_get0_signers(cms);\n\n            if (!save_certs(signerfile, signers)) {\n                BIO_printf(bio_err,\n                           \"Error writing signers to %s\\n\", signerfile);\n                ret = 5;\n                goto end;\n            }\n            sk_X509_free(signers);\n        }\n        if (rr_print)\n            receipt_request_print(cms);\n\n    } else if (operation == SMIME_VERIFY_RECEIPT) {\n        if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else {\n        if (noout) {\n            if (print) {\n                ASN1_PCTX *pctx = NULL;\n                if (get_nameopt() != XN_FLAG_ONELINE) {\n                    pctx = ASN1_PCTX_new();\n                    if (pctx != NULL) { /* Print anyway if malloc failed */\n                        ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT);\n                        ASN1_PCTX_set_str_flags(pctx, get_nameopt());\n                        ASN1_PCTX_set_nm_flags(pctx, get_nameopt());\n                    }\n                }\n                CMS_ContentInfo_print_ctx(out, cms, 0, pctx);\n                ASN1_PCTX_free(pctx);\n            }\n        } else if (outformat == FORMAT_SMIME) {\n            if (to)\n                BIO_printf(out, \"To: %s%s\", to, mime_eol);\n            if (from)\n                BIO_printf(out, \"From: %s%s\", from, mime_eol);\n            if (subject)\n                BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n            if (operation == SMIME_RESIGN)\n                ret = SMIME_write_CMS(out, cms, indata, flags);\n            else\n                ret = SMIME_write_CMS(out, cms, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            ret = PEM_write_bio_CMS_stream(out, cms, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            ret = i2d_CMS_bio_stream(out, cms, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for CMS file\\n\");\n            goto end;\n        }\n        if (ret <= 0) {\n            ret = 6;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    OPENSSL_free(secret_key);\n    OPENSSL_free(secret_keyid);\n    OPENSSL_free(pwri_tmp);\n    ASN1_OBJECT_free(econtent_type);\n    CMS_ReceiptRequest_free(rr);\n    sk_OPENSSL_STRING_free(rr_to);\n    sk_OPENSSL_STRING_free(rr_from);\n    for (key_param = key_first; key_param;) {\n        cms_key_param *tparam;\n        sk_OPENSSL_STRING_free(key_param->param);\n        tparam = key_param->next;\n        OPENSSL_free(key_param);\n        key_param = tparam;\n    }\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_CIPHER_free(cipher);\n    EVP_CIPHER_free(wrap_cipher);\n    EVP_MD_free(sign_md);\n    CMS_ContentInfo_free(cms);\n    CMS_ContentInfo_free(rcms);\n    release_engine(e);\n    BIO_free(rctin);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(digestbin);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "sis = CMS_get0_SignerInfos(cms);",
        "final_sink": "sis = CMS_get0_SignerInfos(cms);",
        "source": [
            "        cv = sk_CONF_VALUE_value(policy, i); /* get the object id */"
        ],
        "index": 8
    },
    {
        "prt": "cms",
        "function_call": [
            "int cms_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ASN1_OBJECT *econtent_type = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\n    CMS_ContentInfo *cms = NULL, *rcms = NULL;\n    CMS_ReceiptRequest *rr = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *key = NULL;\n    EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = sk_X509_new_null(), *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL, *originator = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = X509_VERIFY_PARAM_new();\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *certsoutfile = NULL, *digestname = NULL, *wrapname = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    char *digesthex = NULL;\n    unsigned char *digestbin = NULL;\n    long digestlen = 0;\n    char *infile = NULL, *outfile = NULL, *rctfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *signerfile = NULL;\n    char *originatorfile = NULL, *recipfile = NULL, *ciphername = NULL;\n    char *to = NULL, *from = NULL, *subject = NULL, *prog;\n    cms_key_param *key_first = NULL, *key_param = NULL;\n    int flags = CMS_DETACHED, binary_files = 0;\n    int noout = 0, print = 0, keyidx = -1, vpmtouched = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\n    int operation = 0, ret = 1, rr_print = 0, rr_allorfirst = -1;\n    int verify_retcode = 0, rctformat = FORMAT_SMIME, keyform = FORMAT_UNDEF;\n    size_t secret_keylen = 0, secret_keyidlen = 0;\n    unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\n    unsigned char *secret_key = NULL, *secret_keyid = NULL;\n    long ltmp;\n    const char *mime_eol = \"\\n\";\n    OPTION_CHOICE o;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if (encerts == NULL || vpm == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, cms_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(cms_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n\n        case OPT_ENCRYPT:\n            operation = SMIME_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            operation = SMIME_DECRYPT;\n            break;\n        case OPT_SIGN:\n            operation = SMIME_SIGN;\n            break;\n        case OPT_VERIFY:\n            operation = SMIME_VERIFY;\n            break;\n        case OPT_RESIGN:\n            operation = SMIME_RESIGN;\n            break;\n        case OPT_SIGN_RECEIPT:\n            operation = SMIME_SIGN_RECEIPT;\n            break;\n        case OPT_VERIFY_RECEIPT:\n            operation = SMIME_VERIFY_RECEIPT;\n            rctfile = opt_arg();\n            break;\n        case OPT_VERIFY_RETCODE:\n            verify_retcode = 1;\n            break;\n        case OPT_DIGEST_CREATE:\n            operation = SMIME_DIGEST_CREATE;\n            break;\n        case OPT_DIGEST:\n            digesthex = opt_arg();\n            break;\n        case OPT_DIGEST_VERIFY:\n            operation = SMIME_DIGEST_VERIFY;\n            break;\n        case OPT_COMPRESS:\n            operation = SMIME_COMPRESS;\n            break;\n        case OPT_UNCOMPRESS:\n            operation = SMIME_UNCOMPRESS;\n            break;\n        case OPT_ED_ENCRYPT:\n            operation = SMIME_ENCRYPTED_ENCRYPT;\n            break;\n        case OPT_ED_DECRYPT:\n            operation = SMIME_ENCRYPTED_DECRYPT;\n            break;\n        case OPT_DATA_CREATE:\n            operation = SMIME_DATA_CREATE;\n            break;\n        case OPT_DATA_OUT:\n            operation = SMIME_DATA_OUT;\n            break;\n        case OPT_CMSOUT:\n            operation = SMIME_CMSOUT;\n            break;\n\n        case OPT_DEBUG_DECRYPT:\n            flags |= CMS_DEBUG_DECRYPT;\n            break;\n        case OPT_TEXT:\n            flags |= CMS_TEXT;\n            break;\n        case OPT_ASCIICRLF:\n            flags |= CMS_ASCIICRLF;\n            break;\n        case OPT_NOINTERN:\n            flags |= CMS_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= CMS_NO_SIGNER_CERT_VERIFY;\n            break;\n        case OPT_NOCERTS:\n            flags |= CMS_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= CMS_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~CMS_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= CMS_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= CMS_BINARY;\n            break;\n        case OPT_CADES:\n            flags |= CMS_CADES;\n            break;\n        case OPT_KEYID:\n            flags |= CMS_USE_KEYID;\n            break;\n        case OPT_NOSIGS:\n            flags |= CMS_NOSIGS;\n            break;\n        case OPT_NO_CONTENT_VERIFY:\n            flags |= CMS_NO_CONTENT_VERIFY;\n            break;\n        case OPT_NO_ATTR_VERIFY:\n            flags |= CMS_NO_ATTR_VERIFY;\n            break;\n        case OPT_INDEF:\n            flags |= CMS_STREAM;\n            break;\n        case OPT_NOINDEF:\n            flags &= ~CMS_STREAM;\n            break;\n        case OPT_CRLFEOL:\n            mime_eol = \"\\r\\n\";\n            flags |= CMS_CRLFEOL;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_RR_PRINT:\n            rr_print = 1;\n            break;\n        case OPT_RR_ALL:\n            rr_allorfirst = 0;\n            break;\n        case OPT_RR_FIRST:\n            rr_allorfirst = 1;\n            break;\n        case OPT_RCTFORM:\n            if (!opt_format(opt_arg(),\n                            OPT_FMT_PEMDER | OPT_FMT_SMIME, &rctformat))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_RR_FROM:\n            if (rr_from == NULL\n                && (rr_from = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_from, opt_arg());\n            break;\n        case OPT_RR_TO:\n            if (rr_to == NULL\n                && (rr_to = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_to, opt_arg());\n            break;\n        case OPT_PRINT:\n            noout = print = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SECRETKEY:\n            if (secret_key != NULL) {\n                BIO_printf(bio_err, \"Invalid key (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_key = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_key == NULL) {\n                BIO_printf(bio_err, \"Invalid key %s\\n\", opt_arg());\n                goto end;\n            }\n            secret_keylen = (size_t)ltmp;\n            break;\n        case OPT_SECRETKEYID:\n            if (secret_keyid != NULL) {\n                BIO_printf(bio_err, \"Invalid id (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_keyid = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_keyid == NULL) {\n                BIO_printf(bio_err, \"Invalid id %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            secret_keyidlen = (size_t)ltmp;\n            break;\n        case OPT_PWRI_PASSWORD:\n            pwri_pass = (unsigned char *)opt_arg();\n            break;\n        case OPT_ECONTENT_TYPE:\n            if (econtent_type != NULL) {\n                BIO_printf(bio_err, \"Invalid OID (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            econtent_type = OBJ_txt2obj(opt_arg(), 0);\n            if (econtent_type == NULL) {\n                BIO_printf(bio_err, \"Invalid OID %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_CERTSOUT:\n            certsoutfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_ORIGINATOR:\n            originatorfile = opt_arg();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n                    goto end;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_RECIP:\n            if (operation == SMIME_ENCRYPT) {\n                cert = load_cert(opt_arg(), FORMAT_UNDEF,\n                                 \"recipient certificate file\");\n                if (cert == NULL)\n                    goto end;\n                if (!sk_X509_push(encerts, cert))\n                    goto end;\n                cert = NULL;\n            } else {\n                recipfile = opt_arg();\n            }\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_KEYOPT:\n            keyidx = -1;\n            if (operation == SMIME_ENCRYPT) {\n                if (sk_X509_num(encerts) > 0)\n                    keyidx += sk_X509_num(encerts);\n            } else {\n                if (keyfile != NULL || signerfile != NULL)\n                    keyidx++;\n                if (skkeys != NULL)\n                    keyidx += sk_OPENSSL_STRING_num(skkeys);\n            }\n            if (keyidx < 0) {\n                BIO_printf(bio_err, \"No key specified\\n\");\n                goto opthelp;\n            }\n            if (key_param == NULL || key_param->idx != keyidx) {\n                cms_key_param *nparam;\n                nparam = app_malloc(sizeof(*nparam), \"key param buffer\");\n                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {\n                    OPENSSL_free(nparam);\n                    goto end;\n                }\n                nparam->idx = keyidx;\n                nparam->next = NULL;\n                if (key_first == NULL)\n                    key_first = nparam;\n                else\n                    key_param->next = nparam;\n                key_param = nparam;\n            }\n            sk_OPENSSL_STRING_push(key_param->param, opt_arg());\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_WRAP:\n            wrapname = opt_arg();\n            break;\n        case OPT_AES128_WRAP:\n        case OPT_AES192_WRAP:\n        case OPT_AES256_WRAP:\n        case OPT_3DES_WRAP:\n            wrapname = opt_flag() + 1;\n            break;\n        }\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto end;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n        goto end;\n    if (wrapname != NULL) {\n        if (!opt_cipher_any(wrapname, &wrap_cipher))\n            goto end;\n    }\n\n    /* Remaining args are files to process. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((rr_allorfirst != -1 || rr_from != NULL) && rr_to == NULL) {\n        BIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\n        goto opthelp;\n    }\n\n    if (!(operation & SMIME_SIGNERS) && (rr_to != NULL || rr_from != NULL)) {\n        BIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\n        goto opthelp;\n    }\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n\n    if ((flags & CMS_CADES) != 0) {\n        if ((flags & CMS_NOATTR) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: \"\n                     \"CAdES requires signed attributes\\n\");\n            goto opthelp;\n        }\n        if (operation == SMIME_VERIFY\n                && (flags & (CMS_NO_SIGNER_CERT_VERIFY | CMS_NO_ATTR_VERIFY)) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: CAdES validation requires\"\n                     \" certs and signed attributes validations\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        if (keyfile != NULL && signerfile == NULL) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        /* Check to see if any final signer needs to be appended */\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (skkeys == NULL && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (keyfile == NULL)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL\n            && secret_key == NULL && pwri_pass == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (*argv == NULL && secret_key == NULL\n            && pwri_pass == NULL && sk_X509_num(encerts) <= 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    } else if (!operation) {\n        BIO_printf(bio_err, \"No operation option (-encrypt|-decrypt|-sign|-verify|...) specified.\\n\");\n        goto opthelp;\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if ((operation & SMIME_SIGNERS) == 0) {\n        if ((flags & CMS_DETACHED) == 0)\n            BIO_printf(bio_err,\n                       \"Warning: -nodetach option is ignored for non-signing operation\\n\");\n\n        flags &= ~CMS_DETACHED;\n    }\n    if ((operation & SMIME_IP) == 0 && contfile != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: -contfile option is ignored for the given operation\\n\");\n    if (operation != SMIME_ENCRYPT && *argv != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: recipient certificate file parameters ignored for operation other than -encrypt\\n\");\n\n    if ((flags & CMS_BINARY) != 0) {\n        if (!(operation & SMIME_OP))\n            outformat = FORMAT_BINARY;\n        if (!(operation & SMIME_IP))\n            informat = FORMAT_BINARY;\n        if ((operation & SMIME_SIGNERS) != 0 && (flags & CMS_DETACHED) != 0)\n            binary_files = 1;\n        if ((operation & SMIME_IP) != 0 && contfile == NULL)\n            binary_files = 1;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (!cipher)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        if (secret_key && !secret_keyid) {\n            BIO_printf(bio_err, \"No secret key id\\n\");\n            goto end;\n        }\n\n        for (; *argv != NULL; argv++) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificate file\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (originatorfile != NULL) {\n        if ((originator = load_cert(originatorfile, FORMAT_UNDEF,\n                                    \"originator certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_SIGN_RECEIPT) {\n        if ((signer = load_cert(signerfile, FORMAT_UNDEF,\n                                \"receipt signer certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((operation == SMIME_DECRYPT) || (operation == SMIME_ENCRYPT)) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (digesthex != NULL) {\n        if (operation != SMIME_SIGN) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest for non-signing operation\\n\");\n            goto end;\n        }\n        if (infile != NULL\n            || (flags & CMS_DETACHED) == 0\n            || (flags & CMS_STREAM) != 0) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest when -in, -nodetach or streaming is used\\n\");\n            goto end;\n        }\n        digestbin = OPENSSL_hexstr2buf(digesthex, &digestlen);\n        if (digestbin == NULL) {\n            BIO_printf(bio_err,\n                       \"Invalid hex value after -digest\\n\");\n            goto end;\n        }\n    } else {\n        in = bio_open_default(infile, 'r',\n                              binary_files ? FORMAT_BINARY : informat);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (operation & SMIME_IP) {\n        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");\n        if (cms == NULL)\n            goto end;\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n        if (certsoutfile != NULL) {\n            STACK_OF(X509) *allcerts;\n            allcerts = CMS_get1_certs(cms);\n            if (!save_certs(certsoutfile, allcerts)) {\n                BIO_printf(bio_err,\n                           \"Error writing certs to %s\\n\", certsoutfile);\n                ret = 5;\n                goto end;\n            }\n            OSSL_STACK_OF_X509_free(allcerts);\n        }\n    }\n\n    if (rctfile != NULL) {\n        char *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\n\n        if ((rctin = BIO_new_file(rctfile, rctmode)) == NULL) {\n            BIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\n            goto end;\n        }\n\n        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");\n        if (rcms == NULL)\n            goto end;\n    }\n\n    out = bio_open_default(outfile, 'w',\n                           binary_files ? FORMAT_BINARY : outformat);\n    if (out == NULL)\n        goto end;\n\n    if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, cms_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_DATA_CREATE) {\n        cms = CMS_data_create_ex(in, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_DIGEST_CREATE) {\n        cms = CMS_digest_create_ex(in, sign_md, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_COMPRESS) {\n        cms = CMS_compress(in, -1, flags);\n    } else if (operation == SMIME_ENCRYPT) {\n        int i;\n        flags |= CMS_PARTIAL;\n        cms = CMS_encrypt_ex(NULL, in, cipher, flags, libctx, app_get0_propq());\n        if (cms == NULL)\n            goto end;\n        for (i = 0; i < sk_X509_num(encerts); i++) {\n            CMS_RecipientInfo *ri;\n            cms_key_param *kparam;\n            int tflags = flags | CMS_KEY_PARAM;\n            /* This flag enforces allocating the EVP_PKEY_CTX for the recipient here */\n            EVP_PKEY_CTX *pctx;\n            X509 *x = sk_X509_value(encerts, i);\n            int res;\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    break;\n                }\n            }\n            ri = CMS_add1_recipient(cms, x, key, originator, tflags);\n            if (ri == NULL)\n                goto end;\n\n            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n            if (kparam != NULL) {\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n\n            res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,\n                                    EVP_PKEY_CTRL_CIPHER,\n                                    EVP_CIPHER_get_nid(cipher), NULL);\n            if (res <= 0 && res != -2)\n                goto end;\n\n            if (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\n                    && wrap_cipher != NULL) {\n                EVP_CIPHER_CTX *wctx;\n                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n                if (EVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL) != 1)\n                    goto end;\n            }\n        }\n\n        if (secret_key != NULL) {\n            if (!CMS_add0_recipient_key(cms, NID_undef,\n                                        secret_key, secret_keylen,\n                                        secret_keyid, secret_keyidlen,\n                                        NULL, NULL, NULL))\n                goto end;\n            /* NULL these because call absorbs them */\n            secret_key = NULL;\n            secret_keyid = NULL;\n        }\n        if (pwri_pass != NULL) {\n            pwri_tmp = (unsigned char *)OPENSSL_strdup((char *)pwri_pass);\n            if (pwri_tmp == NULL)\n                goto end;\n            if (CMS_add0_recipient_password(cms,\n                                            -1, NID_undef, NID_undef,\n                                            pwri_tmp, -1, NULL) == NULL)\n                goto end;\n            pwri_tmp = NULL;\n        }\n        if (!(flags & CMS_STREAM)) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\n        cms = CMS_EncryptedData_encrypt_ex(in, cipher, secret_key,\n                                           secret_keylen, flags, libctx, app_get0_propq());\n\n    } else if (operation == SMIME_SIGN_RECEIPT) {\n        CMS_ContentInfo *srcms = NULL;\n        STACK_OF(CMS_SignerInfo) *sis;\n        CMS_SignerInfo *si;\n        sis = CMS_get0_SignerInfos(cms);\n        if (sis == NULL)\n            goto end;\n        si = sk_CMS_SignerInfo_value(sis, 0);\n        srcms = CMS_sign_receipt(si, signer, key, other, flags);\n        if (srcms == NULL)\n            goto end;\n        CMS_ContentInfo_free(cms);\n        cms = srcms;\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content and not signing pre-computed digest, we\n         * enable streaming if S/MIME output format.\n         */\n        if (operation == SMIME_SIGN) {\n\n            if ((flags & CMS_DETACHED) != 0 && digestbin == NULL) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= CMS_STREAM;\n            }\n            flags |= CMS_PARTIAL;\n            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (cms == NULL)\n                goto end;\n            if (econtent_type != NULL)\n                CMS_set1_eContentType(cms, econtent_type);\n\n            if (rr_to != NULL\n                && ((rr = make_receipt_request(rr_to, rr_allorfirst, rr_from))\n                    == NULL)) {\n                BIO_puts(bio_err, \"Signed Receipt Request Creation Error\\n\");\n                goto end;\n            }\n        } else {\n            flags |= CMS_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            CMS_SignerInfo *si;\n            cms_key_param *kparam;\n            int tflags = flags;\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL) {\n                ret = 2;\n                goto end;\n            }\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL) {\n                ret = 2;\n                goto end;\n            }\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    tflags |= CMS_KEY_PARAM;\n                    break;\n                }\n            }\n            si = CMS_add1_signer(cms, signer, key, sign_md, tflags);\n            if (si == NULL)\n                goto end;\n            if (kparam != NULL) {\n                EVP_PKEY_CTX *pctx;\n                pctx = CMS_SignerInfo_get0_pkey_ctx(si);\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n            if (rr != NULL && !CMS_add1_ReceiptRequest(si, rr))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if (operation == SMIME_SIGN && digestbin != NULL\n            && (flags & CMS_STREAM) == 0) {\n            /* Use pre-computed digest instead of content */\n            if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))\n                goto end;\n        } else if (operation == SMIME_SIGN && (flags & CMS_STREAM) == 0) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    }\n\n    if (cms == NULL) {\n        BIO_printf(bio_err, \"Error creating CMS structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (flags & CMS_DEBUG_DECRYPT)\n            CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\n\n        if (secret_key != NULL) {\n            if (!CMS_decrypt_set1_key(cms,\n                                      secret_key, secret_keylen,\n                                      secret_keyid, secret_keyidlen)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\n                goto end;\n            }\n        }\n\n        if (key != NULL) {\n            if (!CMS_decrypt_set1_pkey_and_peer(cms, key, recip, originator)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\n                goto end;\n            }\n        }\n\n        if (pwri_pass != NULL) {\n            if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\n                goto end;\n            }\n        }\n\n        if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_DATA_OUT) {\n        if (!CMS_data(cms, out, flags))\n            goto end;\n    } else if (operation == SMIME_UNCOMPRESS) {\n        if (!CMS_uncompress(cms, indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_DIGEST_VERIFY) {\n        if (CMS_digest_verify(cms, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_DECRYPT) {\n        if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\n                                       indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_VERIFY) {\n        if (CMS_verify(cms, other, store, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"%s Verification successful\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n        } else {\n            BIO_printf(bio_err, \"%s Verification failure\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n            if (verify_retcode)\n                ret = verify_err + 32;\n            goto end;\n        }\n        if (signerfile != NULL) {\n            STACK_OF(X509) *signers = CMS_get0_signers(cms);\n\n            if (!save_certs(signerfile, signers)) {\n                BIO_printf(bio_err,\n                           \"Error writing signers to %s\\n\", signerfile);\n                ret = 5;\n                goto end;\n            }\n            sk_X509_free(signers);\n        }\n        if (rr_print)\n            receipt_request_print(cms);\n\n    } else if (operation == SMIME_VERIFY_RECEIPT) {\n        if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else {\n        if (noout) {\n            if (print) {\n                ASN1_PCTX *pctx = NULL;\n                if (get_nameopt() != XN_FLAG_ONELINE) {\n                    pctx = ASN1_PCTX_new();\n                    if (pctx != NULL) { /* Print anyway if malloc failed */\n                        ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT);\n                        ASN1_PCTX_set_str_flags(pctx, get_nameopt());\n                        ASN1_PCTX_set_nm_flags(pctx, get_nameopt());\n                    }\n                }\n                CMS_ContentInfo_print_ctx(out, cms, 0, pctx);\n                ASN1_PCTX_free(pctx);\n            }\n        } else if (outformat == FORMAT_SMIME) {\n            if (to)\n                BIO_printf(out, \"To: %s%s\", to, mime_eol);\n            if (from)\n                BIO_printf(out, \"From: %s%s\", from, mime_eol);\n            if (subject)\n                BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n            if (operation == SMIME_RESIGN)\n                ret = SMIME_write_CMS(out, cms, indata, flags);\n            else\n                ret = SMIME_write_CMS(out, cms, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            ret = PEM_write_bio_CMS_stream(out, cms, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            ret = i2d_CMS_bio_stream(out, cms, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for CMS file\\n\");\n            goto end;\n        }\n        if (ret <= 0) {\n            ret = 6;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    OPENSSL_free(secret_key);\n    OPENSSL_free(secret_keyid);\n    OPENSSL_free(pwri_tmp);\n    ASN1_OBJECT_free(econtent_type);\n    CMS_ReceiptRequest_free(rr);\n    sk_OPENSSL_STRING_free(rr_to);\n    sk_OPENSSL_STRING_free(rr_from);\n    for (key_param = key_first; key_param;) {\n        cms_key_param *tparam;\n        sk_OPENSSL_STRING_free(key_param->param);\n        tparam = key_param->next;\n        OPENSSL_free(key_param);\n        key_param = tparam;\n    }\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_CIPHER_free(cipher);\n    EVP_CIPHER_free(wrap_cipher);\n    EVP_MD_free(sign_md);\n    CMS_ContentInfo_free(cms);\n    CMS_ContentInfo_free(rcms);\n    release_engine(e);\n    BIO_free(rctin);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(digestbin);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}",
            "CMS_SignerInfo *CMS_add1_signer(CMS_ContentInfo *cms,\n                                X509 *signer, EVP_PKEY *pk, const EVP_MD *md,\n                                unsigned int flags)\n{\n    CMS_SignedData *sd;\n    CMS_SignerInfo *si = NULL;\n    X509_ALGOR *alg;\n    int i, type;\n    const CMS_CTX *ctx = ossl_cms_get0_cmsctx(cms);\n\n    if (!X509_check_private_key(signer, pk)) {\n        ERR_raise(ERR_LIB_CMS, CMS_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE);\n        return NULL;\n    }\n    sd = cms_signed_data_init(cms);\n    if (!sd)\n        goto err;\n    si = M_ASN1_new_of(CMS_SignerInfo);\n    if (!si) {\n        ERR_raise(ERR_LIB_CMS, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    /* Call for side-effect of computing hash and caching extensions */\n    X509_check_purpose(signer, -1, -1);\n\n    X509_up_ref(signer);\n    EVP_PKEY_up_ref(pk);\n\n    si->cms_ctx = ctx;\n    si->pkey = pk;\n    si->signer = signer;\n    si->mctx = EVP_MD_CTX_new();\n    si->pctx = NULL;\n\n    if (si->mctx == NULL) {\n        ERR_raise(ERR_LIB_CMS, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    if (flags & CMS_USE_KEYID) {\n        si->version = 3;\n        if (sd->version < 3)\n            sd->version = 3;\n        type = CMS_SIGNERINFO_KEYIDENTIFIER;\n    } else {\n        type = CMS_SIGNERINFO_ISSUER_SERIAL;\n        si->version = 1;\n    }\n\n    if (!ossl_cms_set1_SignerIdentifier(si->sid, signer, type, ctx))\n        goto err;\n\n    if (md == NULL) {\n        int def_nid;\n\n        if (EVP_PKEY_get_default_digest_nid(pk, &def_nid) <= 0) {\n            ERR_raise_data(ERR_LIB_CMS, CMS_R_NO_DEFAULT_DIGEST,\n                           \"pkey nid=%d\", EVP_PKEY_get_id(pk));\n            goto err;\n        }\n        md = EVP_get_digestbynid(def_nid);\n        if (md == NULL) {\n            ERR_raise_data(ERR_LIB_CMS, CMS_R_NO_DEFAULT_DIGEST,\n                           \"default md nid=%d\", def_nid);\n            goto err;\n        }\n    }\n\n    X509_ALGOR_set_md(si->digestAlgorithm, md);\n\n    /* See if digest is present in digestAlgorithms */\n    for (i = 0; i < sk_X509_ALGOR_num(sd->digestAlgorithms); i++) {\n        const ASN1_OBJECT *aoid;\n        char name[OSSL_MAX_NAME_SIZE];\n\n        alg = sk_X509_ALGOR_value(sd->digestAlgorithms, i);\n        X509_ALGOR_get0(&aoid, NULL, NULL, alg);\n        OBJ_obj2txt(name, sizeof(name), aoid, 0);\n        if (EVP_MD_is_a(md, name))\n            break;\n    }\n\n    if (i == sk_X509_ALGOR_num(sd->digestAlgorithms)) {\n        if ((alg = X509_ALGOR_new()) == NULL) {\n            ERR_raise(ERR_LIB_CMS, ERR_R_ASN1_LIB);\n            goto err;\n        }\n        X509_ALGOR_set_md(alg, md);\n        if (!sk_X509_ALGOR_push(sd->digestAlgorithms, alg)) {\n            X509_ALGOR_free(alg);\n            ERR_raise(ERR_LIB_CMS, ERR_R_CRYPTO_LIB);\n            goto err;\n        }\n    }\n\n    if (!(flags & CMS_KEY_PARAM) && !cms_sd_asn1_ctrl(si, 0)) {\n        ERR_raise_data(ERR_LIB_CMS, CMS_R_UNSUPPORTED_SIGNATURE_ALGORITHM,\n                       \"pkey nid=%d\", EVP_PKEY_get_id(pk));\n        goto err;\n    }\n    if (!(flags & CMS_NOATTR)) {\n        /*\n         * Initialize signed attributes structure so other attributes\n         * such as signing time etc are added later even if we add none here.\n         */\n        if (!si->signedAttrs) {\n            si->signedAttrs = sk_X509_ATTRIBUTE_new_null();\n            if (!si->signedAttrs) {\n                ERR_raise(ERR_LIB_CMS, ERR_R_CRYPTO_LIB);\n                goto err;\n            }\n        }\n\n        if (!(flags & CMS_NOSMIMECAP)) {\n            STACK_OF(X509_ALGOR) *smcap = NULL;\n\n            i = CMS_add_standard_smimecap(&smcap);\n            if (i)\n                i = CMS_add_smimecap(si, smcap);\n            sk_X509_ALGOR_pop_free(smcap, X509_ALGOR_free);\n            if (!i) {\n                ERR_raise(ERR_LIB_CMS, ERR_R_CMS_LIB);\n                goto err;\n            }\n        }\n        if (flags & CMS_CADES) {\n            ESS_SIGNING_CERT *sc = NULL;\n            ESS_SIGNING_CERT_V2 *sc2 = NULL;\n            int add_sc;\n\n            if (md == NULL || EVP_MD_is_a(md, SN_sha1)) {\n                if ((sc = OSSL_ESS_signing_cert_new_init(signer,\n                                                         NULL, 1)) == NULL)\n                    goto err;\n                add_sc = ossl_cms_add1_signing_cert(si, sc);\n                ESS_SIGNING_CERT_free(sc);\n            } else {\n                if ((sc2 = OSSL_ESS_signing_cert_v2_new_init(md, signer,\n                                                             NULL, 1)) == NULL)\n                    goto err;\n                add_sc = ossl_cms_add1_signing_cert_v2(si, sc2);\n                ESS_SIGNING_CERT_V2_free(sc2);\n            }\n            if (!add_sc)\n                goto err;\n        }\n        if (flags & CMS_REUSE_DIGEST) {\n            if (!cms_copy_messageDigest(cms, si))\n                goto err;\n            if (!cms_set_si_contentType_attr(cms, si))\n                goto err;\n            if (!(flags & (CMS_PARTIAL | CMS_KEY_PARAM)) &&\n                !CMS_SignerInfo_sign(si))\n                goto err;\n        }\n    }\n\n    if (!(flags & CMS_NOCERTS)) {\n        /* NB ignore -1 return for duplicate cert */\n        if (!CMS_add1_cert(cms, signer)) {\n            ERR_raise(ERR_LIB_CMS, ERR_R_CMS_LIB);\n            goto err;\n        }\n    }\n\n    if (flags & CMS_KEY_PARAM) {\n        if (flags & CMS_NOATTR) {\n            si->pctx = EVP_PKEY_CTX_new_from_pkey(ossl_cms_ctx_get0_libctx(ctx),\n                                                  si->pkey,\n                                                  ossl_cms_ctx_get0_propq(ctx));\n            if (si->pctx == NULL)\n                goto err;\n            if (EVP_PKEY_sign_init(si->pctx) <= 0)\n                goto err;\n            if (EVP_PKEY_CTX_set_signature_md(si->pctx, md) <= 0)\n                goto err;\n        } else if (EVP_DigestSignInit_ex(si->mctx, &si->pctx,\n                                         EVP_MD_get0_name(md),\n                                         ossl_cms_ctx_get0_libctx(ctx),\n                                         ossl_cms_ctx_get0_propq(ctx),\n                                         pk, NULL) <= 0) {\n            si->pctx = NULL;\n            goto err;\n        }\n        else {\n            EVP_MD_CTX_set_flags(si->mctx, EVP_MD_CTX_FLAG_KEEP_PKEY_CTX);\n        }\n    }\n\n    if (sd->signerInfos == NULL)\n        sd->signerInfos = sk_CMS_SignerInfo_new_null();\n    if (sd->signerInfos == NULL || !sk_CMS_SignerInfo_push(sd->signerInfos, si)) {\n        ERR_raise(ERR_LIB_CMS, ERR_R_CRYPTO_LIB);\n        goto err;\n    }\n\n    return si;\n\n err:\n    M_ASN1_free_of(si, CMS_SignerInfo);\n    return NULL;\n\n}",
            "static CMS_SignedData *cms_signed_data_init(CMS_ContentInfo *cms)\n{\n    if (cms->d.other == NULL) {\n        cms->d.signedData = M_ASN1_new_of(CMS_SignedData);\n        if (!cms->d.signedData) {\n            ERR_raise(ERR_LIB_CMS, ERR_R_ASN1_LIB);\n            return NULL;\n        }\n        cms->d.signedData->version = 1;\n        cms->d.signedData->encapContentInfo->eContentType =\n            OBJ_nid2obj(NID_pkcs7_data);\n        cms->d.signedData->encapContentInfo->partial = 1;\n        ASN1_OBJECT_free(cms->contentType);\n        cms->contentType = OBJ_nid2obj(NID_pkcs7_signed);\n        return cms->d.signedData;\n    }\n    return cms_get0_signed(cms);\n}"
        ],
        "sink": "si = CMS_add1_signer(cms, signer, key, sign_md, tflags);",
        "final_sink": "    if (cms->d.other == NULL) {",
        "source": [
            "    pktmp = X509_get0_pubkey(ret);"
        ],
        "index": 9
    },
    {
        "prt": "cms",
        "function_call": [
            "int cms_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ASN1_OBJECT *econtent_type = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\n    CMS_ContentInfo *cms = NULL, *rcms = NULL;\n    CMS_ReceiptRequest *rr = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *key = NULL;\n    EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = sk_X509_new_null(), *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL, *originator = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = X509_VERIFY_PARAM_new();\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *certsoutfile = NULL, *digestname = NULL, *wrapname = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    char *digesthex = NULL;\n    unsigned char *digestbin = NULL;\n    long digestlen = 0;\n    char *infile = NULL, *outfile = NULL, *rctfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *signerfile = NULL;\n    char *originatorfile = NULL, *recipfile = NULL, *ciphername = NULL;\n    char *to = NULL, *from = NULL, *subject = NULL, *prog;\n    cms_key_param *key_first = NULL, *key_param = NULL;\n    int flags = CMS_DETACHED, binary_files = 0;\n    int noout = 0, print = 0, keyidx = -1, vpmtouched = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\n    int operation = 0, ret = 1, rr_print = 0, rr_allorfirst = -1;\n    int verify_retcode = 0, rctformat = FORMAT_SMIME, keyform = FORMAT_UNDEF;\n    size_t secret_keylen = 0, secret_keyidlen = 0;\n    unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\n    unsigned char *secret_key = NULL, *secret_keyid = NULL;\n    long ltmp;\n    const char *mime_eol = \"\\n\";\n    OPTION_CHOICE o;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if (encerts == NULL || vpm == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, cms_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(cms_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n\n        case OPT_ENCRYPT:\n            operation = SMIME_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            operation = SMIME_DECRYPT;\n            break;\n        case OPT_SIGN:\n            operation = SMIME_SIGN;\n            break;\n        case OPT_VERIFY:\n            operation = SMIME_VERIFY;\n            break;\n        case OPT_RESIGN:\n            operation = SMIME_RESIGN;\n            break;\n        case OPT_SIGN_RECEIPT:\n            operation = SMIME_SIGN_RECEIPT;\n            break;\n        case OPT_VERIFY_RECEIPT:\n            operation = SMIME_VERIFY_RECEIPT;\n            rctfile = opt_arg();\n            break;\n        case OPT_VERIFY_RETCODE:\n            verify_retcode = 1;\n            break;\n        case OPT_DIGEST_CREATE:\n            operation = SMIME_DIGEST_CREATE;\n            break;\n        case OPT_DIGEST:\n            digesthex = opt_arg();\n            break;\n        case OPT_DIGEST_VERIFY:\n            operation = SMIME_DIGEST_VERIFY;\n            break;\n        case OPT_COMPRESS:\n            operation = SMIME_COMPRESS;\n            break;\n        case OPT_UNCOMPRESS:\n            operation = SMIME_UNCOMPRESS;\n            break;\n        case OPT_ED_ENCRYPT:\n            operation = SMIME_ENCRYPTED_ENCRYPT;\n            break;\n        case OPT_ED_DECRYPT:\n            operation = SMIME_ENCRYPTED_DECRYPT;\n            break;\n        case OPT_DATA_CREATE:\n            operation = SMIME_DATA_CREATE;\n            break;\n        case OPT_DATA_OUT:\n            operation = SMIME_DATA_OUT;\n            break;\n        case OPT_CMSOUT:\n            operation = SMIME_CMSOUT;\n            break;\n\n        case OPT_DEBUG_DECRYPT:\n            flags |= CMS_DEBUG_DECRYPT;\n            break;\n        case OPT_TEXT:\n            flags |= CMS_TEXT;\n            break;\n        case OPT_ASCIICRLF:\n            flags |= CMS_ASCIICRLF;\n            break;\n        case OPT_NOINTERN:\n            flags |= CMS_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= CMS_NO_SIGNER_CERT_VERIFY;\n            break;\n        case OPT_NOCERTS:\n            flags |= CMS_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= CMS_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~CMS_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= CMS_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= CMS_BINARY;\n            break;\n        case OPT_CADES:\n            flags |= CMS_CADES;\n            break;\n        case OPT_KEYID:\n            flags |= CMS_USE_KEYID;\n            break;\n        case OPT_NOSIGS:\n            flags |= CMS_NOSIGS;\n            break;\n        case OPT_NO_CONTENT_VERIFY:\n            flags |= CMS_NO_CONTENT_VERIFY;\n            break;\n        case OPT_NO_ATTR_VERIFY:\n            flags |= CMS_NO_ATTR_VERIFY;\n            break;\n        case OPT_INDEF:\n            flags |= CMS_STREAM;\n            break;\n        case OPT_NOINDEF:\n            flags &= ~CMS_STREAM;\n            break;\n        case OPT_CRLFEOL:\n            mime_eol = \"\\r\\n\";\n            flags |= CMS_CRLFEOL;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_RR_PRINT:\n            rr_print = 1;\n            break;\n        case OPT_RR_ALL:\n            rr_allorfirst = 0;\n            break;\n        case OPT_RR_FIRST:\n            rr_allorfirst = 1;\n            break;\n        case OPT_RCTFORM:\n            if (!opt_format(opt_arg(),\n                            OPT_FMT_PEMDER | OPT_FMT_SMIME, &rctformat))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_RR_FROM:\n            if (rr_from == NULL\n                && (rr_from = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_from, opt_arg());\n            break;\n        case OPT_RR_TO:\n            if (rr_to == NULL\n                && (rr_to = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_to, opt_arg());\n            break;\n        case OPT_PRINT:\n            noout = print = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SECRETKEY:\n            if (secret_key != NULL) {\n                BIO_printf(bio_err, \"Invalid key (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_key = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_key == NULL) {\n                BIO_printf(bio_err, \"Invalid key %s\\n\", opt_arg());\n                goto end;\n            }\n            secret_keylen = (size_t)ltmp;\n            break;\n        case OPT_SECRETKEYID:\n            if (secret_keyid != NULL) {\n                BIO_printf(bio_err, \"Invalid id (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_keyid = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_keyid == NULL) {\n                BIO_printf(bio_err, \"Invalid id %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            secret_keyidlen = (size_t)ltmp;\n            break;\n        case OPT_PWRI_PASSWORD:\n            pwri_pass = (unsigned char *)opt_arg();\n            break;\n        case OPT_ECONTENT_TYPE:\n            if (econtent_type != NULL) {\n                BIO_printf(bio_err, \"Invalid OID (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            econtent_type = OBJ_txt2obj(opt_arg(), 0);\n            if (econtent_type == NULL) {\n                BIO_printf(bio_err, \"Invalid OID %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_CERTSOUT:\n            certsoutfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_ORIGINATOR:\n            originatorfile = opt_arg();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n                    goto end;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_RECIP:\n            if (operation == SMIME_ENCRYPT) {\n                cert = load_cert(opt_arg(), FORMAT_UNDEF,\n                                 \"recipient certificate file\");\n                if (cert == NULL)\n                    goto end;\n                if (!sk_X509_push(encerts, cert))\n                    goto end;\n                cert = NULL;\n            } else {\n                recipfile = opt_arg();\n            }\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_KEYOPT:\n            keyidx = -1;\n            if (operation == SMIME_ENCRYPT) {\n                if (sk_X509_num(encerts) > 0)\n                    keyidx += sk_X509_num(encerts);\n            } else {\n                if (keyfile != NULL || signerfile != NULL)\n                    keyidx++;\n                if (skkeys != NULL)\n                    keyidx += sk_OPENSSL_STRING_num(skkeys);\n            }\n            if (keyidx < 0) {\n                BIO_printf(bio_err, \"No key specified\\n\");\n                goto opthelp;\n            }\n            if (key_param == NULL || key_param->idx != keyidx) {\n                cms_key_param *nparam;\n                nparam = app_malloc(sizeof(*nparam), \"key param buffer\");\n                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {\n                    OPENSSL_free(nparam);\n                    goto end;\n                }\n                nparam->idx = keyidx;\n                nparam->next = NULL;\n                if (key_first == NULL)\n                    key_first = nparam;\n                else\n                    key_param->next = nparam;\n                key_param = nparam;\n            }\n            sk_OPENSSL_STRING_push(key_param->param, opt_arg());\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_WRAP:\n            wrapname = opt_arg();\n            break;\n        case OPT_AES128_WRAP:\n        case OPT_AES192_WRAP:\n        case OPT_AES256_WRAP:\n        case OPT_3DES_WRAP:\n            wrapname = opt_flag() + 1;\n            break;\n        }\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto end;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n        goto end;\n    if (wrapname != NULL) {\n        if (!opt_cipher_any(wrapname, &wrap_cipher))\n            goto end;\n    }\n\n    /* Remaining args are files to process. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((rr_allorfirst != -1 || rr_from != NULL) && rr_to == NULL) {\n        BIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\n        goto opthelp;\n    }\n\n    if (!(operation & SMIME_SIGNERS) && (rr_to != NULL || rr_from != NULL)) {\n        BIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\n        goto opthelp;\n    }\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n\n    if ((flags & CMS_CADES) != 0) {\n        if ((flags & CMS_NOATTR) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: \"\n                     \"CAdES requires signed attributes\\n\");\n            goto opthelp;\n        }\n        if (operation == SMIME_VERIFY\n                && (flags & (CMS_NO_SIGNER_CERT_VERIFY | CMS_NO_ATTR_VERIFY)) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: CAdES validation requires\"\n                     \" certs and signed attributes validations\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        if (keyfile != NULL && signerfile == NULL) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        /* Check to see if any final signer needs to be appended */\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (skkeys == NULL && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (keyfile == NULL)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL\n            && secret_key == NULL && pwri_pass == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (*argv == NULL && secret_key == NULL\n            && pwri_pass == NULL && sk_X509_num(encerts) <= 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    } else if (!operation) {\n        BIO_printf(bio_err, \"No operation option (-encrypt|-decrypt|-sign|-verify|...) specified.\\n\");\n        goto opthelp;\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if ((operation & SMIME_SIGNERS) == 0) {\n        if ((flags & CMS_DETACHED) == 0)\n            BIO_printf(bio_err,\n                       \"Warning: -nodetach option is ignored for non-signing operation\\n\");\n\n        flags &= ~CMS_DETACHED;\n    }\n    if ((operation & SMIME_IP) == 0 && contfile != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: -contfile option is ignored for the given operation\\n\");\n    if (operation != SMIME_ENCRYPT && *argv != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: recipient certificate file parameters ignored for operation other than -encrypt\\n\");\n\n    if ((flags & CMS_BINARY) != 0) {\n        if (!(operation & SMIME_OP))\n            outformat = FORMAT_BINARY;\n        if (!(operation & SMIME_IP))\n            informat = FORMAT_BINARY;\n        if ((operation & SMIME_SIGNERS) != 0 && (flags & CMS_DETACHED) != 0)\n            binary_files = 1;\n        if ((operation & SMIME_IP) != 0 && contfile == NULL)\n            binary_files = 1;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (!cipher)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        if (secret_key && !secret_keyid) {\n            BIO_printf(bio_err, \"No secret key id\\n\");\n            goto end;\n        }\n\n        for (; *argv != NULL; argv++) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificate file\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (originatorfile != NULL) {\n        if ((originator = load_cert(originatorfile, FORMAT_UNDEF,\n                                    \"originator certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_SIGN_RECEIPT) {\n        if ((signer = load_cert(signerfile, FORMAT_UNDEF,\n                                \"receipt signer certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((operation == SMIME_DECRYPT) || (operation == SMIME_ENCRYPT)) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (digesthex != NULL) {\n        if (operation != SMIME_SIGN) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest for non-signing operation\\n\");\n            goto end;\n        }\n        if (infile != NULL\n            || (flags & CMS_DETACHED) == 0\n            || (flags & CMS_STREAM) != 0) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest when -in, -nodetach or streaming is used\\n\");\n            goto end;\n        }\n        digestbin = OPENSSL_hexstr2buf(digesthex, &digestlen);\n        if (digestbin == NULL) {\n            BIO_printf(bio_err,\n                       \"Invalid hex value after -digest\\n\");\n            goto end;\n        }\n    } else {\n        in = bio_open_default(infile, 'r',\n                              binary_files ? FORMAT_BINARY : informat);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (operation & SMIME_IP) {\n        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");\n        if (cms == NULL)\n            goto end;\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n        if (certsoutfile != NULL) {\n            STACK_OF(X509) *allcerts;\n            allcerts = CMS_get1_certs(cms);\n            if (!save_certs(certsoutfile, allcerts)) {\n                BIO_printf(bio_err,\n                           \"Error writing certs to %s\\n\", certsoutfile);\n                ret = 5;\n                goto end;\n            }\n            OSSL_STACK_OF_X509_free(allcerts);\n        }\n    }\n\n    if (rctfile != NULL) {\n        char *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\n\n        if ((rctin = BIO_new_file(rctfile, rctmode)) == NULL) {\n            BIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\n            goto end;\n        }\n\n        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");\n        if (rcms == NULL)\n            goto end;\n    }\n\n    out = bio_open_default(outfile, 'w',\n                           binary_files ? FORMAT_BINARY : outformat);\n    if (out == NULL)\n        goto end;\n\n    if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, cms_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_DATA_CREATE) {\n        cms = CMS_data_create_ex(in, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_DIGEST_CREATE) {\n        cms = CMS_digest_create_ex(in, sign_md, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_COMPRESS) {\n        cms = CMS_compress(in, -1, flags);\n    } else if (operation == SMIME_ENCRYPT) {\n        int i;\n        flags |= CMS_PARTIAL;\n        cms = CMS_encrypt_ex(NULL, in, cipher, flags, libctx, app_get0_propq());\n        if (cms == NULL)\n            goto end;\n        for (i = 0; i < sk_X509_num(encerts); i++) {\n            CMS_RecipientInfo *ri;\n            cms_key_param *kparam;\n            int tflags = flags | CMS_KEY_PARAM;\n            /* This flag enforces allocating the EVP_PKEY_CTX for the recipient here */\n            EVP_PKEY_CTX *pctx;\n            X509 *x = sk_X509_value(encerts, i);\n            int res;\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    break;\n                }\n            }\n            ri = CMS_add1_recipient(cms, x, key, originator, tflags);\n            if (ri == NULL)\n                goto end;\n\n            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n            if (kparam != NULL) {\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n\n            res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,\n                                    EVP_PKEY_CTRL_CIPHER,\n                                    EVP_CIPHER_get_nid(cipher), NULL);\n            if (res <= 0 && res != -2)\n                goto end;\n\n            if (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\n                    && wrap_cipher != NULL) {\n                EVP_CIPHER_CTX *wctx;\n                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n                if (EVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL) != 1)\n                    goto end;\n            }\n        }\n\n        if (secret_key != NULL) {\n            if (!CMS_add0_recipient_key(cms, NID_undef,\n                                        secret_key, secret_keylen,\n                                        secret_keyid, secret_keyidlen,\n                                        NULL, NULL, NULL))\n                goto end;\n            /* NULL these because call absorbs them */\n            secret_key = NULL;\n            secret_keyid = NULL;\n        }\n        if (pwri_pass != NULL) {\n            pwri_tmp = (unsigned char *)OPENSSL_strdup((char *)pwri_pass);\n            if (pwri_tmp == NULL)\n                goto end;\n            if (CMS_add0_recipient_password(cms,\n                                            -1, NID_undef, NID_undef,\n                                            pwri_tmp, -1, NULL) == NULL)\n                goto end;\n            pwri_tmp = NULL;\n        }\n        if (!(flags & CMS_STREAM)) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\n        cms = CMS_EncryptedData_encrypt_ex(in, cipher, secret_key,\n                                           secret_keylen, flags, libctx, app_get0_propq());\n\n    } else if (operation == SMIME_SIGN_RECEIPT) {\n        CMS_ContentInfo *srcms = NULL;\n        STACK_OF(CMS_SignerInfo) *sis;\n        CMS_SignerInfo *si;\n        sis = CMS_get0_SignerInfos(cms);\n        if (sis == NULL)\n            goto end;\n        si = sk_CMS_SignerInfo_value(sis, 0);\n        srcms = CMS_sign_receipt(si, signer, key, other, flags);\n        if (srcms == NULL)\n            goto end;\n        CMS_ContentInfo_free(cms);\n        cms = srcms;\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content and not signing pre-computed digest, we\n         * enable streaming if S/MIME output format.\n         */\n        if (operation == SMIME_SIGN) {\n\n            if ((flags & CMS_DETACHED) != 0 && digestbin == NULL) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= CMS_STREAM;\n            }\n            flags |= CMS_PARTIAL;\n            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (cms == NULL)\n                goto end;\n            if (econtent_type != NULL)\n                CMS_set1_eContentType(cms, econtent_type);\n\n            if (rr_to != NULL\n                && ((rr = make_receipt_request(rr_to, rr_allorfirst, rr_from))\n                    == NULL)) {\n                BIO_puts(bio_err, \"Signed Receipt Request Creation Error\\n\");\n                goto end;\n            }\n        } else {\n            flags |= CMS_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            CMS_SignerInfo *si;\n            cms_key_param *kparam;\n            int tflags = flags;\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL) {\n                ret = 2;\n                goto end;\n            }\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL) {\n                ret = 2;\n                goto end;\n            }\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    tflags |= CMS_KEY_PARAM;\n                    break;\n                }\n            }\n            si = CMS_add1_signer(cms, signer, key, sign_md, tflags);\n            if (si == NULL)\n                goto end;\n            if (kparam != NULL) {\n                EVP_PKEY_CTX *pctx;\n                pctx = CMS_SignerInfo_get0_pkey_ctx(si);\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n            if (rr != NULL && !CMS_add1_ReceiptRequest(si, rr))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if (operation == SMIME_SIGN && digestbin != NULL\n            && (flags & CMS_STREAM) == 0) {\n            /* Use pre-computed digest instead of content */\n            if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))\n                goto end;\n        } else if (operation == SMIME_SIGN && (flags & CMS_STREAM) == 0) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    }\n\n    if (cms == NULL) {\n        BIO_printf(bio_err, \"Error creating CMS structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (flags & CMS_DEBUG_DECRYPT)\n            CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\n\n        if (secret_key != NULL) {\n            if (!CMS_decrypt_set1_key(cms,\n                                      secret_key, secret_keylen,\n                                      secret_keyid, secret_keyidlen)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\n                goto end;\n            }\n        }\n\n        if (key != NULL) {\n            if (!CMS_decrypt_set1_pkey_and_peer(cms, key, recip, originator)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\n                goto end;\n            }\n        }\n\n        if (pwri_pass != NULL) {\n            if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\n                goto end;\n            }\n        }\n\n        if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_DATA_OUT) {\n        if (!CMS_data(cms, out, flags))\n            goto end;\n    } else if (operation == SMIME_UNCOMPRESS) {\n        if (!CMS_uncompress(cms, indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_DIGEST_VERIFY) {\n        if (CMS_digest_verify(cms, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_DECRYPT) {\n        if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\n                                       indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_VERIFY) {\n        if (CMS_verify(cms, other, store, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"%s Verification successful\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n        } else {\n            BIO_printf(bio_err, \"%s Verification failure\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n            if (verify_retcode)\n                ret = verify_err + 32;\n            goto end;\n        }\n        if (signerfile != NULL) {\n            STACK_OF(X509) *signers = CMS_get0_signers(cms);\n\n            if (!save_certs(signerfile, signers)) {\n                BIO_printf(bio_err,\n                           \"Error writing signers to %s\\n\", signerfile);\n                ret = 5;\n                goto end;\n            }\n            sk_X509_free(signers);\n        }\n        if (rr_print)\n            receipt_request_print(cms);\n\n    } else if (operation == SMIME_VERIFY_RECEIPT) {\n        if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else {\n        if (noout) {\n            if (print) {\n                ASN1_PCTX *pctx = NULL;\n                if (get_nameopt() != XN_FLAG_ONELINE) {\n                    pctx = ASN1_PCTX_new();\n                    if (pctx != NULL) { /* Print anyway if malloc failed */\n                        ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT);\n                        ASN1_PCTX_set_str_flags(pctx, get_nameopt());\n                        ASN1_PCTX_set_nm_flags(pctx, get_nameopt());\n                    }\n                }\n                CMS_ContentInfo_print_ctx(out, cms, 0, pctx);\n                ASN1_PCTX_free(pctx);\n            }\n        } else if (outformat == FORMAT_SMIME) {\n            if (to)\n                BIO_printf(out, \"To: %s%s\", to, mime_eol);\n            if (from)\n                BIO_printf(out, \"From: %s%s\", from, mime_eol);\n            if (subject)\n                BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n            if (operation == SMIME_RESIGN)\n                ret = SMIME_write_CMS(out, cms, indata, flags);\n            else\n                ret = SMIME_write_CMS(out, cms, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            ret = PEM_write_bio_CMS_stream(out, cms, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            ret = i2d_CMS_bio_stream(out, cms, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for CMS file\\n\");\n            goto end;\n        }\n        if (ret <= 0) {\n            ret = 6;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    OPENSSL_free(secret_key);\n    OPENSSL_free(secret_keyid);\n    OPENSSL_free(pwri_tmp);\n    ASN1_OBJECT_free(econtent_type);\n    CMS_ReceiptRequest_free(rr);\n    sk_OPENSSL_STRING_free(rr_to);\n    sk_OPENSSL_STRING_free(rr_from);\n    for (key_param = key_first; key_param;) {\n        cms_key_param *tparam;\n        sk_OPENSSL_STRING_free(key_param->param);\n        tparam = key_param->next;\n        OPENSSL_free(key_param);\n        key_param = tparam;\n    }\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_CIPHER_free(cipher);\n    EVP_CIPHER_free(wrap_cipher);\n    EVP_MD_free(sign_md);\n    CMS_ContentInfo_free(cms);\n    CMS_ContentInfo_free(rcms);\n    release_engine(e);\n    BIO_free(rctin);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(digestbin);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))",
        "final_sink": "if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))",
        "source": [
            "    irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row space\");"
        ],
        "index": 10
    },
    {
        "prt": "cms",
        "function_call": [
            "int cms_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ASN1_OBJECT *econtent_type = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\n    CMS_ContentInfo *cms = NULL, *rcms = NULL;\n    CMS_ReceiptRequest *rr = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *key = NULL;\n    EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = sk_X509_new_null(), *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL, *originator = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = X509_VERIFY_PARAM_new();\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *certsoutfile = NULL, *digestname = NULL, *wrapname = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    char *digesthex = NULL;\n    unsigned char *digestbin = NULL;\n    long digestlen = 0;\n    char *infile = NULL, *outfile = NULL, *rctfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *signerfile = NULL;\n    char *originatorfile = NULL, *recipfile = NULL, *ciphername = NULL;\n    char *to = NULL, *from = NULL, *subject = NULL, *prog;\n    cms_key_param *key_first = NULL, *key_param = NULL;\n    int flags = CMS_DETACHED, binary_files = 0;\n    int noout = 0, print = 0, keyidx = -1, vpmtouched = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\n    int operation = 0, ret = 1, rr_print = 0, rr_allorfirst = -1;\n    int verify_retcode = 0, rctformat = FORMAT_SMIME, keyform = FORMAT_UNDEF;\n    size_t secret_keylen = 0, secret_keyidlen = 0;\n    unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\n    unsigned char *secret_key = NULL, *secret_keyid = NULL;\n    long ltmp;\n    const char *mime_eol = \"\\n\";\n    OPTION_CHOICE o;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if (encerts == NULL || vpm == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, cms_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(cms_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n\n        case OPT_ENCRYPT:\n            operation = SMIME_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            operation = SMIME_DECRYPT;\n            break;\n        case OPT_SIGN:\n            operation = SMIME_SIGN;\n            break;\n        case OPT_VERIFY:\n            operation = SMIME_VERIFY;\n            break;\n        case OPT_RESIGN:\n            operation = SMIME_RESIGN;\n            break;\n        case OPT_SIGN_RECEIPT:\n            operation = SMIME_SIGN_RECEIPT;\n            break;\n        case OPT_VERIFY_RECEIPT:\n            operation = SMIME_VERIFY_RECEIPT;\n            rctfile = opt_arg();\n            break;\n        case OPT_VERIFY_RETCODE:\n            verify_retcode = 1;\n            break;\n        case OPT_DIGEST_CREATE:\n            operation = SMIME_DIGEST_CREATE;\n            break;\n        case OPT_DIGEST:\n            digesthex = opt_arg();\n            break;\n        case OPT_DIGEST_VERIFY:\n            operation = SMIME_DIGEST_VERIFY;\n            break;\n        case OPT_COMPRESS:\n            operation = SMIME_COMPRESS;\n            break;\n        case OPT_UNCOMPRESS:\n            operation = SMIME_UNCOMPRESS;\n            break;\n        case OPT_ED_ENCRYPT:\n            operation = SMIME_ENCRYPTED_ENCRYPT;\n            break;\n        case OPT_ED_DECRYPT:\n            operation = SMIME_ENCRYPTED_DECRYPT;\n            break;\n        case OPT_DATA_CREATE:\n            operation = SMIME_DATA_CREATE;\n            break;\n        case OPT_DATA_OUT:\n            operation = SMIME_DATA_OUT;\n            break;\n        case OPT_CMSOUT:\n            operation = SMIME_CMSOUT;\n            break;\n\n        case OPT_DEBUG_DECRYPT:\n            flags |= CMS_DEBUG_DECRYPT;\n            break;\n        case OPT_TEXT:\n            flags |= CMS_TEXT;\n            break;\n        case OPT_ASCIICRLF:\n            flags |= CMS_ASCIICRLF;\n            break;\n        case OPT_NOINTERN:\n            flags |= CMS_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= CMS_NO_SIGNER_CERT_VERIFY;\n            break;\n        case OPT_NOCERTS:\n            flags |= CMS_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= CMS_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~CMS_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= CMS_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= CMS_BINARY;\n            break;\n        case OPT_CADES:\n            flags |= CMS_CADES;\n            break;\n        case OPT_KEYID:\n            flags |= CMS_USE_KEYID;\n            break;\n        case OPT_NOSIGS:\n            flags |= CMS_NOSIGS;\n            break;\n        case OPT_NO_CONTENT_VERIFY:\n            flags |= CMS_NO_CONTENT_VERIFY;\n            break;\n        case OPT_NO_ATTR_VERIFY:\n            flags |= CMS_NO_ATTR_VERIFY;\n            break;\n        case OPT_INDEF:\n            flags |= CMS_STREAM;\n            break;\n        case OPT_NOINDEF:\n            flags &= ~CMS_STREAM;\n            break;\n        case OPT_CRLFEOL:\n            mime_eol = \"\\r\\n\";\n            flags |= CMS_CRLFEOL;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_RR_PRINT:\n            rr_print = 1;\n            break;\n        case OPT_RR_ALL:\n            rr_allorfirst = 0;\n            break;\n        case OPT_RR_FIRST:\n            rr_allorfirst = 1;\n            break;\n        case OPT_RCTFORM:\n            if (!opt_format(opt_arg(),\n                            OPT_FMT_PEMDER | OPT_FMT_SMIME, &rctformat))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_RR_FROM:\n            if (rr_from == NULL\n                && (rr_from = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_from, opt_arg());\n            break;\n        case OPT_RR_TO:\n            if (rr_to == NULL\n                && (rr_to = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_to, opt_arg());\n            break;\n        case OPT_PRINT:\n            noout = print = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SECRETKEY:\n            if (secret_key != NULL) {\n                BIO_printf(bio_err, \"Invalid key (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_key = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_key == NULL) {\n                BIO_printf(bio_err, \"Invalid key %s\\n\", opt_arg());\n                goto end;\n            }\n            secret_keylen = (size_t)ltmp;\n            break;\n        case OPT_SECRETKEYID:\n            if (secret_keyid != NULL) {\n                BIO_printf(bio_err, \"Invalid id (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_keyid = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_keyid == NULL) {\n                BIO_printf(bio_err, \"Invalid id %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            secret_keyidlen = (size_t)ltmp;\n            break;\n        case OPT_PWRI_PASSWORD:\n            pwri_pass = (unsigned char *)opt_arg();\n            break;\n        case OPT_ECONTENT_TYPE:\n            if (econtent_type != NULL) {\n                BIO_printf(bio_err, \"Invalid OID (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            econtent_type = OBJ_txt2obj(opt_arg(), 0);\n            if (econtent_type == NULL) {\n                BIO_printf(bio_err, \"Invalid OID %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_CERTSOUT:\n            certsoutfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_ORIGINATOR:\n            originatorfile = opt_arg();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n                    goto end;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_RECIP:\n            if (operation == SMIME_ENCRYPT) {\n                cert = load_cert(opt_arg(), FORMAT_UNDEF,\n                                 \"recipient certificate file\");\n                if (cert == NULL)\n                    goto end;\n                if (!sk_X509_push(encerts, cert))\n                    goto end;\n                cert = NULL;\n            } else {\n                recipfile = opt_arg();\n            }\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_KEYOPT:\n            keyidx = -1;\n            if (operation == SMIME_ENCRYPT) {\n                if (sk_X509_num(encerts) > 0)\n                    keyidx += sk_X509_num(encerts);\n            } else {\n                if (keyfile != NULL || signerfile != NULL)\n                    keyidx++;\n                if (skkeys != NULL)\n                    keyidx += sk_OPENSSL_STRING_num(skkeys);\n            }\n            if (keyidx < 0) {\n                BIO_printf(bio_err, \"No key specified\\n\");\n                goto opthelp;\n            }\n            if (key_param == NULL || key_param->idx != keyidx) {\n                cms_key_param *nparam;\n                nparam = app_malloc(sizeof(*nparam), \"key param buffer\");\n                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {\n                    OPENSSL_free(nparam);\n                    goto end;\n                }\n                nparam->idx = keyidx;\n                nparam->next = NULL;\n                if (key_first == NULL)\n                    key_first = nparam;\n                else\n                    key_param->next = nparam;\n                key_param = nparam;\n            }\n            sk_OPENSSL_STRING_push(key_param->param, opt_arg());\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_WRAP:\n            wrapname = opt_arg();\n            break;\n        case OPT_AES128_WRAP:\n        case OPT_AES192_WRAP:\n        case OPT_AES256_WRAP:\n        case OPT_3DES_WRAP:\n            wrapname = opt_flag() + 1;\n            break;\n        }\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto end;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n        goto end;\n    if (wrapname != NULL) {\n        if (!opt_cipher_any(wrapname, &wrap_cipher))\n            goto end;\n    }\n\n    /* Remaining args are files to process. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((rr_allorfirst != -1 || rr_from != NULL) && rr_to == NULL) {\n        BIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\n        goto opthelp;\n    }\n\n    if (!(operation & SMIME_SIGNERS) && (rr_to != NULL || rr_from != NULL)) {\n        BIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\n        goto opthelp;\n    }\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n\n    if ((flags & CMS_CADES) != 0) {\n        if ((flags & CMS_NOATTR) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: \"\n                     \"CAdES requires signed attributes\\n\");\n            goto opthelp;\n        }\n        if (operation == SMIME_VERIFY\n                && (flags & (CMS_NO_SIGNER_CERT_VERIFY | CMS_NO_ATTR_VERIFY)) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: CAdES validation requires\"\n                     \" certs and signed attributes validations\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        if (keyfile != NULL && signerfile == NULL) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        /* Check to see if any final signer needs to be appended */\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (skkeys == NULL && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (keyfile == NULL)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL\n            && secret_key == NULL && pwri_pass == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (*argv == NULL && secret_key == NULL\n            && pwri_pass == NULL && sk_X509_num(encerts) <= 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    } else if (!operation) {\n        BIO_printf(bio_err, \"No operation option (-encrypt|-decrypt|-sign|-verify|...) specified.\\n\");\n        goto opthelp;\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if ((operation & SMIME_SIGNERS) == 0) {\n        if ((flags & CMS_DETACHED) == 0)\n            BIO_printf(bio_err,\n                       \"Warning: -nodetach option is ignored for non-signing operation\\n\");\n\n        flags &= ~CMS_DETACHED;\n    }\n    if ((operation & SMIME_IP) == 0 && contfile != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: -contfile option is ignored for the given operation\\n\");\n    if (operation != SMIME_ENCRYPT && *argv != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: recipient certificate file parameters ignored for operation other than -encrypt\\n\");\n\n    if ((flags & CMS_BINARY) != 0) {\n        if (!(operation & SMIME_OP))\n            outformat = FORMAT_BINARY;\n        if (!(operation & SMIME_IP))\n            informat = FORMAT_BINARY;\n        if ((operation & SMIME_SIGNERS) != 0 && (flags & CMS_DETACHED) != 0)\n            binary_files = 1;\n        if ((operation & SMIME_IP) != 0 && contfile == NULL)\n            binary_files = 1;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (!cipher)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        if (secret_key && !secret_keyid) {\n            BIO_printf(bio_err, \"No secret key id\\n\");\n            goto end;\n        }\n\n        for (; *argv != NULL; argv++) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificate file\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (originatorfile != NULL) {\n        if ((originator = load_cert(originatorfile, FORMAT_UNDEF,\n                                    \"originator certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_SIGN_RECEIPT) {\n        if ((signer = load_cert(signerfile, FORMAT_UNDEF,\n                                \"receipt signer certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((operation == SMIME_DECRYPT) || (operation == SMIME_ENCRYPT)) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (digesthex != NULL) {\n        if (operation != SMIME_SIGN) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest for non-signing operation\\n\");\n            goto end;\n        }\n        if (infile != NULL\n            || (flags & CMS_DETACHED) == 0\n            || (flags & CMS_STREAM) != 0) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest when -in, -nodetach or streaming is used\\n\");\n            goto end;\n        }\n        digestbin = OPENSSL_hexstr2buf(digesthex, &digestlen);\n        if (digestbin == NULL) {\n            BIO_printf(bio_err,\n                       \"Invalid hex value after -digest\\n\");\n            goto end;\n        }\n    } else {\n        in = bio_open_default(infile, 'r',\n                              binary_files ? FORMAT_BINARY : informat);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (operation & SMIME_IP) {\n        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");\n        if (cms == NULL)\n            goto end;\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n        if (certsoutfile != NULL) {\n            STACK_OF(X509) *allcerts;\n            allcerts = CMS_get1_certs(cms);\n            if (!save_certs(certsoutfile, allcerts)) {\n                BIO_printf(bio_err,\n                           \"Error writing certs to %s\\n\", certsoutfile);\n                ret = 5;\n                goto end;\n            }\n            OSSL_STACK_OF_X509_free(allcerts);\n        }\n    }\n\n    if (rctfile != NULL) {\n        char *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\n\n        if ((rctin = BIO_new_file(rctfile, rctmode)) == NULL) {\n            BIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\n            goto end;\n        }\n\n        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");\n        if (rcms == NULL)\n            goto end;\n    }\n\n    out = bio_open_default(outfile, 'w',\n                           binary_files ? FORMAT_BINARY : outformat);\n    if (out == NULL)\n        goto end;\n\n    if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, cms_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_DATA_CREATE) {\n        cms = CMS_data_create_ex(in, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_DIGEST_CREATE) {\n        cms = CMS_digest_create_ex(in, sign_md, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_COMPRESS) {\n        cms = CMS_compress(in, -1, flags);\n    } else if (operation == SMIME_ENCRYPT) {\n        int i;\n        flags |= CMS_PARTIAL;\n        cms = CMS_encrypt_ex(NULL, in, cipher, flags, libctx, app_get0_propq());\n        if (cms == NULL)\n            goto end;\n        for (i = 0; i < sk_X509_num(encerts); i++) {\n            CMS_RecipientInfo *ri;\n            cms_key_param *kparam;\n            int tflags = flags | CMS_KEY_PARAM;\n            /* This flag enforces allocating the EVP_PKEY_CTX for the recipient here */\n            EVP_PKEY_CTX *pctx;\n            X509 *x = sk_X509_value(encerts, i);\n            int res;\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    break;\n                }\n            }\n            ri = CMS_add1_recipient(cms, x, key, originator, tflags);\n            if (ri == NULL)\n                goto end;\n\n            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n            if (kparam != NULL) {\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n\n            res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,\n                                    EVP_PKEY_CTRL_CIPHER,\n                                    EVP_CIPHER_get_nid(cipher), NULL);\n            if (res <= 0 && res != -2)\n                goto end;\n\n            if (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\n                    && wrap_cipher != NULL) {\n                EVP_CIPHER_CTX *wctx;\n                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n                if (EVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL) != 1)\n                    goto end;\n            }\n        }\n\n        if (secret_key != NULL) {\n            if (!CMS_add0_recipient_key(cms, NID_undef,\n                                        secret_key, secret_keylen,\n                                        secret_keyid, secret_keyidlen,\n                                        NULL, NULL, NULL))\n                goto end;\n            /* NULL these because call absorbs them */\n            secret_key = NULL;\n            secret_keyid = NULL;\n        }\n        if (pwri_pass != NULL) {\n            pwri_tmp = (unsigned char *)OPENSSL_strdup((char *)pwri_pass);\n            if (pwri_tmp == NULL)\n                goto end;\n            if (CMS_add0_recipient_password(cms,\n                                            -1, NID_undef, NID_undef,\n                                            pwri_tmp, -1, NULL) == NULL)\n                goto end;\n            pwri_tmp = NULL;\n        }\n        if (!(flags & CMS_STREAM)) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\n        cms = CMS_EncryptedData_encrypt_ex(in, cipher, secret_key,\n                                           secret_keylen, flags, libctx, app_get0_propq());\n\n    } else if (operation == SMIME_SIGN_RECEIPT) {\n        CMS_ContentInfo *srcms = NULL;\n        STACK_OF(CMS_SignerInfo) *sis;\n        CMS_SignerInfo *si;\n        sis = CMS_get0_SignerInfos(cms);\n        if (sis == NULL)\n            goto end;\n        si = sk_CMS_SignerInfo_value(sis, 0);\n        srcms = CMS_sign_receipt(si, signer, key, other, flags);\n        if (srcms == NULL)\n            goto end;\n        CMS_ContentInfo_free(cms);\n        cms = srcms;\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content and not signing pre-computed digest, we\n         * enable streaming if S/MIME output format.\n         */\n        if (operation == SMIME_SIGN) {\n\n            if ((flags & CMS_DETACHED) != 0 && digestbin == NULL) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= CMS_STREAM;\n            }\n            flags |= CMS_PARTIAL;\n            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (cms == NULL)\n                goto end;\n            if (econtent_type != NULL)\n                CMS_set1_eContentType(cms, econtent_type);\n\n            if (rr_to != NULL\n                && ((rr = make_receipt_request(rr_to, rr_allorfirst, rr_from))\n                    == NULL)) {\n                BIO_puts(bio_err, \"Signed Receipt Request Creation Error\\n\");\n                goto end;\n            }\n        } else {\n            flags |= CMS_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            CMS_SignerInfo *si;\n            cms_key_param *kparam;\n            int tflags = flags;\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL) {\n                ret = 2;\n                goto end;\n            }\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL) {\n                ret = 2;\n                goto end;\n            }\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    tflags |= CMS_KEY_PARAM;\n                    break;\n                }\n            }\n            si = CMS_add1_signer(cms, signer, key, sign_md, tflags);\n            if (si == NULL)\n                goto end;\n            if (kparam != NULL) {\n                EVP_PKEY_CTX *pctx;\n                pctx = CMS_SignerInfo_get0_pkey_ctx(si);\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n            if (rr != NULL && !CMS_add1_ReceiptRequest(si, rr))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if (operation == SMIME_SIGN && digestbin != NULL\n            && (flags & CMS_STREAM) == 0) {\n            /* Use pre-computed digest instead of content */\n            if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))\n                goto end;\n        } else if (operation == SMIME_SIGN && (flags & CMS_STREAM) == 0) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    }\n\n    if (cms == NULL) {\n        BIO_printf(bio_err, \"Error creating CMS structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (flags & CMS_DEBUG_DECRYPT)\n            CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\n\n        if (secret_key != NULL) {\n            if (!CMS_decrypt_set1_key(cms,\n                                      secret_key, secret_keylen,\n                                      secret_keyid, secret_keyidlen)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\n                goto end;\n            }\n        }\n\n        if (key != NULL) {\n            if (!CMS_decrypt_set1_pkey_and_peer(cms, key, recip, originator)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\n                goto end;\n            }\n        }\n\n        if (pwri_pass != NULL) {\n            if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\n                goto end;\n            }\n        }\n\n        if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_DATA_OUT) {\n        if (!CMS_data(cms, out, flags))\n            goto end;\n    } else if (operation == SMIME_UNCOMPRESS) {\n        if (!CMS_uncompress(cms, indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_DIGEST_VERIFY) {\n        if (CMS_digest_verify(cms, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_DECRYPT) {\n        if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\n                                       indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_VERIFY) {\n        if (CMS_verify(cms, other, store, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"%s Verification successful\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n        } else {\n            BIO_printf(bio_err, \"%s Verification failure\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n            if (verify_retcode)\n                ret = verify_err + 32;\n            goto end;\n        }\n        if (signerfile != NULL) {\n            STACK_OF(X509) *signers = CMS_get0_signers(cms);\n\n            if (!save_certs(signerfile, signers)) {\n                BIO_printf(bio_err,\n                           \"Error writing signers to %s\\n\", signerfile);\n                ret = 5;\n                goto end;\n            }\n            sk_X509_free(signers);\n        }\n        if (rr_print)\n            receipt_request_print(cms);\n\n    } else if (operation == SMIME_VERIFY_RECEIPT) {\n        if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else {\n        if (noout) {\n            if (print) {\n                ASN1_PCTX *pctx = NULL;\n                if (get_nameopt() != XN_FLAG_ONELINE) {\n                    pctx = ASN1_PCTX_new();\n                    if (pctx != NULL) { /* Print anyway if malloc failed */\n                        ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT);\n                        ASN1_PCTX_set_str_flags(pctx, get_nameopt());\n                        ASN1_PCTX_set_nm_flags(pctx, get_nameopt());\n                    }\n                }\n                CMS_ContentInfo_print_ctx(out, cms, 0, pctx);\n                ASN1_PCTX_free(pctx);\n            }\n        } else if (outformat == FORMAT_SMIME) {\n            if (to)\n                BIO_printf(out, \"To: %s%s\", to, mime_eol);\n            if (from)\n                BIO_printf(out, \"From: %s%s\", from, mime_eol);\n            if (subject)\n                BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n            if (operation == SMIME_RESIGN)\n                ret = SMIME_write_CMS(out, cms, indata, flags);\n            else\n                ret = SMIME_write_CMS(out, cms, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            ret = PEM_write_bio_CMS_stream(out, cms, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            ret = i2d_CMS_bio_stream(out, cms, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for CMS file\\n\");\n            goto end;\n        }\n        if (ret <= 0) {\n            ret = 6;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    OPENSSL_free(secret_key);\n    OPENSSL_free(secret_keyid);\n    OPENSSL_free(pwri_tmp);\n    ASN1_OBJECT_free(econtent_type);\n    CMS_ReceiptRequest_free(rr);\n    sk_OPENSSL_STRING_free(rr_to);\n    sk_OPENSSL_STRING_free(rr_from);\n    for (key_param = key_first; key_param;) {\n        cms_key_param *tparam;\n        sk_OPENSSL_STRING_free(key_param->param);\n        tparam = key_param->next;\n        OPENSSL_free(key_param);\n        key_param = tparam;\n    }\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_CIPHER_free(cipher);\n    EVP_CIPHER_free(wrap_cipher);\n    EVP_MD_free(sign_md);\n    CMS_ContentInfo_free(cms);\n    CMS_ContentInfo_free(rcms);\n    release_engine(e);\n    BIO_free(rctin);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(digestbin);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "if (!CMS_final(cms, in, NULL, flags))",
        "final_sink": "if (!CMS_final(cms, in, NULL, flags))",
        "source": [
            "    irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row space\");"
        ],
        "index": 11
    },
    {
        "prt": "rcms",
        "function_call": [
            "int cms_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ASN1_OBJECT *econtent_type = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL, *rctin = NULL;\n    CMS_ContentInfo *cms = NULL, *rcms = NULL;\n    CMS_ReceiptRequest *rr = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *key = NULL;\n    EVP_CIPHER *cipher = NULL, *wrap_cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rr_to = NULL, *rr_from = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = sk_X509_new_null(), *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL, *originator = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = X509_VERIFY_PARAM_new();\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *certsoutfile = NULL, *digestname = NULL, *wrapname = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    char *digesthex = NULL;\n    unsigned char *digestbin = NULL;\n    long digestlen = 0;\n    char *infile = NULL, *outfile = NULL, *rctfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *signerfile = NULL;\n    char *originatorfile = NULL, *recipfile = NULL, *ciphername = NULL;\n    char *to = NULL, *from = NULL, *subject = NULL, *prog;\n    cms_key_param *key_first = NULL, *key_param = NULL;\n    int flags = CMS_DETACHED, binary_files = 0;\n    int noout = 0, print = 0, keyidx = -1, vpmtouched = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME;\n    int operation = 0, ret = 1, rr_print = 0, rr_allorfirst = -1;\n    int verify_retcode = 0, rctformat = FORMAT_SMIME, keyform = FORMAT_UNDEF;\n    size_t secret_keylen = 0, secret_keyidlen = 0;\n    unsigned char *pwri_pass = NULL, *pwri_tmp = NULL;\n    unsigned char *secret_key = NULL, *secret_keyid = NULL;\n    long ltmp;\n    const char *mime_eol = \"\\n\";\n    OPTION_CHOICE o;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if (encerts == NULL || vpm == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, cms_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(cms_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n\n        case OPT_ENCRYPT:\n            operation = SMIME_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            operation = SMIME_DECRYPT;\n            break;\n        case OPT_SIGN:\n            operation = SMIME_SIGN;\n            break;\n        case OPT_VERIFY:\n            operation = SMIME_VERIFY;\n            break;\n        case OPT_RESIGN:\n            operation = SMIME_RESIGN;\n            break;\n        case OPT_SIGN_RECEIPT:\n            operation = SMIME_SIGN_RECEIPT;\n            break;\n        case OPT_VERIFY_RECEIPT:\n            operation = SMIME_VERIFY_RECEIPT;\n            rctfile = opt_arg();\n            break;\n        case OPT_VERIFY_RETCODE:\n            verify_retcode = 1;\n            break;\n        case OPT_DIGEST_CREATE:\n            operation = SMIME_DIGEST_CREATE;\n            break;\n        case OPT_DIGEST:\n            digesthex = opt_arg();\n            break;\n        case OPT_DIGEST_VERIFY:\n            operation = SMIME_DIGEST_VERIFY;\n            break;\n        case OPT_COMPRESS:\n            operation = SMIME_COMPRESS;\n            break;\n        case OPT_UNCOMPRESS:\n            operation = SMIME_UNCOMPRESS;\n            break;\n        case OPT_ED_ENCRYPT:\n            operation = SMIME_ENCRYPTED_ENCRYPT;\n            break;\n        case OPT_ED_DECRYPT:\n            operation = SMIME_ENCRYPTED_DECRYPT;\n            break;\n        case OPT_DATA_CREATE:\n            operation = SMIME_DATA_CREATE;\n            break;\n        case OPT_DATA_OUT:\n            operation = SMIME_DATA_OUT;\n            break;\n        case OPT_CMSOUT:\n            operation = SMIME_CMSOUT;\n            break;\n\n        case OPT_DEBUG_DECRYPT:\n            flags |= CMS_DEBUG_DECRYPT;\n            break;\n        case OPT_TEXT:\n            flags |= CMS_TEXT;\n            break;\n        case OPT_ASCIICRLF:\n            flags |= CMS_ASCIICRLF;\n            break;\n        case OPT_NOINTERN:\n            flags |= CMS_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= CMS_NO_SIGNER_CERT_VERIFY;\n            break;\n        case OPT_NOCERTS:\n            flags |= CMS_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= CMS_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~CMS_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= CMS_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= CMS_BINARY;\n            break;\n        case OPT_CADES:\n            flags |= CMS_CADES;\n            break;\n        case OPT_KEYID:\n            flags |= CMS_USE_KEYID;\n            break;\n        case OPT_NOSIGS:\n            flags |= CMS_NOSIGS;\n            break;\n        case OPT_NO_CONTENT_VERIFY:\n            flags |= CMS_NO_CONTENT_VERIFY;\n            break;\n        case OPT_NO_ATTR_VERIFY:\n            flags |= CMS_NO_ATTR_VERIFY;\n            break;\n        case OPT_INDEF:\n            flags |= CMS_STREAM;\n            break;\n        case OPT_NOINDEF:\n            flags &= ~CMS_STREAM;\n            break;\n        case OPT_CRLFEOL:\n            mime_eol = \"\\r\\n\";\n            flags |= CMS_CRLFEOL;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_RR_PRINT:\n            rr_print = 1;\n            break;\n        case OPT_RR_ALL:\n            rr_allorfirst = 0;\n            break;\n        case OPT_RR_FIRST:\n            rr_allorfirst = 1;\n            break;\n        case OPT_RCTFORM:\n            if (!opt_format(opt_arg(),\n                            OPT_FMT_PEMDER | OPT_FMT_SMIME, &rctformat))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_RR_FROM:\n            if (rr_from == NULL\n                && (rr_from = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_from, opt_arg());\n            break;\n        case OPT_RR_TO:\n            if (rr_to == NULL\n                && (rr_to = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(rr_to, opt_arg());\n            break;\n        case OPT_PRINT:\n            noout = print = 1;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SECRETKEY:\n            if (secret_key != NULL) {\n                BIO_printf(bio_err, \"Invalid key (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_key = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_key == NULL) {\n                BIO_printf(bio_err, \"Invalid key %s\\n\", opt_arg());\n                goto end;\n            }\n            secret_keylen = (size_t)ltmp;\n            break;\n        case OPT_SECRETKEYID:\n            if (secret_keyid != NULL) {\n                BIO_printf(bio_err, \"Invalid id (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            secret_keyid = OPENSSL_hexstr2buf(opt_arg(), &ltmp);\n            if (secret_keyid == NULL) {\n                BIO_printf(bio_err, \"Invalid id %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            secret_keyidlen = (size_t)ltmp;\n            break;\n        case OPT_PWRI_PASSWORD:\n            pwri_pass = (unsigned char *)opt_arg();\n            break;\n        case OPT_ECONTENT_TYPE:\n            if (econtent_type != NULL) {\n                BIO_printf(bio_err, \"Invalid OID (supplied twice) %s\\n\",\n                           opt_arg());\n                goto opthelp;\n            }\n            econtent_type = OBJ_txt2obj(opt_arg(), 0);\n            if (econtent_type == NULL) {\n                BIO_printf(bio_err, \"Invalid OID %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_CERTSOUT:\n            certsoutfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_ORIGINATOR:\n            originatorfile = opt_arg();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n                    goto end;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_RECIP:\n            if (operation == SMIME_ENCRYPT) {\n                cert = load_cert(opt_arg(), FORMAT_UNDEF,\n                                 \"recipient certificate file\");\n                if (cert == NULL)\n                    goto end;\n                if (!sk_X509_push(encerts, cert))\n                    goto end;\n                cert = NULL;\n            } else {\n                recipfile = opt_arg();\n            }\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_KEYOPT:\n            keyidx = -1;\n            if (operation == SMIME_ENCRYPT) {\n                if (sk_X509_num(encerts) > 0)\n                    keyidx += sk_X509_num(encerts);\n            } else {\n                if (keyfile != NULL || signerfile != NULL)\n                    keyidx++;\n                if (skkeys != NULL)\n                    keyidx += sk_OPENSSL_STRING_num(skkeys);\n            }\n            if (keyidx < 0) {\n                BIO_printf(bio_err, \"No key specified\\n\");\n                goto opthelp;\n            }\n            if (key_param == NULL || key_param->idx != keyidx) {\n                cms_key_param *nparam;\n                nparam = app_malloc(sizeof(*nparam), \"key param buffer\");\n                if ((nparam->param = sk_OPENSSL_STRING_new_null()) == NULL) {\n                    OPENSSL_free(nparam);\n                    goto end;\n                }\n                nparam->idx = keyidx;\n                nparam->next = NULL;\n                if (key_first == NULL)\n                    key_first = nparam;\n                else\n                    key_param->next = nparam;\n                key_param = nparam;\n            }\n            sk_OPENSSL_STRING_push(key_param->param, opt_arg());\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_WRAP:\n            wrapname = opt_arg();\n            break;\n        case OPT_AES128_WRAP:\n        case OPT_AES192_WRAP:\n        case OPT_AES256_WRAP:\n        case OPT_3DES_WRAP:\n            wrapname = opt_flag() + 1;\n            break;\n        }\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto end;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n        goto end;\n    if (wrapname != NULL) {\n        if (!opt_cipher_any(wrapname, &wrap_cipher))\n            goto end;\n    }\n\n    /* Remaining args are files to process. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if ((rr_allorfirst != -1 || rr_from != NULL) && rr_to == NULL) {\n        BIO_puts(bio_err, \"No Signed Receipts Recipients\\n\");\n        goto opthelp;\n    }\n\n    if (!(operation & SMIME_SIGNERS) && (rr_to != NULL || rr_from != NULL)) {\n        BIO_puts(bio_err, \"Signed receipts only allowed with -sign\\n\");\n        goto opthelp;\n    }\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n\n    if ((flags & CMS_CADES) != 0) {\n        if ((flags & CMS_NOATTR) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: \"\n                     \"CAdES requires signed attributes\\n\");\n            goto opthelp;\n        }\n        if (operation == SMIME_VERIFY\n                && (flags & (CMS_NO_SIGNER_CERT_VERIFY | CMS_NO_ATTR_VERIFY)) != 0) {\n            BIO_puts(bio_err, \"Incompatible options: CAdES validation requires\"\n                     \" certs and signed attributes validations\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        if (keyfile != NULL && signerfile == NULL) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        /* Check to see if any final signer needs to be appended */\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (skkeys == NULL && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (keyfile == NULL)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL\n            && secret_key == NULL && pwri_pass == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (*argv == NULL && secret_key == NULL\n            && pwri_pass == NULL && sk_X509_num(encerts) <= 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    } else if (!operation) {\n        BIO_printf(bio_err, \"No operation option (-encrypt|-decrypt|-sign|-verify|...) specified.\\n\");\n        goto opthelp;\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if ((operation & SMIME_SIGNERS) == 0) {\n        if ((flags & CMS_DETACHED) == 0)\n            BIO_printf(bio_err,\n                       \"Warning: -nodetach option is ignored for non-signing operation\\n\");\n\n        flags &= ~CMS_DETACHED;\n    }\n    if ((operation & SMIME_IP) == 0 && contfile != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: -contfile option is ignored for the given operation\\n\");\n    if (operation != SMIME_ENCRYPT && *argv != NULL)\n        BIO_printf(bio_err,\n                   \"Warning: recipient certificate file parameters ignored for operation other than -encrypt\\n\");\n\n    if ((flags & CMS_BINARY) != 0) {\n        if (!(operation & SMIME_OP))\n            outformat = FORMAT_BINARY;\n        if (!(operation & SMIME_IP))\n            informat = FORMAT_BINARY;\n        if ((operation & SMIME_SIGNERS) != 0 && (flags & CMS_DETACHED) != 0)\n            binary_files = 1;\n        if ((operation & SMIME_IP) != 0 && contfile == NULL)\n            binary_files = 1;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (!cipher)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        if (secret_key && !secret_keyid) {\n            BIO_printf(bio_err, \"No secret key id\\n\");\n            goto end;\n        }\n\n        for (; *argv != NULL; argv++) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificate file\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (originatorfile != NULL) {\n        if ((originator = load_cert(originatorfile, FORMAT_UNDEF,\n                                    \"originator certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_SIGN_RECEIPT) {\n        if ((signer = load_cert(signerfile, FORMAT_UNDEF,\n                                \"receipt signer certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if ((operation == SMIME_DECRYPT) || (operation == SMIME_ENCRYPT)) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if ((operation == SMIME_SIGN) || (operation == SMIME_SIGN_RECEIPT)) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (digesthex != NULL) {\n        if (operation != SMIME_SIGN) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest for non-signing operation\\n\");\n            goto end;\n        }\n        if (infile != NULL\n            || (flags & CMS_DETACHED) == 0\n            || (flags & CMS_STREAM) != 0) {\n            BIO_printf(bio_err,\n                       \"Cannot use -digest when -in, -nodetach or streaming is used\\n\");\n            goto end;\n        }\n        digestbin = OPENSSL_hexstr2buf(digesthex, &digestlen);\n        if (digestbin == NULL) {\n            BIO_printf(bio_err,\n                       \"Invalid hex value after -digest\\n\");\n            goto end;\n        }\n    } else {\n        in = bio_open_default(infile, 'r',\n                              binary_files ? FORMAT_BINARY : informat);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (operation & SMIME_IP) {\n        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");\n        if (cms == NULL)\n            goto end;\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n        if (certsoutfile != NULL) {\n            STACK_OF(X509) *allcerts;\n            allcerts = CMS_get1_certs(cms);\n            if (!save_certs(certsoutfile, allcerts)) {\n                BIO_printf(bio_err,\n                           \"Error writing certs to %s\\n\", certsoutfile);\n                ret = 5;\n                goto end;\n            }\n            OSSL_STACK_OF_X509_free(allcerts);\n        }\n    }\n\n    if (rctfile != NULL) {\n        char *rctmode = (rctformat == FORMAT_ASN1) ? \"rb\" : \"r\";\n\n        if ((rctin = BIO_new_file(rctfile, rctmode)) == NULL) {\n            BIO_printf(bio_err, \"Can't open receipt file %s\\n\", rctfile);\n            goto end;\n        }\n\n        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");\n        if (rcms == NULL)\n            goto end;\n    }\n\n    out = bio_open_default(outfile, 'w',\n                           binary_files ? FORMAT_BINARY : outformat);\n    if (out == NULL)\n        goto end;\n\n    if ((operation == SMIME_VERIFY) || (operation == SMIME_VERIFY_RECEIPT)) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, cms_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_DATA_CREATE) {\n        cms = CMS_data_create_ex(in, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_DIGEST_CREATE) {\n        cms = CMS_digest_create_ex(in, sign_md, flags, libctx, app_get0_propq());\n    } else if (operation == SMIME_COMPRESS) {\n        cms = CMS_compress(in, -1, flags);\n    } else if (operation == SMIME_ENCRYPT) {\n        int i;\n        flags |= CMS_PARTIAL;\n        cms = CMS_encrypt_ex(NULL, in, cipher, flags, libctx, app_get0_propq());\n        if (cms == NULL)\n            goto end;\n        for (i = 0; i < sk_X509_num(encerts); i++) {\n            CMS_RecipientInfo *ri;\n            cms_key_param *kparam;\n            int tflags = flags | CMS_KEY_PARAM;\n            /* This flag enforces allocating the EVP_PKEY_CTX for the recipient here */\n            EVP_PKEY_CTX *pctx;\n            X509 *x = sk_X509_value(encerts, i);\n            int res;\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    break;\n                }\n            }\n            ri = CMS_add1_recipient(cms, x, key, originator, tflags);\n            if (ri == NULL)\n                goto end;\n\n            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);\n            if (kparam != NULL) {\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n\n            res = EVP_PKEY_CTX_ctrl(pctx, -1, -1,\n                                    EVP_PKEY_CTRL_CIPHER,\n                                    EVP_CIPHER_get_nid(cipher), NULL);\n            if (res <= 0 && res != -2)\n                goto end;\n\n            if (CMS_RecipientInfo_type(ri) == CMS_RECIPINFO_AGREE\n                    && wrap_cipher != NULL) {\n                EVP_CIPHER_CTX *wctx;\n                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);\n                if (EVP_EncryptInit_ex(wctx, wrap_cipher, NULL, NULL, NULL) != 1)\n                    goto end;\n            }\n        }\n\n        if (secret_key != NULL) {\n            if (!CMS_add0_recipient_key(cms, NID_undef,\n                                        secret_key, secret_keylen,\n                                        secret_keyid, secret_keyidlen,\n                                        NULL, NULL, NULL))\n                goto end;\n            /* NULL these because call absorbs them */\n            secret_key = NULL;\n            secret_keyid = NULL;\n        }\n        if (pwri_pass != NULL) {\n            pwri_tmp = (unsigned char *)OPENSSL_strdup((char *)pwri_pass);\n            if (pwri_tmp == NULL)\n                goto end;\n            if (CMS_add0_recipient_password(cms,\n                                            -1, NID_undef, NID_undef,\n                                            pwri_tmp, -1, NULL) == NULL)\n                goto end;\n            pwri_tmp = NULL;\n        }\n        if (!(flags & CMS_STREAM)) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_ENCRYPT) {\n        cms = CMS_EncryptedData_encrypt_ex(in, cipher, secret_key,\n                                           secret_keylen, flags, libctx, app_get0_propq());\n\n    } else if (operation == SMIME_SIGN_RECEIPT) {\n        CMS_ContentInfo *srcms = NULL;\n        STACK_OF(CMS_SignerInfo) *sis;\n        CMS_SignerInfo *si;\n        sis = CMS_get0_SignerInfos(cms);\n        if (sis == NULL)\n            goto end;\n        si = sk_CMS_SignerInfo_value(sis, 0);\n        srcms = CMS_sign_receipt(si, signer, key, other, flags);\n        if (srcms == NULL)\n            goto end;\n        CMS_ContentInfo_free(cms);\n        cms = srcms;\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content and not signing pre-computed digest, we\n         * enable streaming if S/MIME output format.\n         */\n        if (operation == SMIME_SIGN) {\n\n            if ((flags & CMS_DETACHED) != 0 && digestbin == NULL) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= CMS_STREAM;\n            }\n            flags |= CMS_PARTIAL;\n            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (cms == NULL)\n                goto end;\n            if (econtent_type != NULL)\n                CMS_set1_eContentType(cms, econtent_type);\n\n            if (rr_to != NULL\n                && ((rr = make_receipt_request(rr_to, rr_allorfirst, rr_from))\n                    == NULL)) {\n                BIO_puts(bio_err, \"Signed Receipt Request Creation Error\\n\");\n                goto end;\n            }\n        } else {\n            flags |= CMS_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            CMS_SignerInfo *si;\n            cms_key_param *kparam;\n            int tflags = flags;\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL) {\n                ret = 2;\n                goto end;\n            }\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL) {\n                ret = 2;\n                goto end;\n            }\n\n            for (kparam = key_first; kparam; kparam = kparam->next) {\n                if (kparam->idx == i) {\n                    tflags |= CMS_KEY_PARAM;\n                    break;\n                }\n            }\n            si = CMS_add1_signer(cms, signer, key, sign_md, tflags);\n            if (si == NULL)\n                goto end;\n            if (kparam != NULL) {\n                EVP_PKEY_CTX *pctx;\n                pctx = CMS_SignerInfo_get0_pkey_ctx(si);\n                if (!cms_set_pkey_param(pctx, kparam->param))\n                    goto end;\n            }\n            if (rr != NULL && !CMS_add1_ReceiptRequest(si, rr))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if (operation == SMIME_SIGN && digestbin != NULL\n            && (flags & CMS_STREAM) == 0) {\n            /* Use pre-computed digest instead of content */\n            if (!CMS_final_digest(cms, digestbin, digestlen, NULL, flags))\n                goto end;\n        } else if (operation == SMIME_SIGN && (flags & CMS_STREAM) == 0) {\n            if (!CMS_final(cms, in, NULL, flags))\n                goto end;\n        }\n    }\n\n    if (cms == NULL) {\n        BIO_printf(bio_err, \"Error creating CMS structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (flags & CMS_DEBUG_DECRYPT)\n            CMS_decrypt(cms, NULL, NULL, NULL, NULL, flags);\n\n        if (secret_key != NULL) {\n            if (!CMS_decrypt_set1_key(cms,\n                                      secret_key, secret_keylen,\n                                      secret_keyid, secret_keyidlen)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using secret key\\n\");\n                goto end;\n            }\n        }\n\n        if (key != NULL) {\n            if (!CMS_decrypt_set1_pkey_and_peer(cms, key, recip, originator)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using private key\\n\");\n                goto end;\n            }\n        }\n\n        if (pwri_pass != NULL) {\n            if (!CMS_decrypt_set1_password(cms, pwri_pass, -1)) {\n                BIO_puts(bio_err, \"Error decrypting CMS using password\\n\");\n                goto end;\n            }\n        }\n\n        if (!CMS_decrypt(cms, NULL, NULL, indata, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting CMS structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_DATA_OUT) {\n        if (!CMS_data(cms, out, flags))\n            goto end;\n    } else if (operation == SMIME_UNCOMPRESS) {\n        if (!CMS_uncompress(cms, indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_DIGEST_VERIFY) {\n        if (CMS_digest_verify(cms, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_ENCRYPTED_DECRYPT) {\n        if (!CMS_EncryptedData_decrypt(cms, secret_key, secret_keylen,\n                                       indata, out, flags))\n            goto end;\n    } else if (operation == SMIME_VERIFY) {\n        if (CMS_verify(cms, other, store, indata, out, flags) > 0) {\n            BIO_printf(bio_err, \"%s Verification successful\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n        } else {\n            BIO_printf(bio_err, \"%s Verification failure\\n\",\n                       (flags & CMS_CADES) != 0 ? \"CAdES\" : \"CMS\");\n            if (verify_retcode)\n                ret = verify_err + 32;\n            goto end;\n        }\n        if (signerfile != NULL) {\n            STACK_OF(X509) *signers = CMS_get0_signers(cms);\n\n            if (!save_certs(signerfile, signers)) {\n                BIO_printf(bio_err,\n                           \"Error writing signers to %s\\n\", signerfile);\n                ret = 5;\n                goto end;\n            }\n            sk_X509_free(signers);\n        }\n        if (rr_print)\n            receipt_request_print(cms);\n\n    } else if (operation == SMIME_VERIFY_RECEIPT) {\n        if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        } else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n    } else {\n        if (noout) {\n            if (print) {\n                ASN1_PCTX *pctx = NULL;\n                if (get_nameopt() != XN_FLAG_ONELINE) {\n                    pctx = ASN1_PCTX_new();\n                    if (pctx != NULL) { /* Print anyway if malloc failed */\n                        ASN1_PCTX_set_flags(pctx, ASN1_PCTX_FLAGS_SHOW_ABSENT);\n                        ASN1_PCTX_set_str_flags(pctx, get_nameopt());\n                        ASN1_PCTX_set_nm_flags(pctx, get_nameopt());\n                    }\n                }\n                CMS_ContentInfo_print_ctx(out, cms, 0, pctx);\n                ASN1_PCTX_free(pctx);\n            }\n        } else if (outformat == FORMAT_SMIME) {\n            if (to)\n                BIO_printf(out, \"To: %s%s\", to, mime_eol);\n            if (from)\n                BIO_printf(out, \"From: %s%s\", from, mime_eol);\n            if (subject)\n                BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n            if (operation == SMIME_RESIGN)\n                ret = SMIME_write_CMS(out, cms, indata, flags);\n            else\n                ret = SMIME_write_CMS(out, cms, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            ret = PEM_write_bio_CMS_stream(out, cms, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            ret = i2d_CMS_bio_stream(out, cms, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for CMS file\\n\");\n            goto end;\n        }\n        if (ret <= 0) {\n            ret = 6;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    OPENSSL_free(secret_key);\n    OPENSSL_free(secret_keyid);\n    OPENSSL_free(pwri_tmp);\n    ASN1_OBJECT_free(econtent_type);\n    CMS_ReceiptRequest_free(rr);\n    sk_OPENSSL_STRING_free(rr_to);\n    sk_OPENSSL_STRING_free(rr_from);\n    for (key_param = key_first; key_param;) {\n        cms_key_param *tparam;\n        sk_OPENSSL_STRING_free(key_param->param);\n        tparam = key_param->next;\n        OPENSSL_free(key_param);\n        key_param = tparam;\n    }\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_CIPHER_free(cipher);\n    EVP_CIPHER_free(wrap_cipher);\n    EVP_MD_free(sign_md);\n    CMS_ContentInfo_free(cms);\n    CMS_ContentInfo_free(rcms);\n    release_engine(e);\n    BIO_free(rctin);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(digestbin);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {",
        "final_sink": "if (CMS_verify_receipt(rcms, cms, other, store, flags) > 0) {",
        "source": [
            "        pp = sk_OPENSSL_PSTRING_value(db->db->data, i);"
        ],
        "index": -1
    },
    {
        "prt": "ectx",
        "function_call": [
            "int dsa_main(int argc, char **argv)\n{\n    BIO *out = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *pkey = NULL;\n    EVP_CIPHER *enc = NULL;\n    char *infile = NULL, *outfile = NULL, *prog;\n    char *passin = NULL, *passout = NULL, *passinarg = NULL, *passoutarg = NULL;\n    OPTION_CHOICE o;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, text = 0, noout = 0;\n    int modulus = 0, pubin = 0, pubout = 0, ret = 1;\n    int pvk_encr = DEFAULT_PVK_ENCR_STRENGTH;\n    int private = 0;\n    const char *output_type = NULL, *ciphername = NULL;\n    const char *output_structure = NULL;\n    int selection = 0;\n    OSSL_ENCODER_CTX *ectx = NULL;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, dsa_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            ret = 0;\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(dsa_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passoutarg = opt_arg();\n            break;\n        case OPT_PVK_STRONG:    /* pvk_encr:= 2 */\n        case OPT_PVK_WEAK:      /* pvk_encr:= 1 */\n        case OPT_PVK_NONE:      /* pvk_encr:= 0 */\n#ifndef OPENSSL_NO_RC4\n            pvk_encr = (o - OPT_PVK_NONE);\n#endif\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_MODULUS:\n            modulus = 1;\n            break;\n        case OPT_PUBIN:\n            pubin = 1;\n            break;\n        case OPT_PUBOUT:\n            pubout = 1;\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* No extra args. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!opt_cipher(ciphername, &enc))\n        goto end;\n    private = !pubin && (!pubout || text);\n\n    if (!app_passwd(passinarg, passoutarg, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n\n    BIO_printf(bio_err, \"read DSA key\\n\");\n    if (pubin)\n        pkey = load_pubkey(infile, informat, 1, passin, e, \"public key\");\n    else\n        pkey = load_key(infile, informat, 1, passin, e, \"private key\");\n\n    if (pkey == NULL) {\n        BIO_printf(bio_err, \"unable to load Key\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    if (!EVP_PKEY_is_a(pkey, \"DSA\")) {\n        BIO_printf(bio_err, \"Not a DSA key\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (text) {\n        assert(pubin || private);\n        if ((pubin && EVP_PKEY_print_public(out, pkey, 0, NULL) <= 0)\n            || (!pubin && EVP_PKEY_print_private(out, pkey, 0, NULL) <= 0)) {\n            perror(outfile);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (modulus) {\n        BIGNUM *pub_key = NULL;\n\n        if (!EVP_PKEY_get_bn_param(pkey, \"pub\", &pub_key)) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        BIO_printf(out, \"Public Key=\");\n        BN_print(out, pub_key);\n        BIO_printf(out, \"\\n\");\n        BN_free(pub_key);\n    }\n\n    if (noout) {\n        ret = 0;\n        goto end;\n    }\n    BIO_printf(bio_err, \"writing DSA key\\n\");\n    if (outformat == FORMAT_ASN1) {\n        output_type = \"DER\";\n    } else if (outformat == FORMAT_PEM) {\n        output_type = \"PEM\";\n    } else if (outformat == FORMAT_MSBLOB) {\n        output_type = \"MSBLOB\";\n    } else if (outformat == FORMAT_PVK) {\n        if (pubin) {\n            BIO_printf(bio_err, \"PVK form impossible with public key input\\n\");\n            goto end;\n        }\n        output_type = \"PVK\";\n    } else {\n        BIO_printf(bio_err, \"bad output format specified for outfile\\n\");\n        goto end;\n    }\n\n    if (outformat == FORMAT_ASN1 || outformat == FORMAT_PEM) {\n        if (pubout || pubin)\n            output_structure = \"SubjectPublicKeyInfo\";\n        else\n            output_structure = \"type-specific\";\n    }\n\n    /* Select what you want in the output */\n    if (pubout || pubin) {\n        selection = OSSL_KEYMGMT_SELECT_PUBLIC_KEY;\n    } else {\n        assert(private);\n        selection = (OSSL_KEYMGMT_SELECT_KEYPAIR\n                     | OSSL_KEYMGMT_SELECT_ALL_PARAMETERS);\n    }\n\n    /* Perform the encoding */\n    ectx = OSSL_ENCODER_CTX_new_for_pkey(pkey, selection, output_type,\n                                         output_structure, NULL);\n    if (OSSL_ENCODER_CTX_get_num_encoders(ectx) == 0) {\n        BIO_printf(bio_err, \"%s format not supported\\n\", output_type);\n        goto end;\n    }\n\n    /* Passphrase setup */\n    if (enc != NULL)\n        OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);\n\n    /* Default passphrase prompter */\n    if (enc != NULL || outformat == FORMAT_PVK) {\n        OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);\n        if (passout != NULL)\n            /* When passout given, override the passphrase prompter */\n            OSSL_ENCODER_CTX_set_passphrase(ectx,\n                                            (const unsigned char *)passout,\n                                            strlen(passout));\n    }\n\n    /* PVK requires a bit more */\n    if (outformat == FORMAT_PVK) {\n        OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n        params[0] = OSSL_PARAM_construct_int(\"encrypt-level\", &pvk_encr);\n        if (!OSSL_ENCODER_CTX_set_params(ectx, params)) {\n            BIO_printf(bio_err, \"invalid PVK encryption level\\n\");\n            goto end;\n        }\n    }\n\n    if (!OSSL_ENCODER_to_bio(ectx, out)) {\n        BIO_printf(bio_err, \"unable to write key\\n\");\n        goto end;\n    }\n    ret = 0;\n end:\n    if (ret != 0)\n        ERR_print_errors(bio_err);\n    OSSL_ENCODER_CTX_free(ectx);\n    BIO_free_all(out);\n    EVP_PKEY_free(pkey);\n    EVP_CIPHER_free(enc);\n    release_engine(e);\n    OPENSSL_free(passin);\n    OPENSSL_free(passout);\n    return ret;\n}",
            "int OSSL_ENCODER_CTX_set_passphrase_ui(OSSL_ENCODER_CTX *ctx,\n                                       const UI_METHOD *ui_method,\n                                       void *ui_data)\n{\n    return ossl_pw_set_ui_method(&ctx->pwdata, ui_method, ui_data);\n}"
        ],
        "sink": "OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);",
        "final_sink": "    return ossl_pw_set_ui_method(&ctx->pwdata, ui_method, ui_data);",
        "source": [
            "    char *outdir = NULL, *outfile = NULL, *rev_arg = NULL, *ser_status = NULL;",
            "        outdir = NCONF_get_string(conf, section, ENV_NEW_CERTS_DIR);"
        ],
        "index": 12
    },
    {
        "prt": "ectx",
        "function_call": [
            "int dsa_main(int argc, char **argv)\n{\n    BIO *out = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY *pkey = NULL;\n    EVP_CIPHER *enc = NULL;\n    char *infile = NULL, *outfile = NULL, *prog;\n    char *passin = NULL, *passout = NULL, *passinarg = NULL, *passoutarg = NULL;\n    OPTION_CHOICE o;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, text = 0, noout = 0;\n    int modulus = 0, pubin = 0, pubout = 0, ret = 1;\n    int pvk_encr = DEFAULT_PVK_ENCR_STRENGTH;\n    int private = 0;\n    const char *output_type = NULL, *ciphername = NULL;\n    const char *output_structure = NULL;\n    int selection = 0;\n    OSSL_ENCODER_CTX *ectx = NULL;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, dsa_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            ret = 0;\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(dsa_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passoutarg = opt_arg();\n            break;\n        case OPT_PVK_STRONG:    /* pvk_encr:= 2 */\n        case OPT_PVK_WEAK:      /* pvk_encr:= 1 */\n        case OPT_PVK_NONE:      /* pvk_encr:= 0 */\n#ifndef OPENSSL_NO_RC4\n            pvk_encr = (o - OPT_PVK_NONE);\n#endif\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_MODULUS:\n            modulus = 1;\n            break;\n        case OPT_PUBIN:\n            pubin = 1;\n            break;\n        case OPT_PUBOUT:\n            pubout = 1;\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* No extra args. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!opt_cipher(ciphername, &enc))\n        goto end;\n    private = !pubin && (!pubout || text);\n\n    if (!app_passwd(passinarg, passoutarg, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n\n    BIO_printf(bio_err, \"read DSA key\\n\");\n    if (pubin)\n        pkey = load_pubkey(infile, informat, 1, passin, e, \"public key\");\n    else\n        pkey = load_key(infile, informat, 1, passin, e, \"private key\");\n\n    if (pkey == NULL) {\n        BIO_printf(bio_err, \"unable to load Key\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    if (!EVP_PKEY_is_a(pkey, \"DSA\")) {\n        BIO_printf(bio_err, \"Not a DSA key\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (text) {\n        assert(pubin || private);\n        if ((pubin && EVP_PKEY_print_public(out, pkey, 0, NULL) <= 0)\n            || (!pubin && EVP_PKEY_print_private(out, pkey, 0, NULL) <= 0)) {\n            perror(outfile);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (modulus) {\n        BIGNUM *pub_key = NULL;\n\n        if (!EVP_PKEY_get_bn_param(pkey, \"pub\", &pub_key)) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        BIO_printf(out, \"Public Key=\");\n        BN_print(out, pub_key);\n        BIO_printf(out, \"\\n\");\n        BN_free(pub_key);\n    }\n\n    if (noout) {\n        ret = 0;\n        goto end;\n    }\n    BIO_printf(bio_err, \"writing DSA key\\n\");\n    if (outformat == FORMAT_ASN1) {\n        output_type = \"DER\";\n    } else if (outformat == FORMAT_PEM) {\n        output_type = \"PEM\";\n    } else if (outformat == FORMAT_MSBLOB) {\n        output_type = \"MSBLOB\";\n    } else if (outformat == FORMAT_PVK) {\n        if (pubin) {\n            BIO_printf(bio_err, \"PVK form impossible with public key input\\n\");\n            goto end;\n        }\n        output_type = \"PVK\";\n    } else {\n        BIO_printf(bio_err, \"bad output format specified for outfile\\n\");\n        goto end;\n    }\n\n    if (outformat == FORMAT_ASN1 || outformat == FORMAT_PEM) {\n        if (pubout || pubin)\n            output_structure = \"SubjectPublicKeyInfo\";\n        else\n            output_structure = \"type-specific\";\n    }\n\n    /* Select what you want in the output */\n    if (pubout || pubin) {\n        selection = OSSL_KEYMGMT_SELECT_PUBLIC_KEY;\n    } else {\n        assert(private);\n        selection = (OSSL_KEYMGMT_SELECT_KEYPAIR\n                     | OSSL_KEYMGMT_SELECT_ALL_PARAMETERS);\n    }\n\n    /* Perform the encoding */\n    ectx = OSSL_ENCODER_CTX_new_for_pkey(pkey, selection, output_type,\n                                         output_structure, NULL);\n    if (OSSL_ENCODER_CTX_get_num_encoders(ectx) == 0) {\n        BIO_printf(bio_err, \"%s format not supported\\n\", output_type);\n        goto end;\n    }\n\n    /* Passphrase setup */\n    if (enc != NULL)\n        OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);\n\n    /* Default passphrase prompter */\n    if (enc != NULL || outformat == FORMAT_PVK) {\n        OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);\n        if (passout != NULL)\n            /* When passout given, override the passphrase prompter */\n            OSSL_ENCODER_CTX_set_passphrase(ectx,\n                                            (const unsigned char *)passout,\n                                            strlen(passout));\n    }\n\n    /* PVK requires a bit more */\n    if (outformat == FORMAT_PVK) {\n        OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n        params[0] = OSSL_PARAM_construct_int(\"encrypt-level\", &pvk_encr);\n        if (!OSSL_ENCODER_CTX_set_params(ectx, params)) {\n            BIO_printf(bio_err, \"invalid PVK encryption level\\n\");\n            goto end;\n        }\n    }\n\n    if (!OSSL_ENCODER_to_bio(ectx, out)) {\n        BIO_printf(bio_err, \"unable to write key\\n\");\n        goto end;\n    }\n    ret = 0;\n end:\n    if (ret != 0)\n        ERR_print_errors(bio_err);\n    OSSL_ENCODER_CTX_free(ectx);\n    BIO_free_all(out);\n    EVP_PKEY_free(pkey);\n    EVP_CIPHER_free(enc);\n    release_engine(e);\n    OPENSSL_free(passin);\n    OPENSSL_free(passout);\n    return ret;\n}"
        ],
        "sink": "if (!OSSL_ENCODER_to_bio(ectx, out)) {",
        "final_sink": "if (!OSSL_ENCODER_to_bio(ectx, out)) {",
        "source": [
            "            X509 *xi = sk_X509_value(cert_sk, i);"
        ],
        "index": 13
    },
    {
        "prt": "ectx",
        "function_call": [
            "int ec_main(int argc, char **argv)\n{\n    OSSL_ENCODER_CTX *ectx = NULL;\n    OSSL_DECODER_CTX *dctx = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    EVP_PKEY *eckey = NULL;\n    BIO *out = NULL;\n    ENGINE *e = NULL;\n    EVP_CIPHER *enc = NULL;\n    char *infile = NULL, *outfile = NULL, *ciphername = NULL, *prog;\n    char *passin = NULL, *passout = NULL, *passinarg = NULL, *passoutarg = NULL;\n    OPTION_CHOICE o;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, text = 0, noout = 0;\n    int pubin = 0, pubout = 0, param_out = 0, ret = 1, private = 0;\n    int check = 0;\n    char *asn1_encoding = NULL;\n    char *point_format = NULL;\n    int no_public = 0;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, ec_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ec_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_PARAM_OUT:\n            param_out = 1;\n            break;\n        case OPT_PUBIN:\n            pubin = 1;\n            break;\n        case OPT_PUBOUT:\n            pubout = 1;\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passoutarg = opt_arg();\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_CONV_FORM:\n            point_format = opt_arg();\n            if (!opt_string(point_format, point_format_options))\n                goto opthelp;\n            break;\n        case OPT_PARAM_ENC:\n            asn1_encoding = opt_arg();\n            if (!opt_string(asn1_encoding, asn1_encoding_options))\n                goto opthelp;\n            break;\n        case OPT_NO_PUBLIC:\n            no_public = 1;\n            break;\n        case OPT_CHECK:\n            check = 1;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!opt_cipher(ciphername, &enc))\n        goto opthelp;\n    private = !pubin && (text || (!param_out && !pubout));\n\n    if (!app_passwd(passinarg, passoutarg, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n\n    BIO_printf(bio_err, \"read EC key\\n\");\n\n    if (pubin)\n        eckey = load_pubkey(infile, informat, 1, passin, e, \"public key\");\n    else\n        eckey = load_key(infile, informat, 1, passin, e, \"private key\");\n\n    if (eckey == NULL) {\n        BIO_printf(bio_err, \"unable to load Key\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (point_format\n        && !EVP_PKEY_set_utf8_string_param(\n                eckey, OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,\n                point_format)) {\n        BIO_printf(bio_err, \"unable to set point conversion format\\n\");\n        goto end;\n    }\n\n    if (asn1_encoding != NULL\n        && !EVP_PKEY_set_utf8_string_param(\n                eckey, OSSL_PKEY_PARAM_EC_ENCODING, asn1_encoding)) {\n        BIO_printf(bio_err, \"unable to set asn1 encoding format\\n\");\n        goto end;\n    }\n\n    if (no_public) {\n        if (!EVP_PKEY_set_int_param(eckey, OSSL_PKEY_PARAM_EC_INCLUDE_PUBLIC, 0)) {\n            BIO_printf(bio_err, \"unable to disable public key encoding\\n\");\n            goto end;\n        }\n    } else {\n        if (!EVP_PKEY_set_int_param(eckey, OSSL_PKEY_PARAM_EC_INCLUDE_PUBLIC, 1)) {\n            BIO_printf(bio_err, \"unable to enable public key encoding\\n\");\n            goto end;\n        }\n    }\n\n    if (text) {\n        assert(pubin || private);\n        if ((pubin && EVP_PKEY_print_public(out, eckey, 0, NULL) <= 0)\n            || (!pubin && EVP_PKEY_print_private(out, eckey, 0, NULL) <= 0)) {\n            BIO_printf(bio_err, \"unable to print EC key\\n\");\n            goto end;\n        }\n    }\n\n    if (check) {\n        pctx = EVP_PKEY_CTX_new_from_pkey(NULL, eckey, NULL);\n        if (pctx == NULL) {\n            BIO_printf(bio_err, \"unable to check EC key\\n\");\n            goto end;\n        }\n        if (EVP_PKEY_check(pctx) <= 0)\n            BIO_printf(bio_err, \"EC Key Invalid!\\n\");\n        else\n            BIO_printf(bio_err, \"EC Key valid.\\n\");\n        ERR_print_errors(bio_err);\n    }\n\n    if (!noout) {\n        int selection;\n        const char *output_type = outformat == FORMAT_ASN1 ? \"DER\" : \"PEM\";\n        const char *output_structure = \"type-specific\";\n\n        BIO_printf(bio_err, \"writing EC key\\n\");\n        if (param_out) {\n            selection = OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS;\n        } else if (pubin || pubout) {\n            selection = OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS\n                | OSSL_KEYMGMT_SELECT_PUBLIC_KEY;\n            output_structure = \"SubjectPublicKeyInfo\";\n        } else {\n            selection = OSSL_KEYMGMT_SELECT_ALL;\n            assert(private);\n        }\n\n        ectx = OSSL_ENCODER_CTX_new_for_pkey(eckey, selection,\n                                             output_type, output_structure,\n                                             NULL);\n        if (enc != NULL) {\n            OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);\n            /* Default passphrase prompter */\n            OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);\n            if (passout != NULL)\n                /* When passout given, override the passphrase prompter */\n                OSSL_ENCODER_CTX_set_passphrase(ectx,\n                                                (const unsigned char *)passout,\n                                                strlen(passout));\n        }\n        if (!OSSL_ENCODER_to_bio(ectx, out)) {\n            BIO_printf(bio_err, \"unable to write EC key\\n\");\n            goto end;\n        }\n    }\n\n    ret = 0;\nend:\n    if (ret != 0)\n        ERR_print_errors(bio_err);\n    BIO_free_all(out);\n    EVP_PKEY_free(eckey);\n    EVP_CIPHER_free(enc);\n    OSSL_ENCODER_CTX_free(ectx);\n    OSSL_DECODER_CTX_free(dctx);\n    EVP_PKEY_CTX_free(pctx);\n    release_engine(e);\n    if (passin != NULL)\n        OPENSSL_clear_free(passin, strlen(passin));\n    if (passout != NULL)\n        OPENSSL_clear_free(passout, strlen(passout));\n    return ret;\n}",
            "int OSSL_ENCODER_CTX_set_passphrase_ui(OSSL_ENCODER_CTX *ctx,\n                                       const UI_METHOD *ui_method,\n                                       void *ui_data)\n{\n    return ossl_pw_set_ui_method(&ctx->pwdata, ui_method, ui_data);\n}"
        ],
        "sink": "OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);",
        "final_sink": "    return ossl_pw_set_ui_method(&ctx->pwdata, ui_method, ui_data);",
        "source": [
            "            pp = sk_OPENSSL_PSTRING_value(db->db->data, i);"
        ],
        "index": 14
    },
    {
        "prt": "ectx",
        "function_call": [
            "int ec_main(int argc, char **argv)\n{\n    OSSL_ENCODER_CTX *ectx = NULL;\n    OSSL_DECODER_CTX *dctx = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    EVP_PKEY *eckey = NULL;\n    BIO *out = NULL;\n    ENGINE *e = NULL;\n    EVP_CIPHER *enc = NULL;\n    char *infile = NULL, *outfile = NULL, *ciphername = NULL, *prog;\n    char *passin = NULL, *passout = NULL, *passinarg = NULL, *passoutarg = NULL;\n    OPTION_CHOICE o;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, text = 0, noout = 0;\n    int pubin = 0, pubout = 0, param_out = 0, ret = 1, private = 0;\n    int check = 0;\n    char *asn1_encoding = NULL;\n    char *point_format = NULL;\n    int no_public = 0;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, ec_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ec_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_PARAM_OUT:\n            param_out = 1;\n            break;\n        case OPT_PUBIN:\n            pubin = 1;\n            break;\n        case OPT_PUBOUT:\n            pubout = 1;\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passoutarg = opt_arg();\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_CONV_FORM:\n            point_format = opt_arg();\n            if (!opt_string(point_format, point_format_options))\n                goto opthelp;\n            break;\n        case OPT_PARAM_ENC:\n            asn1_encoding = opt_arg();\n            if (!opt_string(asn1_encoding, asn1_encoding_options))\n                goto opthelp;\n            break;\n        case OPT_NO_PUBLIC:\n            no_public = 1;\n            break;\n        case OPT_CHECK:\n            check = 1;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!opt_cipher(ciphername, &enc))\n        goto opthelp;\n    private = !pubin && (text || (!param_out && !pubout));\n\n    if (!app_passwd(passinarg, passoutarg, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n\n    BIO_printf(bio_err, \"read EC key\\n\");\n\n    if (pubin)\n        eckey = load_pubkey(infile, informat, 1, passin, e, \"public key\");\n    else\n        eckey = load_key(infile, informat, 1, passin, e, \"private key\");\n\n    if (eckey == NULL) {\n        BIO_printf(bio_err, \"unable to load Key\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (point_format\n        && !EVP_PKEY_set_utf8_string_param(\n                eckey, OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,\n                point_format)) {\n        BIO_printf(bio_err, \"unable to set point conversion format\\n\");\n        goto end;\n    }\n\n    if (asn1_encoding != NULL\n        && !EVP_PKEY_set_utf8_string_param(\n                eckey, OSSL_PKEY_PARAM_EC_ENCODING, asn1_encoding)) {\n        BIO_printf(bio_err, \"unable to set asn1 encoding format\\n\");\n        goto end;\n    }\n\n    if (no_public) {\n        if (!EVP_PKEY_set_int_param(eckey, OSSL_PKEY_PARAM_EC_INCLUDE_PUBLIC, 0)) {\n            BIO_printf(bio_err, \"unable to disable public key encoding\\n\");\n            goto end;\n        }\n    } else {\n        if (!EVP_PKEY_set_int_param(eckey, OSSL_PKEY_PARAM_EC_INCLUDE_PUBLIC, 1)) {\n            BIO_printf(bio_err, \"unable to enable public key encoding\\n\");\n            goto end;\n        }\n    }\n\n    if (text) {\n        assert(pubin || private);\n        if ((pubin && EVP_PKEY_print_public(out, eckey, 0, NULL) <= 0)\n            || (!pubin && EVP_PKEY_print_private(out, eckey, 0, NULL) <= 0)) {\n            BIO_printf(bio_err, \"unable to print EC key\\n\");\n            goto end;\n        }\n    }\n\n    if (check) {\n        pctx = EVP_PKEY_CTX_new_from_pkey(NULL, eckey, NULL);\n        if (pctx == NULL) {\n            BIO_printf(bio_err, \"unable to check EC key\\n\");\n            goto end;\n        }\n        if (EVP_PKEY_check(pctx) <= 0)\n            BIO_printf(bio_err, \"EC Key Invalid!\\n\");\n        else\n            BIO_printf(bio_err, \"EC Key valid.\\n\");\n        ERR_print_errors(bio_err);\n    }\n\n    if (!noout) {\n        int selection;\n        const char *output_type = outformat == FORMAT_ASN1 ? \"DER\" : \"PEM\";\n        const char *output_structure = \"type-specific\";\n\n        BIO_printf(bio_err, \"writing EC key\\n\");\n        if (param_out) {\n            selection = OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS;\n        } else if (pubin || pubout) {\n            selection = OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS\n                | OSSL_KEYMGMT_SELECT_PUBLIC_KEY;\n            output_structure = \"SubjectPublicKeyInfo\";\n        } else {\n            selection = OSSL_KEYMGMT_SELECT_ALL;\n            assert(private);\n        }\n\n        ectx = OSSL_ENCODER_CTX_new_for_pkey(eckey, selection,\n                                             output_type, output_structure,\n                                             NULL);\n        if (enc != NULL) {\n            OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);\n            /* Default passphrase prompter */\n            OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);\n            if (passout != NULL)\n                /* When passout given, override the passphrase prompter */\n                OSSL_ENCODER_CTX_set_passphrase(ectx,\n                                                (const unsigned char *)passout,\n                                                strlen(passout));\n        }\n        if (!OSSL_ENCODER_to_bio(ectx, out)) {\n            BIO_printf(bio_err, \"unable to write EC key\\n\");\n            goto end;\n        }\n    }\n\n    ret = 0;\nend:\n    if (ret != 0)\n        ERR_print_errors(bio_err);\n    BIO_free_all(out);\n    EVP_PKEY_free(eckey);\n    EVP_CIPHER_free(enc);\n    OSSL_ENCODER_CTX_free(ectx);\n    OSSL_DECODER_CTX_free(dctx);\n    EVP_PKEY_CTX_free(pctx);\n    release_engine(e);\n    if (passin != NULL)\n        OPENSSL_clear_free(passin, strlen(passin));\n    if (passout != NULL)\n        OPENSSL_clear_free(passout, strlen(passout));\n    return ret;\n}"
        ],
        "sink": "if (!OSSL_ENCODER_to_bio(ectx, out)) {",
        "final_sink": "if (!OSSL_ENCODER_to_bio(ectx, out)) {",
        "source": [
            "    BIGNUM *crlnumber = NULL, *serial = NULL;"
        ],
        "index": 15
    },
    {
        "prt": "ectx_params",
        "function_call": [
            "int ecparam_main(int argc, char **argv)\n{\n    EVP_PKEY_CTX *gctx_params = NULL, *gctx_key = NULL, *pctx = NULL;\n    EVP_PKEY *params_key = NULL, *key = NULL;\n    OSSL_ENCODER_CTX *ectx_key = NULL, *ectx_params = NULL;\n    OSSL_DECODER_CTX *dctx_params = NULL;\n    ENGINE *e = NULL;\n    BIO *out = NULL;\n    char *curve_name = NULL;\n    char *asn1_encoding = NULL;\n    char *point_format = NULL;\n    char *infile = NULL, *outfile = NULL, *prog;\n    OPTION_CHOICE o;\n    int informat = FORMAT_PEM, outformat = FORMAT_PEM, noout = 0;\n    int ret = 1, private = 0;\n    int no_seed = 0, check = 0, check_named = 0, text = 0, genkey = 0;\n    int list_curves = 0;\n\n    prog = opt_init(argc, argv, ecparam_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ecparam_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_CHECK:\n            check = 1;\n            break;\n        case OPT_CHECK_NAMED:\n            check_named = 1;\n            break;\n        case OPT_LIST_CURVES:\n            list_curves = 1;\n            break;\n        case OPT_NO_SEED:\n            no_seed = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_NAME:\n            curve_name = opt_arg();\n            break;\n        case OPT_CONV_FORM:\n            point_format = opt_arg();\n            if (!opt_string(point_format, point_format_options))\n                goto opthelp;\n            break;\n        case OPT_PARAM_ENC:\n            asn1_encoding = opt_arg();\n            if (!opt_string(asn1_encoding, asn1_encoding_options))\n                goto opthelp;\n            break;\n        case OPT_GENKEY:\n            genkey = 1;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n\n    /* No extra args. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n    private = genkey ? 1 : 0;\n\n    if (curve_name != NULL) {\n        OSSL_PARAM params[4];\n        OSSL_PARAM *p = params;\n\n        if (strcmp(curve_name, \"secp192r1\") == 0) {\n            BIO_printf(bio_err,\n                       \"using curve name prime192v1 instead of secp192r1\\n\");\n            curve_name = SN_X9_62_prime192v1;\n        } else if (strcmp(curve_name, \"secp256r1\") == 0) {\n            BIO_printf(bio_err,\n                       \"using curve name prime256v1 instead of secp256r1\\n\");\n            curve_name = SN_X9_62_prime256v1;\n        }\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_GROUP_NAME,\n                                                curve_name, 0);\n        if (asn1_encoding != NULL)\n            *p++ = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_EC_ENCODING,\n                                                    asn1_encoding, 0);\n        if (point_format != NULL)\n            *p++ = OSSL_PARAM_construct_utf8_string(\n                       OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,\n                       point_format, 0);\n        *p = OSSL_PARAM_construct_end();\n\n        if (OPENSSL_strcasecmp(curve_name, \"SM2\") == 0)\n            gctx_params = EVP_PKEY_CTX_new_from_name(app_get0_libctx(), \"sm2\",\n                                                     app_get0_propq());\n        else\n            gctx_params = EVP_PKEY_CTX_new_from_name(app_get0_libctx(), \"ec\",\n                                                     app_get0_propq());\n        if (gctx_params == NULL\n            || EVP_PKEY_keygen_init(gctx_params) <= 0\n            || EVP_PKEY_CTX_set_params(gctx_params, params) <= 0\n            || EVP_PKEY_keygen(gctx_params, &params_key) <= 0) {\n            BIO_printf(bio_err, \"unable to generate key\\n\");\n            goto end;\n        }\n    } else {\n        params_key = load_keyparams_suppress(infile, informat, 1, \"EC\",\n                                             \"EC parameters\", 1);\n        if (params_key == NULL)\n            params_key = load_keyparams_suppress(infile, informat, 1, \"SM2\",\n                                                 \"SM2 parameters\", 1);\n\n        if (params_key == NULL) {\n            BIO_printf(bio_err, \"Unable to load parameters from %s\\n\", infile);\n            goto end;\n        }\n\n        if (point_format\n            && !EVP_PKEY_set_utf8_string_param(\n                    params_key, OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,\n                    point_format)) {\n            BIO_printf(bio_err, \"unable to set point conversion format\\n\");\n            goto end;\n        }\n\n        if (asn1_encoding != NULL\n            && !EVP_PKEY_set_utf8_string_param(\n                    params_key, OSSL_PKEY_PARAM_EC_ENCODING, asn1_encoding)) {\n            BIO_printf(bio_err, \"unable to set asn1 encoding format\\n\");\n            goto end;\n        }\n    }\n\n    if (no_seed\n        && !EVP_PKEY_set_octet_string_param(params_key, OSSL_PKEY_PARAM_EC_SEED,\n                                            NULL, 0)) {\n        BIO_printf(bio_err, \"unable to clear seed\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (list_curves) {\n        if (list_builtin_curves(out))\n            ret = 0;\n        goto end;\n    }\n\n    if (text\n        && !EVP_PKEY_print_params(out, params_key, 0, NULL)) {\n        BIO_printf(bio_err, \"unable to print params\\n\");\n        goto end;\n    }\n\n    if (check || check_named) {\n        BIO_printf(bio_err, \"checking elliptic curve parameters: \");\n\n        if (check_named\n            && !EVP_PKEY_set_utf8_string_param(params_key,\n                                           OSSL_PKEY_PARAM_EC_GROUP_CHECK_TYPE,\n                                           OSSL_PKEY_EC_GROUP_CHECK_NAMED)) {\n                BIO_printf(bio_err, \"unable to set check_type\\n\");\n                goto end;\n        }\n        pctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(), params_key,\n                                          app_get0_propq());\n        if (pctx == NULL || EVP_PKEY_param_check(pctx) <= 0) {\n            BIO_printf(bio_err, \"failed\\n\");\n            goto end;\n        }\n        BIO_printf(bio_err, \"ok\\n\");\n    }\n\n    if (outformat == FORMAT_ASN1 && genkey)\n        noout = 1;\n\n    if (!noout) {\n        ectx_params = OSSL_ENCODER_CTX_new_for_pkey(\n                          params_key, OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,\n                          outformat == FORMAT_ASN1 ? \"DER\" : \"PEM\", NULL, NULL);\n        if (!OSSL_ENCODER_to_bio(ectx_params, out)) {\n            BIO_printf(bio_err, \"unable to write elliptic curve parameters\\n\");\n            goto end;\n        }\n    }\n\n    if (genkey) {\n        /*\n         * NOTE: EC keygen does not normally need to pass in the param_key\n         * for named curves. This can be achieved using:\n         *    gctx = EVP_PKEY_CTX_new_from_name(NULL, \"EC\", NULL);\n         *    EVP_PKEY_keygen_init(gctx);\n         *    EVP_PKEY_CTX_set_group_name(gctx, curvename);\n         *    EVP_PKEY_keygen(gctx, &key) <= 0)\n         */\n        gctx_key = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(), params_key,\n                                              app_get0_propq());\n        if (EVP_PKEY_keygen_init(gctx_key) <= 0\n            || EVP_PKEY_keygen(gctx_key, &key) <= 0) {\n            BIO_printf(bio_err, \"unable to generate key\\n\");\n            goto end;\n        }\n        assert(private);\n        ectx_key = OSSL_ENCODER_CTX_new_for_pkey(\n                       key, OSSL_KEYMGMT_SELECT_ALL,\n                       outformat == FORMAT_ASN1 ? \"DER\" : \"PEM\", NULL, NULL);\n        if (!OSSL_ENCODER_to_bio(ectx_key, out)) {\n            BIO_printf(bio_err, \"unable to write elliptic \"\n                       \"curve parameters\\n\");\n            goto end;\n        }\n    }\n\n    ret = 0;\nend:\n    if (ret != 0)\n        ERR_print_errors(bio_err);\n    release_engine(e);\n    EVP_PKEY_free(params_key);\n    EVP_PKEY_free(key);\n    EVP_PKEY_CTX_free(pctx);\n    EVP_PKEY_CTX_free(gctx_params);\n    EVP_PKEY_CTX_free(gctx_key);\n    OSSL_DECODER_CTX_free(dctx_params);\n    OSSL_ENCODER_CTX_free(ectx_params);\n    OSSL_ENCODER_CTX_free(ectx_key);\n    BIO_free_all(out);\n    return ret;\n}"
        ],
        "sink": "if (!OSSL_ENCODER_to_bio(ectx_params, out)) {",
        "final_sink": "if (!OSSL_ENCODER_to_bio(ectx_params, out)) {",
        "source": [
            "    BIGNUM *crlnumber = NULL, *serial = NULL;"
        ],
        "index": 16
    },
    {
        "prt": "gctx_key",
        "function_call": [
            "int ecparam_main(int argc, char **argv)\n{\n    EVP_PKEY_CTX *gctx_params = NULL, *gctx_key = NULL, *pctx = NULL;\n    EVP_PKEY *params_key = NULL, *key = NULL;\n    OSSL_ENCODER_CTX *ectx_key = NULL, *ectx_params = NULL;\n    OSSL_DECODER_CTX *dctx_params = NULL;\n    ENGINE *e = NULL;\n    BIO *out = NULL;\n    char *curve_name = NULL;\n    char *asn1_encoding = NULL;\n    char *point_format = NULL;\n    char *infile = NULL, *outfile = NULL, *prog;\n    OPTION_CHOICE o;\n    int informat = FORMAT_PEM, outformat = FORMAT_PEM, noout = 0;\n    int ret = 1, private = 0;\n    int no_seed = 0, check = 0, check_named = 0, text = 0, genkey = 0;\n    int list_curves = 0;\n\n    prog = opt_init(argc, argv, ecparam_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ecparam_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_CHECK:\n            check = 1;\n            break;\n        case OPT_CHECK_NAMED:\n            check_named = 1;\n            break;\n        case OPT_LIST_CURVES:\n            list_curves = 1;\n            break;\n        case OPT_NO_SEED:\n            no_seed = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_NAME:\n            curve_name = opt_arg();\n            break;\n        case OPT_CONV_FORM:\n            point_format = opt_arg();\n            if (!opt_string(point_format, point_format_options))\n                goto opthelp;\n            break;\n        case OPT_PARAM_ENC:\n            asn1_encoding = opt_arg();\n            if (!opt_string(asn1_encoding, asn1_encoding_options))\n                goto opthelp;\n            break;\n        case OPT_GENKEY:\n            genkey = 1;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n\n    /* No extra args. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n    private = genkey ? 1 : 0;\n\n    if (curve_name != NULL) {\n        OSSL_PARAM params[4];\n        OSSL_PARAM *p = params;\n\n        if (strcmp(curve_name, \"secp192r1\") == 0) {\n            BIO_printf(bio_err,\n                       \"using curve name prime192v1 instead of secp192r1\\n\");\n            curve_name = SN_X9_62_prime192v1;\n        } else if (strcmp(curve_name, \"secp256r1\") == 0) {\n            BIO_printf(bio_err,\n                       \"using curve name prime256v1 instead of secp256r1\\n\");\n            curve_name = SN_X9_62_prime256v1;\n        }\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_GROUP_NAME,\n                                                curve_name, 0);\n        if (asn1_encoding != NULL)\n            *p++ = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_EC_ENCODING,\n                                                    asn1_encoding, 0);\n        if (point_format != NULL)\n            *p++ = OSSL_PARAM_construct_utf8_string(\n                       OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,\n                       point_format, 0);\n        *p = OSSL_PARAM_construct_end();\n\n        if (OPENSSL_strcasecmp(curve_name, \"SM2\") == 0)\n            gctx_params = EVP_PKEY_CTX_new_from_name(app_get0_libctx(), \"sm2\",\n                                                     app_get0_propq());\n        else\n            gctx_params = EVP_PKEY_CTX_new_from_name(app_get0_libctx(), \"ec\",\n                                                     app_get0_propq());\n        if (gctx_params == NULL\n            || EVP_PKEY_keygen_init(gctx_params) <= 0\n            || EVP_PKEY_CTX_set_params(gctx_params, params) <= 0\n            || EVP_PKEY_keygen(gctx_params, &params_key) <= 0) {\n            BIO_printf(bio_err, \"unable to generate key\\n\");\n            goto end;\n        }\n    } else {\n        params_key = load_keyparams_suppress(infile, informat, 1, \"EC\",\n                                             \"EC parameters\", 1);\n        if (params_key == NULL)\n            params_key = load_keyparams_suppress(infile, informat, 1, \"SM2\",\n                                                 \"SM2 parameters\", 1);\n\n        if (params_key == NULL) {\n            BIO_printf(bio_err, \"Unable to load parameters from %s\\n\", infile);\n            goto end;\n        }\n\n        if (point_format\n            && !EVP_PKEY_set_utf8_string_param(\n                    params_key, OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,\n                    point_format)) {\n            BIO_printf(bio_err, \"unable to set point conversion format\\n\");\n            goto end;\n        }\n\n        if (asn1_encoding != NULL\n            && !EVP_PKEY_set_utf8_string_param(\n                    params_key, OSSL_PKEY_PARAM_EC_ENCODING, asn1_encoding)) {\n            BIO_printf(bio_err, \"unable to set asn1 encoding format\\n\");\n            goto end;\n        }\n    }\n\n    if (no_seed\n        && !EVP_PKEY_set_octet_string_param(params_key, OSSL_PKEY_PARAM_EC_SEED,\n                                            NULL, 0)) {\n        BIO_printf(bio_err, \"unable to clear seed\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (list_curves) {\n        if (list_builtin_curves(out))\n            ret = 0;\n        goto end;\n    }\n\n    if (text\n        && !EVP_PKEY_print_params(out, params_key, 0, NULL)) {\n        BIO_printf(bio_err, \"unable to print params\\n\");\n        goto end;\n    }\n\n    if (check || check_named) {\n        BIO_printf(bio_err, \"checking elliptic curve parameters: \");\n\n        if (check_named\n            && !EVP_PKEY_set_utf8_string_param(params_key,\n                                           OSSL_PKEY_PARAM_EC_GROUP_CHECK_TYPE,\n                                           OSSL_PKEY_EC_GROUP_CHECK_NAMED)) {\n                BIO_printf(bio_err, \"unable to set check_type\\n\");\n                goto end;\n        }\n        pctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(), params_key,\n                                          app_get0_propq());\n        if (pctx == NULL || EVP_PKEY_param_check(pctx) <= 0) {\n            BIO_printf(bio_err, \"failed\\n\");\n            goto end;\n        }\n        BIO_printf(bio_err, \"ok\\n\");\n    }\n\n    if (outformat == FORMAT_ASN1 && genkey)\n        noout = 1;\n\n    if (!noout) {\n        ectx_params = OSSL_ENCODER_CTX_new_for_pkey(\n                          params_key, OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,\n                          outformat == FORMAT_ASN1 ? \"DER\" : \"PEM\", NULL, NULL);\n        if (!OSSL_ENCODER_to_bio(ectx_params, out)) {\n            BIO_printf(bio_err, \"unable to write elliptic curve parameters\\n\");\n            goto end;\n        }\n    }\n\n    if (genkey) {\n        /*\n         * NOTE: EC keygen does not normally need to pass in the param_key\n         * for named curves. This can be achieved using:\n         *    gctx = EVP_PKEY_CTX_new_from_name(NULL, \"EC\", NULL);\n         *    EVP_PKEY_keygen_init(gctx);\n         *    EVP_PKEY_CTX_set_group_name(gctx, curvename);\n         *    EVP_PKEY_keygen(gctx, &key) <= 0)\n         */\n        gctx_key = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(), params_key,\n                                              app_get0_propq());\n        if (EVP_PKEY_keygen_init(gctx_key) <= 0\n            || EVP_PKEY_keygen(gctx_key, &key) <= 0) {\n            BIO_printf(bio_err, \"unable to generate key\\n\");\n            goto end;\n        }\n        assert(private);\n        ectx_key = OSSL_ENCODER_CTX_new_for_pkey(\n                       key, OSSL_KEYMGMT_SELECT_ALL,\n                       outformat == FORMAT_ASN1 ? \"DER\" : \"PEM\", NULL, NULL);\n        if (!OSSL_ENCODER_to_bio(ectx_key, out)) {\n            BIO_printf(bio_err, \"unable to write elliptic \"\n                       \"curve parameters\\n\");\n            goto end;\n        }\n    }\n\n    ret = 0;\nend:\n    if (ret != 0)\n        ERR_print_errors(bio_err);\n    release_engine(e);\n    EVP_PKEY_free(params_key);\n    EVP_PKEY_free(key);\n    EVP_PKEY_CTX_free(pctx);\n    EVP_PKEY_CTX_free(gctx_params);\n    EVP_PKEY_CTX_free(gctx_key);\n    OSSL_DECODER_CTX_free(dctx_params);\n    OSSL_ENCODER_CTX_free(ectx_params);\n    OSSL_ENCODER_CTX_free(ectx_key);\n    BIO_free_all(out);\n    return ret;\n}",
            "int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)\n{\n    if (ctx->operation != EVP_PKEY_OP_KEYGEN) {\n        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_INITIALIZED);\n        return -1;\n    }\n    return EVP_PKEY_generate(ctx, ppkey);\n}"
        ],
        "sink": "|| EVP_PKEY_keygen(gctx_key, &key) <= 0) {",
        "final_sink": "    if (ctx->operation != EVP_PKEY_OP_KEYGEN) {",
        "source": [
            "    char *outdir = NULL, *outfile = NULL, *rev_arg = NULL, *ser_status = NULL;"
        ],
        "index": 17
    },
    {
        "prt": "ectx_key",
        "function_call": [
            "int ecparam_main(int argc, char **argv)\n{\n    EVP_PKEY_CTX *gctx_params = NULL, *gctx_key = NULL, *pctx = NULL;\n    EVP_PKEY *params_key = NULL, *key = NULL;\n    OSSL_ENCODER_CTX *ectx_key = NULL, *ectx_params = NULL;\n    OSSL_DECODER_CTX *dctx_params = NULL;\n    ENGINE *e = NULL;\n    BIO *out = NULL;\n    char *curve_name = NULL;\n    char *asn1_encoding = NULL;\n    char *point_format = NULL;\n    char *infile = NULL, *outfile = NULL, *prog;\n    OPTION_CHOICE o;\n    int informat = FORMAT_PEM, outformat = FORMAT_PEM, noout = 0;\n    int ret = 1, private = 0;\n    int no_seed = 0, check = 0, check_named = 0, text = 0, genkey = 0;\n    int list_curves = 0;\n\n    prog = opt_init(argc, argv, ecparam_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(ecparam_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_CHECK:\n            check = 1;\n            break;\n        case OPT_CHECK_NAMED:\n            check_named = 1;\n            break;\n        case OPT_LIST_CURVES:\n            list_curves = 1;\n            break;\n        case OPT_NO_SEED:\n            no_seed = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_NAME:\n            curve_name = opt_arg();\n            break;\n        case OPT_CONV_FORM:\n            point_format = opt_arg();\n            if (!opt_string(point_format, point_format_options))\n                goto opthelp;\n            break;\n        case OPT_PARAM_ENC:\n            asn1_encoding = opt_arg();\n            if (!opt_string(asn1_encoding, asn1_encoding_options))\n                goto opthelp;\n            break;\n        case OPT_GENKEY:\n            genkey = 1;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        }\n    }\n\n    /* No extra args. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n    private = genkey ? 1 : 0;\n\n    if (curve_name != NULL) {\n        OSSL_PARAM params[4];\n        OSSL_PARAM *p = params;\n\n        if (strcmp(curve_name, \"secp192r1\") == 0) {\n            BIO_printf(bio_err,\n                       \"using curve name prime192v1 instead of secp192r1\\n\");\n            curve_name = SN_X9_62_prime192v1;\n        } else if (strcmp(curve_name, \"secp256r1\") == 0) {\n            BIO_printf(bio_err,\n                       \"using curve name prime256v1 instead of secp256r1\\n\");\n            curve_name = SN_X9_62_prime256v1;\n        }\n        *p++ = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_GROUP_NAME,\n                                                curve_name, 0);\n        if (asn1_encoding != NULL)\n            *p++ = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_EC_ENCODING,\n                                                    asn1_encoding, 0);\n        if (point_format != NULL)\n            *p++ = OSSL_PARAM_construct_utf8_string(\n                       OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,\n                       point_format, 0);\n        *p = OSSL_PARAM_construct_end();\n\n        if (OPENSSL_strcasecmp(curve_name, \"SM2\") == 0)\n            gctx_params = EVP_PKEY_CTX_new_from_name(app_get0_libctx(), \"sm2\",\n                                                     app_get0_propq());\n        else\n            gctx_params = EVP_PKEY_CTX_new_from_name(app_get0_libctx(), \"ec\",\n                                                     app_get0_propq());\n        if (gctx_params == NULL\n            || EVP_PKEY_keygen_init(gctx_params) <= 0\n            || EVP_PKEY_CTX_set_params(gctx_params, params) <= 0\n            || EVP_PKEY_keygen(gctx_params, &params_key) <= 0) {\n            BIO_printf(bio_err, \"unable to generate key\\n\");\n            goto end;\n        }\n    } else {\n        params_key = load_keyparams_suppress(infile, informat, 1, \"EC\",\n                                             \"EC parameters\", 1);\n        if (params_key == NULL)\n            params_key = load_keyparams_suppress(infile, informat, 1, \"SM2\",\n                                                 \"SM2 parameters\", 1);\n\n        if (params_key == NULL) {\n            BIO_printf(bio_err, \"Unable to load parameters from %s\\n\", infile);\n            goto end;\n        }\n\n        if (point_format\n            && !EVP_PKEY_set_utf8_string_param(\n                    params_key, OSSL_PKEY_PARAM_EC_POINT_CONVERSION_FORMAT,\n                    point_format)) {\n            BIO_printf(bio_err, \"unable to set point conversion format\\n\");\n            goto end;\n        }\n\n        if (asn1_encoding != NULL\n            && !EVP_PKEY_set_utf8_string_param(\n                    params_key, OSSL_PKEY_PARAM_EC_ENCODING, asn1_encoding)) {\n            BIO_printf(bio_err, \"unable to set asn1 encoding format\\n\");\n            goto end;\n        }\n    }\n\n    if (no_seed\n        && !EVP_PKEY_set_octet_string_param(params_key, OSSL_PKEY_PARAM_EC_SEED,\n                                            NULL, 0)) {\n        BIO_printf(bio_err, \"unable to clear seed\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (list_curves) {\n        if (list_builtin_curves(out))\n            ret = 0;\n        goto end;\n    }\n\n    if (text\n        && !EVP_PKEY_print_params(out, params_key, 0, NULL)) {\n        BIO_printf(bio_err, \"unable to print params\\n\");\n        goto end;\n    }\n\n    if (check || check_named) {\n        BIO_printf(bio_err, \"checking elliptic curve parameters: \");\n\n        if (check_named\n            && !EVP_PKEY_set_utf8_string_param(params_key,\n                                           OSSL_PKEY_PARAM_EC_GROUP_CHECK_TYPE,\n                                           OSSL_PKEY_EC_GROUP_CHECK_NAMED)) {\n                BIO_printf(bio_err, \"unable to set check_type\\n\");\n                goto end;\n        }\n        pctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(), params_key,\n                                          app_get0_propq());\n        if (pctx == NULL || EVP_PKEY_param_check(pctx) <= 0) {\n            BIO_printf(bio_err, \"failed\\n\");\n            goto end;\n        }\n        BIO_printf(bio_err, \"ok\\n\");\n    }\n\n    if (outformat == FORMAT_ASN1 && genkey)\n        noout = 1;\n\n    if (!noout) {\n        ectx_params = OSSL_ENCODER_CTX_new_for_pkey(\n                          params_key, OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS,\n                          outformat == FORMAT_ASN1 ? \"DER\" : \"PEM\", NULL, NULL);\n        if (!OSSL_ENCODER_to_bio(ectx_params, out)) {\n            BIO_printf(bio_err, \"unable to write elliptic curve parameters\\n\");\n            goto end;\n        }\n    }\n\n    if (genkey) {\n        /*\n         * NOTE: EC keygen does not normally need to pass in the param_key\n         * for named curves. This can be achieved using:\n         *    gctx = EVP_PKEY_CTX_new_from_name(NULL, \"EC\", NULL);\n         *    EVP_PKEY_keygen_init(gctx);\n         *    EVP_PKEY_CTX_set_group_name(gctx, curvename);\n         *    EVP_PKEY_keygen(gctx, &key) <= 0)\n         */\n        gctx_key = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(), params_key,\n                                              app_get0_propq());\n        if (EVP_PKEY_keygen_init(gctx_key) <= 0\n            || EVP_PKEY_keygen(gctx_key, &key) <= 0) {\n            BIO_printf(bio_err, \"unable to generate key\\n\");\n            goto end;\n        }\n        assert(private);\n        ectx_key = OSSL_ENCODER_CTX_new_for_pkey(\n                       key, OSSL_KEYMGMT_SELECT_ALL,\n                       outformat == FORMAT_ASN1 ? \"DER\" : \"PEM\", NULL, NULL);\n        if (!OSSL_ENCODER_to_bio(ectx_key, out)) {\n            BIO_printf(bio_err, \"unable to write elliptic \"\n                       \"curve parameters\\n\");\n            goto end;\n        }\n    }\n\n    ret = 0;\nend:\n    if (ret != 0)\n        ERR_print_errors(bio_err);\n    release_engine(e);\n    EVP_PKEY_free(params_key);\n    EVP_PKEY_free(key);\n    EVP_PKEY_CTX_free(pctx);\n    EVP_PKEY_CTX_free(gctx_params);\n    EVP_PKEY_CTX_free(gctx_key);\n    OSSL_DECODER_CTX_free(dctx_params);\n    OSSL_ENCODER_CTX_free(ectx_params);\n    OSSL_ENCODER_CTX_free(ectx_key);\n    BIO_free_all(out);\n    return ret;\n}"
        ],
        "sink": "if (!OSSL_ENCODER_to_bio(ectx_key, out)) {",
        "final_sink": "if (!OSSL_ENCODER_to_bio(ectx_key, out)) {",
        "source": [
            "                X509_ALGOR *alg = OSSL_CMP_ATAV_get0_algId(atav);"
        ],
        "index": 18
    },
    {
        "prt": "id",
        "function_call": [
            "int engine_main(int argc, char **argv)\n{\n    int ret = 1, i;\n    int verbose = 0, list_cap = 0, test_avail = 0, test_avail_noise = 0;\n    ENGINE *e;\n    STACK_OF(OPENSSL_CSTRING) *engines = sk_OPENSSL_CSTRING_new_null();\n    STACK_OF(OPENSSL_STRING) *pre_cmds = sk_OPENSSL_STRING_new_null();\n    STACK_OF(OPENSSL_STRING) *post_cmds = sk_OPENSSL_STRING_new_null();\n    BIO *out;\n    const char *indent = \"     \";\n    OPTION_CHOICE o;\n    char *prog;\n    char *argv1;\n\n    out = dup_bio_out(FORMAT_TEXT);\n    if (engines == NULL || pre_cmds == NULL || post_cmds == NULL)\n        goto end;\n\n    /* Remember the original command name, parse/skip any leading engine\n     * names, and then setup to parse the rest of the line as flags. */\n    prog = argv[0];\n    while ((argv1 = argv[1]) != NULL && *argv1 != '-') {\n        sk_OPENSSL_CSTRING_push(engines, argv1);\n        argc--;\n        argv++;\n    }\n    argv[0] = prog;\n    opt_init(argc, argv, engine_options);\n\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(engine_options);\n            ret = 0;\n            goto end;\n        case OPT_VVVV:\n        case OPT_VVV:\n        case OPT_VV:\n        case OPT_V:\n            /* Convert to an integer from one to four. */\n            i = (int)(o - OPT_V) + 1;\n            if (verbose < i)\n                verbose = i;\n            break;\n        case OPT_C:\n            list_cap = 1;\n            break;\n        case OPT_TT:\n            test_avail_noise++;\n            /* fall through */\n        case OPT_T:\n            test_avail++;\n            break;\n        case OPT_PRE:\n            sk_OPENSSL_STRING_push(pre_cmds, opt_arg());\n            break;\n        case OPT_POST:\n            sk_OPENSSL_STRING_push(post_cmds, opt_arg());\n            break;\n        }\n    }\n\n    /* Any remaining arguments are engine names. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n    for ( ; *argv; argv++) {\n        if (**argv == '-') {\n            BIO_printf(bio_err, \"%s: Cannot mix flags and engine names.\\n\",\n                       prog);\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        }\n        sk_OPENSSL_CSTRING_push(engines, *argv);\n    }\n\n    if (sk_OPENSSL_CSTRING_num(engines) == 0) {\n        for (e = ENGINE_get_first(); e != NULL; e = ENGINE_get_next(e)) {\n            sk_OPENSSL_CSTRING_push(engines, ENGINE_get_id(e));\n        }\n    }\n\n    ret = 0;\n    for (i = 0; i < sk_OPENSSL_CSTRING_num(engines); i++) {\n        const char *id = sk_OPENSSL_CSTRING_value(engines, i);\n        if ((e = ENGINE_by_id(id)) != NULL) {\n            const char *name = ENGINE_get_name(e);\n            /*\n             * Do \"id\" first, then \"name\". Easier to auto-parse.\n             */\n            BIO_printf(out, \"(%s) %s\\n\", id, name);\n            util_do_cmds(e, pre_cmds, out, indent);\n            if (strcmp(ENGINE_get_id(e), id) != 0) {\n                BIO_printf(out, \"Loaded: (%s) %s\\n\",\n                           ENGINE_get_id(e), ENGINE_get_name(e));\n            }\n            if (list_cap) {\n                int cap_size = 256;\n                char *cap_buf = NULL;\n                int k, n;\n                const int *nids;\n                ENGINE_CIPHERS_PTR fn_c;\n                ENGINE_DIGESTS_PTR fn_d;\n                ENGINE_PKEY_METHS_PTR fn_pk;\n\n                if (ENGINE_get_RSA(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"RSA\"))\n                    goto end;\n                if (ENGINE_get_EC(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"EC\"))\n                    goto end;\n                if (ENGINE_get_DSA(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"DSA\"))\n                    goto end;\n                if (ENGINE_get_DH(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"DH\"))\n                    goto end;\n                if (ENGINE_get_RAND(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"RAND\"))\n                    goto end;\n\n                fn_c = ENGINE_get_ciphers(e);\n                if (fn_c == NULL)\n                    goto skip_ciphers;\n                n = fn_c(e, NULL, &nids, 0);\n                for (k = 0; k < n; ++k)\n                    if (!append_buf(&cap_buf, &cap_size, OBJ_nid2sn(nids[k])))\n                        goto end;\n\n skip_ciphers:\n                fn_d = ENGINE_get_digests(e);\n                if (fn_d == NULL)\n                    goto skip_digests;\n                n = fn_d(e, NULL, &nids, 0);\n                for (k = 0; k < n; ++k)\n                    if (!append_buf(&cap_buf, &cap_size, OBJ_nid2sn(nids[k])))\n                        goto end;\n\n skip_digests:\n                fn_pk = ENGINE_get_pkey_meths(e);\n                if (fn_pk == NULL)\n                    goto skip_pmeths;\n                n = fn_pk(e, NULL, &nids, 0);\n                for (k = 0; k < n; ++k)\n                    if (!append_buf(&cap_buf, &cap_size, OBJ_nid2sn(nids[k])))\n                        goto end;\n skip_pmeths:\n                {\n                    struct util_store_cap_data store_ctx;\n\n                    store_ctx.engine = e;\n                    store_ctx.cap_buf = &cap_buf;\n                    store_ctx.cap_size = &cap_size;\n                    store_ctx.ok = 1;\n\n                    OSSL_STORE_do_all_loaders(util_store_cap, &store_ctx);\n                    if (!store_ctx.ok)\n                        goto end;\n                }\n                if (cap_buf != NULL && (*cap_buf != '\\0'))\n                    BIO_printf(out, \" [%s]\\n\", cap_buf);\n\n                OPENSSL_free(cap_buf);\n            }\n            if (test_avail) {\n                BIO_printf(out, \"%s\", indent);\n                if (ENGINE_init(e)) {\n                    BIO_printf(out, \"[ available ]\\n\");\n                    util_do_cmds(e, post_cmds, out, indent);\n                    ENGINE_finish(e);\n                } else {\n                    BIO_printf(out, \"[ unavailable ]\\n\");\n                    if (test_avail_noise)\n                        ERR_print_errors_fp(stdout);\n                    ERR_clear_error();\n                }\n            }\n            if ((verbose > 0) && !util_verbose(e, verbose, out, indent))\n                goto end;\n            ENGINE_free(e);\n        } else {\n            ERR_print_errors(bio_err);\n            /* because exit codes above 127 have special meaning on Unix */\n            if (++ret > 127)\n                ret = 127;\n        }\n    }\n\n end:\n\n    ERR_print_errors(bio_err);\n    sk_OPENSSL_CSTRING_free(engines);\n    sk_OPENSSL_STRING_free(pre_cmds);\n    sk_OPENSSL_STRING_free(post_cmds);\n    BIO_free_all(out);\n    return ret;\n}"
        ],
        "sink": "if (strcmp(ENGINE_get_id(e), id) != 0) {",
        "final_sink": "if (strcmp(ENGINE_get_id(e), id) != 0) {",
        "source": [
            "            X509_VERIFY_PARAM *tls_vpm = NULL;"
        ],
        "index": 19
    },
    {
        "prt": "strcmp(ENGINE_get_id(e), id)",
        "function_call": [
            "int engine_main(int argc, char **argv)\n{\n    int ret = 1, i;\n    int verbose = 0, list_cap = 0, test_avail = 0, test_avail_noise = 0;\n    ENGINE *e;\n    STACK_OF(OPENSSL_CSTRING) *engines = sk_OPENSSL_CSTRING_new_null();\n    STACK_OF(OPENSSL_STRING) *pre_cmds = sk_OPENSSL_STRING_new_null();\n    STACK_OF(OPENSSL_STRING) *post_cmds = sk_OPENSSL_STRING_new_null();\n    BIO *out;\n    const char *indent = \"     \";\n    OPTION_CHOICE o;\n    char *prog;\n    char *argv1;\n\n    out = dup_bio_out(FORMAT_TEXT);\n    if (engines == NULL || pre_cmds == NULL || post_cmds == NULL)\n        goto end;\n\n    /* Remember the original command name, parse/skip any leading engine\n     * names, and then setup to parse the rest of the line as flags. */\n    prog = argv[0];\n    while ((argv1 = argv[1]) != NULL && *argv1 != '-') {\n        sk_OPENSSL_CSTRING_push(engines, argv1);\n        argc--;\n        argv++;\n    }\n    argv[0] = prog;\n    opt_init(argc, argv, engine_options);\n\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(engine_options);\n            ret = 0;\n            goto end;\n        case OPT_VVVV:\n        case OPT_VVV:\n        case OPT_VV:\n        case OPT_V:\n            /* Convert to an integer from one to four. */\n            i = (int)(o - OPT_V) + 1;\n            if (verbose < i)\n                verbose = i;\n            break;\n        case OPT_C:\n            list_cap = 1;\n            break;\n        case OPT_TT:\n            test_avail_noise++;\n            /* fall through */\n        case OPT_T:\n            test_avail++;\n            break;\n        case OPT_PRE:\n            sk_OPENSSL_STRING_push(pre_cmds, opt_arg());\n            break;\n        case OPT_POST:\n            sk_OPENSSL_STRING_push(post_cmds, opt_arg());\n            break;\n        }\n    }\n\n    /* Any remaining arguments are engine names. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n    for ( ; *argv; argv++) {\n        if (**argv == '-') {\n            BIO_printf(bio_err, \"%s: Cannot mix flags and engine names.\\n\",\n                       prog);\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        }\n        sk_OPENSSL_CSTRING_push(engines, *argv);\n    }\n\n    if (sk_OPENSSL_CSTRING_num(engines) == 0) {\n        for (e = ENGINE_get_first(); e != NULL; e = ENGINE_get_next(e)) {\n            sk_OPENSSL_CSTRING_push(engines, ENGINE_get_id(e));\n        }\n    }\n\n    ret = 0;\n    for (i = 0; i < sk_OPENSSL_CSTRING_num(engines); i++) {\n        const char *id = sk_OPENSSL_CSTRING_value(engines, i);\n        if ((e = ENGINE_by_id(id)) != NULL) {\n            const char *name = ENGINE_get_name(e);\n            /*\n             * Do \"id\" first, then \"name\". Easier to auto-parse.\n             */\n            BIO_printf(out, \"(%s) %s\\n\", id, name);\n            util_do_cmds(e, pre_cmds, out, indent);\n            if (strcmp(ENGINE_get_id(e), id) != 0) {\n                BIO_printf(out, \"Loaded: (%s) %s\\n\",\n                           ENGINE_get_id(e), ENGINE_get_name(e));\n            }\n            if (list_cap) {\n                int cap_size = 256;\n                char *cap_buf = NULL;\n                int k, n;\n                const int *nids;\n                ENGINE_CIPHERS_PTR fn_c;\n                ENGINE_DIGESTS_PTR fn_d;\n                ENGINE_PKEY_METHS_PTR fn_pk;\n\n                if (ENGINE_get_RSA(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"RSA\"))\n                    goto end;\n                if (ENGINE_get_EC(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"EC\"))\n                    goto end;\n                if (ENGINE_get_DSA(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"DSA\"))\n                    goto end;\n                if (ENGINE_get_DH(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"DH\"))\n                    goto end;\n                if (ENGINE_get_RAND(e) != NULL\n                    && !append_buf(&cap_buf, &cap_size, \"RAND\"))\n                    goto end;\n\n                fn_c = ENGINE_get_ciphers(e);\n                if (fn_c == NULL)\n                    goto skip_ciphers;\n                n = fn_c(e, NULL, &nids, 0);\n                for (k = 0; k < n; ++k)\n                    if (!append_buf(&cap_buf, &cap_size, OBJ_nid2sn(nids[k])))\n                        goto end;\n\n skip_ciphers:\n                fn_d = ENGINE_get_digests(e);\n                if (fn_d == NULL)\n                    goto skip_digests;\n                n = fn_d(e, NULL, &nids, 0);\n                for (k = 0; k < n; ++k)\n                    if (!append_buf(&cap_buf, &cap_size, OBJ_nid2sn(nids[k])))\n                        goto end;\n\n skip_digests:\n                fn_pk = ENGINE_get_pkey_meths(e);\n                if (fn_pk == NULL)\n                    goto skip_pmeths;\n                n = fn_pk(e, NULL, &nids, 0);\n                for (k = 0; k < n; ++k)\n                    if (!append_buf(&cap_buf, &cap_size, OBJ_nid2sn(nids[k])))\n                        goto end;\n skip_pmeths:\n                {\n                    struct util_store_cap_data store_ctx;\n\n                    store_ctx.engine = e;\n                    store_ctx.cap_buf = &cap_buf;\n                    store_ctx.cap_size = &cap_size;\n                    store_ctx.ok = 1;\n\n                    OSSL_STORE_do_all_loaders(util_store_cap, &store_ctx);\n                    if (!store_ctx.ok)\n                        goto end;\n                }\n                if (cap_buf != NULL && (*cap_buf != '\\0'))\n                    BIO_printf(out, \" [%s]\\n\", cap_buf);\n\n                OPENSSL_free(cap_buf);\n            }\n            if (test_avail) {\n                BIO_printf(out, \"%s\", indent);\n                if (ENGINE_init(e)) {\n                    BIO_printf(out, \"[ available ]\\n\");\n                    util_do_cmds(e, post_cmds, out, indent);\n                    ENGINE_finish(e);\n                } else {\n                    BIO_printf(out, \"[ unavailable ]\\n\");\n                    if (test_avail_noise)\n                        ERR_print_errors_fp(stdout);\n                    ERR_clear_error();\n                }\n            }\n            if ((verbose > 0) && !util_verbose(e, verbose, out, indent))\n                goto end;\n            ENGINE_free(e);\n        } else {\n            ERR_print_errors(bio_err);\n            /* because exit codes above 127 have special meaning on Unix */\n            if (++ret > 127)\n                ret = 127;\n        }\n    }\n\n end:\n\n    ERR_print_errors(bio_err);\n    sk_OPENSSL_CSTRING_free(engines);\n    sk_OPENSSL_STRING_free(pre_cmds);\n    sk_OPENSSL_STRING_free(post_cmds);\n    BIO_free_all(out);\n    return ret;\n}"
        ],
        "sink": "if (strcmp(ENGINE_get_id(e), id) != 0) {",
        "final_sink": "if (strcmp(ENGINE_get_id(e), id) != 0) {",
        "source": [
            "            gen = sk_GENERAL_NAME_value(gens, j);"
        ],
        "index": 20
    },
    {
        "prt": "cmd",
        "function_call": [
            "static void util_do_cmds(ENGINE *e, STACK_OF(OPENSSL_STRING) *cmds,\n                         BIO *out, const char *indent)\n{\n    int loop, res, num = sk_OPENSSL_STRING_num(cmds);\n\n    if (num < 0) {\n        BIO_printf(out, \"[Error]: internal stack error\\n\");\n        return;\n    }\n    for (loop = 0; loop < num; loop++) {\n        char buf[256];\n        const char *cmd, *arg;\n        cmd = sk_OPENSSL_STRING_value(cmds, loop);\n        res = 1;                /* assume success */\n        /* Check if this command has no \":arg\" */\n        if ((arg = strchr(cmd, ':')) == NULL) {\n            if (!ENGINE_ctrl_cmd_string(e, cmd, NULL, 0))\n                res = 0;\n        } else {\n            if ((int)(arg - cmd) > 254) {\n                BIO_printf(out, \"[Error]: command name too long\\n\");\n                return;\n            }\n            memcpy(buf, cmd, (int)(arg - cmd));\n            buf[arg - cmd] = '\\0';\n            arg++;              /* Move past the \":\" */\n            /* Call the command with the argument */\n            if (!ENGINE_ctrl_cmd_string(e, buf, arg, 0))\n                res = 0;\n        }\n        if (res) {\n            BIO_printf(out, \"[Success]: %s\\n\", cmd);\n        } else {\n            BIO_printf(out, \"[Failure]: %s\\n\", cmd);\n            ERR_print_errors(out);\n        }\n    }\n}"
        ],
        "sink": "memcpy(buf, cmd, (int)(arg - cmd));",
        "final_sink": "memcpy(buf, cmd, (int)(arg - cmd));",
        "source": [
            "    cms_key_param *key_first = NULL, *key_param = NULL;"
        ],
        "index": 21
    },
    {
        "prt": "p",
        "function_call": [
            "int app_RAND_load(void)\n{\n    char *p;\n    int i, ret = 1;\n\n    for (i = 0; i < sk_OPENSSL_STRING_num(randfiles); i++) {\n        p = sk_OPENSSL_STRING_value(randfiles, i);\n        if (!loadfiles(p))\n            ret = 0;\n    }\n    sk_OPENSSL_STRING_free(randfiles);\n    return ret;\n}"
        ],
        "sink": "if (!loadfiles(p))",
        "final_sink": "if (!loadfiles(p))",
        "source": [
            "            X509 *x = sk_X509_value(encerts, i);"
        ],
        "index": 22
    },
    {
        "prt": "dp",
        "function_call": [
            "static X509_CRL *load_crl_crldp(STACK_OF(DIST_POINT) *crldp)\n{\n    int i;\n    const char *urlptr = NULL;\n\n    for (i = 0; i < sk_DIST_POINT_num(crldp); i++) {\n        DIST_POINT *dp = sk_DIST_POINT_value(crldp, i);\n\n        urlptr = get_dp_url(dp);\n        if (urlptr != NULL)\n            return load_crl(urlptr, FORMAT_UNDEF, 0, \"CRL via CDP\");\n    }\n    return NULL;\n}",
            "static const char *get_dp_url(DIST_POINT *dp)\n{\n    GENERAL_NAMES *gens;\n    GENERAL_NAME *gen;\n    int i, gtype;\n    ASN1_STRING *uri;\n\n    if (!dp->distpoint || dp->distpoint->type != 0)\n        return NULL;\n    gens = dp->distpoint->name.fullname;\n    for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {\n        gen = sk_GENERAL_NAME_value(gens, i);\n        uri = GENERAL_NAME_get0_value(gen, &gtype);\n        if (gtype == GEN_URI && ASN1_STRING_length(uri) > 6) {\n            const char *uptr = (const char *)ASN1_STRING_get0_data(uri);\n\n            if (IS_HTTP(uptr)) /* can/should not use HTTPS here */\n                return uptr;\n        }\n    }\n    return NULL;\n}"
        ],
        "sink": "urlptr = get_dp_url(dp);",
        "final_sink": "    if (!dp->distpoint || dp->distpoint->type != 0)",
        "source": [
            "            pctx = CMS_RecipientInfo_get0_pkey_ctx(ri);"
        ],
        "index": 23
    },
    {
        "prt": "out",
        "function_call": [
            "unsigned char *next_protos_parse(size_t *outlen, const char *in)\n{\n    size_t len;\n    unsigned char *out;\n    size_t i, start = 0;\n    size_t skipped = 0;\n\n    len = strlen(in);\n    if (len == 0 || len >= 65535)\n        return NULL;\n\n    out = app_malloc(len + 1, \"NPN buffer\");\n    for (i = 0; i <= len; ++i) {\n        if (i == len || in[i] == ',') {\n            /*\n             * Zero-length ALPN elements are invalid on the wire, we could be\n             * strict and reject the entire string, but just ignoring extra\n             * commas seems harmless and more friendly.\n             *\n             * Every comma we skip in this way puts the input buffer another\n             * byte ahead of the output buffer, so all stores into the output\n             * buffer need to be decremented by the number commas skipped.\n             */\n            if (i == start) {\n                ++start;\n                ++skipped;\n                continue;\n            }\n            if (i - start > 255) {\n                OPENSSL_free(out);\n                return NULL;\n            }\n            out[start - skipped] = (unsigned char)(i - start);\n            start = i + 1;\n        } else {\n            out[i + 1 - skipped] = in[i];\n        }\n    }\n\n    if (len <= skipped) {\n        OPENSSL_free(out);\n        return NULL;\n    }\n\n    *outlen = len + 1 - skipped;\n    return out;\n}"
        ],
        "sink": "out[start - skipped] = (unsigned char)(i - start);",
        "final_sink": "out[start - skipped] = (unsigned char)(i - start);",
        "source": [
            "                wctx = CMS_RecipientInfo_kari_get0_ctx(ri);"
        ],
        "index": 24
    },
    {
        "prt": "bn_ctx",
        "function_call": [
            "static int srp_Verify_N_and_g(const BIGNUM *N, const BIGNUM *g)\n{\n    BN_CTX *bn_ctx = BN_CTX_new();\n    BIGNUM *p = BN_new();\n    BIGNUM *r = BN_new();\n    int ret =\n        g != NULL && N != NULL && bn_ctx != NULL && BN_is_odd(N) &&\n        BN_check_prime(N, bn_ctx, NULL) == 1 &&\n        p != NULL && BN_rshift1(p, N) &&\n        /* p = (N-1)/2 */\n        BN_check_prime(p, bn_ctx, NULL) == 1 &&\n        r != NULL &&\n        /* verify g^((N-1)/2) == -1 (mod N) */\n        BN_mod_exp(r, g, p, N, bn_ctx) &&\n        BN_add_word(r, 1) && BN_cmp(r, N) == 0;\n\n    BN_free(r);\n    BN_free(p);\n    BN_CTX_free(bn_ctx);\n    return ret;\n}",
            "void BN_CTX_free(BN_CTX *ctx)\n{\n    if (ctx == NULL)\n        return;\n#ifndef FIPS_MODULE\n    OSSL_TRACE_BEGIN(BN_CTX) {\n        BN_POOL_ITEM *pool = ctx->pool.head;\n        BIO_printf(trc_out,\n                   \"BN_CTX_free(): stack-size=%d, pool-bignums=%d\\n\",\n                   ctx->stack.size, ctx->pool.size);\n        BIO_printf(trc_out, \"  dmaxs: \");\n        while (pool) {\n            unsigned loop = 0;\n            while (loop < BN_CTX_POOL_SIZE)\n                BIO_printf(trc_out, \"%02x \", pool->vals[loop++].dmax);\n            pool = pool->next;\n        }\n        BIO_printf(trc_out, \"\\n\");\n    } OSSL_TRACE_END(BN_CTX);\n#endif\n    BN_STACK_finish(&ctx->stack);\n    BN_POOL_finish(&ctx->pool);\n    OPENSSL_free(ctx);\n}"
        ],
        "sink": "BN_CTX_free(bn_ctx);",
        "final_sink": "        BN_POOL_ITEM *pool = ctx->pool.head;",
        "source": [
            "    CMS_ContentInfo *cms = NULL, *rcms = NULL;",
            "        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");"
        ],
        "index": 25
    },
    {
        "prt": "bs",
        "function_call": [
            "static void make_ocsp_response(BIO *err, OCSP_RESPONSE **resp, OCSP_REQUEST *req,\n                              CA_DB *db, STACK_OF(X509) *ca, X509 *rcert,\n                              EVP_PKEY *rkey, const EVP_MD *rmd,\n                              STACK_OF(OPENSSL_STRING) *sigopts,\n                              STACK_OF(X509) *rother, unsigned long flags,\n                              int nmin, int ndays, int badsig,\n                              const EVP_MD *resp_md)\n{\n    ASN1_TIME *thisupd = NULL, *nextupd = NULL;\n    OCSP_CERTID *cid;\n    OCSP_BASICRESP *bs = NULL;\n    int i, id_count;\n    EVP_MD_CTX *mctx = NULL;\n    EVP_PKEY_CTX *pkctx = NULL;\n\n    id_count = OCSP_request_onereq_count(req);\n\n    if (id_count <= 0) {\n        *resp =\n            OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, NULL);\n        goto end;\n    }\n\n    bs = OCSP_BASICRESP_new();\n    thisupd = X509_gmtime_adj(NULL, 0);\n    if (ndays != -1)\n        nextupd = X509_time_adj_ex(NULL, ndays, nmin * 60, NULL);\n\n    /* Examine each certificate id in the request */\n    for (i = 0; i < id_count; i++) {\n        OCSP_ONEREQ *one;\n        ASN1_INTEGER *serial;\n        char **inf;\n        int jj;\n        int found = 0;\n        ASN1_OBJECT *cert_id_md_oid;\n        const EVP_MD *cert_id_md;\n        OCSP_CERTID *cid_resp_md = NULL;\n\n        one = OCSP_request_onereq_get0(req, i);\n        cid = OCSP_onereq_get0_id(one);\n\n        OCSP_id_get0_info(NULL, &cert_id_md_oid, NULL, NULL, cid);\n\n        cert_id_md = EVP_get_digestbyobj(cert_id_md_oid);\n        if (cert_id_md == NULL) {\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n        for (jj = 0; jj < sk_X509_num(ca) && !found; jj++) {\n            X509 *ca_cert = sk_X509_value(ca, jj);\n            OCSP_CERTID *ca_id = OCSP_cert_to_id(cert_id_md, NULL, ca_cert);\n\n            if (OCSP_id_issuer_cmp(ca_id, cid) == 0) {\n                found = 1;\n                if (resp_md != NULL)\n                    cid_resp_md = OCSP_cert_to_id(resp_md, NULL, ca_cert);\n            }\n            OCSP_CERTID_free(ca_id);\n        }\n        OCSP_id_get0_info(NULL, NULL, NULL, &serial, cid);\n        inf = lookup_serial(db, serial);\n\n        /* at this point, we can have cid be an alias of cid_resp_md */\n        cid = (cid_resp_md != NULL) ? cid_resp_md : cid;\n\n        if (!found) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n            continue;\n        }\n        if (inf == NULL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_VAL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_GOOD,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_REV) {\n            ASN1_OBJECT *inst = NULL;\n            ASN1_TIME *revtm = NULL;\n            ASN1_GENERALIZEDTIME *invtm = NULL;\n            OCSP_SINGLERESP *single;\n            int reason = -1;\n\n            unpack_revinfo(&revtm, &reason, &inst, &invtm, inf[DB_rev_date]);\n            single = OCSP_basic_add1_status(bs, cid,\n                                            V_OCSP_CERTSTATUS_REVOKED,\n                                            reason, revtm, thisupd, nextupd);\n            if (single == NULL) {\n                *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                             NULL);\n                goto end;\n            }\n            if (invtm != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single, NID_invalidity_date,\n                                             invtm, 0, 0);\n            else if (inst != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single,\n                                             NID_hold_instruction_code, inst,\n                                             0, 0);\n            ASN1_OBJECT_free(inst);\n            ASN1_TIME_free(revtm);\n            ASN1_GENERALIZEDTIME_free(invtm);\n        }\n        OCSP_CERTID_free(cid_resp_md);\n    }\n\n    OCSP_copy_nonce(bs, req);\n\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL || !EVP_DigestSignInit(mctx, &pkctx, rmd, NULL, rkey)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, NULL);\n        goto end;\n    }\n    for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++) {\n        char *sigopt = sk_OPENSSL_STRING_value(sigopts, i);\n\n        if (pkey_ctrl_string(pkctx, sigopt) <= 0) {\n            BIO_printf(err, \"parameter error \\\"%s\\\"\\n\", sigopt);\n            ERR_print_errors(bio_err);\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n    }\n    if (!OCSP_basic_sign_ctx(bs, rcert, mctx, rother, flags)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, bs);\n        goto end;\n    }\n\n    if (badsig) {\n        const ASN1_OCTET_STRING *sig = OCSP_resp_get0_signature(bs);\n        corrupt_signature(sig);\n    }\n\n    *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_SUCCESSFUL, bs);\n\n end:\n    EVP_MD_CTX_free(mctx);\n    ASN1_TIME_free(thisupd);\n    ASN1_TIME_free(nextupd);\n    OCSP_BASICRESP_free(bs);\n}"
        ],
        "sink": "OCSP_basic_add1_status(bs, cid,",
        "final_sink": "OCSP_basic_add1_status(bs, cid,",
        "source": [
            "        si = sk_CMS_SignerInfo_value(sis, 0);"
        ],
        "index": 26
    },
    {
        "prt": "bs",
        "function_call": [
            "static void make_ocsp_response(BIO *err, OCSP_RESPONSE **resp, OCSP_REQUEST *req,\n                              CA_DB *db, STACK_OF(X509) *ca, X509 *rcert,\n                              EVP_PKEY *rkey, const EVP_MD *rmd,\n                              STACK_OF(OPENSSL_STRING) *sigopts,\n                              STACK_OF(X509) *rother, unsigned long flags,\n                              int nmin, int ndays, int badsig,\n                              const EVP_MD *resp_md)\n{\n    ASN1_TIME *thisupd = NULL, *nextupd = NULL;\n    OCSP_CERTID *cid;\n    OCSP_BASICRESP *bs = NULL;\n    int i, id_count;\n    EVP_MD_CTX *mctx = NULL;\n    EVP_PKEY_CTX *pkctx = NULL;\n\n    id_count = OCSP_request_onereq_count(req);\n\n    if (id_count <= 0) {\n        *resp =\n            OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, NULL);\n        goto end;\n    }\n\n    bs = OCSP_BASICRESP_new();\n    thisupd = X509_gmtime_adj(NULL, 0);\n    if (ndays != -1)\n        nextupd = X509_time_adj_ex(NULL, ndays, nmin * 60, NULL);\n\n    /* Examine each certificate id in the request */\n    for (i = 0; i < id_count; i++) {\n        OCSP_ONEREQ *one;\n        ASN1_INTEGER *serial;\n        char **inf;\n        int jj;\n        int found = 0;\n        ASN1_OBJECT *cert_id_md_oid;\n        const EVP_MD *cert_id_md;\n        OCSP_CERTID *cid_resp_md = NULL;\n\n        one = OCSP_request_onereq_get0(req, i);\n        cid = OCSP_onereq_get0_id(one);\n\n        OCSP_id_get0_info(NULL, &cert_id_md_oid, NULL, NULL, cid);\n\n        cert_id_md = EVP_get_digestbyobj(cert_id_md_oid);\n        if (cert_id_md == NULL) {\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n        for (jj = 0; jj < sk_X509_num(ca) && !found; jj++) {\n            X509 *ca_cert = sk_X509_value(ca, jj);\n            OCSP_CERTID *ca_id = OCSP_cert_to_id(cert_id_md, NULL, ca_cert);\n\n            if (OCSP_id_issuer_cmp(ca_id, cid) == 0) {\n                found = 1;\n                if (resp_md != NULL)\n                    cid_resp_md = OCSP_cert_to_id(resp_md, NULL, ca_cert);\n            }\n            OCSP_CERTID_free(ca_id);\n        }\n        OCSP_id_get0_info(NULL, NULL, NULL, &serial, cid);\n        inf = lookup_serial(db, serial);\n\n        /* at this point, we can have cid be an alias of cid_resp_md */\n        cid = (cid_resp_md != NULL) ? cid_resp_md : cid;\n\n        if (!found) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n            continue;\n        }\n        if (inf == NULL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_VAL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_GOOD,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_REV) {\n            ASN1_OBJECT *inst = NULL;\n            ASN1_TIME *revtm = NULL;\n            ASN1_GENERALIZEDTIME *invtm = NULL;\n            OCSP_SINGLERESP *single;\n            int reason = -1;\n\n            unpack_revinfo(&revtm, &reason, &inst, &invtm, inf[DB_rev_date]);\n            single = OCSP_basic_add1_status(bs, cid,\n                                            V_OCSP_CERTSTATUS_REVOKED,\n                                            reason, revtm, thisupd, nextupd);\n            if (single == NULL) {\n                *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                             NULL);\n                goto end;\n            }\n            if (invtm != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single, NID_invalidity_date,\n                                             invtm, 0, 0);\n            else if (inst != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single,\n                                             NID_hold_instruction_code, inst,\n                                             0, 0);\n            ASN1_OBJECT_free(inst);\n            ASN1_TIME_free(revtm);\n            ASN1_GENERALIZEDTIME_free(invtm);\n        }\n        OCSP_CERTID_free(cid_resp_md);\n    }\n\n    OCSP_copy_nonce(bs, req);\n\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL || !EVP_DigestSignInit(mctx, &pkctx, rmd, NULL, rkey)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, NULL);\n        goto end;\n    }\n    for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++) {\n        char *sigopt = sk_OPENSSL_STRING_value(sigopts, i);\n\n        if (pkey_ctrl_string(pkctx, sigopt) <= 0) {\n            BIO_printf(err, \"parameter error \\\"%s\\\"\\n\", sigopt);\n            ERR_print_errors(bio_err);\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n    }\n    if (!OCSP_basic_sign_ctx(bs, rcert, mctx, rother, flags)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, bs);\n        goto end;\n    }\n\n    if (badsig) {\n        const ASN1_OCTET_STRING *sig = OCSP_resp_get0_signature(bs);\n        corrupt_signature(sig);\n    }\n\n    *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_SUCCESSFUL, bs);\n\n end:\n    EVP_MD_CTX_free(mctx);\n    ASN1_TIME_free(thisupd);\n    ASN1_TIME_free(nextupd);\n    OCSP_BASICRESP_free(bs);\n}"
        ],
        "sink": "OCSP_basic_add1_status(bs, cid,",
        "final_sink": "OCSP_basic_add1_status(bs, cid,",
        "source": [
            "    CMS_ContentInfo *cms = NULL, *rcms = NULL;",
            "        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");",
            "            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());"
        ],
        "index": 27
    },
    {
        "prt": "bs",
        "function_call": [
            "static void make_ocsp_response(BIO *err, OCSP_RESPONSE **resp, OCSP_REQUEST *req,\n                              CA_DB *db, STACK_OF(X509) *ca, X509 *rcert,\n                              EVP_PKEY *rkey, const EVP_MD *rmd,\n                              STACK_OF(OPENSSL_STRING) *sigopts,\n                              STACK_OF(X509) *rother, unsigned long flags,\n                              int nmin, int ndays, int badsig,\n                              const EVP_MD *resp_md)\n{\n    ASN1_TIME *thisupd = NULL, *nextupd = NULL;\n    OCSP_CERTID *cid;\n    OCSP_BASICRESP *bs = NULL;\n    int i, id_count;\n    EVP_MD_CTX *mctx = NULL;\n    EVP_PKEY_CTX *pkctx = NULL;\n\n    id_count = OCSP_request_onereq_count(req);\n\n    if (id_count <= 0) {\n        *resp =\n            OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, NULL);\n        goto end;\n    }\n\n    bs = OCSP_BASICRESP_new();\n    thisupd = X509_gmtime_adj(NULL, 0);\n    if (ndays != -1)\n        nextupd = X509_time_adj_ex(NULL, ndays, nmin * 60, NULL);\n\n    /* Examine each certificate id in the request */\n    for (i = 0; i < id_count; i++) {\n        OCSP_ONEREQ *one;\n        ASN1_INTEGER *serial;\n        char **inf;\n        int jj;\n        int found = 0;\n        ASN1_OBJECT *cert_id_md_oid;\n        const EVP_MD *cert_id_md;\n        OCSP_CERTID *cid_resp_md = NULL;\n\n        one = OCSP_request_onereq_get0(req, i);\n        cid = OCSP_onereq_get0_id(one);\n\n        OCSP_id_get0_info(NULL, &cert_id_md_oid, NULL, NULL, cid);\n\n        cert_id_md = EVP_get_digestbyobj(cert_id_md_oid);\n        if (cert_id_md == NULL) {\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n        for (jj = 0; jj < sk_X509_num(ca) && !found; jj++) {\n            X509 *ca_cert = sk_X509_value(ca, jj);\n            OCSP_CERTID *ca_id = OCSP_cert_to_id(cert_id_md, NULL, ca_cert);\n\n            if (OCSP_id_issuer_cmp(ca_id, cid) == 0) {\n                found = 1;\n                if (resp_md != NULL)\n                    cid_resp_md = OCSP_cert_to_id(resp_md, NULL, ca_cert);\n            }\n            OCSP_CERTID_free(ca_id);\n        }\n        OCSP_id_get0_info(NULL, NULL, NULL, &serial, cid);\n        inf = lookup_serial(db, serial);\n\n        /* at this point, we can have cid be an alias of cid_resp_md */\n        cid = (cid_resp_md != NULL) ? cid_resp_md : cid;\n\n        if (!found) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n            continue;\n        }\n        if (inf == NULL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_VAL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_GOOD,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_REV) {\n            ASN1_OBJECT *inst = NULL;\n            ASN1_TIME *revtm = NULL;\n            ASN1_GENERALIZEDTIME *invtm = NULL;\n            OCSP_SINGLERESP *single;\n            int reason = -1;\n\n            unpack_revinfo(&revtm, &reason, &inst, &invtm, inf[DB_rev_date]);\n            single = OCSP_basic_add1_status(bs, cid,\n                                            V_OCSP_CERTSTATUS_REVOKED,\n                                            reason, revtm, thisupd, nextupd);\n            if (single == NULL) {\n                *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                             NULL);\n                goto end;\n            }\n            if (invtm != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single, NID_invalidity_date,\n                                             invtm, 0, 0);\n            else if (inst != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single,\n                                             NID_hold_instruction_code, inst,\n                                             0, 0);\n            ASN1_OBJECT_free(inst);\n            ASN1_TIME_free(revtm);\n            ASN1_GENERALIZEDTIME_free(invtm);\n        }\n        OCSP_CERTID_free(cid_resp_md);\n    }\n\n    OCSP_copy_nonce(bs, req);\n\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL || !EVP_DigestSignInit(mctx, &pkctx, rmd, NULL, rkey)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, NULL);\n        goto end;\n    }\n    for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++) {\n        char *sigopt = sk_OPENSSL_STRING_value(sigopts, i);\n\n        if (pkey_ctrl_string(pkctx, sigopt) <= 0) {\n            BIO_printf(err, \"parameter error \\\"%s\\\"\\n\", sigopt);\n            ERR_print_errors(bio_err);\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n    }\n    if (!OCSP_basic_sign_ctx(bs, rcert, mctx, rother, flags)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, bs);\n        goto end;\n    }\n\n    if (badsig) {\n        const ASN1_OCTET_STRING *sig = OCSP_resp_get0_signature(bs);\n        corrupt_signature(sig);\n    }\n\n    *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_SUCCESSFUL, bs);\n\n end:\n    EVP_MD_CTX_free(mctx);\n    ASN1_TIME_free(thisupd);\n    ASN1_TIME_free(nextupd);\n    OCSP_BASICRESP_free(bs);\n}"
        ],
        "sink": "OCSP_basic_add1_status(bs, cid,",
        "final_sink": "OCSP_basic_add1_status(bs, cid,",
        "source": [
            "    CMS_ContentInfo *cms = NULL, *rcms = NULL;",
            "        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");",
            "            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());"
        ],
        "index": 28
    },
    {
        "prt": "bs",
        "function_call": [
            "static void make_ocsp_response(BIO *err, OCSP_RESPONSE **resp, OCSP_REQUEST *req,\n                              CA_DB *db, STACK_OF(X509) *ca, X509 *rcert,\n                              EVP_PKEY *rkey, const EVP_MD *rmd,\n                              STACK_OF(OPENSSL_STRING) *sigopts,\n                              STACK_OF(X509) *rother, unsigned long flags,\n                              int nmin, int ndays, int badsig,\n                              const EVP_MD *resp_md)\n{\n    ASN1_TIME *thisupd = NULL, *nextupd = NULL;\n    OCSP_CERTID *cid;\n    OCSP_BASICRESP *bs = NULL;\n    int i, id_count;\n    EVP_MD_CTX *mctx = NULL;\n    EVP_PKEY_CTX *pkctx = NULL;\n\n    id_count = OCSP_request_onereq_count(req);\n\n    if (id_count <= 0) {\n        *resp =\n            OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, NULL);\n        goto end;\n    }\n\n    bs = OCSP_BASICRESP_new();\n    thisupd = X509_gmtime_adj(NULL, 0);\n    if (ndays != -1)\n        nextupd = X509_time_adj_ex(NULL, ndays, nmin * 60, NULL);\n\n    /* Examine each certificate id in the request */\n    for (i = 0; i < id_count; i++) {\n        OCSP_ONEREQ *one;\n        ASN1_INTEGER *serial;\n        char **inf;\n        int jj;\n        int found = 0;\n        ASN1_OBJECT *cert_id_md_oid;\n        const EVP_MD *cert_id_md;\n        OCSP_CERTID *cid_resp_md = NULL;\n\n        one = OCSP_request_onereq_get0(req, i);\n        cid = OCSP_onereq_get0_id(one);\n\n        OCSP_id_get0_info(NULL, &cert_id_md_oid, NULL, NULL, cid);\n\n        cert_id_md = EVP_get_digestbyobj(cert_id_md_oid);\n        if (cert_id_md == NULL) {\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n        for (jj = 0; jj < sk_X509_num(ca) && !found; jj++) {\n            X509 *ca_cert = sk_X509_value(ca, jj);\n            OCSP_CERTID *ca_id = OCSP_cert_to_id(cert_id_md, NULL, ca_cert);\n\n            if (OCSP_id_issuer_cmp(ca_id, cid) == 0) {\n                found = 1;\n                if (resp_md != NULL)\n                    cid_resp_md = OCSP_cert_to_id(resp_md, NULL, ca_cert);\n            }\n            OCSP_CERTID_free(ca_id);\n        }\n        OCSP_id_get0_info(NULL, NULL, NULL, &serial, cid);\n        inf = lookup_serial(db, serial);\n\n        /* at this point, we can have cid be an alias of cid_resp_md */\n        cid = (cid_resp_md != NULL) ? cid_resp_md : cid;\n\n        if (!found) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n            continue;\n        }\n        if (inf == NULL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_VAL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_GOOD,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_REV) {\n            ASN1_OBJECT *inst = NULL;\n            ASN1_TIME *revtm = NULL;\n            ASN1_GENERALIZEDTIME *invtm = NULL;\n            OCSP_SINGLERESP *single;\n            int reason = -1;\n\n            unpack_revinfo(&revtm, &reason, &inst, &invtm, inf[DB_rev_date]);\n            single = OCSP_basic_add1_status(bs, cid,\n                                            V_OCSP_CERTSTATUS_REVOKED,\n                                            reason, revtm, thisupd, nextupd);\n            if (single == NULL) {\n                *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                             NULL);\n                goto end;\n            }\n            if (invtm != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single, NID_invalidity_date,\n                                             invtm, 0, 0);\n            else if (inst != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single,\n                                             NID_hold_instruction_code, inst,\n                                             0, 0);\n            ASN1_OBJECT_free(inst);\n            ASN1_TIME_free(revtm);\n            ASN1_GENERALIZEDTIME_free(invtm);\n        }\n        OCSP_CERTID_free(cid_resp_md);\n    }\n\n    OCSP_copy_nonce(bs, req);\n\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL || !EVP_DigestSignInit(mctx, &pkctx, rmd, NULL, rkey)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, NULL);\n        goto end;\n    }\n    for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++) {\n        char *sigopt = sk_OPENSSL_STRING_value(sigopts, i);\n\n        if (pkey_ctrl_string(pkctx, sigopt) <= 0) {\n            BIO_printf(err, \"parameter error \\\"%s\\\"\\n\", sigopt);\n            ERR_print_errors(bio_err);\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n    }\n    if (!OCSP_basic_sign_ctx(bs, rcert, mctx, rother, flags)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, bs);\n        goto end;\n    }\n\n    if (badsig) {\n        const ASN1_OCTET_STRING *sig = OCSP_resp_get0_signature(bs);\n        corrupt_signature(sig);\n    }\n\n    *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_SUCCESSFUL, bs);\n\n end:\n    EVP_MD_CTX_free(mctx);\n    ASN1_TIME_free(thisupd);\n    ASN1_TIME_free(nextupd);\n    OCSP_BASICRESP_free(bs);\n}"
        ],
        "sink": "single = OCSP_basic_add1_status(bs, cid,",
        "final_sink": "single = OCSP_basic_add1_status(bs, cid,",
        "source": [
            "    CMS_ContentInfo *cms = NULL, *rcms = NULL;",
            "        cms = load_content_info(informat, in, flags, &indata, \"SMIME\");",
            "            cms = CMS_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());"
        ],
        "index": 29
    },
    {
        "prt": "bs",
        "function_call": [
            "static void make_ocsp_response(BIO *err, OCSP_RESPONSE **resp, OCSP_REQUEST *req,\n                              CA_DB *db, STACK_OF(X509) *ca, X509 *rcert,\n                              EVP_PKEY *rkey, const EVP_MD *rmd,\n                              STACK_OF(OPENSSL_STRING) *sigopts,\n                              STACK_OF(X509) *rother, unsigned long flags,\n                              int nmin, int ndays, int badsig,\n                              const EVP_MD *resp_md)\n{\n    ASN1_TIME *thisupd = NULL, *nextupd = NULL;\n    OCSP_CERTID *cid;\n    OCSP_BASICRESP *bs = NULL;\n    int i, id_count;\n    EVP_MD_CTX *mctx = NULL;\n    EVP_PKEY_CTX *pkctx = NULL;\n\n    id_count = OCSP_request_onereq_count(req);\n\n    if (id_count <= 0) {\n        *resp =\n            OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST, NULL);\n        goto end;\n    }\n\n    bs = OCSP_BASICRESP_new();\n    thisupd = X509_gmtime_adj(NULL, 0);\n    if (ndays != -1)\n        nextupd = X509_time_adj_ex(NULL, ndays, nmin * 60, NULL);\n\n    /* Examine each certificate id in the request */\n    for (i = 0; i < id_count; i++) {\n        OCSP_ONEREQ *one;\n        ASN1_INTEGER *serial;\n        char **inf;\n        int jj;\n        int found = 0;\n        ASN1_OBJECT *cert_id_md_oid;\n        const EVP_MD *cert_id_md;\n        OCSP_CERTID *cid_resp_md = NULL;\n\n        one = OCSP_request_onereq_get0(req, i);\n        cid = OCSP_onereq_get0_id(one);\n\n        OCSP_id_get0_info(NULL, &cert_id_md_oid, NULL, NULL, cid);\n\n        cert_id_md = EVP_get_digestbyobj(cert_id_md_oid);\n        if (cert_id_md == NULL) {\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n        for (jj = 0; jj < sk_X509_num(ca) && !found; jj++) {\n            X509 *ca_cert = sk_X509_value(ca, jj);\n            OCSP_CERTID *ca_id = OCSP_cert_to_id(cert_id_md, NULL, ca_cert);\n\n            if (OCSP_id_issuer_cmp(ca_id, cid) == 0) {\n                found = 1;\n                if (resp_md != NULL)\n                    cid_resp_md = OCSP_cert_to_id(resp_md, NULL, ca_cert);\n            }\n            OCSP_CERTID_free(ca_id);\n        }\n        OCSP_id_get0_info(NULL, NULL, NULL, &serial, cid);\n        inf = lookup_serial(db, serial);\n\n        /* at this point, we can have cid be an alias of cid_resp_md */\n        cid = (cid_resp_md != NULL) ? cid_resp_md : cid;\n\n        if (!found) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n            continue;\n        }\n        if (inf == NULL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_UNKNOWN,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_VAL) {\n            OCSP_basic_add1_status(bs, cid,\n                                   V_OCSP_CERTSTATUS_GOOD,\n                                   0, NULL, thisupd, nextupd);\n        } else if (inf[DB_type][0] == DB_TYPE_REV) {\n            ASN1_OBJECT *inst = NULL;\n            ASN1_TIME *revtm = NULL;\n            ASN1_GENERALIZEDTIME *invtm = NULL;\n            OCSP_SINGLERESP *single;\n            int reason = -1;\n\n            unpack_revinfo(&revtm, &reason, &inst, &invtm, inf[DB_rev_date]);\n            single = OCSP_basic_add1_status(bs, cid,\n                                            V_OCSP_CERTSTATUS_REVOKED,\n                                            reason, revtm, thisupd, nextupd);\n            if (single == NULL) {\n                *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                             NULL);\n                goto end;\n            }\n            if (invtm != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single, NID_invalidity_date,\n                                             invtm, 0, 0);\n            else if (inst != NULL)\n                OCSP_SINGLERESP_add1_ext_i2d(single,\n                                             NID_hold_instruction_code, inst,\n                                             0, 0);\n            ASN1_OBJECT_free(inst);\n            ASN1_TIME_free(revtm);\n            ASN1_GENERALIZEDTIME_free(invtm);\n        }\n        OCSP_CERTID_free(cid_resp_md);\n    }\n\n    OCSP_copy_nonce(bs, req);\n\n    mctx = EVP_MD_CTX_new();\n    if (mctx == NULL || !EVP_DigestSignInit(mctx, &pkctx, rmd, NULL, rkey)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, NULL);\n        goto end;\n    }\n    for (i = 0; i < sk_OPENSSL_STRING_num(sigopts); i++) {\n        char *sigopt = sk_OPENSSL_STRING_value(sigopts, i);\n\n        if (pkey_ctrl_string(pkctx, sigopt) <= 0) {\n            BIO_printf(err, \"parameter error \\\"%s\\\"\\n\", sigopt);\n            ERR_print_errors(bio_err);\n            *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR,\n                                         NULL);\n            goto end;\n        }\n    }\n    if (!OCSP_basic_sign_ctx(bs, rcert, mctx, rother, flags)) {\n        *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_INTERNALERROR, bs);\n        goto end;\n    }\n\n    if (badsig) {\n        const ASN1_OCTET_STRING *sig = OCSP_resp_get0_signature(bs);\n        corrupt_signature(sig);\n    }\n\n    *resp = OCSP_response_create(OCSP_RESPONSE_STATUS_SUCCESSFUL, bs);\n\n end:\n    EVP_MD_CTX_free(mctx);\n    ASN1_TIME_free(thisupd);\n    ASN1_TIME_free(nextupd);\n    OCSP_BASICRESP_free(bs);\n}",
            "int OCSP_copy_nonce(OCSP_BASICRESP *resp, OCSP_REQUEST *req)\n{\n    X509_EXTENSION *req_ext;\n    int req_idx;\n    /* Check for nonce in request */\n    req_idx = OCSP_REQUEST_get_ext_by_NID(req, NID_id_pkix_OCSP_Nonce, -1);\n    /* If no nonce that's OK */\n    if (req_idx < 0)\n        return 2;\n    req_ext = OCSP_REQUEST_get_ext(req, req_idx);\n    return OCSP_BASICRESP_add_ext(resp, req_ext, -1);\n}",
            "int OCSP_BASICRESP_add_ext(OCSP_BASICRESP *x, X509_EXTENSION *ex, int loc)\n{\n    return (X509v3_add_ext(&(x->tbsResponseData.responseExtensions), ex, loc)\n            != NULL);\n}"
        ],
        "sink": "OCSP_copy_nonce(bs, req);",
        "final_sink": "    return (X509v3_add_ext(&(x->tbsResponseData.responseExtensions), ex, loc)",
        "source": [
            "    CMS_ContentInfo *cms = NULL, *rcms = NULL;",
            "        rcms = load_content_info(rctformat, rctin, 0, NULL, \"receipt\");"
        ],
        "index": 30
    },
    {
        "prt": "req",
        "function_call": [
            "int ocsp_main(int argc, char **argv)\n{\n    BIO *acbio = NULL, *cbio = NULL, *derbio = NULL, *out = NULL;\n    EVP_MD *cert_id_md = NULL, *rsign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rsign_sigopts = NULL;\n    int trailing_md = 0;\n    CA_DB *rdb = NULL;\n    EVP_PKEY *key = NULL, *rkey = NULL;\n    OCSP_BASICRESP *bs = NULL;\n    OCSP_REQUEST *req = NULL;\n    OCSP_RESPONSE *resp = NULL;\n    STACK_OF(CONF_VALUE) *headers = NULL;\n    STACK_OF(OCSP_CERTID) *ids = NULL;\n    STACK_OF(OPENSSL_STRING) *reqnames = NULL;\n    STACK_OF(X509) *sign_other = NULL, *verify_other = NULL, *rother = NULL;\n    STACK_OF(X509) *issuers = NULL;\n    X509 *issuer = NULL, *cert = NULL;\n    STACK_OF(X509) *rca_certs = NULL;\n    EVP_MD *resp_certid_md = NULL;\n    X509 *signer = NULL, *rsigner = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *header, *value, *respdigname = NULL;\n    char *host = NULL, *port = NULL, *path = \"/\", *outfile = NULL;\n#ifndef OPENSSL_NO_SOCK\n    char *opt_proxy = NULL;\n    char *opt_no_proxy = NULL;\n#endif\n    char *rca_filename = NULL, *reqin = NULL, *respin = NULL;\n    char *reqout = NULL, *respout = NULL, *ridx_filename = NULL;\n    char *rsignfile = NULL, *rkeyfile = NULL;\n    char *passinarg = NULL, *passin = NULL;\n    char *sign_certfile = NULL, *verify_certfile = NULL, *rcertfile = NULL;\n    char *signfile = NULL, *keyfile = NULL;\n    char *thost = NULL, *tport = NULL, *tpath = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    int accept_count = -1, add_nonce = 1, noverify = 0, use_ssl = -1;\n    int vpmtouched = 0, badsig = 0, i, ignore_err = 0, nmin = 0, ndays = -1;\n    int req_text = 0, resp_text = 0, res, ret = 1;\n    int req_timeout = -1;\n    long nsec = MAX_VALIDITY_PERIOD, maxage = -1;\n    unsigned long sign_flags = 0, verify_flags = 0, rflags = 0;\n    OPTION_CHOICE o;\n\n    if ((reqnames = sk_OPENSSL_STRING_new_null()) == NULL\n            || (ids = sk_OCSP_CERTID_new_null()) == NULL\n            || (vpm = X509_VERIFY_PARAM_new()) == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"digest\");\n    prog = opt_init(argc, argv, ocsp_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            ret = 0;\n            opt_help(ocsp_options);\n            goto end;\n        case OPT_OUTFILE:\n            outfile = opt_arg();\n            break;\n        case OPT_TIMEOUT:\n#ifndef OPENSSL_NO_SOCK\n            req_timeout = atoi(opt_arg());\n#endif\n            break;\n        case OPT_URL:\n            OPENSSL_free(thost);\n            OPENSSL_free(tport);\n            OPENSSL_free(tpath);\n            thost = tport = tpath = NULL;\n            if (!OSSL_HTTP_parse_url(opt_arg(), &use_ssl, NULL /* userinfo */,\n                                     &host, &port, NULL /* port_num */,\n                                     &path, NULL /* qry */, NULL /* frag */)) {\n                BIO_printf(bio_err, \"%s Error parsing -url argument\\n\", prog);\n                goto end;\n            }\n            thost = host;\n            tport = port;\n            tpath = path;\n            break;\n        case OPT_HOST:\n            host = opt_arg();\n            break;\n        case OPT_PORT:\n            port = opt_arg();\n            break;\n        case OPT_PATH:\n            path = opt_arg();\n            break;\n#ifndef OPENSSL_NO_SOCK\n        case OPT_PROXY:\n            opt_proxy = opt_arg();\n            break;\n        case OPT_NO_PROXY:\n            opt_no_proxy = opt_arg();\n            break;\n#endif\n        case OPT_IGNORE_ERR:\n            ignore_err = 1;\n            break;\n        case OPT_NOVERIFY:\n            noverify = 1;\n            break;\n        case OPT_NONCE:\n            add_nonce = 2;\n            break;\n        case OPT_NO_NONCE:\n            add_nonce = 0;\n            break;\n        case OPT_RESP_NO_CERTS:\n            rflags |= OCSP_NOCERTS;\n            break;\n        case OPT_RESP_KEY_ID:\n            rflags |= OCSP_RESPID_KEY;\n            break;\n        case OPT_NO_CERTS:\n            sign_flags |= OCSP_NOCERTS;\n            break;\n        case OPT_NO_SIGNATURE_VERIFY:\n            verify_flags |= OCSP_NOSIGS;\n            break;\n        case OPT_NO_CERT_VERIFY:\n            verify_flags |= OCSP_NOVERIFY;\n            break;\n        case OPT_NO_CHAIN:\n            verify_flags |= OCSP_NOCHAIN;\n            break;\n        case OPT_NO_CERT_CHECKS:\n            verify_flags |= OCSP_NOCHECKS;\n            break;\n        case OPT_NO_EXPLICIT:\n            verify_flags |= OCSP_NOEXPLICIT;\n            break;\n        case OPT_TRUST_OTHER:\n            verify_flags |= OCSP_TRUSTOTHER;\n            break;\n        case OPT_NO_INTERN:\n            verify_flags |= OCSP_NOINTERN;\n            break;\n        case OPT_BADSIG:\n            badsig = 1;\n            break;\n        case OPT_TEXT:\n            req_text = resp_text = 1;\n            break;\n        case OPT_REQ_TEXT:\n            req_text = 1;\n            break;\n        case OPT_RESP_TEXT:\n            resp_text = 1;\n            break;\n        case OPT_REQIN:\n            reqin = opt_arg();\n            break;\n        case OPT_RESPIN:\n            respin = opt_arg();\n            break;\n        case OPT_SIGNER:\n            signfile = opt_arg();\n            break;\n        case OPT_VAFILE:\n            verify_certfile = opt_arg();\n            verify_flags |= OCSP_TRUSTOTHER;\n            break;\n        case OPT_SIGN_OTHER:\n            sign_certfile = opt_arg();\n            break;\n        case OPT_VERIFY_OTHER:\n            verify_certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_VALIDITY_PERIOD:\n            opt_long(opt_arg(), &nsec);\n            break;\n        case OPT_STATUS_AGE:\n            opt_long(opt_arg(), &maxage);\n            break;\n        case OPT_SIGNKEY:\n            keyfile = opt_arg();\n            break;\n        case OPT_REQOUT:\n            reqout = opt_arg();\n            break;\n        case OPT_RESPOUT:\n            respout = opt_arg();\n            break;\n        case OPT_ISSUER:\n            issuer = load_cert(opt_arg(), FORMAT_UNDEF, \"issuer certificate\");\n            if (issuer == NULL)\n                goto end;\n            if (issuers == NULL) {\n                if ((issuers = sk_X509_new_null()) == NULL)\n                    goto end;\n            }\n            if (!sk_X509_push(issuers, issuer))\n                goto end;\n            break;\n        case OPT_CERT:\n            reset_unknown();\n            X509_free(cert);\n            cert = load_cert(opt_arg(), FORMAT_UNDEF, \"certificate\");\n            if (cert == NULL)\n                goto end;\n            if (cert_id_md == NULL)\n                cert_id_md = (EVP_MD *)EVP_sha1();\n            if (!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))\n                goto end;\n            if (!sk_OPENSSL_STRING_push(reqnames, opt_arg()))\n                goto end;\n            trailing_md = 0;\n            break;\n        case OPT_SERIAL:\n            reset_unknown();\n            if (cert_id_md == NULL)\n                cert_id_md = (EVP_MD *)EVP_sha1();\n            if (!add_ocsp_serial(&req, opt_arg(), cert_id_md, issuer, ids))\n                goto end;\n            if (!sk_OPENSSL_STRING_push(reqnames, opt_arg()))\n                goto end;\n            trailing_md = 0;\n            break;\n        case OPT_INDEX:\n            ridx_filename = opt_arg();\n            break;\n        case OPT_CA:\n            rca_filename = opt_arg();\n            break;\n        case OPT_NMIN:\n            nmin = opt_int_arg();\n            if (ndays == -1)\n                ndays = 0;\n            break;\n        case OPT_REQUEST:\n            accept_count = opt_int_arg();\n            break;\n        case OPT_NDAYS:\n            ndays = atoi(opt_arg());\n            break;\n        case OPT_RSIGNER:\n            rsignfile = opt_arg();\n            break;\n        case OPT_RKEY:\n            rkeyfile = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_ROTHER:\n            rcertfile = opt_arg();\n            break;\n        case OPT_RMD:   /* Response MessageDigest */\n            respdigname = opt_arg();\n            break;\n        case OPT_RSIGOPT:\n            if (rsign_sigopts == NULL)\n                rsign_sigopts = sk_OPENSSL_STRING_new_null();\n            if (rsign_sigopts == NULL\n                || !sk_OPENSSL_STRING_push(rsign_sigopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_HEADER:\n            header = opt_arg();\n            value = strchr(header, '=');\n            if (value == NULL) {\n                BIO_printf(bio_err, \"Missing = in header key=value\\n\");\n                goto opthelp;\n            }\n            *value++ = '\\0';\n            if (!X509V3_add_value(header, value, &headers))\n                goto end;\n            break;\n        case OPT_RCID:\n            if (!opt_md(opt_arg(), &resp_certid_md))\n                goto opthelp;\n            break;\n        case OPT_MD:\n            if (trailing_md) {\n                BIO_printf(bio_err,\n                           \"%s: Digest must be before -cert or -serial\\n\",\n                           prog);\n                goto opthelp;\n            }\n            if (!opt_md(opt_unknown(), &cert_id_md))\n                goto opthelp;\n            trailing_md = 1;\n            break;\n        case OPT_MULTI:\n#ifdef HTTP_DAEMON\n            n_responders = atoi(opt_arg());\n#endif\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (trailing_md) {\n        BIO_printf(bio_err, \"%s: Digest must be before -cert or -serial\\n\",\n                   prog);\n        goto opthelp;\n    }\n\n    if (respdigname != NULL) {\n        if (!opt_md(respdigname, &rsign_md))\n            goto end;\n    }\n\n    /* Have we anything to do? */\n    if (req == NULL && reqin == NULL\n        && respin == NULL && !(port != NULL && ridx_filename != NULL))\n        goto opthelp;\n\n    if (req == NULL && (add_nonce != 2))\n        add_nonce = 0;\n\n    if (req == NULL && reqin != NULL) {\n        derbio = bio_open_default(reqin, 'r', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        req = d2i_OCSP_REQUEST_bio(derbio, NULL);\n        BIO_free(derbio);\n        if (req == NULL) {\n            BIO_printf(bio_err, \"Error reading OCSP request\\n\");\n            goto end;\n        }\n    }\n\n    if (req == NULL && port != NULL) {\n#ifndef OPENSSL_NO_SOCK\n        acbio = http_server_init(prog, port, -1);\n        if (acbio == NULL)\n            goto end;\n#else\n        BIO_printf(bio_err, \"Cannot act as server - sockets not supported\\n\");\n        goto end;\n#endif\n    }\n\n    if (rsignfile != NULL) {\n        if (rkeyfile == NULL)\n            rkeyfile = rsignfile;\n        rsigner = load_cert(rsignfile, FORMAT_UNDEF, \"responder certificate\");\n        if (rsigner == NULL) {\n            BIO_printf(bio_err, \"Error loading responder certificate\\n\");\n            goto end;\n        }\n        if (!load_certs(rca_filename, 0, &rca_certs, NULL, \"CA certificates\"))\n            goto end;\n        if (rcertfile != NULL) {\n            if (!load_certs(rcertfile, 0, &rother, NULL,\n                            \"responder other certificates\"))\n                goto end;\n        }\n        if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n            BIO_printf(bio_err, \"Error getting password\\n\");\n            goto end;\n        }\n        rkey = load_key(rkeyfile, FORMAT_UNDEF, 0, passin, NULL,\n                        \"responder private key\");\n        if (rkey == NULL)\n            goto end;\n    }\n\n    if (ridx_filename != NULL\n        && (rkey == NULL || rsigner == NULL || rca_certs == NULL)) {\n        BIO_printf(bio_err,\n                   \"Responder mode requires certificate, key, and CA.\\n\");\n        goto end;\n    }\n\n    if (ridx_filename != NULL) {\n        rdb = load_index(ridx_filename, NULL);\n        if (rdb == NULL || index_index(rdb) <= 0) {\n            BIO_printf(bio_err,\n                \"Problem with index file: %s (could not load/parse file)\\n\",\n                ridx_filename);\n            ret = 1;\n            goto end;\n        }\n    }\n\n#ifdef HTTP_DAEMON\n    if (n_responders != 0 && acbio != NULL)\n        spawn_loop(prog);\n    if (acbio != NULL && req_timeout > 0)\n        signal(SIGALRM, socket_timeout);\n#endif\n\n    if (acbio != NULL)\n        trace_log_message(-1, prog,\n                          LOG_INFO, \"waiting for OCSP client connections...\");\n\nredo_accept:\n\n    if (acbio != NULL) {\n#ifdef HTTP_DAEMON\n        if (index_changed(rdb)) {\n            CA_DB *newrdb = load_index(ridx_filename, NULL);\n\n            if (newrdb != NULL && index_index(newrdb) > 0) {\n                free_index(rdb);\n                rdb = newrdb;\n            } else {\n                free_index(newrdb);\n                trace_log_message(-1, prog,\n                                  LOG_ERR, \"error reloading updated index: %s\",\n                                  ridx_filename);\n            }\n        }\n#endif\n\n        req = NULL;\n        res = do_responder(&req, &cbio, acbio, req_timeout);\n        if (res == 0)\n            goto redo_accept;\n\n        if (req == NULL) {\n            if (res == 1) {\n                resp =\n                    OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST,\n                                         NULL);\n                send_ocsp_response(cbio, resp);\n            }\n            goto done_resp;\n        }\n    }\n\n    if (req == NULL\n        && (signfile != NULL || reqout != NULL\n            || host != NULL || add_nonce || ridx_filename != NULL)) {\n        BIO_printf(bio_err, \"Need an OCSP request for this operation!\\n\");\n        goto end;\n    }\n\n    if (req != NULL && add_nonce) {\n        if (!OCSP_request_add1_nonce(req, NULL, -1))\n            goto end;\n    }\n\n    if (signfile != NULL) {\n        if (keyfile == NULL)\n            keyfile = signfile;\n        signer = load_cert(signfile, FORMAT_UNDEF, \"signer certificate\");\n        if (signer == NULL) {\n            BIO_printf(bio_err, \"Error loading signer certificate\\n\");\n            goto end;\n        }\n        if (sign_certfile != NULL) {\n            if (!load_certs(sign_certfile, 0, &sign_other, NULL,\n                            \"signer certificates\"))\n                goto end;\n        }\n        key = load_key(keyfile, FORMAT_UNDEF, 0, NULL, NULL,\n                       \"signer private key\");\n        if (key == NULL)\n            goto end;\n\n        if (!OCSP_request_sign(req, signer, key, NULL,\n                               sign_other, sign_flags)) {\n            BIO_printf(bio_err, \"Error signing OCSP request\\n\");\n            goto end;\n        }\n    }\n\n    out = bio_open_default(outfile, 'w', FORMAT_TEXT);\n    if (out == NULL)\n        goto end;\n\n    if (req_text && req != NULL)\n        OCSP_REQUEST_print(out, req, 0);\n\n    if (reqout != NULL) {\n        derbio = bio_open_default(reqout, 'w', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        i2d_OCSP_REQUEST_bio(derbio, req);\n        BIO_free(derbio);\n    }\n\n    if (rdb != NULL) {\n        make_ocsp_response(bio_err, &resp, req, rdb, rca_certs, rsigner, rkey,\n                           rsign_md, rsign_sigopts, rother, rflags, nmin, ndays,\n                           badsig, resp_certid_md);\n        if (resp == NULL)\n            goto end;\n        if (cbio != NULL)\n            send_ocsp_response(cbio, resp);\n    } else if (host != NULL) {\n#ifndef OPENSSL_NO_SOCK\n        resp = process_responder(req, host, port, path, opt_proxy, opt_no_proxy,\n                                 use_ssl, headers, req_timeout);\n        if (resp == NULL)\n            goto end;\n#else\n        BIO_printf(bio_err,\n                   \"Error creating connect BIO - sockets not supported\\n\");\n        goto end;\n#endif\n    } else if (respin != NULL) {\n        derbio = bio_open_default(respin, 'r', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        resp = d2i_OCSP_RESPONSE_bio(derbio, NULL);\n        BIO_free(derbio);\n        if (resp == NULL) {\n            BIO_printf(bio_err, \"Error reading OCSP response\\n\");\n            goto end;\n        }\n    } else {\n        ret = 0;\n        goto end;\n    }\n\n done_resp:\n\n    if (respout != NULL) {\n        derbio = bio_open_default(respout, 'w', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        i2d_OCSP_RESPONSE_bio(derbio, resp);\n        BIO_free(derbio);\n    }\n\n    i = OCSP_response_status(resp);\n    if (i != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n        BIO_printf(out, \"Responder Error: %s (%d)\\n\",\n                   OCSP_response_status_str(i), i);\n        if (!ignore_err)\n                goto end;\n    }\n\n    if (resp_text)\n        OCSP_RESPONSE_print(out, resp, 0);\n\n    /* If running as responder don't verify our own response */\n    if (cbio != NULL) {\n        /* If not unlimited, see if we took all we should. */\n        if (accept_count != -1 && --accept_count <= 0) {\n            ret = 0;\n            goto end;\n        }\n        BIO_free_all(cbio);\n        cbio = NULL;\n        OCSP_REQUEST_free(req);\n        req = NULL;\n        OCSP_RESPONSE_free(resp);\n        resp = NULL;\n        goto redo_accept;\n    }\n    if (ridx_filename != NULL) {\n        ret = 0;\n        goto end;\n    }\n\n    if (store == NULL) {\n        store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                             CAstore, noCAstore);\n        if (!store)\n            goto end;\n    }\n    if (vpmtouched)\n        X509_STORE_set1_param(store, vpm);\n    if (verify_certfile != NULL) {\n        if (!load_certs(verify_certfile, 0, &verify_other, NULL,\n                        \"validator certificates\"))\n            goto end;\n    }\n\n    bs = OCSP_response_get1_basic(resp);\n    if (bs == NULL) {\n        BIO_printf(bio_err, \"Error parsing response\\n\");\n        goto end;\n    }\n\n    ret = 0;\n\n    if (!noverify) {\n        if (req != NULL && ((i = OCSP_check_nonce(req, bs)) <= 0)) {\n            if (i == -1)\n                BIO_printf(bio_err, \"WARNING: no nonce in response\\n\");\n            else {\n                BIO_printf(bio_err, \"Nonce Verify error\\n\");\n                ret = 1;\n                goto end;\n            }\n        }\n\n        i = OCSP_basic_verify(bs, verify_other, store, verify_flags);\n        if (i <= 0 && issuers) {\n            i = OCSP_basic_verify(bs, issuers, store, OCSP_TRUSTOTHER);\n            if (i > 0)\n                ERR_clear_error();\n        }\n        if (i <= 0) {\n            BIO_printf(bio_err, \"Response Verify Failure\\n\");\n            ERR_print_errors(bio_err);\n            ret = 1;\n        } else {\n            BIO_printf(bio_err, \"Response verify OK\\n\");\n        }\n    }\n\n    if (!print_ocsp_summary(out, bs, req, reqnames, ids, nsec, maxage))\n        ret = 1;\n\n end:\n    ERR_print_errors(bio_err);\n    X509_free(signer);\n    X509_STORE_free(store);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(rsign_sigopts);\n    EVP_PKEY_free(key);\n    EVP_PKEY_free(rkey);\n    EVP_MD_free(cert_id_md);\n    EVP_MD_free(rsign_md);\n    EVP_MD_free(resp_certid_md);\n    X509_free(cert);\n    OSSL_STACK_OF_X509_free(issuers);\n    X509_free(rsigner);\n    OSSL_STACK_OF_X509_free(rca_certs);\n    free_index(rdb);\n    BIO_free_all(cbio);\n    BIO_free_all(acbio);\n    BIO_free_all(out);\n    OCSP_REQUEST_free(req);\n    OCSP_RESPONSE_free(resp);\n    OCSP_BASICRESP_free(bs);\n    sk_OPENSSL_STRING_free(reqnames);\n    sk_OCSP_CERTID_free(ids);\n    OSSL_STACK_OF_X509_free(sign_other);\n    OSSL_STACK_OF_X509_free(verify_other);\n    sk_CONF_VALUE_pop_free(headers, X509V3_conf_free);\n    OPENSSL_free(thost);\n    OPENSSL_free(tport);\n    OPENSSL_free(tpath);\n\n    return ret;\n}"
        ],
        "sink": "if (!OCSP_request_sign(req, signer, key, NULL,",
        "final_sink": "if (!OCSP_request_sign(req, signer, key, NULL,",
        "source": [
            "        xi = sk_X509_INFO_shift(sk);"
        ],
        "index": 31
    },
    {
        "prt": "req",
        "function_call": [
            "int ocsp_main(int argc, char **argv)\n{\n    BIO *acbio = NULL, *cbio = NULL, *derbio = NULL, *out = NULL;\n    EVP_MD *cert_id_md = NULL, *rsign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rsign_sigopts = NULL;\n    int trailing_md = 0;\n    CA_DB *rdb = NULL;\n    EVP_PKEY *key = NULL, *rkey = NULL;\n    OCSP_BASICRESP *bs = NULL;\n    OCSP_REQUEST *req = NULL;\n    OCSP_RESPONSE *resp = NULL;\n    STACK_OF(CONF_VALUE) *headers = NULL;\n    STACK_OF(OCSP_CERTID) *ids = NULL;\n    STACK_OF(OPENSSL_STRING) *reqnames = NULL;\n    STACK_OF(X509) *sign_other = NULL, *verify_other = NULL, *rother = NULL;\n    STACK_OF(X509) *issuers = NULL;\n    X509 *issuer = NULL, *cert = NULL;\n    STACK_OF(X509) *rca_certs = NULL;\n    EVP_MD *resp_certid_md = NULL;\n    X509 *signer = NULL, *rsigner = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *header, *value, *respdigname = NULL;\n    char *host = NULL, *port = NULL, *path = \"/\", *outfile = NULL;\n#ifndef OPENSSL_NO_SOCK\n    char *opt_proxy = NULL;\n    char *opt_no_proxy = NULL;\n#endif\n    char *rca_filename = NULL, *reqin = NULL, *respin = NULL;\n    char *reqout = NULL, *respout = NULL, *ridx_filename = NULL;\n    char *rsignfile = NULL, *rkeyfile = NULL;\n    char *passinarg = NULL, *passin = NULL;\n    char *sign_certfile = NULL, *verify_certfile = NULL, *rcertfile = NULL;\n    char *signfile = NULL, *keyfile = NULL;\n    char *thost = NULL, *tport = NULL, *tpath = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    int accept_count = -1, add_nonce = 1, noverify = 0, use_ssl = -1;\n    int vpmtouched = 0, badsig = 0, i, ignore_err = 0, nmin = 0, ndays = -1;\n    int req_text = 0, resp_text = 0, res, ret = 1;\n    int req_timeout = -1;\n    long nsec = MAX_VALIDITY_PERIOD, maxage = -1;\n    unsigned long sign_flags = 0, verify_flags = 0, rflags = 0;\n    OPTION_CHOICE o;\n\n    if ((reqnames = sk_OPENSSL_STRING_new_null()) == NULL\n            || (ids = sk_OCSP_CERTID_new_null()) == NULL\n            || (vpm = X509_VERIFY_PARAM_new()) == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"digest\");\n    prog = opt_init(argc, argv, ocsp_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            ret = 0;\n            opt_help(ocsp_options);\n            goto end;\n        case OPT_OUTFILE:\n            outfile = opt_arg();\n            break;\n        case OPT_TIMEOUT:\n#ifndef OPENSSL_NO_SOCK\n            req_timeout = atoi(opt_arg());\n#endif\n            break;\n        case OPT_URL:\n            OPENSSL_free(thost);\n            OPENSSL_free(tport);\n            OPENSSL_free(tpath);\n            thost = tport = tpath = NULL;\n            if (!OSSL_HTTP_parse_url(opt_arg(), &use_ssl, NULL /* userinfo */,\n                                     &host, &port, NULL /* port_num */,\n                                     &path, NULL /* qry */, NULL /* frag */)) {\n                BIO_printf(bio_err, \"%s Error parsing -url argument\\n\", prog);\n                goto end;\n            }\n            thost = host;\n            tport = port;\n            tpath = path;\n            break;\n        case OPT_HOST:\n            host = opt_arg();\n            break;\n        case OPT_PORT:\n            port = opt_arg();\n            break;\n        case OPT_PATH:\n            path = opt_arg();\n            break;\n#ifndef OPENSSL_NO_SOCK\n        case OPT_PROXY:\n            opt_proxy = opt_arg();\n            break;\n        case OPT_NO_PROXY:\n            opt_no_proxy = opt_arg();\n            break;\n#endif\n        case OPT_IGNORE_ERR:\n            ignore_err = 1;\n            break;\n        case OPT_NOVERIFY:\n            noverify = 1;\n            break;\n        case OPT_NONCE:\n            add_nonce = 2;\n            break;\n        case OPT_NO_NONCE:\n            add_nonce = 0;\n            break;\n        case OPT_RESP_NO_CERTS:\n            rflags |= OCSP_NOCERTS;\n            break;\n        case OPT_RESP_KEY_ID:\n            rflags |= OCSP_RESPID_KEY;\n            break;\n        case OPT_NO_CERTS:\n            sign_flags |= OCSP_NOCERTS;\n            break;\n        case OPT_NO_SIGNATURE_VERIFY:\n            verify_flags |= OCSP_NOSIGS;\n            break;\n        case OPT_NO_CERT_VERIFY:\n            verify_flags |= OCSP_NOVERIFY;\n            break;\n        case OPT_NO_CHAIN:\n            verify_flags |= OCSP_NOCHAIN;\n            break;\n        case OPT_NO_CERT_CHECKS:\n            verify_flags |= OCSP_NOCHECKS;\n            break;\n        case OPT_NO_EXPLICIT:\n            verify_flags |= OCSP_NOEXPLICIT;\n            break;\n        case OPT_TRUST_OTHER:\n            verify_flags |= OCSP_TRUSTOTHER;\n            break;\n        case OPT_NO_INTERN:\n            verify_flags |= OCSP_NOINTERN;\n            break;\n        case OPT_BADSIG:\n            badsig = 1;\n            break;\n        case OPT_TEXT:\n            req_text = resp_text = 1;\n            break;\n        case OPT_REQ_TEXT:\n            req_text = 1;\n            break;\n        case OPT_RESP_TEXT:\n            resp_text = 1;\n            break;\n        case OPT_REQIN:\n            reqin = opt_arg();\n            break;\n        case OPT_RESPIN:\n            respin = opt_arg();\n            break;\n        case OPT_SIGNER:\n            signfile = opt_arg();\n            break;\n        case OPT_VAFILE:\n            verify_certfile = opt_arg();\n            verify_flags |= OCSP_TRUSTOTHER;\n            break;\n        case OPT_SIGN_OTHER:\n            sign_certfile = opt_arg();\n            break;\n        case OPT_VERIFY_OTHER:\n            verify_certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_VALIDITY_PERIOD:\n            opt_long(opt_arg(), &nsec);\n            break;\n        case OPT_STATUS_AGE:\n            opt_long(opt_arg(), &maxage);\n            break;\n        case OPT_SIGNKEY:\n            keyfile = opt_arg();\n            break;\n        case OPT_REQOUT:\n            reqout = opt_arg();\n            break;\n        case OPT_RESPOUT:\n            respout = opt_arg();\n            break;\n        case OPT_ISSUER:\n            issuer = load_cert(opt_arg(), FORMAT_UNDEF, \"issuer certificate\");\n            if (issuer == NULL)\n                goto end;\n            if (issuers == NULL) {\n                if ((issuers = sk_X509_new_null()) == NULL)\n                    goto end;\n            }\n            if (!sk_X509_push(issuers, issuer))\n                goto end;\n            break;\n        case OPT_CERT:\n            reset_unknown();\n            X509_free(cert);\n            cert = load_cert(opt_arg(), FORMAT_UNDEF, \"certificate\");\n            if (cert == NULL)\n                goto end;\n            if (cert_id_md == NULL)\n                cert_id_md = (EVP_MD *)EVP_sha1();\n            if (!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))\n                goto end;\n            if (!sk_OPENSSL_STRING_push(reqnames, opt_arg()))\n                goto end;\n            trailing_md = 0;\n            break;\n        case OPT_SERIAL:\n            reset_unknown();\n            if (cert_id_md == NULL)\n                cert_id_md = (EVP_MD *)EVP_sha1();\n            if (!add_ocsp_serial(&req, opt_arg(), cert_id_md, issuer, ids))\n                goto end;\n            if (!sk_OPENSSL_STRING_push(reqnames, opt_arg()))\n                goto end;\n            trailing_md = 0;\n            break;\n        case OPT_INDEX:\n            ridx_filename = opt_arg();\n            break;\n        case OPT_CA:\n            rca_filename = opt_arg();\n            break;\n        case OPT_NMIN:\n            nmin = opt_int_arg();\n            if (ndays == -1)\n                ndays = 0;\n            break;\n        case OPT_REQUEST:\n            accept_count = opt_int_arg();\n            break;\n        case OPT_NDAYS:\n            ndays = atoi(opt_arg());\n            break;\n        case OPT_RSIGNER:\n            rsignfile = opt_arg();\n            break;\n        case OPT_RKEY:\n            rkeyfile = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_ROTHER:\n            rcertfile = opt_arg();\n            break;\n        case OPT_RMD:   /* Response MessageDigest */\n            respdigname = opt_arg();\n            break;\n        case OPT_RSIGOPT:\n            if (rsign_sigopts == NULL)\n                rsign_sigopts = sk_OPENSSL_STRING_new_null();\n            if (rsign_sigopts == NULL\n                || !sk_OPENSSL_STRING_push(rsign_sigopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_HEADER:\n            header = opt_arg();\n            value = strchr(header, '=');\n            if (value == NULL) {\n                BIO_printf(bio_err, \"Missing = in header key=value\\n\");\n                goto opthelp;\n            }\n            *value++ = '\\0';\n            if (!X509V3_add_value(header, value, &headers))\n                goto end;\n            break;\n        case OPT_RCID:\n            if (!opt_md(opt_arg(), &resp_certid_md))\n                goto opthelp;\n            break;\n        case OPT_MD:\n            if (trailing_md) {\n                BIO_printf(bio_err,\n                           \"%s: Digest must be before -cert or -serial\\n\",\n                           prog);\n                goto opthelp;\n            }\n            if (!opt_md(opt_unknown(), &cert_id_md))\n                goto opthelp;\n            trailing_md = 1;\n            break;\n        case OPT_MULTI:\n#ifdef HTTP_DAEMON\n            n_responders = atoi(opt_arg());\n#endif\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (trailing_md) {\n        BIO_printf(bio_err, \"%s: Digest must be before -cert or -serial\\n\",\n                   prog);\n        goto opthelp;\n    }\n\n    if (respdigname != NULL) {\n        if (!opt_md(respdigname, &rsign_md))\n            goto end;\n    }\n\n    /* Have we anything to do? */\n    if (req == NULL && reqin == NULL\n        && respin == NULL && !(port != NULL && ridx_filename != NULL))\n        goto opthelp;\n\n    if (req == NULL && (add_nonce != 2))\n        add_nonce = 0;\n\n    if (req == NULL && reqin != NULL) {\n        derbio = bio_open_default(reqin, 'r', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        req = d2i_OCSP_REQUEST_bio(derbio, NULL);\n        BIO_free(derbio);\n        if (req == NULL) {\n            BIO_printf(bio_err, \"Error reading OCSP request\\n\");\n            goto end;\n        }\n    }\n\n    if (req == NULL && port != NULL) {\n#ifndef OPENSSL_NO_SOCK\n        acbio = http_server_init(prog, port, -1);\n        if (acbio == NULL)\n            goto end;\n#else\n        BIO_printf(bio_err, \"Cannot act as server - sockets not supported\\n\");\n        goto end;\n#endif\n    }\n\n    if (rsignfile != NULL) {\n        if (rkeyfile == NULL)\n            rkeyfile = rsignfile;\n        rsigner = load_cert(rsignfile, FORMAT_UNDEF, \"responder certificate\");\n        if (rsigner == NULL) {\n            BIO_printf(bio_err, \"Error loading responder certificate\\n\");\n            goto end;\n        }\n        if (!load_certs(rca_filename, 0, &rca_certs, NULL, \"CA certificates\"))\n            goto end;\n        if (rcertfile != NULL) {\n            if (!load_certs(rcertfile, 0, &rother, NULL,\n                            \"responder other certificates\"))\n                goto end;\n        }\n        if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n            BIO_printf(bio_err, \"Error getting password\\n\");\n            goto end;\n        }\n        rkey = load_key(rkeyfile, FORMAT_UNDEF, 0, passin, NULL,\n                        \"responder private key\");\n        if (rkey == NULL)\n            goto end;\n    }\n\n    if (ridx_filename != NULL\n        && (rkey == NULL || rsigner == NULL || rca_certs == NULL)) {\n        BIO_printf(bio_err,\n                   \"Responder mode requires certificate, key, and CA.\\n\");\n        goto end;\n    }\n\n    if (ridx_filename != NULL) {\n        rdb = load_index(ridx_filename, NULL);\n        if (rdb == NULL || index_index(rdb) <= 0) {\n            BIO_printf(bio_err,\n                \"Problem with index file: %s (could not load/parse file)\\n\",\n                ridx_filename);\n            ret = 1;\n            goto end;\n        }\n    }\n\n#ifdef HTTP_DAEMON\n    if (n_responders != 0 && acbio != NULL)\n        spawn_loop(prog);\n    if (acbio != NULL && req_timeout > 0)\n        signal(SIGALRM, socket_timeout);\n#endif\n\n    if (acbio != NULL)\n        trace_log_message(-1, prog,\n                          LOG_INFO, \"waiting for OCSP client connections...\");\n\nredo_accept:\n\n    if (acbio != NULL) {\n#ifdef HTTP_DAEMON\n        if (index_changed(rdb)) {\n            CA_DB *newrdb = load_index(ridx_filename, NULL);\n\n            if (newrdb != NULL && index_index(newrdb) > 0) {\n                free_index(rdb);\n                rdb = newrdb;\n            } else {\n                free_index(newrdb);\n                trace_log_message(-1, prog,\n                                  LOG_ERR, \"error reloading updated index: %s\",\n                                  ridx_filename);\n            }\n        }\n#endif\n\n        req = NULL;\n        res = do_responder(&req, &cbio, acbio, req_timeout);\n        if (res == 0)\n            goto redo_accept;\n\n        if (req == NULL) {\n            if (res == 1) {\n                resp =\n                    OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST,\n                                         NULL);\n                send_ocsp_response(cbio, resp);\n            }\n            goto done_resp;\n        }\n    }\n\n    if (req == NULL\n        && (signfile != NULL || reqout != NULL\n            || host != NULL || add_nonce || ridx_filename != NULL)) {\n        BIO_printf(bio_err, \"Need an OCSP request for this operation!\\n\");\n        goto end;\n    }\n\n    if (req != NULL && add_nonce) {\n        if (!OCSP_request_add1_nonce(req, NULL, -1))\n            goto end;\n    }\n\n    if (signfile != NULL) {\n        if (keyfile == NULL)\n            keyfile = signfile;\n        signer = load_cert(signfile, FORMAT_UNDEF, \"signer certificate\");\n        if (signer == NULL) {\n            BIO_printf(bio_err, \"Error loading signer certificate\\n\");\n            goto end;\n        }\n        if (sign_certfile != NULL) {\n            if (!load_certs(sign_certfile, 0, &sign_other, NULL,\n                            \"signer certificates\"))\n                goto end;\n        }\n        key = load_key(keyfile, FORMAT_UNDEF, 0, NULL, NULL,\n                       \"signer private key\");\n        if (key == NULL)\n            goto end;\n\n        if (!OCSP_request_sign(req, signer, key, NULL,\n                               sign_other, sign_flags)) {\n            BIO_printf(bio_err, \"Error signing OCSP request\\n\");\n            goto end;\n        }\n    }\n\n    out = bio_open_default(outfile, 'w', FORMAT_TEXT);\n    if (out == NULL)\n        goto end;\n\n    if (req_text && req != NULL)\n        OCSP_REQUEST_print(out, req, 0);\n\n    if (reqout != NULL) {\n        derbio = bio_open_default(reqout, 'w', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        i2d_OCSP_REQUEST_bio(derbio, req);\n        BIO_free(derbio);\n    }\n\n    if (rdb != NULL) {\n        make_ocsp_response(bio_err, &resp, req, rdb, rca_certs, rsigner, rkey,\n                           rsign_md, rsign_sigopts, rother, rflags, nmin, ndays,\n                           badsig, resp_certid_md);\n        if (resp == NULL)\n            goto end;\n        if (cbio != NULL)\n            send_ocsp_response(cbio, resp);\n    } else if (host != NULL) {\n#ifndef OPENSSL_NO_SOCK\n        resp = process_responder(req, host, port, path, opt_proxy, opt_no_proxy,\n                                 use_ssl, headers, req_timeout);\n        if (resp == NULL)\n            goto end;\n#else\n        BIO_printf(bio_err,\n                   \"Error creating connect BIO - sockets not supported\\n\");\n        goto end;\n#endif\n    } else if (respin != NULL) {\n        derbio = bio_open_default(respin, 'r', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        resp = d2i_OCSP_RESPONSE_bio(derbio, NULL);\n        BIO_free(derbio);\n        if (resp == NULL) {\n            BIO_printf(bio_err, \"Error reading OCSP response\\n\");\n            goto end;\n        }\n    } else {\n        ret = 0;\n        goto end;\n    }\n\n done_resp:\n\n    if (respout != NULL) {\n        derbio = bio_open_default(respout, 'w', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        i2d_OCSP_RESPONSE_bio(derbio, resp);\n        BIO_free(derbio);\n    }\n\n    i = OCSP_response_status(resp);\n    if (i != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n        BIO_printf(out, \"Responder Error: %s (%d)\\n\",\n                   OCSP_response_status_str(i), i);\n        if (!ignore_err)\n                goto end;\n    }\n\n    if (resp_text)\n        OCSP_RESPONSE_print(out, resp, 0);\n\n    /* If running as responder don't verify our own response */\n    if (cbio != NULL) {\n        /* If not unlimited, see if we took all we should. */\n        if (accept_count != -1 && --accept_count <= 0) {\n            ret = 0;\n            goto end;\n        }\n        BIO_free_all(cbio);\n        cbio = NULL;\n        OCSP_REQUEST_free(req);\n        req = NULL;\n        OCSP_RESPONSE_free(resp);\n        resp = NULL;\n        goto redo_accept;\n    }\n    if (ridx_filename != NULL) {\n        ret = 0;\n        goto end;\n    }\n\n    if (store == NULL) {\n        store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                             CAstore, noCAstore);\n        if (!store)\n            goto end;\n    }\n    if (vpmtouched)\n        X509_STORE_set1_param(store, vpm);\n    if (verify_certfile != NULL) {\n        if (!load_certs(verify_certfile, 0, &verify_other, NULL,\n                        \"validator certificates\"))\n            goto end;\n    }\n\n    bs = OCSP_response_get1_basic(resp);\n    if (bs == NULL) {\n        BIO_printf(bio_err, \"Error parsing response\\n\");\n        goto end;\n    }\n\n    ret = 0;\n\n    if (!noverify) {\n        if (req != NULL && ((i = OCSP_check_nonce(req, bs)) <= 0)) {\n            if (i == -1)\n                BIO_printf(bio_err, \"WARNING: no nonce in response\\n\");\n            else {\n                BIO_printf(bio_err, \"Nonce Verify error\\n\");\n                ret = 1;\n                goto end;\n            }\n        }\n\n        i = OCSP_basic_verify(bs, verify_other, store, verify_flags);\n        if (i <= 0 && issuers) {\n            i = OCSP_basic_verify(bs, issuers, store, OCSP_TRUSTOTHER);\n            if (i > 0)\n                ERR_clear_error();\n        }\n        if (i <= 0) {\n            BIO_printf(bio_err, \"Response Verify Failure\\n\");\n            ERR_print_errors(bio_err);\n            ret = 1;\n        } else {\n            BIO_printf(bio_err, \"Response verify OK\\n\");\n        }\n    }\n\n    if (!print_ocsp_summary(out, bs, req, reqnames, ids, nsec, maxage))\n        ret = 1;\n\n end:\n    ERR_print_errors(bio_err);\n    X509_free(signer);\n    X509_STORE_free(store);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(rsign_sigopts);\n    EVP_PKEY_free(key);\n    EVP_PKEY_free(rkey);\n    EVP_MD_free(cert_id_md);\n    EVP_MD_free(rsign_md);\n    EVP_MD_free(resp_certid_md);\n    X509_free(cert);\n    OSSL_STACK_OF_X509_free(issuers);\n    X509_free(rsigner);\n    OSSL_STACK_OF_X509_free(rca_certs);\n    free_index(rdb);\n    BIO_free_all(cbio);\n    BIO_free_all(acbio);\n    BIO_free_all(out);\n    OCSP_REQUEST_free(req);\n    OCSP_RESPONSE_free(resp);\n    OCSP_BASICRESP_free(bs);\n    sk_OPENSSL_STRING_free(reqnames);\n    sk_OCSP_CERTID_free(ids);\n    OSSL_STACK_OF_X509_free(sign_other);\n    OSSL_STACK_OF_X509_free(verify_other);\n    sk_CONF_VALUE_pop_free(headers, X509V3_conf_free);\n    OPENSSL_free(thost);\n    OPENSSL_free(tport);\n    OPENSSL_free(tpath);\n\n    return ret;\n}"
        ],
        "sink": "make_ocsp_response(bio_err, &resp, req, rdb, rca_certs, rsigner, rkey,",
        "final_sink": "make_ocsp_response(bio_err, &resp, req, rdb, rca_certs, rsigner, rkey,",
        "source": [
            "    ectx = OSSL_ENCODER_CTX_new_for_pkey(pkey, selection, output_type,"
        ],
        "index": 32
    },
    {
        "prt": "rsigner",
        "function_call": [
            "int ocsp_main(int argc, char **argv)\n{\n    BIO *acbio = NULL, *cbio = NULL, *derbio = NULL, *out = NULL;\n    EVP_MD *cert_id_md = NULL, *rsign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rsign_sigopts = NULL;\n    int trailing_md = 0;\n    CA_DB *rdb = NULL;\n    EVP_PKEY *key = NULL, *rkey = NULL;\n    OCSP_BASICRESP *bs = NULL;\n    OCSP_REQUEST *req = NULL;\n    OCSP_RESPONSE *resp = NULL;\n    STACK_OF(CONF_VALUE) *headers = NULL;\n    STACK_OF(OCSP_CERTID) *ids = NULL;\n    STACK_OF(OPENSSL_STRING) *reqnames = NULL;\n    STACK_OF(X509) *sign_other = NULL, *verify_other = NULL, *rother = NULL;\n    STACK_OF(X509) *issuers = NULL;\n    X509 *issuer = NULL, *cert = NULL;\n    STACK_OF(X509) *rca_certs = NULL;\n    EVP_MD *resp_certid_md = NULL;\n    X509 *signer = NULL, *rsigner = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *header, *value, *respdigname = NULL;\n    char *host = NULL, *port = NULL, *path = \"/\", *outfile = NULL;\n#ifndef OPENSSL_NO_SOCK\n    char *opt_proxy = NULL;\n    char *opt_no_proxy = NULL;\n#endif\n    char *rca_filename = NULL, *reqin = NULL, *respin = NULL;\n    char *reqout = NULL, *respout = NULL, *ridx_filename = NULL;\n    char *rsignfile = NULL, *rkeyfile = NULL;\n    char *passinarg = NULL, *passin = NULL;\n    char *sign_certfile = NULL, *verify_certfile = NULL, *rcertfile = NULL;\n    char *signfile = NULL, *keyfile = NULL;\n    char *thost = NULL, *tport = NULL, *tpath = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    int accept_count = -1, add_nonce = 1, noverify = 0, use_ssl = -1;\n    int vpmtouched = 0, badsig = 0, i, ignore_err = 0, nmin = 0, ndays = -1;\n    int req_text = 0, resp_text = 0, res, ret = 1;\n    int req_timeout = -1;\n    long nsec = MAX_VALIDITY_PERIOD, maxage = -1;\n    unsigned long sign_flags = 0, verify_flags = 0, rflags = 0;\n    OPTION_CHOICE o;\n\n    if ((reqnames = sk_OPENSSL_STRING_new_null()) == NULL\n            || (ids = sk_OCSP_CERTID_new_null()) == NULL\n            || (vpm = X509_VERIFY_PARAM_new()) == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"digest\");\n    prog = opt_init(argc, argv, ocsp_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            ret = 0;\n            opt_help(ocsp_options);\n            goto end;\n        case OPT_OUTFILE:\n            outfile = opt_arg();\n            break;\n        case OPT_TIMEOUT:\n#ifndef OPENSSL_NO_SOCK\n            req_timeout = atoi(opt_arg());\n#endif\n            break;\n        case OPT_URL:\n            OPENSSL_free(thost);\n            OPENSSL_free(tport);\n            OPENSSL_free(tpath);\n            thost = tport = tpath = NULL;\n            if (!OSSL_HTTP_parse_url(opt_arg(), &use_ssl, NULL /* userinfo */,\n                                     &host, &port, NULL /* port_num */,\n                                     &path, NULL /* qry */, NULL /* frag */)) {\n                BIO_printf(bio_err, \"%s Error parsing -url argument\\n\", prog);\n                goto end;\n            }\n            thost = host;\n            tport = port;\n            tpath = path;\n            break;\n        case OPT_HOST:\n            host = opt_arg();\n            break;\n        case OPT_PORT:\n            port = opt_arg();\n            break;\n        case OPT_PATH:\n            path = opt_arg();\n            break;\n#ifndef OPENSSL_NO_SOCK\n        case OPT_PROXY:\n            opt_proxy = opt_arg();\n            break;\n        case OPT_NO_PROXY:\n            opt_no_proxy = opt_arg();\n            break;\n#endif\n        case OPT_IGNORE_ERR:\n            ignore_err = 1;\n            break;\n        case OPT_NOVERIFY:\n            noverify = 1;\n            break;\n        case OPT_NONCE:\n            add_nonce = 2;\n            break;\n        case OPT_NO_NONCE:\n            add_nonce = 0;\n            break;\n        case OPT_RESP_NO_CERTS:\n            rflags |= OCSP_NOCERTS;\n            break;\n        case OPT_RESP_KEY_ID:\n            rflags |= OCSP_RESPID_KEY;\n            break;\n        case OPT_NO_CERTS:\n            sign_flags |= OCSP_NOCERTS;\n            break;\n        case OPT_NO_SIGNATURE_VERIFY:\n            verify_flags |= OCSP_NOSIGS;\n            break;\n        case OPT_NO_CERT_VERIFY:\n            verify_flags |= OCSP_NOVERIFY;\n            break;\n        case OPT_NO_CHAIN:\n            verify_flags |= OCSP_NOCHAIN;\n            break;\n        case OPT_NO_CERT_CHECKS:\n            verify_flags |= OCSP_NOCHECKS;\n            break;\n        case OPT_NO_EXPLICIT:\n            verify_flags |= OCSP_NOEXPLICIT;\n            break;\n        case OPT_TRUST_OTHER:\n            verify_flags |= OCSP_TRUSTOTHER;\n            break;\n        case OPT_NO_INTERN:\n            verify_flags |= OCSP_NOINTERN;\n            break;\n        case OPT_BADSIG:\n            badsig = 1;\n            break;\n        case OPT_TEXT:\n            req_text = resp_text = 1;\n            break;\n        case OPT_REQ_TEXT:\n            req_text = 1;\n            break;\n        case OPT_RESP_TEXT:\n            resp_text = 1;\n            break;\n        case OPT_REQIN:\n            reqin = opt_arg();\n            break;\n        case OPT_RESPIN:\n            respin = opt_arg();\n            break;\n        case OPT_SIGNER:\n            signfile = opt_arg();\n            break;\n        case OPT_VAFILE:\n            verify_certfile = opt_arg();\n            verify_flags |= OCSP_TRUSTOTHER;\n            break;\n        case OPT_SIGN_OTHER:\n            sign_certfile = opt_arg();\n            break;\n        case OPT_VERIFY_OTHER:\n            verify_certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_VALIDITY_PERIOD:\n            opt_long(opt_arg(), &nsec);\n            break;\n        case OPT_STATUS_AGE:\n            opt_long(opt_arg(), &maxage);\n            break;\n        case OPT_SIGNKEY:\n            keyfile = opt_arg();\n            break;\n        case OPT_REQOUT:\n            reqout = opt_arg();\n            break;\n        case OPT_RESPOUT:\n            respout = opt_arg();\n            break;\n        case OPT_ISSUER:\n            issuer = load_cert(opt_arg(), FORMAT_UNDEF, \"issuer certificate\");\n            if (issuer == NULL)\n                goto end;\n            if (issuers == NULL) {\n                if ((issuers = sk_X509_new_null()) == NULL)\n                    goto end;\n            }\n            if (!sk_X509_push(issuers, issuer))\n                goto end;\n            break;\n        case OPT_CERT:\n            reset_unknown();\n            X509_free(cert);\n            cert = load_cert(opt_arg(), FORMAT_UNDEF, \"certificate\");\n            if (cert == NULL)\n                goto end;\n            if (cert_id_md == NULL)\n                cert_id_md = (EVP_MD *)EVP_sha1();\n            if (!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))\n                goto end;\n            if (!sk_OPENSSL_STRING_push(reqnames, opt_arg()))\n                goto end;\n            trailing_md = 0;\n            break;\n        case OPT_SERIAL:\n            reset_unknown();\n            if (cert_id_md == NULL)\n                cert_id_md = (EVP_MD *)EVP_sha1();\n            if (!add_ocsp_serial(&req, opt_arg(), cert_id_md, issuer, ids))\n                goto end;\n            if (!sk_OPENSSL_STRING_push(reqnames, opt_arg()))\n                goto end;\n            trailing_md = 0;\n            break;\n        case OPT_INDEX:\n            ridx_filename = opt_arg();\n            break;\n        case OPT_CA:\n            rca_filename = opt_arg();\n            break;\n        case OPT_NMIN:\n            nmin = opt_int_arg();\n            if (ndays == -1)\n                ndays = 0;\n            break;\n        case OPT_REQUEST:\n            accept_count = opt_int_arg();\n            break;\n        case OPT_NDAYS:\n            ndays = atoi(opt_arg());\n            break;\n        case OPT_RSIGNER:\n            rsignfile = opt_arg();\n            break;\n        case OPT_RKEY:\n            rkeyfile = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_ROTHER:\n            rcertfile = opt_arg();\n            break;\n        case OPT_RMD:   /* Response MessageDigest */\n            respdigname = opt_arg();\n            break;\n        case OPT_RSIGOPT:\n            if (rsign_sigopts == NULL)\n                rsign_sigopts = sk_OPENSSL_STRING_new_null();\n            if (rsign_sigopts == NULL\n                || !sk_OPENSSL_STRING_push(rsign_sigopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_HEADER:\n            header = opt_arg();\n            value = strchr(header, '=');\n            if (value == NULL) {\n                BIO_printf(bio_err, \"Missing = in header key=value\\n\");\n                goto opthelp;\n            }\n            *value++ = '\\0';\n            if (!X509V3_add_value(header, value, &headers))\n                goto end;\n            break;\n        case OPT_RCID:\n            if (!opt_md(opt_arg(), &resp_certid_md))\n                goto opthelp;\n            break;\n        case OPT_MD:\n            if (trailing_md) {\n                BIO_printf(bio_err,\n                           \"%s: Digest must be before -cert or -serial\\n\",\n                           prog);\n                goto opthelp;\n            }\n            if (!opt_md(opt_unknown(), &cert_id_md))\n                goto opthelp;\n            trailing_md = 1;\n            break;\n        case OPT_MULTI:\n#ifdef HTTP_DAEMON\n            n_responders = atoi(opt_arg());\n#endif\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (trailing_md) {\n        BIO_printf(bio_err, \"%s: Digest must be before -cert or -serial\\n\",\n                   prog);\n        goto opthelp;\n    }\n\n    if (respdigname != NULL) {\n        if (!opt_md(respdigname, &rsign_md))\n            goto end;\n    }\n\n    /* Have we anything to do? */\n    if (req == NULL && reqin == NULL\n        && respin == NULL && !(port != NULL && ridx_filename != NULL))\n        goto opthelp;\n\n    if (req == NULL && (add_nonce != 2))\n        add_nonce = 0;\n\n    if (req == NULL && reqin != NULL) {\n        derbio = bio_open_default(reqin, 'r', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        req = d2i_OCSP_REQUEST_bio(derbio, NULL);\n        BIO_free(derbio);\n        if (req == NULL) {\n            BIO_printf(bio_err, \"Error reading OCSP request\\n\");\n            goto end;\n        }\n    }\n\n    if (req == NULL && port != NULL) {\n#ifndef OPENSSL_NO_SOCK\n        acbio = http_server_init(prog, port, -1);\n        if (acbio == NULL)\n            goto end;\n#else\n        BIO_printf(bio_err, \"Cannot act as server - sockets not supported\\n\");\n        goto end;\n#endif\n    }\n\n    if (rsignfile != NULL) {\n        if (rkeyfile == NULL)\n            rkeyfile = rsignfile;\n        rsigner = load_cert(rsignfile, FORMAT_UNDEF, \"responder certificate\");\n        if (rsigner == NULL) {\n            BIO_printf(bio_err, \"Error loading responder certificate\\n\");\n            goto end;\n        }\n        if (!load_certs(rca_filename, 0, &rca_certs, NULL, \"CA certificates\"))\n            goto end;\n        if (rcertfile != NULL) {\n            if (!load_certs(rcertfile, 0, &rother, NULL,\n                            \"responder other certificates\"))\n                goto end;\n        }\n        if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n            BIO_printf(bio_err, \"Error getting password\\n\");\n            goto end;\n        }\n        rkey = load_key(rkeyfile, FORMAT_UNDEF, 0, passin, NULL,\n                        \"responder private key\");\n        if (rkey == NULL)\n            goto end;\n    }\n\n    if (ridx_filename != NULL\n        && (rkey == NULL || rsigner == NULL || rca_certs == NULL)) {\n        BIO_printf(bio_err,\n                   \"Responder mode requires certificate, key, and CA.\\n\");\n        goto end;\n    }\n\n    if (ridx_filename != NULL) {\n        rdb = load_index(ridx_filename, NULL);\n        if (rdb == NULL || index_index(rdb) <= 0) {\n            BIO_printf(bio_err,\n                \"Problem with index file: %s (could not load/parse file)\\n\",\n                ridx_filename);\n            ret = 1;\n            goto end;\n        }\n    }\n\n#ifdef HTTP_DAEMON\n    if (n_responders != 0 && acbio != NULL)\n        spawn_loop(prog);\n    if (acbio != NULL && req_timeout > 0)\n        signal(SIGALRM, socket_timeout);\n#endif\n\n    if (acbio != NULL)\n        trace_log_message(-1, prog,\n                          LOG_INFO, \"waiting for OCSP client connections...\");\n\nredo_accept:\n\n    if (acbio != NULL) {\n#ifdef HTTP_DAEMON\n        if (index_changed(rdb)) {\n            CA_DB *newrdb = load_index(ridx_filename, NULL);\n\n            if (newrdb != NULL && index_index(newrdb) > 0) {\n                free_index(rdb);\n                rdb = newrdb;\n            } else {\n                free_index(newrdb);\n                trace_log_message(-1, prog,\n                                  LOG_ERR, \"error reloading updated index: %s\",\n                                  ridx_filename);\n            }\n        }\n#endif\n\n        req = NULL;\n        res = do_responder(&req, &cbio, acbio, req_timeout);\n        if (res == 0)\n            goto redo_accept;\n\n        if (req == NULL) {\n            if (res == 1) {\n                resp =\n                    OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST,\n                                         NULL);\n                send_ocsp_response(cbio, resp);\n            }\n            goto done_resp;\n        }\n    }\n\n    if (req == NULL\n        && (signfile != NULL || reqout != NULL\n            || host != NULL || add_nonce || ridx_filename != NULL)) {\n        BIO_printf(bio_err, \"Need an OCSP request for this operation!\\n\");\n        goto end;\n    }\n\n    if (req != NULL && add_nonce) {\n        if (!OCSP_request_add1_nonce(req, NULL, -1))\n            goto end;\n    }\n\n    if (signfile != NULL) {\n        if (keyfile == NULL)\n            keyfile = signfile;\n        signer = load_cert(signfile, FORMAT_UNDEF, \"signer certificate\");\n        if (signer == NULL) {\n            BIO_printf(bio_err, \"Error loading signer certificate\\n\");\n            goto end;\n        }\n        if (sign_certfile != NULL) {\n            if (!load_certs(sign_certfile, 0, &sign_other, NULL,\n                            \"signer certificates\"))\n                goto end;\n        }\n        key = load_key(keyfile, FORMAT_UNDEF, 0, NULL, NULL,\n                       \"signer private key\");\n        if (key == NULL)\n            goto end;\n\n        if (!OCSP_request_sign(req, signer, key, NULL,\n                               sign_other, sign_flags)) {\n            BIO_printf(bio_err, \"Error signing OCSP request\\n\");\n            goto end;\n        }\n    }\n\n    out = bio_open_default(outfile, 'w', FORMAT_TEXT);\n    if (out == NULL)\n        goto end;\n\n    if (req_text && req != NULL)\n        OCSP_REQUEST_print(out, req, 0);\n\n    if (reqout != NULL) {\n        derbio = bio_open_default(reqout, 'w', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        i2d_OCSP_REQUEST_bio(derbio, req);\n        BIO_free(derbio);\n    }\n\n    if (rdb != NULL) {\n        make_ocsp_response(bio_err, &resp, req, rdb, rca_certs, rsigner, rkey,\n                           rsign_md, rsign_sigopts, rother, rflags, nmin, ndays,\n                           badsig, resp_certid_md);\n        if (resp == NULL)\n            goto end;\n        if (cbio != NULL)\n            send_ocsp_response(cbio, resp);\n    } else if (host != NULL) {\n#ifndef OPENSSL_NO_SOCK\n        resp = process_responder(req, host, port, path, opt_proxy, opt_no_proxy,\n                                 use_ssl, headers, req_timeout);\n        if (resp == NULL)\n            goto end;\n#else\n        BIO_printf(bio_err,\n                   \"Error creating connect BIO - sockets not supported\\n\");\n        goto end;\n#endif\n    } else if (respin != NULL) {\n        derbio = bio_open_default(respin, 'r', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        resp = d2i_OCSP_RESPONSE_bio(derbio, NULL);\n        BIO_free(derbio);\n        if (resp == NULL) {\n            BIO_printf(bio_err, \"Error reading OCSP response\\n\");\n            goto end;\n        }\n    } else {\n        ret = 0;\n        goto end;\n    }\n\n done_resp:\n\n    if (respout != NULL) {\n        derbio = bio_open_default(respout, 'w', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        i2d_OCSP_RESPONSE_bio(derbio, resp);\n        BIO_free(derbio);\n    }\n\n    i = OCSP_response_status(resp);\n    if (i != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n        BIO_printf(out, \"Responder Error: %s (%d)\\n\",\n                   OCSP_response_status_str(i), i);\n        if (!ignore_err)\n                goto end;\n    }\n\n    if (resp_text)\n        OCSP_RESPONSE_print(out, resp, 0);\n\n    /* If running as responder don't verify our own response */\n    if (cbio != NULL) {\n        /* If not unlimited, see if we took all we should. */\n        if (accept_count != -1 && --accept_count <= 0) {\n            ret = 0;\n            goto end;\n        }\n        BIO_free_all(cbio);\n        cbio = NULL;\n        OCSP_REQUEST_free(req);\n        req = NULL;\n        OCSP_RESPONSE_free(resp);\n        resp = NULL;\n        goto redo_accept;\n    }\n    if (ridx_filename != NULL) {\n        ret = 0;\n        goto end;\n    }\n\n    if (store == NULL) {\n        store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                             CAstore, noCAstore);\n        if (!store)\n            goto end;\n    }\n    if (vpmtouched)\n        X509_STORE_set1_param(store, vpm);\n    if (verify_certfile != NULL) {\n        if (!load_certs(verify_certfile, 0, &verify_other, NULL,\n                        \"validator certificates\"))\n            goto end;\n    }\n\n    bs = OCSP_response_get1_basic(resp);\n    if (bs == NULL) {\n        BIO_printf(bio_err, \"Error parsing response\\n\");\n        goto end;\n    }\n\n    ret = 0;\n\n    if (!noverify) {\n        if (req != NULL && ((i = OCSP_check_nonce(req, bs)) <= 0)) {\n            if (i == -1)\n                BIO_printf(bio_err, \"WARNING: no nonce in response\\n\");\n            else {\n                BIO_printf(bio_err, \"Nonce Verify error\\n\");\n                ret = 1;\n                goto end;\n            }\n        }\n\n        i = OCSP_basic_verify(bs, verify_other, store, verify_flags);\n        if (i <= 0 && issuers) {\n            i = OCSP_basic_verify(bs, issuers, store, OCSP_TRUSTOTHER);\n            if (i > 0)\n                ERR_clear_error();\n        }\n        if (i <= 0) {\n            BIO_printf(bio_err, \"Response Verify Failure\\n\");\n            ERR_print_errors(bio_err);\n            ret = 1;\n        } else {\n            BIO_printf(bio_err, \"Response verify OK\\n\");\n        }\n    }\n\n    if (!print_ocsp_summary(out, bs, req, reqnames, ids, nsec, maxage))\n        ret = 1;\n\n end:\n    ERR_print_errors(bio_err);\n    X509_free(signer);\n    X509_STORE_free(store);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(rsign_sigopts);\n    EVP_PKEY_free(key);\n    EVP_PKEY_free(rkey);\n    EVP_MD_free(cert_id_md);\n    EVP_MD_free(rsign_md);\n    EVP_MD_free(resp_certid_md);\n    X509_free(cert);\n    OSSL_STACK_OF_X509_free(issuers);\n    X509_free(rsigner);\n    OSSL_STACK_OF_X509_free(rca_certs);\n    free_index(rdb);\n    BIO_free_all(cbio);\n    BIO_free_all(acbio);\n    BIO_free_all(out);\n    OCSP_REQUEST_free(req);\n    OCSP_RESPONSE_free(resp);\n    OCSP_BASICRESP_free(bs);\n    sk_OPENSSL_STRING_free(reqnames);\n    sk_OCSP_CERTID_free(ids);\n    OSSL_STACK_OF_X509_free(sign_other);\n    OSSL_STACK_OF_X509_free(verify_other);\n    sk_CONF_VALUE_pop_free(headers, X509V3_conf_free);\n    OPENSSL_free(thost);\n    OPENSSL_free(tport);\n    OPENSSL_free(tpath);\n\n    return ret;\n}"
        ],
        "sink": "make_ocsp_response(bio_err, &resp, req, rdb, rca_certs, rsigner, rkey,",
        "final_sink": "make_ocsp_response(bio_err, &resp, req, rdb, rca_certs, rsigner, rkey,",
        "source": [
            "    ectx = OSSL_ENCODER_CTX_new_for_pkey(pkey, selection, output_type,"
        ],
        "index": 33
    },
    {
        "prt": "resp",
        "function_call": [
            "int ocsp_main(int argc, char **argv)\n{\n    BIO *acbio = NULL, *cbio = NULL, *derbio = NULL, *out = NULL;\n    EVP_MD *cert_id_md = NULL, *rsign_md = NULL;\n    STACK_OF(OPENSSL_STRING) *rsign_sigopts = NULL;\n    int trailing_md = 0;\n    CA_DB *rdb = NULL;\n    EVP_PKEY *key = NULL, *rkey = NULL;\n    OCSP_BASICRESP *bs = NULL;\n    OCSP_REQUEST *req = NULL;\n    OCSP_RESPONSE *resp = NULL;\n    STACK_OF(CONF_VALUE) *headers = NULL;\n    STACK_OF(OCSP_CERTID) *ids = NULL;\n    STACK_OF(OPENSSL_STRING) *reqnames = NULL;\n    STACK_OF(X509) *sign_other = NULL, *verify_other = NULL, *rother = NULL;\n    STACK_OF(X509) *issuers = NULL;\n    X509 *issuer = NULL, *cert = NULL;\n    STACK_OF(X509) *rca_certs = NULL;\n    EVP_MD *resp_certid_md = NULL;\n    X509 *signer = NULL, *rsigner = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL;\n    char *header, *value, *respdigname = NULL;\n    char *host = NULL, *port = NULL, *path = \"/\", *outfile = NULL;\n#ifndef OPENSSL_NO_SOCK\n    char *opt_proxy = NULL;\n    char *opt_no_proxy = NULL;\n#endif\n    char *rca_filename = NULL, *reqin = NULL, *respin = NULL;\n    char *reqout = NULL, *respout = NULL, *ridx_filename = NULL;\n    char *rsignfile = NULL, *rkeyfile = NULL;\n    char *passinarg = NULL, *passin = NULL;\n    char *sign_certfile = NULL, *verify_certfile = NULL, *rcertfile = NULL;\n    char *signfile = NULL, *keyfile = NULL;\n    char *thost = NULL, *tport = NULL, *tpath = NULL;\n    int noCAfile = 0, noCApath = 0, noCAstore = 0;\n    int accept_count = -1, add_nonce = 1, noverify = 0, use_ssl = -1;\n    int vpmtouched = 0, badsig = 0, i, ignore_err = 0, nmin = 0, ndays = -1;\n    int req_text = 0, resp_text = 0, res, ret = 1;\n    int req_timeout = -1;\n    long nsec = MAX_VALIDITY_PERIOD, maxage = -1;\n    unsigned long sign_flags = 0, verify_flags = 0, rflags = 0;\n    OPTION_CHOICE o;\n\n    if ((reqnames = sk_OPENSSL_STRING_new_null()) == NULL\n            || (ids = sk_OCSP_CERTID_new_null()) == NULL\n            || (vpm = X509_VERIFY_PARAM_new()) == NULL)\n        goto end;\n\n    opt_set_unknown_name(\"digest\");\n    prog = opt_init(argc, argv, ocsp_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            ret = 0;\n            opt_help(ocsp_options);\n            goto end;\n        case OPT_OUTFILE:\n            outfile = opt_arg();\n            break;\n        case OPT_TIMEOUT:\n#ifndef OPENSSL_NO_SOCK\n            req_timeout = atoi(opt_arg());\n#endif\n            break;\n        case OPT_URL:\n            OPENSSL_free(thost);\n            OPENSSL_free(tport);\n            OPENSSL_free(tpath);\n            thost = tport = tpath = NULL;\n            if (!OSSL_HTTP_parse_url(opt_arg(), &use_ssl, NULL /* userinfo */,\n                                     &host, &port, NULL /* port_num */,\n                                     &path, NULL /* qry */, NULL /* frag */)) {\n                BIO_printf(bio_err, \"%s Error parsing -url argument\\n\", prog);\n                goto end;\n            }\n            thost = host;\n            tport = port;\n            tpath = path;\n            break;\n        case OPT_HOST:\n            host = opt_arg();\n            break;\n        case OPT_PORT:\n            port = opt_arg();\n            break;\n        case OPT_PATH:\n            path = opt_arg();\n            break;\n#ifndef OPENSSL_NO_SOCK\n        case OPT_PROXY:\n            opt_proxy = opt_arg();\n            break;\n        case OPT_NO_PROXY:\n            opt_no_proxy = opt_arg();\n            break;\n#endif\n        case OPT_IGNORE_ERR:\n            ignore_err = 1;\n            break;\n        case OPT_NOVERIFY:\n            noverify = 1;\n            break;\n        case OPT_NONCE:\n            add_nonce = 2;\n            break;\n        case OPT_NO_NONCE:\n            add_nonce = 0;\n            break;\n        case OPT_RESP_NO_CERTS:\n            rflags |= OCSP_NOCERTS;\n            break;\n        case OPT_RESP_KEY_ID:\n            rflags |= OCSP_RESPID_KEY;\n            break;\n        case OPT_NO_CERTS:\n            sign_flags |= OCSP_NOCERTS;\n            break;\n        case OPT_NO_SIGNATURE_VERIFY:\n            verify_flags |= OCSP_NOSIGS;\n            break;\n        case OPT_NO_CERT_VERIFY:\n            verify_flags |= OCSP_NOVERIFY;\n            break;\n        case OPT_NO_CHAIN:\n            verify_flags |= OCSP_NOCHAIN;\n            break;\n        case OPT_NO_CERT_CHECKS:\n            verify_flags |= OCSP_NOCHECKS;\n            break;\n        case OPT_NO_EXPLICIT:\n            verify_flags |= OCSP_NOEXPLICIT;\n            break;\n        case OPT_TRUST_OTHER:\n            verify_flags |= OCSP_TRUSTOTHER;\n            break;\n        case OPT_NO_INTERN:\n            verify_flags |= OCSP_NOINTERN;\n            break;\n        case OPT_BADSIG:\n            badsig = 1;\n            break;\n        case OPT_TEXT:\n            req_text = resp_text = 1;\n            break;\n        case OPT_REQ_TEXT:\n            req_text = 1;\n            break;\n        case OPT_RESP_TEXT:\n            resp_text = 1;\n            break;\n        case OPT_REQIN:\n            reqin = opt_arg();\n            break;\n        case OPT_RESPIN:\n            respin = opt_arg();\n            break;\n        case OPT_SIGNER:\n            signfile = opt_arg();\n            break;\n        case OPT_VAFILE:\n            verify_certfile = opt_arg();\n            verify_flags |= OCSP_TRUSTOTHER;\n            break;\n        case OPT_SIGN_OTHER:\n            sign_certfile = opt_arg();\n            break;\n        case OPT_VERIFY_OTHER:\n            verify_certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_VALIDITY_PERIOD:\n            opt_long(opt_arg(), &nsec);\n            break;\n        case OPT_STATUS_AGE:\n            opt_long(opt_arg(), &maxage);\n            break;\n        case OPT_SIGNKEY:\n            keyfile = opt_arg();\n            break;\n        case OPT_REQOUT:\n            reqout = opt_arg();\n            break;\n        case OPT_RESPOUT:\n            respout = opt_arg();\n            break;\n        case OPT_ISSUER:\n            issuer = load_cert(opt_arg(), FORMAT_UNDEF, \"issuer certificate\");\n            if (issuer == NULL)\n                goto end;\n            if (issuers == NULL) {\n                if ((issuers = sk_X509_new_null()) == NULL)\n                    goto end;\n            }\n            if (!sk_X509_push(issuers, issuer))\n                goto end;\n            break;\n        case OPT_CERT:\n            reset_unknown();\n            X509_free(cert);\n            cert = load_cert(opt_arg(), FORMAT_UNDEF, \"certificate\");\n            if (cert == NULL)\n                goto end;\n            if (cert_id_md == NULL)\n                cert_id_md = (EVP_MD *)EVP_sha1();\n            if (!add_ocsp_cert(&req, cert, cert_id_md, issuer, ids))\n                goto end;\n            if (!sk_OPENSSL_STRING_push(reqnames, opt_arg()))\n                goto end;\n            trailing_md = 0;\n            break;\n        case OPT_SERIAL:\n            reset_unknown();\n            if (cert_id_md == NULL)\n                cert_id_md = (EVP_MD *)EVP_sha1();\n            if (!add_ocsp_serial(&req, opt_arg(), cert_id_md, issuer, ids))\n                goto end;\n            if (!sk_OPENSSL_STRING_push(reqnames, opt_arg()))\n                goto end;\n            trailing_md = 0;\n            break;\n        case OPT_INDEX:\n            ridx_filename = opt_arg();\n            break;\n        case OPT_CA:\n            rca_filename = opt_arg();\n            break;\n        case OPT_NMIN:\n            nmin = opt_int_arg();\n            if (ndays == -1)\n                ndays = 0;\n            break;\n        case OPT_REQUEST:\n            accept_count = opt_int_arg();\n            break;\n        case OPT_NDAYS:\n            ndays = atoi(opt_arg());\n            break;\n        case OPT_RSIGNER:\n            rsignfile = opt_arg();\n            break;\n        case OPT_RKEY:\n            rkeyfile = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_ROTHER:\n            rcertfile = opt_arg();\n            break;\n        case OPT_RMD:   /* Response MessageDigest */\n            respdigname = opt_arg();\n            break;\n        case OPT_RSIGOPT:\n            if (rsign_sigopts == NULL)\n                rsign_sigopts = sk_OPENSSL_STRING_new_null();\n            if (rsign_sigopts == NULL\n                || !sk_OPENSSL_STRING_push(rsign_sigopts, opt_arg()))\n                goto end;\n            break;\n        case OPT_HEADER:\n            header = opt_arg();\n            value = strchr(header, '=');\n            if (value == NULL) {\n                BIO_printf(bio_err, \"Missing = in header key=value\\n\");\n                goto opthelp;\n            }\n            *value++ = '\\0';\n            if (!X509V3_add_value(header, value, &headers))\n                goto end;\n            break;\n        case OPT_RCID:\n            if (!opt_md(opt_arg(), &resp_certid_md))\n                goto opthelp;\n            break;\n        case OPT_MD:\n            if (trailing_md) {\n                BIO_printf(bio_err,\n                           \"%s: Digest must be before -cert or -serial\\n\",\n                           prog);\n                goto opthelp;\n            }\n            if (!opt_md(opt_unknown(), &cert_id_md))\n                goto opthelp;\n            trailing_md = 1;\n            break;\n        case OPT_MULTI:\n#ifdef HTTP_DAEMON\n            n_responders = atoi(opt_arg());\n#endif\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (trailing_md) {\n        BIO_printf(bio_err, \"%s: Digest must be before -cert or -serial\\n\",\n                   prog);\n        goto opthelp;\n    }\n\n    if (respdigname != NULL) {\n        if (!opt_md(respdigname, &rsign_md))\n            goto end;\n    }\n\n    /* Have we anything to do? */\n    if (req == NULL && reqin == NULL\n        && respin == NULL && !(port != NULL && ridx_filename != NULL))\n        goto opthelp;\n\n    if (req == NULL && (add_nonce != 2))\n        add_nonce = 0;\n\n    if (req == NULL && reqin != NULL) {\n        derbio = bio_open_default(reqin, 'r', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        req = d2i_OCSP_REQUEST_bio(derbio, NULL);\n        BIO_free(derbio);\n        if (req == NULL) {\n            BIO_printf(bio_err, \"Error reading OCSP request\\n\");\n            goto end;\n        }\n    }\n\n    if (req == NULL && port != NULL) {\n#ifndef OPENSSL_NO_SOCK\n        acbio = http_server_init(prog, port, -1);\n        if (acbio == NULL)\n            goto end;\n#else\n        BIO_printf(bio_err, \"Cannot act as server - sockets not supported\\n\");\n        goto end;\n#endif\n    }\n\n    if (rsignfile != NULL) {\n        if (rkeyfile == NULL)\n            rkeyfile = rsignfile;\n        rsigner = load_cert(rsignfile, FORMAT_UNDEF, \"responder certificate\");\n        if (rsigner == NULL) {\n            BIO_printf(bio_err, \"Error loading responder certificate\\n\");\n            goto end;\n        }\n        if (!load_certs(rca_filename, 0, &rca_certs, NULL, \"CA certificates\"))\n            goto end;\n        if (rcertfile != NULL) {\n            if (!load_certs(rcertfile, 0, &rother, NULL,\n                            \"responder other certificates\"))\n                goto end;\n        }\n        if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n            BIO_printf(bio_err, \"Error getting password\\n\");\n            goto end;\n        }\n        rkey = load_key(rkeyfile, FORMAT_UNDEF, 0, passin, NULL,\n                        \"responder private key\");\n        if (rkey == NULL)\n            goto end;\n    }\n\n    if (ridx_filename != NULL\n        && (rkey == NULL || rsigner == NULL || rca_certs == NULL)) {\n        BIO_printf(bio_err,\n                   \"Responder mode requires certificate, key, and CA.\\n\");\n        goto end;\n    }\n\n    if (ridx_filename != NULL) {\n        rdb = load_index(ridx_filename, NULL);\n        if (rdb == NULL || index_index(rdb) <= 0) {\n            BIO_printf(bio_err,\n                \"Problem with index file: %s (could not load/parse file)\\n\",\n                ridx_filename);\n            ret = 1;\n            goto end;\n        }\n    }\n\n#ifdef HTTP_DAEMON\n    if (n_responders != 0 && acbio != NULL)\n        spawn_loop(prog);\n    if (acbio != NULL && req_timeout > 0)\n        signal(SIGALRM, socket_timeout);\n#endif\n\n    if (acbio != NULL)\n        trace_log_message(-1, prog,\n                          LOG_INFO, \"waiting for OCSP client connections...\");\n\nredo_accept:\n\n    if (acbio != NULL) {\n#ifdef HTTP_DAEMON\n        if (index_changed(rdb)) {\n            CA_DB *newrdb = load_index(ridx_filename, NULL);\n\n            if (newrdb != NULL && index_index(newrdb) > 0) {\n                free_index(rdb);\n                rdb = newrdb;\n            } else {\n                free_index(newrdb);\n                trace_log_message(-1, prog,\n                                  LOG_ERR, \"error reloading updated index: %s\",\n                                  ridx_filename);\n            }\n        }\n#endif\n\n        req = NULL;\n        res = do_responder(&req, &cbio, acbio, req_timeout);\n        if (res == 0)\n            goto redo_accept;\n\n        if (req == NULL) {\n            if (res == 1) {\n                resp =\n                    OCSP_response_create(OCSP_RESPONSE_STATUS_MALFORMEDREQUEST,\n                                         NULL);\n                send_ocsp_response(cbio, resp);\n            }\n            goto done_resp;\n        }\n    }\n\n    if (req == NULL\n        && (signfile != NULL || reqout != NULL\n            || host != NULL || add_nonce || ridx_filename != NULL)) {\n        BIO_printf(bio_err, \"Need an OCSP request for this operation!\\n\");\n        goto end;\n    }\n\n    if (req != NULL && add_nonce) {\n        if (!OCSP_request_add1_nonce(req, NULL, -1))\n            goto end;\n    }\n\n    if (signfile != NULL) {\n        if (keyfile == NULL)\n            keyfile = signfile;\n        signer = load_cert(signfile, FORMAT_UNDEF, \"signer certificate\");\n        if (signer == NULL) {\n            BIO_printf(bio_err, \"Error loading signer certificate\\n\");\n            goto end;\n        }\n        if (sign_certfile != NULL) {\n            if (!load_certs(sign_certfile, 0, &sign_other, NULL,\n                            \"signer certificates\"))\n                goto end;\n        }\n        key = load_key(keyfile, FORMAT_UNDEF, 0, NULL, NULL,\n                       \"signer private key\");\n        if (key == NULL)\n            goto end;\n\n        if (!OCSP_request_sign(req, signer, key, NULL,\n                               sign_other, sign_flags)) {\n            BIO_printf(bio_err, \"Error signing OCSP request\\n\");\n            goto end;\n        }\n    }\n\n    out = bio_open_default(outfile, 'w', FORMAT_TEXT);\n    if (out == NULL)\n        goto end;\n\n    if (req_text && req != NULL)\n        OCSP_REQUEST_print(out, req, 0);\n\n    if (reqout != NULL) {\n        derbio = bio_open_default(reqout, 'w', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        i2d_OCSP_REQUEST_bio(derbio, req);\n        BIO_free(derbio);\n    }\n\n    if (rdb != NULL) {\n        make_ocsp_response(bio_err, &resp, req, rdb, rca_certs, rsigner, rkey,\n                           rsign_md, rsign_sigopts, rother, rflags, nmin, ndays,\n                           badsig, resp_certid_md);\n        if (resp == NULL)\n            goto end;\n        if (cbio != NULL)\n            send_ocsp_response(cbio, resp);\n    } else if (host != NULL) {\n#ifndef OPENSSL_NO_SOCK\n        resp = process_responder(req, host, port, path, opt_proxy, opt_no_proxy,\n                                 use_ssl, headers, req_timeout);\n        if (resp == NULL)\n            goto end;\n#else\n        BIO_printf(bio_err,\n                   \"Error creating connect BIO - sockets not supported\\n\");\n        goto end;\n#endif\n    } else if (respin != NULL) {\n        derbio = bio_open_default(respin, 'r', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        resp = d2i_OCSP_RESPONSE_bio(derbio, NULL);\n        BIO_free(derbio);\n        if (resp == NULL) {\n            BIO_printf(bio_err, \"Error reading OCSP response\\n\");\n            goto end;\n        }\n    } else {\n        ret = 0;\n        goto end;\n    }\n\n done_resp:\n\n    if (respout != NULL) {\n        derbio = bio_open_default(respout, 'w', FORMAT_ASN1);\n        if (derbio == NULL)\n            goto end;\n        i2d_OCSP_RESPONSE_bio(derbio, resp);\n        BIO_free(derbio);\n    }\n\n    i = OCSP_response_status(resp);\n    if (i != OCSP_RESPONSE_STATUS_SUCCESSFUL) {\n        BIO_printf(out, \"Responder Error: %s (%d)\\n\",\n                   OCSP_response_status_str(i), i);\n        if (!ignore_err)\n                goto end;\n    }\n\n    if (resp_text)\n        OCSP_RESPONSE_print(out, resp, 0);\n\n    /* If running as responder don't verify our own response */\n    if (cbio != NULL) {\n        /* If not unlimited, see if we took all we should. */\n        if (accept_count != -1 && --accept_count <= 0) {\n            ret = 0;\n            goto end;\n        }\n        BIO_free_all(cbio);\n        cbio = NULL;\n        OCSP_REQUEST_free(req);\n        req = NULL;\n        OCSP_RESPONSE_free(resp);\n        resp = NULL;\n        goto redo_accept;\n    }\n    if (ridx_filename != NULL) {\n        ret = 0;\n        goto end;\n    }\n\n    if (store == NULL) {\n        store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                             CAstore, noCAstore);\n        if (!store)\n            goto end;\n    }\n    if (vpmtouched)\n        X509_STORE_set1_param(store, vpm);\n    if (verify_certfile != NULL) {\n        if (!load_certs(verify_certfile, 0, &verify_other, NULL,\n                        \"validator certificates\"))\n            goto end;\n    }\n\n    bs = OCSP_response_get1_basic(resp);\n    if (bs == NULL) {\n        BIO_printf(bio_err, \"Error parsing response\\n\");\n        goto end;\n    }\n\n    ret = 0;\n\n    if (!noverify) {\n        if (req != NULL && ((i = OCSP_check_nonce(req, bs)) <= 0)) {\n            if (i == -1)\n                BIO_printf(bio_err, \"WARNING: no nonce in response\\n\");\n            else {\n                BIO_printf(bio_err, \"Nonce Verify error\\n\");\n                ret = 1;\n                goto end;\n            }\n        }\n\n        i = OCSP_basic_verify(bs, verify_other, store, verify_flags);\n        if (i <= 0 && issuers) {\n            i = OCSP_basic_verify(bs, issuers, store, OCSP_TRUSTOTHER);\n            if (i > 0)\n                ERR_clear_error();\n        }\n        if (i <= 0) {\n            BIO_printf(bio_err, \"Response Verify Failure\\n\");\n            ERR_print_errors(bio_err);\n            ret = 1;\n        } else {\n            BIO_printf(bio_err, \"Response verify OK\\n\");\n        }\n    }\n\n    if (!print_ocsp_summary(out, bs, req, reqnames, ids, nsec, maxage))\n        ret = 1;\n\n end:\n    ERR_print_errors(bio_err);\n    X509_free(signer);\n    X509_STORE_free(store);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(rsign_sigopts);\n    EVP_PKEY_free(key);\n    EVP_PKEY_free(rkey);\n    EVP_MD_free(cert_id_md);\n    EVP_MD_free(rsign_md);\n    EVP_MD_free(resp_certid_md);\n    X509_free(cert);\n    OSSL_STACK_OF_X509_free(issuers);\n    X509_free(rsigner);\n    OSSL_STACK_OF_X509_free(rca_certs);\n    free_index(rdb);\n    BIO_free_all(cbio);\n    BIO_free_all(acbio);\n    BIO_free_all(out);\n    OCSP_REQUEST_free(req);\n    OCSP_RESPONSE_free(resp);\n    OCSP_BASICRESP_free(bs);\n    sk_OPENSSL_STRING_free(reqnames);\n    sk_OCSP_CERTID_free(ids);\n    OSSL_STACK_OF_X509_free(sign_other);\n    OSSL_STACK_OF_X509_free(verify_other);\n    sk_CONF_VALUE_pop_free(headers, X509V3_conf_free);\n    OPENSSL_free(thost);\n    OPENSSL_free(tport);\n    OPENSSL_free(tpath);\n\n    return ret;\n}",
            "int OCSP_response_status(OCSP_RESPONSE *resp)\n{\n    return ASN1_ENUMERATED_get(resp->responseStatus);\n}"
        ],
        "sink": "i = OCSP_response_status(resp);",
        "final_sink": "    return ASN1_ENUMERATED_get(resp->responseStatus);",
        "source": [
            "        ectx = OSSL_ENCODER_CTX_new_for_pkey(eckey, selection,"
        ],
        "index": -1
    },
    {
        "prt": "prog",
        "function_call": [
            "int main(int argc, char *argv[])\n{\n    FUNCTION f, *fp;\n    LHASH_OF(FUNCTION) *prog = NULL;\n    char *pname;\n    const char *fname;\n    ARGS arg;\n    int global_help = 0;\n    int global_version = 0;\n    int ret = 0;\n\n    arg.argv = NULL;\n    arg.size = 0;\n\n    /* Set up some of the environment. */\n    bio_in = dup_bio_in(FORMAT_TEXT);\n    bio_out = dup_bio_out(FORMAT_TEXT);\n    bio_err = dup_bio_err(FORMAT_TEXT);\n\n#if defined(OPENSSL_SYS_VMS) && defined(__DECC)\n    argv = copy_argv(&argc, argv);\n#elif defined(_WIN32)\n    /* Replace argv[] with UTF-8 encoded strings. */\n    win32_utf8argv(&argc, &argv);\n#endif\n\n#ifndef OPENSSL_NO_TRACE\n    setup_trace(getenv(\"OPENSSL_TRACE\"));\n#endif\n\n    if ((fname = \"apps_startup\", !apps_startup())\n            || (fname = \"prog_init\", (prog = prog_init()) == NULL)) {\n        BIO_printf(bio_err,\n                   \"FATAL: Startup failure (dev note: %s()) for %s\\n\",\n                   fname, argv[0]);\n        ERR_print_errors(bio_err);\n        ret = 1;\n        goto end;\n    }\n    pname = opt_progname(argv[0]);\n\n    default_config_file = CONF_get1_default_config_file();\n    if (default_config_file == NULL)\n        app_bail_out(\"%s: could not get default config file\\n\", pname);\n\n    /* first check the program name */\n    f.name = pname;\n    fp = lh_FUNCTION_retrieve(prog, &f);\n    if (fp == NULL) {\n        /* We assume we've been called as 'openssl ...' */\n        global_help = argc > 1\n            && (strcmp(argv[1], \"-help\") == 0 || strcmp(argv[1], \"--help\") == 0\n                || strcmp(argv[1], \"-h\") == 0 || strcmp(argv[1], \"--h\") == 0);\n        global_version = argc > 1\n            && (strcmp(argv[1], \"-version\") == 0 || strcmp(argv[1], \"--version\") == 0\n                || strcmp(argv[1], \"-v\") == 0 || strcmp(argv[1], \"--v\") == 0);\n\n        argc--;\n        argv++;\n        opt_appname(argc == 1 || global_help ? \"help\" : global_version ? \"version\" : argv[0]);\n    } else {\n        argv[0] = pname;\n    }\n\n    /*\n     * If there's no command, assume \"help\". If there's an override for help\n     * or version run those, otherwise run the command given.\n     */\n    ret =  (argc == 0) || global_help\n            ? do_cmd(prog, 1, help_argv)\n            : global_version\n                ? do_cmd(prog, 1, version_argv)\n                : do_cmd(prog, argc, argv);\n\n end:\n    OPENSSL_free(default_config_file);\n    lh_FUNCTION_free(prog);\n    OPENSSL_free(arg.argv);\n    if (!app_RAND_write())\n        ret = EXIT_FAILURE;\n\n    BIO_free(bio_in);\n    BIO_free_all(bio_out);\n    apps_shutdown();\n    BIO_free_all(bio_err);\n    EXIT(ret);\n}"
        ],
        "sink": "fp = lh_FUNCTION_retrieve(prog, &f);",
        "final_sink": "fp = lh_FUNCTION_retrieve(prog, &f);",
        "source": [
            "        ectx = OSSL_ENCODER_CTX_new_for_pkey(eckey, selection,"
        ],
        "index": 34
    },
    {
        "prt": "passwds",
        "function_call": [
            "int passwd_main(int argc, char **argv)\n{\n    BIO *in = NULL;\n    char *infile = NULL, *salt = NULL, *passwd = NULL, **passwds = NULL;\n    char *salt_malloc = NULL, *passwd_malloc = NULL, *prog;\n    OPTION_CHOICE o;\n    int in_stdin = 0, pw_source_defined = 0;\n#ifndef OPENSSL_NO_UI_CONSOLE\n    int in_noverify = 0;\n#endif\n    int passed_salt = 0, quiet = 0, table = 0, reverse = 0;\n    int ret = 1;\n    passwd_modes mode = passwd_unset;\n    size_t passwd_malloc_size = 0;\n    size_t pw_maxlen = 256; /* arbitrary limit, should be enough for most\n                             * passwords */\n\n    prog = opt_init(argc, argv, passwd_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(passwd_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            if (pw_source_defined)\n                goto opthelp;\n            infile = opt_arg();\n            pw_source_defined = 1;\n            break;\n        case OPT_NOVERIFY:\n#ifndef OPENSSL_NO_UI_CONSOLE\n            in_noverify = 1;\n#endif\n            break;\n        case OPT_QUIET:\n            quiet = 1;\n            break;\n        case OPT_TABLE:\n            table = 1;\n            break;\n        case OPT_REVERSE:\n            reverse = 1;\n            break;\n        case OPT_1:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_md5;\n            break;\n        case OPT_5:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_sha256;\n            break;\n        case OPT_6:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_sha512;\n            break;\n        case OPT_APR1:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_apr1;\n            break;\n        case OPT_AIXMD5:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_aixmd5;\n            break;\n        case OPT_SALT:\n            passed_salt = 1;\n            salt = opt_arg();\n            break;\n        case OPT_STDIN:\n            if (pw_source_defined)\n                goto opthelp;\n            in_stdin = 1;\n            pw_source_defined = 1;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* All remaining arguments are the password text */\n    argc = opt_num_rest();\n    argv = opt_rest();\n    if (*argv != NULL) {\n        if (pw_source_defined)\n            goto opthelp;\n        pw_source_defined = 1;\n        passwds = argv;\n    }\n\n    if (!app_RAND_load())\n        goto end;\n\n    if (mode == passwd_unset) {\n        /* use default */\n        mode = passwd_md5;\n    }\n\n    if (infile != NULL && in_stdin) {\n        BIO_printf(bio_err, \"%s: Can't combine -in and -stdin\\n\", prog);\n        goto end;\n    }\n\n    if (infile != NULL || in_stdin) {\n        /*\n         * If in_stdin is true, we know that infile is NULL, and that\n         * bio_open_default() will give us back an alias for stdin.\n         */\n        in = bio_open_default(infile, 'r', FORMAT_TEXT);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (passwds == NULL) {\n        /* no passwords on the command line */\n\n        passwd_malloc_size = pw_maxlen + 2;\n        /* longer than necessary so that we can warn about truncation */\n        passwd = passwd_malloc =\n            app_malloc(passwd_malloc_size, \"password buffer\");\n    }\n\n    if ((in == NULL) && (passwds == NULL)) {\n        /*\n         * we use the following method to make sure what\n         * in the 'else' section is always compiled, to\n         * avoid rot of not-frequently-used code.\n         */\n        if (1) {\n#ifndef OPENSSL_NO_UI_CONSOLE\n            /* build a null-terminated list */\n            static char *passwds_static[2] = { NULL, NULL };\n\n            passwds = passwds_static;\n            if (in == NULL) {\n                if (EVP_read_pw_string\n                    (passwd_malloc, passwd_malloc_size, \"Password: \",\n                     !(passed_salt || in_noverify)) != 0)\n                    goto end;\n            }\n            passwds[0] = passwd_malloc;\n        } else {\n#endif\n            BIO_printf(bio_err, \"password required\\n\");\n            goto end;\n        }\n    }\n\n    if (in == NULL) {\n        assert(passwds != NULL);\n        assert(*passwds != NULL);\n\n        do {                    /* loop over list of passwords */\n            passwd = *passwds++;\n            if (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, bio_out,\n                           quiet, table, reverse, pw_maxlen, mode))\n                goto end;\n        } while (*passwds != NULL);\n    } else {\n        /* in != NULL */\n        int done;\n\n        assert(passwd != NULL);\n        do {\n            int r = BIO_gets(in, passwd, pw_maxlen + 1);\n            if (r > 0) {\n                char *c = (strchr(passwd, '\\n'));\n                if (c != NULL) {\n                    *c = 0;     /* truncate at newline */\n                } else {\n                    /* ignore rest of line */\n                    char trash[BUFSIZ];\n                    do\n                        r = BIO_gets(in, trash, sizeof(trash));\n                    while ((r > 0) && (!strchr(trash, '\\n')));\n                }\n\n                if (!do_passwd\n                    (passed_salt, &salt, &salt_malloc, passwd, bio_out, quiet,\n                     table, reverse, pw_maxlen, mode))\n                    goto end;\n            }\n            done = (r <= 0);\n        } while (!done);\n    }\n    ret = 0;\n\n end:\n#if 0\n    ERR_print_errors(bio_err);\n#endif\n    OPENSSL_free(salt_malloc);\n    OPENSSL_free(passwd_malloc);\n    BIO_free(in);\n    return ret;\n}"
        ],
        "sink": "} while (*passwds != NULL);",
        "final_sink": "} while (*passwds != NULL);",
        "source": [
            "        ectx_params = OSSL_ENCODER_CTX_new_for_pkey("
        ],
        "index": 35
    },
    {
        "prt": "passwd",
        "function_call": [
            "int passwd_main(int argc, char **argv)\n{\n    BIO *in = NULL;\n    char *infile = NULL, *salt = NULL, *passwd = NULL, **passwds = NULL;\n    char *salt_malloc = NULL, *passwd_malloc = NULL, *prog;\n    OPTION_CHOICE o;\n    int in_stdin = 0, pw_source_defined = 0;\n#ifndef OPENSSL_NO_UI_CONSOLE\n    int in_noverify = 0;\n#endif\n    int passed_salt = 0, quiet = 0, table = 0, reverse = 0;\n    int ret = 1;\n    passwd_modes mode = passwd_unset;\n    size_t passwd_malloc_size = 0;\n    size_t pw_maxlen = 256; /* arbitrary limit, should be enough for most\n                             * passwords */\n\n    prog = opt_init(argc, argv, passwd_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(passwd_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            if (pw_source_defined)\n                goto opthelp;\n            infile = opt_arg();\n            pw_source_defined = 1;\n            break;\n        case OPT_NOVERIFY:\n#ifndef OPENSSL_NO_UI_CONSOLE\n            in_noverify = 1;\n#endif\n            break;\n        case OPT_QUIET:\n            quiet = 1;\n            break;\n        case OPT_TABLE:\n            table = 1;\n            break;\n        case OPT_REVERSE:\n            reverse = 1;\n            break;\n        case OPT_1:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_md5;\n            break;\n        case OPT_5:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_sha256;\n            break;\n        case OPT_6:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_sha512;\n            break;\n        case OPT_APR1:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_apr1;\n            break;\n        case OPT_AIXMD5:\n            if (mode != passwd_unset)\n                goto opthelp;\n            mode = passwd_aixmd5;\n            break;\n        case OPT_SALT:\n            passed_salt = 1;\n            salt = opt_arg();\n            break;\n        case OPT_STDIN:\n            if (pw_source_defined)\n                goto opthelp;\n            in_stdin = 1;\n            pw_source_defined = 1;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        }\n    }\n\n    /* All remaining arguments are the password text */\n    argc = opt_num_rest();\n    argv = opt_rest();\n    if (*argv != NULL) {\n        if (pw_source_defined)\n            goto opthelp;\n        pw_source_defined = 1;\n        passwds = argv;\n    }\n\n    if (!app_RAND_load())\n        goto end;\n\n    if (mode == passwd_unset) {\n        /* use default */\n        mode = passwd_md5;\n    }\n\n    if (infile != NULL && in_stdin) {\n        BIO_printf(bio_err, \"%s: Can't combine -in and -stdin\\n\", prog);\n        goto end;\n    }\n\n    if (infile != NULL || in_stdin) {\n        /*\n         * If in_stdin is true, we know that infile is NULL, and that\n         * bio_open_default() will give us back an alias for stdin.\n         */\n        in = bio_open_default(infile, 'r', FORMAT_TEXT);\n        if (in == NULL)\n            goto end;\n    }\n\n    if (passwds == NULL) {\n        /* no passwords on the command line */\n\n        passwd_malloc_size = pw_maxlen + 2;\n        /* longer than necessary so that we can warn about truncation */\n        passwd = passwd_malloc =\n            app_malloc(passwd_malloc_size, \"password buffer\");\n    }\n\n    if ((in == NULL) && (passwds == NULL)) {\n        /*\n         * we use the following method to make sure what\n         * in the 'else' section is always compiled, to\n         * avoid rot of not-frequently-used code.\n         */\n        if (1) {\n#ifndef OPENSSL_NO_UI_CONSOLE\n            /* build a null-terminated list */\n            static char *passwds_static[2] = { NULL, NULL };\n\n            passwds = passwds_static;\n            if (in == NULL) {\n                if (EVP_read_pw_string\n                    (passwd_malloc, passwd_malloc_size, \"Password: \",\n                     !(passed_salt || in_noverify)) != 0)\n                    goto end;\n            }\n            passwds[0] = passwd_malloc;\n        } else {\n#endif\n            BIO_printf(bio_err, \"password required\\n\");\n            goto end;\n        }\n    }\n\n    if (in == NULL) {\n        assert(passwds != NULL);\n        assert(*passwds != NULL);\n\n        do {                    /* loop over list of passwords */\n            passwd = *passwds++;\n            if (!do_passwd(passed_salt, &salt, &salt_malloc, passwd, bio_out,\n                           quiet, table, reverse, pw_maxlen, mode))\n                goto end;\n        } while (*passwds != NULL);\n    } else {\n        /* in != NULL */\n        int done;\n\n        assert(passwd != NULL);\n        do {\n            int r = BIO_gets(in, passwd, pw_maxlen + 1);\n            if (r > 0) {\n                char *c = (strchr(passwd, '\\n'));\n                if (c != NULL) {\n                    *c = 0;     /* truncate at newline */\n                } else {\n                    /* ignore rest of line */\n                    char trash[BUFSIZ];\n                    do\n                        r = BIO_gets(in, trash, sizeof(trash));\n                    while ((r > 0) && (!strchr(trash, '\\n')));\n                }\n\n                if (!do_passwd\n                    (passed_salt, &salt, &salt_malloc, passwd, bio_out, quiet,\n                     table, reverse, pw_maxlen, mode))\n                    goto end;\n            }\n            done = (r <= 0);\n        } while (!done);\n    }\n    ret = 0;\n\n end:\n#if 0\n    ERR_print_errors(bio_err);\n#endif\n    OPENSSL_free(salt_malloc);\n    OPENSSL_free(passwd_malloc);\n    BIO_free(in);\n    return ret;\n}"
        ],
        "sink": "(passed_salt, &salt, &salt_malloc, passwd, bio_out, quiet,",
        "final_sink": "(passed_salt, &salt, &salt_malloc, passwd, bio_out, quiet,",
        "source": [
            "        gctx_key = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(), params_key,"
        ],
        "index": 36
    },
    {
        "prt": "mctx",
        "function_call": [
            "int pkeyutl_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    BIO *in = NULL, *out = NULL, *secout = NULL;\n    ENGINE *e = NULL;\n    EVP_PKEY_CTX *ctx = NULL;\n    EVP_PKEY *pkey = NULL;\n    char *infile = NULL, *outfile = NULL, *secoutfile = NULL, *sigfile = NULL, *passinarg = NULL;\n    char hexdump = 0, asn1parse = 0, rev = 0, *prog;\n    unsigned char *buf_in = NULL, *buf_out = NULL, *sig = NULL, *secret = NULL;\n    OPTION_CHOICE o;\n    int buf_inlen = 0, siglen = -1;\n    int keyform = FORMAT_UNDEF, peerform = FORMAT_UNDEF;\n    int keysize = -1, pkey_op = EVP_PKEY_OP_SIGN, key_type = KEY_PRIVKEY;\n    int engine_impl = 0;\n    int ret = 1, rv = -1;\n    size_t buf_outlen = 0, secretlen = 0;\n    const char *inkey = NULL;\n    const char *peerkey = NULL;\n    const char *kdfalg = NULL, *digestname = NULL, *kemop = NULL;\n    int kdflen = 0;\n    STACK_OF(OPENSSL_STRING) *pkeyopts = NULL;\n    STACK_OF(OPENSSL_STRING) *pkeyopts_passin = NULL;\n    int rawin = 0;\n    EVP_MD_CTX *mctx = NULL;\n    EVP_MD *md = NULL;\n    int filesize = -1;\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    prog = opt_init(argc, argv, pkeyutl_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(pkeyutl_options);\n            ret = 0;\n            goto end;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_SECOUT:\n            secoutfile = opt_arg();\n            break;\n        case OPT_SIGFILE:\n            sigfile = opt_arg();\n            break;\n        case OPT_ENGINE_IMPL:\n            engine_impl = 1;\n            break;\n        case OPT_INKEY:\n            inkey = opt_arg();\n            break;\n        case OPT_PEERKEY:\n            peerkey = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_PEERFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &peerform))\n                goto opthelp;\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PUBIN:\n            key_type = KEY_PUBKEY;\n            break;\n        case OPT_CERTIN:\n            key_type = KEY_CERT;\n            break;\n        case OPT_ASN1PARSE:\n            asn1parse = 1;\n            break;\n        case OPT_HEXDUMP:\n            hexdump = 1;\n            break;\n        case OPT_SIGN:\n            pkey_op = EVP_PKEY_OP_SIGN;\n            break;\n        case OPT_VERIFY:\n            pkey_op = EVP_PKEY_OP_VERIFY;\n            break;\n        case OPT_VERIFYRECOVER:\n            pkey_op = EVP_PKEY_OP_VERIFYRECOVER;\n            break;\n        case OPT_ENCRYPT:\n            pkey_op = EVP_PKEY_OP_ENCRYPT;\n            break;\n        case OPT_DECRYPT:\n            pkey_op = EVP_PKEY_OP_DECRYPT;\n            break;\n        case OPT_DERIVE:\n            pkey_op = EVP_PKEY_OP_DERIVE;\n            break;\n        case OPT_DECAP:\n            pkey_op = EVP_PKEY_OP_DECAPSULATE;\n            break;\n        case OPT_ENCAP:\n            pkey_op = EVP_PKEY_OP_ENCAPSULATE;\n            break;\n        case OPT_KEMOP:\n            kemop = opt_arg();\n            break;\n        case OPT_KDF:\n            pkey_op = EVP_PKEY_OP_DERIVE;\n            key_type = KEY_NONE;\n            kdfalg = opt_arg();\n            break;\n        case OPT_KDFLEN:\n            kdflen = atoi(opt_arg());\n            break;\n        case OPT_REV:\n            rev = 1;\n            break;\n        case OPT_PKEYOPT:\n            if ((pkeyopts == NULL &&\n                 (pkeyopts = sk_OPENSSL_STRING_new_null()) == NULL) ||\n                sk_OPENSSL_STRING_push(pkeyopts, opt_arg()) == 0) {\n                BIO_puts(bio_err, \"out of memory\\n\");\n                goto end;\n            }\n            break;\n        case OPT_PKEYOPT_PASSIN:\n            if ((pkeyopts_passin == NULL &&\n                 (pkeyopts_passin = sk_OPENSSL_STRING_new_null()) == NULL) ||\n                sk_OPENSSL_STRING_push(pkeyopts_passin, opt_arg()) == 0) {\n                BIO_puts(bio_err, \"out of memory\\n\");\n                goto end;\n            }\n            break;\n        case OPT_RAWIN:\n            rawin = 1;\n            break;\n        case OPT_DIGEST:\n            digestname = opt_arg();\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL)\n        rawin = 1;\n\n    if (kdfalg != NULL) {\n        if (kdflen == 0) {\n            BIO_printf(bio_err,\n                       \"%s: no KDF length given (-kdflen parameter).\\n\", prog);\n            goto opthelp;\n        }\n    } else if (inkey == NULL) {\n        BIO_printf(bio_err,\n                   \"%s: no private key given (-inkey parameter).\\n\", prog);\n        goto opthelp;\n    } else if (peerkey != NULL && pkey_op != EVP_PKEY_OP_DERIVE) {\n        BIO_printf(bio_err,\n                   \"%s: no peer key given (-peerkey parameter).\\n\", prog);\n        goto opthelp;\n    }\n\n    pkey = get_pkey(kdfalg, inkey, keyform, key_type, passinarg, pkey_op, e);\n\n    if (pkey_op == EVP_PKEY_OP_VERIFYRECOVER && !EVP_PKEY_is_a(pkey, \"RSA\")) {\n        BIO_printf(bio_err, \"%s: -verifyrecover can be used only with RSA\\n\", prog);\n        goto end;\n    }\n\n    if (pkey_op == EVP_PKEY_OP_SIGN || pkey_op == EVP_PKEY_OP_VERIFY) {\n        if (only_rawin(pkey)) {\n            if (is_EdDSA(pkey) && digestname != NULL) {\n                BIO_printf(bio_err,\n                           \"%s: -digest (prehash) is not supported with EdDSA\\n\", prog);\n                EVP_PKEY_free(pkey);\n                goto end;\n            }\n            rawin = 1; /* implied for Ed25519(ph) and Ed448(ph) and maybe others in the future */\n        }\n    } else if (digestname != NULL || rawin) {\n        BIO_printf(bio_err,\n                   \"%s: -digest and -rawin can only be used with -sign or -verify\\n\", prog);\n        EVP_PKEY_free(pkey);\n        goto opthelp;\n    }\n\n    if (rawin && rev) {\n        BIO_printf(bio_err, \"%s: -rev cannot be used with raw input\\n\", prog);\n        EVP_PKEY_free(pkey);\n        goto opthelp;\n    }\n\n    if (rawin) {\n        if ((mctx = EVP_MD_CTX_new()) == NULL) {\n            BIO_printf(bio_err, \"Error: out of memory\\n\");\n            EVP_PKEY_free(pkey);\n            goto end;\n        }\n    }\n    ctx = init_ctx(kdfalg, &keysize, pkey_op, e, engine_impl, rawin, pkey,\n                   mctx, digestname, kemop, libctx, app_get0_propq());\n    if (ctx == NULL) {\n        BIO_printf(bio_err, \"%s: Error initializing context\\n\", prog);\n        goto end;\n    }\n    if (peerkey != NULL && !setup_peer(ctx, peerform, peerkey, e)) {\n        BIO_printf(bio_err, \"%s: Error setting up peer key\\n\", prog);\n        goto end;\n    }\n    if (pkeyopts != NULL) {\n        int num = sk_OPENSSL_STRING_num(pkeyopts);\n        int i;\n\n        for (i = 0; i < num; ++i) {\n            const char *opt = sk_OPENSSL_STRING_value(pkeyopts, i);\n\n            if (pkey_ctrl_string(ctx, opt) <= 0) {\n                BIO_printf(bio_err, \"%s: Can't set parameter \\\"%s\\\":\\n\",\n                           prog, opt);\n                goto end;\n            }\n        }\n    }\n    if (pkeyopts_passin != NULL) {\n        int num = sk_OPENSSL_STRING_num(pkeyopts_passin);\n        int i;\n\n        for (i = 0; i < num; i++) {\n            char *opt = sk_OPENSSL_STRING_value(pkeyopts_passin, i);\n            char *passin = strchr(opt, ':');\n            char *passwd;\n\n            if (passin == NULL) {\n                /* Get password interactively */\n                char passwd_buf[4096];\n                int r;\n\n                BIO_snprintf(passwd_buf, sizeof(passwd_buf), \"Enter %s: \", opt);\n                r = EVP_read_pw_string(passwd_buf, sizeof(passwd_buf) - 1,\n                                       passwd_buf, 0);\n                if (r < 0) {\n                    if (r == -2)\n                        BIO_puts(bio_err, \"user abort\\n\");\n                    else\n                        BIO_puts(bio_err, \"entry failed\\n\");\n                    goto end;\n                }\n                passwd = OPENSSL_strdup(passwd_buf);\n                if (passwd == NULL) {\n                    BIO_puts(bio_err, \"out of memory\\n\");\n                    goto end;\n                }\n            } else {\n                /*\n                 * Get password as a passin argument: First split option name\n                 * and passphrase argument into two strings\n                 */\n                *passin = 0;\n                passin++;\n                if (app_passwd(passin, NULL, &passwd, NULL) == 0) {\n                    BIO_printf(bio_err, \"failed to get '%s'\\n\", opt);\n                    goto end;\n                }\n            }\n\n            if (EVP_PKEY_CTX_ctrl_str(ctx, opt, passwd) <= 0) {\n                BIO_printf(bio_err, \"%s: Can't set parameter \\\"%s\\\":\\n\",\n                           prog, opt);\n                goto end;\n            }\n            OPENSSL_free(passwd);\n        }\n    }\n\n    if (sigfile != NULL && (pkey_op != EVP_PKEY_OP_VERIFY)) {\n        BIO_printf(bio_err,\n                   \"%s: Signature file specified for non verify\\n\", prog);\n        goto end;\n    }\n\n    if (sigfile == NULL && (pkey_op == EVP_PKEY_OP_VERIFY)) {\n        BIO_printf(bio_err,\n                   \"%s: No signature file specified for verify\\n\", prog);\n        goto end;\n    }\n\n    if (pkey_op != EVP_PKEY_OP_DERIVE && pkey_op != EVP_PKEY_OP_ENCAPSULATE) {\n        in = bio_open_default(infile, 'r', FORMAT_BINARY);\n        if (infile != NULL) {\n            struct stat st;\n\n            if (stat(infile, &st) == 0 && st.st_size <= INT_MAX)\n                filesize = (int)st.st_size;\n        }\n        if (in == NULL)\n            goto end;\n    }\n    out = bio_open_default(outfile, 'w', FORMAT_BINARY);\n    if (out == NULL)\n        goto end;\n\n    if (pkey_op == EVP_PKEY_OP_ENCAPSULATE) {\n        if (secoutfile == NULL) {\n            BIO_printf(bio_err, \"Encapsulation requires '-secret' argument\\n\");\n            goto end;\n        }\n        secout = bio_open_default(secoutfile, 'w', FORMAT_BINARY);\n        if (secout == NULL)\n            goto end;\n    }\n\n    if (sigfile != NULL) {\n        BIO *sigbio = BIO_new_file(sigfile, \"rb\");\n\n        if (sigbio == NULL) {\n            BIO_printf(bio_err, \"Can't open signature file %s\\n\", sigfile);\n            goto end;\n        }\n        siglen = bio_to_mem(&sig, keysize * 10, sigbio);\n        BIO_free(sigbio);\n        if (siglen < 0) {\n            BIO_printf(bio_err, \"Error reading signature data\\n\");\n            goto end;\n        }\n    }\n\n    /* Raw input data is handled elsewhere */\n    if (in != NULL && !rawin) {\n        /* Read the input data */\n        buf_inlen = bio_to_mem(&buf_in, -1, in);\n        if (buf_inlen < 0) {\n            BIO_printf(bio_err, \"Error reading input Data\\n\");\n            goto end;\n        }\n        if (rev) {\n            size_t i;\n            unsigned char ctmp;\n            size_t l = (size_t)buf_inlen;\n\n            for (i = 0; i < l / 2; i++) {\n                ctmp = buf_in[i];\n                buf_in[i] = buf_in[l - 1 - i];\n                buf_in[l - 1 - i] = ctmp;\n            }\n        }\n    }\n\n    /* Sanity check the input if the input is not raw */\n    if (!rawin\n        && (pkey_op == EVP_PKEY_OP_SIGN || pkey_op == EVP_PKEY_OP_VERIFY)) {\n        if (buf_inlen > EVP_MAX_MD_SIZE) {\n            BIO_printf(bio_err,\n                       \"Error: The non-raw input data length %d is too long - max supported hashed size is %d\\n\",\n                       buf_inlen, EVP_MAX_MD_SIZE);\n            goto end;\n        }\n    }\n\n    if (pkey_op == EVP_PKEY_OP_VERIFY) {\n        if (rawin) {\n            rv = do_raw_keyop(pkey_op, mctx, pkey, in, filesize, sig, siglen,\n                              NULL, 0);\n        } else {\n            rv = EVP_PKEY_verify(ctx, sig, (size_t)siglen,\n                                 buf_in, (size_t)buf_inlen);\n        }\n        if (rv == 1) {\n            BIO_puts(out, \"Signature Verified Successfully\\n\");\n            ret = 0;\n        } else {\n            BIO_puts(out, \"Signature Verification Failure\\n\");\n        }\n        goto end;\n    }\n    if (rawin) {\n        /* rawin allocates the buffer in do_raw_keyop() */\n        rv = do_raw_keyop(pkey_op, mctx, pkey, in, filesize, NULL, 0,\n                          &buf_out, (size_t *)&buf_outlen);\n    } else {\n        if (kdflen != 0) {\n            buf_outlen = kdflen;\n            rv = 1;\n        } else {\n            rv = do_keyop(ctx, pkey_op, NULL, (size_t *)&buf_outlen,\n                          buf_in, (size_t)buf_inlen, NULL, (size_t *)&secretlen);\n        }\n        if (rv > 0 && buf_outlen != 0) {\n            buf_out = app_malloc(buf_outlen, \"buffer output\");\n            if (secretlen > 0)\n                secret = app_malloc(secretlen, \"secret output\");\n            rv = do_keyop(ctx, pkey_op,\n                          buf_out, (size_t *)&buf_outlen,\n                          buf_in, (size_t)buf_inlen, secret, (size_t *)&secretlen);\n        }\n    }\n    if (rv <= 0) {\n        if (pkey_op != EVP_PKEY_OP_DERIVE) {\n            BIO_puts(bio_err, \"Public Key operation error\\n\");\n        } else {\n            BIO_puts(bio_err, \"Key derivation failed\\n\");\n        }\n        goto end;\n    }\n    ret = 0;\n\n    if (asn1parse) {\n        if (!ASN1_parse_dump(out, buf_out, buf_outlen, 1, -1))\n            ERR_print_errors(bio_err); /* but still return success */\n    } else if (hexdump) {\n        BIO_dump(out, (char *)buf_out, buf_outlen);\n    } else {\n        BIO_write(out, buf_out, buf_outlen);\n    }\n    if (secretlen > 0)\n        BIO_write(secout, secret, secretlen);\n\n end:\n    if (ret != 0)\n        ERR_print_errors(bio_err);\n    EVP_MD_CTX_free(mctx);\n    EVP_PKEY_CTX_free(ctx);\n    EVP_MD_free(md);\n    release_engine(e);\n    BIO_free(in);\n    BIO_free_all(out);\n    BIO_free_all(secout);\n    OPENSSL_free(buf_in);\n    OPENSSL_free(buf_out);\n    OPENSSL_free(sig);\n    OPENSSL_free(secret);\n    sk_OPENSSL_STRING_free(pkeyopts);\n    sk_OPENSSL_STRING_free(pkeyopts_passin);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "mctx, digestname, kemop, libctx, app_get0_propq());",
        "final_sink": "mctx, digestname, kemop, libctx, app_get0_propq());",
        "source": [
            "        ectx_key = OSSL_ENCODER_CTX_new_for_pkey("
        ],
        "index": 37
    },
    {
        "prt": "pkey",
        "function_call": [
            "int req_main(int argc, char **argv)\n{\n    ASN1_INTEGER *serial = NULL;\n    BIO *out = NULL;\n    ENGINE *e = NULL, *gen_eng = NULL;\n    EVP_PKEY *pkey = NULL, *CAkey = NULL;\n    EVP_PKEY_CTX *genctx = NULL;\n    STACK_OF(OPENSSL_STRING) *pkeyopts = NULL, *sigopts = NULL, *vfyopts = NULL;\n    LHASH_OF(OPENSSL_STRING) *addexts = NULL;\n    X509 *new_x509 = NULL, *CAcert = NULL;\n    X509_REQ *req = NULL;\n    const EVP_CIPHER *cipher = NULL;\n    int ext_copy = EXT_COPY_UNSET;\n    BIO *addext_bio = NULL;\n    char *extsect = NULL;\n    const char *infile = NULL, *CAfile = NULL, *CAkeyfile = NULL;\n    char *outfile = NULL, *keyfile = NULL, *digest = NULL;\n    char *keyalgstr = NULL, *p, *prog, *passargin = NULL, *passargout = NULL;\n    char *passin = NULL, *passout = NULL;\n    char *nofree_passin = NULL, *nofree_passout = NULL;\n    char *subj = NULL;\n    X509_NAME *fsubj = NULL;\n    char *template = default_config_file, *keyout = NULL;\n    const char *keyalg = NULL;\n    OPTION_CHOICE o;\n    char *not_before = NULL, *not_after = NULL;\n    int days = UNSET_DAYS;\n    int ret = 1, gen_x509 = 0, i = 0, newreq = 0, verbose = 0, progress = 1;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, keyform = FORMAT_UNDEF;\n    int modulus = 0, multirdn = 1, verify = 0, noout = 0, text = 0;\n    int noenc = 0, newhdr = 0, subject = 0, pubkey = 0, precert = 0, x509v1 = 0;\n    long newkey_len = -1;\n    unsigned long chtype = MBSTRING_ASC, reqflag = 0;\n\n    cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n\n    opt_set_unknown_name(\"digest\");\n    prog = opt_init(argc, argv, req_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(req_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_KEYGEN_ENGINE:\n#ifndef OPENSSL_NO_ENGINE\n            gen_eng = setup_engine(opt_arg(), 0);\n            if (gen_eng == NULL) {\n                BIO_printf(bio_err, \"Can't find keygen engine %s\\n\", *argv);\n                goto opthelp;\n            }\n#endif\n            break;\n        case OPT_KEY:\n            keyfile = opt_arg();\n            break;\n        case OPT_PUBKEY:\n            pubkey = 1;\n            break;\n        case OPT_NEW:\n            newreq = 1;\n            break;\n        case OPT_CONFIG:\n            template = opt_arg();\n            break;\n        case OPT_SECTION:\n            section = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_KEYOUT:\n            keyout = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passargin = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passargout = opt_arg();\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_NEWKEY:\n            keyalg = opt_arg();\n            newreq = 1;\n            break;\n        case OPT_PKEYOPT:\n            if (pkeyopts == NULL)\n                pkeyopts = sk_OPENSSL_STRING_new_null();\n            if (pkeyopts == NULL\n                    || !sk_OPENSSL_STRING_push(pkeyopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SIGOPT:\n            if (!sigopts)\n                sigopts = sk_OPENSSL_STRING_new_null();\n            if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_VFYOPT:\n            if (!vfyopts)\n                vfyopts = sk_OPENSSL_STRING_new_null();\n            if (!vfyopts || !sk_OPENSSL_STRING_push(vfyopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_BATCH:\n            batch = 1;\n            break;\n        case OPT_NEWHDR:\n            newhdr = 1;\n            break;\n        case OPT_MODULUS:\n            modulus = 1;\n            break;\n        case OPT_VERIFY:\n            verify = 1;\n            break;\n        case OPT_NODES:\n        case OPT_NOENC:\n            noenc = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_VERBOSE:\n            verbose = 1;\n            progress = 1;\n            break;\n        case OPT_QUIET:\n            verbose = 0;\n            progress = 0;\n            break;\n        case OPT_UTF8:\n            chtype = MBSTRING_UTF8;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_REQOPT:\n            if (!set_cert_ex(&reqflag, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_X509V1:\n            x509v1 = 1;\n            /* fall thru */\n        case OPT_X509:\n            gen_x509 = 1;\n            break;\n        case OPT_CA:\n            CAfile = opt_arg();\n            gen_x509 = 1;\n            break;\n        case OPT_CAKEY:\n            CAkeyfile = opt_arg();\n            break;\n        case OPT_NOT_BEFORE:\n            not_before = opt_arg();\n            break;\n        case OPT_NOT_AFTER:\n            not_after = opt_arg();\n            break;\n        case OPT_DAYS:\n            days = atoi(opt_arg());\n            if (days <= UNSET_DAYS) {\n                BIO_printf(bio_err, \"%s: -days parameter arg must be >= -1\\n\",\n                           prog);\n                goto end;\n            }\n            break;\n        case OPT_SET_SERIAL:\n            if (serial != NULL) {\n                BIO_printf(bio_err, \"Serial number supplied twice\\n\");\n                goto opthelp;\n            }\n            serial = s2i_ASN1_INTEGER(NULL, opt_arg());\n            if (serial == NULL)\n                goto opthelp;\n            break;\n        case OPT_SUBJECT:\n            subject = 1;\n            break;\n        case OPT_SUBJ:\n            subj = opt_arg();\n            break;\n        case OPT_MULTIVALUE_RDN:\n            /* obsolete */\n            break;\n        case OPT_COPY_EXTENSIONS:\n            if (!set_ext_copy(&ext_copy, opt_arg())) {\n                BIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\",\n                           opt_arg());\n                goto end;\n            }\n            break;\n        case OPT_EXTENSIONS:\n        case OPT_REQEXTS:\n            extsect = opt_arg();\n            break;\n        case OPT_ADDEXT:\n            p = opt_arg();\n            if (addexts == NULL) {\n                addexts = lh_OPENSSL_STRING_new(ext_name_hash, ext_name_cmp);\n                addext_bio = BIO_new(BIO_s_mem());\n                if (addexts == NULL || addext_bio == NULL)\n                    goto end;\n            }\n            i = duplicated(addexts, p);\n            if (i == 1)\n                goto end;\n            if (i == -1)\n                BIO_printf(bio_err, \"Internal error handling -addext %s\\n\", p);\n            if (i < 0 || BIO_printf(addext_bio, \"%s\\n\", p) < 0)\n                goto end;\n            break;\n        case OPT_PRECERT:\n            newreq = precert = 1;\n            break;\n        case OPT_CIPHER:\n            cipher = EVP_get_cipherbyname(opt_arg());\n            if (cipher == NULL) {\n                BIO_printf(bio_err, \"Unknown cipher: %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_MD:\n            digest = opt_unknown();\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n    if (!gen_x509) {\n        if (days != UNSET_DAYS)\n            BIO_printf(bio_err, \"Warning: Ignoring -days without -x509; not generating a certificate\\n\");\n        if (not_before != NULL)\n            BIO_printf(bio_err, \"Warning: Ignoring -not_before without -x509; not generating a certificate\\n\");\n        if (not_after != NULL)\n            BIO_printf(bio_err, \"Warning: Ignoring -not_after without -x509; not generating a certificate\\n\");\n        if (ext_copy == EXT_COPY_NONE)\n            BIO_printf(bio_err, \"Warning: Ignoring -copy_extensions 'none' when -x509 is not given\\n\");\n    }\n    if (infile == NULL) {\n        if (gen_x509)\n            newreq = 1;\n        else if (!newreq && isatty(fileno_stdin()))\n            BIO_printf(bio_err,\n                       \"Warning: Will read cert request from stdin since no -in option is given\\n\");\n    }\n\n    if (!app_passwd(passargin, passargout, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n\n    if ((req_conf = app_load_config_verbose(template, verbose)) == NULL)\n        goto end;\n    if (addext_bio != NULL) {\n        if (verbose)\n            BIO_printf(bio_err,\n                       \"Using additional configuration from -addext options\\n\");\n        if ((addext_conf = app_load_config_bio(addext_bio, NULL)) == NULL)\n            goto end;\n    }\n    if (template != default_config_file && !app_load_modules(req_conf))\n        goto end;\n\n    if (req_conf != NULL) {\n        p = app_conf_try_string(req_conf, NULL, \"oid_file\");\n        if (p != NULL) {\n            BIO *oid_bio = BIO_new_file(p, \"r\");\n\n            if (oid_bio == NULL) {\n                if (verbose)\n                    BIO_printf(bio_err,\n                               \"Problems opening '%s' for extra OIDs\\n\", p);\n            } else {\n                OBJ_create_objects(oid_bio);\n                BIO_free(oid_bio);\n            }\n        }\n    }\n    if (!add_oid_section(req_conf))\n        goto end;\n\n    /* Check that any specified digest is fetchable */\n    if (digest != NULL) {\n        if (!opt_check_md(digest))\n            goto opthelp;\n    } else {\n        /* No digest specified, default to configuration */\n        p = app_conf_try_string(req_conf, section, \"default_md\");\n        if (p != NULL)\n            digest = p;\n    }\n\n    if (extsect == NULL)\n        extsect = app_conf_try_string(req_conf, section,\n                                   gen_x509 ? V3_EXTENSIONS : REQ_EXTENSIONS);\n    if (extsect != NULL) {\n        /* Check syntax of extension section in config file */\n        X509V3_CTX ctx;\n\n        X509V3_set_ctx_test(&ctx);\n        X509V3_set_nconf(&ctx, req_conf);\n        if (!X509V3_EXT_add_nconf(req_conf, &ctx, extsect, NULL)) {\n            BIO_printf(bio_err,\n                       \"Error checking %s extension section %s\\n\",\n                       gen_x509 ? \"x509\" : \"request\", extsect);\n            goto end;\n        }\n    }\n    if (addext_conf != NULL) {\n        /* Check syntax of command line extensions */\n        X509V3_CTX ctx;\n\n        X509V3_set_ctx_test(&ctx);\n        X509V3_set_nconf(&ctx, req_conf);\n        if (!X509V3_EXT_add_nconf(addext_conf, &ctx, \"default\", NULL)) {\n            BIO_printf(bio_err, \"Error checking extensions defined using -addext\\n\");\n            goto end;\n        }\n    }\n\n    if (passin == NULL)\n        passin = nofree_passin =\n            app_conf_try_string(req_conf, section, \"input_password\");\n\n    if (passout == NULL)\n        passout = nofree_passout =\n            app_conf_try_string(req_conf, section, \"output_password\");\n\n    p = app_conf_try_string(req_conf, section, STRING_MASK);\n    if (p != NULL && !ASN1_STRING_set_default_mask_asc(p)) {\n        BIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", p);\n        goto end;\n    }\n\n    if (chtype != MBSTRING_UTF8) {\n        p = app_conf_try_string(req_conf, section, UTF8_IN);\n        if (p != NULL && strcmp(p, \"yes\") == 0)\n            chtype = MBSTRING_UTF8;\n    }\n\n    if (keyfile != NULL) {\n        pkey = load_key(keyfile, keyform, 0, passin, e, \"private key\");\n        if (pkey == NULL)\n            goto end;\n        app_RAND_load_conf(req_conf, section);\n    }\n    if (keyalg != NULL && pkey != NULL) {\n        BIO_printf(bio_err,\n                   \"Warning: Not generating key via given -newkey option since -key is given\\n\");\n        /* Better throw an error in this case */\n    }\n    if (newreq && pkey == NULL) {\n        app_RAND_load_conf(req_conf, section);\n\n        if (!app_conf_try_number(req_conf, section, BITS, &newkey_len))\n            newkey_len = DEFAULT_KEY_LENGTH;\n\n        genctx = set_keygen_ctx(keyalg, &keyalgstr, &newkey_len, gen_eng);\n        if (genctx == NULL)\n            goto end;\n\n        if (newkey_len < MIN_KEY_LENGTH\n            && (EVP_PKEY_CTX_is_a(genctx, \"RSA\")\n                || EVP_PKEY_CTX_is_a(genctx, \"RSA-PSS\")\n                || EVP_PKEY_CTX_is_a(genctx, \"DSA\"))) {\n            BIO_printf(bio_err, \"Private key length too short, needs to be at least %d bits, not %ld.\\n\",\n                       MIN_KEY_LENGTH, newkey_len);\n            goto end;\n        }\n\n        if (newkey_len > OPENSSL_RSA_MAX_MODULUS_BITS\n            && (EVP_PKEY_CTX_is_a(genctx, \"RSA\")\n                || EVP_PKEY_CTX_is_a(genctx, \"RSA-PSS\")))\n            BIO_printf(bio_err,\n                       \"Warning: It is not recommended to use more than %d bit for RSA keys.\\n\"\n                       \"         Your key size is %ld! Larger key size may behave not as expected.\\n\",\n                       OPENSSL_RSA_MAX_MODULUS_BITS, newkey_len);\n\n#ifndef OPENSSL_NO_DSA\n        if (EVP_PKEY_CTX_is_a(genctx, \"DSA\")\n                && newkey_len > OPENSSL_DSA_MAX_MODULUS_BITS)\n            BIO_printf(bio_err,\n                       \"Warning: It is not recommended to use more than %d bit for DSA keys.\\n\"\n                       \"         Your key size is %ld! Larger key size may behave not as expected.\\n\",\n                       OPENSSL_DSA_MAX_MODULUS_BITS, newkey_len);\n#endif\n\n        if (pkeyopts != NULL) {\n            char *genopt;\n            for (i = 0; i < sk_OPENSSL_STRING_num(pkeyopts); i++) {\n                genopt = sk_OPENSSL_STRING_value(pkeyopts, i);\n                if (pkey_ctrl_string(genctx, genopt) <= 0) {\n                    BIO_printf(bio_err, \"Key parameter error \\\"%s\\\"\\n\", genopt);\n                    goto end;\n                }\n            }\n        }\n\n        EVP_PKEY_CTX_set_app_data(genctx, bio_err);\n        if (progress)\n            EVP_PKEY_CTX_set_cb(genctx, progress_cb);\n\n        pkey = app_keygen(genctx, keyalgstr, newkey_len, verbose);\n        if (pkey == NULL)\n            goto end;\n\n        EVP_PKEY_CTX_free(genctx);\n        genctx = NULL;\n    }\n    if (keyout == NULL && keyfile == NULL)\n        keyout = app_conf_try_string(req_conf, section, KEYFILE);\n\n    if (pkey != NULL && (keyfile == NULL || keyout != NULL)) {\n        if (verbose) {\n            BIO_printf(bio_err, \"Writing private key to \");\n            if (keyout == NULL)\n                BIO_printf(bio_err, \"stdout\\n\");\n            else\n                BIO_printf(bio_err, \"'%s'\\n\", keyout);\n        }\n        out = bio_open_owner(keyout, outformat, newreq);\n        if (out == NULL)\n            goto end;\n\n        p = app_conf_try_string(req_conf, section, \"encrypt_rsa_key\");\n        if (p == NULL)\n            p = app_conf_try_string(req_conf, section, \"encrypt_key\");\n        if (p != NULL && strcmp(p, \"no\") == 0)\n            cipher = NULL;\n        if (noenc)\n            cipher = NULL;\n\n        i = 0;\n loop:\n        if (!PEM_write_bio_PrivateKey(out, pkey, cipher,\n                                      NULL, 0, NULL, passout)) {\n            if ((ERR_GET_REASON(ERR_peek_error()) ==\n                 PEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3)) {\n                ERR_clear_error();\n                i++;\n                goto loop;\n            }\n            goto end;\n        }\n        BIO_free_all(out);\n        out = NULL;\n        BIO_printf(bio_err, \"-----\\n\");\n    }\n\n    /*\n     * subj is expected to be in the format /type0=value0/type1=value1/type2=...\n     * where characters may be escaped by \\\n     */\n    if (subj != NULL\n            && (fsubj = parse_name(subj, chtype, multirdn, \"subject\")) == NULL)\n        goto end;\n\n    if (!newreq) {\n        if (keyfile != NULL)\n            BIO_printf(bio_err,\n                       \"Warning: Not placing -key in cert or request since request is used\\n\");\n        req = load_csr_autofmt(infile /* if NULL, reads from stdin */,\n                               informat, vfyopts, \"X509 request\");\n        if (req == NULL)\n            goto end;\n    } else if (infile != NULL) {\n        BIO_printf(bio_err,\n                   \"Warning: Ignoring -in option since -new or -newkey or -precert is given\\n\");\n        /* Better throw an error in this case, as done in the x509 app */\n    }\n\n    if (CAkeyfile == NULL)\n        CAkeyfile = CAfile;\n    if (CAkeyfile != NULL) {\n        if (CAfile == NULL) {\n            BIO_printf(bio_err,\n                       \"Warning: Ignoring -CAkey option since no -CA option is given\\n\");\n        } else {\n            if ((CAkey = load_key(CAkeyfile, FORMAT_UNDEF,\n                                  0, passin, e,\n                                  CAkeyfile != CAfile\n                                  ? \"issuer private key from -CAkey arg\"\n                                  : \"issuer private key from -CA arg\")) == NULL)\n                goto end;\n        }\n    }\n    if (CAfile != NULL) {\n        if ((CAcert = load_cert_pass(CAfile, FORMAT_UNDEF, 1, passin,\n                                     \"issuer cert from -CA arg\")) == NULL)\n            goto end;\n        if (!X509_check_private_key(CAcert, CAkey)) {\n            BIO_printf(bio_err,\n                       \"Issuer CA certificate and key do not match\\n\");\n            goto end;\n        }\n    }\n    if (newreq || gen_x509) {\n        if (CAcert == NULL && pkey == NULL) {\n            BIO_printf(bio_err, \"Must provide a signature key using -key or\"\n                \" provide -CA / -CAkey\\n\");\n            goto end;\n        }\n\n        if (req == NULL) {\n            req = X509_REQ_new_ex(app_get0_libctx(), app_get0_propq());\n            if (req == NULL) {\n                goto end;\n            }\n\n            if (!make_REQ(req, pkey, fsubj, multirdn, !gen_x509, chtype)) {\n                BIO_printf(bio_err, \"Error making certificate request\\n\");\n                goto end;\n            }\n            /* Note that -x509 can take over -key and -subj option values. */\n        }\n        if (gen_x509) {\n            EVP_PKEY *pub_key = X509_REQ_get0_pubkey(req);\n            EVP_PKEY *issuer_key = CAcert != NULL ? CAkey : pkey;\n            X509V3_CTX ext_ctx;\n            X509_NAME *issuer = CAcert != NULL ? X509_get_subject_name(CAcert) :\n                X509_REQ_get_subject_name(req);\n            X509_NAME *n_subj = fsubj != NULL ? fsubj :\n                X509_REQ_get_subject_name(req);\n\n            if (CAcert != NULL && keyfile != NULL)\n                BIO_printf(bio_err,\n                           \"Warning: Not using -key or -newkey for signing since -CA option is given\\n\");\n\n            if ((new_x509 = X509_new_ex(app_get0_libctx(),\n                                        app_get0_propq())) == NULL)\n                goto end;\n\n            if (serial != NULL) {\n                if (!X509_set_serialNumber(new_x509, serial))\n                    goto end;\n            } else {\n                if (!rand_serial(NULL, X509_get_serialNumber(new_x509)))\n                    goto end;\n            }\n\n            if (!X509_set_issuer_name(new_x509, issuer))\n                goto end;\n            if (days == UNSET_DAYS)\n                days = DEFAULT_DAYS;\n            else if (not_after != NULL)\n                BIO_printf(bio_err,\"Warning: -not_after option overriding -days option\\n\");\n            if (!set_cert_times(new_x509, not_before, not_after, days, 1))\n                goto end;\n            if (!X509_set_subject_name(new_x509, n_subj))\n                goto end;\n            if (!pub_key || !X509_set_pubkey(new_x509, pub_key))\n                goto end;\n            if (ext_copy == EXT_COPY_UNSET) {\n                if (infile != NULL)\n                    BIO_printf(bio_err, \"Warning: No -copy_extensions given; ignoring any extensions in the request\\n\");\n            } else if (!copy_extensions(new_x509, req, ext_copy)) {\n                BIO_printf(bio_err, \"Error copying extensions from request\\n\");\n                goto end;\n            }\n\n            /* Set up V3 context struct */\n            X509V3_set_ctx(&ext_ctx, CAcert != NULL ? CAcert : new_x509,\n                           new_x509, NULL, NULL, X509V3_CTX_REPLACE);\n            /* prepare fallback for AKID, but only if issuer cert == new_x509 */\n            if (CAcert == NULL) {\n                if (!X509V3_set_issuer_pkey(&ext_ctx, issuer_key))\n                    goto end;\n                if (!cert_matches_key(new_x509, issuer_key))\n                    BIO_printf(bio_err,\n                               \"Warning: Signature key and public key of cert do not match\\n\");\n            }\n            X509V3_set_nconf(&ext_ctx, req_conf);\n\n            /* Add extensions */\n            if (extsect != NULL\n                && !X509V3_EXT_add_nconf(req_conf, &ext_ctx, extsect, new_x509)) {\n                BIO_printf(bio_err, \"Error adding x509 extensions from section %s\\n\",\n                           extsect);\n                goto end;\n            }\n            if (addext_conf != NULL\n                && !X509V3_EXT_add_nconf(addext_conf, &ext_ctx, \"default\",\n                                         new_x509)) {\n                BIO_printf(bio_err, \"Error adding x509 extensions defined via -addext\\n\");\n                goto end;\n            }\n\n            /* If a pre-cert was requested, we need to add a poison extension */\n            if (precert) {\n                if (X509_add1_ext_i2d(new_x509, NID_ct_precert_poison,\n                                      NULL, 1, 0) != 1) {\n                    BIO_printf(bio_err, \"Error adding poison extension\\n\");\n                    goto end;\n                }\n            }\n\n            i = do_X509_sign(new_x509, x509v1, issuer_key, digest, sigopts,\n                             &ext_ctx);\n            if (!i)\n                goto end;\n        } else {\n            X509V3_CTX ext_ctx;\n\n            if (precert) {\n                BIO_printf(bio_err,\n                           \"Warning: Ignoring -precert flag since no cert is produced\\n\");\n            }\n            /* Set up V3 context struct */\n            X509V3_set_ctx(&ext_ctx, NULL, NULL, req, NULL, X509V3_CTX_REPLACE);\n            X509V3_set_nconf(&ext_ctx, req_conf);\n\n            /* Add extensions */\n            if (extsect != NULL\n                && !X509V3_EXT_REQ_add_nconf(req_conf, &ext_ctx, extsect, req)) {\n                BIO_printf(bio_err, \"Error adding request extensions from section %s\\n\",\n                           extsect);\n                goto end;\n            }\n            if (addext_conf != NULL\n                && !X509V3_EXT_REQ_add_nconf(addext_conf, &ext_ctx, \"default\",\n                                             req)) {\n                BIO_printf(bio_err, \"Error adding request extensions defined via -addext\\n\");\n                goto end;\n            }\n            i = do_X509_REQ_sign(req, pkey, digest, sigopts);\n            if (!i)\n                goto end;\n        }\n    }\n\n    if (subj != NULL && !newreq && !gen_x509) {\n        if (verbose) {\n            BIO_printf(out, \"Modifying subject of certificate request\\n\");\n            print_name(out, \"Old subject=\", X509_REQ_get_subject_name(req));\n        }\n\n        if (!X509_REQ_set_subject_name(req, fsubj)) {\n            BIO_printf(bio_err, \"Error modifying subject of certificate request\\n\");\n            goto end;\n        }\n\n        if (verbose) {\n            print_name(out, \"New subject=\", X509_REQ_get_subject_name(req));\n        }\n    }\n\n    if (verify) {\n        EVP_PKEY *tpubkey = pkey;\n\n        if (tpubkey == NULL) {\n            tpubkey = X509_REQ_get0_pubkey(req);\n            if (tpubkey == NULL)\n                goto end;\n        }\n\n        i = do_X509_REQ_verify(req, tpubkey, vfyopts);\n\n        if (i < 0)\n            goto end;\n        if (i == 0) {\n            BIO_printf(bio_err, \"Certificate request self-signature verify failure\\n\");\n\t    goto end;\n        } else /* i > 0 */\n            BIO_printf(bio_out, \"Certificate request self-signature verify OK\\n\");\n    }\n\n    if (noout && !text && !modulus && !subject && !pubkey) {\n        ret = 0;\n        goto end;\n    }\n\n    out = bio_open_default(outfile,\n                           keyout != NULL && outfile != NULL &&\n                           strcmp(keyout, outfile) == 0 ? 'a' : 'w',\n                           outformat);\n    if (out == NULL)\n        goto end;\n\n    if (pubkey) {\n        EVP_PKEY *tpubkey = X509_REQ_get0_pubkey(req);\n\n        if (tpubkey == NULL) {\n            BIO_printf(bio_err, \"Error getting public key\\n\");\n            goto end;\n        }\n        PEM_write_bio_PUBKEY(out, tpubkey);\n    }\n\n    if (text) {\n        if (gen_x509)\n            ret = X509_print_ex(out, new_x509, get_nameopt(), reqflag);\n        else\n            ret = X509_REQ_print_ex(out, req, get_nameopt(), reqflag);\n\n        if (ret == 0) {\n            if (gen_x509)\n                BIO_printf(bio_err, \"Error printing certificate\\n\");\n            else\n                BIO_printf(bio_err, \"Error printing certificate request\\n\");\n            goto end;\n        }\n    }\n\n    if (subject) {\n        print_name(out, \"subject=\", gen_x509\n                   ? X509_get_subject_name(new_x509)\n                   : X509_REQ_get_subject_name(req));\n    }\n\n    if (modulus) {\n        EVP_PKEY *tpubkey;\n\n        if (gen_x509)\n            tpubkey = X509_get0_pubkey(new_x509);\n        else\n            tpubkey = X509_REQ_get0_pubkey(req);\n        if (tpubkey == NULL) {\n            BIO_puts(bio_err, \"Modulus is unavailable\\n\");\n            goto end;\n        }\n        BIO_puts(out, \"Modulus=\");\n        if (EVP_PKEY_is_a(tpubkey, \"RSA\") || EVP_PKEY_is_a(tpubkey, \"RSA-PSS\")) {\n            BIGNUM *n = NULL;\n\n            if (!EVP_PKEY_get_bn_param(tpubkey, \"n\", &n))\n                goto end;\n            BN_print(out, n);\n            BN_free(n);\n        } else {\n            BIO_puts(out, \"Wrong Algorithm type\");\n        }\n        BIO_puts(out, \"\\n\");\n    }\n\n    if (!noout && !gen_x509) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_X509_REQ_bio(out, req);\n        else if (newhdr)\n            i = PEM_write_bio_X509_REQ_NEW(out, req);\n        else\n            i = PEM_write_bio_X509_REQ(out, req);\n        if (!i) {\n            BIO_printf(bio_err, \"Unable to write certificate request\\n\");\n            goto end;\n        }\n    }\n    if (!noout && gen_x509 && new_x509 != NULL) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_X509_bio(out, new_x509);\n        else\n            i = PEM_write_bio_X509(out, new_x509);\n        if (!i) {\n            BIO_printf(bio_err, \"Unable to write X509 certificate\\n\");\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret) {\n        ERR_print_errors(bio_err);\n    }\n    NCONF_free(req_conf);\n    NCONF_free(addext_conf);\n    BIO_free(addext_bio);\n    BIO_free_all(out);\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(genctx);\n    sk_OPENSSL_STRING_free(pkeyopts);\n    sk_OPENSSL_STRING_free(sigopts);\n    sk_OPENSSL_STRING_free(vfyopts);\n    lh_OPENSSL_STRING_doall(addexts, exts_cleanup);\n    lh_OPENSSL_STRING_free(addexts);\n#ifndef OPENSSL_NO_ENGINE\n    release_engine(gen_eng);\n#endif\n    OPENSSL_free(keyalgstr);\n    X509_REQ_free(req);\n    X509_NAME_free(fsubj);\n    X509_free(new_x509);\n    X509_free(CAcert);\n    EVP_PKEY_free(CAkey);\n    ASN1_INTEGER_free(serial);\n    release_engine(e);\n    if (passin != nofree_passin)\n        OPENSSL_free(passin);\n    if (passout != nofree_passout)\n        OPENSSL_free(passout);\n    return ret;\n}",
            "int do_X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const char *md,\n                     STACK_OF(OPENSSL_STRING) *sigopts)\n{\n    int rv = 0;\n    EVP_MD_CTX *mctx = EVP_MD_CTX_new();\n\n    if (do_sign_init(mctx, pkey, md, sigopts) > 0)\n        rv = (X509_REQ_sign_ctx(x, mctx) > 0);\n    EVP_MD_CTX_free(mctx);\n    return rv;\n}",
            "static int do_sign_init(EVP_MD_CTX *ctx, EVP_PKEY *pkey,\n                        const char *md, STACK_OF(OPENSSL_STRING) *sigopts)\n{\n    EVP_PKEY_CTX *pkctx = NULL;\n    char def_md[80];\n\n    if (ctx == NULL)\n        return 0;\n    /*\n     * EVP_PKEY_get_default_digest_name() returns 2 if the digest is mandatory\n     * for this algorithm.\n     */\n    if (EVP_PKEY_get_default_digest_name(pkey, def_md, sizeof(def_md)) == 2\n            && strcmp(def_md, \"UNDEF\") == 0) {\n        /* The signing algorithm requires there to be no digest */\n        md = NULL;\n    }\n\n    return EVP_DigestSignInit_ex(ctx, &pkctx, md, app_get0_libctx(),\n                                 app_get0_propq(), pkey, NULL)\n        && do_pkey_ctx_init(pkctx, sigopts);\n}"
        ],
        "sink": "i = do_X509_REQ_sign(req, pkey, digest, sigopts);",
        "final_sink": "    if (EVP_PKEY_get_default_digest_name(pkey, def_md, sizeof(def_md)) == 2",
        "source": [
            "        const char *id = sk_OPENSSL_CSTRING_value(engines, i);"
        ],
        "index": 38
    },
    {
        "prt": "req",
        "function_call": [
            "int req_main(int argc, char **argv)\n{\n    ASN1_INTEGER *serial = NULL;\n    BIO *out = NULL;\n    ENGINE *e = NULL, *gen_eng = NULL;\n    EVP_PKEY *pkey = NULL, *CAkey = NULL;\n    EVP_PKEY_CTX *genctx = NULL;\n    STACK_OF(OPENSSL_STRING) *pkeyopts = NULL, *sigopts = NULL, *vfyopts = NULL;\n    LHASH_OF(OPENSSL_STRING) *addexts = NULL;\n    X509 *new_x509 = NULL, *CAcert = NULL;\n    X509_REQ *req = NULL;\n    const EVP_CIPHER *cipher = NULL;\n    int ext_copy = EXT_COPY_UNSET;\n    BIO *addext_bio = NULL;\n    char *extsect = NULL;\n    const char *infile = NULL, *CAfile = NULL, *CAkeyfile = NULL;\n    char *outfile = NULL, *keyfile = NULL, *digest = NULL;\n    char *keyalgstr = NULL, *p, *prog, *passargin = NULL, *passargout = NULL;\n    char *passin = NULL, *passout = NULL;\n    char *nofree_passin = NULL, *nofree_passout = NULL;\n    char *subj = NULL;\n    X509_NAME *fsubj = NULL;\n    char *template = default_config_file, *keyout = NULL;\n    const char *keyalg = NULL;\n    OPTION_CHOICE o;\n    char *not_before = NULL, *not_after = NULL;\n    int days = UNSET_DAYS;\n    int ret = 1, gen_x509 = 0, i = 0, newreq = 0, verbose = 0, progress = 1;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, keyform = FORMAT_UNDEF;\n    int modulus = 0, multirdn = 1, verify = 0, noout = 0, text = 0;\n    int noenc = 0, newhdr = 0, subject = 0, pubkey = 0, precert = 0, x509v1 = 0;\n    long newkey_len = -1;\n    unsigned long chtype = MBSTRING_ASC, reqflag = 0;\n\n    cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n\n    opt_set_unknown_name(\"digest\");\n    prog = opt_init(argc, argv, req_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(req_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_KEYGEN_ENGINE:\n#ifndef OPENSSL_NO_ENGINE\n            gen_eng = setup_engine(opt_arg(), 0);\n            if (gen_eng == NULL) {\n                BIO_printf(bio_err, \"Can't find keygen engine %s\\n\", *argv);\n                goto opthelp;\n            }\n#endif\n            break;\n        case OPT_KEY:\n            keyfile = opt_arg();\n            break;\n        case OPT_PUBKEY:\n            pubkey = 1;\n            break;\n        case OPT_NEW:\n            newreq = 1;\n            break;\n        case OPT_CONFIG:\n            template = opt_arg();\n            break;\n        case OPT_SECTION:\n            section = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_KEYOUT:\n            keyout = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passargin = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passargout = opt_arg();\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_NEWKEY:\n            keyalg = opt_arg();\n            newreq = 1;\n            break;\n        case OPT_PKEYOPT:\n            if (pkeyopts == NULL)\n                pkeyopts = sk_OPENSSL_STRING_new_null();\n            if (pkeyopts == NULL\n                    || !sk_OPENSSL_STRING_push(pkeyopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SIGOPT:\n            if (!sigopts)\n                sigopts = sk_OPENSSL_STRING_new_null();\n            if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_VFYOPT:\n            if (!vfyopts)\n                vfyopts = sk_OPENSSL_STRING_new_null();\n            if (!vfyopts || !sk_OPENSSL_STRING_push(vfyopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_BATCH:\n            batch = 1;\n            break;\n        case OPT_NEWHDR:\n            newhdr = 1;\n            break;\n        case OPT_MODULUS:\n            modulus = 1;\n            break;\n        case OPT_VERIFY:\n            verify = 1;\n            break;\n        case OPT_NODES:\n        case OPT_NOENC:\n            noenc = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_VERBOSE:\n            verbose = 1;\n            progress = 1;\n            break;\n        case OPT_QUIET:\n            verbose = 0;\n            progress = 0;\n            break;\n        case OPT_UTF8:\n            chtype = MBSTRING_UTF8;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_REQOPT:\n            if (!set_cert_ex(&reqflag, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_X509V1:\n            x509v1 = 1;\n            /* fall thru */\n        case OPT_X509:\n            gen_x509 = 1;\n            break;\n        case OPT_CA:\n            CAfile = opt_arg();\n            gen_x509 = 1;\n            break;\n        case OPT_CAKEY:\n            CAkeyfile = opt_arg();\n            break;\n        case OPT_NOT_BEFORE:\n            not_before = opt_arg();\n            break;\n        case OPT_NOT_AFTER:\n            not_after = opt_arg();\n            break;\n        case OPT_DAYS:\n            days = atoi(opt_arg());\n            if (days <= UNSET_DAYS) {\n                BIO_printf(bio_err, \"%s: -days parameter arg must be >= -1\\n\",\n                           prog);\n                goto end;\n            }\n            break;\n        case OPT_SET_SERIAL:\n            if (serial != NULL) {\n                BIO_printf(bio_err, \"Serial number supplied twice\\n\");\n                goto opthelp;\n            }\n            serial = s2i_ASN1_INTEGER(NULL, opt_arg());\n            if (serial == NULL)\n                goto opthelp;\n            break;\n        case OPT_SUBJECT:\n            subject = 1;\n            break;\n        case OPT_SUBJ:\n            subj = opt_arg();\n            break;\n        case OPT_MULTIVALUE_RDN:\n            /* obsolete */\n            break;\n        case OPT_COPY_EXTENSIONS:\n            if (!set_ext_copy(&ext_copy, opt_arg())) {\n                BIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\",\n                           opt_arg());\n                goto end;\n            }\n            break;\n        case OPT_EXTENSIONS:\n        case OPT_REQEXTS:\n            extsect = opt_arg();\n            break;\n        case OPT_ADDEXT:\n            p = opt_arg();\n            if (addexts == NULL) {\n                addexts = lh_OPENSSL_STRING_new(ext_name_hash, ext_name_cmp);\n                addext_bio = BIO_new(BIO_s_mem());\n                if (addexts == NULL || addext_bio == NULL)\n                    goto end;\n            }\n            i = duplicated(addexts, p);\n            if (i == 1)\n                goto end;\n            if (i == -1)\n                BIO_printf(bio_err, \"Internal error handling -addext %s\\n\", p);\n            if (i < 0 || BIO_printf(addext_bio, \"%s\\n\", p) < 0)\n                goto end;\n            break;\n        case OPT_PRECERT:\n            newreq = precert = 1;\n            break;\n        case OPT_CIPHER:\n            cipher = EVP_get_cipherbyname(opt_arg());\n            if (cipher == NULL) {\n                BIO_printf(bio_err, \"Unknown cipher: %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_MD:\n            digest = opt_unknown();\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n    if (!gen_x509) {\n        if (days != UNSET_DAYS)\n            BIO_printf(bio_err, \"Warning: Ignoring -days without -x509; not generating a certificate\\n\");\n        if (not_before != NULL)\n            BIO_printf(bio_err, \"Warning: Ignoring -not_before without -x509; not generating a certificate\\n\");\n        if (not_after != NULL)\n            BIO_printf(bio_err, \"Warning: Ignoring -not_after without -x509; not generating a certificate\\n\");\n        if (ext_copy == EXT_COPY_NONE)\n            BIO_printf(bio_err, \"Warning: Ignoring -copy_extensions 'none' when -x509 is not given\\n\");\n    }\n    if (infile == NULL) {\n        if (gen_x509)\n            newreq = 1;\n        else if (!newreq && isatty(fileno_stdin()))\n            BIO_printf(bio_err,\n                       \"Warning: Will read cert request from stdin since no -in option is given\\n\");\n    }\n\n    if (!app_passwd(passargin, passargout, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n\n    if ((req_conf = app_load_config_verbose(template, verbose)) == NULL)\n        goto end;\n    if (addext_bio != NULL) {\n        if (verbose)\n            BIO_printf(bio_err,\n                       \"Using additional configuration from -addext options\\n\");\n        if ((addext_conf = app_load_config_bio(addext_bio, NULL)) == NULL)\n            goto end;\n    }\n    if (template != default_config_file && !app_load_modules(req_conf))\n        goto end;\n\n    if (req_conf != NULL) {\n        p = app_conf_try_string(req_conf, NULL, \"oid_file\");\n        if (p != NULL) {\n            BIO *oid_bio = BIO_new_file(p, \"r\");\n\n            if (oid_bio == NULL) {\n                if (verbose)\n                    BIO_printf(bio_err,\n                               \"Problems opening '%s' for extra OIDs\\n\", p);\n            } else {\n                OBJ_create_objects(oid_bio);\n                BIO_free(oid_bio);\n            }\n        }\n    }\n    if (!add_oid_section(req_conf))\n        goto end;\n\n    /* Check that any specified digest is fetchable */\n    if (digest != NULL) {\n        if (!opt_check_md(digest))\n            goto opthelp;\n    } else {\n        /* No digest specified, default to configuration */\n        p = app_conf_try_string(req_conf, section, \"default_md\");\n        if (p != NULL)\n            digest = p;\n    }\n\n    if (extsect == NULL)\n        extsect = app_conf_try_string(req_conf, section,\n                                   gen_x509 ? V3_EXTENSIONS : REQ_EXTENSIONS);\n    if (extsect != NULL) {\n        /* Check syntax of extension section in config file */\n        X509V3_CTX ctx;\n\n        X509V3_set_ctx_test(&ctx);\n        X509V3_set_nconf(&ctx, req_conf);\n        if (!X509V3_EXT_add_nconf(req_conf, &ctx, extsect, NULL)) {\n            BIO_printf(bio_err,\n                       \"Error checking %s extension section %s\\n\",\n                       gen_x509 ? \"x509\" : \"request\", extsect);\n            goto end;\n        }\n    }\n    if (addext_conf != NULL) {\n        /* Check syntax of command line extensions */\n        X509V3_CTX ctx;\n\n        X509V3_set_ctx_test(&ctx);\n        X509V3_set_nconf(&ctx, req_conf);\n        if (!X509V3_EXT_add_nconf(addext_conf, &ctx, \"default\", NULL)) {\n            BIO_printf(bio_err, \"Error checking extensions defined using -addext\\n\");\n            goto end;\n        }\n    }\n\n    if (passin == NULL)\n        passin = nofree_passin =\n            app_conf_try_string(req_conf, section, \"input_password\");\n\n    if (passout == NULL)\n        passout = nofree_passout =\n            app_conf_try_string(req_conf, section, \"output_password\");\n\n    p = app_conf_try_string(req_conf, section, STRING_MASK);\n    if (p != NULL && !ASN1_STRING_set_default_mask_asc(p)) {\n        BIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", p);\n        goto end;\n    }\n\n    if (chtype != MBSTRING_UTF8) {\n        p = app_conf_try_string(req_conf, section, UTF8_IN);\n        if (p != NULL && strcmp(p, \"yes\") == 0)\n            chtype = MBSTRING_UTF8;\n    }\n\n    if (keyfile != NULL) {\n        pkey = load_key(keyfile, keyform, 0, passin, e, \"private key\");\n        if (pkey == NULL)\n            goto end;\n        app_RAND_load_conf(req_conf, section);\n    }\n    if (keyalg != NULL && pkey != NULL) {\n        BIO_printf(bio_err,\n                   \"Warning: Not generating key via given -newkey option since -key is given\\n\");\n        /* Better throw an error in this case */\n    }\n    if (newreq && pkey == NULL) {\n        app_RAND_load_conf(req_conf, section);\n\n        if (!app_conf_try_number(req_conf, section, BITS, &newkey_len))\n            newkey_len = DEFAULT_KEY_LENGTH;\n\n        genctx = set_keygen_ctx(keyalg, &keyalgstr, &newkey_len, gen_eng);\n        if (genctx == NULL)\n            goto end;\n\n        if (newkey_len < MIN_KEY_LENGTH\n            && (EVP_PKEY_CTX_is_a(genctx, \"RSA\")\n                || EVP_PKEY_CTX_is_a(genctx, \"RSA-PSS\")\n                || EVP_PKEY_CTX_is_a(genctx, \"DSA\"))) {\n            BIO_printf(bio_err, \"Private key length too short, needs to be at least %d bits, not %ld.\\n\",\n                       MIN_KEY_LENGTH, newkey_len);\n            goto end;\n        }\n\n        if (newkey_len > OPENSSL_RSA_MAX_MODULUS_BITS\n            && (EVP_PKEY_CTX_is_a(genctx, \"RSA\")\n                || EVP_PKEY_CTX_is_a(genctx, \"RSA-PSS\")))\n            BIO_printf(bio_err,\n                       \"Warning: It is not recommended to use more than %d bit for RSA keys.\\n\"\n                       \"         Your key size is %ld! Larger key size may behave not as expected.\\n\",\n                       OPENSSL_RSA_MAX_MODULUS_BITS, newkey_len);\n\n#ifndef OPENSSL_NO_DSA\n        if (EVP_PKEY_CTX_is_a(genctx, \"DSA\")\n                && newkey_len > OPENSSL_DSA_MAX_MODULUS_BITS)\n            BIO_printf(bio_err,\n                       \"Warning: It is not recommended to use more than %d bit for DSA keys.\\n\"\n                       \"         Your key size is %ld! Larger key size may behave not as expected.\\n\",\n                       OPENSSL_DSA_MAX_MODULUS_BITS, newkey_len);\n#endif\n\n        if (pkeyopts != NULL) {\n            char *genopt;\n            for (i = 0; i < sk_OPENSSL_STRING_num(pkeyopts); i++) {\n                genopt = sk_OPENSSL_STRING_value(pkeyopts, i);\n                if (pkey_ctrl_string(genctx, genopt) <= 0) {\n                    BIO_printf(bio_err, \"Key parameter error \\\"%s\\\"\\n\", genopt);\n                    goto end;\n                }\n            }\n        }\n\n        EVP_PKEY_CTX_set_app_data(genctx, bio_err);\n        if (progress)\n            EVP_PKEY_CTX_set_cb(genctx, progress_cb);\n\n        pkey = app_keygen(genctx, keyalgstr, newkey_len, verbose);\n        if (pkey == NULL)\n            goto end;\n\n        EVP_PKEY_CTX_free(genctx);\n        genctx = NULL;\n    }\n    if (keyout == NULL && keyfile == NULL)\n        keyout = app_conf_try_string(req_conf, section, KEYFILE);\n\n    if (pkey != NULL && (keyfile == NULL || keyout != NULL)) {\n        if (verbose) {\n            BIO_printf(bio_err, \"Writing private key to \");\n            if (keyout == NULL)\n                BIO_printf(bio_err, \"stdout\\n\");\n            else\n                BIO_printf(bio_err, \"'%s'\\n\", keyout);\n        }\n        out = bio_open_owner(keyout, outformat, newreq);\n        if (out == NULL)\n            goto end;\n\n        p = app_conf_try_string(req_conf, section, \"encrypt_rsa_key\");\n        if (p == NULL)\n            p = app_conf_try_string(req_conf, section, \"encrypt_key\");\n        if (p != NULL && strcmp(p, \"no\") == 0)\n            cipher = NULL;\n        if (noenc)\n            cipher = NULL;\n\n        i = 0;\n loop:\n        if (!PEM_write_bio_PrivateKey(out, pkey, cipher,\n                                      NULL, 0, NULL, passout)) {\n            if ((ERR_GET_REASON(ERR_peek_error()) ==\n                 PEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3)) {\n                ERR_clear_error();\n                i++;\n                goto loop;\n            }\n            goto end;\n        }\n        BIO_free_all(out);\n        out = NULL;\n        BIO_printf(bio_err, \"-----\\n\");\n    }\n\n    /*\n     * subj is expected to be in the format /type0=value0/type1=value1/type2=...\n     * where characters may be escaped by \\\n     */\n    if (subj != NULL\n            && (fsubj = parse_name(subj, chtype, multirdn, \"subject\")) == NULL)\n        goto end;\n\n    if (!newreq) {\n        if (keyfile != NULL)\n            BIO_printf(bio_err,\n                       \"Warning: Not placing -key in cert or request since request is used\\n\");\n        req = load_csr_autofmt(infile /* if NULL, reads from stdin */,\n                               informat, vfyopts, \"X509 request\");\n        if (req == NULL)\n            goto end;\n    } else if (infile != NULL) {\n        BIO_printf(bio_err,\n                   \"Warning: Ignoring -in option since -new or -newkey or -precert is given\\n\");\n        /* Better throw an error in this case, as done in the x509 app */\n    }\n\n    if (CAkeyfile == NULL)\n        CAkeyfile = CAfile;\n    if (CAkeyfile != NULL) {\n        if (CAfile == NULL) {\n            BIO_printf(bio_err,\n                       \"Warning: Ignoring -CAkey option since no -CA option is given\\n\");\n        } else {\n            if ((CAkey = load_key(CAkeyfile, FORMAT_UNDEF,\n                                  0, passin, e,\n                                  CAkeyfile != CAfile\n                                  ? \"issuer private key from -CAkey arg\"\n                                  : \"issuer private key from -CA arg\")) == NULL)\n                goto end;\n        }\n    }\n    if (CAfile != NULL) {\n        if ((CAcert = load_cert_pass(CAfile, FORMAT_UNDEF, 1, passin,\n                                     \"issuer cert from -CA arg\")) == NULL)\n            goto end;\n        if (!X509_check_private_key(CAcert, CAkey)) {\n            BIO_printf(bio_err,\n                       \"Issuer CA certificate and key do not match\\n\");\n            goto end;\n        }\n    }\n    if (newreq || gen_x509) {\n        if (CAcert == NULL && pkey == NULL) {\n            BIO_printf(bio_err, \"Must provide a signature key using -key or\"\n                \" provide -CA / -CAkey\\n\");\n            goto end;\n        }\n\n        if (req == NULL) {\n            req = X509_REQ_new_ex(app_get0_libctx(), app_get0_propq());\n            if (req == NULL) {\n                goto end;\n            }\n\n            if (!make_REQ(req, pkey, fsubj, multirdn, !gen_x509, chtype)) {\n                BIO_printf(bio_err, \"Error making certificate request\\n\");\n                goto end;\n            }\n            /* Note that -x509 can take over -key and -subj option values. */\n        }\n        if (gen_x509) {\n            EVP_PKEY *pub_key = X509_REQ_get0_pubkey(req);\n            EVP_PKEY *issuer_key = CAcert != NULL ? CAkey : pkey;\n            X509V3_CTX ext_ctx;\n            X509_NAME *issuer = CAcert != NULL ? X509_get_subject_name(CAcert) :\n                X509_REQ_get_subject_name(req);\n            X509_NAME *n_subj = fsubj != NULL ? fsubj :\n                X509_REQ_get_subject_name(req);\n\n            if (CAcert != NULL && keyfile != NULL)\n                BIO_printf(bio_err,\n                           \"Warning: Not using -key or -newkey for signing since -CA option is given\\n\");\n\n            if ((new_x509 = X509_new_ex(app_get0_libctx(),\n                                        app_get0_propq())) == NULL)\n                goto end;\n\n            if (serial != NULL) {\n                if (!X509_set_serialNumber(new_x509, serial))\n                    goto end;\n            } else {\n                if (!rand_serial(NULL, X509_get_serialNumber(new_x509)))\n                    goto end;\n            }\n\n            if (!X509_set_issuer_name(new_x509, issuer))\n                goto end;\n            if (days == UNSET_DAYS)\n                days = DEFAULT_DAYS;\n            else if (not_after != NULL)\n                BIO_printf(bio_err,\"Warning: -not_after option overriding -days option\\n\");\n            if (!set_cert_times(new_x509, not_before, not_after, days, 1))\n                goto end;\n            if (!X509_set_subject_name(new_x509, n_subj))\n                goto end;\n            if (!pub_key || !X509_set_pubkey(new_x509, pub_key))\n                goto end;\n            if (ext_copy == EXT_COPY_UNSET) {\n                if (infile != NULL)\n                    BIO_printf(bio_err, \"Warning: No -copy_extensions given; ignoring any extensions in the request\\n\");\n            } else if (!copy_extensions(new_x509, req, ext_copy)) {\n                BIO_printf(bio_err, \"Error copying extensions from request\\n\");\n                goto end;\n            }\n\n            /* Set up V3 context struct */\n            X509V3_set_ctx(&ext_ctx, CAcert != NULL ? CAcert : new_x509,\n                           new_x509, NULL, NULL, X509V3_CTX_REPLACE);\n            /* prepare fallback for AKID, but only if issuer cert == new_x509 */\n            if (CAcert == NULL) {\n                if (!X509V3_set_issuer_pkey(&ext_ctx, issuer_key))\n                    goto end;\n                if (!cert_matches_key(new_x509, issuer_key))\n                    BIO_printf(bio_err,\n                               \"Warning: Signature key and public key of cert do not match\\n\");\n            }\n            X509V3_set_nconf(&ext_ctx, req_conf);\n\n            /* Add extensions */\n            if (extsect != NULL\n                && !X509V3_EXT_add_nconf(req_conf, &ext_ctx, extsect, new_x509)) {\n                BIO_printf(bio_err, \"Error adding x509 extensions from section %s\\n\",\n                           extsect);\n                goto end;\n            }\n            if (addext_conf != NULL\n                && !X509V3_EXT_add_nconf(addext_conf, &ext_ctx, \"default\",\n                                         new_x509)) {\n                BIO_printf(bio_err, \"Error adding x509 extensions defined via -addext\\n\");\n                goto end;\n            }\n\n            /* If a pre-cert was requested, we need to add a poison extension */\n            if (precert) {\n                if (X509_add1_ext_i2d(new_x509, NID_ct_precert_poison,\n                                      NULL, 1, 0) != 1) {\n                    BIO_printf(bio_err, \"Error adding poison extension\\n\");\n                    goto end;\n                }\n            }\n\n            i = do_X509_sign(new_x509, x509v1, issuer_key, digest, sigopts,\n                             &ext_ctx);\n            if (!i)\n                goto end;\n        } else {\n            X509V3_CTX ext_ctx;\n\n            if (precert) {\n                BIO_printf(bio_err,\n                           \"Warning: Ignoring -precert flag since no cert is produced\\n\");\n            }\n            /* Set up V3 context struct */\n            X509V3_set_ctx(&ext_ctx, NULL, NULL, req, NULL, X509V3_CTX_REPLACE);\n            X509V3_set_nconf(&ext_ctx, req_conf);\n\n            /* Add extensions */\n            if (extsect != NULL\n                && !X509V3_EXT_REQ_add_nconf(req_conf, &ext_ctx, extsect, req)) {\n                BIO_printf(bio_err, \"Error adding request extensions from section %s\\n\",\n                           extsect);\n                goto end;\n            }\n            if (addext_conf != NULL\n                && !X509V3_EXT_REQ_add_nconf(addext_conf, &ext_ctx, \"default\",\n                                             req)) {\n                BIO_printf(bio_err, \"Error adding request extensions defined via -addext\\n\");\n                goto end;\n            }\n            i = do_X509_REQ_sign(req, pkey, digest, sigopts);\n            if (!i)\n                goto end;\n        }\n    }\n\n    if (subj != NULL && !newreq && !gen_x509) {\n        if (verbose) {\n            BIO_printf(out, \"Modifying subject of certificate request\\n\");\n            print_name(out, \"Old subject=\", X509_REQ_get_subject_name(req));\n        }\n\n        if (!X509_REQ_set_subject_name(req, fsubj)) {\n            BIO_printf(bio_err, \"Error modifying subject of certificate request\\n\");\n            goto end;\n        }\n\n        if (verbose) {\n            print_name(out, \"New subject=\", X509_REQ_get_subject_name(req));\n        }\n    }\n\n    if (verify) {\n        EVP_PKEY *tpubkey = pkey;\n\n        if (tpubkey == NULL) {\n            tpubkey = X509_REQ_get0_pubkey(req);\n            if (tpubkey == NULL)\n                goto end;\n        }\n\n        i = do_X509_REQ_verify(req, tpubkey, vfyopts);\n\n        if (i < 0)\n            goto end;\n        if (i == 0) {\n            BIO_printf(bio_err, \"Certificate request self-signature verify failure\\n\");\n\t    goto end;\n        } else /* i > 0 */\n            BIO_printf(bio_out, \"Certificate request self-signature verify OK\\n\");\n    }\n\n    if (noout && !text && !modulus && !subject && !pubkey) {\n        ret = 0;\n        goto end;\n    }\n\n    out = bio_open_default(outfile,\n                           keyout != NULL && outfile != NULL &&\n                           strcmp(keyout, outfile) == 0 ? 'a' : 'w',\n                           outformat);\n    if (out == NULL)\n        goto end;\n\n    if (pubkey) {\n        EVP_PKEY *tpubkey = X509_REQ_get0_pubkey(req);\n\n        if (tpubkey == NULL) {\n            BIO_printf(bio_err, \"Error getting public key\\n\");\n            goto end;\n        }\n        PEM_write_bio_PUBKEY(out, tpubkey);\n    }\n\n    if (text) {\n        if (gen_x509)\n            ret = X509_print_ex(out, new_x509, get_nameopt(), reqflag);\n        else\n            ret = X509_REQ_print_ex(out, req, get_nameopt(), reqflag);\n\n        if (ret == 0) {\n            if (gen_x509)\n                BIO_printf(bio_err, \"Error printing certificate\\n\");\n            else\n                BIO_printf(bio_err, \"Error printing certificate request\\n\");\n            goto end;\n        }\n    }\n\n    if (subject) {\n        print_name(out, \"subject=\", gen_x509\n                   ? X509_get_subject_name(new_x509)\n                   : X509_REQ_get_subject_name(req));\n    }\n\n    if (modulus) {\n        EVP_PKEY *tpubkey;\n\n        if (gen_x509)\n            tpubkey = X509_get0_pubkey(new_x509);\n        else\n            tpubkey = X509_REQ_get0_pubkey(req);\n        if (tpubkey == NULL) {\n            BIO_puts(bio_err, \"Modulus is unavailable\\n\");\n            goto end;\n        }\n        BIO_puts(out, \"Modulus=\");\n        if (EVP_PKEY_is_a(tpubkey, \"RSA\") || EVP_PKEY_is_a(tpubkey, \"RSA-PSS\")) {\n            BIGNUM *n = NULL;\n\n            if (!EVP_PKEY_get_bn_param(tpubkey, \"n\", &n))\n                goto end;\n            BN_print(out, n);\n            BN_free(n);\n        } else {\n            BIO_puts(out, \"Wrong Algorithm type\");\n        }\n        BIO_puts(out, \"\\n\");\n    }\n\n    if (!noout && !gen_x509) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_X509_REQ_bio(out, req);\n        else if (newhdr)\n            i = PEM_write_bio_X509_REQ_NEW(out, req);\n        else\n            i = PEM_write_bio_X509_REQ(out, req);\n        if (!i) {\n            BIO_printf(bio_err, \"Unable to write certificate request\\n\");\n            goto end;\n        }\n    }\n    if (!noout && gen_x509 && new_x509 != NULL) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_X509_bio(out, new_x509);\n        else\n            i = PEM_write_bio_X509(out, new_x509);\n        if (!i) {\n            BIO_printf(bio_err, \"Unable to write X509 certificate\\n\");\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret) {\n        ERR_print_errors(bio_err);\n    }\n    NCONF_free(req_conf);\n    NCONF_free(addext_conf);\n    BIO_free(addext_bio);\n    BIO_free_all(out);\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(genctx);\n    sk_OPENSSL_STRING_free(pkeyopts);\n    sk_OPENSSL_STRING_free(sigopts);\n    sk_OPENSSL_STRING_free(vfyopts);\n    lh_OPENSSL_STRING_doall(addexts, exts_cleanup);\n    lh_OPENSSL_STRING_free(addexts);\n#ifndef OPENSSL_NO_ENGINE\n    release_engine(gen_eng);\n#endif\n    OPENSSL_free(keyalgstr);\n    X509_REQ_free(req);\n    X509_NAME_free(fsubj);\n    X509_free(new_x509);\n    X509_free(CAcert);\n    EVP_PKEY_free(CAkey);\n    ASN1_INTEGER_free(serial);\n    release_engine(e);\n    if (passin != nofree_passin)\n        OPENSSL_free(passin);\n    if (passout != nofree_passout)\n        OPENSSL_free(passout);\n    return ret;\n}",
            "int do_X509_REQ_verify(X509_REQ *x, EVP_PKEY *pkey,\n                       STACK_OF(OPENSSL_STRING) *vfyopts)\n{\n    int rv = 0;\n\n    if (do_x509_req_init(x, vfyopts) > 0)\n        rv = X509_REQ_verify_ex(x, pkey, app_get0_libctx(), app_get0_propq());\n    else\n        rv = -1;\n    return rv;\n}",
            "int X509_REQ_verify_ex(X509_REQ *a, EVP_PKEY *r, OSSL_LIB_CTX *libctx,\n                       const char *propq)\n{\n    if (X509_REQ_get_version(a) != X509_REQ_VERSION_1) {\n        ERR_raise(ERR_LIB_X509, X509_R_UNSUPPORTED_VERSION);\n        return -1;\n    }\n\n    return ASN1_item_verify_ex(ASN1_ITEM_rptr(X509_REQ_INFO), &a->sig_alg,\n                               a->signature, &a->req_info, a->distinguishing_id,\n                               r, libctx, propq);\n}"
        ],
        "sink": "i = do_X509_REQ_verify(req, tpubkey, vfyopts);",
        "final_sink": "    return ASN1_item_verify_ex(ASN1_ITEM_rptr(X509_REQ_INFO), &a->sig_alg,",
        "source": [],
        "index": 39
    },
    {
        "prt": "new_x509",
        "function_call": [
            "int req_main(int argc, char **argv)\n{\n    ASN1_INTEGER *serial = NULL;\n    BIO *out = NULL;\n    ENGINE *e = NULL, *gen_eng = NULL;\n    EVP_PKEY *pkey = NULL, *CAkey = NULL;\n    EVP_PKEY_CTX *genctx = NULL;\n    STACK_OF(OPENSSL_STRING) *pkeyopts = NULL, *sigopts = NULL, *vfyopts = NULL;\n    LHASH_OF(OPENSSL_STRING) *addexts = NULL;\n    X509 *new_x509 = NULL, *CAcert = NULL;\n    X509_REQ *req = NULL;\n    const EVP_CIPHER *cipher = NULL;\n    int ext_copy = EXT_COPY_UNSET;\n    BIO *addext_bio = NULL;\n    char *extsect = NULL;\n    const char *infile = NULL, *CAfile = NULL, *CAkeyfile = NULL;\n    char *outfile = NULL, *keyfile = NULL, *digest = NULL;\n    char *keyalgstr = NULL, *p, *prog, *passargin = NULL, *passargout = NULL;\n    char *passin = NULL, *passout = NULL;\n    char *nofree_passin = NULL, *nofree_passout = NULL;\n    char *subj = NULL;\n    X509_NAME *fsubj = NULL;\n    char *template = default_config_file, *keyout = NULL;\n    const char *keyalg = NULL;\n    OPTION_CHOICE o;\n    char *not_before = NULL, *not_after = NULL;\n    int days = UNSET_DAYS;\n    int ret = 1, gen_x509 = 0, i = 0, newreq = 0, verbose = 0, progress = 1;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, keyform = FORMAT_UNDEF;\n    int modulus = 0, multirdn = 1, verify = 0, noout = 0, text = 0;\n    int noenc = 0, newhdr = 0, subject = 0, pubkey = 0, precert = 0, x509v1 = 0;\n    long newkey_len = -1;\n    unsigned long chtype = MBSTRING_ASC, reqflag = 0;\n\n    cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n\n    opt_set_unknown_name(\"digest\");\n    prog = opt_init(argc, argv, req_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(req_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_KEYGEN_ENGINE:\n#ifndef OPENSSL_NO_ENGINE\n            gen_eng = setup_engine(opt_arg(), 0);\n            if (gen_eng == NULL) {\n                BIO_printf(bio_err, \"Can't find keygen engine %s\\n\", *argv);\n                goto opthelp;\n            }\n#endif\n            break;\n        case OPT_KEY:\n            keyfile = opt_arg();\n            break;\n        case OPT_PUBKEY:\n            pubkey = 1;\n            break;\n        case OPT_NEW:\n            newreq = 1;\n            break;\n        case OPT_CONFIG:\n            template = opt_arg();\n            break;\n        case OPT_SECTION:\n            section = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_KEYOUT:\n            keyout = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passargin = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passargout = opt_arg();\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_NEWKEY:\n            keyalg = opt_arg();\n            newreq = 1;\n            break;\n        case OPT_PKEYOPT:\n            if (pkeyopts == NULL)\n                pkeyopts = sk_OPENSSL_STRING_new_null();\n            if (pkeyopts == NULL\n                    || !sk_OPENSSL_STRING_push(pkeyopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SIGOPT:\n            if (!sigopts)\n                sigopts = sk_OPENSSL_STRING_new_null();\n            if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_VFYOPT:\n            if (!vfyopts)\n                vfyopts = sk_OPENSSL_STRING_new_null();\n            if (!vfyopts || !sk_OPENSSL_STRING_push(vfyopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_BATCH:\n            batch = 1;\n            break;\n        case OPT_NEWHDR:\n            newhdr = 1;\n            break;\n        case OPT_MODULUS:\n            modulus = 1;\n            break;\n        case OPT_VERIFY:\n            verify = 1;\n            break;\n        case OPT_NODES:\n        case OPT_NOENC:\n            noenc = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_VERBOSE:\n            verbose = 1;\n            progress = 1;\n            break;\n        case OPT_QUIET:\n            verbose = 0;\n            progress = 0;\n            break;\n        case OPT_UTF8:\n            chtype = MBSTRING_UTF8;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_REQOPT:\n            if (!set_cert_ex(&reqflag, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_X509V1:\n            x509v1 = 1;\n            /* fall thru */\n        case OPT_X509:\n            gen_x509 = 1;\n            break;\n        case OPT_CA:\n            CAfile = opt_arg();\n            gen_x509 = 1;\n            break;\n        case OPT_CAKEY:\n            CAkeyfile = opt_arg();\n            break;\n        case OPT_NOT_BEFORE:\n            not_before = opt_arg();\n            break;\n        case OPT_NOT_AFTER:\n            not_after = opt_arg();\n            break;\n        case OPT_DAYS:\n            days = atoi(opt_arg());\n            if (days <= UNSET_DAYS) {\n                BIO_printf(bio_err, \"%s: -days parameter arg must be >= -1\\n\",\n                           prog);\n                goto end;\n            }\n            break;\n        case OPT_SET_SERIAL:\n            if (serial != NULL) {\n                BIO_printf(bio_err, \"Serial number supplied twice\\n\");\n                goto opthelp;\n            }\n            serial = s2i_ASN1_INTEGER(NULL, opt_arg());\n            if (serial == NULL)\n                goto opthelp;\n            break;\n        case OPT_SUBJECT:\n            subject = 1;\n            break;\n        case OPT_SUBJ:\n            subj = opt_arg();\n            break;\n        case OPT_MULTIVALUE_RDN:\n            /* obsolete */\n            break;\n        case OPT_COPY_EXTENSIONS:\n            if (!set_ext_copy(&ext_copy, opt_arg())) {\n                BIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\",\n                           opt_arg());\n                goto end;\n            }\n            break;\n        case OPT_EXTENSIONS:\n        case OPT_REQEXTS:\n            extsect = opt_arg();\n            break;\n        case OPT_ADDEXT:\n            p = opt_arg();\n            if (addexts == NULL) {\n                addexts = lh_OPENSSL_STRING_new(ext_name_hash, ext_name_cmp);\n                addext_bio = BIO_new(BIO_s_mem());\n                if (addexts == NULL || addext_bio == NULL)\n                    goto end;\n            }\n            i = duplicated(addexts, p);\n            if (i == 1)\n                goto end;\n            if (i == -1)\n                BIO_printf(bio_err, \"Internal error handling -addext %s\\n\", p);\n            if (i < 0 || BIO_printf(addext_bio, \"%s\\n\", p) < 0)\n                goto end;\n            break;\n        case OPT_PRECERT:\n            newreq = precert = 1;\n            break;\n        case OPT_CIPHER:\n            cipher = EVP_get_cipherbyname(opt_arg());\n            if (cipher == NULL) {\n                BIO_printf(bio_err, \"Unknown cipher: %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_MD:\n            digest = opt_unknown();\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n    if (!gen_x509) {\n        if (days != UNSET_DAYS)\n            BIO_printf(bio_err, \"Warning: Ignoring -days without -x509; not generating a certificate\\n\");\n        if (not_before != NULL)\n            BIO_printf(bio_err, \"Warning: Ignoring -not_before without -x509; not generating a certificate\\n\");\n        if (not_after != NULL)\n            BIO_printf(bio_err, \"Warning: Ignoring -not_after without -x509; not generating a certificate\\n\");\n        if (ext_copy == EXT_COPY_NONE)\n            BIO_printf(bio_err, \"Warning: Ignoring -copy_extensions 'none' when -x509 is not given\\n\");\n    }\n    if (infile == NULL) {\n        if (gen_x509)\n            newreq = 1;\n        else if (!newreq && isatty(fileno_stdin()))\n            BIO_printf(bio_err,\n                       \"Warning: Will read cert request from stdin since no -in option is given\\n\");\n    }\n\n    if (!app_passwd(passargin, passargout, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n\n    if ((req_conf = app_load_config_verbose(template, verbose)) == NULL)\n        goto end;\n    if (addext_bio != NULL) {\n        if (verbose)\n            BIO_printf(bio_err,\n                       \"Using additional configuration from -addext options\\n\");\n        if ((addext_conf = app_load_config_bio(addext_bio, NULL)) == NULL)\n            goto end;\n    }\n    if (template != default_config_file && !app_load_modules(req_conf))\n        goto end;\n\n    if (req_conf != NULL) {\n        p = app_conf_try_string(req_conf, NULL, \"oid_file\");\n        if (p != NULL) {\n            BIO *oid_bio = BIO_new_file(p, \"r\");\n\n            if (oid_bio == NULL) {\n                if (verbose)\n                    BIO_printf(bio_err,\n                               \"Problems opening '%s' for extra OIDs\\n\", p);\n            } else {\n                OBJ_create_objects(oid_bio);\n                BIO_free(oid_bio);\n            }\n        }\n    }\n    if (!add_oid_section(req_conf))\n        goto end;\n\n    /* Check that any specified digest is fetchable */\n    if (digest != NULL) {\n        if (!opt_check_md(digest))\n            goto opthelp;\n    } else {\n        /* No digest specified, default to configuration */\n        p = app_conf_try_string(req_conf, section, \"default_md\");\n        if (p != NULL)\n            digest = p;\n    }\n\n    if (extsect == NULL)\n        extsect = app_conf_try_string(req_conf, section,\n                                   gen_x509 ? V3_EXTENSIONS : REQ_EXTENSIONS);\n    if (extsect != NULL) {\n        /* Check syntax of extension section in config file */\n        X509V3_CTX ctx;\n\n        X509V3_set_ctx_test(&ctx);\n        X509V3_set_nconf(&ctx, req_conf);\n        if (!X509V3_EXT_add_nconf(req_conf, &ctx, extsect, NULL)) {\n            BIO_printf(bio_err,\n                       \"Error checking %s extension section %s\\n\",\n                       gen_x509 ? \"x509\" : \"request\", extsect);\n            goto end;\n        }\n    }\n    if (addext_conf != NULL) {\n        /* Check syntax of command line extensions */\n        X509V3_CTX ctx;\n\n        X509V3_set_ctx_test(&ctx);\n        X509V3_set_nconf(&ctx, req_conf);\n        if (!X509V3_EXT_add_nconf(addext_conf, &ctx, \"default\", NULL)) {\n            BIO_printf(bio_err, \"Error checking extensions defined using -addext\\n\");\n            goto end;\n        }\n    }\n\n    if (passin == NULL)\n        passin = nofree_passin =\n            app_conf_try_string(req_conf, section, \"input_password\");\n\n    if (passout == NULL)\n        passout = nofree_passout =\n            app_conf_try_string(req_conf, section, \"output_password\");\n\n    p = app_conf_try_string(req_conf, section, STRING_MASK);\n    if (p != NULL && !ASN1_STRING_set_default_mask_asc(p)) {\n        BIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", p);\n        goto end;\n    }\n\n    if (chtype != MBSTRING_UTF8) {\n        p = app_conf_try_string(req_conf, section, UTF8_IN);\n        if (p != NULL && strcmp(p, \"yes\") == 0)\n            chtype = MBSTRING_UTF8;\n    }\n\n    if (keyfile != NULL) {\n        pkey = load_key(keyfile, keyform, 0, passin, e, \"private key\");\n        if (pkey == NULL)\n            goto end;\n        app_RAND_load_conf(req_conf, section);\n    }\n    if (keyalg != NULL && pkey != NULL) {\n        BIO_printf(bio_err,\n                   \"Warning: Not generating key via given -newkey option since -key is given\\n\");\n        /* Better throw an error in this case */\n    }\n    if (newreq && pkey == NULL) {\n        app_RAND_load_conf(req_conf, section);\n\n        if (!app_conf_try_number(req_conf, section, BITS, &newkey_len))\n            newkey_len = DEFAULT_KEY_LENGTH;\n\n        genctx = set_keygen_ctx(keyalg, &keyalgstr, &newkey_len, gen_eng);\n        if (genctx == NULL)\n            goto end;\n\n        if (newkey_len < MIN_KEY_LENGTH\n            && (EVP_PKEY_CTX_is_a(genctx, \"RSA\")\n                || EVP_PKEY_CTX_is_a(genctx, \"RSA-PSS\")\n                || EVP_PKEY_CTX_is_a(genctx, \"DSA\"))) {\n            BIO_printf(bio_err, \"Private key length too short, needs to be at least %d bits, not %ld.\\n\",\n                       MIN_KEY_LENGTH, newkey_len);\n            goto end;\n        }\n\n        if (newkey_len > OPENSSL_RSA_MAX_MODULUS_BITS\n            && (EVP_PKEY_CTX_is_a(genctx, \"RSA\")\n                || EVP_PKEY_CTX_is_a(genctx, \"RSA-PSS\")))\n            BIO_printf(bio_err,\n                       \"Warning: It is not recommended to use more than %d bit for RSA keys.\\n\"\n                       \"         Your key size is %ld! Larger key size may behave not as expected.\\n\",\n                       OPENSSL_RSA_MAX_MODULUS_BITS, newkey_len);\n\n#ifndef OPENSSL_NO_DSA\n        if (EVP_PKEY_CTX_is_a(genctx, \"DSA\")\n                && newkey_len > OPENSSL_DSA_MAX_MODULUS_BITS)\n            BIO_printf(bio_err,\n                       \"Warning: It is not recommended to use more than %d bit for DSA keys.\\n\"\n                       \"         Your key size is %ld! Larger key size may behave not as expected.\\n\",\n                       OPENSSL_DSA_MAX_MODULUS_BITS, newkey_len);\n#endif\n\n        if (pkeyopts != NULL) {\n            char *genopt;\n            for (i = 0; i < sk_OPENSSL_STRING_num(pkeyopts); i++) {\n                genopt = sk_OPENSSL_STRING_value(pkeyopts, i);\n                if (pkey_ctrl_string(genctx, genopt) <= 0) {\n                    BIO_printf(bio_err, \"Key parameter error \\\"%s\\\"\\n\", genopt);\n                    goto end;\n                }\n            }\n        }\n\n        EVP_PKEY_CTX_set_app_data(genctx, bio_err);\n        if (progress)\n            EVP_PKEY_CTX_set_cb(genctx, progress_cb);\n\n        pkey = app_keygen(genctx, keyalgstr, newkey_len, verbose);\n        if (pkey == NULL)\n            goto end;\n\n        EVP_PKEY_CTX_free(genctx);\n        genctx = NULL;\n    }\n    if (keyout == NULL && keyfile == NULL)\n        keyout = app_conf_try_string(req_conf, section, KEYFILE);\n\n    if (pkey != NULL && (keyfile == NULL || keyout != NULL)) {\n        if (verbose) {\n            BIO_printf(bio_err, \"Writing private key to \");\n            if (keyout == NULL)\n                BIO_printf(bio_err, \"stdout\\n\");\n            else\n                BIO_printf(bio_err, \"'%s'\\n\", keyout);\n        }\n        out = bio_open_owner(keyout, outformat, newreq);\n        if (out == NULL)\n            goto end;\n\n        p = app_conf_try_string(req_conf, section, \"encrypt_rsa_key\");\n        if (p == NULL)\n            p = app_conf_try_string(req_conf, section, \"encrypt_key\");\n        if (p != NULL && strcmp(p, \"no\") == 0)\n            cipher = NULL;\n        if (noenc)\n            cipher = NULL;\n\n        i = 0;\n loop:\n        if (!PEM_write_bio_PrivateKey(out, pkey, cipher,\n                                      NULL, 0, NULL, passout)) {\n            if ((ERR_GET_REASON(ERR_peek_error()) ==\n                 PEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3)) {\n                ERR_clear_error();\n                i++;\n                goto loop;\n            }\n            goto end;\n        }\n        BIO_free_all(out);\n        out = NULL;\n        BIO_printf(bio_err, \"-----\\n\");\n    }\n\n    /*\n     * subj is expected to be in the format /type0=value0/type1=value1/type2=...\n     * where characters may be escaped by \\\n     */\n    if (subj != NULL\n            && (fsubj = parse_name(subj, chtype, multirdn, \"subject\")) == NULL)\n        goto end;\n\n    if (!newreq) {\n        if (keyfile != NULL)\n            BIO_printf(bio_err,\n                       \"Warning: Not placing -key in cert or request since request is used\\n\");\n        req = load_csr_autofmt(infile /* if NULL, reads from stdin */,\n                               informat, vfyopts, \"X509 request\");\n        if (req == NULL)\n            goto end;\n    } else if (infile != NULL) {\n        BIO_printf(bio_err,\n                   \"Warning: Ignoring -in option since -new or -newkey or -precert is given\\n\");\n        /* Better throw an error in this case, as done in the x509 app */\n    }\n\n    if (CAkeyfile == NULL)\n        CAkeyfile = CAfile;\n    if (CAkeyfile != NULL) {\n        if (CAfile == NULL) {\n            BIO_printf(bio_err,\n                       \"Warning: Ignoring -CAkey option since no -CA option is given\\n\");\n        } else {\n            if ((CAkey = load_key(CAkeyfile, FORMAT_UNDEF,\n                                  0, passin, e,\n                                  CAkeyfile != CAfile\n                                  ? \"issuer private key from -CAkey arg\"\n                                  : \"issuer private key from -CA arg\")) == NULL)\n                goto end;\n        }\n    }\n    if (CAfile != NULL) {\n        if ((CAcert = load_cert_pass(CAfile, FORMAT_UNDEF, 1, passin,\n                                     \"issuer cert from -CA arg\")) == NULL)\n            goto end;\n        if (!X509_check_private_key(CAcert, CAkey)) {\n            BIO_printf(bio_err,\n                       \"Issuer CA certificate and key do not match\\n\");\n            goto end;\n        }\n    }\n    if (newreq || gen_x509) {\n        if (CAcert == NULL && pkey == NULL) {\n            BIO_printf(bio_err, \"Must provide a signature key using -key or\"\n                \" provide -CA / -CAkey\\n\");\n            goto end;\n        }\n\n        if (req == NULL) {\n            req = X509_REQ_new_ex(app_get0_libctx(), app_get0_propq());\n            if (req == NULL) {\n                goto end;\n            }\n\n            if (!make_REQ(req, pkey, fsubj, multirdn, !gen_x509, chtype)) {\n                BIO_printf(bio_err, \"Error making certificate request\\n\");\n                goto end;\n            }\n            /* Note that -x509 can take over -key and -subj option values. */\n        }\n        if (gen_x509) {\n            EVP_PKEY *pub_key = X509_REQ_get0_pubkey(req);\n            EVP_PKEY *issuer_key = CAcert != NULL ? CAkey : pkey;\n            X509V3_CTX ext_ctx;\n            X509_NAME *issuer = CAcert != NULL ? X509_get_subject_name(CAcert) :\n                X509_REQ_get_subject_name(req);\n            X509_NAME *n_subj = fsubj != NULL ? fsubj :\n                X509_REQ_get_subject_name(req);\n\n            if (CAcert != NULL && keyfile != NULL)\n                BIO_printf(bio_err,\n                           \"Warning: Not using -key or -newkey for signing since -CA option is given\\n\");\n\n            if ((new_x509 = X509_new_ex(app_get0_libctx(),\n                                        app_get0_propq())) == NULL)\n                goto end;\n\n            if (serial != NULL) {\n                if (!X509_set_serialNumber(new_x509, serial))\n                    goto end;\n            } else {\n                if (!rand_serial(NULL, X509_get_serialNumber(new_x509)))\n                    goto end;\n            }\n\n            if (!X509_set_issuer_name(new_x509, issuer))\n                goto end;\n            if (days == UNSET_DAYS)\n                days = DEFAULT_DAYS;\n            else if (not_after != NULL)\n                BIO_printf(bio_err,\"Warning: -not_after option overriding -days option\\n\");\n            if (!set_cert_times(new_x509, not_before, not_after, days, 1))\n                goto end;\n            if (!X509_set_subject_name(new_x509, n_subj))\n                goto end;\n            if (!pub_key || !X509_set_pubkey(new_x509, pub_key))\n                goto end;\n            if (ext_copy == EXT_COPY_UNSET) {\n                if (infile != NULL)\n                    BIO_printf(bio_err, \"Warning: No -copy_extensions given; ignoring any extensions in the request\\n\");\n            } else if (!copy_extensions(new_x509, req, ext_copy)) {\n                BIO_printf(bio_err, \"Error copying extensions from request\\n\");\n                goto end;\n            }\n\n            /* Set up V3 context struct */\n            X509V3_set_ctx(&ext_ctx, CAcert != NULL ? CAcert : new_x509,\n                           new_x509, NULL, NULL, X509V3_CTX_REPLACE);\n            /* prepare fallback for AKID, but only if issuer cert == new_x509 */\n            if (CAcert == NULL) {\n                if (!X509V3_set_issuer_pkey(&ext_ctx, issuer_key))\n                    goto end;\n                if (!cert_matches_key(new_x509, issuer_key))\n                    BIO_printf(bio_err,\n                               \"Warning: Signature key and public key of cert do not match\\n\");\n            }\n            X509V3_set_nconf(&ext_ctx, req_conf);\n\n            /* Add extensions */\n            if (extsect != NULL\n                && !X509V3_EXT_add_nconf(req_conf, &ext_ctx, extsect, new_x509)) {\n                BIO_printf(bio_err, \"Error adding x509 extensions from section %s\\n\",\n                           extsect);\n                goto end;\n            }\n            if (addext_conf != NULL\n                && !X509V3_EXT_add_nconf(addext_conf, &ext_ctx, \"default\",\n                                         new_x509)) {\n                BIO_printf(bio_err, \"Error adding x509 extensions defined via -addext\\n\");\n                goto end;\n            }\n\n            /* If a pre-cert was requested, we need to add a poison extension */\n            if (precert) {\n                if (X509_add1_ext_i2d(new_x509, NID_ct_precert_poison,\n                                      NULL, 1, 0) != 1) {\n                    BIO_printf(bio_err, \"Error adding poison extension\\n\");\n                    goto end;\n                }\n            }\n\n            i = do_X509_sign(new_x509, x509v1, issuer_key, digest, sigopts,\n                             &ext_ctx);\n            if (!i)\n                goto end;\n        } else {\n            X509V3_CTX ext_ctx;\n\n            if (precert) {\n                BIO_printf(bio_err,\n                           \"Warning: Ignoring -precert flag since no cert is produced\\n\");\n            }\n            /* Set up V3 context struct */\n            X509V3_set_ctx(&ext_ctx, NULL, NULL, req, NULL, X509V3_CTX_REPLACE);\n            X509V3_set_nconf(&ext_ctx, req_conf);\n\n            /* Add extensions */\n            if (extsect != NULL\n                && !X509V3_EXT_REQ_add_nconf(req_conf, &ext_ctx, extsect, req)) {\n                BIO_printf(bio_err, \"Error adding request extensions from section %s\\n\",\n                           extsect);\n                goto end;\n            }\n            if (addext_conf != NULL\n                && !X509V3_EXT_REQ_add_nconf(addext_conf, &ext_ctx, \"default\",\n                                             req)) {\n                BIO_printf(bio_err, \"Error adding request extensions defined via -addext\\n\");\n                goto end;\n            }\n            i = do_X509_REQ_sign(req, pkey, digest, sigopts);\n            if (!i)\n                goto end;\n        }\n    }\n\n    if (subj != NULL && !newreq && !gen_x509) {\n        if (verbose) {\n            BIO_printf(out, \"Modifying subject of certificate request\\n\");\n            print_name(out, \"Old subject=\", X509_REQ_get_subject_name(req));\n        }\n\n        if (!X509_REQ_set_subject_name(req, fsubj)) {\n            BIO_printf(bio_err, \"Error modifying subject of certificate request\\n\");\n            goto end;\n        }\n\n        if (verbose) {\n            print_name(out, \"New subject=\", X509_REQ_get_subject_name(req));\n        }\n    }\n\n    if (verify) {\n        EVP_PKEY *tpubkey = pkey;\n\n        if (tpubkey == NULL) {\n            tpubkey = X509_REQ_get0_pubkey(req);\n            if (tpubkey == NULL)\n                goto end;\n        }\n\n        i = do_X509_REQ_verify(req, tpubkey, vfyopts);\n\n        if (i < 0)\n            goto end;\n        if (i == 0) {\n            BIO_printf(bio_err, \"Certificate request self-signature verify failure\\n\");\n\t    goto end;\n        } else /* i > 0 */\n            BIO_printf(bio_out, \"Certificate request self-signature verify OK\\n\");\n    }\n\n    if (noout && !text && !modulus && !subject && !pubkey) {\n        ret = 0;\n        goto end;\n    }\n\n    out = bio_open_default(outfile,\n                           keyout != NULL && outfile != NULL &&\n                           strcmp(keyout, outfile) == 0 ? 'a' : 'w',\n                           outformat);\n    if (out == NULL)\n        goto end;\n\n    if (pubkey) {\n        EVP_PKEY *tpubkey = X509_REQ_get0_pubkey(req);\n\n        if (tpubkey == NULL) {\n            BIO_printf(bio_err, \"Error getting public key\\n\");\n            goto end;\n        }\n        PEM_write_bio_PUBKEY(out, tpubkey);\n    }\n\n    if (text) {\n        if (gen_x509)\n            ret = X509_print_ex(out, new_x509, get_nameopt(), reqflag);\n        else\n            ret = X509_REQ_print_ex(out, req, get_nameopt(), reqflag);\n\n        if (ret == 0) {\n            if (gen_x509)\n                BIO_printf(bio_err, \"Error printing certificate\\n\");\n            else\n                BIO_printf(bio_err, \"Error printing certificate request\\n\");\n            goto end;\n        }\n    }\n\n    if (subject) {\n        print_name(out, \"subject=\", gen_x509\n                   ? X509_get_subject_name(new_x509)\n                   : X509_REQ_get_subject_name(req));\n    }\n\n    if (modulus) {\n        EVP_PKEY *tpubkey;\n\n        if (gen_x509)\n            tpubkey = X509_get0_pubkey(new_x509);\n        else\n            tpubkey = X509_REQ_get0_pubkey(req);\n        if (tpubkey == NULL) {\n            BIO_puts(bio_err, \"Modulus is unavailable\\n\");\n            goto end;\n        }\n        BIO_puts(out, \"Modulus=\");\n        if (EVP_PKEY_is_a(tpubkey, \"RSA\") || EVP_PKEY_is_a(tpubkey, \"RSA-PSS\")) {\n            BIGNUM *n = NULL;\n\n            if (!EVP_PKEY_get_bn_param(tpubkey, \"n\", &n))\n                goto end;\n            BN_print(out, n);\n            BN_free(n);\n        } else {\n            BIO_puts(out, \"Wrong Algorithm type\");\n        }\n        BIO_puts(out, \"\\n\");\n    }\n\n    if (!noout && !gen_x509) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_X509_REQ_bio(out, req);\n        else if (newhdr)\n            i = PEM_write_bio_X509_REQ_NEW(out, req);\n        else\n            i = PEM_write_bio_X509_REQ(out, req);\n        if (!i) {\n            BIO_printf(bio_err, \"Unable to write certificate request\\n\");\n            goto end;\n        }\n    }\n    if (!noout && gen_x509 && new_x509 != NULL) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_X509_bio(out, new_x509);\n        else\n            i = PEM_write_bio_X509(out, new_x509);\n        if (!i) {\n            BIO_printf(bio_err, \"Unable to write X509 certificate\\n\");\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret) {\n        ERR_print_errors(bio_err);\n    }\n    NCONF_free(req_conf);\n    NCONF_free(addext_conf);\n    BIO_free(addext_bio);\n    BIO_free_all(out);\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(genctx);\n    sk_OPENSSL_STRING_free(pkeyopts);\n    sk_OPENSSL_STRING_free(sigopts);\n    sk_OPENSSL_STRING_free(vfyopts);\n    lh_OPENSSL_STRING_doall(addexts, exts_cleanup);\n    lh_OPENSSL_STRING_free(addexts);\n#ifndef OPENSSL_NO_ENGINE\n    release_engine(gen_eng);\n#endif\n    OPENSSL_free(keyalgstr);\n    X509_REQ_free(req);\n    X509_NAME_free(fsubj);\n    X509_free(new_x509);\n    X509_free(CAcert);\n    EVP_PKEY_free(CAkey);\n    ASN1_INTEGER_free(serial);\n    release_engine(e);\n    if (passin != nofree_passin)\n        OPENSSL_free(passin);\n    if (passout != nofree_passout)\n        OPENSSL_free(passout);\n    return ret;\n}",
            "int X509_print_ex(BIO *bp, X509 *x, unsigned long nmflags,\n                  unsigned long cflag)\n{\n    long l;\n    int ret = 0;\n    char mlch = ' ';\n    int nmindent = 0, printok = 0;\n    EVP_PKEY *pkey = NULL;\n\n    if ((nmflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {\n        mlch = '\\n';\n        nmindent = 12;\n    }\n\n    if (nmflags == XN_FLAG_COMPAT)\n        printok = 1;\n\n    if (!(cflag & X509_FLAG_NO_HEADER)) {\n        if (BIO_write(bp, \"Certificate:\\n\", 13) <= 0)\n            goto err;\n        if (BIO_write(bp, \"    Data:\\n\", 10) <= 0)\n            goto err;\n    }\n    if (!(cflag & X509_FLAG_NO_VERSION)) {\n        l = X509_get_version(x);\n        if (l >= X509_VERSION_1 && l <= X509_VERSION_3) {\n            if (BIO_printf(bp, \"%8sVersion: %ld (0x%lx)\\n\", \"\", l + 1, (unsigned long)l) <= 0)\n                goto err;\n        } else {\n            if (BIO_printf(bp, \"%8sVersion: Unknown (%ld)\\n\", \"\", l) <= 0)\n                goto err;\n        }\n    }\n    if (!(cflag & X509_FLAG_NO_SERIAL)) {\n        const ASN1_INTEGER *bs = X509_get0_serialNumber(x);\n\n        if (BIO_write(bp, \"        Serial Number:\", 22) <= 0)\n            goto err;\n        if (ossl_serial_number_print(bp, bs, 12) != 0)\n            goto err;\n        if (BIO_puts(bp, \"\\n\") <= 0)\n            goto err;\n    }\n\n    if (!(cflag & X509_FLAG_NO_SIGNAME)) {\n        const X509_ALGOR *tsig_alg = X509_get0_tbs_sigalg(x);\n\n        if (BIO_puts(bp, \"    \") <= 0)\n            goto err;\n        if (X509_signature_print(bp, tsig_alg, NULL) <= 0)\n            goto err;\n    }\n\n    if (!(cflag & X509_FLAG_NO_ISSUER)) {\n        if (BIO_printf(bp, \"        Issuer:%c\", mlch) <= 0)\n            goto err;\n        if (X509_NAME_print_ex(bp, X509_get_issuer_name(x), nmindent, nmflags)\n            < printok)\n            goto err;\n        if (BIO_write(bp, \"\\n\", 1) <= 0)\n            goto err;\n    }\n    if (!(cflag & X509_FLAG_NO_VALIDITY)) {\n        if (BIO_write(bp, \"        Validity\\n\", 17) <= 0)\n            goto err;\n        if (BIO_write(bp, \"            Not Before: \", 24) <= 0)\n            goto err;\n        if (ossl_asn1_time_print_ex(bp, X509_get0_notBefore(x), ASN1_DTFLGS_RFC822) == 0)\n            goto err;\n        if (BIO_write(bp, \"\\n            Not After : \", 25) <= 0)\n            goto err;\n        if (ossl_asn1_time_print_ex(bp, X509_get0_notAfter(x), ASN1_DTFLGS_RFC822) == 0)\n            goto err;\n        if (BIO_write(bp, \"\\n\", 1) <= 0)\n            goto err;\n    }\n    if (!(cflag & X509_FLAG_NO_SUBJECT)) {\n        if (BIO_printf(bp, \"        Subject:%c\", mlch) <= 0)\n            goto err;\n        if (X509_NAME_print_ex\n            (bp, X509_get_subject_name(x), nmindent, nmflags) < printok)\n            goto err;\n        if (BIO_write(bp, \"\\n\", 1) <= 0)\n            goto err;\n    }\n    if (!(cflag & X509_FLAG_NO_PUBKEY)) {\n        X509_PUBKEY *xpkey = X509_get_X509_PUBKEY(x);\n        ASN1_OBJECT *xpoid;\n        X509_PUBKEY_get0_param(&xpoid, NULL, NULL, NULL, xpkey);\n        if (BIO_write(bp, \"        Subject Public Key Info:\\n\", 33) <= 0)\n            goto err;\n        if (BIO_printf(bp, \"%12sPublic Key Algorithm: \", \"\") <= 0)\n            goto err;\n        if (i2a_ASN1_OBJECT(bp, xpoid) <= 0)\n            goto err;\n        if (BIO_puts(bp, \"\\n\") <= 0)\n            goto err;\n\n        pkey = X509_get0_pubkey(x);\n        if (pkey == NULL) {\n            BIO_printf(bp, \"%12sUnable to load Public Key\\n\", \"\");\n            ERR_print_errors(bp);\n        } else {\n            EVP_PKEY_print_public(bp, pkey, 16, NULL);\n        }\n    }\n\n    if (!(cflag & X509_FLAG_NO_IDS)) {\n        const ASN1_BIT_STRING *iuid, *suid;\n        X509_get0_uids(x, &iuid, &suid);\n        if (iuid != NULL) {\n            if (BIO_printf(bp, \"%8sIssuer Unique ID: \", \"\") <= 0)\n                goto err;\n            if (!X509_signature_dump(bp, iuid, 12))\n                goto err;\n        }\n        if (suid != NULL) {\n            if (BIO_printf(bp, \"%8sSubject Unique ID: \", \"\") <= 0)\n                goto err;\n            if (!X509_signature_dump(bp, suid, 12))\n                goto err;\n        }\n    }\n\n    if (!(cflag & X509_FLAG_NO_EXTENSIONS)\n        && !X509V3_extensions_print(bp, \"X509v3 extensions\",\n                                    X509_get0_extensions(x), cflag, 8))\n        goto err;\n\n    if (!(cflag & X509_FLAG_NO_SIGDUMP)) {\n        const X509_ALGOR *sig_alg;\n        const ASN1_BIT_STRING *sig;\n        X509_get0_signature(&sig, &sig_alg, x);\n        if (X509_signature_print(bp, sig_alg, sig) <= 0)\n            goto err;\n    }\n    if (!(cflag & X509_FLAG_NO_AUX)) {\n        if (!X509_aux_print(bp, x, 0))\n            goto err;\n    }\n    ret = 1;\n err:\n    return ret;\n}",
            "int X509_aux_print(BIO *out, X509 *x, int indent)\n{\n    char oidstr[80], first;\n    STACK_OF(ASN1_OBJECT) *trust, *reject;\n    const unsigned char *alias, *keyid;\n    int keyidlen;\n    int i;\n    if (X509_trusted(x) == 0)\n        return 1;\n    trust = X509_get0_trust_objects(x);\n    reject = X509_get0_reject_objects(x);\n    if (trust) {\n        first = 1;\n        BIO_printf(out, \"%*sTrusted Uses:\\n%*s\", indent, \"\", indent + 2, \"\");\n        for (i = 0; i < sk_ASN1_OBJECT_num(trust); i++) {\n            if (!first)\n                BIO_puts(out, \", \");\n            else\n                first = 0;\n            OBJ_obj2txt(oidstr, sizeof(oidstr),\n                        sk_ASN1_OBJECT_value(trust, i), 0);\n            BIO_puts(out, oidstr);\n        }\n        BIO_puts(out, \"\\n\");\n    } else\n        BIO_printf(out, \"%*sNo Trusted Uses.\\n\", indent, \"\");\n    if (reject) {\n        first = 1;\n        BIO_printf(out, \"%*sRejected Uses:\\n%*s\", indent, \"\", indent + 2, \"\");\n        for (i = 0; i < sk_ASN1_OBJECT_num(reject); i++) {\n            if (!first)\n                BIO_puts(out, \", \");\n            else\n                first = 0;\n            OBJ_obj2txt(oidstr, sizeof(oidstr),\n                        sk_ASN1_OBJECT_value(reject, i), 0);\n            BIO_puts(out, oidstr);\n        }\n        BIO_puts(out, \"\\n\");\n    } else\n        BIO_printf(out, \"%*sNo Rejected Uses.\\n\", indent, \"\");\n    alias = X509_alias_get0(x, &i);\n    if (alias)\n        BIO_printf(out, \"%*sAlias: %.*s\\n\", indent, \"\", i, alias);\n    keyid = X509_keyid_get0(x, &keyidlen);\n    if (keyid) {\n        BIO_printf(out, \"%*sKey Id: \", indent, \"\");\n        for (i = 0; i < keyidlen; i++)\n            BIO_printf(out, \"%s%02X\", i ? \":\" : \"\", keyid[i]);\n        BIO_write(out, \"\\n\", 1);\n    }\n    return 1;\n}"
        ],
        "sink": "ret = X509_print_ex(out, new_x509, get_nameopt(), reqflag);",
        "final_sink": "    trust = X509_get0_trust_objects(x);",
        "source": [
            "        cmd = sk_OPENSSL_STRING_value(cmds, loop);"
        ],
        "index": 40
    },
    {
        "prt": "req",
        "function_call": [
            "int req_main(int argc, char **argv)\n{\n    ASN1_INTEGER *serial = NULL;\n    BIO *out = NULL;\n    ENGINE *e = NULL, *gen_eng = NULL;\n    EVP_PKEY *pkey = NULL, *CAkey = NULL;\n    EVP_PKEY_CTX *genctx = NULL;\n    STACK_OF(OPENSSL_STRING) *pkeyopts = NULL, *sigopts = NULL, *vfyopts = NULL;\n    LHASH_OF(OPENSSL_STRING) *addexts = NULL;\n    X509 *new_x509 = NULL, *CAcert = NULL;\n    X509_REQ *req = NULL;\n    const EVP_CIPHER *cipher = NULL;\n    int ext_copy = EXT_COPY_UNSET;\n    BIO *addext_bio = NULL;\n    char *extsect = NULL;\n    const char *infile = NULL, *CAfile = NULL, *CAkeyfile = NULL;\n    char *outfile = NULL, *keyfile = NULL, *digest = NULL;\n    char *keyalgstr = NULL, *p, *prog, *passargin = NULL, *passargout = NULL;\n    char *passin = NULL, *passout = NULL;\n    char *nofree_passin = NULL, *nofree_passout = NULL;\n    char *subj = NULL;\n    X509_NAME *fsubj = NULL;\n    char *template = default_config_file, *keyout = NULL;\n    const char *keyalg = NULL;\n    OPTION_CHOICE o;\n    char *not_before = NULL, *not_after = NULL;\n    int days = UNSET_DAYS;\n    int ret = 1, gen_x509 = 0, i = 0, newreq = 0, verbose = 0, progress = 1;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, keyform = FORMAT_UNDEF;\n    int modulus = 0, multirdn = 1, verify = 0, noout = 0, text = 0;\n    int noenc = 0, newhdr = 0, subject = 0, pubkey = 0, precert = 0, x509v1 = 0;\n    long newkey_len = -1;\n    unsigned long chtype = MBSTRING_ASC, reqflag = 0;\n\n    cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n\n    opt_set_unknown_name(\"digest\");\n    prog = opt_init(argc, argv, req_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(req_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &informat))\n                goto opthelp;\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &outformat))\n                goto opthelp;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_KEYGEN_ENGINE:\n#ifndef OPENSSL_NO_ENGINE\n            gen_eng = setup_engine(opt_arg(), 0);\n            if (gen_eng == NULL) {\n                BIO_printf(bio_err, \"Can't find keygen engine %s\\n\", *argv);\n                goto opthelp;\n            }\n#endif\n            break;\n        case OPT_KEY:\n            keyfile = opt_arg();\n            break;\n        case OPT_PUBKEY:\n            pubkey = 1;\n            break;\n        case OPT_NEW:\n            newreq = 1;\n            break;\n        case OPT_CONFIG:\n            template = opt_arg();\n            break;\n        case OPT_SECTION:\n            section = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_KEYOUT:\n            keyout = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passargin = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passargout = opt_arg();\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_NEWKEY:\n            keyalg = opt_arg();\n            newreq = 1;\n            break;\n        case OPT_PKEYOPT:\n            if (pkeyopts == NULL)\n                pkeyopts = sk_OPENSSL_STRING_new_null();\n            if (pkeyopts == NULL\n                    || !sk_OPENSSL_STRING_push(pkeyopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_SIGOPT:\n            if (!sigopts)\n                sigopts = sk_OPENSSL_STRING_new_null();\n            if (!sigopts || !sk_OPENSSL_STRING_push(sigopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_VFYOPT:\n            if (!vfyopts)\n                vfyopts = sk_OPENSSL_STRING_new_null();\n            if (!vfyopts || !sk_OPENSSL_STRING_push(vfyopts, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_BATCH:\n            batch = 1;\n            break;\n        case OPT_NEWHDR:\n            newhdr = 1;\n            break;\n        case OPT_MODULUS:\n            modulus = 1;\n            break;\n        case OPT_VERIFY:\n            verify = 1;\n            break;\n        case OPT_NODES:\n        case OPT_NOENC:\n            noenc = 1;\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_VERBOSE:\n            verbose = 1;\n            progress = 1;\n            break;\n        case OPT_QUIET:\n            verbose = 0;\n            progress = 0;\n            break;\n        case OPT_UTF8:\n            chtype = MBSTRING_UTF8;\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_REQOPT:\n            if (!set_cert_ex(&reqflag, opt_arg()))\n                goto opthelp;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_X509V1:\n            x509v1 = 1;\n            /* fall thru */\n        case OPT_X509:\n            gen_x509 = 1;\n            break;\n        case OPT_CA:\n            CAfile = opt_arg();\n            gen_x509 = 1;\n            break;\n        case OPT_CAKEY:\n            CAkeyfile = opt_arg();\n            break;\n        case OPT_NOT_BEFORE:\n            not_before = opt_arg();\n            break;\n        case OPT_NOT_AFTER:\n            not_after = opt_arg();\n            break;\n        case OPT_DAYS:\n            days = atoi(opt_arg());\n            if (days <= UNSET_DAYS) {\n                BIO_printf(bio_err, \"%s: -days parameter arg must be >= -1\\n\",\n                           prog);\n                goto end;\n            }\n            break;\n        case OPT_SET_SERIAL:\n            if (serial != NULL) {\n                BIO_printf(bio_err, \"Serial number supplied twice\\n\");\n                goto opthelp;\n            }\n            serial = s2i_ASN1_INTEGER(NULL, opt_arg());\n            if (serial == NULL)\n                goto opthelp;\n            break;\n        case OPT_SUBJECT:\n            subject = 1;\n            break;\n        case OPT_SUBJ:\n            subj = opt_arg();\n            break;\n        case OPT_MULTIVALUE_RDN:\n            /* obsolete */\n            break;\n        case OPT_COPY_EXTENSIONS:\n            if (!set_ext_copy(&ext_copy, opt_arg())) {\n                BIO_printf(bio_err, \"Invalid extension copy option: \\\"%s\\\"\\n\",\n                           opt_arg());\n                goto end;\n            }\n            break;\n        case OPT_EXTENSIONS:\n        case OPT_REQEXTS:\n            extsect = opt_arg();\n            break;\n        case OPT_ADDEXT:\n            p = opt_arg();\n            if (addexts == NULL) {\n                addexts = lh_OPENSSL_STRING_new(ext_name_hash, ext_name_cmp);\n                addext_bio = BIO_new(BIO_s_mem());\n                if (addexts == NULL || addext_bio == NULL)\n                    goto end;\n            }\n            i = duplicated(addexts, p);\n            if (i == 1)\n                goto end;\n            if (i == -1)\n                BIO_printf(bio_err, \"Internal error handling -addext %s\\n\", p);\n            if (i < 0 || BIO_printf(addext_bio, \"%s\\n\", p) < 0)\n                goto end;\n            break;\n        case OPT_PRECERT:\n            newreq = precert = 1;\n            break;\n        case OPT_CIPHER:\n            cipher = EVP_get_cipherbyname(opt_arg());\n            if (cipher == NULL) {\n                BIO_printf(bio_err, \"Unknown cipher: %s\\n\", opt_arg());\n                goto opthelp;\n            }\n            break;\n        case OPT_MD:\n            digest = opt_unknown();\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n    if (!gen_x509) {\n        if (days != UNSET_DAYS)\n            BIO_printf(bio_err, \"Warning: Ignoring -days without -x509; not generating a certificate\\n\");\n        if (not_before != NULL)\n            BIO_printf(bio_err, \"Warning: Ignoring -not_before without -x509; not generating a certificate\\n\");\n        if (not_after != NULL)\n            BIO_printf(bio_err, \"Warning: Ignoring -not_after without -x509; not generating a certificate\\n\");\n        if (ext_copy == EXT_COPY_NONE)\n            BIO_printf(bio_err, \"Warning: Ignoring -copy_extensions 'none' when -x509 is not given\\n\");\n    }\n    if (infile == NULL) {\n        if (gen_x509)\n            newreq = 1;\n        else if (!newreq && isatty(fileno_stdin()))\n            BIO_printf(bio_err,\n                       \"Warning: Will read cert request from stdin since no -in option is given\\n\");\n    }\n\n    if (!app_passwd(passargin, passargout, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n\n    if ((req_conf = app_load_config_verbose(template, verbose)) == NULL)\n        goto end;\n    if (addext_bio != NULL) {\n        if (verbose)\n            BIO_printf(bio_err,\n                       \"Using additional configuration from -addext options\\n\");\n        if ((addext_conf = app_load_config_bio(addext_bio, NULL)) == NULL)\n            goto end;\n    }\n    if (template != default_config_file && !app_load_modules(req_conf))\n        goto end;\n\n    if (req_conf != NULL) {\n        p = app_conf_try_string(req_conf, NULL, \"oid_file\");\n        if (p != NULL) {\n            BIO *oid_bio = BIO_new_file(p, \"r\");\n\n            if (oid_bio == NULL) {\n                if (verbose)\n                    BIO_printf(bio_err,\n                               \"Problems opening '%s' for extra OIDs\\n\", p);\n            } else {\n                OBJ_create_objects(oid_bio);\n                BIO_free(oid_bio);\n            }\n        }\n    }\n    if (!add_oid_section(req_conf))\n        goto end;\n\n    /* Check that any specified digest is fetchable */\n    if (digest != NULL) {\n        if (!opt_check_md(digest))\n            goto opthelp;\n    } else {\n        /* No digest specified, default to configuration */\n        p = app_conf_try_string(req_conf, section, \"default_md\");\n        if (p != NULL)\n            digest = p;\n    }\n\n    if (extsect == NULL)\n        extsect = app_conf_try_string(req_conf, section,\n                                   gen_x509 ? V3_EXTENSIONS : REQ_EXTENSIONS);\n    if (extsect != NULL) {\n        /* Check syntax of extension section in config file */\n        X509V3_CTX ctx;\n\n        X509V3_set_ctx_test(&ctx);\n        X509V3_set_nconf(&ctx, req_conf);\n        if (!X509V3_EXT_add_nconf(req_conf, &ctx, extsect, NULL)) {\n            BIO_printf(bio_err,\n                       \"Error checking %s extension section %s\\n\",\n                       gen_x509 ? \"x509\" : \"request\", extsect);\n            goto end;\n        }\n    }\n    if (addext_conf != NULL) {\n        /* Check syntax of command line extensions */\n        X509V3_CTX ctx;\n\n        X509V3_set_ctx_test(&ctx);\n        X509V3_set_nconf(&ctx, req_conf);\n        if (!X509V3_EXT_add_nconf(addext_conf, &ctx, \"default\", NULL)) {\n            BIO_printf(bio_err, \"Error checking extensions defined using -addext\\n\");\n            goto end;\n        }\n    }\n\n    if (passin == NULL)\n        passin = nofree_passin =\n            app_conf_try_string(req_conf, section, \"input_password\");\n\n    if (passout == NULL)\n        passout = nofree_passout =\n            app_conf_try_string(req_conf, section, \"output_password\");\n\n    p = app_conf_try_string(req_conf, section, STRING_MASK);\n    if (p != NULL && !ASN1_STRING_set_default_mask_asc(p)) {\n        BIO_printf(bio_err, \"Invalid global string mask setting %s\\n\", p);\n        goto end;\n    }\n\n    if (chtype != MBSTRING_UTF8) {\n        p = app_conf_try_string(req_conf, section, UTF8_IN);\n        if (p != NULL && strcmp(p, \"yes\") == 0)\n            chtype = MBSTRING_UTF8;\n    }\n\n    if (keyfile != NULL) {\n        pkey = load_key(keyfile, keyform, 0, passin, e, \"private key\");\n        if (pkey == NULL)\n            goto end;\n        app_RAND_load_conf(req_conf, section);\n    }\n    if (keyalg != NULL && pkey != NULL) {\n        BIO_printf(bio_err,\n                   \"Warning: Not generating key via given -newkey option since -key is given\\n\");\n        /* Better throw an error in this case */\n    }\n    if (newreq && pkey == NULL) {\n        app_RAND_load_conf(req_conf, section);\n\n        if (!app_conf_try_number(req_conf, section, BITS, &newkey_len))\n            newkey_len = DEFAULT_KEY_LENGTH;\n\n        genctx = set_keygen_ctx(keyalg, &keyalgstr, &newkey_len, gen_eng);\n        if (genctx == NULL)\n            goto end;\n\n        if (newkey_len < MIN_KEY_LENGTH\n            && (EVP_PKEY_CTX_is_a(genctx, \"RSA\")\n                || EVP_PKEY_CTX_is_a(genctx, \"RSA-PSS\")\n                || EVP_PKEY_CTX_is_a(genctx, \"DSA\"))) {\n            BIO_printf(bio_err, \"Private key length too short, needs to be at least %d bits, not %ld.\\n\",\n                       MIN_KEY_LENGTH, newkey_len);\n            goto end;\n        }\n\n        if (newkey_len > OPENSSL_RSA_MAX_MODULUS_BITS\n            && (EVP_PKEY_CTX_is_a(genctx, \"RSA\")\n                || EVP_PKEY_CTX_is_a(genctx, \"RSA-PSS\")))\n            BIO_printf(bio_err,\n                       \"Warning: It is not recommended to use more than %d bit for RSA keys.\\n\"\n                       \"         Your key size is %ld! Larger key size may behave not as expected.\\n\",\n                       OPENSSL_RSA_MAX_MODULUS_BITS, newkey_len);\n\n#ifndef OPENSSL_NO_DSA\n        if (EVP_PKEY_CTX_is_a(genctx, \"DSA\")\n                && newkey_len > OPENSSL_DSA_MAX_MODULUS_BITS)\n            BIO_printf(bio_err,\n                       \"Warning: It is not recommended to use more than %d bit for DSA keys.\\n\"\n                       \"         Your key size is %ld! Larger key size may behave not as expected.\\n\",\n                       OPENSSL_DSA_MAX_MODULUS_BITS, newkey_len);\n#endif\n\n        if (pkeyopts != NULL) {\n            char *genopt;\n            for (i = 0; i < sk_OPENSSL_STRING_num(pkeyopts); i++) {\n                genopt = sk_OPENSSL_STRING_value(pkeyopts, i);\n                if (pkey_ctrl_string(genctx, genopt) <= 0) {\n                    BIO_printf(bio_err, \"Key parameter error \\\"%s\\\"\\n\", genopt);\n                    goto end;\n                }\n            }\n        }\n\n        EVP_PKEY_CTX_set_app_data(genctx, bio_err);\n        if (progress)\n            EVP_PKEY_CTX_set_cb(genctx, progress_cb);\n\n        pkey = app_keygen(genctx, keyalgstr, newkey_len, verbose);\n        if (pkey == NULL)\n            goto end;\n\n        EVP_PKEY_CTX_free(genctx);\n        genctx = NULL;\n    }\n    if (keyout == NULL && keyfile == NULL)\n        keyout = app_conf_try_string(req_conf, section, KEYFILE);\n\n    if (pkey != NULL && (keyfile == NULL || keyout != NULL)) {\n        if (verbose) {\n            BIO_printf(bio_err, \"Writing private key to \");\n            if (keyout == NULL)\n                BIO_printf(bio_err, \"stdout\\n\");\n            else\n                BIO_printf(bio_err, \"'%s'\\n\", keyout);\n        }\n        out = bio_open_owner(keyout, outformat, newreq);\n        if (out == NULL)\n            goto end;\n\n        p = app_conf_try_string(req_conf, section, \"encrypt_rsa_key\");\n        if (p == NULL)\n            p = app_conf_try_string(req_conf, section, \"encrypt_key\");\n        if (p != NULL && strcmp(p, \"no\") == 0)\n            cipher = NULL;\n        if (noenc)\n            cipher = NULL;\n\n        i = 0;\n loop:\n        if (!PEM_write_bio_PrivateKey(out, pkey, cipher,\n                                      NULL, 0, NULL, passout)) {\n            if ((ERR_GET_REASON(ERR_peek_error()) ==\n                 PEM_R_PROBLEMS_GETTING_PASSWORD) && (i < 3)) {\n                ERR_clear_error();\n                i++;\n                goto loop;\n            }\n            goto end;\n        }\n        BIO_free_all(out);\n        out = NULL;\n        BIO_printf(bio_err, \"-----\\n\");\n    }\n\n    /*\n     * subj is expected to be in the format /type0=value0/type1=value1/type2=...\n     * where characters may be escaped by \\\n     */\n    if (subj != NULL\n            && (fsubj = parse_name(subj, chtype, multirdn, \"subject\")) == NULL)\n        goto end;\n\n    if (!newreq) {\n        if (keyfile != NULL)\n            BIO_printf(bio_err,\n                       \"Warning: Not placing -key in cert or request since request is used\\n\");\n        req = load_csr_autofmt(infile /* if NULL, reads from stdin */,\n                               informat, vfyopts, \"X509 request\");\n        if (req == NULL)\n            goto end;\n    } else if (infile != NULL) {\n        BIO_printf(bio_err,\n                   \"Warning: Ignoring -in option since -new or -newkey or -precert is given\\n\");\n        /* Better throw an error in this case, as done in the x509 app */\n    }\n\n    if (CAkeyfile == NULL)\n        CAkeyfile = CAfile;\n    if (CAkeyfile != NULL) {\n        if (CAfile == NULL) {\n            BIO_printf(bio_err,\n                       \"Warning: Ignoring -CAkey option since no -CA option is given\\n\");\n        } else {\n            if ((CAkey = load_key(CAkeyfile, FORMAT_UNDEF,\n                                  0, passin, e,\n                                  CAkeyfile != CAfile\n                                  ? \"issuer private key from -CAkey arg\"\n                                  : \"issuer private key from -CA arg\")) == NULL)\n                goto end;\n        }\n    }\n    if (CAfile != NULL) {\n        if ((CAcert = load_cert_pass(CAfile, FORMAT_UNDEF, 1, passin,\n                                     \"issuer cert from -CA arg\")) == NULL)\n            goto end;\n        if (!X509_check_private_key(CAcert, CAkey)) {\n            BIO_printf(bio_err,\n                       \"Issuer CA certificate and key do not match\\n\");\n            goto end;\n        }\n    }\n    if (newreq || gen_x509) {\n        if (CAcert == NULL && pkey == NULL) {\n            BIO_printf(bio_err, \"Must provide a signature key using -key or\"\n                \" provide -CA / -CAkey\\n\");\n            goto end;\n        }\n\n        if (req == NULL) {\n            req = X509_REQ_new_ex(app_get0_libctx(), app_get0_propq());\n            if (req == NULL) {\n                goto end;\n            }\n\n            if (!make_REQ(req, pkey, fsubj, multirdn, !gen_x509, chtype)) {\n                BIO_printf(bio_err, \"Error making certificate request\\n\");\n                goto end;\n            }\n            /* Note that -x509 can take over -key and -subj option values. */\n        }\n        if (gen_x509) {\n            EVP_PKEY *pub_key = X509_REQ_get0_pubkey(req);\n            EVP_PKEY *issuer_key = CAcert != NULL ? CAkey : pkey;\n            X509V3_CTX ext_ctx;\n            X509_NAME *issuer = CAcert != NULL ? X509_get_subject_name(CAcert) :\n                X509_REQ_get_subject_name(req);\n            X509_NAME *n_subj = fsubj != NULL ? fsubj :\n                X509_REQ_get_subject_name(req);\n\n            if (CAcert != NULL && keyfile != NULL)\n                BIO_printf(bio_err,\n                           \"Warning: Not using -key or -newkey for signing since -CA option is given\\n\");\n\n            if ((new_x509 = X509_new_ex(app_get0_libctx(),\n                                        app_get0_propq())) == NULL)\n                goto end;\n\n            if (serial != NULL) {\n                if (!X509_set_serialNumber(new_x509, serial))\n                    goto end;\n            } else {\n                if (!rand_serial(NULL, X509_get_serialNumber(new_x509)))\n                    goto end;\n            }\n\n            if (!X509_set_issuer_name(new_x509, issuer))\n                goto end;\n            if (days == UNSET_DAYS)\n                days = DEFAULT_DAYS;\n            else if (not_after != NULL)\n                BIO_printf(bio_err,\"Warning: -not_after option overriding -days option\\n\");\n            if (!set_cert_times(new_x509, not_before, not_after, days, 1))\n                goto end;\n            if (!X509_set_subject_name(new_x509, n_subj))\n                goto end;\n            if (!pub_key || !X509_set_pubkey(new_x509, pub_key))\n                goto end;\n            if (ext_copy == EXT_COPY_UNSET) {\n                if (infile != NULL)\n                    BIO_printf(bio_err, \"Warning: No -copy_extensions given; ignoring any extensions in the request\\n\");\n            } else if (!copy_extensions(new_x509, req, ext_copy)) {\n                BIO_printf(bio_err, \"Error copying extensions from request\\n\");\n                goto end;\n            }\n\n            /* Set up V3 context struct */\n            X509V3_set_ctx(&ext_ctx, CAcert != NULL ? CAcert : new_x509,\n                           new_x509, NULL, NULL, X509V3_CTX_REPLACE);\n            /* prepare fallback for AKID, but only if issuer cert == new_x509 */\n            if (CAcert == NULL) {\n                if (!X509V3_set_issuer_pkey(&ext_ctx, issuer_key))\n                    goto end;\n                if (!cert_matches_key(new_x509, issuer_key))\n                    BIO_printf(bio_err,\n                               \"Warning: Signature key and public key of cert do not match\\n\");\n            }\n            X509V3_set_nconf(&ext_ctx, req_conf);\n\n            /* Add extensions */\n            if (extsect != NULL\n                && !X509V3_EXT_add_nconf(req_conf, &ext_ctx, extsect, new_x509)) {\n                BIO_printf(bio_err, \"Error adding x509 extensions from section %s\\n\",\n                           extsect);\n                goto end;\n            }\n            if (addext_conf != NULL\n                && !X509V3_EXT_add_nconf(addext_conf, &ext_ctx, \"default\",\n                                         new_x509)) {\n                BIO_printf(bio_err, \"Error adding x509 extensions defined via -addext\\n\");\n                goto end;\n            }\n\n            /* If a pre-cert was requested, we need to add a poison extension */\n            if (precert) {\n                if (X509_add1_ext_i2d(new_x509, NID_ct_precert_poison,\n                                      NULL, 1, 0) != 1) {\n                    BIO_printf(bio_err, \"Error adding poison extension\\n\");\n                    goto end;\n                }\n            }\n\n            i = do_X509_sign(new_x509, x509v1, issuer_key, digest, sigopts,\n                             &ext_ctx);\n            if (!i)\n                goto end;\n        } else {\n            X509V3_CTX ext_ctx;\n\n            if (precert) {\n                BIO_printf(bio_err,\n                           \"Warning: Ignoring -precert flag since no cert is produced\\n\");\n            }\n            /* Set up V3 context struct */\n            X509V3_set_ctx(&ext_ctx, NULL, NULL, req, NULL, X509V3_CTX_REPLACE);\n            X509V3_set_nconf(&ext_ctx, req_conf);\n\n            /* Add extensions */\n            if (extsect != NULL\n                && !X509V3_EXT_REQ_add_nconf(req_conf, &ext_ctx, extsect, req)) {\n                BIO_printf(bio_err, \"Error adding request extensions from section %s\\n\",\n                           extsect);\n                goto end;\n            }\n            if (addext_conf != NULL\n                && !X509V3_EXT_REQ_add_nconf(addext_conf, &ext_ctx, \"default\",\n                                             req)) {\n                BIO_printf(bio_err, \"Error adding request extensions defined via -addext\\n\");\n                goto end;\n            }\n            i = do_X509_REQ_sign(req, pkey, digest, sigopts);\n            if (!i)\n                goto end;\n        }\n    }\n\n    if (subj != NULL && !newreq && !gen_x509) {\n        if (verbose) {\n            BIO_printf(out, \"Modifying subject of certificate request\\n\");\n            print_name(out, \"Old subject=\", X509_REQ_get_subject_name(req));\n        }\n\n        if (!X509_REQ_set_subject_name(req, fsubj)) {\n            BIO_printf(bio_err, \"Error modifying subject of certificate request\\n\");\n            goto end;\n        }\n\n        if (verbose) {\n            print_name(out, \"New subject=\", X509_REQ_get_subject_name(req));\n        }\n    }\n\n    if (verify) {\n        EVP_PKEY *tpubkey = pkey;\n\n        if (tpubkey == NULL) {\n            tpubkey = X509_REQ_get0_pubkey(req);\n            if (tpubkey == NULL)\n                goto end;\n        }\n\n        i = do_X509_REQ_verify(req, tpubkey, vfyopts);\n\n        if (i < 0)\n            goto end;\n        if (i == 0) {\n            BIO_printf(bio_err, \"Certificate request self-signature verify failure\\n\");\n\t    goto end;\n        } else /* i > 0 */\n            BIO_printf(bio_out, \"Certificate request self-signature verify OK\\n\");\n    }\n\n    if (noout && !text && !modulus && !subject && !pubkey) {\n        ret = 0;\n        goto end;\n    }\n\n    out = bio_open_default(outfile,\n                           keyout != NULL && outfile != NULL &&\n                           strcmp(keyout, outfile) == 0 ? 'a' : 'w',\n                           outformat);\n    if (out == NULL)\n        goto end;\n\n    if (pubkey) {\n        EVP_PKEY *tpubkey = X509_REQ_get0_pubkey(req);\n\n        if (tpubkey == NULL) {\n            BIO_printf(bio_err, \"Error getting public key\\n\");\n            goto end;\n        }\n        PEM_write_bio_PUBKEY(out, tpubkey);\n    }\n\n    if (text) {\n        if (gen_x509)\n            ret = X509_print_ex(out, new_x509, get_nameopt(), reqflag);\n        else\n            ret = X509_REQ_print_ex(out, req, get_nameopt(), reqflag);\n\n        if (ret == 0) {\n            if (gen_x509)\n                BIO_printf(bio_err, \"Error printing certificate\\n\");\n            else\n                BIO_printf(bio_err, \"Error printing certificate request\\n\");\n            goto end;\n        }\n    }\n\n    if (subject) {\n        print_name(out, \"subject=\", gen_x509\n                   ? X509_get_subject_name(new_x509)\n                   : X509_REQ_get_subject_name(req));\n    }\n\n    if (modulus) {\n        EVP_PKEY *tpubkey;\n\n        if (gen_x509)\n            tpubkey = X509_get0_pubkey(new_x509);\n        else\n            tpubkey = X509_REQ_get0_pubkey(req);\n        if (tpubkey == NULL) {\n            BIO_puts(bio_err, \"Modulus is unavailable\\n\");\n            goto end;\n        }\n        BIO_puts(out, \"Modulus=\");\n        if (EVP_PKEY_is_a(tpubkey, \"RSA\") || EVP_PKEY_is_a(tpubkey, \"RSA-PSS\")) {\n            BIGNUM *n = NULL;\n\n            if (!EVP_PKEY_get_bn_param(tpubkey, \"n\", &n))\n                goto end;\n            BN_print(out, n);\n            BN_free(n);\n        } else {\n            BIO_puts(out, \"Wrong Algorithm type\");\n        }\n        BIO_puts(out, \"\\n\");\n    }\n\n    if (!noout && !gen_x509) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_X509_REQ_bio(out, req);\n        else if (newhdr)\n            i = PEM_write_bio_X509_REQ_NEW(out, req);\n        else\n            i = PEM_write_bio_X509_REQ(out, req);\n        if (!i) {\n            BIO_printf(bio_err, \"Unable to write certificate request\\n\");\n            goto end;\n        }\n    }\n    if (!noout && gen_x509 && new_x509 != NULL) {\n        if (outformat == FORMAT_ASN1)\n            i = i2d_X509_bio(out, new_x509);\n        else\n            i = PEM_write_bio_X509(out, new_x509);\n        if (!i) {\n            BIO_printf(bio_err, \"Unable to write X509 certificate\\n\");\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret) {\n        ERR_print_errors(bio_err);\n    }\n    NCONF_free(req_conf);\n    NCONF_free(addext_conf);\n    BIO_free(addext_bio);\n    BIO_free_all(out);\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(genctx);\n    sk_OPENSSL_STRING_free(pkeyopts);\n    sk_OPENSSL_STRING_free(sigopts);\n    sk_OPENSSL_STRING_free(vfyopts);\n    lh_OPENSSL_STRING_doall(addexts, exts_cleanup);\n    lh_OPENSSL_STRING_free(addexts);\n#ifndef OPENSSL_NO_ENGINE\n    release_engine(gen_eng);\n#endif\n    OPENSSL_free(keyalgstr);\n    X509_REQ_free(req);\n    X509_NAME_free(fsubj);\n    X509_free(new_x509);\n    X509_free(CAcert);\n    EVP_PKEY_free(CAkey);\n    ASN1_INTEGER_free(serial);\n    release_engine(e);\n    if (passin != nofree_passin)\n        OPENSSL_free(passin);\n    if (passout != nofree_passout)\n        OPENSSL_free(passout);\n    return ret;\n}",
            "int X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflags,\n                      unsigned long cflag)\n{\n    long l;\n    int i;\n    EVP_PKEY *pkey;\n    STACK_OF(X509_EXTENSION) *exts;\n    char mlch = ' ';\n    int nmindent = 0, printok = 0;\n\n    if ((nmflags & XN_FLAG_SEP_MASK) == XN_FLAG_SEP_MULTILINE) {\n        mlch = '\\n';\n        nmindent = 12;\n    }\n\n    if (nmflags == XN_FLAG_COMPAT)\n        printok = 1;\n\n    if (!(cflag & X509_FLAG_NO_HEADER)) {\n        if (BIO_write(bp, \"Certificate Request:\\n\", 21) <= 0)\n            goto err;\n        if (BIO_write(bp, \"    Data:\\n\", 10) <= 0)\n            goto err;\n    }\n    if (!(cflag & X509_FLAG_NO_VERSION)) {\n        l = X509_REQ_get_version(x);\n        if (l == X509_REQ_VERSION_1) {\n            if (BIO_printf(bp, \"%8sVersion: %ld (0x%lx)\\n\", \"\", l + 1, (unsigned long)l) <= 0)\n                goto err;\n        } else {\n            if (BIO_printf(bp, \"%8sVersion: Unknown (%ld)\\n\", \"\", l) <= 0)\n                goto err;\n        }\n    }\n    if (!(cflag & X509_FLAG_NO_SUBJECT)) {\n        if (BIO_printf(bp, \"        Subject:%c\", mlch) <= 0)\n            goto err;\n        if (X509_NAME_print_ex(bp, X509_REQ_get_subject_name(x),\n            nmindent, nmflags) < printok)\n            goto err;\n        if (BIO_write(bp, \"\\n\", 1) <= 0)\n            goto err;\n    }\n    if (!(cflag & X509_FLAG_NO_PUBKEY)) {\n        X509_PUBKEY *xpkey;\n        ASN1_OBJECT *koid;\n        if (BIO_write(bp, \"        Subject Public Key Info:\\n\", 33) <= 0)\n            goto err;\n        if (BIO_printf(bp, \"%12sPublic Key Algorithm: \", \"\") <= 0)\n            goto err;\n        xpkey = X509_REQ_get_X509_PUBKEY(x);\n        X509_PUBKEY_get0_param(&koid, NULL, NULL, NULL, xpkey);\n        if (i2a_ASN1_OBJECT(bp, koid) <= 0)\n            goto err;\n        if (BIO_puts(bp, \"\\n\") <= 0)\n            goto err;\n\n        pkey = X509_REQ_get0_pubkey(x);\n        if (pkey == NULL) {\n            if (BIO_printf(bp, \"%12sUnable to load Public Key\\n\", \"\") <= 0)\n                goto err;\n            ERR_print_errors(bp);\n        } else {\n            if (EVP_PKEY_print_public(bp, pkey, 16, NULL) <= 0)\n                goto err;\n        }\n    }\n\n    if (!(cflag & X509_FLAG_NO_ATTRIBUTES)) {\n        /* may not be */\n        if (BIO_printf(bp, \"%8sAttributes:\\n\", \"\") <= 0)\n            goto err;\n\n        if (X509_REQ_get_attr_count(x) == 0) {\n            if (BIO_printf(bp, \"%12s(none)\\n\", \"\") <= 0)\n                goto err;\n        } else {\n            for (i = 0; i < X509_REQ_get_attr_count(x); i++) {\n                ASN1_TYPE *at;\n                X509_ATTRIBUTE *a;\n                ASN1_BIT_STRING *bs = NULL;\n                ASN1_OBJECT *aobj;\n                int j, type = 0, count = 1, ii = 0;\n\n                a = X509_REQ_get_attr(x, i);\n                aobj = X509_ATTRIBUTE_get0_object(a);\n                if (X509_REQ_extension_nid(OBJ_obj2nid(aobj)))\n                    continue;\n                if (BIO_printf(bp, \"%12s\", \"\") <= 0)\n                    goto err;\n                if ((j = i2a_ASN1_OBJECT(bp, aobj)) > 0) {\n                    ii = 0;\n                    count = X509_ATTRIBUTE_count(a);\n                    if (count == 0) {\n                      ERR_raise(ERR_LIB_X509, X509_R_INVALID_ATTRIBUTES);\n                      return 0;\n                    }\n get_next:\n                    at = X509_ATTRIBUTE_get0_type(a, ii);\n                    type = at->type;\n                    bs = at->value.asn1_string;\n                }\n                for (j = 25 - j; j > 0; j--)\n                    if (BIO_write(bp, \" \", 1) != 1)\n                        goto err;\n                if (BIO_puts(bp, \":\") <= 0)\n                    goto err;\n                switch (type) {\n                case V_ASN1_PRINTABLESTRING:\n                case V_ASN1_T61STRING:\n                case V_ASN1_NUMERICSTRING:\n                case V_ASN1_UTF8STRING:\n                case V_ASN1_IA5STRING:\n                    if (BIO_write(bp, (char *)bs->data, bs->length)\n                            != bs->length)\n                        goto err;\n                    if (BIO_puts(bp, \"\\n\") <= 0)\n                        goto err;\n                    break;\n                default:\n                    if (BIO_puts(bp, \"unable to print attribute\\n\") <= 0)\n                        goto err;\n                    break;\n                }\n                if (++ii < count)\n                    goto get_next;\n            }\n        }\n    }\n    if (!(cflag & X509_FLAG_NO_EXTENSIONS)) {\n        exts = X509_REQ_get_extensions(x);\n        if (exts) {\n            if (BIO_printf(bp, \"%12sRequested Extensions:\\n\", \"\") <= 0)\n                goto err;\n            for (i = 0; i < sk_X509_EXTENSION_num(exts); i++) {\n                ASN1_OBJECT *obj;\n                X509_EXTENSION *ex;\n                int critical;\n                ex = sk_X509_EXTENSION_value(exts, i);\n                if (BIO_printf(bp, \"%16s\", \"\") <= 0)\n                    goto err;\n                obj = X509_EXTENSION_get_object(ex);\n                if (i2a_ASN1_OBJECT(bp, obj) <= 0)\n                    goto err;\n                critical = X509_EXTENSION_get_critical(ex);\n                if (BIO_printf(bp, \": %s\\n\", critical ? \"critical\" : \"\") <= 0)\n                    goto err;\n                if (!X509V3_EXT_print(bp, ex, cflag, 20)) {\n                    if (BIO_printf(bp, \"%20s\", \"\") <= 0\n                        || ASN1_STRING_print(bp,\n                                             X509_EXTENSION_get_data(ex)) <= 0)\n                        goto err;\n                }\n                if (BIO_write(bp, \"\\n\", 1) <= 0)\n                    goto err;\n            }\n            sk_X509_EXTENSION_pop_free(exts, X509_EXTENSION_free);\n        }\n    }\n\n    if (!(cflag & X509_FLAG_NO_SIGDUMP)) {\n        const X509_ALGOR *sig_alg;\n        const ASN1_BIT_STRING *sig;\n        X509_REQ_get0_signature(x, &sig, &sig_alg);\n        if (!X509_signature_print(bp, sig_alg, sig))\n            goto err;\n    }\n\n    return 1;\n err:\n    ERR_raise(ERR_LIB_X509, ERR_R_BUF_LIB);\n    return 0;\n}",
            "X509_PUBKEY *X509_REQ_get_X509_PUBKEY(X509_REQ *req)\n{\n    return req->req_info.pubkey;\n}"
        ],
        "sink": "ret = X509_REQ_print_ex(out, req, get_nameopt(), reqflag);",
        "final_sink": "    return req->req_info.pubkey;",
        "source": [
            "        p = sk_OPENSSL_STRING_value(randfiles, i);"
        ],
        "index": 41
    },
    {
        "prt": "ectx",
        "function_call": [
            "int rsa_main(int argc, char **argv)\n{\n    ENGINE *e = NULL;\n    BIO *out = NULL;\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *pctx;\n    EVP_CIPHER *enc = NULL;\n    char *infile = NULL, *outfile = NULL, *ciphername = NULL, *prog;\n    char *passin = NULL, *passout = NULL, *passinarg = NULL, *passoutarg = NULL;\n    int private = 0;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, text = 0, check = 0;\n    int noout = 0, modulus = 0, pubin = 0, pubout = 0, ret = 1;\n    int pvk_encr = DEFAULT_PVK_ENCR_STRENGTH;\n    OPTION_CHOICE o;\n    int traditional = 0;\n    const char *output_type = NULL;\n    const char *output_structure = NULL;\n    int selection = 0;\n    OSSL_ENCODER_CTX *ectx = NULL;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, rsa_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(rsa_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passoutarg = opt_arg();\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PUBIN:\n            pubin = 1;\n            break;\n        case OPT_PUBOUT:\n            pubout = 1;\n            break;\n        case OPT_RSAPUBKEY_IN:\n            pubin = 2;\n            break;\n        case OPT_RSAPUBKEY_OUT:\n            pubout = 2;\n            break;\n        case OPT_PVK_STRONG:    /* pvk_encr:= 2 */\n        case OPT_PVK_WEAK:      /* pvk_encr:= 1 */\n        case OPT_PVK_NONE:      /* pvk_encr:= 0 */\n            pvk_encr = (o - OPT_PVK_NONE);\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_MODULUS:\n            modulus = 1;\n            break;\n        case OPT_CHECK:\n            check = 1;\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_TRADITIONAL:\n            traditional = 1;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!opt_cipher(ciphername, &enc))\n        goto opthelp;\n    private = (text && !pubin) || (!pubout && !noout);\n\n    if (!app_passwd(passinarg, passoutarg, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n    if (check && pubin) {\n        BIO_printf(bio_err, \"Only private keys can be checked\\n\");\n        goto end;\n    }\n\n    if (pubin) {\n        int tmpformat = FORMAT_UNDEF;\n\n        if (pubin == 2) {\n            if (informat == FORMAT_PEM)\n                tmpformat = FORMAT_PEMRSA;\n            else if (informat == FORMAT_ASN1)\n                tmpformat = FORMAT_ASN1RSA;\n        } else {\n            tmpformat = informat;\n        }\n\n        pkey = load_pubkey(infile, tmpformat, 1, passin, e, \"public key\");\n    } else {\n        pkey = load_key(infile, informat, 1, passin, e, \"private key\");\n    }\n\n    if (pkey == NULL) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    if (!EVP_PKEY_is_a(pkey, \"RSA\") && !EVP_PKEY_is_a(pkey, \"RSA-PSS\")) {\n        BIO_printf(bio_err, \"Not an RSA key\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (text) {\n        assert(pubin || private);\n        if ((pubin && EVP_PKEY_print_public(out, pkey, 0, NULL) <= 0)\n            || (!pubin && EVP_PKEY_print_private(out, pkey, 0, NULL) <= 0)) {\n            perror(outfile);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (modulus) {\n        BIGNUM *n = NULL;\n\n        /* Every RSA key has an 'n' */\n        EVP_PKEY_get_bn_param(pkey, \"n\", &n);\n        BIO_printf(out, \"Modulus=\");\n        BN_print(out, n);\n        BIO_printf(out, \"\\n\");\n        BN_free(n);\n    }\n\n    if (check) {\n        int r;\n\n        pctx = EVP_PKEY_CTX_new_from_pkey(NULL, pkey, NULL);\n        if (pctx == NULL) {\n            BIO_printf(bio_err, \"RSA unable to create PKEY context\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        r = EVP_PKEY_check(pctx);\n        EVP_PKEY_CTX_free(pctx);\n\n        if (r == 1) {\n            BIO_printf(out, \"RSA key ok\\n\");\n        } else if (r == 0) {\n            BIO_printf(bio_err, \"RSA key not ok\\n\");\n            ERR_print_errors(bio_err);\n        } else if (r < 0) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (noout) {\n        ret = 0;\n        goto end;\n    }\n    BIO_printf(bio_err, \"writing RSA key\\n\");\n\n    /* Choose output type for the format */\n    if (outformat == FORMAT_ASN1) {\n        output_type = \"DER\";\n    } else if (outformat == FORMAT_PEM) {\n        output_type = \"PEM\";\n    } else if (outformat == FORMAT_MSBLOB) {\n        output_type = \"MSBLOB\";\n    } else if (outformat == FORMAT_PVK) {\n        if (pubin) {\n            BIO_printf(bio_err, \"PVK form impossible with public key input\\n\");\n            goto end;\n        }\n        output_type = \"PVK\";\n    } else {\n        BIO_printf(bio_err, \"bad output format specified for outfile\\n\");\n        goto end;\n    }\n\n    /* Select what you want in the output */\n    if (pubout || pubin) {\n        selection = OSSL_KEYMGMT_SELECT_PUBLIC_KEY;\n    } else {\n        assert(private);\n        selection = (OSSL_KEYMGMT_SELECT_KEYPAIR\n                     | OSSL_KEYMGMT_SELECT_ALL_PARAMETERS);\n    }\n\n    /* For DER based output, select the desired output structure */\n    if (outformat == FORMAT_ASN1 || outformat == FORMAT_PEM) {\n        if (pubout || pubin) {\n            if (pubout == 2)\n                output_structure = \"pkcs1\"; /* \"type-specific\" would work too */\n            else\n                output_structure = \"SubjectPublicKeyInfo\";\n        } else {\n            assert(private);\n            if (traditional)\n                output_structure = \"pkcs1\"; /* \"type-specific\" would work too */\n            else\n                output_structure = \"PrivateKeyInfo\";\n        }\n    }\n\n    /* Now, perform the encoding */\n    ectx = OSSL_ENCODER_CTX_new_for_pkey(pkey, selection,\n                                         output_type, output_structure,\n                                         NULL);\n    if (OSSL_ENCODER_CTX_get_num_encoders(ectx) == 0) {\n        if ((!pubout && !pubin)\n            || !try_legacy_encoding(pkey, outformat, pubout, out))\n            BIO_printf(bio_err, \"%s format not supported\\n\", output_type);\n        else\n            ret = 0;\n        goto end;\n    }\n\n    /* Passphrase setup */\n    if (enc != NULL)\n        OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);\n\n    /* Default passphrase prompter */\n    if (enc != NULL || outformat == FORMAT_PVK) {\n        OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);\n        if (passout != NULL)\n            /* When passout given, override the passphrase prompter */\n            OSSL_ENCODER_CTX_set_passphrase(ectx,\n                                            (const unsigned char *)passout,\n                                            strlen(passout));\n    }\n\n    /* PVK is a bit special... */\n    if (outformat == FORMAT_PVK) {\n        OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n        params[0] = OSSL_PARAM_construct_int(\"encrypt-level\", &pvk_encr);\n        if (!OSSL_ENCODER_CTX_set_params(ectx, params)) {\n            BIO_printf(bio_err, \"invalid PVK encryption level\\n\");\n            goto end;\n        }\n    }\n\n    if (!OSSL_ENCODER_to_bio(ectx, out)) {\n        BIO_printf(bio_err, \"unable to write key\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    ret = 0;\n end:\n    OSSL_ENCODER_CTX_free(ectx);\n    release_engine(e);\n    BIO_free_all(out);\n    EVP_PKEY_free(pkey);\n    EVP_CIPHER_free(enc);\n    OPENSSL_free(passin);\n    OPENSSL_free(passout);\n    return ret;\n}",
            "int OSSL_ENCODER_CTX_set_passphrase_ui(OSSL_ENCODER_CTX *ctx,\n                                       const UI_METHOD *ui_method,\n                                       void *ui_data)\n{\n    return ossl_pw_set_ui_method(&ctx->pwdata, ui_method, ui_data);\n}"
        ],
        "sink": "OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);",
        "final_sink": "    return ossl_pw_set_ui_method(&ctx->pwdata, ui_method, ui_data);",
        "source": [
            "    fds = app_malloc(sizeof(OSSL_ASYNC_FD) * numfds, \"allocate async fds\");"
        ],
        "index": 42
    },
    {
        "prt": "ectx",
        "function_call": [
            "int rsa_main(int argc, char **argv)\n{\n    ENGINE *e = NULL;\n    BIO *out = NULL;\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *pctx;\n    EVP_CIPHER *enc = NULL;\n    char *infile = NULL, *outfile = NULL, *ciphername = NULL, *prog;\n    char *passin = NULL, *passout = NULL, *passinarg = NULL, *passoutarg = NULL;\n    int private = 0;\n    int informat = FORMAT_UNDEF, outformat = FORMAT_PEM, text = 0, check = 0;\n    int noout = 0, modulus = 0, pubin = 0, pubout = 0, ret = 1;\n    int pvk_encr = DEFAULT_PVK_ENCR_STRENGTH;\n    OPTION_CHOICE o;\n    int traditional = 0;\n    const char *output_type = NULL;\n    const char *output_structure = NULL;\n    int selection = 0;\n    OSSL_ENCODER_CTX *ectx = NULL;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, rsa_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(rsa_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_PASSOUT:\n            passoutarg = opt_arg();\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PUBIN:\n            pubin = 1;\n            break;\n        case OPT_PUBOUT:\n            pubout = 1;\n            break;\n        case OPT_RSAPUBKEY_IN:\n            pubin = 2;\n            break;\n        case OPT_RSAPUBKEY_OUT:\n            pubout = 2;\n            break;\n        case OPT_PVK_STRONG:    /* pvk_encr:= 2 */\n        case OPT_PVK_WEAK:      /* pvk_encr:= 1 */\n        case OPT_PVK_NONE:      /* pvk_encr:= 0 */\n            pvk_encr = (o - OPT_PVK_NONE);\n            break;\n        case OPT_NOOUT:\n            noout = 1;\n            break;\n        case OPT_TEXT:\n            text = 1;\n            break;\n        case OPT_MODULUS:\n            modulus = 1;\n            break;\n        case OPT_CHECK:\n            check = 1;\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_TRADITIONAL:\n            traditional = 1;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!opt_cipher(ciphername, &enc))\n        goto opthelp;\n    private = (text && !pubin) || (!pubout && !noout);\n\n    if (!app_passwd(passinarg, passoutarg, &passin, &passout)) {\n        BIO_printf(bio_err, \"Error getting passwords\\n\");\n        goto end;\n    }\n    if (check && pubin) {\n        BIO_printf(bio_err, \"Only private keys can be checked\\n\");\n        goto end;\n    }\n\n    if (pubin) {\n        int tmpformat = FORMAT_UNDEF;\n\n        if (pubin == 2) {\n            if (informat == FORMAT_PEM)\n                tmpformat = FORMAT_PEMRSA;\n            else if (informat == FORMAT_ASN1)\n                tmpformat = FORMAT_ASN1RSA;\n        } else {\n            tmpformat = informat;\n        }\n\n        pkey = load_pubkey(infile, tmpformat, 1, passin, e, \"public key\");\n    } else {\n        pkey = load_key(infile, informat, 1, passin, e, \"private key\");\n    }\n\n    if (pkey == NULL) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    if (!EVP_PKEY_is_a(pkey, \"RSA\") && !EVP_PKEY_is_a(pkey, \"RSA-PSS\")) {\n        BIO_printf(bio_err, \"Not an RSA key\\n\");\n        goto end;\n    }\n\n    out = bio_open_owner(outfile, outformat, private);\n    if (out == NULL)\n        goto end;\n\n    if (text) {\n        assert(pubin || private);\n        if ((pubin && EVP_PKEY_print_public(out, pkey, 0, NULL) <= 0)\n            || (!pubin && EVP_PKEY_print_private(out, pkey, 0, NULL) <= 0)) {\n            perror(outfile);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (modulus) {\n        BIGNUM *n = NULL;\n\n        /* Every RSA key has an 'n' */\n        EVP_PKEY_get_bn_param(pkey, \"n\", &n);\n        BIO_printf(out, \"Modulus=\");\n        BN_print(out, n);\n        BIO_printf(out, \"\\n\");\n        BN_free(n);\n    }\n\n    if (check) {\n        int r;\n\n        pctx = EVP_PKEY_CTX_new_from_pkey(NULL, pkey, NULL);\n        if (pctx == NULL) {\n            BIO_printf(bio_err, \"RSA unable to create PKEY context\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        r = EVP_PKEY_check(pctx);\n        EVP_PKEY_CTX_free(pctx);\n\n        if (r == 1) {\n            BIO_printf(out, \"RSA key ok\\n\");\n        } else if (r == 0) {\n            BIO_printf(bio_err, \"RSA key not ok\\n\");\n            ERR_print_errors(bio_err);\n        } else if (r < 0) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (noout) {\n        ret = 0;\n        goto end;\n    }\n    BIO_printf(bio_err, \"writing RSA key\\n\");\n\n    /* Choose output type for the format */\n    if (outformat == FORMAT_ASN1) {\n        output_type = \"DER\";\n    } else if (outformat == FORMAT_PEM) {\n        output_type = \"PEM\";\n    } else if (outformat == FORMAT_MSBLOB) {\n        output_type = \"MSBLOB\";\n    } else if (outformat == FORMAT_PVK) {\n        if (pubin) {\n            BIO_printf(bio_err, \"PVK form impossible with public key input\\n\");\n            goto end;\n        }\n        output_type = \"PVK\";\n    } else {\n        BIO_printf(bio_err, \"bad output format specified for outfile\\n\");\n        goto end;\n    }\n\n    /* Select what you want in the output */\n    if (pubout || pubin) {\n        selection = OSSL_KEYMGMT_SELECT_PUBLIC_KEY;\n    } else {\n        assert(private);\n        selection = (OSSL_KEYMGMT_SELECT_KEYPAIR\n                     | OSSL_KEYMGMT_SELECT_ALL_PARAMETERS);\n    }\n\n    /* For DER based output, select the desired output structure */\n    if (outformat == FORMAT_ASN1 || outformat == FORMAT_PEM) {\n        if (pubout || pubin) {\n            if (pubout == 2)\n                output_structure = \"pkcs1\"; /* \"type-specific\" would work too */\n            else\n                output_structure = \"SubjectPublicKeyInfo\";\n        } else {\n            assert(private);\n            if (traditional)\n                output_structure = \"pkcs1\"; /* \"type-specific\" would work too */\n            else\n                output_structure = \"PrivateKeyInfo\";\n        }\n    }\n\n    /* Now, perform the encoding */\n    ectx = OSSL_ENCODER_CTX_new_for_pkey(pkey, selection,\n                                         output_type, output_structure,\n                                         NULL);\n    if (OSSL_ENCODER_CTX_get_num_encoders(ectx) == 0) {\n        if ((!pubout && !pubin)\n            || !try_legacy_encoding(pkey, outformat, pubout, out))\n            BIO_printf(bio_err, \"%s format not supported\\n\", output_type);\n        else\n            ret = 0;\n        goto end;\n    }\n\n    /* Passphrase setup */\n    if (enc != NULL)\n        OSSL_ENCODER_CTX_set_cipher(ectx, EVP_CIPHER_get0_name(enc), NULL);\n\n    /* Default passphrase prompter */\n    if (enc != NULL || outformat == FORMAT_PVK) {\n        OSSL_ENCODER_CTX_set_passphrase_ui(ectx, get_ui_method(), NULL);\n        if (passout != NULL)\n            /* When passout given, override the passphrase prompter */\n            OSSL_ENCODER_CTX_set_passphrase(ectx,\n                                            (const unsigned char *)passout,\n                                            strlen(passout));\n    }\n\n    /* PVK is a bit special... */\n    if (outformat == FORMAT_PVK) {\n        OSSL_PARAM params[2] = { OSSL_PARAM_END, OSSL_PARAM_END };\n\n        params[0] = OSSL_PARAM_construct_int(\"encrypt-level\", &pvk_encr);\n        if (!OSSL_ENCODER_CTX_set_params(ectx, params)) {\n            BIO_printf(bio_err, \"invalid PVK encryption level\\n\");\n            goto end;\n        }\n    }\n\n    if (!OSSL_ENCODER_to_bio(ectx, out)) {\n        BIO_printf(bio_err, \"unable to write key\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    ret = 0;\n end:\n    OSSL_ENCODER_CTX_free(ectx);\n    release_engine(e);\n    BIO_free_all(out);\n    EVP_PKEY_free(pkey);\n    EVP_CIPHER_free(enc);\n    OPENSSL_free(passin);\n    OPENSSL_free(passout);\n    return ret;\n}"
        ],
        "sink": "if (!OSSL_ENCODER_to_bio(ectx, out)) {",
        "final_sink": "if (!OSSL_ENCODER_to_bio(ectx, out)) {",
        "source": [
            "        DIST_POINT *dp = sk_DIST_POINT_value(crldp, i);"
        ],
        "index": 43
    },
    {
        "prt": "host",
        "function_call": [
            "int s_client_main(int argc, char **argv)\n{\n    BIO *sbio;\n    EVP_PKEY *key = NULL;\n    SSL *con = NULL;\n    SSL_CTX *ctx = NULL;\n    STACK_OF(X509) *chain = NULL;\n    X509 *cert = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    SSL_EXCERT *exc = NULL;\n    SSL_CONF_CTX *cctx = NULL;\n    STACK_OF(OPENSSL_STRING) *ssl_args = NULL;\n    char *dane_tlsa_domain = NULL;\n    STACK_OF(OPENSSL_STRING) *dane_tlsa_rrset = NULL;\n    int dane_ee_no_name = 0;\n    STACK_OF(X509_CRL) *crls = NULL;\n    const SSL_METHOD *meth = TLS_client_method();\n    const char *CApath = NULL, *CAfile = NULL, *CAstore = NULL;\n    char *cbuf = NULL, *sbuf = NULL, *mbuf = NULL;\n    char *proxystr = NULL, *proxyuser = NULL;\n    char *proxypassarg = NULL, *proxypass = NULL;\n    char *connectstr = NULL, *bindstr = NULL;\n    char *cert_file = NULL, *key_file = NULL, *chain_file = NULL;\n    char *chCApath = NULL, *chCAfile = NULL, *chCAstore = NULL, *host = NULL;\n    char *thost = NULL, *tport = NULL;\n    char *port = NULL;\n    char *bindhost = NULL, *bindport = NULL;\n    char *passarg = NULL, *pass = NULL;\n    char *vfyCApath = NULL, *vfyCAfile = NULL, *vfyCAstore = NULL;\n    char *ReqCAfile = NULL;\n    char *sess_in = NULL, *crl_file = NULL, *p;\n    const char *protohost = NULL;\n    struct timeval timeout, *timeoutp;\n    fd_set readfds, writefds;\n    int noCApath = 0, noCAfile = 0, noCAstore = 0;\n    int build_chain = 0, cert_format = FORMAT_UNDEF;\n    size_t cbuf_len, cbuf_off;\n    int key_format = FORMAT_UNDEF, crlf = 0, full_log = 1, mbuf_len = 0;\n    int prexit = 0;\n    int nointeractive = 0;\n    int sdebug = 0;\n    int reconnect = 0, verify = SSL_VERIFY_NONE, vpmtouched = 0;\n    int ret = 1, in_init = 1, i, nbio_test = 0, sock = -1, k, width, state = 0;\n    int sbuf_len, sbuf_off, cmdmode = USER_DATA_MODE_BASIC;\n    int socket_family = AF_UNSPEC, socket_type = SOCK_STREAM, protocol = 0;\n    int starttls_proto = PROTO_OFF, crl_format = FORMAT_UNDEF, crl_download = 0;\n    int write_tty, read_tty, write_ssl, read_ssl, tty_on, ssl_pending;\n    int first_loop;\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS)\n    int at_eof = 0;\n#endif\n    int read_buf_len = 0;\n    int fallback_scsv = 0;\n    OPTION_CHOICE o;\n#ifndef OPENSSL_NO_DTLS\n    int enable_timeouts = 0;\n    long socket_mtu = 0;\n#endif\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE *ssl_client_engine = NULL;\n#endif\n    ENGINE *e = NULL;\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)\n    struct timeval tv;\n#endif\n    const char *servername = NULL;\n    char *sname_alloc = NULL;\n    int noservername = 0;\n    const char *alpn_in = NULL;\n    tlsextctx tlsextcbp = { NULL, 0 };\n    const char *ssl_config = NULL;\n#define MAX_SI_TYPES 100\n    unsigned short serverinfo_types[MAX_SI_TYPES];\n    int serverinfo_count = 0, start = 0, len;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    const char *next_proto_neg_in = NULL;\n#endif\n#ifndef OPENSSL_NO_SRP\n    char *srppass = NULL;\n    int srp_lateuser = 0;\n    SRP_ARG srp_arg = { NULL, NULL, 0, 0, 0, 1024 };\n#endif\n#ifndef OPENSSL_NO_SRTP\n    char *srtp_profiles = NULL;\n#endif\n#ifndef OPENSSL_NO_CT\n    char *ctlog_file = NULL;\n    int ct_validation = 0;\n#endif\n    int min_version = 0, max_version = 0, prot_opt = 0, no_prot_opt = 0;\n    int async = 0;\n    unsigned int max_send_fragment = 0;\n    unsigned int split_send_fragment = 0, max_pipelines = 0;\n    enum { use_inet, use_unix, use_unknown } connect_type = use_unknown;\n    int count4or6 = 0;\n    uint8_t maxfraglen = 0;\n    int c_nbio = 0, c_msg = 0, c_ign_eof = 0, c_brief = 0;\n    int c_tlsextdebug = 0;\n#ifndef OPENSSL_NO_OCSP\n    int c_status_req = 0;\n#endif\n    BIO *bio_c_msg = NULL;\n    const char *keylog_file = NULL, *early_data_file = NULL;\n    int isdtls = 0, isquic = 0;\n    char *psksessf = NULL;\n    int enable_pha = 0;\n    int enable_client_rpk = 0;\n#ifndef OPENSSL_NO_SCTP\n    int sctp_label_bug = 0;\n#endif\n    int ignore_unexpected_eof = 0;\n#ifndef OPENSSL_NO_KTLS\n    int enable_ktls = 0;\n#endif\n    int tfo = 0;\n    int is_infinite;\n    BIO_ADDR *peer_addr = NULL;\n    struct user_data_st user_data;\n\n    FD_ZERO(&readfds);\n    FD_ZERO(&writefds);\n/* Known false-positive of MemorySanitizer. */\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n    __msan_unpoison(&readfds, sizeof(readfds));\n    __msan_unpoison(&writefds, sizeof(writefds));\n# endif\n#endif\n\n    c_quiet = 0;\n    c_debug = 0;\n    c_showcerts = 0;\n    c_nbio = 0;\n    port = OPENSSL_strdup(PORT);\n    vpm = X509_VERIFY_PARAM_new();\n    cctx = SSL_CONF_CTX_new();\n\n    if (port == NULL || vpm == NULL || cctx == NULL) {\n        BIO_printf(bio_err, \"%s: out of memory\\n\", opt_getprog());\n        goto end;\n    }\n\n    cbuf = app_malloc(BUFSIZZ, \"cbuf\");\n    sbuf = app_malloc(BUFSIZZ, \"sbuf\");\n    mbuf = app_malloc(BUFSIZZ, \"mbuf\");\n\n    SSL_CONF_CTX_set_flags(cctx, SSL_CONF_FLAG_CLIENT | SSL_CONF_FLAG_CMDLINE);\n\n    prog = opt_init(argc, argv, s_client_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        /* Check for intermixing flags. */\n        if (connect_type == use_unix && IS_INET_FLAG(o)) {\n            BIO_printf(bio_err,\n                       \"%s: Intermixed protocol flags (unix and internet domains)\\n\",\n                       prog);\n            goto end;\n        }\n        if (connect_type == use_inet && IS_UNIX_FLAG(o)) {\n            BIO_printf(bio_err,\n                       \"%s: Intermixed protocol flags (internet and unix domains)\\n\",\n                       prog);\n            goto end;\n        }\n\n        if (IS_PROT_FLAG(o) && ++prot_opt > 1) {\n            BIO_printf(bio_err, \"Cannot supply multiple protocol flags\\n\");\n            goto end;\n        }\n        if (IS_NO_PROT_FLAG(o))\n            no_prot_opt++;\n        if (prot_opt == 1 && no_prot_opt) {\n            BIO_printf(bio_err,\n                       \"Cannot supply both a protocol flag and '-no_<prot>'\\n\");\n            goto end;\n        }\n\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(s_client_options);\n            ret = 0;\n            goto end;\n        case OPT_4:\n            connect_type = use_inet;\n            socket_family = AF_INET;\n            count4or6++;\n            break;\n#ifdef AF_INET6\n        case OPT_6:\n            connect_type = use_inet;\n            socket_family = AF_INET6;\n            count4or6++;\n            break;\n#endif\n        case OPT_HOST:\n            connect_type = use_inet;\n            freeandcopy(&host, opt_arg());\n            break;\n        case OPT_PORT:\n            connect_type = use_inet;\n            freeandcopy(&port, opt_arg());\n            break;\n        case OPT_CONNECT:\n            connect_type = use_inet;\n            freeandcopy(&connectstr, opt_arg());\n            break;\n        case OPT_BIND:\n            freeandcopy(&bindstr, opt_arg());\n            break;\n        case OPT_PROXY:\n            proxystr = opt_arg();\n            break;\n        case OPT_PROXY_USER:\n            proxyuser = opt_arg();\n            break;\n        case OPT_PROXY_PASS:\n            proxypassarg = opt_arg();\n            break;\n#ifdef AF_UNIX\n        case OPT_UNIX:\n            connect_type = use_unix;\n            socket_family = AF_UNIX;\n            freeandcopy(&host, opt_arg());\n            break;\n#endif\n        case OPT_XMPPHOST:\n            /* fall through, since this is an alias */\n        case OPT_PROTOHOST:\n            protohost = opt_arg();\n            break;\n        case OPT_VERIFY:\n            verify = SSL_VERIFY_PEER;\n            verify_args.depth = atoi(opt_arg());\n            if (!c_quiet)\n                BIO_printf(bio_err, \"verify depth is %d\\n\", verify_args.depth);\n            break;\n        case OPT_CERT:\n            cert_file = opt_arg();\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto end;\n            break;\n        case OPT_CRL:\n            crl_file = opt_arg();\n            break;\n        case OPT_CRL_DOWNLOAD:\n            crl_download = 1;\n            break;\n        case OPT_SESS_OUT:\n            sess_out = opt_arg();\n            break;\n        case OPT_SESS_IN:\n            sess_in = opt_arg();\n            break;\n        case OPT_CERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &cert_format))\n                goto opthelp;\n            break;\n        case OPT_CRLFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &crl_format))\n                goto opthelp;\n            break;\n        case OPT_VERIFY_RET_ERROR:\n            verify = SSL_VERIFY_PEER;\n            verify_args.return_error = 1;\n            break;\n        case OPT_VERIFY_QUIET:\n            verify_args.quiet = 1;\n            break;\n        case OPT_BRIEF:\n            c_brief = verify_args.quiet = c_quiet = 1;\n            break;\n        case OPT_S_CASES:\n            if (ssl_args == NULL)\n                ssl_args = sk_OPENSSL_STRING_new_null();\n            if (ssl_args == NULL\n                || !sk_OPENSSL_STRING_push(ssl_args, opt_flag())\n                || !sk_OPENSSL_STRING_push(ssl_args, opt_arg())) {\n                BIO_printf(bio_err, \"%s: Memory allocation failure\\n\", prog);\n                goto end;\n            }\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_X_CASES:\n            if (!args_excert(o, &exc))\n                goto end;\n            break;\n        case OPT_IGNORE_UNEXPECTED_EOF:\n            ignore_unexpected_eof = 1;\n            break;\n        case OPT_PREXIT:\n            prexit = 1;\n            break;\n        case OPT_NO_INTERACTIVE:\n            nointeractive = 1;\n            break;\n        case OPT_CRLF:\n            crlf = 1;\n            break;\n        case OPT_QUIET:\n            c_quiet = c_ign_eof = 1;\n            break;\n        case OPT_NBIO:\n            c_nbio = 1;\n            break;\n        case OPT_NOCMDS:\n            cmdmode = USER_DATA_MODE_NONE;\n            break;\n        case OPT_ADV:\n            cmdmode = USER_DATA_MODE_ADVANCED;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 1);\n            break;\n        case OPT_SSL_CLIENT_ENGINE:\n#ifndef OPENSSL_NO_ENGINE\n            ssl_client_engine = setup_engine(opt_arg(), 0);\n            if (ssl_client_engine == NULL) {\n                BIO_printf(bio_err, \"Error getting client auth engine\\n\");\n                goto opthelp;\n            }\n#endif\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_IGN_EOF:\n            c_ign_eof = 1;\n            break;\n        case OPT_NO_IGN_EOF:\n            c_ign_eof = 0;\n            break;\n        case OPT_DEBUG:\n            c_debug = 1;\n            break;\n        case OPT_TLSEXTDEBUG:\n            c_tlsextdebug = 1;\n            break;\n        case OPT_STATUS:\n#ifndef OPENSSL_NO_OCSP\n            c_status_req = 1;\n#endif\n            break;\n        case OPT_WDEBUG:\n#ifdef WATT32\n            dbug_init();\n#endif\n            break;\n        case OPT_MSG:\n            c_msg = 1;\n            break;\n        case OPT_MSGFILE:\n            bio_c_msg = BIO_new_file(opt_arg(), \"w\");\n            if (bio_c_msg == NULL) {\n                BIO_printf(bio_err, \"Error writing file %s\\n\", opt_arg());\n                goto end;\n            }\n            break;\n        case OPT_TRACE:\n#ifndef OPENSSL_NO_SSL_TRACE\n            c_msg = 2;\n#endif\n            break;\n        case OPT_SECURITY_DEBUG:\n            sdebug = 1;\n            break;\n        case OPT_SECURITY_DEBUG_VERBOSE:\n            sdebug = 2;\n            break;\n        case OPT_SHOWCERTS:\n            c_showcerts = 1;\n            break;\n        case OPT_NBIO_TEST:\n            nbio_test = 1;\n            break;\n        case OPT_STATE:\n            state = 1;\n            break;\n        case OPT_PSK_IDENTITY:\n            psk_identity = opt_arg();\n            break;\n        case OPT_PSK:\n            for (p = psk_key = opt_arg(); *p; p++) {\n                if (isxdigit(_UC(*p)))\n                    continue;\n                BIO_printf(bio_err, \"Not a hex number '%s'\\n\", psk_key);\n                goto end;\n            }\n            break;\n        case OPT_PSK_SESS:\n            psksessf = opt_arg();\n            break;\n#ifndef OPENSSL_NO_SRP\n        case OPT_SRPUSER:\n            srp_arg.srplogin = opt_arg();\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n            break;\n        case OPT_SRPPASS:\n            srppass = opt_arg();\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n            break;\n        case OPT_SRP_STRENGTH:\n            srp_arg.strength = atoi(opt_arg());\n            BIO_printf(bio_err, \"SRP minimal length for N is %d\\n\",\n                       srp_arg.strength);\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n            break;\n        case OPT_SRP_LATEUSER:\n            srp_lateuser = 1;\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n            break;\n        case OPT_SRP_MOREGROUPS:\n            srp_arg.amp = 1;\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n            break;\n#endif\n        case OPT_SSL_CONFIG:\n            ssl_config = opt_arg();\n            break;\n        case OPT_SSL3:\n            min_version = SSL3_VERSION;\n            max_version = SSL3_VERSION;\n            socket_type = SOCK_STREAM;\n#ifndef OPENSSL_NO_DTLS\n            isdtls = 0;\n#endif\n            isquic = 0;\n            break;\n        case OPT_TLS1_3:\n            min_version = TLS1_3_VERSION;\n            max_version = TLS1_3_VERSION;\n            socket_type = SOCK_STREAM;\n#ifndef OPENSSL_NO_DTLS\n            isdtls = 0;\n#endif\n            isquic = 0;\n            break;\n        case OPT_TLS1_2:\n            min_version = TLS1_2_VERSION;\n            max_version = TLS1_2_VERSION;\n            socket_type = SOCK_STREAM;\n#ifndef OPENSSL_NO_DTLS\n            isdtls = 0;\n#endif\n            isquic = 0;\n            break;\n        case OPT_TLS1_1:\n            min_version = TLS1_1_VERSION;\n            max_version = TLS1_1_VERSION;\n            socket_type = SOCK_STREAM;\n#ifndef OPENSSL_NO_DTLS\n            isdtls = 0;\n#endif\n            isquic = 0;\n            break;\n        case OPT_TLS1:\n            min_version = TLS1_VERSION;\n            max_version = TLS1_VERSION;\n            socket_type = SOCK_STREAM;\n#ifndef OPENSSL_NO_DTLS\n            isdtls = 0;\n#endif\n            isquic = 0;\n            break;\n        case OPT_DTLS:\n#ifndef OPENSSL_NO_DTLS\n            meth = DTLS_client_method();\n            socket_type = SOCK_DGRAM;\n            isdtls = 1;\n            isquic = 0;\n#endif\n            break;\n        case OPT_DTLS1:\n#ifndef OPENSSL_NO_DTLS1\n            meth = DTLS_client_method();\n            min_version = DTLS1_VERSION;\n            max_version = DTLS1_VERSION;\n            socket_type = SOCK_DGRAM;\n            isdtls = 1;\n            isquic = 0;\n#endif\n            break;\n        case OPT_DTLS1_2:\n#ifndef OPENSSL_NO_DTLS1_2\n            meth = DTLS_client_method();\n            min_version = DTLS1_2_VERSION;\n            max_version = DTLS1_2_VERSION;\n            socket_type = SOCK_DGRAM;\n            isdtls = 1;\n            isquic = 0;\n#endif\n            break;\n        case OPT_QUIC:\n#ifndef OPENSSL_NO_QUIC\n            meth = OSSL_QUIC_client_method();\n            min_version = 0;\n            max_version = 0;\n            socket_type = SOCK_DGRAM;\n# ifndef OPENSSL_NO_DTLS\n            isdtls = 0;\n# endif\n            isquic = 1;\n#endif\n            break;\n        case OPT_SCTP:\n#ifndef OPENSSL_NO_SCTP\n            protocol = IPPROTO_SCTP;\n#endif\n            break;\n        case OPT_SCTP_LABEL_BUG:\n#ifndef OPENSSL_NO_SCTP\n            sctp_label_bug = 1;\n#endif\n            break;\n        case OPT_TIMEOUT:\n#ifndef OPENSSL_NO_DTLS\n            enable_timeouts = 1;\n#endif\n            break;\n        case OPT_MTU:\n#ifndef OPENSSL_NO_DTLS\n            socket_mtu = atol(opt_arg());\n#endif\n            break;\n        case OPT_FALLBACKSCSV:\n            fallback_scsv = 1;\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &key_format))\n                goto opthelp;\n            break;\n        case OPT_PASS:\n            passarg = opt_arg();\n            break;\n        case OPT_CERT_CHAIN:\n            chain_file = opt_arg();\n            break;\n        case OPT_KEY:\n            key_file = opt_arg();\n            break;\n        case OPT_RECONNECT:\n            reconnect = 5;\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_CHAINCAPATH:\n            chCApath = opt_arg();\n            break;\n        case OPT_VERIFYCAPATH:\n            vfyCApath = opt_arg();\n            break;\n        case OPT_BUILD_CHAIN:\n            build_chain = 1;\n            break;\n        case OPT_REQCAFILE:\n            ReqCAfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n#ifndef OPENSSL_NO_CT\n        case OPT_NOCT:\n            ct_validation = 0;\n            break;\n        case OPT_CT:\n            ct_validation = 1;\n            break;\n        case OPT_CTLOG_FILE:\n            ctlog_file = opt_arg();\n            break;\n#endif\n        case OPT_CHAINCAFILE:\n            chCAfile = opt_arg();\n            break;\n        case OPT_VERIFYCAFILE:\n            vfyCAfile = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_CHAINCASTORE:\n            chCAstore = opt_arg();\n            break;\n        case OPT_VERIFYCASTORE:\n            vfyCAstore = opt_arg();\n            break;\n        case OPT_DANE_TLSA_DOMAIN:\n            dane_tlsa_domain = opt_arg();\n            break;\n        case OPT_DANE_TLSA_RRDATA:\n            if (dane_tlsa_rrset == NULL)\n                dane_tlsa_rrset = sk_OPENSSL_STRING_new_null();\n            if (dane_tlsa_rrset == NULL ||\n                !sk_OPENSSL_STRING_push(dane_tlsa_rrset, opt_arg())) {\n                BIO_printf(bio_err, \"%s: Memory allocation failure\\n\", prog);\n                goto end;\n            }\n            break;\n        case OPT_DANE_EE_NO_NAME:\n            dane_ee_no_name = 1;\n            break;\n        case OPT_NEXTPROTONEG:\n#ifndef OPENSSL_NO_NEXTPROTONEG\n            next_proto_neg_in = opt_arg();\n#endif\n            break;\n        case OPT_ALPN:\n            alpn_in = opt_arg();\n            break;\n        case OPT_SERVERINFO:\n            p = opt_arg();\n            len = strlen(p);\n            for (start = 0, i = 0; i <= len; ++i) {\n                if (i == len || p[i] == ',') {\n                    serverinfo_types[serverinfo_count] = atoi(p + start);\n                    if (++serverinfo_count == MAX_SI_TYPES)\n                        break;\n                    start = i + 1;\n                }\n            }\n            break;\n        case OPT_STARTTLS:\n            if (!opt_pair(opt_arg(), services, &starttls_proto))\n                goto end;\n            break;\n        case OPT_TFO:\n            tfo = 1;\n            break;\n        case OPT_SERVERNAME:\n            servername = opt_arg();\n            break;\n        case OPT_NOSERVERNAME:\n            noservername = 1;\n            break;\n        case OPT_USE_SRTP:\n#ifndef OPENSSL_NO_SRTP\n            srtp_profiles = opt_arg();\n#endif\n            break;\n        case OPT_KEYMATEXPORT:\n            keymatexportlabel = opt_arg();\n            break;\n        case OPT_KEYMATEXPORTLEN:\n            keymatexportlen = atoi(opt_arg());\n            break;\n        case OPT_ASYNC:\n            async = 1;\n            break;\n        case OPT_MAXFRAGLEN:\n            len = atoi(opt_arg());\n            switch (len) {\n            case 512:\n                maxfraglen = TLSEXT_max_fragment_length_512;\n                break;\n            case 1024:\n                maxfraglen = TLSEXT_max_fragment_length_1024;\n                break;\n            case 2048:\n                maxfraglen = TLSEXT_max_fragment_length_2048;\n                break;\n            case 4096:\n                maxfraglen = TLSEXT_max_fragment_length_4096;\n                break;\n            default:\n                BIO_printf(bio_err,\n                           \"%s: Max Fragment Len %u is out of permitted values\",\n                           prog, len);\n                goto opthelp;\n            }\n            break;\n        case OPT_MAX_SEND_FRAG:\n            max_send_fragment = atoi(opt_arg());\n            break;\n        case OPT_SPLIT_SEND_FRAG:\n            split_send_fragment = atoi(opt_arg());\n            break;\n        case OPT_MAX_PIPELINES:\n            max_pipelines = atoi(opt_arg());\n            break;\n        case OPT_READ_BUF:\n            read_buf_len = atoi(opt_arg());\n            break;\n        case OPT_KEYLOG_FILE:\n            keylog_file = opt_arg();\n            break;\n        case OPT_EARLY_DATA:\n            early_data_file = opt_arg();\n            break;\n        case OPT_ENABLE_PHA:\n            enable_pha = 1;\n            break;\n        case OPT_KTLS:\n#ifndef OPENSSL_NO_KTLS\n            enable_ktls = 1;\n#endif\n            break;\n        case OPT_ENABLE_SERVER_RPK:\n            enable_server_rpk = 1;\n            break;\n        case OPT_ENABLE_CLIENT_RPK:\n            enable_client_rpk = 1;\n            break;\n        }\n    }\n\n    /* Optional argument is connect string if -connect not used. */\n    if (opt_num_rest() == 1) {\n        /* Don't allow -connect and a separate argument. */\n        if (connectstr != NULL) {\n            BIO_printf(bio_err,\n                       \"%s: cannot provide both -connect option and target parameter\\n\",\n                       prog);\n            goto opthelp;\n        }\n        connect_type = use_inet;\n        freeandcopy(&connectstr, *opt_rest());\n    } else if (!opt_check_rest_arg(NULL)) {\n        goto opthelp;\n    }\n    if (!app_RAND_load())\n        goto end;\n\n    if (c_ign_eof)\n        cmdmode = USER_DATA_MODE_NONE;\n\n    if (count4or6 >= 2) {\n        BIO_printf(bio_err, \"%s: Can't use both -4 and -6\\n\", prog);\n        goto opthelp;\n    }\n    if (noservername) {\n        if (servername != NULL) {\n            BIO_printf(bio_err,\n                       \"%s: Can't use -servername and -noservername together\\n\",\n                       prog);\n            goto opthelp;\n        }\n        if (dane_tlsa_domain != NULL) {\n            BIO_printf(bio_err,\n               \"%s: Can't use -dane_tlsa_domain and -noservername together\\n\",\n               prog);\n            goto opthelp;\n        }\n    }\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    if (min_version == TLS1_3_VERSION && next_proto_neg_in != NULL) {\n        BIO_printf(bio_err, \"Cannot supply -nextprotoneg with TLSv1.3\\n\");\n        goto opthelp;\n    }\n#endif\n\n    if (connectstr != NULL) {\n        int res;\n        char *tmp_host = host, *tmp_port = port;\n\n        res = BIO_parse_hostserv(connectstr, &host, &port, BIO_PARSE_PRIO_HOST);\n        if (tmp_host != host)\n            OPENSSL_free(tmp_host);\n        if (tmp_port != port)\n            OPENSSL_free(tmp_port);\n        if (!res) {\n            BIO_printf(bio_err,\n                       \"%s: -connect argument or target parameter malformed or ambiguous\\n\",\n                       prog);\n            goto end;\n        }\n    }\n\n    if (proxystr != NULL) {\n#ifndef OPENSSL_NO_HTTP\n        int res;\n        char *tmp_host = host, *tmp_port = port;\n\n        if (host == NULL || port == NULL) {\n            BIO_printf(bio_err, \"%s: -proxy requires use of -connect or target parameter\\n\", prog);\n            goto opthelp;\n        }\n\n        if (servername == NULL && !noservername) {\n            servername = sname_alloc = OPENSSL_strdup(host);\n            if (sname_alloc == NULL) {\n                BIO_printf(bio_err, \"%s: out of memory\\n\", prog);\n                goto end;\n            }\n        }\n\n        /* Retain the original target host:port for use in the HTTP proxy connect string */\n        thost = OPENSSL_strdup(host);\n        tport = OPENSSL_strdup(port);\n        if (thost == NULL || tport == NULL) {\n            BIO_printf(bio_err, \"%s: out of memory\\n\", prog);\n            goto end;\n        }\n\n        res = BIO_parse_hostserv(proxystr, &host, &port, BIO_PARSE_PRIO_HOST);\n        if (tmp_host != host)\n            OPENSSL_free(tmp_host);\n        if (tmp_port != port)\n            OPENSSL_free(tmp_port);\n        if (!res) {\n            BIO_printf(bio_err,\n                       \"%s: -proxy argument malformed or ambiguous\\n\", prog);\n            goto end;\n        }\n#else\n        BIO_printf(bio_err,\n                   \"%s: -proxy not supported in no-http build\\n\", prog);\n\tgoto end;\n#endif\n    }\n\n\n    if (bindstr != NULL) {\n        int res;\n        res = BIO_parse_hostserv(bindstr, &bindhost, &bindport,\n                                 BIO_PARSE_PRIO_HOST);\n        if (!res) {\n            BIO_printf(bio_err,\n                       \"%s: -bind argument parameter malformed or ambiguous\\n\",\n                       prog);\n            goto end;\n        }\n    }\n\n#ifdef AF_UNIX\n    if (socket_family == AF_UNIX && socket_type != SOCK_STREAM) {\n        BIO_printf(bio_err,\n                   \"Can't use unix sockets and datagrams together\\n\");\n        goto end;\n    }\n#endif\n\n#ifndef OPENSSL_NO_SCTP\n    if (protocol == IPPROTO_SCTP) {\n        if (socket_type != SOCK_DGRAM) {\n            BIO_printf(bio_err, \"Can't use -sctp without DTLS\\n\");\n            goto end;\n        }\n        /* SCTP is unusual. It uses DTLS over a SOCK_STREAM protocol */\n        socket_type = SOCK_STREAM;\n    }\n#endif\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    next_proto.status = -1;\n    if (next_proto_neg_in) {\n        next_proto.data =\n            next_protos_parse(&next_proto.len, next_proto_neg_in);\n        if (next_proto.data == NULL) {\n            BIO_printf(bio_err, \"Error parsing -nextprotoneg argument\\n\");\n            goto end;\n        }\n    } else\n        next_proto.data = NULL;\n#endif\n\n    if (!app_passwd(passarg, NULL, &pass, NULL)) {\n        BIO_printf(bio_err, \"Error getting private key password\\n\");\n        goto end;\n    }\n\n    if (!app_passwd(proxypassarg, NULL, &proxypass, NULL)) {\n        BIO_printf(bio_err, \"Error getting proxy password\\n\");\n        goto end;\n    }\n\n    if (proxypass != NULL && proxyuser == NULL) {\n        BIO_printf(bio_err, \"Error: Must specify proxy_user with proxy_pass\\n\");\n        goto end;\n    }\n\n    if (key_file == NULL)\n        key_file = cert_file;\n\n    if (key_file != NULL) {\n        key = load_key(key_file, key_format, 0, pass, e,\n                       \"client certificate private key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    if (cert_file != NULL) {\n        cert = load_cert_pass(cert_file, cert_format, 1, pass,\n                              \"client certificate\");\n        if (cert == NULL)\n            goto end;\n    }\n\n    if (chain_file != NULL) {\n        if (!load_certs(chain_file, 0, &chain, pass, \"client certificate chain\"))\n            goto end;\n    }\n\n    if (crl_file != NULL) {\n        X509_CRL *crl;\n        crl = load_crl(crl_file, crl_format, 0, \"CRL\");\n        if (crl == NULL)\n            goto end;\n        crls = sk_X509_CRL_new_null();\n        if (crls == NULL || !sk_X509_CRL_push(crls, crl)) {\n            BIO_puts(bio_err, \"Error adding CRL\\n\");\n            ERR_print_errors(bio_err);\n            X509_CRL_free(crl);\n            goto end;\n        }\n    }\n\n    if (!load_excert(&exc))\n        goto end;\n\n    if (bio_c_out == NULL) {\n        if (c_quiet && !c_debug) {\n            bio_c_out = BIO_new(BIO_s_null());\n            if (c_msg && bio_c_msg == NULL) {\n                bio_c_msg = dup_bio_out(FORMAT_TEXT);\n                if (bio_c_msg == NULL) {\n                    BIO_printf(bio_err, \"Out of memory\\n\");\n                    goto end;\n                }\n            }\n        } else {\n            bio_c_out = dup_bio_out(FORMAT_TEXT);\n        }\n\n        if (bio_c_out == NULL) {\n            BIO_printf(bio_err, \"Unable to create BIO\\n\");\n            goto end;\n        }\n    }\n#ifndef OPENSSL_NO_SRP\n    if (!app_passwd(srppass, NULL, &srp_arg.srppassin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n#endif\n\n    ctx = SSL_CTX_new_ex(app_get0_libctx(), app_get0_propq(), meth);\n    if (ctx == NULL) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    SSL_CTX_clear_mode(ctx, SSL_MODE_AUTO_RETRY);\n\n    if (sdebug)\n        ssl_ctx_security_debug(ctx, sdebug);\n\n    if (!config_ctx(cctx, ssl_args, ctx))\n        goto end;\n\n    if (ssl_config != NULL) {\n        if (SSL_CTX_config(ctx, ssl_config) == 0) {\n            BIO_printf(bio_err, \"Error using configuration \\\"%s\\\"\\n\",\n                       ssl_config);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n#ifndef OPENSSL_NO_SCTP\n    if (protocol == IPPROTO_SCTP && sctp_label_bug == 1)\n        SSL_CTX_set_mode(ctx, SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG);\n#endif\n\n    if (min_version != 0\n        && SSL_CTX_set_min_proto_version(ctx, min_version) == 0)\n        goto end;\n    if (max_version != 0\n        && SSL_CTX_set_max_proto_version(ctx, max_version) == 0)\n        goto end;\n\n    if (ignore_unexpected_eof)\n        SSL_CTX_set_options(ctx, SSL_OP_IGNORE_UNEXPECTED_EOF);\n#ifndef OPENSSL_NO_KTLS\n    if (enable_ktls)\n        SSL_CTX_set_options(ctx, SSL_OP_ENABLE_KTLS);\n#endif\n\n    if (vpmtouched && !SSL_CTX_set1_param(ctx, vpm)) {\n        BIO_printf(bio_err, \"Error setting verify params\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    if (async) {\n        SSL_CTX_set_mode(ctx, SSL_MODE_ASYNC);\n    }\n\n    if (max_send_fragment > 0\n        && !SSL_CTX_set_max_send_fragment(ctx, max_send_fragment)) {\n        BIO_printf(bio_err, \"%s: Max send fragment size %u is out of permitted range\\n\",\n                   prog, max_send_fragment);\n        goto end;\n    }\n\n    if (split_send_fragment > 0\n        && !SSL_CTX_set_split_send_fragment(ctx, split_send_fragment)) {\n        BIO_printf(bio_err, \"%s: Split send fragment size %u is out of permitted range\\n\",\n                   prog, split_send_fragment);\n        goto end;\n    }\n\n    if (max_pipelines > 0\n        && !SSL_CTX_set_max_pipelines(ctx, max_pipelines)) {\n        BIO_printf(bio_err, \"%s: Max pipelines %u is out of permitted range\\n\",\n                   prog, max_pipelines);\n        goto end;\n    }\n\n    if (read_buf_len > 0) {\n        SSL_CTX_set_default_read_buffer_len(ctx, read_buf_len);\n    }\n\n    if (maxfraglen > 0\n            && !SSL_CTX_set_tlsext_max_fragment_length(ctx, maxfraglen)) {\n        BIO_printf(bio_err,\n                   \"%s: Max Fragment Length code %u is out of permitted values\"\n                   \"\\n\", prog, maxfraglen);\n        goto end;\n    }\n\n    if (!ssl_load_stores(ctx,\n                         vfyCApath, vfyCAfile, vfyCAstore,\n                         chCApath, chCAfile, chCAstore,\n                         crls, crl_download)) {\n        BIO_printf(bio_err, \"Error loading store locations\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    if (ReqCAfile != NULL) {\n        STACK_OF(X509_NAME) *nm = sk_X509_NAME_new_null();\n\n        if (nm == NULL || !SSL_add_file_cert_subjects_to_stack(nm, ReqCAfile)) {\n            sk_X509_NAME_pop_free(nm, X509_NAME_free);\n            BIO_printf(bio_err, \"Error loading CA names\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        SSL_CTX_set0_CA_list(ctx, nm);\n    }\n#ifndef OPENSSL_NO_ENGINE\n    if (ssl_client_engine) {\n        if (!SSL_CTX_set_client_cert_engine(ctx, ssl_client_engine)) {\n            BIO_puts(bio_err, \"Error setting client auth engine\\n\");\n            ERR_print_errors(bio_err);\n            release_engine(ssl_client_engine);\n            goto end;\n        }\n        release_engine(ssl_client_engine);\n    }\n#endif\n\n#ifndef OPENSSL_NO_PSK\n    if (psk_key != NULL) {\n        if (c_debug)\n            BIO_printf(bio_c_out, \"PSK key given, setting client callback\\n\");\n        SSL_CTX_set_psk_client_callback(ctx, psk_client_cb);\n    }\n#endif\n    if (psksessf != NULL) {\n        BIO *stmp = BIO_new_file(psksessf, \"r\");\n\n        if (stmp == NULL) {\n            BIO_printf(bio_err, \"Can't open PSK session file %s\\n\", psksessf);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        psksess = PEM_read_bio_SSL_SESSION(stmp, NULL, 0, NULL);\n        BIO_free(stmp);\n        if (psksess == NULL) {\n            BIO_printf(bio_err, \"Can't read PSK session file %s\\n\", psksessf);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n    if (psk_key != NULL || psksess != NULL)\n        SSL_CTX_set_psk_use_session_callback(ctx, psk_use_session_cb);\n\n#ifndef OPENSSL_NO_SRTP\n    if (srtp_profiles != NULL) {\n        /* Returns 0 on success! */\n        if (SSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles) != 0) {\n            BIO_printf(bio_err, \"Error setting SRTP profile\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n#endif\n\n    if (exc != NULL)\n        ssl_ctx_set_excert(ctx, exc);\n\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    if (next_proto.data != NULL)\n        SSL_CTX_set_next_proto_select_cb(ctx, next_proto_cb, &next_proto);\n#endif\n    if (alpn_in) {\n        size_t alpn_len;\n        unsigned char *alpn = next_protos_parse(&alpn_len, alpn_in);\n\n        if (alpn == NULL) {\n            BIO_printf(bio_err, \"Error parsing -alpn argument\\n\");\n            goto end;\n        }\n        /* Returns 0 on success! */\n        if (SSL_CTX_set_alpn_protos(ctx, alpn, alpn_len) != 0) {\n            BIO_printf(bio_err, \"Error setting ALPN\\n\");\n            goto end;\n        }\n        OPENSSL_free(alpn);\n    }\n\n    for (i = 0; i < serverinfo_count; i++) {\n        if (!SSL_CTX_add_client_custom_ext(ctx,\n                                           serverinfo_types[i],\n                                           NULL, NULL, NULL,\n                                           serverinfo_cli_parse_cb, NULL)) {\n            BIO_printf(bio_err,\n                       \"Warning: Unable to add custom extension %u, skipping\\n\",\n                       serverinfo_types[i]);\n        }\n    }\n\n    if (state)\n        SSL_CTX_set_info_callback(ctx, apps_ssl_info_callback);\n\n#ifndef OPENSSL_NO_CT\n    /* Enable SCT processing, without early connection termination */\n    if (ct_validation &&\n        !SSL_CTX_enable_ct(ctx, SSL_CT_VALIDATION_PERMISSIVE)) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    if (!ctx_set_ctlog_list_file(ctx, ctlog_file)) {\n        if (ct_validation) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n\n        /*\n         * If CT validation is not enabled, the log list isn't needed so don't\n         * show errors or abort. We try to load it regardless because then we\n         * can show the names of the logs any SCTs came from (SCTs may be seen\n         * even with validation disabled).\n         */\n        ERR_clear_error();\n    }\n#endif\n\n    SSL_CTX_set_verify(ctx, verify, verify_callback);\n\n    if (!ctx_set_verify_locations(ctx, CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    ssl_ctx_add_crls(ctx, crls, crl_download);\n\n    if (!set_cert_key_stuff(ctx, cert, key, chain, build_chain))\n        goto end;\n\n    if (!noservername) {\n        tlsextcbp.biodebug = bio_err;\n        SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);\n        SSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);\n    }\n#ifndef OPENSSL_NO_SRP\n    if (srp_arg.srplogin != NULL\n            && !set_up_srp_arg(ctx, &srp_arg, srp_lateuser, c_msg, c_debug))\n        goto end;\n# endif\n\n    if (dane_tlsa_domain != NULL) {\n        if (SSL_CTX_dane_enable(ctx) <= 0) {\n            BIO_printf(bio_err,\n                       \"%s: Error enabling DANE TLSA authentication.\\n\",\n                       prog);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    /*\n     * In TLSv1.3 NewSessionTicket messages arrive after the handshake and can\n     * come at any time. Therefore, we use a callback to write out the session\n     * when we know about it. This approach works for < TLSv1.3 as well.\n     */\n    SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_CLIENT\n                                        | SSL_SESS_CACHE_NO_INTERNAL_STORE);\n    SSL_CTX_sess_set_new_cb(ctx, new_session_cb);\n\n    if (set_keylog_file(ctx, keylog_file))\n        goto end;\n\n    con = SSL_new(ctx);\n    if (con == NULL)\n        goto end;\n\n    if (enable_pha)\n        SSL_set_post_handshake_auth(con, 1);\n\n    if (enable_client_rpk)\n        if (!SSL_set1_client_cert_type(con, cert_type_rpk, sizeof(cert_type_rpk))) {\n            BIO_printf(bio_err, \"Error setting client certificate types\\n\");\n            goto end;\n        }\n    if (enable_server_rpk) {\n        if (!SSL_set1_server_cert_type(con, cert_type_rpk, sizeof(cert_type_rpk))) {\n            BIO_printf(bio_err, \"Error setting server certificate types\\n\");\n            goto end;\n        }\n    }\n\n    if (sess_in != NULL) {\n        SSL_SESSION *sess;\n        BIO *stmp = BIO_new_file(sess_in, \"r\");\n        if (stmp == NULL) {\n            BIO_printf(bio_err, \"Can't open session file %s\\n\", sess_in);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        sess = PEM_read_bio_SSL_SESSION(stmp, NULL, 0, NULL);\n        BIO_free(stmp);\n        if (sess == NULL) {\n            BIO_printf(bio_err, \"Can't open session file %s\\n\", sess_in);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        if (!SSL_set_session(con, sess)) {\n            BIO_printf(bio_err, \"Can't set session\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n\n        SSL_SESSION_free(sess);\n    }\n\n    if (fallback_scsv)\n        SSL_set_mode(con, SSL_MODE_SEND_FALLBACK_SCSV);\n\n    if (!noservername && (servername != NULL || dane_tlsa_domain == NULL)) {\n        if (servername == NULL) {\n            if (host == NULL || is_dNS_name(host))\n                servername = (host == NULL) ? \"localhost\" : host;\n        }\n        if (servername != NULL && !SSL_set_tlsext_host_name(con, servername)) {\n            BIO_printf(bio_err, \"Unable to set TLS servername extension.\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (dane_tlsa_domain != NULL) {\n        if (SSL_dane_enable(con, dane_tlsa_domain) <= 0) {\n            BIO_printf(bio_err, \"%s: Error enabling DANE TLSA \"\n                       \"authentication.\\n\", prog);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        if (dane_tlsa_rrset == NULL) {\n            BIO_printf(bio_err, \"%s: DANE TLSA authentication requires at \"\n                       \"least one -dane_tlsa_rrdata option.\\n\", prog);\n            goto end;\n        }\n        if (tlsa_import_rrset(con, dane_tlsa_rrset) <= 0) {\n            BIO_printf(bio_err, \"%s: Failed to import any TLSA \"\n                       \"records.\\n\", prog);\n            goto end;\n        }\n        if (dane_ee_no_name)\n            SSL_dane_set_flags(con, DANE_FLAG_NO_DANE_EE_NAMECHECKS);\n    } else if (dane_tlsa_rrset != NULL) {\n        BIO_printf(bio_err, \"%s: DANE TLSA authentication requires the \"\n                   \"-dane_tlsa_domain option.\\n\", prog);\n        goto end;\n    }\n#ifndef OPENSSL_NO_DTLS\n    if (isdtls && tfo) {\n        BIO_printf(bio_err, \"%s: DTLS does not support the -tfo option\\n\", prog);\n        goto end;\n    }\n#endif\n#ifndef OPENSSL_NO_QUIC\n    if (isquic && tfo) {\n        BIO_printf(bio_err, \"%s: QUIC does not support the -tfo option\\n\", prog);\n        goto end;\n    }\n    if (isquic && alpn_in == NULL) {\n        BIO_printf(bio_err, \"%s: QUIC requires ALPN to be specified (e.g. \\\"h3\\\" for HTTP/3) via the -alpn option\\n\", prog);\n        goto end;\n    }\n#endif\n\n    if (tfo)\n        BIO_printf(bio_c_out, \"Connecting via TFO\\n\");\n re_start:\n    /* peer_addr might be set from previous connections */\n    BIO_ADDR_free(peer_addr);\n    peer_addr = NULL;\n    if (init_client(&sock, host, port, bindhost, bindport, socket_family,\n                    socket_type, protocol, tfo, !isquic, &peer_addr) == 0) {\n        BIO_printf(bio_err, \"connect:errno=%d\\n\", get_last_socket_error());\n        BIO_closesocket(sock);\n        goto end;\n    }\n    BIO_printf(bio_c_out, \"CONNECTED(%08X)\\n\", sock);\n\n    /*\n     * QUIC always uses a non-blocking socket - and we have to switch on\n     * non-blocking mode at the SSL level\n     */\n    if (c_nbio || isquic) {\n        if (!BIO_socket_nbio(sock, 1)) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        if (c_nbio) {\n            if (isquic && !SSL_set_blocking_mode(con, 0))\n                goto end;\n            BIO_printf(bio_c_out, \"Turned on non blocking io\\n\");\n        }\n    }\n#ifndef OPENSSL_NO_DTLS\n    if (isdtls) {\n        union BIO_sock_info_u peer_info;\n\n#ifndef OPENSSL_NO_SCTP\n        if (protocol == IPPROTO_SCTP)\n            sbio = BIO_new_dgram_sctp(sock, BIO_NOCLOSE);\n        else\n#endif\n            sbio = BIO_new_dgram(sock, BIO_NOCLOSE);\n\n        if (sbio == NULL || (peer_info.addr = BIO_ADDR_new()) == NULL) {\n            BIO_printf(bio_err, \"memory allocation failure\\n\");\n            BIO_free(sbio);\n            BIO_closesocket(sock);\n            goto end;\n        }\n        if (!BIO_sock_info(sock, BIO_SOCK_INFO_ADDRESS, &peer_info)) {\n            BIO_printf(bio_err, \"getsockname:errno=%d\\n\",\n                       get_last_socket_error());\n            BIO_free(sbio);\n            BIO_ADDR_free(peer_info.addr);\n            BIO_closesocket(sock);\n            goto end;\n        }\n\n        (void)BIO_ctrl_set_connected(sbio, peer_info.addr);\n        BIO_ADDR_free(peer_info.addr);\n        peer_info.addr = NULL;\n\n        if (enable_timeouts) {\n            timeout.tv_sec = 0;\n            timeout.tv_usec = DGRAM_RCV_TIMEOUT;\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_RECV_TIMEOUT, 0, &timeout);\n\n            timeout.tv_sec = 0;\n            timeout.tv_usec = DGRAM_SND_TIMEOUT;\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_SET_SEND_TIMEOUT, 0, &timeout);\n        }\n\n        if (socket_mtu) {\n            if (socket_mtu < DTLS_get_link_min_mtu(con)) {\n                BIO_printf(bio_err, \"MTU too small. Must be at least %ld\\n\",\n                           DTLS_get_link_min_mtu(con));\n                BIO_free(sbio);\n                goto shut;\n            }\n            SSL_set_options(con, SSL_OP_NO_QUERY_MTU);\n            if (!DTLS_set_link_mtu(con, socket_mtu)) {\n                BIO_printf(bio_err, \"Failed to set MTU\\n\");\n                BIO_free(sbio);\n                goto shut;\n            }\n        } else {\n            /* want to do MTU discovery */\n            BIO_ctrl(sbio, BIO_CTRL_DGRAM_MTU_DISCOVER, 0, NULL);\n        }\n    } else\n#endif /* OPENSSL_NO_DTLS */\n#ifndef OPENSSL_NO_QUIC\n    if (isquic) {\n        sbio = BIO_new_dgram(sock, BIO_NOCLOSE);\n        if (!SSL_set1_initial_peer_addr(con, peer_addr)) {\n            BIO_printf(bio_err, \"Failed to set the initial peer address\\n\");\n            goto shut;\n        }\n    } else\n#endif\n        sbio = BIO_new_socket(sock, BIO_NOCLOSE);\n\n    if (sbio == NULL) {\n        BIO_printf(bio_err, \"Unable to create BIO\\n\");\n        ERR_print_errors(bio_err);\n        BIO_closesocket(sock);\n        goto end;\n    }\n\n    /* Now that we're using a BIO... */\n    if (tfo) {\n        (void)BIO_set_conn_address(sbio, peer_addr);\n        (void)BIO_set_tfo(sbio, 1);\n    }\n\n    if (nbio_test) {\n        BIO *test;\n\n        test = BIO_new(BIO_f_nbio_test());\n        if (test == NULL) {\n            BIO_printf(bio_err, \"Unable to create BIO\\n\");\n            BIO_free(sbio);\n            goto shut;\n        }\n        sbio = BIO_push(test, sbio);\n    }\n\n    if (c_debug) {\n        BIO_set_callback_ex(sbio, bio_dump_callback);\n        BIO_set_callback_arg(sbio, (char *)bio_c_out);\n    }\n    if (c_msg) {\n#ifndef OPENSSL_NO_SSL_TRACE\n        if (c_msg == 2)\n            SSL_set_msg_callback(con, SSL_trace);\n        else\n#endif\n            SSL_set_msg_callback(con, msg_cb);\n        SSL_set_msg_callback_arg(con, bio_c_msg ? bio_c_msg : bio_c_out);\n    }\n\n    if (c_tlsextdebug) {\n        SSL_set_tlsext_debug_callback(con, tlsext_cb);\n        SSL_set_tlsext_debug_arg(con, bio_c_out);\n    }\n#ifndef OPENSSL_NO_OCSP\n    if (c_status_req) {\n        SSL_set_tlsext_status_type(con, TLSEXT_STATUSTYPE_ocsp);\n        SSL_CTX_set_tlsext_status_cb(ctx, ocsp_resp_cb);\n        SSL_CTX_set_tlsext_status_arg(ctx, bio_c_out);\n    }\n#endif\n\n    SSL_set_bio(con, sbio, sbio);\n    SSL_set_connect_state(con);\n\n    /* ok, lets connect */\n    if (fileno_stdin() > SSL_get_fd(con))\n        width = fileno_stdin() + 1;\n    else\n        width = SSL_get_fd(con) + 1;\n\n    read_tty = 1;\n    write_tty = 0;\n    tty_on = 0;\n    read_ssl = 1;\n    write_ssl = 1;\n    first_loop = 1;\n\n    cbuf_len = 0;\n    cbuf_off = 0;\n    sbuf_len = 0;\n    sbuf_off = 0;\n\n#ifndef OPENSSL_NO_HTTP\n    if (proxystr != NULL) {\n        /* Here we must use the connect string target host & port */\n        if (!OSSL_HTTP_proxy_connect(sbio, thost, tport, proxyuser, proxypass,\n                                     0 /* no timeout */, bio_err, prog))\n            goto shut;\n    }\n#endif\n\n    switch ((PROTOCOL_CHOICE) starttls_proto) {\n    case PROTO_OFF:\n        break;\n    case PROTO_LMTP:\n    case PROTO_SMTP:\n        {\n            /*\n             * This is an ugly hack that does a lot of assumptions. We do\n             * have to handle multi-line responses which may come in a single\n             * packet or not. We therefore have to use BIO_gets() which does\n             * need a buffering BIO. So during the initial chitchat we do\n             * push a buffering BIO into the chain that is removed again\n             * later on to not disturb the rest of the s_client operation.\n             */\n            int foundit = 0;\n            BIO *fbio = BIO_new(BIO_f_buffer());\n\n            if (fbio == NULL) {\n                BIO_printf(bio_err, \"Unable to create BIO\\n\");\n                goto shut;\n            }\n            BIO_push(fbio, sbio);\n            /* Wait for multi-line response to end from LMTP or SMTP */\n            do {\n                mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\n            } while (mbuf_len > 3 && mbuf[3] == '-');\n            if (protohost == NULL)\n                protohost = \"mail.example.com\";\n            if (starttls_proto == (int)PROTO_LMTP)\n                BIO_printf(fbio, \"LHLO %s\\r\\n\", protohost);\n            else\n                BIO_printf(fbio, \"EHLO %s\\r\\n\", protohost);\n            (void)BIO_flush(fbio);\n            /*\n             * Wait for multi-line response to end LHLO LMTP or EHLO SMTP\n             * response.\n             */\n            do {\n                mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\n                if (strstr(mbuf, \"STARTTLS\"))\n                    foundit = 1;\n            } while (mbuf_len > 3 && mbuf[3] == '-');\n            (void)BIO_flush(fbio);\n            BIO_pop(fbio);\n            BIO_free(fbio);\n            if (!foundit)\n                BIO_printf(bio_err,\n                           \"Didn't find STARTTLS in server response,\"\n                           \" trying anyway...\\n\");\n            BIO_printf(sbio, \"STARTTLS\\r\\n\");\n            BIO_read(sbio, sbuf, BUFSIZZ);\n        }\n        break;\n    case PROTO_POP3:\n        {\n            BIO_read(sbio, mbuf, BUFSIZZ);\n            BIO_printf(sbio, \"STLS\\r\\n\");\n            mbuf_len = BIO_read(sbio, sbuf, BUFSIZZ);\n            if (mbuf_len < 0) {\n                BIO_printf(bio_err, \"BIO_read failed\\n\");\n                goto end;\n            }\n        }\n        break;\n    case PROTO_IMAP:\n        {\n            int foundit = 0;\n            BIO *fbio = BIO_new(BIO_f_buffer());\n\n            if (fbio == NULL) {\n                BIO_printf(bio_err, \"Unable to create BIO\\n\");\n                goto shut;\n            }\n            BIO_push(fbio, sbio);\n            BIO_gets(fbio, mbuf, BUFSIZZ);\n            /* STARTTLS command requires CAPABILITY... */\n            BIO_printf(fbio, \". CAPABILITY\\r\\n\");\n            (void)BIO_flush(fbio);\n            /* wait for multi-line CAPABILITY response */\n            do {\n                mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\n                if (strstr(mbuf, \"STARTTLS\"))\n                    foundit = 1;\n            }\n            while (mbuf_len > 3 && mbuf[0] != '.');\n            (void)BIO_flush(fbio);\n            BIO_pop(fbio);\n            BIO_free(fbio);\n            if (!foundit)\n                BIO_printf(bio_err,\n                           \"Didn't find STARTTLS in server response,\"\n                           \" trying anyway...\\n\");\n            BIO_printf(sbio, \". STARTTLS\\r\\n\");\n            BIO_read(sbio, sbuf, BUFSIZZ);\n        }\n        break;\n    case PROTO_FTP:\n        {\n            BIO *fbio = BIO_new(BIO_f_buffer());\n\n            if (fbio == NULL) {\n                BIO_printf(bio_err, \"Unable to create BIO\\n\");\n                goto shut;\n            }\n            BIO_push(fbio, sbio);\n            /* wait for multi-line response to end from FTP */\n            do {\n                mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\n            }\n            while (mbuf_len > 3 && (!isdigit((unsigned char)mbuf[0]) || !isdigit((unsigned char)mbuf[1]) || !isdigit((unsigned char)mbuf[2]) || mbuf[3] != ' '));\n            (void)BIO_flush(fbio);\n            BIO_pop(fbio);\n            BIO_free(fbio);\n            BIO_printf(sbio, \"AUTH TLS\\r\\n\");\n            BIO_read(sbio, sbuf, BUFSIZZ);\n        }\n        break;\n    case PROTO_XMPP:\n    case PROTO_XMPP_SERVER:\n        {\n            int seen = 0;\n            BIO_printf(sbio, \"<stream:stream \"\n                       \"xmlns:stream='http://etherx.jabber.org/streams' \"\n                       \"xmlns='jabber:%s' to='%s' version='1.0'>\",\n                       starttls_proto == PROTO_XMPP ? \"client\" : \"server\",\n                       protohost ? protohost : host);\n            seen = BIO_read(sbio, mbuf, BUFSIZZ);\n            if (seen < 0) {\n                BIO_printf(bio_err, \"BIO_read failed\\n\");\n                goto end;\n            }\n            mbuf[seen] = '\\0';\n            while (!strstr\n                   (mbuf, \"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'\")\n                   && !strstr(mbuf,\n                              \"<starttls xmlns=\\\"urn:ietf:params:xml:ns:xmpp-tls\\\"\"))\n            {\n                seen = BIO_read(sbio, mbuf, BUFSIZZ);\n\n                if (seen <= 0)\n                    goto shut;\n\n                mbuf[seen] = '\\0';\n            }\n            BIO_printf(sbio,\n                       \"<starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\");\n            seen = BIO_read(sbio, sbuf, BUFSIZZ);\n            if (seen < 0) {\n                BIO_printf(bio_err, \"BIO_read failed\\n\");\n                goto shut;\n            }\n            sbuf[seen] = '\\0';\n            if (!strstr(sbuf, \"<proceed\"))\n                goto shut;\n            mbuf[0] = '\\0';\n        }\n        break;\n    case PROTO_TELNET:\n        {\n            static const unsigned char tls_do[] = {\n                /* IAC    DO   START_TLS */\n                   255,   253, 46\n            };\n            static const unsigned char tls_will[] = {\n                /* IAC  WILL START_TLS */\n                   255, 251, 46\n            };\n            static const unsigned char tls_follows[] = {\n                /* IAC  SB   START_TLS FOLLOWS IAC  SE */\n                   255, 250, 46,       1,      255, 240\n            };\n            int bytes;\n\n            /* Telnet server should demand we issue START_TLS */\n            bytes = BIO_read(sbio, mbuf, BUFSIZZ);\n            if (bytes != 3 || memcmp(mbuf, tls_do, 3) != 0)\n                goto shut;\n            /* Agree to issue START_TLS and send the FOLLOWS sub-command */\n            BIO_write(sbio, tls_will, 3);\n            BIO_write(sbio, tls_follows, 6);\n            (void)BIO_flush(sbio);\n            /* Telnet server also sent the FOLLOWS sub-command */\n            bytes = BIO_read(sbio, mbuf, BUFSIZZ);\n            if (bytes != 6 || memcmp(mbuf, tls_follows, 6) != 0)\n                goto shut;\n        }\n        break;\n    case PROTO_IRC:\n        {\n            int numeric;\n            BIO *fbio = BIO_new(BIO_f_buffer());\n\n            if (fbio == NULL) {\n                BIO_printf(bio_err, \"Unable to create BIO\\n\");\n                goto end;\n            }\n            BIO_push(fbio, sbio);\n            BIO_printf(fbio, \"STARTTLS\\r\\n\");\n            (void)BIO_flush(fbio);\n            width = SSL_get_fd(con) + 1;\n\n            do {\n                numeric = 0;\n\n                FD_ZERO(&readfds);\n                openssl_fdset(SSL_get_fd(con), &readfds);\n                timeout.tv_sec = S_CLIENT_IRC_READ_TIMEOUT;\n                timeout.tv_usec = 0;\n                /*\n                 * If the IRCd doesn't respond within\n                 * S_CLIENT_IRC_READ_TIMEOUT seconds, assume\n                 * it doesn't support STARTTLS. Many IRCds\n                 * will not give _any_ sort of response to a\n                 * STARTTLS command when it's not supported.\n                 */\n                if (!BIO_get_buffer_num_lines(fbio)\n                    && !BIO_pending(fbio)\n                    && !BIO_pending(sbio)\n                    && select(width, (void *)&readfds, NULL, NULL,\n                              &timeout) < 1) {\n                    BIO_printf(bio_err,\n                               \"Timeout waiting for response (%d seconds).\\n\",\n                               S_CLIENT_IRC_READ_TIMEOUT);\n                    break;\n                }\n\n                mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\n                if (mbuf_len < 1 || sscanf(mbuf, \"%*s %d\", &numeric) != 1)\n                    break;\n                /* :example.net 451 STARTTLS :You have not registered */\n                /* :example.net 421 STARTTLS :Unknown command */\n                if ((numeric == 451 || numeric == 421)\n                    && strstr(mbuf, \"STARTTLS\") != NULL) {\n                    BIO_printf(bio_err, \"STARTTLS not supported: %s\", mbuf);\n                    break;\n                }\n                if (numeric == 691) {\n                    BIO_printf(bio_err, \"STARTTLS negotiation failed: \");\n                    ERR_print_errors(bio_err);\n                    break;\n                }\n            } while (numeric != 670);\n\n            (void)BIO_flush(fbio);\n            BIO_pop(fbio);\n            BIO_free(fbio);\n            if (numeric != 670) {\n                BIO_printf(bio_err, \"Server does not support STARTTLS.\\n\");\n                ret = 1;\n                goto shut;\n            }\n        }\n        break;\n    case PROTO_MYSQL:\n        {\n            /* SSL request packet */\n            static const unsigned char ssl_req[] = {\n                /* payload_length,   sequence_id */\n                   0x20, 0x00, 0x00, 0x01,\n                /* payload */\n                /* capability flags, CLIENT_SSL always set */\n                   0x85, 0xae, 0x7f, 0x00,\n                /* max-packet size */\n                   0x00, 0x00, 0x00, 0x01,\n                /* character set */\n                   0x21,\n                /* string[23] reserved (all [0]) */\n                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n            };\n            int bytes = 0;\n            int ssl_flg = 0x800;\n            int pos;\n            const unsigned char *packet = (const unsigned char *)sbuf;\n\n            /* Receiving Initial Handshake packet. */\n            bytes = BIO_read(sbio, (void *)packet, BUFSIZZ);\n            if (bytes < 0) {\n                BIO_printf(bio_err, \"BIO_read failed\\n\");\n                goto shut;\n            /* Packet length[3], Packet number[1] + minimum payload[17] */\n            } else if (bytes < 21) {\n                BIO_printf(bio_err, \"MySQL packet too short.\\n\");\n                goto shut;\n            } else if (bytes != (4 + packet[0] +\n                                 (packet[1] << 8) +\n                                 (packet[2] << 16))) {\n                BIO_printf(bio_err, \"MySQL packet length does not match.\\n\");\n                goto shut;\n            /* protocol version[1] */\n            } else if (packet[4] != 0xA) {\n                BIO_printf(bio_err,\n                           \"Only MySQL protocol version 10 is supported.\\n\");\n                goto shut;\n            }\n\n            pos = 5;\n            /* server version[string+NULL] */\n            for (;;) {\n                if (pos >= bytes) {\n                    BIO_printf(bio_err, \"Cannot confirm server version. \");\n                    goto shut;\n                } else if (packet[pos++] == '\\0') {\n                    break;\n                }\n            }\n\n            /* make sure we have at least 15 bytes left in the packet */\n            if (pos + 15 > bytes) {\n                BIO_printf(bio_err,\n                           \"MySQL server handshake packet is broken.\\n\");\n                goto shut;\n            }\n\n            pos += 12; /* skip over conn id[4] + SALT[8] */\n            if (packet[pos++] != '\\0') { /* verify filler */\n                BIO_printf(bio_err,\n                           \"MySQL packet is broken.\\n\");\n                goto shut;\n            }\n\n            /* capability flags[2] */\n            if (!((packet[pos] + (packet[pos + 1] << 8)) & ssl_flg)) {\n                BIO_printf(bio_err, \"MySQL server does not support SSL.\\n\");\n                goto shut;\n            }\n\n            /* Sending SSL Handshake packet. */\n            BIO_write(sbio, ssl_req, sizeof(ssl_req));\n            (void)BIO_flush(sbio);\n        }\n        break;\n    case PROTO_POSTGRES:\n        {\n            static const unsigned char ssl_request[] = {\n                /* Length        SSLRequest */\n                   0, 0, 0, 8,   4, 210, 22, 47\n            };\n            int bytes;\n\n            /* Send SSLRequest packet */\n            BIO_write(sbio, ssl_request, 8);\n            (void)BIO_flush(sbio);\n\n            /* Reply will be a single S if SSL is enabled */\n            bytes = BIO_read(sbio, sbuf, BUFSIZZ);\n            if (bytes != 1 || sbuf[0] != 'S')\n                goto shut;\n        }\n        break;\n    case PROTO_NNTP:\n        {\n            int foundit = 0;\n            BIO *fbio = BIO_new(BIO_f_buffer());\n\n            if (fbio == NULL) {\n                BIO_printf(bio_err, \"Unable to create BIO\\n\");\n                goto end;\n            }\n            BIO_push(fbio, sbio);\n            BIO_gets(fbio, mbuf, BUFSIZZ);\n            /* STARTTLS command requires CAPABILITIES... */\n            BIO_printf(fbio, \"CAPABILITIES\\r\\n\");\n            (void)BIO_flush(fbio);\n            BIO_gets(fbio, mbuf, BUFSIZZ);\n            /* no point in trying to parse the CAPABILITIES response if there is none */\n            if (strstr(mbuf, \"101\") != NULL) {\n                /* wait for multi-line CAPABILITIES response */\n                do {\n                    mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\n                    if (strstr(mbuf, \"STARTTLS\"))\n                        foundit = 1;\n                } while (mbuf_len > 1 && mbuf[0] != '.');\n            }\n            (void)BIO_flush(fbio);\n            BIO_pop(fbio);\n            BIO_free(fbio);\n            if (!foundit)\n                BIO_printf(bio_err,\n                           \"Didn't find STARTTLS in server response,\"\n                           \" trying anyway...\\n\");\n            BIO_printf(sbio, \"STARTTLS\\r\\n\");\n            mbuf_len = BIO_read(sbio, mbuf, BUFSIZZ);\n            if (mbuf_len < 0) {\n                BIO_printf(bio_err, \"BIO_read failed\\n\");\n                goto end;\n            }\n            mbuf[mbuf_len] = '\\0';\n            if (strstr(mbuf, \"382\") == NULL) {\n                BIO_printf(bio_err, \"STARTTLS failed: %s\", mbuf);\n                goto shut;\n            }\n        }\n        break;\n    case PROTO_SIEVE:\n        {\n            int foundit = 0;\n            BIO *fbio = BIO_new(BIO_f_buffer());\n\n            if (fbio == NULL) {\n                BIO_printf(bio_err, \"Unable to create BIO\\n\");\n                goto end;\n            }\n            BIO_push(fbio, sbio);\n            /* wait for multi-line response to end from Sieve */\n            do {\n                mbuf_len = BIO_gets(fbio, mbuf, BUFSIZZ);\n                /*\n                 * According to RFC 5804 \u00a7 1.7, capability\n                 * is case-insensitive, make it uppercase\n                 */\n                if (mbuf_len > 1 && mbuf[0] == '\"') {\n                    make_uppercase(mbuf);\n                    if (HAS_PREFIX(mbuf, \"\\\"STARTTLS\\\"\"))\n                        foundit = 1;\n                }\n            } while (mbuf_len > 1 && mbuf[0] == '\"');\n            (void)BIO_flush(fbio);\n            BIO_pop(fbio);\n            BIO_free(fbio);\n            if (!foundit)\n                BIO_printf(bio_err,\n                           \"Didn't find STARTTLS in server response,\"\n                           \" trying anyway...\\n\");\n            BIO_printf(sbio, \"STARTTLS\\r\\n\");\n            mbuf_len = BIO_read(sbio, mbuf, BUFSIZZ);\n            if (mbuf_len < 0) {\n                BIO_printf(bio_err, \"BIO_read failed\\n\");\n                goto end;\n            }\n            mbuf[mbuf_len] = '\\0';\n            if (mbuf_len < 2) {\n                BIO_printf(bio_err, \"STARTTLS failed: %s\", mbuf);\n                goto shut;\n            }\n            /*\n             * According to RFC 5804 \u00a7 2.2, response codes are case-\n             * insensitive, make it uppercase but preserve the response.\n             */\n            strncpy(sbuf, mbuf, 2);\n            make_uppercase(sbuf);\n            if (!HAS_PREFIX(sbuf, \"OK\")) {\n                BIO_printf(bio_err, \"STARTTLS not supported: %s\", mbuf);\n                goto shut;\n            }\n        }\n        break;\n    case PROTO_LDAP:\n        {\n            /* StartTLS Operation according to RFC 4511 */\n            static char ldap_tls_genconf[] = \"asn1=SEQUENCE:LDAPMessage\\n\"\n                \"[LDAPMessage]\\n\"\n                \"messageID=INTEGER:1\\n\"\n                \"extendedReq=EXPLICIT:23A,IMPLICIT:0C,\"\n                \"FORMAT:ASCII,OCT:1.3.6.1.4.1.1466.20037\\n\";\n            long errline = -1;\n            char *genstr = NULL;\n            int result = -1;\n            ASN1_TYPE *atyp = NULL;\n            BIO *ldapbio = BIO_new(BIO_s_mem());\n            CONF *cnf = NCONF_new(NULL);\n\n            if (ldapbio == NULL || cnf == NULL) {\n                BIO_free(ldapbio);\n                NCONF_free(cnf);\n                goto end;\n            }\n            BIO_puts(ldapbio, ldap_tls_genconf);\n            if (NCONF_load_bio(cnf, ldapbio, &errline) <= 0) {\n                BIO_free(ldapbio);\n                NCONF_free(cnf);\n                if (errline <= 0) {\n                    BIO_printf(bio_err, \"NCONF_load_bio failed\\n\");\n                    goto end;\n                } else {\n                    BIO_printf(bio_err, \"Error on line %ld\\n\", errline);\n                    goto end;\n                }\n            }\n            BIO_free(ldapbio);\n            genstr = NCONF_get_string(cnf, \"default\", \"asn1\");\n            if (genstr == NULL) {\n                NCONF_free(cnf);\n                BIO_printf(bio_err, \"NCONF_get_string failed\\n\");\n                goto end;\n            }\n            atyp = ASN1_generate_nconf(genstr, cnf);\n            if (atyp == NULL) {\n                NCONF_free(cnf);\n                BIO_printf(bio_err, \"ASN1_generate_nconf failed\\n\");\n                goto end;\n            }\n            NCONF_free(cnf);\n\n            /* Send SSLRequest packet */\n            BIO_write(sbio, atyp->value.sequence->data,\n                      atyp->value.sequence->length);\n            (void)BIO_flush(sbio);\n            ASN1_TYPE_free(atyp);\n\n            mbuf_len = BIO_read(sbio, mbuf, BUFSIZZ);\n            if (mbuf_len < 0) {\n                BIO_printf(bio_err, \"BIO_read failed\\n\");\n                goto end;\n            }\n            result = ldap_ExtendedResponse_parse(mbuf, mbuf_len);\n            if (result < 0) {\n                BIO_printf(bio_err, \"ldap_ExtendedResponse_parse failed\\n\");\n                goto shut;\n            } else if (result > 0) {\n                BIO_printf(bio_err, \"STARTTLS failed, LDAP Result Code: %i\\n\",\n                           result);\n                goto shut;\n            }\n            mbuf_len = 0;\n        }\n        break;\n    }\n\n    if (early_data_file != NULL\n            && ((SSL_get0_session(con) != NULL\n                 && SSL_SESSION_get_max_early_data(SSL_get0_session(con)) > 0)\n                || (psksess != NULL\n                    && SSL_SESSION_get_max_early_data(psksess) > 0))) {\n        BIO *edfile = BIO_new_file(early_data_file, \"r\");\n        size_t readbytes, writtenbytes;\n        int finish = 0;\n\n        if (edfile == NULL) {\n            BIO_printf(bio_err, \"Cannot open early data file\\n\");\n            goto shut;\n        }\n\n        while (!finish) {\n            if (!BIO_read_ex(edfile, cbuf, BUFSIZZ, &readbytes))\n                finish = 1;\n\n            while (!SSL_write_early_data(con, cbuf, readbytes, &writtenbytes)) {\n                switch (SSL_get_error(con, 0)) {\n                case SSL_ERROR_WANT_WRITE:\n                case SSL_ERROR_WANT_ASYNC:\n                case SSL_ERROR_WANT_READ:\n                    /* Just keep trying - busy waiting */\n                    continue;\n                default:\n                    BIO_printf(bio_err, \"Error writing early data\\n\");\n                    BIO_free(edfile);\n                    ERR_print_errors(bio_err);\n                    goto shut;\n                }\n            }\n        }\n\n        BIO_free(edfile);\n    }\n\n    user_data_init(&user_data, con, cbuf, BUFSIZZ, cmdmode);\n    for (;;) {\n        FD_ZERO(&readfds);\n        FD_ZERO(&writefds);\n\n        if ((isdtls || isquic)\n            && SSL_get_event_timeout(con, &timeout, &is_infinite)\n            && !is_infinite)\n            timeoutp = &timeout;\n        else\n            timeoutp = NULL;\n\n        if (!SSL_is_init_finished(con) && SSL_total_renegotiations(con) == 0\n                && SSL_get_key_update_type(con) == SSL_KEY_UPDATE_NONE) {\n            in_init = 1;\n            tty_on = 0;\n        } else {\n            tty_on = 1;\n            if (in_init) {\n                in_init = 0;\n                if (c_brief) {\n                    BIO_puts(bio_err, \"CONNECTION ESTABLISHED\\n\");\n                    print_ssl_summary(con);\n                }\n\n                print_stuff(bio_c_out, con, full_log);\n                if (full_log > 0)\n                    full_log--;\n\n                if (starttls_proto) {\n                    BIO_write(bio_err, mbuf, mbuf_len);\n                    /* We don't need to know any more */\n                    if (!reconnect)\n                        starttls_proto = PROTO_OFF;\n                }\n\n                if (reconnect) {\n                    reconnect--;\n                    BIO_printf(bio_c_out,\n                               \"drop connection and then reconnect\\n\");\n                    do_ssl_shutdown(con);\n                    SSL_set_connect_state(con);\n                    BIO_closesocket(SSL_get_fd(con));\n                    goto re_start;\n                }\n            }\n        }\n\n        if (!write_ssl) {\n            do {\n                switch (user_data_process(&user_data, &cbuf_len, &cbuf_off)) {\n                default:\n                    BIO_printf(bio_err, \"ERROR\\n\");\n                    /* fall through */\n                case USER_DATA_PROCESS_SHUT:\n                    ret = 0;\n                    goto shut;\n\n                case USER_DATA_PROCESS_RESTART:\n                    goto re_start;\n\n                case USER_DATA_PROCESS_NO_DATA:\n                    break;\n\n                case USER_DATA_PROCESS_CONTINUE:\n                    write_ssl = 1;\n                    break;\n                }\n            } while (!write_ssl\n                     && cbuf_len == 0\n                     && user_data_has_data(&user_data));\n            if (cbuf_len > 0) {\n                read_tty = 0;\n                timeout.tv_sec = 0;\n                timeout.tv_usec = 0;\n            } else {\n                read_tty = 1;\n            }\n        }\n\n        ssl_pending = read_ssl && SSL_has_pending(con);\n\n        if (!ssl_pending) {\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS)\n            if (tty_on) {\n                /*\n                 * Note that select() returns when read _would not block_,\n                 * and EOF satisfies that.  To avoid a CPU-hogging loop,\n                 * set the flag so we exit.\n                 */\n                if (read_tty && !at_eof)\n                    openssl_fdset(fileno_stdin(), &readfds);\n#if !defined(OPENSSL_SYS_VMS)\n                if (write_tty)\n                    openssl_fdset(fileno_stdout(), &writefds);\n#endif\n            }\n\n            /*\n             * Note that for QUIC we never actually check FD_ISSET() for the\n             * underlying network fds. We just rely on select waking up when\n             * they become readable/writeable and then SSL_handle_events() doing\n             * the right thing.\n             */\n            if ((!isquic && read_ssl)\n                    || (isquic && SSL_net_read_desired(con)))\n                openssl_fdset(SSL_get_fd(con), &readfds);\n            if ((!isquic && write_ssl)\n                    || (isquic && (first_loop || SSL_net_write_desired(con))))\n                openssl_fdset(SSL_get_fd(con), &writefds);\n#else\n            if (!tty_on || !write_tty) {\n                if ((!isquic && read_ssl)\n                        || (isquic && SSL_net_read_desired(con)))\n                    openssl_fdset(SSL_get_fd(con), &readfds);\n                if ((!isquic && write_ssl)\n                        || (isquic && (first_loop || SSL_net_write_desired(con))))\n                    openssl_fdset(SSL_get_fd(con), &writefds);\n            }\n#endif\n\n            /*\n             * Note: under VMS with SOCKETSHR the second parameter is\n             * currently of type (int *) whereas under other systems it is\n             * (void *) if you don't have a cast it will choke the compiler:\n             * if you do have a cast then you can either go for (int *) or\n             * (void *).\n             */\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS)\n            /*\n             * Under Windows/DOS we make the assumption that we can always\n             * write to the tty: therefore, if we need to write to the tty we\n             * just fall through. Otherwise we timeout the select every\n             * second and see if there are any keypresses. Note: this is a\n             * hack, in a proper Windows application we wouldn't do this.\n             */\n            i = 0;\n            if (!write_tty) {\n                if (read_tty) {\n                    tv.tv_sec = 1;\n                    tv.tv_usec = 0;\n                    i = select(width, (void *)&readfds, (void *)&writefds,\n                               NULL, &tv);\n                    if (!i && (!has_stdin_waiting() || !read_tty))\n                        continue;\n                } else\n                    i = select(width, (void *)&readfds, (void *)&writefds,\n                               NULL, timeoutp);\n            }\n#else\n            i = select(width, (void *)&readfds, (void *)&writefds,\n                       NULL, timeoutp);\n#endif\n            if (i < 0) {\n                BIO_printf(bio_err, \"bad select %d\\n\",\n                           get_last_socket_error());\n                goto shut;\n            }\n        }\n\n        if (timeoutp != NULL) {\n            SSL_handle_events(con);\n            if (isdtls\n                    && !FD_ISSET(SSL_get_fd(con), &readfds)\n                    && !FD_ISSET(SSL_get_fd(con), &writefds))\n                BIO_printf(bio_err, \"TIMEOUT occurred\\n\");\n        }\n\n        if (!ssl_pending\n                && ((!isquic && FD_ISSET(SSL_get_fd(con), &writefds))\n                    || (isquic && (cbuf_len > 0 || first_loop)))) {\n            k = SSL_write(con, &(cbuf[cbuf_off]), (unsigned int)cbuf_len);\n            switch (SSL_get_error(con, k)) {\n            case SSL_ERROR_NONE:\n                cbuf_off += k;\n                cbuf_len -= k;\n                if (k <= 0)\n                    goto end;\n                /* we have done a  write(con,NULL,0); */\n                if (cbuf_len == 0) {\n                    read_tty = 1;\n                    write_ssl = 0;\n                } else {        /* if (cbuf_len > 0) */\n\n                    read_tty = 0;\n                    write_ssl = 1;\n                }\n                break;\n            case SSL_ERROR_WANT_WRITE:\n                BIO_printf(bio_c_out, \"write W BLOCK\\n\");\n                write_ssl = 1;\n                read_tty = 0;\n                break;\n            case SSL_ERROR_WANT_ASYNC:\n                BIO_printf(bio_c_out, \"write A BLOCK\\n\");\n                wait_for_async(con);\n                write_ssl = 1;\n                read_tty = 0;\n                break;\n            case SSL_ERROR_WANT_READ:\n                BIO_printf(bio_c_out, \"write R BLOCK\\n\");\n                write_tty = 0;\n                read_ssl = 1;\n                write_ssl = 0;\n                break;\n            case SSL_ERROR_WANT_X509_LOOKUP:\n                BIO_printf(bio_c_out, \"write X BLOCK\\n\");\n                break;\n            case SSL_ERROR_ZERO_RETURN:\n                if (cbuf_len != 0) {\n                    BIO_printf(bio_c_out, \"shutdown\\n\");\n                    ret = 0;\n                    goto shut;\n                } else {\n                    read_tty = 1;\n                    write_ssl = 0;\n                    break;\n                }\n\n            case SSL_ERROR_SYSCALL:\n                if ((k != 0) || (cbuf_len != 0)) {\n                    int sockerr = get_last_socket_error();\n\n                    if (!tfo || sockerr != EISCONN) {\n                        BIO_printf(bio_err, \"write:errno=%d\\n\", sockerr);\n                        goto shut;\n                    }\n                } else {\n                    read_tty = 1;\n                    write_ssl = 0;\n                }\n                break;\n            case SSL_ERROR_WANT_ASYNC_JOB:\n                /* This shouldn't ever happen in s_client - treat as an error */\n            case SSL_ERROR_SSL:\n                ERR_print_errors(bio_err);\n                goto shut;\n            }\n        }\n#if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_VMS)\n        /* Assume Windows/DOS/BeOS can always write */\n        else if (!ssl_pending && write_tty)\n#else\n        else if (!ssl_pending && FD_ISSET(fileno_stdout(), &writefds))\n#endif\n        {\n#ifdef CHARSET_EBCDIC\n            ascii2ebcdic(&(sbuf[sbuf_off]), &(sbuf[sbuf_off]), sbuf_len);\n#endif\n            i = raw_write_stdout(&(sbuf[sbuf_off]), sbuf_len);\n\n            if (i <= 0) {\n                BIO_printf(bio_c_out, \"DONE\\n\");\n                ret = 0;\n                goto shut;\n            }\n\n            sbuf_len -= i;\n            sbuf_off += i;\n            if (sbuf_len <= 0) {\n                read_ssl = 1;\n                write_tty = 0;\n            }\n        } else if (ssl_pending\n                   || (!isquic && FD_ISSET(SSL_get_fd(con), &readfds))) {\n#ifdef RENEG\n            {\n                static int iiii;\n                if (++iiii == 52) {\n                    SSL_renegotiate(con);\n                    iiii = 0;\n                }\n            }\n#endif\n            k = SSL_read(con, sbuf, BUFSIZZ);\n\n            switch (SSL_get_error(con, k)) {\n            case SSL_ERROR_NONE:\n                if (k <= 0)\n                    goto end;\n                sbuf_off = 0;\n                sbuf_len = k;\n\n                read_ssl = 0;\n                write_tty = 1;\n                break;\n            case SSL_ERROR_WANT_ASYNC:\n                BIO_printf(bio_c_out, \"read A BLOCK\\n\");\n                wait_for_async(con);\n                write_tty = 0;\n                read_ssl = 1;\n                if ((read_tty == 0) && (write_ssl == 0))\n                    write_ssl = 1;\n                break;\n            case SSL_ERROR_WANT_WRITE:\n                BIO_printf(bio_c_out, \"read W BLOCK\\n\");\n                write_ssl = 1;\n                read_tty = 0;\n                break;\n            case SSL_ERROR_WANT_READ:\n                BIO_printf(bio_c_out, \"read R BLOCK\\n\");\n                write_tty = 0;\n                read_ssl = 1;\n                if ((read_tty == 0) && (write_ssl == 0))\n                    write_ssl = 1;\n                break;\n            case SSL_ERROR_WANT_X509_LOOKUP:\n                BIO_printf(bio_c_out, \"read X BLOCK\\n\");\n                break;\n            case SSL_ERROR_SYSCALL:\n                ret = get_last_socket_error();\n                if (c_brief)\n                    BIO_puts(bio_err, \"CONNECTION CLOSED BY SERVER\\n\");\n                else\n                    BIO_printf(bio_err, \"read:errno=%d\\n\", ret);\n                goto shut;\n            case SSL_ERROR_ZERO_RETURN:\n                BIO_printf(bio_c_out, \"closed\\n\");\n                ret = 0;\n                goto shut;\n            case SSL_ERROR_WANT_ASYNC_JOB:\n                /* This shouldn't ever happen in s_client. Treat as an error */\n            case SSL_ERROR_SSL:\n                ERR_print_errors(bio_err);\n                goto shut;\n            }\n        }\n\n        /* don't wait for client input in the non-interactive mode */\n        else if (nointeractive) {\n            ret = 0;\n            goto shut;\n        }\n\n/* OPENSSL_SYS_MSDOS includes OPENSSL_SYS_WINDOWS */\n#if defined(OPENSSL_SYS_MSDOS)\n        else if (has_stdin_waiting())\n#else\n        else if (FD_ISSET(fileno_stdin(), &readfds))\n#endif\n        {\n            if (crlf) {\n                int j, lf_num;\n\n                i = raw_read_stdin(cbuf, BUFSIZZ / 2);\n                lf_num = 0;\n                /* both loops are skipped when i <= 0 */\n                for (j = 0; j < i; j++)\n                    if (cbuf[j] == '\\n')\n                        lf_num++;\n                for (j = i - 1; j >= 0; j--) {\n                    cbuf[j + lf_num] = cbuf[j];\n                    if (cbuf[j] == '\\n') {\n                        lf_num--;\n                        i++;\n                        cbuf[j + lf_num] = '\\r';\n                    }\n                }\n                assert(lf_num == 0);\n            } else\n                i = raw_read_stdin(cbuf, BUFSIZZ);\n#if !defined(OPENSSL_SYS_WINDOWS) && !defined(OPENSSL_SYS_MSDOS)\n            if (i == 0)\n                at_eof = 1;\n#endif\n\n            if (!c_ign_eof && i <= 0) {\n                BIO_printf(bio_err, \"DONE\\n\");\n                ret = 0;\n                goto shut;\n            }\n\n            if (i > 0 && !user_data_add(&user_data, i)) {\n                ret = 0;\n                goto shut;\n            }\n            read_tty = 0;\n        }\n        first_loop = 0;\n    }\n\n shut:\n    if (in_init)\n        print_stuff(bio_c_out, con, full_log);\n    do_ssl_shutdown(con);\n\n    /*\n     * If we ended with an alert being sent, but still with data in the\n     * network buffer to be read, then calling BIO_closesocket() will\n     * result in a TCP-RST being sent. On some platforms (notably\n     * Windows) then this will result in the peer immediately abandoning\n     * the connection including any buffered alert data before it has\n     * had a chance to be read. Shutting down the sending side first,\n     * and then closing the socket sends TCP-FIN first followed by\n     * TCP-RST. This seems to allow the peer to read the alert data.\n     */\n    shutdown(SSL_get_fd(con), 1); /* SHUT_WR */\n    /*\n     * We just said we have nothing else to say, but it doesn't mean that\n     * the other side has nothing. It's even recommended to consume incoming\n     * data. [In testing context this ensures that alerts are passed on...]\n     */\n    timeout.tv_sec = 0;\n    timeout.tv_usec = 500000;  /* some extreme round-trip */\n    do {\n        FD_ZERO(&readfds);\n        openssl_fdset(sock, &readfds);\n    } while (select(sock + 1, &readfds, NULL, NULL, &timeout) > 0\n             && BIO_read(sbio, sbuf, BUFSIZZ) > 0);\n\n    BIO_closesocket(SSL_get_fd(con));\n end:\n    if (con != NULL) {\n        if (prexit != 0)\n            print_stuff(bio_c_out, con, 1);\n        SSL_free(con);\n    }\n    SSL_SESSION_free(psksess);\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    OPENSSL_free(next_proto.data);\n#endif\n    SSL_CTX_free(ctx);\n    set_keylog_file(NULL, NULL);\n    X509_free(cert);\n    sk_X509_CRL_pop_free(crls, X509_CRL_free);\n    EVP_PKEY_free(key);\n    OSSL_STACK_OF_X509_free(chain);\n    OPENSSL_free(pass);\n#ifndef OPENSSL_NO_SRP\n    OPENSSL_free(srp_arg.srppassin);\n#endif\n    OPENSSL_free(sname_alloc);\n    BIO_ADDR_free(peer_addr);\n    OPENSSL_free(connectstr);\n    OPENSSL_free(bindstr);\n    OPENSSL_free(bindhost);\n    OPENSSL_free(bindport);\n    OPENSSL_free(host);\n    OPENSSL_free(port);\n    OPENSSL_free(thost);\n    OPENSSL_free(tport);\n    X509_VERIFY_PARAM_free(vpm);\n    ssl_excert_free(exc);\n    sk_OPENSSL_STRING_free(ssl_args);\n    sk_OPENSSL_STRING_free(dane_tlsa_rrset);\n    SSL_CONF_CTX_free(cctx);\n    OPENSSL_clear_free(cbuf, BUFSIZZ);\n    OPENSSL_clear_free(sbuf, BUFSIZZ);\n    OPENSSL_clear_free(mbuf, BUFSIZZ);\n    clear_free(proxypass);\n    release_engine(e);\n    BIO_free(bio_c_out);\n    bio_c_out = NULL;\n    BIO_free(bio_c_msg);\n    bio_c_msg = NULL;\n    return ret;\n}"
        ],
        "sink": "if (init_client(&sock, host, port, bindhost, bindport, socket_family,",
        "final_sink": "if (init_client(&sock, host, port, bindhost, bindport, socket_family,",
        "source": [
            "    out = app_malloc(len + 1, \"NPN buffer\");"
        ],
        "index": 44
    },
    {
        "prt": "host",
        "function_call": [
            "int s_server_main(int argc, char *argv[])\n{\n    ENGINE *engine = NULL;\n    EVP_PKEY *s_key = NULL, *s_dkey = NULL;\n    SSL_CONF_CTX *cctx = NULL;\n    const SSL_METHOD *meth = TLS_server_method();\n    SSL_EXCERT *exc = NULL;\n    STACK_OF(OPENSSL_STRING) *ssl_args = NULL;\n    STACK_OF(X509) *s_chain = NULL, *s_dchain = NULL;\n    STACK_OF(X509_CRL) *crls = NULL;\n    X509 *s_cert = NULL, *s_dcert = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    const char *CApath = NULL, *CAfile = NULL, *CAstore = NULL;\n    const char *chCApath = NULL, *chCAfile = NULL, *chCAstore = NULL;\n    char *dpassarg = NULL, *dpass = NULL;\n    char *passarg = NULL, *pass = NULL;\n    char *vfyCApath = NULL, *vfyCAfile = NULL, *vfyCAstore = NULL;\n    char *crl_file = NULL, *prog;\n#ifdef AF_UNIX\n    int unlink_unix_path = 0;\n#endif\n    do_server_cb server_cb;\n    int vpmtouched = 0, build_chain = 0, no_cache = 0, ext_cache = 0;\n    char *dhfile = NULL;\n    int no_dhe = 0;\n    int nocert = 0, ret = 1;\n    int noCApath = 0, noCAfile = 0, noCAstore = 0;\n    int s_cert_format = FORMAT_UNDEF, s_key_format = FORMAT_UNDEF;\n    int s_dcert_format = FORMAT_UNDEF, s_dkey_format = FORMAT_UNDEF;\n    int rev = 0, naccept = -1, sdebug = 0;\n    int socket_family = AF_UNSPEC, socket_type = SOCK_STREAM, protocol = 0;\n    int state = 0, crl_format = FORMAT_UNDEF, crl_download = 0;\n    char *host = NULL;\n    char *port = NULL;\n    unsigned char *context = NULL;\n    OPTION_CHOICE o;\n    EVP_PKEY *s_key2 = NULL;\n    X509 *s_cert2 = NULL;\n    tlsextctx tlsextcbp = { NULL, NULL, SSL_TLSEXT_ERR_ALERT_WARNING };\n    const char *ssl_config = NULL;\n    int read_buf_len = 0;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    const char *next_proto_neg_in = NULL;\n    tlsextnextprotoctx next_proto = { NULL, 0 };\n#endif\n    const char *alpn_in = NULL;\n    tlsextalpnctx alpn_ctx = { NULL, 0 };\n#ifndef OPENSSL_NO_PSK\n    /* by default do not send a PSK identity hint */\n    char *psk_identity_hint = NULL;\n#endif\n    char *p;\n#ifndef OPENSSL_NO_SRP\n    char *srpuserseed = NULL;\n    char *srp_verifier_file = NULL;\n#endif\n#ifndef OPENSSL_NO_SRTP\n    char *srtp_profiles = NULL;\n#endif\n    int min_version = 0, max_version = 0, prot_opt = 0, no_prot_opt = 0;\n    int s_server_verify = SSL_VERIFY_NONE;\n    int s_server_session_id_context = 1; /* anything will do */\n    const char *s_cert_file = TEST_CERT, *s_key_file = NULL, *s_chain_file = NULL;\n    const char *s_cert_file2 = TEST_CERT2, *s_key_file2 = NULL;\n    char *s_dcert_file = NULL, *s_dkey_file = NULL, *s_dchain_file = NULL;\n#ifndef OPENSSL_NO_OCSP\n    int s_tlsextstatus = 0;\n#endif\n    int no_resume_ephemeral = 0;\n    unsigned int max_send_fragment = 0;\n    unsigned int split_send_fragment = 0, max_pipelines = 0;\n    const char *s_serverinfo_file = NULL;\n    const char *keylog_file = NULL;\n    int max_early_data = -1, recv_max_early_data = -1;\n    char *psksessf = NULL;\n    int no_ca_names = 0;\n#ifndef OPENSSL_NO_SCTP\n    int sctp_label_bug = 0;\n#endif\n    int ignore_unexpected_eof = 0;\n#ifndef OPENSSL_NO_KTLS\n    int enable_ktls = 0;\n#endif\n    int tfo = 0;\n    int cert_comp = 0;\n    int enable_server_rpk = 0;\n\n    /* Init of few remaining global variables */\n    local_argc = argc;\n    local_argv = argv;\n\n    ctx = ctx2 = NULL;\n    s_nbio = s_nbio_test = 0;\n    www = 0;\n    bio_s_out = NULL;\n    s_debug = 0;\n    s_msg = 0;\n    s_quiet = 0;\n    s_brief = 0;\n    async = 0;\n    use_sendfile = 0;\n    use_zc_sendfile = 0;\n\n    port = OPENSSL_strdup(PORT);\n    cctx = SSL_CONF_CTX_new();\n    vpm = X509_VERIFY_PARAM_new();\n    if (port == NULL || cctx == NULL || vpm == NULL)\n        goto end;\n    SSL_CONF_CTX_set_flags(cctx,\n                           SSL_CONF_FLAG_SERVER | SSL_CONF_FLAG_CMDLINE);\n\n    prog = opt_init(argc, argv, s_server_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        if (IS_PROT_FLAG(o) && ++prot_opt > 1) {\n            BIO_printf(bio_err, \"Cannot supply multiple protocol flags\\n\");\n            goto end;\n        }\n        if (IS_NO_PROT_FLAG(o))\n            no_prot_opt++;\n        if (prot_opt == 1 && no_prot_opt) {\n            BIO_printf(bio_err,\n                       \"Cannot supply both a protocol flag and '-no_<prot>'\\n\");\n            goto end;\n        }\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(s_server_options);\n            ret = 0;\n            goto end;\n\n        case OPT_4:\n#ifdef AF_UNIX\n            if (socket_family == AF_UNIX) {\n                OPENSSL_free(host); host = NULL;\n                OPENSSL_free(port); port = NULL;\n            }\n#endif\n            socket_family = AF_INET;\n            break;\n        case OPT_6:\n            if (1) {\n#ifdef AF_INET6\n#ifdef AF_UNIX\n                if (socket_family == AF_UNIX) {\n                    OPENSSL_free(host); host = NULL;\n                    OPENSSL_free(port); port = NULL;\n                }\n#endif\n                socket_family = AF_INET6;\n            } else {\n#endif\n                BIO_printf(bio_err, \"%s: IPv6 domain sockets unsupported\\n\", prog);\n                goto end;\n            }\n            break;\n        case OPT_PORT:\n#ifdef AF_UNIX\n            if (socket_family == AF_UNIX) {\n                socket_family = AF_UNSPEC;\n            }\n#endif\n            OPENSSL_free(port); port = NULL;\n            OPENSSL_free(host); host = NULL;\n            if (BIO_parse_hostserv(opt_arg(), NULL, &port, BIO_PARSE_PRIO_SERV) < 1) {\n                BIO_printf(bio_err,\n                           \"%s: -port argument malformed or ambiguous\\n\",\n                           port);\n                goto end;\n            }\n            break;\n        case OPT_ACCEPT:\n#ifdef AF_UNIX\n            if (socket_family == AF_UNIX) {\n                socket_family = AF_UNSPEC;\n            }\n#endif\n            OPENSSL_free(port); port = NULL;\n            OPENSSL_free(host); host = NULL;\n            if (BIO_parse_hostserv(opt_arg(), &host, &port, BIO_PARSE_PRIO_SERV) < 1) {\n                BIO_printf(bio_err,\n                           \"%s: -accept argument malformed or ambiguous\\n\",\n                           port);\n                goto end;\n            }\n            break;\n#ifdef AF_UNIX\n        case OPT_UNIX:\n            socket_family = AF_UNIX;\n            OPENSSL_free(host); host = OPENSSL_strdup(opt_arg());\n            if (host == NULL)\n                goto end;\n            OPENSSL_free(port); port = NULL;\n            break;\n        case OPT_UNLINK:\n            unlink_unix_path = 1;\n            break;\n#endif\n        case OPT_NACCEPT:\n            naccept = atol(opt_arg());\n            break;\n        case OPT_VERIFY:\n            s_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;\n            verify_args.depth = atoi(opt_arg());\n            if (!s_quiet)\n                BIO_printf(bio_err, \"verify depth is %d\\n\", verify_args.depth);\n            break;\n        case OPT_UPPER_V_VERIFY:\n            s_server_verify =\n                SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT |\n                SSL_VERIFY_CLIENT_ONCE;\n            verify_args.depth = atoi(opt_arg());\n            if (!s_quiet)\n                BIO_printf(bio_err,\n                           \"verify depth is %d, must return a certificate\\n\",\n                           verify_args.depth);\n            break;\n        case OPT_CONTEXT:\n            context = (unsigned char *)opt_arg();\n            break;\n        case OPT_CERT:\n            s_cert_file = opt_arg();\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto end;\n            break;\n        case OPT_CRL:\n            crl_file = opt_arg();\n            break;\n        case OPT_CRL_DOWNLOAD:\n            crl_download = 1;\n            break;\n        case OPT_SERVERINFO:\n            s_serverinfo_file = opt_arg();\n            break;\n        case OPT_CERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_cert_format))\n                goto opthelp;\n            break;\n        case OPT_KEY:\n            s_key_file = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_key_format))\n                goto opthelp;\n            break;\n        case OPT_PASS:\n            passarg = opt_arg();\n            break;\n        case OPT_CERT_CHAIN:\n            s_chain_file = opt_arg();\n            break;\n        case OPT_DHPARAM:\n            dhfile = opt_arg();\n            break;\n        case OPT_DCERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_dcert_format))\n                goto opthelp;\n            break;\n        case OPT_DCERT:\n            s_dcert_file = opt_arg();\n            break;\n        case OPT_DKEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_dkey_format))\n                goto opthelp;\n            break;\n        case OPT_DPASS:\n            dpassarg = opt_arg();\n            break;\n        case OPT_DKEY:\n            s_dkey_file = opt_arg();\n            break;\n        case OPT_DCERT_CHAIN:\n            s_dchain_file = opt_arg();\n            break;\n        case OPT_NOCERT:\n            nocert = 1;\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_CHAINCAPATH:\n            chCApath = opt_arg();\n            break;\n        case OPT_VERIFYCAPATH:\n            vfyCApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_CHAINCASTORE:\n            chCAstore = opt_arg();\n            break;\n        case OPT_VERIFYCASTORE:\n            vfyCAstore = opt_arg();\n            break;\n        case OPT_NO_CACHE:\n            no_cache = 1;\n            break;\n        case OPT_EXT_CACHE:\n            ext_cache = 1;\n            break;\n        case OPT_CRLFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &crl_format))\n                goto opthelp;\n            break;\n        case OPT_S_CASES:\n        case OPT_S_NUM_TICKETS:\n        case OPT_ANTI_REPLAY:\n        case OPT_NO_ANTI_REPLAY:\n            if (ssl_args == NULL)\n                ssl_args = sk_OPENSSL_STRING_new_null();\n            if (ssl_args == NULL\n                || !sk_OPENSSL_STRING_push(ssl_args, opt_flag())\n                || !sk_OPENSSL_STRING_push(ssl_args, opt_arg())) {\n                BIO_printf(bio_err, \"%s: Memory allocation failure\\n\", prog);\n                goto end;\n            }\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_X_CASES:\n            if (!args_excert(o, &exc))\n                goto end;\n            break;\n        case OPT_VERIFY_RET_ERROR:\n            verify_args.return_error = 1;\n            break;\n        case OPT_VERIFY_QUIET:\n            verify_args.quiet = 1;\n            break;\n        case OPT_BUILD_CHAIN:\n            build_chain = 1;\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_CHAINCAFILE:\n            chCAfile = opt_arg();\n            break;\n        case OPT_VERIFYCAFILE:\n            vfyCAfile = opt_arg();\n            break;\n        case OPT_NBIO:\n            s_nbio = 1;\n            break;\n        case OPT_NBIO_TEST:\n            s_nbio = s_nbio_test = 1;\n            break;\n        case OPT_IGN_EOF:\n            s_ign_eof = 1;\n            break;\n        case OPT_NO_IGN_EOF:\n            s_ign_eof = 0;\n            break;\n        case OPT_DEBUG:\n            s_debug = 1;\n            break;\n        case OPT_TLSEXTDEBUG:\n            s_tlsextdebug = 1;\n            break;\n        case OPT_STATUS:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = 1;\n#endif\n            break;\n        case OPT_STATUS_VERBOSE:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = tlscstatp.verbose = 1;\n#endif\n            break;\n        case OPT_STATUS_TIMEOUT:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = 1;\n            tlscstatp.timeout = atoi(opt_arg());\n#endif\n            break;\n        case OPT_PROXY:\n#ifndef OPENSSL_NO_OCSP\n            tlscstatp.proxy = opt_arg();\n#endif\n            break;\n        case OPT_NO_PROXY:\n#ifndef OPENSSL_NO_OCSP\n            tlscstatp.no_proxy = opt_arg();\n#endif\n            break;\n        case OPT_STATUS_URL:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = 1;\n            if (!OSSL_HTTP_parse_url(opt_arg(), &tlscstatp.use_ssl, NULL,\n                                     &tlscstatp.host, &tlscstatp.port, NULL,\n                                     &tlscstatp.path, NULL, NULL)) {\n                BIO_printf(bio_err, \"Error parsing -status_url argument\\n\");\n                goto end;\n            }\n#endif\n            break;\n        case OPT_STATUS_FILE:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = 1;\n            tlscstatp.respin = opt_arg();\n#endif\n            break;\n        case OPT_MSG:\n            s_msg = 1;\n            break;\n        case OPT_MSGFILE:\n            bio_s_msg = BIO_new_file(opt_arg(), \"w\");\n            if (bio_s_msg == NULL) {\n                BIO_printf(bio_err, \"Error writing file %s\\n\", opt_arg());\n                goto end;\n            }\n            break;\n        case OPT_TRACE:\n#ifndef OPENSSL_NO_SSL_TRACE\n            s_msg = 2;\n#endif\n            break;\n        case OPT_SECURITY_DEBUG:\n            sdebug = 1;\n            break;\n        case OPT_SECURITY_DEBUG_VERBOSE:\n            sdebug = 2;\n            break;\n        case OPT_STATE:\n            state = 1;\n            break;\n        case OPT_CRLF:\n            s_crlf = 1;\n            break;\n        case OPT_QUIET:\n            s_quiet = 1;\n            break;\n        case OPT_BRIEF:\n            s_quiet = s_brief = verify_args.quiet = 1;\n            break;\n        case OPT_NO_DHE:\n            no_dhe = 1;\n            break;\n        case OPT_NO_RESUME_EPHEMERAL:\n            no_resume_ephemeral = 1;\n            break;\n        case OPT_PSK_IDENTITY:\n            psk_identity = opt_arg();\n            break;\n        case OPT_PSK_HINT:\n#ifndef OPENSSL_NO_PSK\n            psk_identity_hint = opt_arg();\n#endif\n            break;\n        case OPT_PSK:\n            for (p = psk_key = opt_arg(); *p; p++) {\n                if (isxdigit(_UC(*p)))\n                    continue;\n                BIO_printf(bio_err, \"Not a hex number '%s'\\n\", psk_key);\n                goto end;\n            }\n            break;\n        case OPT_PSK_SESS:\n            psksessf = opt_arg();\n            break;\n        case OPT_SRPVFILE:\n#ifndef OPENSSL_NO_SRP\n            srp_verifier_file = opt_arg();\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n#endif\n            break;\n        case OPT_SRPUSERSEED:\n#ifndef OPENSSL_NO_SRP\n            srpuserseed = opt_arg();\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n#endif\n            break;\n        case OPT_REV:\n            rev = 1;\n            break;\n        case OPT_WWW:\n            www = 1;\n            break;\n        case OPT_UPPER_WWW:\n            www = 2;\n            break;\n        case OPT_HTTP:\n            www = 3;\n            break;\n        case OPT_SSL_CONFIG:\n            ssl_config = opt_arg();\n            break;\n        case OPT_SSL3:\n            min_version = SSL3_VERSION;\n            max_version = SSL3_VERSION;\n            break;\n        case OPT_TLS1_3:\n            min_version = TLS1_3_VERSION;\n            max_version = TLS1_3_VERSION;\n            break;\n        case OPT_TLS1_2:\n            min_version = TLS1_2_VERSION;\n            max_version = TLS1_2_VERSION;\n            break;\n        case OPT_TLS1_1:\n            min_version = TLS1_1_VERSION;\n            max_version = TLS1_1_VERSION;\n            break;\n        case OPT_TLS1:\n            min_version = TLS1_VERSION;\n            max_version = TLS1_VERSION;\n            break;\n        case OPT_DTLS:\n#ifndef OPENSSL_NO_DTLS\n            meth = DTLS_server_method();\n            socket_type = SOCK_DGRAM;\n#endif\n            break;\n        case OPT_DTLS1:\n#ifndef OPENSSL_NO_DTLS\n            meth = DTLS_server_method();\n            min_version = DTLS1_VERSION;\n            max_version = DTLS1_VERSION;\n            socket_type = SOCK_DGRAM;\n#endif\n            break;\n        case OPT_DTLS1_2:\n#ifndef OPENSSL_NO_DTLS\n            meth = DTLS_server_method();\n            min_version = DTLS1_2_VERSION;\n            max_version = DTLS1_2_VERSION;\n            socket_type = SOCK_DGRAM;\n#endif\n            break;\n        case OPT_SCTP:\n#ifndef OPENSSL_NO_SCTP\n            protocol = IPPROTO_SCTP;\n#endif\n            break;\n        case OPT_SCTP_LABEL_BUG:\n#ifndef OPENSSL_NO_SCTP\n            sctp_label_bug = 1;\n#endif\n            break;\n        case OPT_TIMEOUT:\n#ifndef OPENSSL_NO_DTLS\n            enable_timeouts = 1;\n#endif\n            break;\n        case OPT_MTU:\n#ifndef OPENSSL_NO_DTLS\n            socket_mtu = atol(opt_arg());\n#endif\n            break;\n        case OPT_LISTEN:\n#ifndef OPENSSL_NO_DTLS\n            dtlslisten = 1;\n#endif\n            break;\n        case OPT_STATELESS:\n            stateless = 1;\n            break;\n        case OPT_ID_PREFIX:\n            session_id_prefix = opt_arg();\n            break;\n        case OPT_ENGINE:\n#ifndef OPENSSL_NO_ENGINE\n            engine = setup_engine(opt_arg(), s_debug);\n#endif\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_SERVERNAME:\n            tlsextcbp.servername = opt_arg();\n            break;\n        case OPT_SERVERNAME_FATAL:\n            tlsextcbp.extension_error = SSL_TLSEXT_ERR_ALERT_FATAL;\n            break;\n        case OPT_CERT2:\n            s_cert_file2 = opt_arg();\n            break;\n        case OPT_KEY2:\n            s_key_file2 = opt_arg();\n            break;\n        case OPT_NEXTPROTONEG:\n# ifndef OPENSSL_NO_NEXTPROTONEG\n            next_proto_neg_in = opt_arg();\n#endif\n            break;\n        case OPT_ALPN:\n            alpn_in = opt_arg();\n            break;\n        case OPT_SRTP_PROFILES:\n#ifndef OPENSSL_NO_SRTP\n            srtp_profiles = opt_arg();\n#endif\n            break;\n        case OPT_KEYMATEXPORT:\n            keymatexportlabel = opt_arg();\n            break;\n        case OPT_KEYMATEXPORTLEN:\n            keymatexportlen = atoi(opt_arg());\n            break;\n        case OPT_ASYNC:\n            async = 1;\n            break;\n        case OPT_MAX_SEND_FRAG:\n            max_send_fragment = atoi(opt_arg());\n            break;\n        case OPT_SPLIT_SEND_FRAG:\n            split_send_fragment = atoi(opt_arg());\n            break;\n        case OPT_MAX_PIPELINES:\n            max_pipelines = atoi(opt_arg());\n            break;\n        case OPT_READ_BUF:\n            read_buf_len = atoi(opt_arg());\n            break;\n        case OPT_KEYLOG_FILE:\n            keylog_file = opt_arg();\n            break;\n        case OPT_MAX_EARLY:\n            max_early_data = atoi(opt_arg());\n            if (max_early_data < 0) {\n                BIO_printf(bio_err, \"Invalid value for max_early_data\\n\");\n                goto end;\n            }\n            break;\n        case OPT_RECV_MAX_EARLY:\n            recv_max_early_data = atoi(opt_arg());\n            if (recv_max_early_data < 0) {\n                BIO_printf(bio_err, \"Invalid value for recv_max_early_data\\n\");\n                goto end;\n            }\n            break;\n        case OPT_EARLY_DATA:\n            early_data = 1;\n            if (max_early_data == -1)\n                max_early_data = SSL3_RT_MAX_PLAIN_LENGTH;\n            break;\n        case OPT_HTTP_SERVER_BINMODE:\n            http_server_binmode = 1;\n            break;\n        case OPT_NOCANAMES:\n            no_ca_names = 1;\n            break;\n        case OPT_KTLS:\n#ifndef OPENSSL_NO_KTLS\n            enable_ktls = 1;\n#endif\n            break;\n        case OPT_SENDFILE:\n#ifndef OPENSSL_NO_KTLS\n            use_sendfile = 1;\n#endif\n            break;\n        case OPT_USE_ZC_SENDFILE:\n#ifndef OPENSSL_NO_KTLS\n            use_zc_sendfile = 1;\n#endif\n            break;\n        case OPT_IGNORE_UNEXPECTED_EOF:\n            ignore_unexpected_eof = 1;\n            break;\n        case OPT_TFO:\n            tfo = 1;\n            break;\n        case OPT_CERT_COMP:\n            cert_comp = 1;\n            break;\n        case OPT_ENABLE_SERVER_RPK:\n            enable_server_rpk = 1;\n            break;\n        case OPT_ENABLE_CLIENT_RPK:\n            enable_client_rpk = 1;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    if (min_version == TLS1_3_VERSION && next_proto_neg_in != NULL) {\n        BIO_printf(bio_err, \"Cannot supply -nextprotoneg with TLSv1.3\\n\");\n        goto opthelp;\n    }\n#endif\n#ifndef OPENSSL_NO_DTLS\n    if (www && socket_type == SOCK_DGRAM) {\n        BIO_printf(bio_err, \"Can't use -HTTP, -www or -WWW with DTLS\\n\");\n        goto end;\n    }\n\n    if (dtlslisten && socket_type != SOCK_DGRAM) {\n        BIO_printf(bio_err, \"Can only use -listen with DTLS\\n\");\n        goto end;\n    }\n\n    if (rev && socket_type == SOCK_DGRAM) {\n        BIO_printf(bio_err, \"Can't use -rev with DTLS\\n\");\n        goto end;\n    }\n#endif\n\n    if (tfo && socket_type != SOCK_STREAM) {\n        BIO_printf(bio_err, \"Can only use -tfo with TLS\\n\");\n        goto end;\n    }\n\n    if (stateless && socket_type != SOCK_STREAM) {\n        BIO_printf(bio_err, \"Can only use --stateless with TLS\\n\");\n        goto end;\n    }\n\n#ifdef AF_UNIX\n    if (socket_family == AF_UNIX && socket_type != SOCK_STREAM) {\n        BIO_printf(bio_err,\n                   \"Can't use unix sockets and datagrams together\\n\");\n        goto end;\n    }\n#endif\n    if (early_data && rev) {\n        BIO_printf(bio_err,\n                   \"Can't use -early_data in combination with -rev\\n\");\n        goto end;\n    }\n\n#ifndef OPENSSL_NO_SCTP\n    if (protocol == IPPROTO_SCTP) {\n        if (socket_type != SOCK_DGRAM) {\n            BIO_printf(bio_err, \"Can't use -sctp without DTLS\\n\");\n            goto end;\n        }\n        /* SCTP is unusual. It uses DTLS over a SOCK_STREAM protocol */\n        socket_type = SOCK_STREAM;\n    }\n#endif\n\n#ifndef OPENSSL_NO_KTLS\n    if (use_zc_sendfile && !use_sendfile) {\n        BIO_printf(bio_out, \"Warning: -zerocopy_sendfile depends on -sendfile, enabling -sendfile now.\\n\");\n        use_sendfile = 1;\n    }\n\n    if (use_sendfile && enable_ktls == 0) {\n        BIO_printf(bio_out, \"Warning: -sendfile depends on -ktls, enabling -ktls now.\\n\");\n        enable_ktls = 1;\n    }\n\n    if (use_sendfile && www <= 1) {\n        BIO_printf(bio_err, \"Can't use -sendfile without -WWW or -HTTP\\n\");\n        goto end;\n    }\n#endif\n\n    if (!app_passwd(passarg, dpassarg, &pass, &dpass)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    if (s_key_file == NULL)\n        s_key_file = s_cert_file;\n\n    if (s_key_file2 == NULL)\n        s_key_file2 = s_cert_file2;\n\n    if (!load_excert(&exc))\n        goto end;\n\n    if (nocert == 0) {\n        s_key = load_key(s_key_file, s_key_format, 0, pass, engine,\n                         \"server certificate private key\");\n        if (s_key == NULL)\n            goto end;\n\n        s_cert = load_cert_pass(s_cert_file, s_cert_format, 1, pass,\n                                \"server certificate\");\n\n        if (s_cert == NULL)\n            goto end;\n        if (s_chain_file != NULL) {\n            if (!load_certs(s_chain_file, 0, &s_chain, NULL,\n                            \"server certificate chain\"))\n                goto end;\n        }\n\n        if (tlsextcbp.servername != NULL) {\n            s_key2 = load_key(s_key_file2, s_key_format, 0, pass, engine,\n                              \"second server certificate private key\");\n            if (s_key2 == NULL)\n                goto end;\n\n            s_cert2 = load_cert_pass(s_cert_file2, s_cert_format, 1, pass,\n                                \"second server certificate\");\n\n            if (s_cert2 == NULL)\n                goto end;\n        }\n    }\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    if (next_proto_neg_in) {\n        next_proto.data = next_protos_parse(&next_proto.len, next_proto_neg_in);\n        if (next_proto.data == NULL)\n            goto end;\n    }\n#endif\n    alpn_ctx.data = NULL;\n    if (alpn_in) {\n        alpn_ctx.data = next_protos_parse(&alpn_ctx.len, alpn_in);\n        if (alpn_ctx.data == NULL)\n            goto end;\n    }\n\n    if (crl_file != NULL) {\n        X509_CRL *crl;\n        crl = load_crl(crl_file, crl_format, 0, \"CRL\");\n        if (crl == NULL)\n            goto end;\n        crls = sk_X509_CRL_new_null();\n        if (crls == NULL || !sk_X509_CRL_push(crls, crl)) {\n            BIO_puts(bio_err, \"Error adding CRL\\n\");\n            ERR_print_errors(bio_err);\n            X509_CRL_free(crl);\n            goto end;\n        }\n    }\n\n    if (s_dcert_file != NULL) {\n\n        if (s_dkey_file == NULL)\n            s_dkey_file = s_dcert_file;\n\n        s_dkey = load_key(s_dkey_file, s_dkey_format,\n                          0, dpass, engine, \"second certificate private key\");\n        if (s_dkey == NULL)\n            goto end;\n\n        s_dcert = load_cert_pass(s_dcert_file, s_dcert_format, 1, dpass,\n                                 \"second server certificate\");\n\n        if (s_dcert == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        if (s_dchain_file != NULL) {\n            if (!load_certs(s_dchain_file, 0, &s_dchain, NULL,\n                            \"second server certificate chain\"))\n                goto end;\n        }\n\n    }\n\n    if (bio_s_out == NULL) {\n        if (s_quiet && !s_debug) {\n            bio_s_out = BIO_new(BIO_s_null());\n            if (s_msg && bio_s_msg == NULL) {\n                bio_s_msg = dup_bio_out(FORMAT_TEXT);\n                if (bio_s_msg == NULL) {\n                    BIO_printf(bio_err, \"Out of memory\\n\");\n                    goto end;\n                }\n            }\n        } else {\n            bio_s_out = dup_bio_out(FORMAT_TEXT);\n        }\n    }\n\n    if (bio_s_out == NULL)\n        goto end;\n\n    if (nocert) {\n        s_cert_file = NULL;\n        s_key_file = NULL;\n        s_dcert_file = NULL;\n        s_dkey_file = NULL;\n        s_cert_file2 = NULL;\n        s_key_file2 = NULL;\n    }\n\n    ctx = SSL_CTX_new_ex(app_get0_libctx(), app_get0_propq(), meth);\n    if (ctx == NULL) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    SSL_CTX_clear_mode(ctx, SSL_MODE_AUTO_RETRY);\n\n    if (sdebug)\n        ssl_ctx_security_debug(ctx, sdebug);\n\n    if (!config_ctx(cctx, ssl_args, ctx))\n        goto end;\n\n    if (ssl_config) {\n        if (SSL_CTX_config(ctx, ssl_config) == 0) {\n            BIO_printf(bio_err, \"Error using configuration \\\"%s\\\"\\n\",\n                       ssl_config);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n#ifndef OPENSSL_NO_SCTP\n    if (protocol == IPPROTO_SCTP && sctp_label_bug == 1)\n        SSL_CTX_set_mode(ctx, SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG);\n#endif\n\n    if (min_version != 0\n        && SSL_CTX_set_min_proto_version(ctx, min_version) == 0)\n        goto end;\n    if (max_version != 0\n        && SSL_CTX_set_max_proto_version(ctx, max_version) == 0)\n        goto end;\n\n    if (session_id_prefix) {\n        if (strlen(session_id_prefix) >= 32)\n            BIO_printf(bio_err,\n                       \"warning: id_prefix is too long, only one new session will be possible\\n\");\n        if (!SSL_CTX_set_generate_session_id(ctx, generate_session_id)) {\n            BIO_printf(bio_err, \"error setting 'id_prefix'\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        BIO_printf(bio_err, \"id_prefix '%s' set.\\n\", session_id_prefix);\n    }\n    if (exc != NULL)\n        ssl_ctx_set_excert(ctx, exc);\n\n    if (state)\n        SSL_CTX_set_info_callback(ctx, apps_ssl_info_callback);\n    if (no_cache)\n        SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);\n    else if (ext_cache)\n        init_session_cache_ctx(ctx);\n    else\n        SSL_CTX_sess_set_cache_size(ctx, 128);\n\n    if (async) {\n        SSL_CTX_set_mode(ctx, SSL_MODE_ASYNC);\n    }\n\n    if (no_ca_names) {\n        SSL_CTX_set_options(ctx, SSL_OP_DISABLE_TLSEXT_CA_NAMES);\n    }\n\n    if (ignore_unexpected_eof)\n        SSL_CTX_set_options(ctx, SSL_OP_IGNORE_UNEXPECTED_EOF);\n#ifndef OPENSSL_NO_KTLS\n    if (enable_ktls)\n        SSL_CTX_set_options(ctx, SSL_OP_ENABLE_KTLS);\n    if (use_zc_sendfile)\n        SSL_CTX_set_options(ctx, SSL_OP_ENABLE_KTLS_TX_ZEROCOPY_SENDFILE);\n#endif\n\n    if (max_send_fragment > 0\n        && !SSL_CTX_set_max_send_fragment(ctx, max_send_fragment)) {\n        BIO_printf(bio_err, \"%s: Max send fragment size %u is out of permitted range\\n\",\n                   prog, max_send_fragment);\n        goto end;\n    }\n\n    if (split_send_fragment > 0\n        && !SSL_CTX_set_split_send_fragment(ctx, split_send_fragment)) {\n        BIO_printf(bio_err, \"%s: Split send fragment size %u is out of permitted range\\n\",\n                   prog, split_send_fragment);\n        goto end;\n    }\n    if (max_pipelines > 0\n        && !SSL_CTX_set_max_pipelines(ctx, max_pipelines)) {\n        BIO_printf(bio_err, \"%s: Max pipelines %u is out of permitted range\\n\",\n                   prog, max_pipelines);\n        goto end;\n    }\n\n    if (read_buf_len > 0) {\n        SSL_CTX_set_default_read_buffer_len(ctx, read_buf_len);\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (srtp_profiles != NULL) {\n        /* Returns 0 on success! */\n        if (SSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles) != 0) {\n            BIO_printf(bio_err, \"Error setting SRTP profile\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n#endif\n\n    if (!ctx_set_verify_locations(ctx, CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    if (vpmtouched && !SSL_CTX_set1_param(ctx, vpm)) {\n        BIO_printf(bio_err, \"Error setting verify params\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    ssl_ctx_add_crls(ctx, crls, 0);\n\n    if (!ssl_load_stores(ctx,\n                         vfyCApath, vfyCAfile, vfyCAstore,\n                         chCApath, chCAfile, chCAstore,\n                         crls, crl_download)) {\n        BIO_printf(bio_err, \"Error loading store locations\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    if (s_cert2) {\n        ctx2 = SSL_CTX_new_ex(app_get0_libctx(), app_get0_propq(), meth);\n        if (ctx2 == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (ctx2 != NULL) {\n        BIO_printf(bio_s_out, \"Setting secondary ctx parameters\\n\");\n\n        if (sdebug)\n            ssl_ctx_security_debug(ctx2, sdebug);\n\n        if (session_id_prefix) {\n            if (strlen(session_id_prefix) >= 32)\n                BIO_printf(bio_err,\n                           \"warning: id_prefix is too long, only one new session will be possible\\n\");\n            if (!SSL_CTX_set_generate_session_id(ctx2, generate_session_id)) {\n                BIO_printf(bio_err, \"error setting 'id_prefix'\\n\");\n                ERR_print_errors(bio_err);\n                goto end;\n            }\n            BIO_printf(bio_err, \"id_prefix '%s' set.\\n\", session_id_prefix);\n        }\n        if (exc != NULL)\n            ssl_ctx_set_excert(ctx2, exc);\n\n        if (state)\n            SSL_CTX_set_info_callback(ctx2, apps_ssl_info_callback);\n\n        if (no_cache)\n            SSL_CTX_set_session_cache_mode(ctx2, SSL_SESS_CACHE_OFF);\n        else if (ext_cache)\n            init_session_cache_ctx(ctx2);\n        else\n            SSL_CTX_sess_set_cache_size(ctx2, 128);\n\n        if (async)\n            SSL_CTX_set_mode(ctx2, SSL_MODE_ASYNC);\n\n        if (!ctx_set_verify_locations(ctx2, CAfile, noCAfile, CApath,\n                                      noCApath, CAstore, noCAstore)) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        if (vpmtouched && !SSL_CTX_set1_param(ctx2, vpm)) {\n            BIO_printf(bio_err, \"Error setting verify params\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n\n        ssl_ctx_add_crls(ctx2, crls, 0);\n        if (!config_ctx(cctx, ssl_args, ctx2))\n            goto end;\n    }\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    if (next_proto.data)\n        SSL_CTX_set_next_protos_advertised_cb(ctx, next_proto_cb,\n                                              &next_proto);\n#endif\n    if (alpn_ctx.data)\n        SSL_CTX_set_alpn_select_cb(ctx, alpn_cb, &alpn_ctx);\n\n    if (!no_dhe) {\n        EVP_PKEY *dhpkey = NULL;\n\n        if (dhfile != NULL)\n            dhpkey = load_keyparams(dhfile, FORMAT_UNDEF, 0, \"DH\", \"DH parameters\");\n        else if (s_cert_file != NULL)\n            dhpkey = load_keyparams_suppress(s_cert_file, FORMAT_UNDEF, 0, \"DH\",\n                                             \"DH parameters\", 1);\n\n        if (dhpkey != NULL) {\n            BIO_printf(bio_s_out, \"Setting temp DH parameters\\n\");\n        } else {\n            BIO_printf(bio_s_out, \"Using default temp DH parameters\\n\");\n        }\n        (void)BIO_flush(bio_s_out);\n\n        if (dhpkey == NULL) {\n            SSL_CTX_set_dh_auto(ctx, 1);\n        } else {\n            /*\n             * We need 2 references: one for use by ctx and one for use by\n             * ctx2\n             */\n            if (!EVP_PKEY_up_ref(dhpkey)) {\n                EVP_PKEY_free(dhpkey);\n                goto end;\n            }\n            if (!SSL_CTX_set0_tmp_dh_pkey(ctx, dhpkey)) {\n                BIO_puts(bio_err, \"Error setting temp DH parameters\\n\");\n                ERR_print_errors(bio_err);\n                /* Free 2 references */\n                EVP_PKEY_free(dhpkey);\n                EVP_PKEY_free(dhpkey);\n                goto end;\n            }\n        }\n\n        if (ctx2 != NULL) {\n            if (dhfile != NULL) {\n                EVP_PKEY *dhpkey2 = load_keyparams_suppress(s_cert_file2,\n                                                            FORMAT_UNDEF,\n                                                            0, \"DH\",\n                                                            \"DH parameters\", 1);\n\n                if (dhpkey2 != NULL) {\n                    BIO_printf(bio_s_out, \"Setting temp DH parameters\\n\");\n                    (void)BIO_flush(bio_s_out);\n\n                    EVP_PKEY_free(dhpkey);\n                    dhpkey = dhpkey2;\n                }\n            }\n            if (dhpkey == NULL) {\n                SSL_CTX_set_dh_auto(ctx2, 1);\n            } else if (!SSL_CTX_set0_tmp_dh_pkey(ctx2, dhpkey)) {\n                BIO_puts(bio_err, \"Error setting temp DH parameters\\n\");\n                ERR_print_errors(bio_err);\n                EVP_PKEY_free(dhpkey);\n                goto end;\n            }\n            dhpkey = NULL;\n        }\n        EVP_PKEY_free(dhpkey);\n    }\n\n    if (!set_cert_key_stuff(ctx, s_cert, s_key, s_chain, build_chain))\n        goto end;\n\n    if (s_serverinfo_file != NULL\n        && !SSL_CTX_use_serverinfo_file(ctx, s_serverinfo_file)) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    if (ctx2 != NULL\n        && !set_cert_key_stuff(ctx2, s_cert2, s_key2, NULL, build_chain))\n        goto end;\n\n    if (s_dcert != NULL) {\n        if (!set_cert_key_stuff(ctx, s_dcert, s_dkey, s_dchain, build_chain))\n            goto end;\n    }\n\n    if (no_resume_ephemeral) {\n        SSL_CTX_set_not_resumable_session_callback(ctx,\n                                                   not_resumable_sess_cb);\n\n        if (ctx2 != NULL)\n            SSL_CTX_set_not_resumable_session_callback(ctx2,\n                                                       not_resumable_sess_cb);\n    }\n#ifndef OPENSSL_NO_PSK\n    if (psk_key != NULL) {\n        if (s_debug)\n            BIO_printf(bio_s_out, \"PSK key given, setting server callback\\n\");\n        SSL_CTX_set_psk_server_callback(ctx, psk_server_cb);\n    }\n\n    if (psk_identity_hint != NULL) {\n        if (min_version == TLS1_3_VERSION) {\n            BIO_printf(bio_s_out, \"PSK warning: there is NO identity hint in TLSv1.3\\n\");\n        } else {\n            if (!SSL_CTX_use_psk_identity_hint(ctx, psk_identity_hint)) {\n                BIO_printf(bio_err, \"error setting PSK identity hint to context\\n\");\n                ERR_print_errors(bio_err);\n                goto end;\n            }\n        }\n    }\n#endif\n    if (psksessf != NULL) {\n        BIO *stmp = BIO_new_file(psksessf, \"r\");\n\n        if (stmp == NULL) {\n            BIO_printf(bio_err, \"Can't open PSK session file %s\\n\", psksessf);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        psksess = PEM_read_bio_SSL_SESSION(stmp, NULL, 0, NULL);\n        BIO_free(stmp);\n        if (psksess == NULL) {\n            BIO_printf(bio_err, \"Can't read PSK session file %s\\n\", psksessf);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n\n    }\n\n    if (psk_key != NULL || psksess != NULL)\n        SSL_CTX_set_psk_find_session_callback(ctx, psk_find_session_cb);\n\n    SSL_CTX_set_verify(ctx, s_server_verify, verify_callback);\n    if (!SSL_CTX_set_session_id_context(ctx,\n                                        (void *)&s_server_session_id_context,\n                                        sizeof(s_server_session_id_context))) {\n        BIO_printf(bio_err, \"error setting session id context\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    /* Set DTLS cookie generation and verification callbacks */\n    SSL_CTX_set_cookie_generate_cb(ctx, generate_cookie_callback);\n    SSL_CTX_set_cookie_verify_cb(ctx, verify_cookie_callback);\n\n    /* Set TLS1.3 cookie generation and verification callbacks */\n    SSL_CTX_set_stateless_cookie_generate_cb(ctx, generate_stateless_cookie_callback);\n    SSL_CTX_set_stateless_cookie_verify_cb(ctx, verify_stateless_cookie_callback);\n\n    if (ctx2 != NULL) {\n        SSL_CTX_set_verify(ctx2, s_server_verify, verify_callback);\n        if (!SSL_CTX_set_session_id_context(ctx2,\n                    (void *)&s_server_session_id_context,\n                    sizeof(s_server_session_id_context))) {\n            BIO_printf(bio_err, \"error setting session id context\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        tlsextcbp.biodebug = bio_s_out;\n        SSL_CTX_set_tlsext_servername_callback(ctx2, ssl_servername_cb);\n        SSL_CTX_set_tlsext_servername_arg(ctx2, &tlsextcbp);\n        SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);\n        SSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);\n    }\n\n#ifndef OPENSSL_NO_SRP\n    if (srp_verifier_file != NULL) {\n        if (!set_up_srp_verifier_file(ctx, &srp_callback_parm, srpuserseed,\n                                      srp_verifier_file))\n            goto end;\n    } else\n#endif\n    if (CAfile != NULL) {\n        SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file(CAfile));\n\n        if (ctx2)\n            SSL_CTX_set_client_CA_list(ctx2, SSL_load_client_CA_file(CAfile));\n    }\n#ifndef OPENSSL_NO_OCSP\n    if (s_tlsextstatus) {\n        SSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);\n        SSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);\n        if (ctx2) {\n            SSL_CTX_set_tlsext_status_cb(ctx2, cert_status_cb);\n            SSL_CTX_set_tlsext_status_arg(ctx2, &tlscstatp);\n        }\n    }\n#endif\n    if (set_keylog_file(ctx, keylog_file))\n        goto end;\n\n    if (max_early_data >= 0)\n        SSL_CTX_set_max_early_data(ctx, max_early_data);\n    if (recv_max_early_data >= 0)\n        SSL_CTX_set_recv_max_early_data(ctx, recv_max_early_data);\n\n    if (cert_comp) {\n        BIO_printf(bio_s_out, \"Compressing certificates\\n\");\n        if (!SSL_CTX_compress_certs(ctx, 0))\n            BIO_printf(bio_s_out, \"Error compressing certs on ctx\\n\");\n        if (ctx2 != NULL && !SSL_CTX_compress_certs(ctx2, 0))\n            BIO_printf(bio_s_out, \"Error compressing certs on ctx2\\n\");\n    }\n    if (enable_server_rpk)\n        if (!SSL_CTX_set1_server_cert_type(ctx, cert_type_rpk, sizeof(cert_type_rpk))) {\n            BIO_printf(bio_s_out, \"Error setting server certificate types\\n\");\n            goto end;\n        }\n    if (enable_client_rpk)\n        if (!SSL_CTX_set1_client_cert_type(ctx, cert_type_rpk, sizeof(cert_type_rpk))) {\n            BIO_printf(bio_s_out, \"Error setting server certificate types\\n\");\n            goto end;\n        }\n\n    if (rev)\n        server_cb = rev_body;\n    else if (www)\n        server_cb = www_body;\n    else\n        server_cb = sv_body;\n#ifdef AF_UNIX\n    if (socket_family == AF_UNIX\n        && unlink_unix_path)\n        unlink(host);\n#endif\n    if (tfo)\n        BIO_printf(bio_s_out, \"Listening for TFO\\n\");\n    do_server(&accept_socket, host, port, socket_family, socket_type, protocol,\n              server_cb, context, naccept, bio_s_out, tfo);\n    print_stats(bio_s_out, ctx);\n    ret = 0;\n end:\n    SSL_CTX_free(ctx);\n    SSL_SESSION_free(psksess);\n    set_keylog_file(NULL, NULL);\n    X509_free(s_cert);\n    sk_X509_CRL_pop_free(crls, X509_CRL_free);\n    X509_free(s_dcert);\n    EVP_PKEY_free(s_key);\n    EVP_PKEY_free(s_dkey);\n    OSSL_STACK_OF_X509_free(s_chain);\n    OSSL_STACK_OF_X509_free(s_dchain);\n    OPENSSL_free(pass);\n    OPENSSL_free(dpass);\n    OPENSSL_free(host);\n    OPENSSL_free(port);\n    X509_VERIFY_PARAM_free(vpm);\n    free_sessions();\n    OPENSSL_free(tlscstatp.host);\n    OPENSSL_free(tlscstatp.port);\n    OPENSSL_free(tlscstatp.path);\n    SSL_CTX_free(ctx2);\n    X509_free(s_cert2);\n    EVP_PKEY_free(s_key2);\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    OPENSSL_free(next_proto.data);\n#endif\n    OPENSSL_free(alpn_ctx.data);\n    ssl_excert_free(exc);\n    sk_OPENSSL_STRING_free(ssl_args);\n    SSL_CONF_CTX_free(cctx);\n    release_engine(engine);\n    BIO_free(bio_s_out);\n    bio_s_out = NULL;\n    BIO_free(bio_s_msg);\n    bio_s_msg = NULL;\n#ifdef CHARSET_EBCDIC\n    BIO_meth_free(methods_ebcdic);\n#endif\n    return ret;\n}"
        ],
        "sink": "do_server(&accept_socket, host, port, socket_family, socket_type, protocol,",
        "final_sink": "do_server(&accept_socket, host, port, socket_family, socket_type, protocol,",
        "source": [
            "    out = app_malloc(len + 1, \"NPN buffer\");"
        ],
        "index": 45
    },
    {
        "prt": "port",
        "function_call": [
            "int s_server_main(int argc, char *argv[])\n{\n    ENGINE *engine = NULL;\n    EVP_PKEY *s_key = NULL, *s_dkey = NULL;\n    SSL_CONF_CTX *cctx = NULL;\n    const SSL_METHOD *meth = TLS_server_method();\n    SSL_EXCERT *exc = NULL;\n    STACK_OF(OPENSSL_STRING) *ssl_args = NULL;\n    STACK_OF(X509) *s_chain = NULL, *s_dchain = NULL;\n    STACK_OF(X509_CRL) *crls = NULL;\n    X509 *s_cert = NULL, *s_dcert = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    const char *CApath = NULL, *CAfile = NULL, *CAstore = NULL;\n    const char *chCApath = NULL, *chCAfile = NULL, *chCAstore = NULL;\n    char *dpassarg = NULL, *dpass = NULL;\n    char *passarg = NULL, *pass = NULL;\n    char *vfyCApath = NULL, *vfyCAfile = NULL, *vfyCAstore = NULL;\n    char *crl_file = NULL, *prog;\n#ifdef AF_UNIX\n    int unlink_unix_path = 0;\n#endif\n    do_server_cb server_cb;\n    int vpmtouched = 0, build_chain = 0, no_cache = 0, ext_cache = 0;\n    char *dhfile = NULL;\n    int no_dhe = 0;\n    int nocert = 0, ret = 1;\n    int noCApath = 0, noCAfile = 0, noCAstore = 0;\n    int s_cert_format = FORMAT_UNDEF, s_key_format = FORMAT_UNDEF;\n    int s_dcert_format = FORMAT_UNDEF, s_dkey_format = FORMAT_UNDEF;\n    int rev = 0, naccept = -1, sdebug = 0;\n    int socket_family = AF_UNSPEC, socket_type = SOCK_STREAM, protocol = 0;\n    int state = 0, crl_format = FORMAT_UNDEF, crl_download = 0;\n    char *host = NULL;\n    char *port = NULL;\n    unsigned char *context = NULL;\n    OPTION_CHOICE o;\n    EVP_PKEY *s_key2 = NULL;\n    X509 *s_cert2 = NULL;\n    tlsextctx tlsextcbp = { NULL, NULL, SSL_TLSEXT_ERR_ALERT_WARNING };\n    const char *ssl_config = NULL;\n    int read_buf_len = 0;\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    const char *next_proto_neg_in = NULL;\n    tlsextnextprotoctx next_proto = { NULL, 0 };\n#endif\n    const char *alpn_in = NULL;\n    tlsextalpnctx alpn_ctx = { NULL, 0 };\n#ifndef OPENSSL_NO_PSK\n    /* by default do not send a PSK identity hint */\n    char *psk_identity_hint = NULL;\n#endif\n    char *p;\n#ifndef OPENSSL_NO_SRP\n    char *srpuserseed = NULL;\n    char *srp_verifier_file = NULL;\n#endif\n#ifndef OPENSSL_NO_SRTP\n    char *srtp_profiles = NULL;\n#endif\n    int min_version = 0, max_version = 0, prot_opt = 0, no_prot_opt = 0;\n    int s_server_verify = SSL_VERIFY_NONE;\n    int s_server_session_id_context = 1; /* anything will do */\n    const char *s_cert_file = TEST_CERT, *s_key_file = NULL, *s_chain_file = NULL;\n    const char *s_cert_file2 = TEST_CERT2, *s_key_file2 = NULL;\n    char *s_dcert_file = NULL, *s_dkey_file = NULL, *s_dchain_file = NULL;\n#ifndef OPENSSL_NO_OCSP\n    int s_tlsextstatus = 0;\n#endif\n    int no_resume_ephemeral = 0;\n    unsigned int max_send_fragment = 0;\n    unsigned int split_send_fragment = 0, max_pipelines = 0;\n    const char *s_serverinfo_file = NULL;\n    const char *keylog_file = NULL;\n    int max_early_data = -1, recv_max_early_data = -1;\n    char *psksessf = NULL;\n    int no_ca_names = 0;\n#ifndef OPENSSL_NO_SCTP\n    int sctp_label_bug = 0;\n#endif\n    int ignore_unexpected_eof = 0;\n#ifndef OPENSSL_NO_KTLS\n    int enable_ktls = 0;\n#endif\n    int tfo = 0;\n    int cert_comp = 0;\n    int enable_server_rpk = 0;\n\n    /* Init of few remaining global variables */\n    local_argc = argc;\n    local_argv = argv;\n\n    ctx = ctx2 = NULL;\n    s_nbio = s_nbio_test = 0;\n    www = 0;\n    bio_s_out = NULL;\n    s_debug = 0;\n    s_msg = 0;\n    s_quiet = 0;\n    s_brief = 0;\n    async = 0;\n    use_sendfile = 0;\n    use_zc_sendfile = 0;\n\n    port = OPENSSL_strdup(PORT);\n    cctx = SSL_CONF_CTX_new();\n    vpm = X509_VERIFY_PARAM_new();\n    if (port == NULL || cctx == NULL || vpm == NULL)\n        goto end;\n    SSL_CONF_CTX_set_flags(cctx,\n                           SSL_CONF_FLAG_SERVER | SSL_CONF_FLAG_CMDLINE);\n\n    prog = opt_init(argc, argv, s_server_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        if (IS_PROT_FLAG(o) && ++prot_opt > 1) {\n            BIO_printf(bio_err, \"Cannot supply multiple protocol flags\\n\");\n            goto end;\n        }\n        if (IS_NO_PROT_FLAG(o))\n            no_prot_opt++;\n        if (prot_opt == 1 && no_prot_opt) {\n            BIO_printf(bio_err,\n                       \"Cannot supply both a protocol flag and '-no_<prot>'\\n\");\n            goto end;\n        }\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(s_server_options);\n            ret = 0;\n            goto end;\n\n        case OPT_4:\n#ifdef AF_UNIX\n            if (socket_family == AF_UNIX) {\n                OPENSSL_free(host); host = NULL;\n                OPENSSL_free(port); port = NULL;\n            }\n#endif\n            socket_family = AF_INET;\n            break;\n        case OPT_6:\n            if (1) {\n#ifdef AF_INET6\n#ifdef AF_UNIX\n                if (socket_family == AF_UNIX) {\n                    OPENSSL_free(host); host = NULL;\n                    OPENSSL_free(port); port = NULL;\n                }\n#endif\n                socket_family = AF_INET6;\n            } else {\n#endif\n                BIO_printf(bio_err, \"%s: IPv6 domain sockets unsupported\\n\", prog);\n                goto end;\n            }\n            break;\n        case OPT_PORT:\n#ifdef AF_UNIX\n            if (socket_family == AF_UNIX) {\n                socket_family = AF_UNSPEC;\n            }\n#endif\n            OPENSSL_free(port); port = NULL;\n            OPENSSL_free(host); host = NULL;\n            if (BIO_parse_hostserv(opt_arg(), NULL, &port, BIO_PARSE_PRIO_SERV) < 1) {\n                BIO_printf(bio_err,\n                           \"%s: -port argument malformed or ambiguous\\n\",\n                           port);\n                goto end;\n            }\n            break;\n        case OPT_ACCEPT:\n#ifdef AF_UNIX\n            if (socket_family == AF_UNIX) {\n                socket_family = AF_UNSPEC;\n            }\n#endif\n            OPENSSL_free(port); port = NULL;\n            OPENSSL_free(host); host = NULL;\n            if (BIO_parse_hostserv(opt_arg(), &host, &port, BIO_PARSE_PRIO_SERV) < 1) {\n                BIO_printf(bio_err,\n                           \"%s: -accept argument malformed or ambiguous\\n\",\n                           port);\n                goto end;\n            }\n            break;\n#ifdef AF_UNIX\n        case OPT_UNIX:\n            socket_family = AF_UNIX;\n            OPENSSL_free(host); host = OPENSSL_strdup(opt_arg());\n            if (host == NULL)\n                goto end;\n            OPENSSL_free(port); port = NULL;\n            break;\n        case OPT_UNLINK:\n            unlink_unix_path = 1;\n            break;\n#endif\n        case OPT_NACCEPT:\n            naccept = atol(opt_arg());\n            break;\n        case OPT_VERIFY:\n            s_server_verify = SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE;\n            verify_args.depth = atoi(opt_arg());\n            if (!s_quiet)\n                BIO_printf(bio_err, \"verify depth is %d\\n\", verify_args.depth);\n            break;\n        case OPT_UPPER_V_VERIFY:\n            s_server_verify =\n                SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT |\n                SSL_VERIFY_CLIENT_ONCE;\n            verify_args.depth = atoi(opt_arg());\n            if (!s_quiet)\n                BIO_printf(bio_err,\n                           \"verify depth is %d, must return a certificate\\n\",\n                           verify_args.depth);\n            break;\n        case OPT_CONTEXT:\n            context = (unsigned char *)opt_arg();\n            break;\n        case OPT_CERT:\n            s_cert_file = opt_arg();\n            break;\n        case OPT_NAMEOPT:\n            if (!set_nameopt(opt_arg()))\n                goto end;\n            break;\n        case OPT_CRL:\n            crl_file = opt_arg();\n            break;\n        case OPT_CRL_DOWNLOAD:\n            crl_download = 1;\n            break;\n        case OPT_SERVERINFO:\n            s_serverinfo_file = opt_arg();\n            break;\n        case OPT_CERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_cert_format))\n                goto opthelp;\n            break;\n        case OPT_KEY:\n            s_key_file = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_key_format))\n                goto opthelp;\n            break;\n        case OPT_PASS:\n            passarg = opt_arg();\n            break;\n        case OPT_CERT_CHAIN:\n            s_chain_file = opt_arg();\n            break;\n        case OPT_DHPARAM:\n            dhfile = opt_arg();\n            break;\n        case OPT_DCERTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_dcert_format))\n                goto opthelp;\n            break;\n        case OPT_DCERT:\n            s_dcert_file = opt_arg();\n            break;\n        case OPT_DKEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &s_dkey_format))\n                goto opthelp;\n            break;\n        case OPT_DPASS:\n            dpassarg = opt_arg();\n            break;\n        case OPT_DKEY:\n            s_dkey_file = opt_arg();\n            break;\n        case OPT_DCERT_CHAIN:\n            s_dchain_file = opt_arg();\n            break;\n        case OPT_NOCERT:\n            nocert = 1;\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_CHAINCAPATH:\n            chCApath = opt_arg();\n            break;\n        case OPT_VERIFYCAPATH:\n            vfyCApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_CHAINCASTORE:\n            chCAstore = opt_arg();\n            break;\n        case OPT_VERIFYCASTORE:\n            vfyCAstore = opt_arg();\n            break;\n        case OPT_NO_CACHE:\n            no_cache = 1;\n            break;\n        case OPT_EXT_CACHE:\n            ext_cache = 1;\n            break;\n        case OPT_CRLFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PEMDER, &crl_format))\n                goto opthelp;\n            break;\n        case OPT_S_CASES:\n        case OPT_S_NUM_TICKETS:\n        case OPT_ANTI_REPLAY:\n        case OPT_NO_ANTI_REPLAY:\n            if (ssl_args == NULL)\n                ssl_args = sk_OPENSSL_STRING_new_null();\n            if (ssl_args == NULL\n                || !sk_OPENSSL_STRING_push(ssl_args, opt_flag())\n                || !sk_OPENSSL_STRING_push(ssl_args, opt_arg())) {\n                BIO_printf(bio_err, \"%s: Memory allocation failure\\n\", prog);\n                goto end;\n            }\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto end;\n            vpmtouched++;\n            break;\n        case OPT_X_CASES:\n            if (!args_excert(o, &exc))\n                goto end;\n            break;\n        case OPT_VERIFY_RET_ERROR:\n            verify_args.return_error = 1;\n            break;\n        case OPT_VERIFY_QUIET:\n            verify_args.quiet = 1;\n            break;\n        case OPT_BUILD_CHAIN:\n            build_chain = 1;\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_CHAINCAFILE:\n            chCAfile = opt_arg();\n            break;\n        case OPT_VERIFYCAFILE:\n            vfyCAfile = opt_arg();\n            break;\n        case OPT_NBIO:\n            s_nbio = 1;\n            break;\n        case OPT_NBIO_TEST:\n            s_nbio = s_nbio_test = 1;\n            break;\n        case OPT_IGN_EOF:\n            s_ign_eof = 1;\n            break;\n        case OPT_NO_IGN_EOF:\n            s_ign_eof = 0;\n            break;\n        case OPT_DEBUG:\n            s_debug = 1;\n            break;\n        case OPT_TLSEXTDEBUG:\n            s_tlsextdebug = 1;\n            break;\n        case OPT_STATUS:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = 1;\n#endif\n            break;\n        case OPT_STATUS_VERBOSE:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = tlscstatp.verbose = 1;\n#endif\n            break;\n        case OPT_STATUS_TIMEOUT:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = 1;\n            tlscstatp.timeout = atoi(opt_arg());\n#endif\n            break;\n        case OPT_PROXY:\n#ifndef OPENSSL_NO_OCSP\n            tlscstatp.proxy = opt_arg();\n#endif\n            break;\n        case OPT_NO_PROXY:\n#ifndef OPENSSL_NO_OCSP\n            tlscstatp.no_proxy = opt_arg();\n#endif\n            break;\n        case OPT_STATUS_URL:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = 1;\n            if (!OSSL_HTTP_parse_url(opt_arg(), &tlscstatp.use_ssl, NULL,\n                                     &tlscstatp.host, &tlscstatp.port, NULL,\n                                     &tlscstatp.path, NULL, NULL)) {\n                BIO_printf(bio_err, \"Error parsing -status_url argument\\n\");\n                goto end;\n            }\n#endif\n            break;\n        case OPT_STATUS_FILE:\n#ifndef OPENSSL_NO_OCSP\n            s_tlsextstatus = 1;\n            tlscstatp.respin = opt_arg();\n#endif\n            break;\n        case OPT_MSG:\n            s_msg = 1;\n            break;\n        case OPT_MSGFILE:\n            bio_s_msg = BIO_new_file(opt_arg(), \"w\");\n            if (bio_s_msg == NULL) {\n                BIO_printf(bio_err, \"Error writing file %s\\n\", opt_arg());\n                goto end;\n            }\n            break;\n        case OPT_TRACE:\n#ifndef OPENSSL_NO_SSL_TRACE\n            s_msg = 2;\n#endif\n            break;\n        case OPT_SECURITY_DEBUG:\n            sdebug = 1;\n            break;\n        case OPT_SECURITY_DEBUG_VERBOSE:\n            sdebug = 2;\n            break;\n        case OPT_STATE:\n            state = 1;\n            break;\n        case OPT_CRLF:\n            s_crlf = 1;\n            break;\n        case OPT_QUIET:\n            s_quiet = 1;\n            break;\n        case OPT_BRIEF:\n            s_quiet = s_brief = verify_args.quiet = 1;\n            break;\n        case OPT_NO_DHE:\n            no_dhe = 1;\n            break;\n        case OPT_NO_RESUME_EPHEMERAL:\n            no_resume_ephemeral = 1;\n            break;\n        case OPT_PSK_IDENTITY:\n            psk_identity = opt_arg();\n            break;\n        case OPT_PSK_HINT:\n#ifndef OPENSSL_NO_PSK\n            psk_identity_hint = opt_arg();\n#endif\n            break;\n        case OPT_PSK:\n            for (p = psk_key = opt_arg(); *p; p++) {\n                if (isxdigit(_UC(*p)))\n                    continue;\n                BIO_printf(bio_err, \"Not a hex number '%s'\\n\", psk_key);\n                goto end;\n            }\n            break;\n        case OPT_PSK_SESS:\n            psksessf = opt_arg();\n            break;\n        case OPT_SRPVFILE:\n#ifndef OPENSSL_NO_SRP\n            srp_verifier_file = opt_arg();\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n#endif\n            break;\n        case OPT_SRPUSERSEED:\n#ifndef OPENSSL_NO_SRP\n            srpuserseed = opt_arg();\n            if (min_version < TLS1_VERSION)\n                min_version = TLS1_VERSION;\n#endif\n            break;\n        case OPT_REV:\n            rev = 1;\n            break;\n        case OPT_WWW:\n            www = 1;\n            break;\n        case OPT_UPPER_WWW:\n            www = 2;\n            break;\n        case OPT_HTTP:\n            www = 3;\n            break;\n        case OPT_SSL_CONFIG:\n            ssl_config = opt_arg();\n            break;\n        case OPT_SSL3:\n            min_version = SSL3_VERSION;\n            max_version = SSL3_VERSION;\n            break;\n        case OPT_TLS1_3:\n            min_version = TLS1_3_VERSION;\n            max_version = TLS1_3_VERSION;\n            break;\n        case OPT_TLS1_2:\n            min_version = TLS1_2_VERSION;\n            max_version = TLS1_2_VERSION;\n            break;\n        case OPT_TLS1_1:\n            min_version = TLS1_1_VERSION;\n            max_version = TLS1_1_VERSION;\n            break;\n        case OPT_TLS1:\n            min_version = TLS1_VERSION;\n            max_version = TLS1_VERSION;\n            break;\n        case OPT_DTLS:\n#ifndef OPENSSL_NO_DTLS\n            meth = DTLS_server_method();\n            socket_type = SOCK_DGRAM;\n#endif\n            break;\n        case OPT_DTLS1:\n#ifndef OPENSSL_NO_DTLS\n            meth = DTLS_server_method();\n            min_version = DTLS1_VERSION;\n            max_version = DTLS1_VERSION;\n            socket_type = SOCK_DGRAM;\n#endif\n            break;\n        case OPT_DTLS1_2:\n#ifndef OPENSSL_NO_DTLS\n            meth = DTLS_server_method();\n            min_version = DTLS1_2_VERSION;\n            max_version = DTLS1_2_VERSION;\n            socket_type = SOCK_DGRAM;\n#endif\n            break;\n        case OPT_SCTP:\n#ifndef OPENSSL_NO_SCTP\n            protocol = IPPROTO_SCTP;\n#endif\n            break;\n        case OPT_SCTP_LABEL_BUG:\n#ifndef OPENSSL_NO_SCTP\n            sctp_label_bug = 1;\n#endif\n            break;\n        case OPT_TIMEOUT:\n#ifndef OPENSSL_NO_DTLS\n            enable_timeouts = 1;\n#endif\n            break;\n        case OPT_MTU:\n#ifndef OPENSSL_NO_DTLS\n            socket_mtu = atol(opt_arg());\n#endif\n            break;\n        case OPT_LISTEN:\n#ifndef OPENSSL_NO_DTLS\n            dtlslisten = 1;\n#endif\n            break;\n        case OPT_STATELESS:\n            stateless = 1;\n            break;\n        case OPT_ID_PREFIX:\n            session_id_prefix = opt_arg();\n            break;\n        case OPT_ENGINE:\n#ifndef OPENSSL_NO_ENGINE\n            engine = setup_engine(opt_arg(), s_debug);\n#endif\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_SERVERNAME:\n            tlsextcbp.servername = opt_arg();\n            break;\n        case OPT_SERVERNAME_FATAL:\n            tlsextcbp.extension_error = SSL_TLSEXT_ERR_ALERT_FATAL;\n            break;\n        case OPT_CERT2:\n            s_cert_file2 = opt_arg();\n            break;\n        case OPT_KEY2:\n            s_key_file2 = opt_arg();\n            break;\n        case OPT_NEXTPROTONEG:\n# ifndef OPENSSL_NO_NEXTPROTONEG\n            next_proto_neg_in = opt_arg();\n#endif\n            break;\n        case OPT_ALPN:\n            alpn_in = opt_arg();\n            break;\n        case OPT_SRTP_PROFILES:\n#ifndef OPENSSL_NO_SRTP\n            srtp_profiles = opt_arg();\n#endif\n            break;\n        case OPT_KEYMATEXPORT:\n            keymatexportlabel = opt_arg();\n            break;\n        case OPT_KEYMATEXPORTLEN:\n            keymatexportlen = atoi(opt_arg());\n            break;\n        case OPT_ASYNC:\n            async = 1;\n            break;\n        case OPT_MAX_SEND_FRAG:\n            max_send_fragment = atoi(opt_arg());\n            break;\n        case OPT_SPLIT_SEND_FRAG:\n            split_send_fragment = atoi(opt_arg());\n            break;\n        case OPT_MAX_PIPELINES:\n            max_pipelines = atoi(opt_arg());\n            break;\n        case OPT_READ_BUF:\n            read_buf_len = atoi(opt_arg());\n            break;\n        case OPT_KEYLOG_FILE:\n            keylog_file = opt_arg();\n            break;\n        case OPT_MAX_EARLY:\n            max_early_data = atoi(opt_arg());\n            if (max_early_data < 0) {\n                BIO_printf(bio_err, \"Invalid value for max_early_data\\n\");\n                goto end;\n            }\n            break;\n        case OPT_RECV_MAX_EARLY:\n            recv_max_early_data = atoi(opt_arg());\n            if (recv_max_early_data < 0) {\n                BIO_printf(bio_err, \"Invalid value for recv_max_early_data\\n\");\n                goto end;\n            }\n            break;\n        case OPT_EARLY_DATA:\n            early_data = 1;\n            if (max_early_data == -1)\n                max_early_data = SSL3_RT_MAX_PLAIN_LENGTH;\n            break;\n        case OPT_HTTP_SERVER_BINMODE:\n            http_server_binmode = 1;\n            break;\n        case OPT_NOCANAMES:\n            no_ca_names = 1;\n            break;\n        case OPT_KTLS:\n#ifndef OPENSSL_NO_KTLS\n            enable_ktls = 1;\n#endif\n            break;\n        case OPT_SENDFILE:\n#ifndef OPENSSL_NO_KTLS\n            use_sendfile = 1;\n#endif\n            break;\n        case OPT_USE_ZC_SENDFILE:\n#ifndef OPENSSL_NO_KTLS\n            use_zc_sendfile = 1;\n#endif\n            break;\n        case OPT_IGNORE_UNEXPECTED_EOF:\n            ignore_unexpected_eof = 1;\n            break;\n        case OPT_TFO:\n            tfo = 1;\n            break;\n        case OPT_CERT_COMP:\n            cert_comp = 1;\n            break;\n        case OPT_ENABLE_SERVER_RPK:\n            enable_server_rpk = 1;\n            break;\n        case OPT_ENABLE_CLIENT_RPK:\n            enable_client_rpk = 1;\n            break;\n        }\n    }\n\n    /* No extra arguments. */\n    if (!opt_check_rest_arg(NULL))\n        goto opthelp;\n\n    if (!app_RAND_load())\n        goto end;\n\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    if (min_version == TLS1_3_VERSION && next_proto_neg_in != NULL) {\n        BIO_printf(bio_err, \"Cannot supply -nextprotoneg with TLSv1.3\\n\");\n        goto opthelp;\n    }\n#endif\n#ifndef OPENSSL_NO_DTLS\n    if (www && socket_type == SOCK_DGRAM) {\n        BIO_printf(bio_err, \"Can't use -HTTP, -www or -WWW with DTLS\\n\");\n        goto end;\n    }\n\n    if (dtlslisten && socket_type != SOCK_DGRAM) {\n        BIO_printf(bio_err, \"Can only use -listen with DTLS\\n\");\n        goto end;\n    }\n\n    if (rev && socket_type == SOCK_DGRAM) {\n        BIO_printf(bio_err, \"Can't use -rev with DTLS\\n\");\n        goto end;\n    }\n#endif\n\n    if (tfo && socket_type != SOCK_STREAM) {\n        BIO_printf(bio_err, \"Can only use -tfo with TLS\\n\");\n        goto end;\n    }\n\n    if (stateless && socket_type != SOCK_STREAM) {\n        BIO_printf(bio_err, \"Can only use --stateless with TLS\\n\");\n        goto end;\n    }\n\n#ifdef AF_UNIX\n    if (socket_family == AF_UNIX && socket_type != SOCK_STREAM) {\n        BIO_printf(bio_err,\n                   \"Can't use unix sockets and datagrams together\\n\");\n        goto end;\n    }\n#endif\n    if (early_data && rev) {\n        BIO_printf(bio_err,\n                   \"Can't use -early_data in combination with -rev\\n\");\n        goto end;\n    }\n\n#ifndef OPENSSL_NO_SCTP\n    if (protocol == IPPROTO_SCTP) {\n        if (socket_type != SOCK_DGRAM) {\n            BIO_printf(bio_err, \"Can't use -sctp without DTLS\\n\");\n            goto end;\n        }\n        /* SCTP is unusual. It uses DTLS over a SOCK_STREAM protocol */\n        socket_type = SOCK_STREAM;\n    }\n#endif\n\n#ifndef OPENSSL_NO_KTLS\n    if (use_zc_sendfile && !use_sendfile) {\n        BIO_printf(bio_out, \"Warning: -zerocopy_sendfile depends on -sendfile, enabling -sendfile now.\\n\");\n        use_sendfile = 1;\n    }\n\n    if (use_sendfile && enable_ktls == 0) {\n        BIO_printf(bio_out, \"Warning: -sendfile depends on -ktls, enabling -ktls now.\\n\");\n        enable_ktls = 1;\n    }\n\n    if (use_sendfile && www <= 1) {\n        BIO_printf(bio_err, \"Can't use -sendfile without -WWW or -HTTP\\n\");\n        goto end;\n    }\n#endif\n\n    if (!app_passwd(passarg, dpassarg, &pass, &dpass)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    if (s_key_file == NULL)\n        s_key_file = s_cert_file;\n\n    if (s_key_file2 == NULL)\n        s_key_file2 = s_cert_file2;\n\n    if (!load_excert(&exc))\n        goto end;\n\n    if (nocert == 0) {\n        s_key = load_key(s_key_file, s_key_format, 0, pass, engine,\n                         \"server certificate private key\");\n        if (s_key == NULL)\n            goto end;\n\n        s_cert = load_cert_pass(s_cert_file, s_cert_format, 1, pass,\n                                \"server certificate\");\n\n        if (s_cert == NULL)\n            goto end;\n        if (s_chain_file != NULL) {\n            if (!load_certs(s_chain_file, 0, &s_chain, NULL,\n                            \"server certificate chain\"))\n                goto end;\n        }\n\n        if (tlsextcbp.servername != NULL) {\n            s_key2 = load_key(s_key_file2, s_key_format, 0, pass, engine,\n                              \"second server certificate private key\");\n            if (s_key2 == NULL)\n                goto end;\n\n            s_cert2 = load_cert_pass(s_cert_file2, s_cert_format, 1, pass,\n                                \"second server certificate\");\n\n            if (s_cert2 == NULL)\n                goto end;\n        }\n    }\n#if !defined(OPENSSL_NO_NEXTPROTONEG)\n    if (next_proto_neg_in) {\n        next_proto.data = next_protos_parse(&next_proto.len, next_proto_neg_in);\n        if (next_proto.data == NULL)\n            goto end;\n    }\n#endif\n    alpn_ctx.data = NULL;\n    if (alpn_in) {\n        alpn_ctx.data = next_protos_parse(&alpn_ctx.len, alpn_in);\n        if (alpn_ctx.data == NULL)\n            goto end;\n    }\n\n    if (crl_file != NULL) {\n        X509_CRL *crl;\n        crl = load_crl(crl_file, crl_format, 0, \"CRL\");\n        if (crl == NULL)\n            goto end;\n        crls = sk_X509_CRL_new_null();\n        if (crls == NULL || !sk_X509_CRL_push(crls, crl)) {\n            BIO_puts(bio_err, \"Error adding CRL\\n\");\n            ERR_print_errors(bio_err);\n            X509_CRL_free(crl);\n            goto end;\n        }\n    }\n\n    if (s_dcert_file != NULL) {\n\n        if (s_dkey_file == NULL)\n            s_dkey_file = s_dcert_file;\n\n        s_dkey = load_key(s_dkey_file, s_dkey_format,\n                          0, dpass, engine, \"second certificate private key\");\n        if (s_dkey == NULL)\n            goto end;\n\n        s_dcert = load_cert_pass(s_dcert_file, s_dcert_format, 1, dpass,\n                                 \"second server certificate\");\n\n        if (s_dcert == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        if (s_dchain_file != NULL) {\n            if (!load_certs(s_dchain_file, 0, &s_dchain, NULL,\n                            \"second server certificate chain\"))\n                goto end;\n        }\n\n    }\n\n    if (bio_s_out == NULL) {\n        if (s_quiet && !s_debug) {\n            bio_s_out = BIO_new(BIO_s_null());\n            if (s_msg && bio_s_msg == NULL) {\n                bio_s_msg = dup_bio_out(FORMAT_TEXT);\n                if (bio_s_msg == NULL) {\n                    BIO_printf(bio_err, \"Out of memory\\n\");\n                    goto end;\n                }\n            }\n        } else {\n            bio_s_out = dup_bio_out(FORMAT_TEXT);\n        }\n    }\n\n    if (bio_s_out == NULL)\n        goto end;\n\n    if (nocert) {\n        s_cert_file = NULL;\n        s_key_file = NULL;\n        s_dcert_file = NULL;\n        s_dkey_file = NULL;\n        s_cert_file2 = NULL;\n        s_key_file2 = NULL;\n    }\n\n    ctx = SSL_CTX_new_ex(app_get0_libctx(), app_get0_propq(), meth);\n    if (ctx == NULL) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    SSL_CTX_clear_mode(ctx, SSL_MODE_AUTO_RETRY);\n\n    if (sdebug)\n        ssl_ctx_security_debug(ctx, sdebug);\n\n    if (!config_ctx(cctx, ssl_args, ctx))\n        goto end;\n\n    if (ssl_config) {\n        if (SSL_CTX_config(ctx, ssl_config) == 0) {\n            BIO_printf(bio_err, \"Error using configuration \\\"%s\\\"\\n\",\n                       ssl_config);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n#ifndef OPENSSL_NO_SCTP\n    if (protocol == IPPROTO_SCTP && sctp_label_bug == 1)\n        SSL_CTX_set_mode(ctx, SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG);\n#endif\n\n    if (min_version != 0\n        && SSL_CTX_set_min_proto_version(ctx, min_version) == 0)\n        goto end;\n    if (max_version != 0\n        && SSL_CTX_set_max_proto_version(ctx, max_version) == 0)\n        goto end;\n\n    if (session_id_prefix) {\n        if (strlen(session_id_prefix) >= 32)\n            BIO_printf(bio_err,\n                       \"warning: id_prefix is too long, only one new session will be possible\\n\");\n        if (!SSL_CTX_set_generate_session_id(ctx, generate_session_id)) {\n            BIO_printf(bio_err, \"error setting 'id_prefix'\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        BIO_printf(bio_err, \"id_prefix '%s' set.\\n\", session_id_prefix);\n    }\n    if (exc != NULL)\n        ssl_ctx_set_excert(ctx, exc);\n\n    if (state)\n        SSL_CTX_set_info_callback(ctx, apps_ssl_info_callback);\n    if (no_cache)\n        SSL_CTX_set_session_cache_mode(ctx, SSL_SESS_CACHE_OFF);\n    else if (ext_cache)\n        init_session_cache_ctx(ctx);\n    else\n        SSL_CTX_sess_set_cache_size(ctx, 128);\n\n    if (async) {\n        SSL_CTX_set_mode(ctx, SSL_MODE_ASYNC);\n    }\n\n    if (no_ca_names) {\n        SSL_CTX_set_options(ctx, SSL_OP_DISABLE_TLSEXT_CA_NAMES);\n    }\n\n    if (ignore_unexpected_eof)\n        SSL_CTX_set_options(ctx, SSL_OP_IGNORE_UNEXPECTED_EOF);\n#ifndef OPENSSL_NO_KTLS\n    if (enable_ktls)\n        SSL_CTX_set_options(ctx, SSL_OP_ENABLE_KTLS);\n    if (use_zc_sendfile)\n        SSL_CTX_set_options(ctx, SSL_OP_ENABLE_KTLS_TX_ZEROCOPY_SENDFILE);\n#endif\n\n    if (max_send_fragment > 0\n        && !SSL_CTX_set_max_send_fragment(ctx, max_send_fragment)) {\n        BIO_printf(bio_err, \"%s: Max send fragment size %u is out of permitted range\\n\",\n                   prog, max_send_fragment);\n        goto end;\n    }\n\n    if (split_send_fragment > 0\n        && !SSL_CTX_set_split_send_fragment(ctx, split_send_fragment)) {\n        BIO_printf(bio_err, \"%s: Split send fragment size %u is out of permitted range\\n\",\n                   prog, split_send_fragment);\n        goto end;\n    }\n    if (max_pipelines > 0\n        && !SSL_CTX_set_max_pipelines(ctx, max_pipelines)) {\n        BIO_printf(bio_err, \"%s: Max pipelines %u is out of permitted range\\n\",\n                   prog, max_pipelines);\n        goto end;\n    }\n\n    if (read_buf_len > 0) {\n        SSL_CTX_set_default_read_buffer_len(ctx, read_buf_len);\n    }\n#ifndef OPENSSL_NO_SRTP\n    if (srtp_profiles != NULL) {\n        /* Returns 0 on success! */\n        if (SSL_CTX_set_tlsext_use_srtp(ctx, srtp_profiles) != 0) {\n            BIO_printf(bio_err, \"Error setting SRTP profile\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n#endif\n\n    if (!ctx_set_verify_locations(ctx, CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n    if (vpmtouched && !SSL_CTX_set1_param(ctx, vpm)) {\n        BIO_printf(bio_err, \"Error setting verify params\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    ssl_ctx_add_crls(ctx, crls, 0);\n\n    if (!ssl_load_stores(ctx,\n                         vfyCApath, vfyCAfile, vfyCAstore,\n                         chCApath, chCAfile, chCAstore,\n                         crls, crl_download)) {\n        BIO_printf(bio_err, \"Error loading store locations\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    if (s_cert2) {\n        ctx2 = SSL_CTX_new_ex(app_get0_libctx(), app_get0_propq(), meth);\n        if (ctx2 == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (ctx2 != NULL) {\n        BIO_printf(bio_s_out, \"Setting secondary ctx parameters\\n\");\n\n        if (sdebug)\n            ssl_ctx_security_debug(ctx2, sdebug);\n\n        if (session_id_prefix) {\n            if (strlen(session_id_prefix) >= 32)\n                BIO_printf(bio_err,\n                           \"warning: id_prefix is too long, only one new session will be possible\\n\");\n            if (!SSL_CTX_set_generate_session_id(ctx2, generate_session_id)) {\n                BIO_printf(bio_err, \"error setting 'id_prefix'\\n\");\n                ERR_print_errors(bio_err);\n                goto end;\n            }\n            BIO_printf(bio_err, \"id_prefix '%s' set.\\n\", session_id_prefix);\n        }\n        if (exc != NULL)\n            ssl_ctx_set_excert(ctx2, exc);\n\n        if (state)\n            SSL_CTX_set_info_callback(ctx2, apps_ssl_info_callback);\n\n        if (no_cache)\n            SSL_CTX_set_session_cache_mode(ctx2, SSL_SESS_CACHE_OFF);\n        else if (ext_cache)\n            init_session_cache_ctx(ctx2);\n        else\n            SSL_CTX_sess_set_cache_size(ctx2, 128);\n\n        if (async)\n            SSL_CTX_set_mode(ctx2, SSL_MODE_ASYNC);\n\n        if (!ctx_set_verify_locations(ctx2, CAfile, noCAfile, CApath,\n                                      noCApath, CAstore, noCAstore)) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        if (vpmtouched && !SSL_CTX_set1_param(ctx2, vpm)) {\n            BIO_printf(bio_err, \"Error setting verify params\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n\n        ssl_ctx_add_crls(ctx2, crls, 0);\n        if (!config_ctx(cctx, ssl_args, ctx2))\n            goto end;\n    }\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    if (next_proto.data)\n        SSL_CTX_set_next_protos_advertised_cb(ctx, next_proto_cb,\n                                              &next_proto);\n#endif\n    if (alpn_ctx.data)\n        SSL_CTX_set_alpn_select_cb(ctx, alpn_cb, &alpn_ctx);\n\n    if (!no_dhe) {\n        EVP_PKEY *dhpkey = NULL;\n\n        if (dhfile != NULL)\n            dhpkey = load_keyparams(dhfile, FORMAT_UNDEF, 0, \"DH\", \"DH parameters\");\n        else if (s_cert_file != NULL)\n            dhpkey = load_keyparams_suppress(s_cert_file, FORMAT_UNDEF, 0, \"DH\",\n                                             \"DH parameters\", 1);\n\n        if (dhpkey != NULL) {\n            BIO_printf(bio_s_out, \"Setting temp DH parameters\\n\");\n        } else {\n            BIO_printf(bio_s_out, \"Using default temp DH parameters\\n\");\n        }\n        (void)BIO_flush(bio_s_out);\n\n        if (dhpkey == NULL) {\n            SSL_CTX_set_dh_auto(ctx, 1);\n        } else {\n            /*\n             * We need 2 references: one for use by ctx and one for use by\n             * ctx2\n             */\n            if (!EVP_PKEY_up_ref(dhpkey)) {\n                EVP_PKEY_free(dhpkey);\n                goto end;\n            }\n            if (!SSL_CTX_set0_tmp_dh_pkey(ctx, dhpkey)) {\n                BIO_puts(bio_err, \"Error setting temp DH parameters\\n\");\n                ERR_print_errors(bio_err);\n                /* Free 2 references */\n                EVP_PKEY_free(dhpkey);\n                EVP_PKEY_free(dhpkey);\n                goto end;\n            }\n        }\n\n        if (ctx2 != NULL) {\n            if (dhfile != NULL) {\n                EVP_PKEY *dhpkey2 = load_keyparams_suppress(s_cert_file2,\n                                                            FORMAT_UNDEF,\n                                                            0, \"DH\",\n                                                            \"DH parameters\", 1);\n\n                if (dhpkey2 != NULL) {\n                    BIO_printf(bio_s_out, \"Setting temp DH parameters\\n\");\n                    (void)BIO_flush(bio_s_out);\n\n                    EVP_PKEY_free(dhpkey);\n                    dhpkey = dhpkey2;\n                }\n            }\n            if (dhpkey == NULL) {\n                SSL_CTX_set_dh_auto(ctx2, 1);\n            } else if (!SSL_CTX_set0_tmp_dh_pkey(ctx2, dhpkey)) {\n                BIO_puts(bio_err, \"Error setting temp DH parameters\\n\");\n                ERR_print_errors(bio_err);\n                EVP_PKEY_free(dhpkey);\n                goto end;\n            }\n            dhpkey = NULL;\n        }\n        EVP_PKEY_free(dhpkey);\n    }\n\n    if (!set_cert_key_stuff(ctx, s_cert, s_key, s_chain, build_chain))\n        goto end;\n\n    if (s_serverinfo_file != NULL\n        && !SSL_CTX_use_serverinfo_file(ctx, s_serverinfo_file)) {\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    if (ctx2 != NULL\n        && !set_cert_key_stuff(ctx2, s_cert2, s_key2, NULL, build_chain))\n        goto end;\n\n    if (s_dcert != NULL) {\n        if (!set_cert_key_stuff(ctx, s_dcert, s_dkey, s_dchain, build_chain))\n            goto end;\n    }\n\n    if (no_resume_ephemeral) {\n        SSL_CTX_set_not_resumable_session_callback(ctx,\n                                                   not_resumable_sess_cb);\n\n        if (ctx2 != NULL)\n            SSL_CTX_set_not_resumable_session_callback(ctx2,\n                                                       not_resumable_sess_cb);\n    }\n#ifndef OPENSSL_NO_PSK\n    if (psk_key != NULL) {\n        if (s_debug)\n            BIO_printf(bio_s_out, \"PSK key given, setting server callback\\n\");\n        SSL_CTX_set_psk_server_callback(ctx, psk_server_cb);\n    }\n\n    if (psk_identity_hint != NULL) {\n        if (min_version == TLS1_3_VERSION) {\n            BIO_printf(bio_s_out, \"PSK warning: there is NO identity hint in TLSv1.3\\n\");\n        } else {\n            if (!SSL_CTX_use_psk_identity_hint(ctx, psk_identity_hint)) {\n                BIO_printf(bio_err, \"error setting PSK identity hint to context\\n\");\n                ERR_print_errors(bio_err);\n                goto end;\n            }\n        }\n    }\n#endif\n    if (psksessf != NULL) {\n        BIO *stmp = BIO_new_file(psksessf, \"r\");\n\n        if (stmp == NULL) {\n            BIO_printf(bio_err, \"Can't open PSK session file %s\\n\", psksessf);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        psksess = PEM_read_bio_SSL_SESSION(stmp, NULL, 0, NULL);\n        BIO_free(stmp);\n        if (psksess == NULL) {\n            BIO_printf(bio_err, \"Can't read PSK session file %s\\n\", psksessf);\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n\n    }\n\n    if (psk_key != NULL || psksess != NULL)\n        SSL_CTX_set_psk_find_session_callback(ctx, psk_find_session_cb);\n\n    SSL_CTX_set_verify(ctx, s_server_verify, verify_callback);\n    if (!SSL_CTX_set_session_id_context(ctx,\n                                        (void *)&s_server_session_id_context,\n                                        sizeof(s_server_session_id_context))) {\n        BIO_printf(bio_err, \"error setting session id context\\n\");\n        ERR_print_errors(bio_err);\n        goto end;\n    }\n\n    /* Set DTLS cookie generation and verification callbacks */\n    SSL_CTX_set_cookie_generate_cb(ctx, generate_cookie_callback);\n    SSL_CTX_set_cookie_verify_cb(ctx, verify_cookie_callback);\n\n    /* Set TLS1.3 cookie generation and verification callbacks */\n    SSL_CTX_set_stateless_cookie_generate_cb(ctx, generate_stateless_cookie_callback);\n    SSL_CTX_set_stateless_cookie_verify_cb(ctx, verify_stateless_cookie_callback);\n\n    if (ctx2 != NULL) {\n        SSL_CTX_set_verify(ctx2, s_server_verify, verify_callback);\n        if (!SSL_CTX_set_session_id_context(ctx2,\n                    (void *)&s_server_session_id_context,\n                    sizeof(s_server_session_id_context))) {\n            BIO_printf(bio_err, \"error setting session id context\\n\");\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n        tlsextcbp.biodebug = bio_s_out;\n        SSL_CTX_set_tlsext_servername_callback(ctx2, ssl_servername_cb);\n        SSL_CTX_set_tlsext_servername_arg(ctx2, &tlsextcbp);\n        SSL_CTX_set_tlsext_servername_callback(ctx, ssl_servername_cb);\n        SSL_CTX_set_tlsext_servername_arg(ctx, &tlsextcbp);\n    }\n\n#ifndef OPENSSL_NO_SRP\n    if (srp_verifier_file != NULL) {\n        if (!set_up_srp_verifier_file(ctx, &srp_callback_parm, srpuserseed,\n                                      srp_verifier_file))\n            goto end;\n    } else\n#endif\n    if (CAfile != NULL) {\n        SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file(CAfile));\n\n        if (ctx2)\n            SSL_CTX_set_client_CA_list(ctx2, SSL_load_client_CA_file(CAfile));\n    }\n#ifndef OPENSSL_NO_OCSP\n    if (s_tlsextstatus) {\n        SSL_CTX_set_tlsext_status_cb(ctx, cert_status_cb);\n        SSL_CTX_set_tlsext_status_arg(ctx, &tlscstatp);\n        if (ctx2) {\n            SSL_CTX_set_tlsext_status_cb(ctx2, cert_status_cb);\n            SSL_CTX_set_tlsext_status_arg(ctx2, &tlscstatp);\n        }\n    }\n#endif\n    if (set_keylog_file(ctx, keylog_file))\n        goto end;\n\n    if (max_early_data >= 0)\n        SSL_CTX_set_max_early_data(ctx, max_early_data);\n    if (recv_max_early_data >= 0)\n        SSL_CTX_set_recv_max_early_data(ctx, recv_max_early_data);\n\n    if (cert_comp) {\n        BIO_printf(bio_s_out, \"Compressing certificates\\n\");\n        if (!SSL_CTX_compress_certs(ctx, 0))\n            BIO_printf(bio_s_out, \"Error compressing certs on ctx\\n\");\n        if (ctx2 != NULL && !SSL_CTX_compress_certs(ctx2, 0))\n            BIO_printf(bio_s_out, \"Error compressing certs on ctx2\\n\");\n    }\n    if (enable_server_rpk)\n        if (!SSL_CTX_set1_server_cert_type(ctx, cert_type_rpk, sizeof(cert_type_rpk))) {\n            BIO_printf(bio_s_out, \"Error setting server certificate types\\n\");\n            goto end;\n        }\n    if (enable_client_rpk)\n        if (!SSL_CTX_set1_client_cert_type(ctx, cert_type_rpk, sizeof(cert_type_rpk))) {\n            BIO_printf(bio_s_out, \"Error setting server certificate types\\n\");\n            goto end;\n        }\n\n    if (rev)\n        server_cb = rev_body;\n    else if (www)\n        server_cb = www_body;\n    else\n        server_cb = sv_body;\n#ifdef AF_UNIX\n    if (socket_family == AF_UNIX\n        && unlink_unix_path)\n        unlink(host);\n#endif\n    if (tfo)\n        BIO_printf(bio_s_out, \"Listening for TFO\\n\");\n    do_server(&accept_socket, host, port, socket_family, socket_type, protocol,\n              server_cb, context, naccept, bio_s_out, tfo);\n    print_stats(bio_s_out, ctx);\n    ret = 0;\n end:\n    SSL_CTX_free(ctx);\n    SSL_SESSION_free(psksess);\n    set_keylog_file(NULL, NULL);\n    X509_free(s_cert);\n    sk_X509_CRL_pop_free(crls, X509_CRL_free);\n    X509_free(s_dcert);\n    EVP_PKEY_free(s_key);\n    EVP_PKEY_free(s_dkey);\n    OSSL_STACK_OF_X509_free(s_chain);\n    OSSL_STACK_OF_X509_free(s_dchain);\n    OPENSSL_free(pass);\n    OPENSSL_free(dpass);\n    OPENSSL_free(host);\n    OPENSSL_free(port);\n    X509_VERIFY_PARAM_free(vpm);\n    free_sessions();\n    OPENSSL_free(tlscstatp.host);\n    OPENSSL_free(tlscstatp.port);\n    OPENSSL_free(tlscstatp.path);\n    SSL_CTX_free(ctx2);\n    X509_free(s_cert2);\n    EVP_PKEY_free(s_key2);\n#ifndef OPENSSL_NO_NEXTPROTONEG\n    OPENSSL_free(next_proto.data);\n#endif\n    OPENSSL_free(alpn_ctx.data);\n    ssl_excert_free(exc);\n    sk_OPENSSL_STRING_free(ssl_args);\n    SSL_CONF_CTX_free(cctx);\n    release_engine(engine);\n    BIO_free(bio_s_out);\n    bio_s_out = NULL;\n    BIO_free(bio_s_msg);\n    bio_s_msg = NULL;\n#ifdef CHARSET_EBCDIC\n    BIO_meth_free(methods_ebcdic);\n#endif\n    return ret;\n}"
        ],
        "sink": "do_server(&accept_socket, host, port, socket_family, socket_type, protocol,",
        "final_sink": "do_server(&accept_socket, host, port, socket_family, socket_type, protocol,",
        "source": [
            "            node = sk_X509_POLICY_NODE_value(nodes, i);"
        ],
        "index": 46
    },
    {
        "prt": "p7",
        "function_call": [
            "int smime_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    BIO *in = NULL, *out = NULL, *indata = NULL;\n    EVP_PKEY *key = NULL;\n    PKCS7 *p7 = NULL;\n    STACK_OF(OPENSSL_STRING) *sksigners = NULL, *skkeys = NULL;\n    STACK_OF(X509) *encerts = NULL, *other = NULL;\n    X509 *cert = NULL, *recip = NULL, *signer = NULL;\n    X509_STORE *store = NULL;\n    X509_VERIFY_PARAM *vpm = NULL;\n    EVP_CIPHER *cipher = NULL;\n    EVP_MD *sign_md = NULL;\n    const char *CAfile = NULL, *CApath = NULL, *CAstore = NULL, *prog = NULL;\n    char *certfile = NULL, *keyfile = NULL, *contfile = NULL;\n    char *infile = NULL, *outfile = NULL, *signerfile = NULL, *recipfile = NULL;\n    char *passinarg = NULL, *passin = NULL, *to = NULL, *from = NULL;\n    char *subject = NULL, *digestname = NULL, *ciphername = NULL;\n    OPTION_CHOICE o;\n    int noCApath = 0, noCAfile = 0, noCAstore = 0;\n    int flags = PKCS7_DETACHED, operation = 0, ret = 0, indef = 0;\n    int informat = FORMAT_SMIME, outformat = FORMAT_SMIME, keyform =\n        FORMAT_UNDEF;\n    int vpmtouched = 0, rv = 0;\n    ENGINE *e = NULL;\n    const char *mime_eol = \"\\n\";\n    OSSL_LIB_CTX *libctx = app_get0_libctx();\n\n    if ((vpm = X509_VERIFY_PARAM_new()) == NULL)\n        return 1;\n\n    opt_set_unknown_name(\"cipher\");\n    prog = opt_init(argc, argv, smime_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opthelp:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(smime_options);\n            ret = 0;\n            goto end;\n        case OPT_INFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &informat))\n                goto opthelp;\n            break;\n        case OPT_IN:\n            infile = opt_arg();\n            break;\n        case OPT_OUTFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_PDS, &outformat))\n                goto opthelp;\n            break;\n        case OPT_OUT:\n            outfile = opt_arg();\n            break;\n        case OPT_ENCRYPT:\n            if (!SET_OPERATION(SMIME_ENCRYPT))\n                goto end;\n            break;\n        case OPT_DECRYPT:\n            if (!SET_OPERATION(SMIME_DECRYPT))\n                goto end;\n            break;\n        case OPT_SIGN:\n            if (!SET_OPERATION(SMIME_SIGN))\n                goto end;\n            break;\n        case OPT_RESIGN:\n            if (!SET_OPERATION(SMIME_RESIGN))\n                goto end;\n            break;\n        case OPT_VERIFY:\n            if (!SET_OPERATION(SMIME_VERIFY))\n                goto end;\n            break;\n        case OPT_PK7OUT:\n            if (!SET_OPERATION(SMIME_PK7OUT))\n                goto end;\n            break;\n        case OPT_TEXT:\n            flags |= PKCS7_TEXT;\n            break;\n        case OPT_NOINTERN:\n            flags |= PKCS7_NOINTERN;\n            break;\n        case OPT_NOVERIFY:\n            flags |= PKCS7_NOVERIFY;\n            break;\n        case OPT_NOCHAIN:\n            flags |= PKCS7_NOCHAIN;\n            break;\n        case OPT_NOCERTS:\n            flags |= PKCS7_NOCERTS;\n            break;\n        case OPT_NOATTR:\n            flags |= PKCS7_NOATTR;\n            break;\n        case OPT_NODETACH:\n            flags &= ~PKCS7_DETACHED;\n            break;\n        case OPT_NOSMIMECAP:\n            flags |= PKCS7_NOSMIMECAP;\n            break;\n        case OPT_BINARY:\n            flags |= PKCS7_BINARY;\n            break;\n        case OPT_NOSIGS:\n            flags |= PKCS7_NOSIGS;\n            break;\n        case OPT_STREAM:\n        case OPT_INDEF:\n            indef = 1;\n            break;\n        case OPT_NOINDEF:\n            indef = 0;\n            break;\n        case OPT_CRLFEOL:\n            flags |= PKCS7_CRLFEOL;\n            mime_eol = \"\\r\\n\";\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_ENGINE:\n            e = setup_engine(opt_arg(), 0);\n            break;\n        case OPT_PASSIN:\n            passinarg = opt_arg();\n            break;\n        case OPT_TO:\n            to = opt_arg();\n            break;\n        case OPT_FROM:\n            from = opt_arg();\n            break;\n        case OPT_SUBJECT:\n            subject = opt_arg();\n            break;\n        case OPT_SIGNER:\n            /* If previous -signer argument add signer to list */\n            if (signerfile != NULL) {\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                if (keyfile == NULL)\n                    keyfile = signerfile;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n                keyfile = NULL;\n            }\n            signerfile = opt_arg();\n            break;\n        case OPT_RECIP:\n            recipfile = opt_arg();\n            break;\n        case OPT_MD:\n            digestname = opt_arg();\n            break;\n        case OPT_CIPHER:\n            ciphername = opt_unknown();\n            break;\n        case OPT_INKEY:\n            /* If previous -inkey argument add signer to list */\n            if (keyfile != NULL) {\n                if (signerfile == NULL) {\n                    BIO_printf(bio_err,\n                               \"%s: Must have -signer before -inkey\\n\", prog);\n                    goto opthelp;\n                }\n                if (sksigners == NULL\n                    && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(sksigners, signerfile);\n                signerfile = NULL;\n                if (skkeys == NULL\n                    && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                    goto end;\n                sk_OPENSSL_STRING_push(skkeys, keyfile);\n            }\n            keyfile = opt_arg();\n            break;\n        case OPT_KEYFORM:\n            if (!opt_format(opt_arg(), OPT_FMT_ANY, &keyform))\n                goto opthelp;\n            break;\n        case OPT_CERTFILE:\n            certfile = opt_arg();\n            break;\n        case OPT_CAFILE:\n            CAfile = opt_arg();\n            break;\n        case OPT_CAPATH:\n            CApath = opt_arg();\n            break;\n        case OPT_CASTORE:\n            CAstore = opt_arg();\n            break;\n        case OPT_NOCAFILE:\n            noCAfile = 1;\n            break;\n        case OPT_NOCAPATH:\n            noCApath = 1;\n            break;\n        case OPT_NOCASTORE:\n            noCAstore = 1;\n            break;\n        case OPT_CONTENT:\n            contfile = opt_arg();\n            break;\n        case OPT_V_CASES:\n            if (!opt_verify(o, vpm))\n                goto opthelp;\n            vpmtouched++;\n            break;\n        }\n    }\n\n    /* Extra arguments are files with recipient keys. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_RAND_load())\n        goto end;\n\n    if (digestname != NULL) {\n        if (!opt_md(digestname, &sign_md))\n            goto opthelp;\n    }\n    if (!opt_cipher_any(ciphername, &cipher))\n            goto opthelp;\n    if (!(operation & SMIME_SIGNERS) && (skkeys != NULL || sksigners != NULL)) {\n        BIO_puts(bio_err, \"Multiple signers or keys not allowed\\n\");\n        goto opthelp;\n    }\n    if (!operation) {\n        BIO_puts(bio_err,\n                \"No operation (-encrypt|-sign|...) specified\\n\");\n        goto opthelp;\n    }\n\n    if (operation & SMIME_SIGNERS) {\n        /* Check to see if any final signer needs to be appended */\n        if (keyfile && !signerfile) {\n            BIO_puts(bio_err, \"Illegal -inkey without -signer\\n\");\n            goto opthelp;\n        }\n        if (signerfile != NULL) {\n            if (sksigners == NULL\n                && (sksigners = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            sk_OPENSSL_STRING_push(sksigners, signerfile);\n            if (!skkeys && (skkeys = sk_OPENSSL_STRING_new_null()) == NULL)\n                goto end;\n            if (!keyfile)\n                keyfile = signerfile;\n            sk_OPENSSL_STRING_push(skkeys, keyfile);\n        }\n        if (sksigners == NULL) {\n            BIO_printf(bio_err, \"No signer certificate specified\\n\");\n            goto opthelp;\n        }\n        signerfile = NULL;\n        keyfile = NULL;\n    } else if (operation == SMIME_DECRYPT) {\n        if (recipfile == NULL && keyfile == NULL) {\n            BIO_printf(bio_err,\n                       \"No recipient certificate or key specified\\n\");\n            goto opthelp;\n        }\n    } else if (operation == SMIME_ENCRYPT) {\n        if (argc == 0) {\n            BIO_printf(bio_err, \"No recipient(s) certificate(s) specified\\n\");\n            goto opthelp;\n        }\n    }\n\n    if (!app_passwd(passinarg, NULL, &passin, NULL)) {\n        BIO_printf(bio_err, \"Error getting password\\n\");\n        goto end;\n    }\n\n    ret = 2;\n\n    if (!(operation & SMIME_SIGNERS))\n        flags &= ~PKCS7_DETACHED;\n\n    if (!(operation & SMIME_OP)) {\n        if (flags & PKCS7_BINARY)\n            outformat = FORMAT_BINARY;\n    }\n\n    if (!(operation & SMIME_IP)) {\n        if (flags & PKCS7_BINARY)\n            informat = FORMAT_BINARY;\n    }\n\n    if (operation == SMIME_ENCRYPT) {\n        if (cipher == NULL)\n            cipher = (EVP_CIPHER *)EVP_aes_256_cbc();\n        encerts = sk_X509_new_null();\n        if (encerts == NULL)\n            goto end;\n        while (*argv != NULL) {\n            cert = load_cert(*argv, FORMAT_UNDEF,\n                             \"recipient certificate file\");\n            if (cert == NULL)\n                goto end;\n            if (!sk_X509_push(encerts, cert))\n                goto end;\n            cert = NULL;\n            argv++;\n        }\n    }\n\n    if (certfile != NULL) {\n        if (!load_certs(certfile, 0, &other, NULL, \"certificates\")) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (recipfile != NULL && (operation == SMIME_DECRYPT)) {\n        if ((recip = load_cert(recipfile, FORMAT_UNDEF,\n                               \"recipient certificate file\")) == NULL) {\n            ERR_print_errors(bio_err);\n            goto end;\n        }\n    }\n\n    if (operation == SMIME_DECRYPT) {\n        if (keyfile == NULL)\n            keyfile = recipfile;\n    } else if (operation == SMIME_SIGN) {\n        if (keyfile == NULL)\n            keyfile = signerfile;\n    } else {\n        keyfile = NULL;\n    }\n\n    if (keyfile != NULL) {\n        key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n        if (key == NULL)\n            goto end;\n    }\n\n    in = bio_open_default(infile, 'r', informat);\n    if (in == NULL)\n        goto end;\n\n    if (operation & SMIME_IP) {\n        PKCS7 *p7_in = NULL;\n\n        p7 = PKCS7_new_ex(libctx, app_get0_propq());\n        if (p7 == NULL) {\n            BIO_printf(bio_err, \"Error allocating PKCS7 object\\n\");\n            goto end;\n        }\n        if (informat == FORMAT_SMIME) {\n            p7_in = SMIME_read_PKCS7_ex(in, &indata, &p7);\n        } else if (informat == FORMAT_PEM) {\n            p7_in = PEM_read_bio_PKCS7(in, &p7, NULL, NULL);\n        } else if (informat == FORMAT_ASN1) {\n            p7_in = d2i_PKCS7_bio(in, &p7);\n        } else {\n            BIO_printf(bio_err, \"Bad input format for PKCS#7 file\\n\");\n            goto end;\n        }\n\n        if (p7_in == NULL) {\n            BIO_printf(bio_err, \"Error reading S/MIME message\\n\");\n            goto end;\n        }\n        if (contfile != NULL) {\n            BIO_free(indata);\n            if ((indata = BIO_new_file(contfile, \"rb\")) == NULL) {\n                BIO_printf(bio_err, \"Can't read content file %s\\n\", contfile);\n                goto end;\n            }\n        }\n    }\n\n    out = bio_open_default(outfile, 'w', outformat);\n    if (out == NULL)\n        goto end;\n\n    if (operation == SMIME_VERIFY) {\n        if ((store = setup_verify(CAfile, noCAfile, CApath, noCApath,\n                                  CAstore, noCAstore)) == NULL)\n            goto end;\n        X509_STORE_set_verify_cb(store, smime_cb);\n        if (vpmtouched)\n            X509_STORE_set1_param(store, vpm);\n    }\n\n    ret = 3;\n\n    if (operation == SMIME_ENCRYPT) {\n        if (indef)\n            flags |= PKCS7_STREAM;\n        p7 = PKCS7_encrypt_ex(encerts, in, cipher, flags, libctx, app_get0_propq());\n    } else if (operation & SMIME_SIGNERS) {\n        int i;\n        /*\n         * If detached data content we only enable streaming if S/MIME output\n         * format.\n         */\n        if (operation == SMIME_SIGN) {\n            if (flags & PKCS7_DETACHED) {\n                if (outformat == FORMAT_SMIME)\n                    flags |= PKCS7_STREAM;\n            } else if (indef) {\n                flags |= PKCS7_STREAM;\n            }\n            flags |= PKCS7_PARTIAL;\n            p7 = PKCS7_sign_ex(NULL, NULL, other, in, flags, libctx, app_get0_propq());\n            if (p7 == NULL)\n                goto end;\n            if (flags & PKCS7_NOCERTS) {\n                for (i = 0; i < sk_X509_num(other); i++) {\n                    X509 *x = sk_X509_value(other, i);\n                    PKCS7_add_certificate(p7, x);\n                }\n            }\n        } else {\n            flags |= PKCS7_REUSE_DIGEST;\n        }\n        for (i = 0; i < sk_OPENSSL_STRING_num(sksigners); i++) {\n            signerfile = sk_OPENSSL_STRING_value(sksigners, i);\n            keyfile = sk_OPENSSL_STRING_value(skkeys, i);\n            signer = load_cert(signerfile, FORMAT_UNDEF, \"signer certificate\");\n            if (signer == NULL)\n                goto end;\n            key = load_key(keyfile, keyform, 0, passin, e, \"signing key\");\n            if (key == NULL)\n                goto end;\n\n            if (!PKCS7_sign_add_signer(p7, signer, key, sign_md, flags))\n                goto end;\n            X509_free(signer);\n            signer = NULL;\n            EVP_PKEY_free(key);\n            key = NULL;\n        }\n        /* If not streaming or resigning finalize structure */\n        if ((operation == SMIME_SIGN) && !(flags & PKCS7_STREAM)) {\n            if (!PKCS7_final(p7, in, flags))\n                goto end;\n        }\n    }\n\n    if (p7 == NULL) {\n        BIO_printf(bio_err, \"Error creating PKCS#7 structure\\n\");\n        goto end;\n    }\n\n    ret = 4;\n    if (operation == SMIME_DECRYPT) {\n        if (!PKCS7_decrypt(p7, key, recip, out, flags)) {\n            BIO_printf(bio_err, \"Error decrypting PKCS#7 structure\\n\");\n            goto end;\n        }\n    } else if (operation == SMIME_VERIFY) {\n        STACK_OF(X509) *signers;\n        if (PKCS7_verify(p7, other, store, indata, out, flags))\n            BIO_printf(bio_err, \"Verification successful\\n\");\n        else {\n            BIO_printf(bio_err, \"Verification failure\\n\");\n            goto end;\n        }\n        signers = PKCS7_get0_signers(p7, other, flags);\n        if (!save_certs(signerfile, signers)) {\n            BIO_printf(bio_err, \"Error writing signers to %s\\n\", signerfile);\n            ret = 5;\n            goto end;\n        }\n        sk_X509_free(signers);\n    } else if (operation == SMIME_PK7OUT) {\n        PEM_write_bio_PKCS7(out, p7);\n    } else {\n        if (to)\n            BIO_printf(out, \"To: %s%s\", to, mime_eol);\n        if (from)\n            BIO_printf(out, \"From: %s%s\", from, mime_eol);\n        if (subject)\n            BIO_printf(out, \"Subject: %s%s\", subject, mime_eol);\n        if (outformat == FORMAT_SMIME) {\n            if (operation == SMIME_RESIGN)\n                rv = SMIME_write_PKCS7(out, p7, indata, flags);\n            else\n                rv = SMIME_write_PKCS7(out, p7, in, flags);\n        } else if (outformat == FORMAT_PEM) {\n            rv = PEM_write_bio_PKCS7_stream(out, p7, in, flags);\n        } else if (outformat == FORMAT_ASN1) {\n            rv = i2d_PKCS7_bio_stream(out, p7, in, flags);\n        } else {\n            BIO_printf(bio_err, \"Bad output format for PKCS#7 file\\n\");\n            goto end;\n        }\n        if (rv == 0) {\n            BIO_printf(bio_err, \"Error writing output\\n\");\n            ret = 3;\n            goto end;\n        }\n    }\n    ret = 0;\n end:\n    if (ret)\n        ERR_print_errors(bio_err);\n    OSSL_STACK_OF_X509_free(encerts);\n    OSSL_STACK_OF_X509_free(other);\n    X509_VERIFY_PARAM_free(vpm);\n    sk_OPENSSL_STRING_free(sksigners);\n    sk_OPENSSL_STRING_free(skkeys);\n    X509_STORE_free(store);\n    X509_free(cert);\n    X509_free(recip);\n    X509_free(signer);\n    EVP_PKEY_free(key);\n    EVP_MD_free(sign_md);\n    EVP_CIPHER_free(cipher);\n    PKCS7_free(p7);\n    release_engine(e);\n    BIO_free(in);\n    BIO_free(indata);\n    BIO_free_all(out);\n    OPENSSL_free(passin);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "if (!PKCS7_sign_add_signer(p7, signer, key, sign_md, flags))",
        "final_sink": "if (!PKCS7_sign_add_signer(p7, signer, key, sign_md, flags))",
        "source": [
            "    retdb = app_malloc(sizeof(*retdb), \"new DB\");"
        ],
        "index": 47
    },
    {
        "prt": "loopargs",
        "function_call": [
            "int speed_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ENGINE *e = NULL;\n    loopargs_t *loopargs = NULL;\n    const char *prog;\n    const char *engine_id = NULL;\n    EVP_CIPHER *evp_cipher = NULL;\n    EVP_MAC *mac = NULL;\n    double d = 0.0;\n    OPTION_CHOICE o;\n    int async_init = 0, multiblock = 0, pr_header = 0;\n    uint8_t doit[ALGOR_NUM] = { 0 };\n    int ret = 1, misalign = 0, lengths_single = 0;\n    STACK_OF(EVP_KEM) *kem_stack = NULL;\n    STACK_OF(EVP_SIGNATURE) *sig_stack = NULL;\n    long count = 0;\n    unsigned int size_num = SIZE_NUM;\n    unsigned int i, k, loopargs_len = 0, async_jobs = 0;\n    unsigned int idx;\n    int keylen = 0;\n    int buflen;\n    size_t declen;\n    BIGNUM *bn = NULL;\n    EVP_PKEY_CTX *genctx = NULL;\n#ifndef NO_FORK\n    int multi = 0;\n#endif\n    long op_count = 1;\n    openssl_speed_sec_t seconds = { SECONDS, RSA_SECONDS, DSA_SECONDS,\n                                    ECDSA_SECONDS, ECDH_SECONDS,\n                                    EdDSA_SECONDS, SM2_SECONDS,\n                                    FFDH_SECONDS, KEM_SECONDS,\n                                    SIG_SECONDS };\n\n    static const unsigned char key32[32] = {\n        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,\n        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,\n        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,\n        0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56\n    };\n    static const unsigned char deskey[] = {\n        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, /* key1 */\n        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, /* key2 */\n        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34  /* key3 */\n    };\n    static const struct {\n        const unsigned char *data;\n        unsigned int length;\n        unsigned int bits;\n    } rsa_keys[] = {\n        {   test512,   sizeof(test512),   512 },\n        {  test1024,  sizeof(test1024),  1024 },\n        {  test2048,  sizeof(test2048),  2048 },\n        {  test3072,  sizeof(test3072),  3072 },\n        {  test4096,  sizeof(test4096),  4096 },\n        {  test7680,  sizeof(test7680),  7680 },\n        { test15360, sizeof(test15360), 15360 }\n    };\n    uint8_t rsa_doit[RSA_NUM] = { 0 };\n    int primes = RSA_DEFAULT_PRIME_NUM;\n#ifndef OPENSSL_NO_DH\n    typedef struct ffdh_params_st {\n        const char *name;\n        unsigned int nid;\n        unsigned int bits;\n    } FFDH_PARAMS;\n\n    static const FFDH_PARAMS ffdh_params[FFDH_NUM] = {\n        {\"ffdh2048\", NID_ffdhe2048, 2048},\n        {\"ffdh3072\", NID_ffdhe3072, 3072},\n        {\"ffdh4096\", NID_ffdhe4096, 4096},\n        {\"ffdh6144\", NID_ffdhe6144, 6144},\n        {\"ffdh8192\", NID_ffdhe8192, 8192}\n    };\n    uint8_t ffdh_doit[FFDH_NUM] = { 0 };\n\n#endif /* OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_DSA\n    static const unsigned int dsa_bits[DSA_NUM] = { 1024, 2048 };\n    uint8_t dsa_doit[DSA_NUM] = { 0 };\n#endif /* OPENSSL_NO_DSA */\n    /*\n     * We only test over the following curves as they are representative, To\n     * add tests over more curves, simply add the curve NID and curve name to\n     * the following arrays and increase the |ecdh_choices| and |ecdsa_choices|\n     * lists accordingly.\n     */\n    static const EC_CURVE ec_curves[EC_NUM] = {\n        /* Prime Curves */\n        {\"secp160r1\", NID_secp160r1, 160},\n        {\"nistp192\", NID_X9_62_prime192v1, 192},\n        {\"nistp224\", NID_secp224r1, 224},\n        {\"nistp256\", NID_X9_62_prime256v1, 256},\n        {\"nistp384\", NID_secp384r1, 384},\n        {\"nistp521\", NID_secp521r1, 521},\n#ifndef OPENSSL_NO_EC2M\n        /* Binary Curves */\n        {\"nistk163\", NID_sect163k1, 163},\n        {\"nistk233\", NID_sect233k1, 233},\n        {\"nistk283\", NID_sect283k1, 283},\n        {\"nistk409\", NID_sect409k1, 409},\n        {\"nistk571\", NID_sect571k1, 571},\n        {\"nistb163\", NID_sect163r2, 163},\n        {\"nistb233\", NID_sect233r1, 233},\n        {\"nistb283\", NID_sect283r1, 283},\n        {\"nistb409\", NID_sect409r1, 409},\n        {\"nistb571\", NID_sect571r1, 571},\n#endif\n        {\"brainpoolP256r1\", NID_brainpoolP256r1, 256},\n        {\"brainpoolP256t1\", NID_brainpoolP256t1, 256},\n        {\"brainpoolP384r1\", NID_brainpoolP384r1, 384},\n        {\"brainpoolP384t1\", NID_brainpoolP384t1, 384},\n        {\"brainpoolP512r1\", NID_brainpoolP512r1, 512},\n        {\"brainpoolP512t1\", NID_brainpoolP512t1, 512},\n#ifndef OPENSSL_NO_ECX\n        /* Other and ECDH only ones */\n        {\"X25519\", NID_X25519, 253},\n        {\"X448\", NID_X448, 448}\n#endif\n    };\n#ifndef OPENSSL_NO_ECX\n    static const EC_CURVE ed_curves[EdDSA_NUM] = {\n        /* EdDSA */\n        {\"Ed25519\", NID_ED25519, 253, 64},\n        {\"Ed448\", NID_ED448, 456, 114}\n    };\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n    static const EC_CURVE sm2_curves[SM2_NUM] = {\n        /* SM2 */\n        {\"CurveSM2\", NID_sm2, 256}\n    };\n    uint8_t sm2_doit[SM2_NUM] = { 0 };\n#endif\n    uint8_t ecdsa_doit[ECDSA_NUM] = { 0 };\n    uint8_t ecdh_doit[EC_NUM] = { 0 };\n#ifndef OPENSSL_NO_ECX\n    uint8_t eddsa_doit[EdDSA_NUM] = { 0 };\n#endif /* OPENSSL_NO_ECX */\n\n    uint8_t kems_doit[MAX_KEM_NUM] = { 0 };\n    uint8_t sigs_doit[MAX_SIG_NUM] = { 0 };\n\n    uint8_t do_kems = 0;\n    uint8_t do_sigs = 0;\n\n    /* checks declared curves against choices list. */\n#ifndef OPENSSL_NO_ECX\n    OPENSSL_assert(ed_curves[EdDSA_NUM - 1].nid == NID_ED448);\n    OPENSSL_assert(strcmp(eddsa_choices[EdDSA_NUM - 1].name, \"ed448\") == 0);\n\n    OPENSSL_assert(ec_curves[EC_NUM - 1].nid == NID_X448);\n    OPENSSL_assert(strcmp(ecdh_choices[EC_NUM - 1].name, \"ecdhx448\") == 0);\n\n    OPENSSL_assert(ec_curves[ECDSA_NUM - 1].nid == NID_brainpoolP512t1);\n    OPENSSL_assert(strcmp(ecdsa_choices[ECDSA_NUM - 1].name, \"ecdsabrp512t1\") == 0);\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    OPENSSL_assert(sm2_curves[SM2_NUM - 1].nid == NID_sm2);\n    OPENSSL_assert(strcmp(sm2_choices[SM2_NUM - 1].name, \"curveSM2\") == 0);\n#endif\n\n    prog = opt_init(argc, argv, speed_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opterr:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(speed_options);\n            ret = 0;\n            goto end;\n        case OPT_ELAPSED:\n            usertime = 0;\n            break;\n        case OPT_EVP:\n            if (doit[D_EVP]) {\n                BIO_printf(bio_err, \"%s: -evp option cannot be used more than once\\n\", prog);\n                goto opterr;\n            }\n            ERR_set_mark();\n            if (!opt_cipher_silent(opt_arg(), &evp_cipher)) {\n                if (have_md(opt_arg()))\n                    evp_md_name = opt_arg();\n            }\n            if (evp_cipher == NULL && evp_md_name == NULL) {\n                ERR_clear_last_mark();\n                BIO_printf(bio_err,\n                           \"%s: %s is an unknown cipher or digest\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            ERR_pop_to_mark();\n            doit[D_EVP] = 1;\n            break;\n        case OPT_HMAC:\n            if (!have_md(opt_arg())) {\n                BIO_printf(bio_err, \"%s: %s is an unknown digest\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            evp_mac_mdname = opt_arg();\n            doit[D_HMAC] = 1;\n            break;\n        case OPT_CMAC:\n            if (!have_cipher(opt_arg())) {\n                BIO_printf(bio_err, \"%s: %s is an unknown cipher\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            evp_mac_ciphername = opt_arg();\n            doit[D_EVP_CMAC] = 1;\n            break;\n        case OPT_DECRYPT:\n            decrypt = 1;\n            break;\n        case OPT_ENGINE:\n            /*\n             * In a forked execution, an engine might need to be\n             * initialised by each child process, not by the parent.\n             * So store the name here and run setup_engine() later on.\n             */\n            engine_id = opt_arg();\n            break;\n        case OPT_MULTI:\n#ifndef NO_FORK\n            multi = opt_int_arg();\n            if ((size_t)multi >= SIZE_MAX / sizeof(int)) {\n                BIO_printf(bio_err, \"%s: multi argument too large\\n\", prog);\n                return 0;\n            }\n#endif\n            break;\n        case OPT_ASYNCJOBS:\n#ifndef OPENSSL_NO_ASYNC\n            async_jobs = opt_int_arg();\n            if (async_jobs > 99999) {\n                BIO_printf(bio_err, \"%s: too many async_jobs\\n\", prog);\n                goto opterr;\n            }\n            if (!ASYNC_is_capable()) {\n                BIO_printf(bio_err,\n                           \"%s: async_jobs specified but async not supported\\n\",\n                           prog);\n                if (testmode)\n                    /* Return success in the testmode. */\n                    return 0;\n                goto opterr;\n            }\n#endif\n            break;\n        case OPT_MISALIGN:\n            misalign = opt_int_arg();\n            if (misalign > MISALIGN) {\n                BIO_printf(bio_err,\n                           \"%s: Maximum offset is %d\\n\", prog, MISALIGN);\n                goto opterr;\n            }\n            break;\n        case OPT_MR:\n            mr = 1;\n            break;\n        case OPT_MB:\n            multiblock = 1;\n#ifdef OPENSSL_NO_MULTIBLOCK\n            BIO_printf(bio_err,\n                       \"%s: -mb specified but multi-block support is disabled\\n\",\n                       prog);\n            goto end;\n#endif\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_PRIMES:\n            primes = opt_int_arg();\n            break;\n        case OPT_SECONDS:\n            seconds.sym = seconds.rsa = seconds.dsa = seconds.ecdsa\n                        = seconds.ecdh = seconds.eddsa\n                        = seconds.sm2 = seconds.ffdh\n                        = seconds.kem = seconds.sig = opt_int_arg();\n            break;\n        case OPT_BYTES:\n            lengths_single = opt_int_arg();\n            lengths = &lengths_single;\n            size_num = 1;\n            break;\n        case OPT_AEAD:\n            aead = 1;\n            break;\n        case OPT_KEM:\n            do_kems = 1;\n            break;\n        case OPT_SIG:\n            do_sigs = 1;\n            break;\n        case OPT_MLOCK:\n            domlock = 1;\n#if !defined(_WIN32) && !defined(OPENSSL_SYS_LINUX)\n            BIO_printf(bio_err,\n                       \"%s: -mlock not supported on this platform\\n\",\n                       prog);\n            goto end;\n#endif\n            break;\n        case OPT_TESTMODE:\n            testmode = 1;\n            break;\n        }\n    }\n\n    /* find all KEMs currently available */\n    kem_stack = sk_EVP_KEM_new(kems_cmp);\n    EVP_KEM_do_all_provided(app_get0_libctx(), collect_kem, kem_stack);\n\n    kems_algs_len = 0;\n\n    for (idx = 0; idx < (unsigned int)sk_EVP_KEM_num(kem_stack); idx++) {\n        EVP_KEM *kem = sk_EVP_KEM_value(kem_stack, idx);\n\n        if (strcmp(EVP_KEM_get0_name(kem), \"RSA\") == 0) {\n            if (kems_algs_len + OSSL_NELEM(rsa_choices) >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < OSSL_NELEM(rsa_choices); i++) {\n                kems_doit[kems_algs_len] = 1;\n                kems_algname[kems_algs_len++] = OPENSSL_strdup(rsa_choices[i].name);\n            }\n        } else if (strcmp(EVP_KEM_get0_name(kem), \"EC\") == 0) {\n            if (kems_algs_len + 3 >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-256\");\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-384\");\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-521\");\n        } else {\n            if (kems_algs_len + 1 >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(EVP_KEM_get0_name(kem));\n        }\n    }\n    sk_EVP_KEM_pop_free(kem_stack, EVP_KEM_free);\n    kem_stack = NULL;\n\n    /* find all SIGNATUREs currently available */\n    sig_stack = sk_EVP_SIGNATURE_new(signatures_cmp);\n    EVP_SIGNATURE_do_all_provided(app_get0_libctx(), collect_signatures, sig_stack);\n\n    sigs_algs_len = 0;\n\n    for (idx = 0; idx < (unsigned int)sk_EVP_SIGNATURE_num(sig_stack); idx++) {\n        EVP_SIGNATURE *s = sk_EVP_SIGNATURE_value(sig_stack, idx);\n        const char *sig_name = EVP_SIGNATURE_get0_name(s);\n\n        if (strcmp(sig_name, \"RSA\") == 0) {\n            if (sigs_algs_len + OSSL_NELEM(rsa_choices) >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < OSSL_NELEM(rsa_choices); i++) {\n                sigs_doit[sigs_algs_len] = 1;\n                sigs_algname[sigs_algs_len++] = OPENSSL_strdup(rsa_choices[i].name);\n            }\n        }\n#ifndef OPENSSL_NO_DSA\n        else if (strcmp(sig_name, \"DSA\") == 0) {\n            if (sigs_algs_len + DSA_NUM >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < DSA_NUM; i++) {\n                sigs_doit[sigs_algs_len] = 1;\n                sigs_algname[sigs_algs_len++] = OPENSSL_strdup(dsa_choices[i].name);\n            }\n        }\n#endif /* OPENSSL_NO_DSA */\n        /* skipping these algs as tested elsewhere - and b/o setup is a pain */\n        else if (strcmp(sig_name, \"ED25519\") &&\n                 strcmp(sig_name, \"ED448\") &&\n                 strcmp(sig_name, \"ECDSA\") &&\n                 strcmp(sig_name, \"HMAC\") &&\n                 strcmp(sig_name, \"SIPHASH\") &&\n                 strcmp(sig_name, \"POLY1305\") &&\n                 strcmp(sig_name, \"CMAC\") &&\n                 strcmp(sig_name, \"SM2\")) { /* skip alg */\n            if (sigs_algs_len + 1 >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            /* activate this provider algorithm */\n            sigs_doit[sigs_algs_len] = 1;\n            sigs_algname[sigs_algs_len++] = OPENSSL_strdup(sig_name);\n        }\n    }\n    sk_EVP_SIGNATURE_pop_free(sig_stack, EVP_SIGNATURE_free);\n    sig_stack = NULL;\n\n    /* Remaining arguments are algorithms. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_RAND_load())\n        goto end;\n\n    for (; *argv; argv++) {\n        const char *algo = *argv;\n        int algo_found = 0;\n\n        if (opt_found(algo, doit_choices, &i)) {\n            doit[i] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"des\") == 0) {\n            doit[D_CBC_DES] = doit[D_EDE3_DES] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"sha\") == 0) {\n            doit[D_SHA1] = doit[D_SHA256] = doit[D_SHA512] = 1;\n            algo_found = 1;\n        }\n#ifndef OPENSSL_NO_DEPRECATED_3_0\n        if (strcmp(algo, \"openssl\") == 0) /* just for compatibility */\n            algo_found = 1;\n#endif\n        if (HAS_PREFIX(algo, \"rsa\")) {\n            if (algo[sizeof(\"rsa\") - 1] == '\\0') {\n                memset(rsa_doit, 1, sizeof(rsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, rsa_choices, &i)) {\n                rsa_doit[i] = 1;\n                algo_found = 1;\n            }\n        }\n#ifndef OPENSSL_NO_DH\n        if (HAS_PREFIX(algo, \"ffdh\")) {\n            if (algo[sizeof(\"ffdh\") - 1] == '\\0') {\n                memset(ffdh_doit, 1, sizeof(ffdh_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ffdh_choices, &i)) {\n                ffdh_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_DSA\n        if (HAS_PREFIX(algo, \"dsa\")) {\n            if (algo[sizeof(\"dsa\") - 1] == '\\0') {\n                memset(dsa_doit, 1, sizeof(dsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, dsa_choices, &i)) {\n                dsa_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#endif\n        if (strcmp(algo, \"aes\") == 0) {\n            doit[D_CBC_128_AES] = doit[D_CBC_192_AES] = doit[D_CBC_256_AES] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"camellia\") == 0) {\n            doit[D_CBC_128_CML] = doit[D_CBC_192_CML] = doit[D_CBC_256_CML] = 1;\n            algo_found = 1;\n        }\n        if (HAS_PREFIX(algo, \"ecdsa\")) {\n            if (algo[sizeof(\"ecdsa\") - 1] == '\\0') {\n                memset(ecdsa_doit, 1, sizeof(ecdsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ecdsa_choices, &i)) {\n                ecdsa_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n        if (HAS_PREFIX(algo, \"ecdh\")) {\n            if (algo[sizeof(\"ecdh\") - 1] == '\\0') {\n                memset(ecdh_doit, 1, sizeof(ecdh_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ecdh_choices, &i)) {\n                ecdh_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#ifndef OPENSSL_NO_ECX\n        if (strcmp(algo, \"eddsa\") == 0) {\n            memset(eddsa_doit, 1, sizeof(eddsa_doit));\n            algo_found = 1;\n        }\n        if (opt_found(algo, eddsa_choices, &i)) {\n            eddsa_doit[i] = 2;\n            algo_found = 1;\n        }\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        if (strcmp(algo, \"sm2\") == 0) {\n            memset(sm2_doit, 1, sizeof(sm2_doit));\n            algo_found = 1;\n        }\n        if (opt_found(algo, sm2_choices, &i)) {\n            sm2_doit[i] = 2;\n            algo_found = 1;\n        }\n#endif\n        if (kem_locate(algo, &idx)) {\n            kems_doit[idx]++;\n            do_kems = 1;\n            algo_found = 1;\n        }\n        if (sig_locate(algo, &idx)) {\n            sigs_doit[idx]++;\n            do_sigs = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"kmac\") == 0) {\n            doit[D_KMAC128] = doit[D_KMAC256] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"cmac\") == 0) {\n            doit[D_EVP_CMAC] = 1;\n            algo_found = 1;\n        }\n\n        if (!algo_found) {\n            BIO_printf(bio_err, \"%s: Unknown algorithm %s\\n\", prog, algo);\n            goto end;\n        }\n    }\n\n    /* Sanity checks */\n    if (aead) {\n        if (evp_cipher == NULL) {\n            BIO_printf(bio_err, \"-aead can be used only with an AEAD cipher\\n\");\n            goto end;\n        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &\n                     EVP_CIPH_FLAG_AEAD_CIPHER)) {\n            BIO_printf(bio_err, \"%s is not an AEAD cipher\\n\",\n                       EVP_CIPHER_get0_name(evp_cipher));\n            goto end;\n        }\n    }\n    if (kems_algs_len > 0) {\n        int maxcnt = get_max(kems_doit, kems_algs_len);\n\n        if (maxcnt > 1) {\n            /* some algs explicitly selected */\n            for (i = 0; i < kems_algs_len; i++) {\n                /* disable the rest */\n                kems_doit[i]--;\n            }\n        }\n    }\n    if (sigs_algs_len > 0) {\n        int maxcnt = get_max(sigs_doit, sigs_algs_len);\n\n        if (maxcnt > 1) {\n            /* some algs explicitly selected */\n            for (i = 0; i < sigs_algs_len; i++) {\n                /* disable the rest */\n                sigs_doit[i]--;\n            }\n        }\n    }\n    if (multiblock) {\n        if (evp_cipher == NULL) {\n            BIO_printf(bio_err, \"-mb can be used only with a multi-block\"\n                                \" capable cipher\\n\");\n            goto end;\n        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &\n                     EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {\n            BIO_printf(bio_err, \"%s is not a multi-block capable\\n\",\n                       EVP_CIPHER_get0_name(evp_cipher));\n            goto end;\n        } else if (async_jobs > 0) {\n            BIO_printf(bio_err, \"Async mode is not supported with -mb\");\n            goto end;\n        }\n    }\n\n    /* Initialize the job pool if async mode is enabled */\n    if (async_jobs > 0) {\n        async_init = ASYNC_init_thread(async_jobs, async_jobs);\n        if (!async_init) {\n            BIO_printf(bio_err, \"Error creating the ASYNC job pool\\n\");\n            goto end;\n        }\n    }\n\n    loopargs_len = (async_jobs == 0 ? 1 : async_jobs);\n    loopargs =\n        app_malloc(loopargs_len * sizeof(loopargs_t), \"array of loopargs\");\n    memset(loopargs, 0, loopargs_len * sizeof(loopargs_t));\n\n    buflen = lengths[size_num - 1];\n    if (buflen < 36)    /* size of random vector in RSA benchmark */\n        buflen = 36;\n    if (INT_MAX - (MAX_MISALIGNMENT + 1) < buflen) {\n        BIO_printf(bio_err, \"Error: buffer size too large\\n\");\n        goto end;\n    }\n    buflen += MAX_MISALIGNMENT + 1;\n    for (i = 0; i < loopargs_len; i++) {\n        if (async_jobs > 0) {\n            loopargs[i].wait_ctx = ASYNC_WAIT_CTX_new();\n            if (loopargs[i].wait_ctx == NULL) {\n                BIO_printf(bio_err, \"Error creating the ASYNC_WAIT_CTX\\n\");\n                goto end;\n            }\n        }\n\n        loopargs[i].buf_malloc = app_malloc(buflen, \"input buffer\");\n        loopargs[i].buf2_malloc = app_malloc(buflen, \"input buffer\");\n\n        /* Align the start of buffers on a 64 byte boundary */\n        loopargs[i].buf = loopargs[i].buf_malloc + misalign;\n        loopargs[i].buf2 = loopargs[i].buf2_malloc + misalign;\n        loopargs[i].buflen = buflen - misalign;\n        loopargs[i].sigsize = buflen - misalign;\n        loopargs[i].secret_a = app_malloc(MAX_ECDH_SIZE, \"ECDH secret a\");\n        loopargs[i].secret_b = app_malloc(MAX_ECDH_SIZE, \"ECDH secret b\");\n#ifndef OPENSSL_NO_DH\n        loopargs[i].secret_ff_a = app_malloc(MAX_FFDH_SIZE, \"FFDH secret a\");\n        loopargs[i].secret_ff_b = app_malloc(MAX_FFDH_SIZE, \"FFDH secret b\");\n#endif\n    }\n\n#ifndef NO_FORK\n    if (multi && do_multi(multi, size_num))\n        goto show_res;\n#endif\n\n    for (i = 0; i < loopargs_len; ++i) {\n        if (domlock) {\n#if defined(_WIN32)\n            (void)VirtualLock(loopargs[i].buf_malloc, buflen);\n            (void)VirtualLock(loopargs[i].buf2_malloc, buflen);\n#elif defined(OPENSSL_SYS_LINUX)\n            (void)mlock(loopargs[i].buf_malloc, buflen);\n            (void)mlock(loopargs[i].buf_malloc, buflen);\n#endif\n        }\n        memset(loopargs[i].buf_malloc, 0, buflen);\n        memset(loopargs[i].buf2_malloc, 0, buflen);\n    }\n\n    /* Initialize the engine after the fork */\n    e = setup_engine(engine_id, 0);\n\n    /* No parameters; turn on everything. */\n    if (argc == 0 && !doit[D_EVP] && !doit[D_HMAC]\n        && !doit[D_EVP_CMAC] && !do_kems && !do_sigs) {\n        memset(doit, 1, sizeof(doit));\n        doit[D_EVP] = doit[D_EVP_CMAC] = 0;\n        ERR_set_mark();\n        for (i = D_MD2; i <= D_WHIRLPOOL; i++) {\n            if (!have_md(names[i]))\n                doit[i] = 0;\n        }\n        for (i = D_CBC_DES; i <= D_CBC_256_CML; i++) {\n            if (!have_cipher(names[i]))\n                doit[i] = 0;\n        }\n        if ((mac = EVP_MAC_fetch(app_get0_libctx(), \"GMAC\",\n                                 app_get0_propq())) != NULL) {\n            EVP_MAC_free(mac);\n            mac = NULL;\n        } else {\n            doit[D_GHASH] = 0;\n        }\n        if ((mac = EVP_MAC_fetch(app_get0_libctx(), \"HMAC\",\n                                 app_get0_propq())) != NULL) {\n            EVP_MAC_free(mac);\n            mac = NULL;\n        } else {\n            doit[D_HMAC] = 0;\n        }\n        ERR_pop_to_mark();\n        memset(rsa_doit, 1, sizeof(rsa_doit));\n#ifndef OPENSSL_NO_DH\n        memset(ffdh_doit, 1, sizeof(ffdh_doit));\n#endif\n#ifndef OPENSSL_NO_DSA\n        memset(dsa_doit, 1, sizeof(dsa_doit));\n#endif\n#ifndef OPENSSL_NO_ECX\n        memset(ecdsa_doit, 1, sizeof(ecdsa_doit));\n        memset(ecdh_doit, 1, sizeof(ecdh_doit));\n        memset(eddsa_doit, 1, sizeof(eddsa_doit));\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        memset(sm2_doit, 1, sizeof(sm2_doit));\n#endif\n        memset(kems_doit, 1, sizeof(kems_doit));\n        do_kems = 1;\n        memset(sigs_doit, 1, sizeof(sigs_doit));\n        do_sigs = 1;\n    }\n    for (i = 0; i < ALGOR_NUM; i++)\n        if (doit[i])\n            pr_header++;\n\n    if (usertime == 0 && !mr)\n        BIO_printf(bio_err,\n                   \"You have chosen to measure elapsed time \"\n                   \"instead of user CPU time.\\n\");\n\n#if SIGALRM > 0\n    signal(SIGALRM, alarmed);\n#endif\n\n    if (doit[D_MD2]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD2], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MD2_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD2, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MDC2]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MDC2], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MDC2_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MDC2, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MD4]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD4], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MD4_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD4, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MD5]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD5], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, MD5_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD5, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA1]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA1], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA1_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA1, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA256]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA256], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA256_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA256, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA512]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA512], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA512_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA512, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_WHIRLPOOL]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_WHIRLPOOL], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, WHIRLPOOL_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_WHIRLPOOL, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_RMD160]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_RMD160], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_RMD160_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_RMD160, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_HMAC]) {\n        static const char hmac_key[] = \"This is a key...\";\n        int len = strlen(hmac_key);\n        size_t hmac_name_len = sizeof(\"hmac()\") + strlen(evp_mac_mdname);\n        OSSL_PARAM params[3];\n\n        if (evp_mac_mdname == NULL)\n            goto end;\n        evp_hmac_name = app_malloc(hmac_name_len, \"HMAC name\");\n        BIO_snprintf(evp_hmac_name, hmac_name_len, \"hmac(%s)\", evp_mac_mdname);\n        names[D_HMAC] = evp_hmac_name;\n\n        params[0] =\n            OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                             evp_mac_mdname, 0);\n        params[1] =\n            OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                              (char *)hmac_key, len);\n        params[2] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"HMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_HMAC], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, HMAC_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_HMAC, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_CBC_DES]) {\n        int st = 1;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ctx = init_evp_cipher_ctx(\"des-cbc\", deskey,\n                                                  sizeof(deskey) / 3);\n            st = loopargs[i].ctx != NULL;\n        }\n        algindex = D_CBC_DES;\n        for (testnum = 0; st && testnum < size_num; testnum++) {\n            if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                break;\n            print_message(names[D_CBC_DES], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_CBC_DES, testnum, count, d);\n        }\n        for (i = 0; i < loopargs_len; i++)\n            EVP_CIPHER_CTX_free(loopargs[i].ctx);\n    }\n\n    if (doit[D_EDE3_DES]) {\n        int st = 1;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ctx = init_evp_cipher_ctx(\"des-ede3-cbc\", deskey,\n                                                  sizeof(deskey));\n            st = loopargs[i].ctx != NULL;\n        }\n        algindex = D_EDE3_DES;\n        for (testnum = 0; st && testnum < size_num; testnum++) {\n            if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                break;\n            print_message(names[D_EDE3_DES], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_EDE3_DES, testnum, count, d);\n        }\n        for (i = 0; i < loopargs_len; i++)\n            EVP_CIPHER_CTX_free(loopargs[i].ctx);\n    }\n\n    for (k = 0; k < 3; k++) {\n        algindex = D_CBC_128_AES + k;\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16 + k * 8;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n\n    for (k = 0; k < 3; k++) {\n        algindex = D_CBC_128_CML + k;\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16 + k * 8;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n\n    for (algindex = D_RC4; algindex <= D_CBC_CAST; algindex++) {\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n    if (doit[D_GHASH]) {\n        static const char gmac_iv[] = \"0123456789ab\";\n        OSSL_PARAM params[4];\n\n        params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_CIPHER,\n                                                     \"aes-128-gcm\", 0);\n        params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_IV,\n                                                      (char *)gmac_iv,\n                                                      sizeof(gmac_iv) - 1);\n        params[2] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 16);\n        params[3] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"GMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        /* b/c of the definition of GHASH_loop(), init() calls are needed here */\n        for (i = 0; i < loopargs_len; i++) {\n            if (!EVP_MAC_init(loopargs[i].mctx, NULL, 0, NULL))\n                goto end;\n        }\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_GHASH], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, GHASH_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_GHASH, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_RAND]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_RAND], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, RAND_bytes_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_RAND, testnum, count, d);\n        }\n    }\n\n    /*-\n     * There are three scenarios for D_EVP:\n     * 1- Using authenticated encryption (AE) e.g. CCM, GCM, OCB etc.\n     * 2- Using AE + associated data (AD) i.e. AEAD using CCM, GCM, OCB etc.\n     * 3- Not using AE or AD e.g. ECB, CBC, CFB etc.\n     */\n    if (doit[D_EVP]) {\n        if (evp_cipher != NULL) {\n            int (*loopfunc) (void *);\n            int outlen = 0;\n            unsigned int ae_mode = 0;\n\n            if (multiblock && (EVP_CIPHER_get_flags(evp_cipher)\n                               & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {\n                multiblock_speed(evp_cipher, lengths_single, &seconds);\n                ret = 0;\n                goto end;\n            }\n\n            names[D_EVP] = EVP_CIPHER_get0_name(evp_cipher);\n\n            mode_op = EVP_CIPHER_get_mode(evp_cipher);\n\n            if (aead) {\n                if (lengths == lengths_list) {\n                    lengths = aead_lengths_list;\n                    size_num = OSSL_NELEM(aead_lengths_list);\n                }\n            }\n            if (mode_op == EVP_CIPH_GCM_MODE\n                || mode_op == EVP_CIPH_CCM_MODE\n                || mode_op == EVP_CIPH_OCB_MODE\n                || mode_op == EVP_CIPH_SIV_MODE\n                || mode_op == EVP_CIPH_GCM_SIV_MODE) {\n                ae_mode = 1;\n                if (decrypt)\n                    loopfunc = EVP_Update_loop_aead_dec;\n                else\n                    loopfunc = EVP_Update_loop_aead_enc;\n            } else {\n                loopfunc = EVP_Update_loop;\n            }\n\n            for (testnum = 0; testnum < size_num; testnum++) {\n                print_message(names[D_EVP], lengths[testnum], seconds.sym);\n\n                for (k = 0; k < loopargs_len; k++) {\n                    loopargs[k].ctx = EVP_CIPHER_CTX_new();\n                    if (loopargs[k].ctx == NULL) {\n                        BIO_printf(bio_err, \"\\nEVP_CIPHER_CTX_new failure\\n\");\n                        exit(1);\n                    }\n\n                    /*\n                     * For AE modes, we must first encrypt the data to get\n                     * a valid tag that enables us to decrypt. If we don't\n                     * encrypt first, we won't have a valid tag that enables\n                     * authenticity and hence decryption will fail.\n                     */\n                    if (!EVP_CipherInit_ex(loopargs[k].ctx, evp_cipher, NULL,\n                                           NULL, NULL, ae_mode ? 1 : !decrypt)) {\n                        BIO_printf(bio_err, \"\\nCouldn't init the context\\n\");\n                        dofail();\n                        exit(1);\n                    }\n\n                    /* Padding isn't needed */\n                    EVP_CIPHER_CTX_set_padding(loopargs[k].ctx, 0);\n\n                    keylen = EVP_CIPHER_CTX_get_key_length(loopargs[k].ctx);\n                    loopargs[k].key = app_malloc(keylen, \"evp_cipher key\");\n                    EVP_CIPHER_CTX_rand_key(loopargs[k].ctx, loopargs[k].key);\n\n                    if (!ae_mode) {\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, NULL, NULL,\n                                               loopargs[k].key, NULL, -1)) {\n                            BIO_printf(bio_err, \"\\nFailed to set the key\\n\");\n                            dofail();\n                            exit(1);\n                        }\n                    } else if (mode_op == EVP_CIPH_SIV_MODE\n                               || mode_op == EVP_CIPH_GCM_SIV_MODE) {\n                        EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                            EVP_CTRL_SET_SPEED, 1, NULL);\n                    }\n                    if (ae_mode && decrypt) {\n                        /* Set length of iv (Doesn't apply to SIV mode) */\n                        if (mode_op != EVP_CIPH_SIV_MODE) {\n                            if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                     EVP_CTRL_AEAD_SET_IVLEN,\n                                                     aead_ivlen, NULL)) {\n                                BIO_printf(bio_err, \"\\nFailed to set iv length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        /* Set tag_len (Not for GCM/SIV at encryption stage) */\n                        if (mode_op != EVP_CIPH_GCM_MODE\n                            && mode_op != EVP_CIPH_SIV_MODE\n                            && mode_op != EVP_CIPH_GCM_SIV_MODE) {\n                            if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                     EVP_CTRL_AEAD_SET_TAG,\n                                                     TAG_LEN, NULL)) {\n                                BIO_printf(bio_err,\n                                           \"\\nFailed to set tag length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, NULL, NULL,\n                                               loopargs[k].key, aead_iv, -1)) {\n                            BIO_printf(bio_err, \"\\nFailed to set the key\\n\");\n                            dofail();\n                            exit(1);\n                        }\n                        /* Set total length of input. Only required for CCM */\n                        if (mode_op == EVP_CIPH_CCM_MODE) {\n                            if (!EVP_EncryptUpdate(loopargs[k].ctx, NULL,\n                                                   &outlen, NULL,\n                                                   lengths[testnum])) {\n                                BIO_printf(bio_err,\n                                           \"\\nCouldn't set input text length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (aead) {\n                            if (!EVP_EncryptUpdate(loopargs[k].ctx, NULL,\n                                                   &outlen, aad, sizeof(aad))) {\n                                BIO_printf(bio_err,\n                                           \"\\nCouldn't insert AAD when encrypting\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (!EVP_EncryptUpdate(loopargs[k].ctx, loopargs[k].buf,\n                                               &outlen, loopargs[k].buf,\n                                               lengths[testnum])) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed to to encrypt the data\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        if (!EVP_EncryptFinal_ex(loopargs[k].ctx,\n                                                 loopargs[k].buf, &outlen)) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed finalize the encryption\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx, EVP_CTRL_AEAD_GET_TAG,\n                                                 TAG_LEN, &loopargs[k].tag)) {\n                            BIO_printf(bio_err, \"\\nFailed to get the tag\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        EVP_CIPHER_CTX_free(loopargs[k].ctx);\n                        loopargs[k].ctx = EVP_CIPHER_CTX_new();\n                        if (loopargs[k].ctx == NULL) {\n                            BIO_printf(bio_err,\n                                       \"\\nEVP_CIPHER_CTX_new failure\\n\");\n                            exit(1);\n                        }\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, evp_cipher,\n                                               NULL, NULL, NULL, 0)) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed initializing the context\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        EVP_CIPHER_CTX_set_padding(loopargs[k].ctx, 0);\n\n                        /* GCM-SIV/SIV only allows for a single Update operation */\n                        if (mode_op == EVP_CIPH_SIV_MODE\n                            || mode_op == EVP_CIPH_GCM_SIV_MODE)\n                            EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                EVP_CTRL_SET_SPEED, 1, NULL);\n                    }\n                }\n\n                Time_F(START);\n                count = run_benchmark(async_jobs, loopfunc, loopargs);\n                d = Time_F(STOP);\n                for (k = 0; k < loopargs_len; k++) {\n                    OPENSSL_clear_free(loopargs[k].key, keylen);\n                    EVP_CIPHER_CTX_free(loopargs[k].ctx);\n                }\n                print_result(D_EVP, testnum, count, d);\n            }\n        } else if (evp_md_name != NULL) {\n            names[D_EVP] = evp_md_name;\n\n            for (testnum = 0; testnum < size_num; testnum++) {\n                print_message(names[D_EVP], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EVP_Digest_md_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(D_EVP, testnum, count, d);\n                if (count < 0)\n                    break;\n            }\n        }\n    }\n\n    if (doit[D_EVP_CMAC]) {\n        size_t len = sizeof(\"cmac()\") + strlen(evp_mac_ciphername);\n        OSSL_PARAM params[3];\n        EVP_CIPHER *cipher = NULL;\n\n        if (!opt_cipher(evp_mac_ciphername, &cipher))\n            goto end;\n\n        keylen = EVP_CIPHER_get_key_length(cipher);\n        EVP_CIPHER_free(cipher);\n        if (keylen <= 0 || keylen > (int)sizeof(key32)) {\n            BIO_printf(bio_err, \"\\nRequested CMAC cipher with unsupported key length.\\n\");\n            goto end;\n        }\n        evp_cmac_name = app_malloc(len, \"CMAC name\");\n        BIO_snprintf(evp_cmac_name, len, \"cmac(%s)\", evp_mac_ciphername);\n        names[D_EVP_CMAC] = evp_cmac_name;\n\n        params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_CIPHER,\n                                                     evp_mac_ciphername, 0);\n        params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (char *)key32, keylen);\n        params[2] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"CMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_EVP_CMAC], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, CMAC_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_EVP_CMAC, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_KMAC128]) {\n        OSSL_PARAM params[2];\n\n        params[0] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 16);\n        params[1] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"KMAC-128\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_KMAC128], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, KMAC128_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_KMAC128, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_KMAC256]) {\n        OSSL_PARAM params[2];\n\n        params[0] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 32);\n        params[1] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"KMAC-256\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_KMAC256], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, KMAC256_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_KMAC256, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    for (i = 0; i < loopargs_len; i++)\n        if (RAND_bytes(loopargs[i].buf, 36) <= 0)\n            goto end;\n\n    for (testnum = 0; testnum < RSA_NUM; testnum++) {\n        EVP_PKEY *rsa_key = NULL;\n        int st = 0;\n\n        if (!rsa_doit[testnum])\n            continue;\n\n        if (primes > RSA_DEFAULT_PRIME_NUM) {\n            /* we haven't set keys yet,  generate multi-prime RSA keys */\n            bn = BN_new();\n            st = bn != NULL\n                && BN_set_word(bn, RSA_F4)\n                && init_gen_str(&genctx, \"RSA\", NULL, 0, NULL, NULL)\n                && EVP_PKEY_CTX_set_rsa_keygen_bits(genctx, rsa_keys[testnum].bits) > 0\n                && EVP_PKEY_CTX_set1_rsa_keygen_pubexp(genctx, bn) > 0\n                && EVP_PKEY_CTX_set_rsa_keygen_primes(genctx, primes) > 0\n                && EVP_PKEY_keygen(genctx, &rsa_key);\n            BN_free(bn);\n            bn = NULL;\n            EVP_PKEY_CTX_free(genctx);\n            genctx = NULL;\n        } else {\n            const unsigned char *p = rsa_keys[testnum].data;\n\n            st = (rsa_key = d2i_PrivateKey(EVP_PKEY_RSA, NULL, &p,\n                                           rsa_keys[testnum].length)) != NULL;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].rsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].rsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].rsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA sign setup failure.  No RSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"private\", \"rsa sign\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R1:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits private RSA sign ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key,\n                                                                   NULL);\n            if (loopargs[i].rsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].rsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].rsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA verify setup failure.  No RSA verify will be done.\\n\");\n            dofail();\n            rsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"public\", \"rsa verify\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R2:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits public RSA verify ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][1] = (double)count / d;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_encrypt_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            loopargs[i].encsize = loopargs[i].buflen;\n            if (loopargs[i].rsa_encrypt_ctx[testnum] == NULL\n                || EVP_PKEY_encrypt_init(loopargs[i].rsa_encrypt_ctx[testnum]) <= 0\n                || EVP_PKEY_encrypt(loopargs[i].rsa_encrypt_ctx[testnum],\n                                    loopargs[i].buf2,\n                                    &loopargs[i].encsize,\n                                    loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA encrypt setup failure.  No RSA encrypt will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"public\", \"rsa encrypt\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_encrypt_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R3:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits public RSA encrypt ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_decrypt_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            declen = loopargs[i].buflen;\n            if (loopargs[i].rsa_decrypt_ctx[testnum] == NULL\n                || EVP_PKEY_decrypt_init(loopargs[i].rsa_decrypt_ctx[testnum]) <= 0\n                || EVP_PKEY_decrypt(loopargs[i].rsa_decrypt_ctx[testnum],\n                                    loopargs[i].buf,\n                                    &declen,\n                                    loopargs[i].buf2,\n                                    loopargs[i].encsize) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA decrypt setup failure.  No RSA decrypt will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"private\", \"rsa decrypt\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_decrypt_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R4:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits private RSA decrypt ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][3] = (double)count / d;\n            op_count = count;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(rsa_doit, testnum);\n        }\n        EVP_PKEY_free(rsa_key);\n    }\n\n#ifndef OPENSSL_NO_DSA\n    for (testnum = 0; testnum < DSA_NUM; testnum++) {\n        EVP_PKEY *dsa_key = NULL;\n        int st;\n\n        if (!dsa_doit[testnum])\n            continue;\n\n        st = (dsa_key = get_dsa(dsa_bits[testnum])) != NULL;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].dsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(dsa_key,\n                                                                 NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].dsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].dsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].dsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"DSA sign setup failure.  No DSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"sign\", \"dsa\",\n                               dsa_bits[testnum], seconds.dsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, DSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R5:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits DSA sign ops in %.2fs\\n\",\n                       count, dsa_bits[testnum], d);\n            dsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].dsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(dsa_key,\n                                                                   NULL);\n            if (loopargs[i].dsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].dsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].dsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"DSA verify setup failure.  No DSA verify will be done.\\n\");\n            dofail();\n            dsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"verify\", \"dsa\",\n                               dsa_bits[testnum], seconds.dsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, DSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R6:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits DSA verify ops in %.2fs\\n\",\n                       count, dsa_bits[testnum], d);\n            dsa_results[testnum][1] = (double)count / d;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(dsa_doit, testnum);\n        }\n        EVP_PKEY_free(dsa_key);\n    }\n#endif /* OPENSSL_NO_DSA */\n\n    for (testnum = 0; testnum < ECDSA_NUM; testnum++) {\n        EVP_PKEY *ecdsa_key = NULL;\n        int st;\n\n        if (!ecdsa_doit[testnum])\n            continue;\n\n        st = (ecdsa_key = get_ecdsa(&ec_curves[testnum])) != NULL;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ecdsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(ecdsa_key,\n                                                                   NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].ecdsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].ecdsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].ecdsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"ECDSA sign setup failure.  No ECDSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"sign\", \"ecdsa\",\n                               ec_curves[testnum].bits, seconds.ecdsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, ECDSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R7:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits ECDSA sign ops in %.2fs\\n\",\n                       count, ec_curves[testnum].bits, d);\n            ecdsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ecdsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(ecdsa_key,\n                                                                     NULL);\n            if (loopargs[i].ecdsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].ecdsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].ecdsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"ECDSA verify setup failure.  No ECDSA verify will be done.\\n\");\n            dofail();\n            ecdsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"verify\", \"ecdsa\",\n                               ec_curves[testnum].bits, seconds.ecdsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, ECDSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R8:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits ECDSA verify ops in %.2fs\\n\",\n                       count, ec_curves[testnum].bits, d);\n            ecdsa_results[testnum][1] = (double)count / d;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ecdsa_doit, testnum);\n        }\n        EVP_PKEY_free(ecdsa_key);\n    }\n\n    for (testnum = 0; testnum < EC_NUM; testnum++) {\n        int ecdh_checks = 1;\n\n        if (!ecdh_doit[testnum])\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY_CTX *test_ctx = NULL;\n            EVP_PKEY_CTX *ctx = NULL;\n            EVP_PKEY *key_A = NULL;\n            EVP_PKEY *key_B = NULL;\n            size_t outlen;\n            size_t test_outlen;\n\n            if ((key_A = get_ecdsa(&ec_curves[testnum])) == NULL /* generate secret key A */\n                || (key_B = get_ecdsa(&ec_curves[testnum])) == NULL /* generate secret key B */\n                || (ctx = EVP_PKEY_CTX_new(key_A, NULL)) == NULL /* derivation ctx from skeyA */\n                || EVP_PKEY_derive_init(ctx) <= 0 /* init derivation ctx */\n                || EVP_PKEY_derive_set_peer(ctx, key_B) <= 0 /* set peer pubkey in ctx */\n                || EVP_PKEY_derive(ctx, NULL, &outlen) <= 0 /* determine max length */\n                || outlen == 0 /* ensure outlen is a valid size */\n                || outlen > MAX_ECDH_SIZE /* avoid buffer overflow */) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH key generation failure.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            /*\n             * Here we perform a test run, comparing the output of a*B and b*A;\n             * we try this here and assume that further EVP_PKEY_derive calls\n             * never fail, so we can skip checks in the actually benchmarked\n             * code, for maximum performance.\n             */\n            if ((test_ctx = EVP_PKEY_CTX_new(key_B, NULL)) == NULL /* test ctx from skeyB */\n                || EVP_PKEY_derive_init(test_ctx) <= 0 /* init derivation test_ctx */\n                || EVP_PKEY_derive_set_peer(test_ctx, key_A) <= 0 /* set peer pubkey in test_ctx */\n                || EVP_PKEY_derive(test_ctx, NULL, &test_outlen) <= 0 /* determine max length */\n                || EVP_PKEY_derive(ctx, loopargs[i].secret_a, &outlen) <= 0 /* compute a*B */\n                || EVP_PKEY_derive(test_ctx, loopargs[i].secret_b, &test_outlen) <= 0 /* compute b*A */\n                || test_outlen != outlen /* compare output length */) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH computation failure.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            /* Compare the computation results: CRYPTO_memcmp() returns 0 if equal */\n            if (CRYPTO_memcmp(loopargs[i].secret_a,\n                              loopargs[i].secret_b, outlen)) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH computations don't match.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            loopargs[i].ecdh_ctx[testnum] = ctx;\n            loopargs[i].outlen[testnum] = outlen;\n\n            EVP_PKEY_free(key_A);\n            EVP_PKEY_free(key_B);\n            EVP_PKEY_CTX_free(test_ctx);\n            test_ctx = NULL;\n        }\n        if (ecdh_checks != 0) {\n            pkey_print_message(\"\", \"ecdh\",\n                               ec_curves[testnum].bits, seconds.ecdh);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, ECDH_EVP_derive_key_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R9:%ld:%d:%.2f\\n\" :\n                       \"%ld %u-bits ECDH ops in %.2fs\\n\", count,\n                       ec_curves[testnum].bits, d);\n            ecdh_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ecdh_doit, testnum);\n        }\n    }\n\n#ifndef OPENSSL_NO_ECX\n    for (testnum = 0; testnum < EdDSA_NUM; testnum++) {\n        int st = 1;\n        EVP_PKEY *ed_pkey = NULL;\n        EVP_PKEY_CTX *ed_pctx = NULL;\n\n        if (!eddsa_doit[testnum])\n            continue;           /* Ignore Curve */\n        for (i = 0; i < loopargs_len; i++) {\n            loopargs[i].eddsa_ctx[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].eddsa_ctx[testnum] == NULL) {\n                st = 0;\n                break;\n            }\n            loopargs[i].eddsa_ctx2[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].eddsa_ctx2[testnum] == NULL) {\n                st = 0;\n                break;\n            }\n\n            if ((ed_pctx = EVP_PKEY_CTX_new_id(ed_curves[testnum].nid,\n                                               NULL)) == NULL\n                || EVP_PKEY_keygen_init(ed_pctx) <= 0\n                || EVP_PKEY_keygen(ed_pctx, &ed_pkey) <= 0) {\n                st = 0;\n                EVP_PKEY_CTX_free(ed_pctx);\n                break;\n            }\n            EVP_PKEY_CTX_free(ed_pctx);\n\n            if (!EVP_DigestSignInit(loopargs[i].eddsa_ctx[testnum], NULL, NULL,\n                                    NULL, ed_pkey)) {\n                st = 0;\n                EVP_PKEY_free(ed_pkey);\n                break;\n            }\n            if (!EVP_DigestVerifyInit(loopargs[i].eddsa_ctx2[testnum], NULL,\n                                      NULL, NULL, ed_pkey)) {\n                st = 0;\n                EVP_PKEY_free(ed_pkey);\n                break;\n            }\n\n            EVP_PKEY_free(ed_pkey);\n            ed_pkey = NULL;\n        }\n        if (st == 0) {\n            BIO_printf(bio_err, \"EdDSA failure.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            for (i = 0; i < loopargs_len; i++) {\n                /* Perform EdDSA signature test */\n                loopargs[i].sigsize = ed_curves[testnum].sigsize;\n                st = EVP_DigestSign(loopargs[i].eddsa_ctx[testnum],\n                                    loopargs[i].buf2, &loopargs[i].sigsize,\n                                    loopargs[i].buf, 20);\n                if (st == 0)\n                    break;\n            }\n            if (st == 0) {\n                BIO_printf(bio_err,\n                           \"EdDSA sign failure.  No EdDSA sign will be done.\\n\");\n                dofail();\n                op_count = 1;\n            } else {\n                pkey_print_message(\"sign\", ed_curves[testnum].name,\n                                   ed_curves[testnum].bits, seconds.eddsa);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EdDSA_sign_loop, loopargs);\n                d = Time_F(STOP);\n\n                BIO_printf(bio_err,\n                           mr ? \"+R10:%ld:%u:%s:%.2f\\n\" :\n                           \"%ld %u bits %s sign ops in %.2fs \\n\",\n                           count, ed_curves[testnum].bits,\n                           ed_curves[testnum].name, d);\n                eddsa_results[testnum][0] = (double)count / d;\n                op_count = count;\n            }\n            /* Perform EdDSA verification test */\n            for (i = 0; i < loopargs_len; i++) {\n                st = EVP_DigestVerify(loopargs[i].eddsa_ctx2[testnum],\n                                      loopargs[i].buf2, loopargs[i].sigsize,\n                                      loopargs[i].buf, 20);\n                if (st != 1)\n                    break;\n            }\n            if (st != 1) {\n                BIO_printf(bio_err,\n                           \"EdDSA verify failure.  No EdDSA verify will be done.\\n\");\n                dofail();\n                eddsa_doit[testnum] = 0;\n            } else {\n                pkey_print_message(\"verify\", ed_curves[testnum].name,\n                                   ed_curves[testnum].bits, seconds.eddsa);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EdDSA_verify_loop, loopargs);\n                d = Time_F(STOP);\n                BIO_printf(bio_err,\n                           mr ? \"+R11:%ld:%u:%s:%.2f\\n\"\n                           : \"%ld %u bits %s verify ops in %.2fs\\n\",\n                           count, ed_curves[testnum].bits,\n                           ed_curves[testnum].name, d);\n                eddsa_results[testnum][1] = (double)count / d;\n            }\n\n            if (op_count <= 1) {\n                /* if longer than 10s, don't do any more */\n                stop_it(eddsa_doit, testnum);\n            }\n        }\n    }\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    for (testnum = 0; testnum < SM2_NUM; testnum++) {\n        int st = 1;\n        EVP_PKEY *sm2_pkey = NULL;\n\n        if (!sm2_doit[testnum])\n            continue;           /* Ignore Curve */\n        /* Init signing and verification */\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY_CTX *sm2_pctx = NULL;\n            EVP_PKEY_CTX *sm2_vfy_pctx = NULL;\n            EVP_PKEY_CTX *pctx = NULL;\n            st = 0;\n\n            loopargs[i].sm2_ctx[testnum] = EVP_MD_CTX_new();\n            loopargs[i].sm2_vfy_ctx[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].sm2_ctx[testnum] == NULL\n                    || loopargs[i].sm2_vfy_ctx[testnum] == NULL)\n                break;\n\n            sm2_pkey = NULL;\n\n            st = !((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_SM2, NULL)) == NULL\n                || EVP_PKEY_keygen_init(pctx) <= 0\n                || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,\n                    sm2_curves[testnum].nid) <= 0\n                || EVP_PKEY_keygen(pctx, &sm2_pkey) <= 0);\n            EVP_PKEY_CTX_free(pctx);\n            if (st == 0)\n                break;\n\n            st = 0; /* set back to zero */\n            /* attach it sooner to rely on main final cleanup */\n            loopargs[i].sm2_pkey[testnum] = sm2_pkey;\n            loopargs[i].sigsize = EVP_PKEY_get_size(sm2_pkey);\n\n            sm2_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);\n            sm2_vfy_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);\n            if (sm2_pctx == NULL || sm2_vfy_pctx == NULL) {\n                EVP_PKEY_CTX_free(sm2_vfy_pctx);\n                break;\n            }\n\n            /* attach them directly to respective ctx */\n            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_ctx[testnum], sm2_pctx);\n            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_vfy_ctx[testnum], sm2_vfy_pctx);\n\n            /*\n             * No need to allow user to set an explicit ID here, just use\n             * the one defined in the 'draft-yang-tls-tl13-sm-suites' I-D.\n             */\n            if (EVP_PKEY_CTX_set1_id(sm2_pctx, SM2_ID, SM2_ID_LEN) != 1\n                || EVP_PKEY_CTX_set1_id(sm2_vfy_pctx, SM2_ID, SM2_ID_LEN) != 1)\n                break;\n\n            if (!EVP_DigestSignInit(loopargs[i].sm2_ctx[testnum], NULL,\n                                    EVP_sm3(), NULL, sm2_pkey))\n                break;\n            if (!EVP_DigestVerifyInit(loopargs[i].sm2_vfy_ctx[testnum], NULL,\n                                      EVP_sm3(), NULL, sm2_pkey))\n                break;\n            st = 1;         /* mark loop as succeeded */\n        }\n        if (st == 0) {\n            BIO_printf(bio_err, \"SM2 init failure.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            for (i = 0; i < loopargs_len; i++) {\n                /* Perform SM2 signature test */\n                st = EVP_DigestSign(loopargs[i].sm2_ctx[testnum],\n                                    loopargs[i].buf2, &loopargs[i].sigsize,\n                                    loopargs[i].buf, 20);\n                if (st == 0)\n                    break;\n            }\n            if (st == 0) {\n                BIO_printf(bio_err,\n                           \"SM2 sign failure.  No SM2 sign will be done.\\n\");\n                dofail();\n                op_count = 1;\n            } else {\n                pkey_print_message(\"sign\", sm2_curves[testnum].name,\n                                   sm2_curves[testnum].bits, seconds.sm2);\n                Time_F(START);\n                count = run_benchmark(async_jobs, SM2_sign_loop, loopargs);\n                d = Time_F(STOP);\n\n                BIO_printf(bio_err,\n                           mr ? \"+R12:%ld:%u:%s:%.2f\\n\" :\n                           \"%ld %u bits %s sign ops in %.2fs \\n\",\n                           count, sm2_curves[testnum].bits,\n                           sm2_curves[testnum].name, d);\n                sm2_results[testnum][0] = (double)count / d;\n                op_count = count;\n            }\n\n            /* Perform SM2 verification test */\n            for (i = 0; i < loopargs_len; i++) {\n                st = EVP_DigestVerify(loopargs[i].sm2_vfy_ctx[testnum],\n                                      loopargs[i].buf2, loopargs[i].sigsize,\n                                      loopargs[i].buf, 20);\n                if (st != 1)\n                    break;\n            }\n            if (st != 1) {\n                BIO_printf(bio_err,\n                           \"SM2 verify failure.  No SM2 verify will be done.\\n\");\n                dofail();\n                sm2_doit[testnum] = 0;\n            } else {\n                pkey_print_message(\"verify\", sm2_curves[testnum].name,\n                                   sm2_curves[testnum].bits, seconds.sm2);\n                Time_F(START);\n                count = run_benchmark(async_jobs, SM2_verify_loop, loopargs);\n                d = Time_F(STOP);\n                BIO_printf(bio_err,\n                           mr ? \"+R13:%ld:%u:%s:%.2f\\n\"\n                           : \"%ld %u bits %s verify ops in %.2fs\\n\",\n                           count, sm2_curves[testnum].bits,\n                           sm2_curves[testnum].name, d);\n                sm2_results[testnum][1] = (double)count / d;\n            }\n\n            if (op_count <= 1) {\n                /* if longer than 10s, don't do any more */\n                for (testnum++; testnum < SM2_NUM; testnum++)\n                    sm2_doit[testnum] = 0;\n            }\n        }\n    }\n#endif                         /* OPENSSL_NO_SM2 */\n\n#ifndef OPENSSL_NO_DH\n    for (testnum = 0; testnum < FFDH_NUM; testnum++) {\n        int ffdh_checks = 1;\n\n        if (!ffdh_doit[testnum])\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey_A = NULL;\n            EVP_PKEY *pkey_B = NULL;\n            EVP_PKEY_CTX *ffdh_ctx = NULL;\n            EVP_PKEY_CTX *test_ctx = NULL;\n            size_t secret_size;\n            size_t test_out;\n\n            /* Ensure that the error queue is empty */\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            pkey_A = EVP_PKEY_new();\n            if (!pkey_A) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY (out of memory?).\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            pkey_B = EVP_PKEY_new();\n            if (!pkey_B) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY (out of memory?).\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            ffdh_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DH, NULL);\n            if (!ffdh_ctx) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            if (EVP_PKEY_keygen_init(ffdh_ctx) <= 0) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_CTX_set_dh_nid(ffdh_ctx, ffdh_params[testnum].nid) <= 0) {\n                BIO_printf(bio_err, \"Error setting DH key size for keygen.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            if (EVP_PKEY_keygen(ffdh_ctx, &pkey_A) <= 0 ||\n                EVP_PKEY_keygen(ffdh_ctx, &pkey_B) <= 0) {\n                BIO_printf(bio_err, \"FFDH key generation failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            EVP_PKEY_CTX_free(ffdh_ctx);\n\n            /*\n             * check if the derivation works correctly both ways so that\n             * we know if future derive calls will fail, and we can skip\n             * error checking in benchmarked code\n             */\n            ffdh_ctx = EVP_PKEY_CTX_new(pkey_A, NULL);\n            if (ffdh_ctx == NULL) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_init(ffdh_ctx) <= 0) {\n                BIO_printf(bio_err, \"FFDH derivation context init failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_set_peer(ffdh_ctx, pkey_B) <= 0) {\n                BIO_printf(bio_err, \"Assigning peer key for derivation failed.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive(ffdh_ctx, NULL, &secret_size) <= 0) {\n                BIO_printf(bio_err, \"Checking size of shared secret failed.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (secret_size > MAX_FFDH_SIZE) {\n                BIO_printf(bio_err, \"Assertion failure: shared secret too large.\\n\");\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive(ffdh_ctx,\n                                loopargs[i].secret_ff_a,\n                                &secret_size) <= 0) {\n                BIO_printf(bio_err, \"Shared secret derive failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            /* Now check from side B */\n            test_ctx = EVP_PKEY_CTX_new(pkey_B, NULL);\n            if (!test_ctx) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_init(test_ctx) <= 0 ||\n                EVP_PKEY_derive_set_peer(test_ctx, pkey_A) <= 0 ||\n                EVP_PKEY_derive(test_ctx, NULL, &test_out) <= 0 ||\n                EVP_PKEY_derive(test_ctx, loopargs[i].secret_ff_b, &test_out) <= 0 ||\n                test_out != secret_size) {\n                BIO_printf(bio_err, \"FFDH computation failure.\\n\");\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            /* compare the computed secrets */\n            if (CRYPTO_memcmp(loopargs[i].secret_ff_a,\n                              loopargs[i].secret_ff_b, secret_size)) {\n                BIO_printf(bio_err, \"FFDH computations don't match.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            loopargs[i].ffdh_ctx[testnum] = ffdh_ctx;\n\n            EVP_PKEY_free(pkey_A);\n            pkey_A = NULL;\n            EVP_PKEY_free(pkey_B);\n            pkey_B = NULL;\n            EVP_PKEY_CTX_free(test_ctx);\n            test_ctx = NULL;\n        }\n        if (ffdh_checks != 0) {\n            pkey_print_message(\"\", \"ffdh\",\n                               ffdh_params[testnum].bits, seconds.ffdh);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, FFDH_derive_key_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R14:%ld:%d:%.2f\\n\" :\n                       \"%ld %u-bits FFDH ops in %.2fs\\n\", count,\n                       ffdh_params[testnum].bits, d);\n            ffdh_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ffdh_doit, testnum);\n        }\n    }\n#endif  /* OPENSSL_NO_DH */\n\n    for (testnum = 0; testnum < kems_algs_len; testnum++) {\n        int kem_checks = 1;\n        const char *kem_name = kems_algname[testnum];\n\n        if (!kems_doit[testnum] || !do_kems)\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey = NULL;\n            EVP_PKEY_CTX *kem_gen_ctx = NULL;\n            EVP_PKEY_CTX *kem_encaps_ctx = NULL;\n            EVP_PKEY_CTX *kem_decaps_ctx = NULL;\n            size_t send_secret_len, out_len;\n            size_t rcv_secret_len;\n            unsigned char *out = NULL, *send_secret = NULL, *rcv_secret;\n            unsigned int bits;\n            char *name;\n            char sfx[MAX_ALGNAME_SUFFIX];\n            OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n            int use_params = 0;\n            enum kem_type_t { KEM_RSA = 1, KEM_EC, KEM_X25519, KEM_X448 } kem_type;\n\n            /* no string after rsa<bitcnt> permitted: */\n            if (strlen(kem_name) < MAX_ALGNAME_SUFFIX + 4 /* rsa+digit */\n                && sscanf(kem_name, \"rsa%u%s\", &bits, sfx) == 1)\n                kem_type = KEM_RSA;\n            else if (strncmp(kem_name, \"EC\", 2) == 0)\n                kem_type = KEM_EC;\n            else if (strcmp(kem_name, \"X25519\") == 0)\n                kem_type = KEM_X25519;\n            else if (strcmp(kem_name, \"X448\") == 0)\n                kem_type = KEM_X448;\n            else kem_type = 0;\n\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            if (kem_type == KEM_RSA) {\n                params[0] = OSSL_PARAM_construct_uint(OSSL_PKEY_PARAM_RSA_BITS,\n                                                      &bits);\n                use_params = 1;\n            } else if (kem_type == KEM_EC) {\n                name = (char *)(kem_name + 2);\n                params[0] = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_GROUP_NAME,\n                                                  name, 0);\n                use_params = 1;\n            }\n\n            kem_gen_ctx = EVP_PKEY_CTX_new_from_name(app_get0_libctx(),\n                                               (kem_type == KEM_RSA) ? \"RSA\":\n                                                (kem_type == KEM_EC) ? \"EC\":\n                                                 kem_name,\n                                               app_get0_propq());\n\n            if ((!kem_gen_ctx || EVP_PKEY_keygen_init(kem_gen_ctx) <= 0)\n                || (use_params\n                    && EVP_PKEY_CTX_set_params(kem_gen_ctx, params) <= 0)) {\n                BIO_printf(bio_err, \"Error initializing keygen ctx for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_keygen(kem_gen_ctx, &pkey) <= 0) {\n                BIO_printf(bio_err, \"Error while generating KEM EVP_PKEY.\\n\");\n                goto kem_err_break;\n            }\n            /* Now prepare encaps data structs */\n            kem_encaps_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (kem_encaps_ctx == NULL\n                || EVP_PKEY_encapsulate_init(kem_encaps_ctx, NULL) <= 0\n                || (kem_type == KEM_RSA\n                    && EVP_PKEY_CTX_set_kem_op(kem_encaps_ctx, \"RSASVE\") <= 0)\n                || ((kem_type == KEM_EC\n                    || kem_type == KEM_X25519\n                    || kem_type == KEM_X448)\n                   && EVP_PKEY_CTX_set_kem_op(kem_encaps_ctx, \"DHKEM\") <= 0)\n                || EVP_PKEY_encapsulate(kem_encaps_ctx, NULL, &out_len,\n                                      NULL, &send_secret_len) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while initializing encaps data structs for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            out = app_malloc(out_len, \"encaps result\");\n            send_secret = app_malloc(send_secret_len, \"encaps secret\");\n            if (out == NULL || send_secret == NULL) {\n                BIO_printf(bio_err, \"MemAlloc error in encaps for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_encapsulate(kem_encaps_ctx, out, &out_len,\n                                     send_secret, &send_secret_len) <= 0) {\n                BIO_printf(bio_err, \"Encaps error for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            /* Now prepare decaps data structs */\n            kem_decaps_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (kem_decaps_ctx == NULL\n                || EVP_PKEY_decapsulate_init(kem_decaps_ctx, NULL) <= 0\n                || (kem_type == KEM_RSA\n                  && EVP_PKEY_CTX_set_kem_op(kem_decaps_ctx, \"RSASVE\") <= 0)\n                || ((kem_type == KEM_EC\n                     || kem_type == KEM_X25519\n                     || kem_type == KEM_X448)\n                  && EVP_PKEY_CTX_set_kem_op(kem_decaps_ctx, \"DHKEM\") <= 0)\n                || EVP_PKEY_decapsulate(kem_decaps_ctx, NULL, &rcv_secret_len,\n                                        out, out_len) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while initializing decaps data structs for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            rcv_secret = app_malloc(rcv_secret_len, \"KEM decaps secret\");\n            if (rcv_secret == NULL) {\n                BIO_printf(bio_err, \"MemAlloc failure in decaps for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_decapsulate(kem_decaps_ctx, rcv_secret,\n                                     &rcv_secret_len, out, out_len) <= 0\n                || rcv_secret_len != send_secret_len\n                || memcmp(send_secret, rcv_secret, send_secret_len)) {\n                BIO_printf(bio_err, \"Decaps error for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            loopargs[i].kem_gen_ctx[testnum] = kem_gen_ctx;\n            loopargs[i].kem_encaps_ctx[testnum] = kem_encaps_ctx;\n            loopargs[i].kem_decaps_ctx[testnum] = kem_decaps_ctx;\n            loopargs[i].kem_out_len[testnum] = out_len;\n            loopargs[i].kem_secret_len[testnum] = send_secret_len;\n            loopargs[i].kem_out[testnum] = out;\n            loopargs[i].kem_send_secret[testnum] = send_secret;\n            loopargs[i].kem_rcv_secret[testnum] = rcv_secret;\n            EVP_PKEY_free(pkey);\n            pkey = NULL;\n            continue;\n\n        kem_err_break:\n            dofail();\n            EVP_PKEY_free(pkey);\n            op_count = 1;\n            kem_checks = 0;\n            break;\n        }\n        if (kem_checks != 0) {\n            kskey_print_message(kem_name, \"keygen\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_keygen_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R15:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM keygen ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][0] = (double)count / d;\n            op_count = count;\n            kskey_print_message(kem_name, \"encaps\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_encaps_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R16:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM encaps ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][1] = (double)count / d;\n            op_count = count;\n            kskey_print_message(kem_name, \"decaps\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_decaps_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R17:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM decaps ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(kems_doit, testnum);\n        }\n    }\n\n    for (testnum = 0; testnum < sigs_algs_len; testnum++) {\n        int sig_checks = 1;\n        const char *sig_name = sigs_algname[testnum];\n\n        if (!sigs_doit[testnum] || !do_sigs)\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey = NULL;\n            EVP_PKEY_CTX *ctx_params = NULL;\n            EVP_PKEY* pkey_params = NULL;\n            EVP_PKEY_CTX *sig_gen_ctx = NULL;\n            EVP_PKEY_CTX *sig_sign_ctx = NULL;\n            EVP_PKEY_CTX *sig_verify_ctx = NULL;\n            unsigned char md[SHA256_DIGEST_LENGTH];\n            unsigned char *sig;\n            char sfx[MAX_ALGNAME_SUFFIX];\n            size_t md_len = SHA256_DIGEST_LENGTH;\n            size_t max_sig_len, sig_len;\n            unsigned int bits;\n            OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n            int use_params = 0;\n\n            /* only sign little data to avoid measuring digest performance */\n            memset(md, 0, SHA256_DIGEST_LENGTH);\n\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            /* no string after rsa<bitcnt> permitted: */\n            if (strlen(sig_name) < MAX_ALGNAME_SUFFIX + 4 /* rsa+digit */\n                && sscanf(sig_name, \"rsa%u%s\", &bits, sfx) == 1) {\n                params[0] = OSSL_PARAM_construct_uint(OSSL_PKEY_PARAM_RSA_BITS,\n                                                      &bits);\n                use_params = 1;\n            }\n\n            if (strncmp(sig_name, \"dsa\", 3) == 0) {\n                ctx_params = EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, NULL);\n                if (ctx_params == NULL\n                    || EVP_PKEY_paramgen_init(ctx_params) <= 0\n                    || EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx_params,\n                                                        atoi(sig_name + 3)) <= 0\n                    || EVP_PKEY_paramgen(ctx_params, &pkey_params) <= 0\n                    || (sig_gen_ctx = EVP_PKEY_CTX_new(pkey_params, NULL)) == NULL\n                    || EVP_PKEY_keygen_init(sig_gen_ctx) <= 0) {\n                    BIO_printf(bio_err,\n                               \"Error initializing classic keygen ctx for %s.\\n\",\n                               sig_name);\n                    goto sig_err_break;\n                }\n            }\n\n            if (sig_gen_ctx == NULL)\n                sig_gen_ctx = EVP_PKEY_CTX_new_from_name(app_get0_libctx(),\n                                      use_params == 1 ? \"RSA\" : sig_name,\n                                      app_get0_propq());\n\n            if (!sig_gen_ctx || EVP_PKEY_keygen_init(sig_gen_ctx) <= 0\n                || (use_params &&\n                    EVP_PKEY_CTX_set_params(sig_gen_ctx, params) <= 0)) {\n                BIO_printf(bio_err, \"Error initializing keygen ctx for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_keygen(sig_gen_ctx, &pkey) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while generating signature EVP_PKEY for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            /* Now prepare signature data structs */\n            sig_sign_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                      pkey,\n                                                      app_get0_propq());\n            if (sig_sign_ctx == NULL\n                || EVP_PKEY_sign_init(sig_sign_ctx) <= 0\n                || (use_params == 1\n                    && (EVP_PKEY_CTX_set_rsa_padding(sig_sign_ctx,\n                                                     RSA_PKCS1_PADDING) <= 0))\n                || EVP_PKEY_sign(sig_sign_ctx, NULL, &max_sig_len,\n                                 md, md_len) <= 0) {\n                    BIO_printf(bio_err,\n                               \"Error while initializing signing data structs for %s.\\n\",\n                               sig_name);\n                    goto sig_err_break;\n            }\n            sig = app_malloc(sig_len = max_sig_len, \"signature buffer\");\n            if (sig == NULL) {\n                BIO_printf(bio_err, \"MemAlloc error in sign for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_sign(sig_sign_ctx, sig, &sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Signing error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            /* Now prepare verify data structs */\n            memset(md, 0, SHA256_DIGEST_LENGTH);\n            sig_verify_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (sig_verify_ctx == NULL\n                || EVP_PKEY_verify_init(sig_verify_ctx) <= 0\n                || (use_params == 1\n                  && (EVP_PKEY_CTX_set_rsa_padding(sig_verify_ctx,\n                                                   RSA_PKCS1_PADDING) <= 0))) {\n                BIO_printf(bio_err,\n                           \"Error while initializing verify data structs for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_verify(sig_verify_ctx, sig, sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Verify error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_verify(sig_verify_ctx, sig, sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Verify 2 error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            loopargs[i].sig_gen_ctx[testnum] = sig_gen_ctx;\n            loopargs[i].sig_sign_ctx[testnum] = sig_sign_ctx;\n            loopargs[i].sig_verify_ctx[testnum] = sig_verify_ctx;\n            loopargs[i].sig_max_sig_len[testnum] = max_sig_len;\n            loopargs[i].sig_act_sig_len[testnum] = sig_len;\n            loopargs[i].sig_sig[testnum] = sig;\n            EVP_PKEY_free(pkey);\n            pkey = NULL;\n            continue;\n\n        sig_err_break:\n            dofail();\n            EVP_PKEY_free(pkey);\n            op_count = 1;\n            sig_checks = 0;\n            break;\n        }\n\n        if (sig_checks != 0) {\n            kskey_print_message(sig_name, \"keygen\", seconds.sig);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SIG_keygen_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R18:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature keygen ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][0] = (double)count / d;\n            op_count = count;\n            kskey_print_message(sig_name, \"signs\", seconds.sig);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, SIG_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R19:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature sign ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][1] = (double)count / d;\n            op_count = count;\n\n            kskey_print_message(sig_name, \"verify\", seconds.sig);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, SIG_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R20:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature verify ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1)\n            stop_it(sigs_doit, testnum);\n    }\n\n#ifndef NO_FORK\n show_res:\n#endif\n    if (!mr) {\n        printf(\"version: %s\\n\", OpenSSL_version(OPENSSL_FULL_VERSION_STRING));\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_BUILT_ON));\n        printf(\"options: %s\\n\", BN_options());\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_CFLAGS));\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_CPU_INFO));\n    }\n\n    if (pr_header) {\n        if (mr) {\n            printf(\"+H\");\n        } else {\n            printf(\"The 'numbers' are in 1000s of bytes per second processed.\\n\");\n            printf(\"type        \");\n        }\n        for (testnum = 0; testnum < size_num; testnum++)\n            printf(mr ? \":%d\" : \"%7d bytes\", lengths[testnum]);\n        printf(\"\\n\");\n    }\n\n    for (k = 0; k < ALGOR_NUM; k++) {\n        const char *alg_name = names[k];\n\n        if (!doit[k])\n            continue;\n\n        if (k == D_EVP) {\n            if (evp_cipher == NULL)\n                alg_name = evp_md_name;\n            else if ((alg_name = EVP_CIPHER_get0_name(evp_cipher)) == NULL)\n                app_bail_out(\"failed to get name of cipher '%s'\\n\", evp_cipher);\n        }\n\n        if (mr)\n            printf(\"+F:%u:%s\", k, alg_name);\n        else\n            printf(\"%-13s\", alg_name);\n        for (testnum = 0; testnum < size_num; testnum++) {\n            if (results[k][testnum] > 10000 && !mr)\n                printf(\" %11.2fk\", results[k][testnum] / 1e3);\n            else\n                printf(mr ? \":%.2f\" : \" %11.2f \", results[k][testnum]);\n        }\n        printf(\"\\n\");\n    }\n    testnum = 1;\n    for (k = 0; k < RSA_NUM; k++) {\n        if (!rsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%19ssign    verify    encrypt   decrypt   sign/s verify/s  encr./s  decr./s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F2:%u:%u:%f:%f:%f:%f\\n\",\n                   k, rsa_keys[k].bits, rsa_results[k][0], rsa_results[k][1],\n                   rsa_results[k][2], rsa_results[k][3]);\n        else\n            printf(\"rsa %5u bits %8.6fs %8.6fs %8.6fs %8.6fs %8.1f %8.1f %8.1f %8.1f\\n\",\n                   rsa_keys[k].bits, 1.0 / rsa_results[k][0],\n                   1.0 / rsa_results[k][1], 1.0 / rsa_results[k][2],\n                   1.0 / rsa_results[k][3],\n                   rsa_results[k][0], rsa_results[k][1],\n                   rsa_results[k][2], rsa_results[k][3]);\n    }\n    testnum = 1;\n#ifndef OPENSSL_NO_DSA\n    for (k = 0; k < DSA_NUM; k++) {\n        if (!dsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%18ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F3:%u:%u:%f:%f\\n\",\n                   k, dsa_bits[k], dsa_results[k][0], dsa_results[k][1]);\n        else\n            printf(\"dsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\\n\",\n                   dsa_bits[k], 1.0 / dsa_results[k][0], 1.0 / dsa_results[k][1],\n                   dsa_results[k][0], dsa_results[k][1]);\n    }\n#endif /* OPENSSL_NO_DSA */\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(ecdsa_doit); k++) {\n        if (!ecdsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F4:%u:%u:%f:%f\\n\",\n                   k, ec_curves[k].bits,\n                   ecdsa_results[k][0], ecdsa_results[k][1]);\n        else\n            printf(\"%4u bits ecdsa (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   ec_curves[k].bits, ec_curves[k].name,\n                   1.0 / ecdsa_results[k][0], 1.0 / ecdsa_results[k][1],\n                   ecdsa_results[k][0], ecdsa_results[k][1]);\n    }\n\n    testnum = 1;\n    for (k = 0; k < EC_NUM; k++) {\n        if (!ecdh_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30sop      op/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F5:%u:%u:%f:%f\\n\",\n                   k, ec_curves[k].bits,\n                   ecdh_results[k][0], 1.0 / ecdh_results[k][0]);\n\n        else\n            printf(\"%4u bits ecdh (%s) %8.4fs %8.1f\\n\",\n                   ec_curves[k].bits, ec_curves[k].name,\n                   1.0 / ecdh_results[k][0], ecdh_results[k][0]);\n    }\n\n#ifndef OPENSSL_NO_ECX\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(eddsa_doit); k++) {\n        if (!eddsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F6:%u:%u:%s:%f:%f\\n\",\n                   k, ed_curves[k].bits, ed_curves[k].name,\n                   eddsa_results[k][0], eddsa_results[k][1]);\n        else\n            printf(\"%4u bits EdDSA (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   ed_curves[k].bits, ed_curves[k].name,\n                   1.0 / eddsa_results[k][0], 1.0 / eddsa_results[k][1],\n                   eddsa_results[k][0], eddsa_results[k][1]);\n    }\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(sm2_doit); k++) {\n        if (!sm2_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F7:%u:%u:%s:%f:%f\\n\",\n                   k, sm2_curves[k].bits, sm2_curves[k].name,\n                   sm2_results[k][0], sm2_results[k][1]);\n        else\n            printf(\"%4u bits SM2 (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   sm2_curves[k].bits, sm2_curves[k].name,\n                   1.0 / sm2_results[k][0], 1.0 / sm2_results[k][1],\n                   sm2_results[k][0], sm2_results[k][1]);\n    }\n#endif\n#ifndef OPENSSL_NO_DH\n    testnum = 1;\n    for (k = 0; k < FFDH_NUM; k++) {\n        if (!ffdh_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%23sop     op/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F8:%u:%u:%f:%f\\n\",\n                   k, ffdh_params[k].bits,\n                   ffdh_results[k][0], 1.0 / ffdh_results[k][0]);\n\n        else\n            printf(\"%4u bits ffdh %8.4fs %8.1f\\n\",\n                   ffdh_params[k].bits,\n                   1.0 / ffdh_results[k][0], ffdh_results[k][0]);\n    }\n#endif /* OPENSSL_NO_DH */\n\n    testnum = 1;\n    for (k = 0; k < kems_algs_len; k++) {\n        const char *kem_name = kems_algname[k];\n\n        if (!kems_doit[k] || !do_kems)\n            continue;\n        if (testnum && !mr) {\n            printf(\"%31skeygen    encaps    decaps keygens/s  encaps/s  decaps/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F9:%u:%f:%f:%f\\n\",\n                   k, kems_results[k][0], kems_results[k][1],\n                   kems_results[k][2]);\n        else\n            printf(\"%27s %8.6fs %8.6fs %8.6fs %9.1f %9.1f %9.1f\\n\", kem_name,\n                   1.0 / kems_results[k][0],\n                   1.0 / kems_results[k][1], 1.0 / kems_results[k][2],\n                   kems_results[k][0], kems_results[k][1], kems_results[k][2]);\n    }\n    ret = 0;\n\n    testnum = 1;\n    for (k = 0; k < sigs_algs_len; k++) {\n        const char *sig_name = sigs_algname[k];\n\n        if (!sigs_doit[k] || !do_sigs)\n            continue;\n        if (testnum && !mr) {\n            printf(\"%31skeygen     signs    verify keygens/s    sign/s  verify/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F10:%u:%f:%f:%f\\n\",\n                   k, sigs_results[k][0], sigs_results[k][1],\n                   sigs_results[k][2]);\n        else\n            printf(\"%27s %8.6fs %8.6fs %8.6fs %9.1f %9.1f %9.1f\\n\", sig_name,\n                   1.0 / sigs_results[k][0], 1.0 / sigs_results[k][1],\n                   1.0 / sigs_results[k][2], sigs_results[k][0],\n                   sigs_results[k][1], sigs_results[k][2]);\n    }\n    ret = 0;\n\n end:\n    if (ret == 0 && testmode)\n        ret = testmoderesult;\n    ERR_print_errors(bio_err);\n    for (i = 0; i < loopargs_len; i++) {\n        OPENSSL_free(loopargs[i].buf_malloc);\n        OPENSSL_free(loopargs[i].buf2_malloc);\n\n        BN_free(bn);\n        EVP_PKEY_CTX_free(genctx);\n        for (k = 0; k < RSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].rsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_verify_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_encrypt_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_decrypt_ctx[k]);\n        }\n#ifndef OPENSSL_NO_DH\n        OPENSSL_free(loopargs[i].secret_ff_a);\n        OPENSSL_free(loopargs[i].secret_ff_b);\n        for (k = 0; k < FFDH_NUM; k++)\n            EVP_PKEY_CTX_free(loopargs[i].ffdh_ctx[k]);\n#endif\n#ifndef OPENSSL_NO_DSA\n        for (k = 0; k < DSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].dsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].dsa_verify_ctx[k]);\n        }\n#endif\n        for (k = 0; k < ECDSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].ecdsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].ecdsa_verify_ctx[k]);\n        }\n        for (k = 0; k < EC_NUM; k++)\n            EVP_PKEY_CTX_free(loopargs[i].ecdh_ctx[k]);\n#ifndef OPENSSL_NO_ECX\n        for (k = 0; k < EdDSA_NUM; k++) {\n            EVP_MD_CTX_free(loopargs[i].eddsa_ctx[k]);\n            EVP_MD_CTX_free(loopargs[i].eddsa_ctx2[k]);\n        }\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        for (k = 0; k < SM2_NUM; k++) {\n            EVP_PKEY_CTX *pctx = NULL;\n\n            /* free signing ctx */\n            if (loopargs[i].sm2_ctx[k] != NULL\n                && (pctx = EVP_MD_CTX_get_pkey_ctx(loopargs[i].sm2_ctx[k])) != NULL)\n                EVP_PKEY_CTX_free(pctx);\n            EVP_MD_CTX_free(loopargs[i].sm2_ctx[k]);\n            /* free verification ctx */\n            if (loopargs[i].sm2_vfy_ctx[k] != NULL\n                && (pctx = EVP_MD_CTX_get_pkey_ctx(loopargs[i].sm2_vfy_ctx[k])) != NULL)\n                EVP_PKEY_CTX_free(pctx);\n            EVP_MD_CTX_free(loopargs[i].sm2_vfy_ctx[k]);\n            /* free pkey */\n            EVP_PKEY_free(loopargs[i].sm2_pkey[k]);\n        }\n#endif\n        for (k = 0; k < kems_algs_len; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].kem_gen_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].kem_encaps_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].kem_decaps_ctx[k]);\n            OPENSSL_free(loopargs[i].kem_out[k]);\n            OPENSSL_free(loopargs[i].kem_send_secret[k]);\n            OPENSSL_free(loopargs[i].kem_rcv_secret[k]);\n        }\n        for (k = 0; k < sigs_algs_len; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].sig_gen_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].sig_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].sig_verify_ctx[k]);\n            OPENSSL_free(loopargs[i].sig_sig[k]);\n        }\n        OPENSSL_free(loopargs[i].secret_a);\n        OPENSSL_free(loopargs[i].secret_b);\n    }\n    OPENSSL_free(evp_hmac_name);\n    OPENSSL_free(evp_cmac_name);\n    for (k = 0; k < kems_algs_len; k++)\n        OPENSSL_free(kems_algname[k]);\n    if (kem_stack != NULL)\n        sk_EVP_KEM_pop_free(kem_stack, EVP_KEM_free);\n    for (k = 0; k < sigs_algs_len; k++)\n        OPENSSL_free(sigs_algname[k]);\n    if (sig_stack != NULL)\n        sk_EVP_SIGNATURE_pop_free(sig_stack, EVP_SIGNATURE_free);\n\n    if (async_jobs > 0) {\n        for (i = 0; i < loopargs_len; i++)\n            ASYNC_WAIT_CTX_free(loopargs[i].wait_ctx);\n    }\n\n    if (async_init) {\n        ASYNC_cleanup_thread();\n    }\n    OPENSSL_free(loopargs);\n    release_engine(e);\n    EVP_CIPHER_free(evp_cipher);\n    EVP_MAC_free(mac);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "OPENSSL_free(loopargs[i].buf_malloc);",
        "final_sink": "OPENSSL_free(loopargs[i].buf_malloc);",
        "source": [
            "        val = sk_CONF_VALUE_value(vals, i);"
        ],
        "index": 48
    },
    {
        "prt": "loopargs",
        "function_call": [
            "int speed_main(int argc, char **argv)\n{\n    CONF *conf = NULL;\n    ENGINE *e = NULL;\n    loopargs_t *loopargs = NULL;\n    const char *prog;\n    const char *engine_id = NULL;\n    EVP_CIPHER *evp_cipher = NULL;\n    EVP_MAC *mac = NULL;\n    double d = 0.0;\n    OPTION_CHOICE o;\n    int async_init = 0, multiblock = 0, pr_header = 0;\n    uint8_t doit[ALGOR_NUM] = { 0 };\n    int ret = 1, misalign = 0, lengths_single = 0;\n    STACK_OF(EVP_KEM) *kem_stack = NULL;\n    STACK_OF(EVP_SIGNATURE) *sig_stack = NULL;\n    long count = 0;\n    unsigned int size_num = SIZE_NUM;\n    unsigned int i, k, loopargs_len = 0, async_jobs = 0;\n    unsigned int idx;\n    int keylen = 0;\n    int buflen;\n    size_t declen;\n    BIGNUM *bn = NULL;\n    EVP_PKEY_CTX *genctx = NULL;\n#ifndef NO_FORK\n    int multi = 0;\n#endif\n    long op_count = 1;\n    openssl_speed_sec_t seconds = { SECONDS, RSA_SECONDS, DSA_SECONDS,\n                                    ECDSA_SECONDS, ECDH_SECONDS,\n                                    EdDSA_SECONDS, SM2_SECONDS,\n                                    FFDH_SECONDS, KEM_SECONDS,\n                                    SIG_SECONDS };\n\n    static const unsigned char key32[32] = {\n        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,\n        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12,\n        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34,\n        0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56\n    };\n    static const unsigned char deskey[] = {\n        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, /* key1 */\n        0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, /* key2 */\n        0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34  /* key3 */\n    };\n    static const struct {\n        const unsigned char *data;\n        unsigned int length;\n        unsigned int bits;\n    } rsa_keys[] = {\n        {   test512,   sizeof(test512),   512 },\n        {  test1024,  sizeof(test1024),  1024 },\n        {  test2048,  sizeof(test2048),  2048 },\n        {  test3072,  sizeof(test3072),  3072 },\n        {  test4096,  sizeof(test4096),  4096 },\n        {  test7680,  sizeof(test7680),  7680 },\n        { test15360, sizeof(test15360), 15360 }\n    };\n    uint8_t rsa_doit[RSA_NUM] = { 0 };\n    int primes = RSA_DEFAULT_PRIME_NUM;\n#ifndef OPENSSL_NO_DH\n    typedef struct ffdh_params_st {\n        const char *name;\n        unsigned int nid;\n        unsigned int bits;\n    } FFDH_PARAMS;\n\n    static const FFDH_PARAMS ffdh_params[FFDH_NUM] = {\n        {\"ffdh2048\", NID_ffdhe2048, 2048},\n        {\"ffdh3072\", NID_ffdhe3072, 3072},\n        {\"ffdh4096\", NID_ffdhe4096, 4096},\n        {\"ffdh6144\", NID_ffdhe6144, 6144},\n        {\"ffdh8192\", NID_ffdhe8192, 8192}\n    };\n    uint8_t ffdh_doit[FFDH_NUM] = { 0 };\n\n#endif /* OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_DSA\n    static const unsigned int dsa_bits[DSA_NUM] = { 1024, 2048 };\n    uint8_t dsa_doit[DSA_NUM] = { 0 };\n#endif /* OPENSSL_NO_DSA */\n    /*\n     * We only test over the following curves as they are representative, To\n     * add tests over more curves, simply add the curve NID and curve name to\n     * the following arrays and increase the |ecdh_choices| and |ecdsa_choices|\n     * lists accordingly.\n     */\n    static const EC_CURVE ec_curves[EC_NUM] = {\n        /* Prime Curves */\n        {\"secp160r1\", NID_secp160r1, 160},\n        {\"nistp192\", NID_X9_62_prime192v1, 192},\n        {\"nistp224\", NID_secp224r1, 224},\n        {\"nistp256\", NID_X9_62_prime256v1, 256},\n        {\"nistp384\", NID_secp384r1, 384},\n        {\"nistp521\", NID_secp521r1, 521},\n#ifndef OPENSSL_NO_EC2M\n        /* Binary Curves */\n        {\"nistk163\", NID_sect163k1, 163},\n        {\"nistk233\", NID_sect233k1, 233},\n        {\"nistk283\", NID_sect283k1, 283},\n        {\"nistk409\", NID_sect409k1, 409},\n        {\"nistk571\", NID_sect571k1, 571},\n        {\"nistb163\", NID_sect163r2, 163},\n        {\"nistb233\", NID_sect233r1, 233},\n        {\"nistb283\", NID_sect283r1, 283},\n        {\"nistb409\", NID_sect409r1, 409},\n        {\"nistb571\", NID_sect571r1, 571},\n#endif\n        {\"brainpoolP256r1\", NID_brainpoolP256r1, 256},\n        {\"brainpoolP256t1\", NID_brainpoolP256t1, 256},\n        {\"brainpoolP384r1\", NID_brainpoolP384r1, 384},\n        {\"brainpoolP384t1\", NID_brainpoolP384t1, 384},\n        {\"brainpoolP512r1\", NID_brainpoolP512r1, 512},\n        {\"brainpoolP512t1\", NID_brainpoolP512t1, 512},\n#ifndef OPENSSL_NO_ECX\n        /* Other and ECDH only ones */\n        {\"X25519\", NID_X25519, 253},\n        {\"X448\", NID_X448, 448}\n#endif\n    };\n#ifndef OPENSSL_NO_ECX\n    static const EC_CURVE ed_curves[EdDSA_NUM] = {\n        /* EdDSA */\n        {\"Ed25519\", NID_ED25519, 253, 64},\n        {\"Ed448\", NID_ED448, 456, 114}\n    };\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n    static const EC_CURVE sm2_curves[SM2_NUM] = {\n        /* SM2 */\n        {\"CurveSM2\", NID_sm2, 256}\n    };\n    uint8_t sm2_doit[SM2_NUM] = { 0 };\n#endif\n    uint8_t ecdsa_doit[ECDSA_NUM] = { 0 };\n    uint8_t ecdh_doit[EC_NUM] = { 0 };\n#ifndef OPENSSL_NO_ECX\n    uint8_t eddsa_doit[EdDSA_NUM] = { 0 };\n#endif /* OPENSSL_NO_ECX */\n\n    uint8_t kems_doit[MAX_KEM_NUM] = { 0 };\n    uint8_t sigs_doit[MAX_SIG_NUM] = { 0 };\n\n    uint8_t do_kems = 0;\n    uint8_t do_sigs = 0;\n\n    /* checks declared curves against choices list. */\n#ifndef OPENSSL_NO_ECX\n    OPENSSL_assert(ed_curves[EdDSA_NUM - 1].nid == NID_ED448);\n    OPENSSL_assert(strcmp(eddsa_choices[EdDSA_NUM - 1].name, \"ed448\") == 0);\n\n    OPENSSL_assert(ec_curves[EC_NUM - 1].nid == NID_X448);\n    OPENSSL_assert(strcmp(ecdh_choices[EC_NUM - 1].name, \"ecdhx448\") == 0);\n\n    OPENSSL_assert(ec_curves[ECDSA_NUM - 1].nid == NID_brainpoolP512t1);\n    OPENSSL_assert(strcmp(ecdsa_choices[ECDSA_NUM - 1].name, \"ecdsabrp512t1\") == 0);\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    OPENSSL_assert(sm2_curves[SM2_NUM - 1].nid == NID_sm2);\n    OPENSSL_assert(strcmp(sm2_choices[SM2_NUM - 1].name, \"curveSM2\") == 0);\n#endif\n\n    prog = opt_init(argc, argv, speed_options);\n    while ((o = opt_next()) != OPT_EOF) {\n        switch (o) {\n        case OPT_EOF:\n        case OPT_ERR:\n opterr:\n            BIO_printf(bio_err, \"%s: Use -help for summary.\\n\", prog);\n            goto end;\n        case OPT_HELP:\n            opt_help(speed_options);\n            ret = 0;\n            goto end;\n        case OPT_ELAPSED:\n            usertime = 0;\n            break;\n        case OPT_EVP:\n            if (doit[D_EVP]) {\n                BIO_printf(bio_err, \"%s: -evp option cannot be used more than once\\n\", prog);\n                goto opterr;\n            }\n            ERR_set_mark();\n            if (!opt_cipher_silent(opt_arg(), &evp_cipher)) {\n                if (have_md(opt_arg()))\n                    evp_md_name = opt_arg();\n            }\n            if (evp_cipher == NULL && evp_md_name == NULL) {\n                ERR_clear_last_mark();\n                BIO_printf(bio_err,\n                           \"%s: %s is an unknown cipher or digest\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            ERR_pop_to_mark();\n            doit[D_EVP] = 1;\n            break;\n        case OPT_HMAC:\n            if (!have_md(opt_arg())) {\n                BIO_printf(bio_err, \"%s: %s is an unknown digest\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            evp_mac_mdname = opt_arg();\n            doit[D_HMAC] = 1;\n            break;\n        case OPT_CMAC:\n            if (!have_cipher(opt_arg())) {\n                BIO_printf(bio_err, \"%s: %s is an unknown cipher\\n\",\n                           prog, opt_arg());\n                goto end;\n            }\n            evp_mac_ciphername = opt_arg();\n            doit[D_EVP_CMAC] = 1;\n            break;\n        case OPT_DECRYPT:\n            decrypt = 1;\n            break;\n        case OPT_ENGINE:\n            /*\n             * In a forked execution, an engine might need to be\n             * initialised by each child process, not by the parent.\n             * So store the name here and run setup_engine() later on.\n             */\n            engine_id = opt_arg();\n            break;\n        case OPT_MULTI:\n#ifndef NO_FORK\n            multi = opt_int_arg();\n            if ((size_t)multi >= SIZE_MAX / sizeof(int)) {\n                BIO_printf(bio_err, \"%s: multi argument too large\\n\", prog);\n                return 0;\n            }\n#endif\n            break;\n        case OPT_ASYNCJOBS:\n#ifndef OPENSSL_NO_ASYNC\n            async_jobs = opt_int_arg();\n            if (async_jobs > 99999) {\n                BIO_printf(bio_err, \"%s: too many async_jobs\\n\", prog);\n                goto opterr;\n            }\n            if (!ASYNC_is_capable()) {\n                BIO_printf(bio_err,\n                           \"%s: async_jobs specified but async not supported\\n\",\n                           prog);\n                if (testmode)\n                    /* Return success in the testmode. */\n                    return 0;\n                goto opterr;\n            }\n#endif\n            break;\n        case OPT_MISALIGN:\n            misalign = opt_int_arg();\n            if (misalign > MISALIGN) {\n                BIO_printf(bio_err,\n                           \"%s: Maximum offset is %d\\n\", prog, MISALIGN);\n                goto opterr;\n            }\n            break;\n        case OPT_MR:\n            mr = 1;\n            break;\n        case OPT_MB:\n            multiblock = 1;\n#ifdef OPENSSL_NO_MULTIBLOCK\n            BIO_printf(bio_err,\n                       \"%s: -mb specified but multi-block support is disabled\\n\",\n                       prog);\n            goto end;\n#endif\n            break;\n        case OPT_R_CASES:\n            if (!opt_rand(o))\n                goto end;\n            break;\n        case OPT_PROV_CASES:\n            if (!opt_provider(o))\n                goto end;\n            break;\n        case OPT_CONFIG:\n            conf = app_load_config_modules(opt_arg());\n            if (conf == NULL)\n                goto end;\n            break;\n        case OPT_PRIMES:\n            primes = opt_int_arg();\n            break;\n        case OPT_SECONDS:\n            seconds.sym = seconds.rsa = seconds.dsa = seconds.ecdsa\n                        = seconds.ecdh = seconds.eddsa\n                        = seconds.sm2 = seconds.ffdh\n                        = seconds.kem = seconds.sig = opt_int_arg();\n            break;\n        case OPT_BYTES:\n            lengths_single = opt_int_arg();\n            lengths = &lengths_single;\n            size_num = 1;\n            break;\n        case OPT_AEAD:\n            aead = 1;\n            break;\n        case OPT_KEM:\n            do_kems = 1;\n            break;\n        case OPT_SIG:\n            do_sigs = 1;\n            break;\n        case OPT_MLOCK:\n            domlock = 1;\n#if !defined(_WIN32) && !defined(OPENSSL_SYS_LINUX)\n            BIO_printf(bio_err,\n                       \"%s: -mlock not supported on this platform\\n\",\n                       prog);\n            goto end;\n#endif\n            break;\n        case OPT_TESTMODE:\n            testmode = 1;\n            break;\n        }\n    }\n\n    /* find all KEMs currently available */\n    kem_stack = sk_EVP_KEM_new(kems_cmp);\n    EVP_KEM_do_all_provided(app_get0_libctx(), collect_kem, kem_stack);\n\n    kems_algs_len = 0;\n\n    for (idx = 0; idx < (unsigned int)sk_EVP_KEM_num(kem_stack); idx++) {\n        EVP_KEM *kem = sk_EVP_KEM_value(kem_stack, idx);\n\n        if (strcmp(EVP_KEM_get0_name(kem), \"RSA\") == 0) {\n            if (kems_algs_len + OSSL_NELEM(rsa_choices) >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < OSSL_NELEM(rsa_choices); i++) {\n                kems_doit[kems_algs_len] = 1;\n                kems_algname[kems_algs_len++] = OPENSSL_strdup(rsa_choices[i].name);\n            }\n        } else if (strcmp(EVP_KEM_get0_name(kem), \"EC\") == 0) {\n            if (kems_algs_len + 3 >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-256\");\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-384\");\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(\"ECP-521\");\n        } else {\n            if (kems_algs_len + 1 >= MAX_KEM_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many KEMs registered. Change MAX_KEM_NUM.\\n\");\n                goto end;\n            }\n            kems_doit[kems_algs_len] = 1;\n            kems_algname[kems_algs_len++] = OPENSSL_strdup(EVP_KEM_get0_name(kem));\n        }\n    }\n    sk_EVP_KEM_pop_free(kem_stack, EVP_KEM_free);\n    kem_stack = NULL;\n\n    /* find all SIGNATUREs currently available */\n    sig_stack = sk_EVP_SIGNATURE_new(signatures_cmp);\n    EVP_SIGNATURE_do_all_provided(app_get0_libctx(), collect_signatures, sig_stack);\n\n    sigs_algs_len = 0;\n\n    for (idx = 0; idx < (unsigned int)sk_EVP_SIGNATURE_num(sig_stack); idx++) {\n        EVP_SIGNATURE *s = sk_EVP_SIGNATURE_value(sig_stack, idx);\n        const char *sig_name = EVP_SIGNATURE_get0_name(s);\n\n        if (strcmp(sig_name, \"RSA\") == 0) {\n            if (sigs_algs_len + OSSL_NELEM(rsa_choices) >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < OSSL_NELEM(rsa_choices); i++) {\n                sigs_doit[sigs_algs_len] = 1;\n                sigs_algname[sigs_algs_len++] = OPENSSL_strdup(rsa_choices[i].name);\n            }\n        }\n#ifndef OPENSSL_NO_DSA\n        else if (strcmp(sig_name, \"DSA\") == 0) {\n            if (sigs_algs_len + DSA_NUM >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            for (i = 0; i < DSA_NUM; i++) {\n                sigs_doit[sigs_algs_len] = 1;\n                sigs_algname[sigs_algs_len++] = OPENSSL_strdup(dsa_choices[i].name);\n            }\n        }\n#endif /* OPENSSL_NO_DSA */\n        /* skipping these algs as tested elsewhere - and b/o setup is a pain */\n        else if (strcmp(sig_name, \"ED25519\") &&\n                 strcmp(sig_name, \"ED448\") &&\n                 strcmp(sig_name, \"ECDSA\") &&\n                 strcmp(sig_name, \"HMAC\") &&\n                 strcmp(sig_name, \"SIPHASH\") &&\n                 strcmp(sig_name, \"POLY1305\") &&\n                 strcmp(sig_name, \"CMAC\") &&\n                 strcmp(sig_name, \"SM2\")) { /* skip alg */\n            if (sigs_algs_len + 1 >= MAX_SIG_NUM) {\n                BIO_printf(bio_err,\n                           \"Too many signatures registered. Change MAX_SIG_NUM.\\n\");\n                goto end;\n            }\n            /* activate this provider algorithm */\n            sigs_doit[sigs_algs_len] = 1;\n            sigs_algname[sigs_algs_len++] = OPENSSL_strdup(sig_name);\n        }\n    }\n    sk_EVP_SIGNATURE_pop_free(sig_stack, EVP_SIGNATURE_free);\n    sig_stack = NULL;\n\n    /* Remaining arguments are algorithms. */\n    argc = opt_num_rest();\n    argv = opt_rest();\n\n    if (!app_RAND_load())\n        goto end;\n\n    for (; *argv; argv++) {\n        const char *algo = *argv;\n        int algo_found = 0;\n\n        if (opt_found(algo, doit_choices, &i)) {\n            doit[i] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"des\") == 0) {\n            doit[D_CBC_DES] = doit[D_EDE3_DES] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"sha\") == 0) {\n            doit[D_SHA1] = doit[D_SHA256] = doit[D_SHA512] = 1;\n            algo_found = 1;\n        }\n#ifndef OPENSSL_NO_DEPRECATED_3_0\n        if (strcmp(algo, \"openssl\") == 0) /* just for compatibility */\n            algo_found = 1;\n#endif\n        if (HAS_PREFIX(algo, \"rsa\")) {\n            if (algo[sizeof(\"rsa\") - 1] == '\\0') {\n                memset(rsa_doit, 1, sizeof(rsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, rsa_choices, &i)) {\n                rsa_doit[i] = 1;\n                algo_found = 1;\n            }\n        }\n#ifndef OPENSSL_NO_DH\n        if (HAS_PREFIX(algo, \"ffdh\")) {\n            if (algo[sizeof(\"ffdh\") - 1] == '\\0') {\n                memset(ffdh_doit, 1, sizeof(ffdh_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ffdh_choices, &i)) {\n                ffdh_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#endif\n#ifndef OPENSSL_NO_DSA\n        if (HAS_PREFIX(algo, \"dsa\")) {\n            if (algo[sizeof(\"dsa\") - 1] == '\\0') {\n                memset(dsa_doit, 1, sizeof(dsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, dsa_choices, &i)) {\n                dsa_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#endif\n        if (strcmp(algo, \"aes\") == 0) {\n            doit[D_CBC_128_AES] = doit[D_CBC_192_AES] = doit[D_CBC_256_AES] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"camellia\") == 0) {\n            doit[D_CBC_128_CML] = doit[D_CBC_192_CML] = doit[D_CBC_256_CML] = 1;\n            algo_found = 1;\n        }\n        if (HAS_PREFIX(algo, \"ecdsa\")) {\n            if (algo[sizeof(\"ecdsa\") - 1] == '\\0') {\n                memset(ecdsa_doit, 1, sizeof(ecdsa_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ecdsa_choices, &i)) {\n                ecdsa_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n        if (HAS_PREFIX(algo, \"ecdh\")) {\n            if (algo[sizeof(\"ecdh\") - 1] == '\\0') {\n                memset(ecdh_doit, 1, sizeof(ecdh_doit));\n                algo_found = 1;\n            }\n            if (opt_found(algo, ecdh_choices, &i)) {\n                ecdh_doit[i] = 2;\n                algo_found = 1;\n            }\n        }\n#ifndef OPENSSL_NO_ECX\n        if (strcmp(algo, \"eddsa\") == 0) {\n            memset(eddsa_doit, 1, sizeof(eddsa_doit));\n            algo_found = 1;\n        }\n        if (opt_found(algo, eddsa_choices, &i)) {\n            eddsa_doit[i] = 2;\n            algo_found = 1;\n        }\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        if (strcmp(algo, \"sm2\") == 0) {\n            memset(sm2_doit, 1, sizeof(sm2_doit));\n            algo_found = 1;\n        }\n        if (opt_found(algo, sm2_choices, &i)) {\n            sm2_doit[i] = 2;\n            algo_found = 1;\n        }\n#endif\n        if (kem_locate(algo, &idx)) {\n            kems_doit[idx]++;\n            do_kems = 1;\n            algo_found = 1;\n        }\n        if (sig_locate(algo, &idx)) {\n            sigs_doit[idx]++;\n            do_sigs = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"kmac\") == 0) {\n            doit[D_KMAC128] = doit[D_KMAC256] = 1;\n            algo_found = 1;\n        }\n        if (strcmp(algo, \"cmac\") == 0) {\n            doit[D_EVP_CMAC] = 1;\n            algo_found = 1;\n        }\n\n        if (!algo_found) {\n            BIO_printf(bio_err, \"%s: Unknown algorithm %s\\n\", prog, algo);\n            goto end;\n        }\n    }\n\n    /* Sanity checks */\n    if (aead) {\n        if (evp_cipher == NULL) {\n            BIO_printf(bio_err, \"-aead can be used only with an AEAD cipher\\n\");\n            goto end;\n        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &\n                     EVP_CIPH_FLAG_AEAD_CIPHER)) {\n            BIO_printf(bio_err, \"%s is not an AEAD cipher\\n\",\n                       EVP_CIPHER_get0_name(evp_cipher));\n            goto end;\n        }\n    }\n    if (kems_algs_len > 0) {\n        int maxcnt = get_max(kems_doit, kems_algs_len);\n\n        if (maxcnt > 1) {\n            /* some algs explicitly selected */\n            for (i = 0; i < kems_algs_len; i++) {\n                /* disable the rest */\n                kems_doit[i]--;\n            }\n        }\n    }\n    if (sigs_algs_len > 0) {\n        int maxcnt = get_max(sigs_doit, sigs_algs_len);\n\n        if (maxcnt > 1) {\n            /* some algs explicitly selected */\n            for (i = 0; i < sigs_algs_len; i++) {\n                /* disable the rest */\n                sigs_doit[i]--;\n            }\n        }\n    }\n    if (multiblock) {\n        if (evp_cipher == NULL) {\n            BIO_printf(bio_err, \"-mb can be used only with a multi-block\"\n                                \" capable cipher\\n\");\n            goto end;\n        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &\n                     EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {\n            BIO_printf(bio_err, \"%s is not a multi-block capable\\n\",\n                       EVP_CIPHER_get0_name(evp_cipher));\n            goto end;\n        } else if (async_jobs > 0) {\n            BIO_printf(bio_err, \"Async mode is not supported with -mb\");\n            goto end;\n        }\n    }\n\n    /* Initialize the job pool if async mode is enabled */\n    if (async_jobs > 0) {\n        async_init = ASYNC_init_thread(async_jobs, async_jobs);\n        if (!async_init) {\n            BIO_printf(bio_err, \"Error creating the ASYNC job pool\\n\");\n            goto end;\n        }\n    }\n\n    loopargs_len = (async_jobs == 0 ? 1 : async_jobs);\n    loopargs =\n        app_malloc(loopargs_len * sizeof(loopargs_t), \"array of loopargs\");\n    memset(loopargs, 0, loopargs_len * sizeof(loopargs_t));\n\n    buflen = lengths[size_num - 1];\n    if (buflen < 36)    /* size of random vector in RSA benchmark */\n        buflen = 36;\n    if (INT_MAX - (MAX_MISALIGNMENT + 1) < buflen) {\n        BIO_printf(bio_err, \"Error: buffer size too large\\n\");\n        goto end;\n    }\n    buflen += MAX_MISALIGNMENT + 1;\n    for (i = 0; i < loopargs_len; i++) {\n        if (async_jobs > 0) {\n            loopargs[i].wait_ctx = ASYNC_WAIT_CTX_new();\n            if (loopargs[i].wait_ctx == NULL) {\n                BIO_printf(bio_err, \"Error creating the ASYNC_WAIT_CTX\\n\");\n                goto end;\n            }\n        }\n\n        loopargs[i].buf_malloc = app_malloc(buflen, \"input buffer\");\n        loopargs[i].buf2_malloc = app_malloc(buflen, \"input buffer\");\n\n        /* Align the start of buffers on a 64 byte boundary */\n        loopargs[i].buf = loopargs[i].buf_malloc + misalign;\n        loopargs[i].buf2 = loopargs[i].buf2_malloc + misalign;\n        loopargs[i].buflen = buflen - misalign;\n        loopargs[i].sigsize = buflen - misalign;\n        loopargs[i].secret_a = app_malloc(MAX_ECDH_SIZE, \"ECDH secret a\");\n        loopargs[i].secret_b = app_malloc(MAX_ECDH_SIZE, \"ECDH secret b\");\n#ifndef OPENSSL_NO_DH\n        loopargs[i].secret_ff_a = app_malloc(MAX_FFDH_SIZE, \"FFDH secret a\");\n        loopargs[i].secret_ff_b = app_malloc(MAX_FFDH_SIZE, \"FFDH secret b\");\n#endif\n    }\n\n#ifndef NO_FORK\n    if (multi && do_multi(multi, size_num))\n        goto show_res;\n#endif\n\n    for (i = 0; i < loopargs_len; ++i) {\n        if (domlock) {\n#if defined(_WIN32)\n            (void)VirtualLock(loopargs[i].buf_malloc, buflen);\n            (void)VirtualLock(loopargs[i].buf2_malloc, buflen);\n#elif defined(OPENSSL_SYS_LINUX)\n            (void)mlock(loopargs[i].buf_malloc, buflen);\n            (void)mlock(loopargs[i].buf_malloc, buflen);\n#endif\n        }\n        memset(loopargs[i].buf_malloc, 0, buflen);\n        memset(loopargs[i].buf2_malloc, 0, buflen);\n    }\n\n    /* Initialize the engine after the fork */\n    e = setup_engine(engine_id, 0);\n\n    /* No parameters; turn on everything. */\n    if (argc == 0 && !doit[D_EVP] && !doit[D_HMAC]\n        && !doit[D_EVP_CMAC] && !do_kems && !do_sigs) {\n        memset(doit, 1, sizeof(doit));\n        doit[D_EVP] = doit[D_EVP_CMAC] = 0;\n        ERR_set_mark();\n        for (i = D_MD2; i <= D_WHIRLPOOL; i++) {\n            if (!have_md(names[i]))\n                doit[i] = 0;\n        }\n        for (i = D_CBC_DES; i <= D_CBC_256_CML; i++) {\n            if (!have_cipher(names[i]))\n                doit[i] = 0;\n        }\n        if ((mac = EVP_MAC_fetch(app_get0_libctx(), \"GMAC\",\n                                 app_get0_propq())) != NULL) {\n            EVP_MAC_free(mac);\n            mac = NULL;\n        } else {\n            doit[D_GHASH] = 0;\n        }\n        if ((mac = EVP_MAC_fetch(app_get0_libctx(), \"HMAC\",\n                                 app_get0_propq())) != NULL) {\n            EVP_MAC_free(mac);\n            mac = NULL;\n        } else {\n            doit[D_HMAC] = 0;\n        }\n        ERR_pop_to_mark();\n        memset(rsa_doit, 1, sizeof(rsa_doit));\n#ifndef OPENSSL_NO_DH\n        memset(ffdh_doit, 1, sizeof(ffdh_doit));\n#endif\n#ifndef OPENSSL_NO_DSA\n        memset(dsa_doit, 1, sizeof(dsa_doit));\n#endif\n#ifndef OPENSSL_NO_ECX\n        memset(ecdsa_doit, 1, sizeof(ecdsa_doit));\n        memset(ecdh_doit, 1, sizeof(ecdh_doit));\n        memset(eddsa_doit, 1, sizeof(eddsa_doit));\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        memset(sm2_doit, 1, sizeof(sm2_doit));\n#endif\n        memset(kems_doit, 1, sizeof(kems_doit));\n        do_kems = 1;\n        memset(sigs_doit, 1, sizeof(sigs_doit));\n        do_sigs = 1;\n    }\n    for (i = 0; i < ALGOR_NUM; i++)\n        if (doit[i])\n            pr_header++;\n\n    if (usertime == 0 && !mr)\n        BIO_printf(bio_err,\n                   \"You have chosen to measure elapsed time \"\n                   \"instead of user CPU time.\\n\");\n\n#if SIGALRM > 0\n    signal(SIGALRM, alarmed);\n#endif\n\n    if (doit[D_MD2]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD2], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MD2_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD2, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MDC2]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MDC2], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MDC2_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MDC2, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MD4]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD4], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_MD4_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD4, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_MD5]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_MD5], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, MD5_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_MD5, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA1]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA1], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA1_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA1, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA256]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA256], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA256_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA256, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_SHA512]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_SHA512], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SHA512_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_SHA512, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_WHIRLPOOL]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_WHIRLPOOL], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, WHIRLPOOL_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_WHIRLPOOL, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_RMD160]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_RMD160], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Digest_RMD160_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_RMD160, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n    }\n\n    if (doit[D_HMAC]) {\n        static const char hmac_key[] = \"This is a key...\";\n        int len = strlen(hmac_key);\n        size_t hmac_name_len = sizeof(\"hmac()\") + strlen(evp_mac_mdname);\n        OSSL_PARAM params[3];\n\n        if (evp_mac_mdname == NULL)\n            goto end;\n        evp_hmac_name = app_malloc(hmac_name_len, \"HMAC name\");\n        BIO_snprintf(evp_hmac_name, hmac_name_len, \"hmac(%s)\", evp_mac_mdname);\n        names[D_HMAC] = evp_hmac_name;\n\n        params[0] =\n            OSSL_PARAM_construct_utf8_string(OSSL_MAC_PARAM_DIGEST,\n                                             evp_mac_mdname, 0);\n        params[1] =\n            OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                              (char *)hmac_key, len);\n        params[2] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"HMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_HMAC], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, HMAC_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_HMAC, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_CBC_DES]) {\n        int st = 1;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ctx = init_evp_cipher_ctx(\"des-cbc\", deskey,\n                                                  sizeof(deskey) / 3);\n            st = loopargs[i].ctx != NULL;\n        }\n        algindex = D_CBC_DES;\n        for (testnum = 0; st && testnum < size_num; testnum++) {\n            if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                break;\n            print_message(names[D_CBC_DES], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_CBC_DES, testnum, count, d);\n        }\n        for (i = 0; i < loopargs_len; i++)\n            EVP_CIPHER_CTX_free(loopargs[i].ctx);\n    }\n\n    if (doit[D_EDE3_DES]) {\n        int st = 1;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ctx = init_evp_cipher_ctx(\"des-ede3-cbc\", deskey,\n                                                  sizeof(deskey));\n            st = loopargs[i].ctx != NULL;\n        }\n        algindex = D_EDE3_DES;\n        for (testnum = 0; st && testnum < size_num; testnum++) {\n            if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                break;\n            print_message(names[D_EDE3_DES], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_EDE3_DES, testnum, count, d);\n        }\n        for (i = 0; i < loopargs_len; i++)\n            EVP_CIPHER_CTX_free(loopargs[i].ctx);\n    }\n\n    for (k = 0; k < 3; k++) {\n        algindex = D_CBC_128_AES + k;\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16 + k * 8;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n\n    for (k = 0; k < 3; k++) {\n        algindex = D_CBC_128_CML + k;\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16 + k * 8;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n\n    for (algindex = D_RC4; algindex <= D_CBC_CAST; algindex++) {\n        if (doit[algindex]) {\n            int st = 1;\n\n            keylen = 16;\n            for (i = 0; st && i < loopargs_len; i++) {\n                loopargs[i].ctx = init_evp_cipher_ctx(names[algindex],\n                                                      key32, keylen);\n                st = loopargs[i].ctx != NULL;\n            }\n\n            for (testnum = 0; st && testnum < size_num; testnum++) {\n                if (!check_block_size(loopargs[0].ctx, lengths[testnum]))\n                    break;\n                print_message(names[algindex], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count =\n                    run_benchmark(async_jobs, EVP_Cipher_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(algindex, testnum, count, d);\n            }\n            for (i = 0; i < loopargs_len; i++)\n                EVP_CIPHER_CTX_free(loopargs[i].ctx);\n        }\n    }\n    if (doit[D_GHASH]) {\n        static const char gmac_iv[] = \"0123456789ab\";\n        OSSL_PARAM params[4];\n\n        params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_CIPHER,\n                                                     \"aes-128-gcm\", 0);\n        params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_IV,\n                                                      (char *)gmac_iv,\n                                                      sizeof(gmac_iv) - 1);\n        params[2] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 16);\n        params[3] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"GMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        /* b/c of the definition of GHASH_loop(), init() calls are needed here */\n        for (i = 0; i < loopargs_len; i++) {\n            if (!EVP_MAC_init(loopargs[i].mctx, NULL, 0, NULL))\n                goto end;\n        }\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_GHASH], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, GHASH_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_GHASH, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_RAND]) {\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_RAND], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, RAND_bytes_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_RAND, testnum, count, d);\n        }\n    }\n\n    /*-\n     * There are three scenarios for D_EVP:\n     * 1- Using authenticated encryption (AE) e.g. CCM, GCM, OCB etc.\n     * 2- Using AE + associated data (AD) i.e. AEAD using CCM, GCM, OCB etc.\n     * 3- Not using AE or AD e.g. ECB, CBC, CFB etc.\n     */\n    if (doit[D_EVP]) {\n        if (evp_cipher != NULL) {\n            int (*loopfunc) (void *);\n            int outlen = 0;\n            unsigned int ae_mode = 0;\n\n            if (multiblock && (EVP_CIPHER_get_flags(evp_cipher)\n                               & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK)) {\n                multiblock_speed(evp_cipher, lengths_single, &seconds);\n                ret = 0;\n                goto end;\n            }\n\n            names[D_EVP] = EVP_CIPHER_get0_name(evp_cipher);\n\n            mode_op = EVP_CIPHER_get_mode(evp_cipher);\n\n            if (aead) {\n                if (lengths == lengths_list) {\n                    lengths = aead_lengths_list;\n                    size_num = OSSL_NELEM(aead_lengths_list);\n                }\n            }\n            if (mode_op == EVP_CIPH_GCM_MODE\n                || mode_op == EVP_CIPH_CCM_MODE\n                || mode_op == EVP_CIPH_OCB_MODE\n                || mode_op == EVP_CIPH_SIV_MODE\n                || mode_op == EVP_CIPH_GCM_SIV_MODE) {\n                ae_mode = 1;\n                if (decrypt)\n                    loopfunc = EVP_Update_loop_aead_dec;\n                else\n                    loopfunc = EVP_Update_loop_aead_enc;\n            } else {\n                loopfunc = EVP_Update_loop;\n            }\n\n            for (testnum = 0; testnum < size_num; testnum++) {\n                print_message(names[D_EVP], lengths[testnum], seconds.sym);\n\n                for (k = 0; k < loopargs_len; k++) {\n                    loopargs[k].ctx = EVP_CIPHER_CTX_new();\n                    if (loopargs[k].ctx == NULL) {\n                        BIO_printf(bio_err, \"\\nEVP_CIPHER_CTX_new failure\\n\");\n                        exit(1);\n                    }\n\n                    /*\n                     * For AE modes, we must first encrypt the data to get\n                     * a valid tag that enables us to decrypt. If we don't\n                     * encrypt first, we won't have a valid tag that enables\n                     * authenticity and hence decryption will fail.\n                     */\n                    if (!EVP_CipherInit_ex(loopargs[k].ctx, evp_cipher, NULL,\n                                           NULL, NULL, ae_mode ? 1 : !decrypt)) {\n                        BIO_printf(bio_err, \"\\nCouldn't init the context\\n\");\n                        dofail();\n                        exit(1);\n                    }\n\n                    /* Padding isn't needed */\n                    EVP_CIPHER_CTX_set_padding(loopargs[k].ctx, 0);\n\n                    keylen = EVP_CIPHER_CTX_get_key_length(loopargs[k].ctx);\n                    loopargs[k].key = app_malloc(keylen, \"evp_cipher key\");\n                    EVP_CIPHER_CTX_rand_key(loopargs[k].ctx, loopargs[k].key);\n\n                    if (!ae_mode) {\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, NULL, NULL,\n                                               loopargs[k].key, NULL, -1)) {\n                            BIO_printf(bio_err, \"\\nFailed to set the key\\n\");\n                            dofail();\n                            exit(1);\n                        }\n                    } else if (mode_op == EVP_CIPH_SIV_MODE\n                               || mode_op == EVP_CIPH_GCM_SIV_MODE) {\n                        EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                            EVP_CTRL_SET_SPEED, 1, NULL);\n                    }\n                    if (ae_mode && decrypt) {\n                        /* Set length of iv (Doesn't apply to SIV mode) */\n                        if (mode_op != EVP_CIPH_SIV_MODE) {\n                            if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                     EVP_CTRL_AEAD_SET_IVLEN,\n                                                     aead_ivlen, NULL)) {\n                                BIO_printf(bio_err, \"\\nFailed to set iv length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        /* Set tag_len (Not for GCM/SIV at encryption stage) */\n                        if (mode_op != EVP_CIPH_GCM_MODE\n                            && mode_op != EVP_CIPH_SIV_MODE\n                            && mode_op != EVP_CIPH_GCM_SIV_MODE) {\n                            if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                     EVP_CTRL_AEAD_SET_TAG,\n                                                     TAG_LEN, NULL)) {\n                                BIO_printf(bio_err,\n                                           \"\\nFailed to set tag length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, NULL, NULL,\n                                               loopargs[k].key, aead_iv, -1)) {\n                            BIO_printf(bio_err, \"\\nFailed to set the key\\n\");\n                            dofail();\n                            exit(1);\n                        }\n                        /* Set total length of input. Only required for CCM */\n                        if (mode_op == EVP_CIPH_CCM_MODE) {\n                            if (!EVP_EncryptUpdate(loopargs[k].ctx, NULL,\n                                                   &outlen, NULL,\n                                                   lengths[testnum])) {\n                                BIO_printf(bio_err,\n                                           \"\\nCouldn't set input text length\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (aead) {\n                            if (!EVP_EncryptUpdate(loopargs[k].ctx, NULL,\n                                                   &outlen, aad, sizeof(aad))) {\n                                BIO_printf(bio_err,\n                                           \"\\nCouldn't insert AAD when encrypting\\n\");\n                                dofail();\n                                exit(1);\n                            }\n                        }\n                        if (!EVP_EncryptUpdate(loopargs[k].ctx, loopargs[k].buf,\n                                               &outlen, loopargs[k].buf,\n                                               lengths[testnum])) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed to to encrypt the data\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        if (!EVP_EncryptFinal_ex(loopargs[k].ctx,\n                                                 loopargs[k].buf, &outlen)) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed finalize the encryption\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        if (!EVP_CIPHER_CTX_ctrl(loopargs[k].ctx, EVP_CTRL_AEAD_GET_TAG,\n                                                 TAG_LEN, &loopargs[k].tag)) {\n                            BIO_printf(bio_err, \"\\nFailed to get the tag\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        EVP_CIPHER_CTX_free(loopargs[k].ctx);\n                        loopargs[k].ctx = EVP_CIPHER_CTX_new();\n                        if (loopargs[k].ctx == NULL) {\n                            BIO_printf(bio_err,\n                                       \"\\nEVP_CIPHER_CTX_new failure\\n\");\n                            exit(1);\n                        }\n                        if (!EVP_CipherInit_ex(loopargs[k].ctx, evp_cipher,\n                                               NULL, NULL, NULL, 0)) {\n                            BIO_printf(bio_err,\n                                       \"\\nFailed initializing the context\\n\");\n                            dofail();\n                            exit(1);\n                        }\n\n                        EVP_CIPHER_CTX_set_padding(loopargs[k].ctx, 0);\n\n                        /* GCM-SIV/SIV only allows for a single Update operation */\n                        if (mode_op == EVP_CIPH_SIV_MODE\n                            || mode_op == EVP_CIPH_GCM_SIV_MODE)\n                            EVP_CIPHER_CTX_ctrl(loopargs[k].ctx,\n                                                EVP_CTRL_SET_SPEED, 1, NULL);\n                    }\n                }\n\n                Time_F(START);\n                count = run_benchmark(async_jobs, loopfunc, loopargs);\n                d = Time_F(STOP);\n                for (k = 0; k < loopargs_len; k++) {\n                    OPENSSL_clear_free(loopargs[k].key, keylen);\n                    EVP_CIPHER_CTX_free(loopargs[k].ctx);\n                }\n                print_result(D_EVP, testnum, count, d);\n            }\n        } else if (evp_md_name != NULL) {\n            names[D_EVP] = evp_md_name;\n\n            for (testnum = 0; testnum < size_num; testnum++) {\n                print_message(names[D_EVP], lengths[testnum], seconds.sym);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EVP_Digest_md_loop, loopargs);\n                d = Time_F(STOP);\n                print_result(D_EVP, testnum, count, d);\n                if (count < 0)\n                    break;\n            }\n        }\n    }\n\n    if (doit[D_EVP_CMAC]) {\n        size_t len = sizeof(\"cmac()\") + strlen(evp_mac_ciphername);\n        OSSL_PARAM params[3];\n        EVP_CIPHER *cipher = NULL;\n\n        if (!opt_cipher(evp_mac_ciphername, &cipher))\n            goto end;\n\n        keylen = EVP_CIPHER_get_key_length(cipher);\n        EVP_CIPHER_free(cipher);\n        if (keylen <= 0 || keylen > (int)sizeof(key32)) {\n            BIO_printf(bio_err, \"\\nRequested CMAC cipher with unsupported key length.\\n\");\n            goto end;\n        }\n        evp_cmac_name = app_malloc(len, \"CMAC name\");\n        BIO_snprintf(evp_cmac_name, len, \"cmac(%s)\", evp_mac_ciphername);\n        names[D_EVP_CMAC] = evp_cmac_name;\n\n        params[0] = OSSL_PARAM_construct_utf8_string(OSSL_ALG_PARAM_CIPHER,\n                                                     evp_mac_ciphername, 0);\n        params[1] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (char *)key32, keylen);\n        params[2] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"CMAC\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_EVP_CMAC], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, CMAC_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_EVP_CMAC, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_KMAC128]) {\n        OSSL_PARAM params[2];\n\n        params[0] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 16);\n        params[1] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"KMAC-128\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_KMAC128], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, KMAC128_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_KMAC128, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    if (doit[D_KMAC256]) {\n        OSSL_PARAM params[2];\n\n        params[0] = OSSL_PARAM_construct_octet_string(OSSL_MAC_PARAM_KEY,\n                                                      (void *)key32, 32);\n        params[1] = OSSL_PARAM_construct_end();\n\n        if (mac_setup(\"KMAC-256\", &mac, params, loopargs, loopargs_len) < 1)\n            goto end;\n        for (testnum = 0; testnum < size_num; testnum++) {\n            print_message(names[D_KMAC256], lengths[testnum], seconds.sym);\n            Time_F(START);\n            count = run_benchmark(async_jobs, KMAC256_loop, loopargs);\n            d = Time_F(STOP);\n            print_result(D_KMAC256, testnum, count, d);\n            if (count < 0)\n                break;\n        }\n        mac_teardown(&mac, loopargs, loopargs_len);\n    }\n\n    for (i = 0; i < loopargs_len; i++)\n        if (RAND_bytes(loopargs[i].buf, 36) <= 0)\n            goto end;\n\n    for (testnum = 0; testnum < RSA_NUM; testnum++) {\n        EVP_PKEY *rsa_key = NULL;\n        int st = 0;\n\n        if (!rsa_doit[testnum])\n            continue;\n\n        if (primes > RSA_DEFAULT_PRIME_NUM) {\n            /* we haven't set keys yet,  generate multi-prime RSA keys */\n            bn = BN_new();\n            st = bn != NULL\n                && BN_set_word(bn, RSA_F4)\n                && init_gen_str(&genctx, \"RSA\", NULL, 0, NULL, NULL)\n                && EVP_PKEY_CTX_set_rsa_keygen_bits(genctx, rsa_keys[testnum].bits) > 0\n                && EVP_PKEY_CTX_set1_rsa_keygen_pubexp(genctx, bn) > 0\n                && EVP_PKEY_CTX_set_rsa_keygen_primes(genctx, primes) > 0\n                && EVP_PKEY_keygen(genctx, &rsa_key);\n            BN_free(bn);\n            bn = NULL;\n            EVP_PKEY_CTX_free(genctx);\n            genctx = NULL;\n        } else {\n            const unsigned char *p = rsa_keys[testnum].data;\n\n            st = (rsa_key = d2i_PrivateKey(EVP_PKEY_RSA, NULL, &p,\n                                           rsa_keys[testnum].length)) != NULL;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].rsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].rsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].rsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA sign setup failure.  No RSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"private\", \"rsa sign\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R1:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits private RSA sign ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key,\n                                                                   NULL);\n            if (loopargs[i].rsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].rsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].rsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA verify setup failure.  No RSA verify will be done.\\n\");\n            dofail();\n            rsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"public\", \"rsa verify\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R2:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits public RSA verify ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][1] = (double)count / d;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_encrypt_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            loopargs[i].encsize = loopargs[i].buflen;\n            if (loopargs[i].rsa_encrypt_ctx[testnum] == NULL\n                || EVP_PKEY_encrypt_init(loopargs[i].rsa_encrypt_ctx[testnum]) <= 0\n                || EVP_PKEY_encrypt(loopargs[i].rsa_encrypt_ctx[testnum],\n                                    loopargs[i].buf2,\n                                    &loopargs[i].encsize,\n                                    loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA encrypt setup failure.  No RSA encrypt will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"public\", \"rsa encrypt\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_encrypt_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R3:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits public RSA encrypt ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].rsa_decrypt_ctx[testnum] = EVP_PKEY_CTX_new(rsa_key, NULL);\n            declen = loopargs[i].buflen;\n            if (loopargs[i].rsa_decrypt_ctx[testnum] == NULL\n                || EVP_PKEY_decrypt_init(loopargs[i].rsa_decrypt_ctx[testnum]) <= 0\n                || EVP_PKEY_decrypt(loopargs[i].rsa_decrypt_ctx[testnum],\n                                    loopargs[i].buf,\n                                    &declen,\n                                    loopargs[i].buf2,\n                                    loopargs[i].encsize) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"RSA decrypt setup failure.  No RSA decrypt will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"private\", \"rsa decrypt\",\n                               rsa_keys[testnum].bits, seconds.rsa);\n            /* RSA_blinding_on(rsa_key[testnum],NULL); */\n            Time_F(START);\n            count = run_benchmark(async_jobs, RSA_decrypt_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R4:%ld:%d:%.2f\\n\"\n                       : \"%ld %u bits private RSA decrypt ops in %.2fs\\n\",\n                       count, rsa_keys[testnum].bits, d);\n            rsa_results[testnum][3] = (double)count / d;\n            op_count = count;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(rsa_doit, testnum);\n        }\n        EVP_PKEY_free(rsa_key);\n    }\n\n#ifndef OPENSSL_NO_DSA\n    for (testnum = 0; testnum < DSA_NUM; testnum++) {\n        EVP_PKEY *dsa_key = NULL;\n        int st;\n\n        if (!dsa_doit[testnum])\n            continue;\n\n        st = (dsa_key = get_dsa(dsa_bits[testnum])) != NULL;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].dsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(dsa_key,\n                                                                 NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].dsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].dsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].dsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"DSA sign setup failure.  No DSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"sign\", \"dsa\",\n                               dsa_bits[testnum], seconds.dsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, DSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R5:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits DSA sign ops in %.2fs\\n\",\n                       count, dsa_bits[testnum], d);\n            dsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].dsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(dsa_key,\n                                                                   NULL);\n            if (loopargs[i].dsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].dsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].dsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 36) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"DSA verify setup failure.  No DSA verify will be done.\\n\");\n            dofail();\n            dsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"verify\", \"dsa\",\n                               dsa_bits[testnum], seconds.dsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, DSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R6:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits DSA verify ops in %.2fs\\n\",\n                       count, dsa_bits[testnum], d);\n            dsa_results[testnum][1] = (double)count / d;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(dsa_doit, testnum);\n        }\n        EVP_PKEY_free(dsa_key);\n    }\n#endif /* OPENSSL_NO_DSA */\n\n    for (testnum = 0; testnum < ECDSA_NUM; testnum++) {\n        EVP_PKEY *ecdsa_key = NULL;\n        int st;\n\n        if (!ecdsa_doit[testnum])\n            continue;\n\n        st = (ecdsa_key = get_ecdsa(&ec_curves[testnum])) != NULL;\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ecdsa_sign_ctx[testnum] = EVP_PKEY_CTX_new(ecdsa_key,\n                                                                   NULL);\n            loopargs[i].sigsize = loopargs[i].buflen;\n            if (loopargs[i].ecdsa_sign_ctx[testnum] == NULL\n                || EVP_PKEY_sign_init(loopargs[i].ecdsa_sign_ctx[testnum]) <= 0\n                || EVP_PKEY_sign(loopargs[i].ecdsa_sign_ctx[testnum],\n                                 loopargs[i].buf2,\n                                 &loopargs[i].sigsize,\n                                 loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"ECDSA sign setup failure.  No ECDSA sign will be done.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            pkey_print_message(\"sign\", \"ecdsa\",\n                               ec_curves[testnum].bits, seconds.ecdsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, ECDSA_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R7:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits ECDSA sign ops in %.2fs\\n\",\n                       count, ec_curves[testnum].bits, d);\n            ecdsa_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        for (i = 0; st && i < loopargs_len; i++) {\n            loopargs[i].ecdsa_verify_ctx[testnum] = EVP_PKEY_CTX_new(ecdsa_key,\n                                                                     NULL);\n            if (loopargs[i].ecdsa_verify_ctx[testnum] == NULL\n                || EVP_PKEY_verify_init(loopargs[i].ecdsa_verify_ctx[testnum]) <= 0\n                || EVP_PKEY_verify(loopargs[i].ecdsa_verify_ctx[testnum],\n                                   loopargs[i].buf2,\n                                   loopargs[i].sigsize,\n                                   loopargs[i].buf, 20) <= 0)\n                st = 0;\n        }\n        if (!st) {\n            BIO_printf(bio_err,\n                       \"ECDSA verify setup failure.  No ECDSA verify will be done.\\n\");\n            dofail();\n            ecdsa_doit[testnum] = 0;\n        } else {\n            pkey_print_message(\"verify\", \"ecdsa\",\n                               ec_curves[testnum].bits, seconds.ecdsa);\n            Time_F(START);\n            count = run_benchmark(async_jobs, ECDSA_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R8:%ld:%u:%.2f\\n\"\n                       : \"%ld %u bits ECDSA verify ops in %.2fs\\n\",\n                       count, ec_curves[testnum].bits, d);\n            ecdsa_results[testnum][1] = (double)count / d;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ecdsa_doit, testnum);\n        }\n        EVP_PKEY_free(ecdsa_key);\n    }\n\n    for (testnum = 0; testnum < EC_NUM; testnum++) {\n        int ecdh_checks = 1;\n\n        if (!ecdh_doit[testnum])\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY_CTX *test_ctx = NULL;\n            EVP_PKEY_CTX *ctx = NULL;\n            EVP_PKEY *key_A = NULL;\n            EVP_PKEY *key_B = NULL;\n            size_t outlen;\n            size_t test_outlen;\n\n            if ((key_A = get_ecdsa(&ec_curves[testnum])) == NULL /* generate secret key A */\n                || (key_B = get_ecdsa(&ec_curves[testnum])) == NULL /* generate secret key B */\n                || (ctx = EVP_PKEY_CTX_new(key_A, NULL)) == NULL /* derivation ctx from skeyA */\n                || EVP_PKEY_derive_init(ctx) <= 0 /* init derivation ctx */\n                || EVP_PKEY_derive_set_peer(ctx, key_B) <= 0 /* set peer pubkey in ctx */\n                || EVP_PKEY_derive(ctx, NULL, &outlen) <= 0 /* determine max length */\n                || outlen == 0 /* ensure outlen is a valid size */\n                || outlen > MAX_ECDH_SIZE /* avoid buffer overflow */) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH key generation failure.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            /*\n             * Here we perform a test run, comparing the output of a*B and b*A;\n             * we try this here and assume that further EVP_PKEY_derive calls\n             * never fail, so we can skip checks in the actually benchmarked\n             * code, for maximum performance.\n             */\n            if ((test_ctx = EVP_PKEY_CTX_new(key_B, NULL)) == NULL /* test ctx from skeyB */\n                || EVP_PKEY_derive_init(test_ctx) <= 0 /* init derivation test_ctx */\n                || EVP_PKEY_derive_set_peer(test_ctx, key_A) <= 0 /* set peer pubkey in test_ctx */\n                || EVP_PKEY_derive(test_ctx, NULL, &test_outlen) <= 0 /* determine max length */\n                || EVP_PKEY_derive(ctx, loopargs[i].secret_a, &outlen) <= 0 /* compute a*B */\n                || EVP_PKEY_derive(test_ctx, loopargs[i].secret_b, &test_outlen) <= 0 /* compute b*A */\n                || test_outlen != outlen /* compare output length */) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH computation failure.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            /* Compare the computation results: CRYPTO_memcmp() returns 0 if equal */\n            if (CRYPTO_memcmp(loopargs[i].secret_a,\n                              loopargs[i].secret_b, outlen)) {\n                ecdh_checks = 0;\n                BIO_printf(bio_err, \"ECDH computations don't match.\\n\");\n                dofail();\n                op_count = 1;\n                break;\n            }\n\n            loopargs[i].ecdh_ctx[testnum] = ctx;\n            loopargs[i].outlen[testnum] = outlen;\n\n            EVP_PKEY_free(key_A);\n            EVP_PKEY_free(key_B);\n            EVP_PKEY_CTX_free(test_ctx);\n            test_ctx = NULL;\n        }\n        if (ecdh_checks != 0) {\n            pkey_print_message(\"\", \"ecdh\",\n                               ec_curves[testnum].bits, seconds.ecdh);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, ECDH_EVP_derive_key_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R9:%ld:%d:%.2f\\n\" :\n                       \"%ld %u-bits ECDH ops in %.2fs\\n\", count,\n                       ec_curves[testnum].bits, d);\n            ecdh_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ecdh_doit, testnum);\n        }\n    }\n\n#ifndef OPENSSL_NO_ECX\n    for (testnum = 0; testnum < EdDSA_NUM; testnum++) {\n        int st = 1;\n        EVP_PKEY *ed_pkey = NULL;\n        EVP_PKEY_CTX *ed_pctx = NULL;\n\n        if (!eddsa_doit[testnum])\n            continue;           /* Ignore Curve */\n        for (i = 0; i < loopargs_len; i++) {\n            loopargs[i].eddsa_ctx[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].eddsa_ctx[testnum] == NULL) {\n                st = 0;\n                break;\n            }\n            loopargs[i].eddsa_ctx2[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].eddsa_ctx2[testnum] == NULL) {\n                st = 0;\n                break;\n            }\n\n            if ((ed_pctx = EVP_PKEY_CTX_new_id(ed_curves[testnum].nid,\n                                               NULL)) == NULL\n                || EVP_PKEY_keygen_init(ed_pctx) <= 0\n                || EVP_PKEY_keygen(ed_pctx, &ed_pkey) <= 0) {\n                st = 0;\n                EVP_PKEY_CTX_free(ed_pctx);\n                break;\n            }\n            EVP_PKEY_CTX_free(ed_pctx);\n\n            if (!EVP_DigestSignInit(loopargs[i].eddsa_ctx[testnum], NULL, NULL,\n                                    NULL, ed_pkey)) {\n                st = 0;\n                EVP_PKEY_free(ed_pkey);\n                break;\n            }\n            if (!EVP_DigestVerifyInit(loopargs[i].eddsa_ctx2[testnum], NULL,\n                                      NULL, NULL, ed_pkey)) {\n                st = 0;\n                EVP_PKEY_free(ed_pkey);\n                break;\n            }\n\n            EVP_PKEY_free(ed_pkey);\n            ed_pkey = NULL;\n        }\n        if (st == 0) {\n            BIO_printf(bio_err, \"EdDSA failure.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            for (i = 0; i < loopargs_len; i++) {\n                /* Perform EdDSA signature test */\n                loopargs[i].sigsize = ed_curves[testnum].sigsize;\n                st = EVP_DigestSign(loopargs[i].eddsa_ctx[testnum],\n                                    loopargs[i].buf2, &loopargs[i].sigsize,\n                                    loopargs[i].buf, 20);\n                if (st == 0)\n                    break;\n            }\n            if (st == 0) {\n                BIO_printf(bio_err,\n                           \"EdDSA sign failure.  No EdDSA sign will be done.\\n\");\n                dofail();\n                op_count = 1;\n            } else {\n                pkey_print_message(\"sign\", ed_curves[testnum].name,\n                                   ed_curves[testnum].bits, seconds.eddsa);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EdDSA_sign_loop, loopargs);\n                d = Time_F(STOP);\n\n                BIO_printf(bio_err,\n                           mr ? \"+R10:%ld:%u:%s:%.2f\\n\" :\n                           \"%ld %u bits %s sign ops in %.2fs \\n\",\n                           count, ed_curves[testnum].bits,\n                           ed_curves[testnum].name, d);\n                eddsa_results[testnum][0] = (double)count / d;\n                op_count = count;\n            }\n            /* Perform EdDSA verification test */\n            for (i = 0; i < loopargs_len; i++) {\n                st = EVP_DigestVerify(loopargs[i].eddsa_ctx2[testnum],\n                                      loopargs[i].buf2, loopargs[i].sigsize,\n                                      loopargs[i].buf, 20);\n                if (st != 1)\n                    break;\n            }\n            if (st != 1) {\n                BIO_printf(bio_err,\n                           \"EdDSA verify failure.  No EdDSA verify will be done.\\n\");\n                dofail();\n                eddsa_doit[testnum] = 0;\n            } else {\n                pkey_print_message(\"verify\", ed_curves[testnum].name,\n                                   ed_curves[testnum].bits, seconds.eddsa);\n                Time_F(START);\n                count = run_benchmark(async_jobs, EdDSA_verify_loop, loopargs);\n                d = Time_F(STOP);\n                BIO_printf(bio_err,\n                           mr ? \"+R11:%ld:%u:%s:%.2f\\n\"\n                           : \"%ld %u bits %s verify ops in %.2fs\\n\",\n                           count, ed_curves[testnum].bits,\n                           ed_curves[testnum].name, d);\n                eddsa_results[testnum][1] = (double)count / d;\n            }\n\n            if (op_count <= 1) {\n                /* if longer than 10s, don't do any more */\n                stop_it(eddsa_doit, testnum);\n            }\n        }\n    }\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    for (testnum = 0; testnum < SM2_NUM; testnum++) {\n        int st = 1;\n        EVP_PKEY *sm2_pkey = NULL;\n\n        if (!sm2_doit[testnum])\n            continue;           /* Ignore Curve */\n        /* Init signing and verification */\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY_CTX *sm2_pctx = NULL;\n            EVP_PKEY_CTX *sm2_vfy_pctx = NULL;\n            EVP_PKEY_CTX *pctx = NULL;\n            st = 0;\n\n            loopargs[i].sm2_ctx[testnum] = EVP_MD_CTX_new();\n            loopargs[i].sm2_vfy_ctx[testnum] = EVP_MD_CTX_new();\n            if (loopargs[i].sm2_ctx[testnum] == NULL\n                    || loopargs[i].sm2_vfy_ctx[testnum] == NULL)\n                break;\n\n            sm2_pkey = NULL;\n\n            st = !((pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_SM2, NULL)) == NULL\n                || EVP_PKEY_keygen_init(pctx) <= 0\n                || EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx,\n                    sm2_curves[testnum].nid) <= 0\n                || EVP_PKEY_keygen(pctx, &sm2_pkey) <= 0);\n            EVP_PKEY_CTX_free(pctx);\n            if (st == 0)\n                break;\n\n            st = 0; /* set back to zero */\n            /* attach it sooner to rely on main final cleanup */\n            loopargs[i].sm2_pkey[testnum] = sm2_pkey;\n            loopargs[i].sigsize = EVP_PKEY_get_size(sm2_pkey);\n\n            sm2_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);\n            sm2_vfy_pctx = EVP_PKEY_CTX_new(sm2_pkey, NULL);\n            if (sm2_pctx == NULL || sm2_vfy_pctx == NULL) {\n                EVP_PKEY_CTX_free(sm2_vfy_pctx);\n                break;\n            }\n\n            /* attach them directly to respective ctx */\n            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_ctx[testnum], sm2_pctx);\n            EVP_MD_CTX_set_pkey_ctx(loopargs[i].sm2_vfy_ctx[testnum], sm2_vfy_pctx);\n\n            /*\n             * No need to allow user to set an explicit ID here, just use\n             * the one defined in the 'draft-yang-tls-tl13-sm-suites' I-D.\n             */\n            if (EVP_PKEY_CTX_set1_id(sm2_pctx, SM2_ID, SM2_ID_LEN) != 1\n                || EVP_PKEY_CTX_set1_id(sm2_vfy_pctx, SM2_ID, SM2_ID_LEN) != 1)\n                break;\n\n            if (!EVP_DigestSignInit(loopargs[i].sm2_ctx[testnum], NULL,\n                                    EVP_sm3(), NULL, sm2_pkey))\n                break;\n            if (!EVP_DigestVerifyInit(loopargs[i].sm2_vfy_ctx[testnum], NULL,\n                                      EVP_sm3(), NULL, sm2_pkey))\n                break;\n            st = 1;         /* mark loop as succeeded */\n        }\n        if (st == 0) {\n            BIO_printf(bio_err, \"SM2 init failure.\\n\");\n            dofail();\n            op_count = 1;\n        } else {\n            for (i = 0; i < loopargs_len; i++) {\n                /* Perform SM2 signature test */\n                st = EVP_DigestSign(loopargs[i].sm2_ctx[testnum],\n                                    loopargs[i].buf2, &loopargs[i].sigsize,\n                                    loopargs[i].buf, 20);\n                if (st == 0)\n                    break;\n            }\n            if (st == 0) {\n                BIO_printf(bio_err,\n                           \"SM2 sign failure.  No SM2 sign will be done.\\n\");\n                dofail();\n                op_count = 1;\n            } else {\n                pkey_print_message(\"sign\", sm2_curves[testnum].name,\n                                   sm2_curves[testnum].bits, seconds.sm2);\n                Time_F(START);\n                count = run_benchmark(async_jobs, SM2_sign_loop, loopargs);\n                d = Time_F(STOP);\n\n                BIO_printf(bio_err,\n                           mr ? \"+R12:%ld:%u:%s:%.2f\\n\" :\n                           \"%ld %u bits %s sign ops in %.2fs \\n\",\n                           count, sm2_curves[testnum].bits,\n                           sm2_curves[testnum].name, d);\n                sm2_results[testnum][0] = (double)count / d;\n                op_count = count;\n            }\n\n            /* Perform SM2 verification test */\n            for (i = 0; i < loopargs_len; i++) {\n                st = EVP_DigestVerify(loopargs[i].sm2_vfy_ctx[testnum],\n                                      loopargs[i].buf2, loopargs[i].sigsize,\n                                      loopargs[i].buf, 20);\n                if (st != 1)\n                    break;\n            }\n            if (st != 1) {\n                BIO_printf(bio_err,\n                           \"SM2 verify failure.  No SM2 verify will be done.\\n\");\n                dofail();\n                sm2_doit[testnum] = 0;\n            } else {\n                pkey_print_message(\"verify\", sm2_curves[testnum].name,\n                                   sm2_curves[testnum].bits, seconds.sm2);\n                Time_F(START);\n                count = run_benchmark(async_jobs, SM2_verify_loop, loopargs);\n                d = Time_F(STOP);\n                BIO_printf(bio_err,\n                           mr ? \"+R13:%ld:%u:%s:%.2f\\n\"\n                           : \"%ld %u bits %s verify ops in %.2fs\\n\",\n                           count, sm2_curves[testnum].bits,\n                           sm2_curves[testnum].name, d);\n                sm2_results[testnum][1] = (double)count / d;\n            }\n\n            if (op_count <= 1) {\n                /* if longer than 10s, don't do any more */\n                for (testnum++; testnum < SM2_NUM; testnum++)\n                    sm2_doit[testnum] = 0;\n            }\n        }\n    }\n#endif                         /* OPENSSL_NO_SM2 */\n\n#ifndef OPENSSL_NO_DH\n    for (testnum = 0; testnum < FFDH_NUM; testnum++) {\n        int ffdh_checks = 1;\n\n        if (!ffdh_doit[testnum])\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey_A = NULL;\n            EVP_PKEY *pkey_B = NULL;\n            EVP_PKEY_CTX *ffdh_ctx = NULL;\n            EVP_PKEY_CTX *test_ctx = NULL;\n            size_t secret_size;\n            size_t test_out;\n\n            /* Ensure that the error queue is empty */\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            pkey_A = EVP_PKEY_new();\n            if (!pkey_A) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY (out of memory?).\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            pkey_B = EVP_PKEY_new();\n            if (!pkey_B) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY (out of memory?).\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            ffdh_ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_DH, NULL);\n            if (!ffdh_ctx) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            if (EVP_PKEY_keygen_init(ffdh_ctx) <= 0) {\n                BIO_printf(bio_err, \"Error while initialising EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_CTX_set_dh_nid(ffdh_ctx, ffdh_params[testnum].nid) <= 0) {\n                BIO_printf(bio_err, \"Error setting DH key size for keygen.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            if (EVP_PKEY_keygen(ffdh_ctx, &pkey_A) <= 0 ||\n                EVP_PKEY_keygen(ffdh_ctx, &pkey_B) <= 0) {\n                BIO_printf(bio_err, \"FFDH key generation failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            EVP_PKEY_CTX_free(ffdh_ctx);\n\n            /*\n             * check if the derivation works correctly both ways so that\n             * we know if future derive calls will fail, and we can skip\n             * error checking in benchmarked code\n             */\n            ffdh_ctx = EVP_PKEY_CTX_new(pkey_A, NULL);\n            if (ffdh_ctx == NULL) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_init(ffdh_ctx) <= 0) {\n                BIO_printf(bio_err, \"FFDH derivation context init failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_set_peer(ffdh_ctx, pkey_B) <= 0) {\n                BIO_printf(bio_err, \"Assigning peer key for derivation failed.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive(ffdh_ctx, NULL, &secret_size) <= 0) {\n                BIO_printf(bio_err, \"Checking size of shared secret failed.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (secret_size > MAX_FFDH_SIZE) {\n                BIO_printf(bio_err, \"Assertion failure: shared secret too large.\\n\");\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive(ffdh_ctx,\n                                loopargs[i].secret_ff_a,\n                                &secret_size) <= 0) {\n                BIO_printf(bio_err, \"Shared secret derive failure.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            /* Now check from side B */\n            test_ctx = EVP_PKEY_CTX_new(pkey_B, NULL);\n            if (!test_ctx) {\n                BIO_printf(bio_err, \"Error while allocating EVP_PKEY_CTX.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n            if (EVP_PKEY_derive_init(test_ctx) <= 0 ||\n                EVP_PKEY_derive_set_peer(test_ctx, pkey_A) <= 0 ||\n                EVP_PKEY_derive(test_ctx, NULL, &test_out) <= 0 ||\n                EVP_PKEY_derive(test_ctx, loopargs[i].secret_ff_b, &test_out) <= 0 ||\n                test_out != secret_size) {\n                BIO_printf(bio_err, \"FFDH computation failure.\\n\");\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            /* compare the computed secrets */\n            if (CRYPTO_memcmp(loopargs[i].secret_ff_a,\n                              loopargs[i].secret_ff_b, secret_size)) {\n                BIO_printf(bio_err, \"FFDH computations don't match.\\n\");\n                dofail();\n                op_count = 1;\n                ffdh_checks = 0;\n                break;\n            }\n\n            loopargs[i].ffdh_ctx[testnum] = ffdh_ctx;\n\n            EVP_PKEY_free(pkey_A);\n            pkey_A = NULL;\n            EVP_PKEY_free(pkey_B);\n            pkey_B = NULL;\n            EVP_PKEY_CTX_free(test_ctx);\n            test_ctx = NULL;\n        }\n        if (ffdh_checks != 0) {\n            pkey_print_message(\"\", \"ffdh\",\n                               ffdh_params[testnum].bits, seconds.ffdh);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, FFDH_derive_key_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R14:%ld:%d:%.2f\\n\" :\n                       \"%ld %u-bits FFDH ops in %.2fs\\n\", count,\n                       ffdh_params[testnum].bits, d);\n            ffdh_results[testnum][0] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(ffdh_doit, testnum);\n        }\n    }\n#endif  /* OPENSSL_NO_DH */\n\n    for (testnum = 0; testnum < kems_algs_len; testnum++) {\n        int kem_checks = 1;\n        const char *kem_name = kems_algname[testnum];\n\n        if (!kems_doit[testnum] || !do_kems)\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey = NULL;\n            EVP_PKEY_CTX *kem_gen_ctx = NULL;\n            EVP_PKEY_CTX *kem_encaps_ctx = NULL;\n            EVP_PKEY_CTX *kem_decaps_ctx = NULL;\n            size_t send_secret_len, out_len;\n            size_t rcv_secret_len;\n            unsigned char *out = NULL, *send_secret = NULL, *rcv_secret;\n            unsigned int bits;\n            char *name;\n            char sfx[MAX_ALGNAME_SUFFIX];\n            OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n            int use_params = 0;\n            enum kem_type_t { KEM_RSA = 1, KEM_EC, KEM_X25519, KEM_X448 } kem_type;\n\n            /* no string after rsa<bitcnt> permitted: */\n            if (strlen(kem_name) < MAX_ALGNAME_SUFFIX + 4 /* rsa+digit */\n                && sscanf(kem_name, \"rsa%u%s\", &bits, sfx) == 1)\n                kem_type = KEM_RSA;\n            else if (strncmp(kem_name, \"EC\", 2) == 0)\n                kem_type = KEM_EC;\n            else if (strcmp(kem_name, \"X25519\") == 0)\n                kem_type = KEM_X25519;\n            else if (strcmp(kem_name, \"X448\") == 0)\n                kem_type = KEM_X448;\n            else kem_type = 0;\n\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            if (kem_type == KEM_RSA) {\n                params[0] = OSSL_PARAM_construct_uint(OSSL_PKEY_PARAM_RSA_BITS,\n                                                      &bits);\n                use_params = 1;\n            } else if (kem_type == KEM_EC) {\n                name = (char *)(kem_name + 2);\n                params[0] = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_GROUP_NAME,\n                                                  name, 0);\n                use_params = 1;\n            }\n\n            kem_gen_ctx = EVP_PKEY_CTX_new_from_name(app_get0_libctx(),\n                                               (kem_type == KEM_RSA) ? \"RSA\":\n                                                (kem_type == KEM_EC) ? \"EC\":\n                                                 kem_name,\n                                               app_get0_propq());\n\n            if ((!kem_gen_ctx || EVP_PKEY_keygen_init(kem_gen_ctx) <= 0)\n                || (use_params\n                    && EVP_PKEY_CTX_set_params(kem_gen_ctx, params) <= 0)) {\n                BIO_printf(bio_err, \"Error initializing keygen ctx for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_keygen(kem_gen_ctx, &pkey) <= 0) {\n                BIO_printf(bio_err, \"Error while generating KEM EVP_PKEY.\\n\");\n                goto kem_err_break;\n            }\n            /* Now prepare encaps data structs */\n            kem_encaps_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (kem_encaps_ctx == NULL\n                || EVP_PKEY_encapsulate_init(kem_encaps_ctx, NULL) <= 0\n                || (kem_type == KEM_RSA\n                    && EVP_PKEY_CTX_set_kem_op(kem_encaps_ctx, \"RSASVE\") <= 0)\n                || ((kem_type == KEM_EC\n                    || kem_type == KEM_X25519\n                    || kem_type == KEM_X448)\n                   && EVP_PKEY_CTX_set_kem_op(kem_encaps_ctx, \"DHKEM\") <= 0)\n                || EVP_PKEY_encapsulate(kem_encaps_ctx, NULL, &out_len,\n                                      NULL, &send_secret_len) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while initializing encaps data structs for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            out = app_malloc(out_len, \"encaps result\");\n            send_secret = app_malloc(send_secret_len, \"encaps secret\");\n            if (out == NULL || send_secret == NULL) {\n                BIO_printf(bio_err, \"MemAlloc error in encaps for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_encapsulate(kem_encaps_ctx, out, &out_len,\n                                     send_secret, &send_secret_len) <= 0) {\n                BIO_printf(bio_err, \"Encaps error for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            /* Now prepare decaps data structs */\n            kem_decaps_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (kem_decaps_ctx == NULL\n                || EVP_PKEY_decapsulate_init(kem_decaps_ctx, NULL) <= 0\n                || (kem_type == KEM_RSA\n                  && EVP_PKEY_CTX_set_kem_op(kem_decaps_ctx, \"RSASVE\") <= 0)\n                || ((kem_type == KEM_EC\n                     || kem_type == KEM_X25519\n                     || kem_type == KEM_X448)\n                  && EVP_PKEY_CTX_set_kem_op(kem_decaps_ctx, \"DHKEM\") <= 0)\n                || EVP_PKEY_decapsulate(kem_decaps_ctx, NULL, &rcv_secret_len,\n                                        out, out_len) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while initializing decaps data structs for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            rcv_secret = app_malloc(rcv_secret_len, \"KEM decaps secret\");\n            if (rcv_secret == NULL) {\n                BIO_printf(bio_err, \"MemAlloc failure in decaps for %s.\\n\",\n                           kem_name);\n                goto kem_err_break;\n            }\n            if (EVP_PKEY_decapsulate(kem_decaps_ctx, rcv_secret,\n                                     &rcv_secret_len, out, out_len) <= 0\n                || rcv_secret_len != send_secret_len\n                || memcmp(send_secret, rcv_secret, send_secret_len)) {\n                BIO_printf(bio_err, \"Decaps error for %s.\\n\", kem_name);\n                goto kem_err_break;\n            }\n            loopargs[i].kem_gen_ctx[testnum] = kem_gen_ctx;\n            loopargs[i].kem_encaps_ctx[testnum] = kem_encaps_ctx;\n            loopargs[i].kem_decaps_ctx[testnum] = kem_decaps_ctx;\n            loopargs[i].kem_out_len[testnum] = out_len;\n            loopargs[i].kem_secret_len[testnum] = send_secret_len;\n            loopargs[i].kem_out[testnum] = out;\n            loopargs[i].kem_send_secret[testnum] = send_secret;\n            loopargs[i].kem_rcv_secret[testnum] = rcv_secret;\n            EVP_PKEY_free(pkey);\n            pkey = NULL;\n            continue;\n\n        kem_err_break:\n            dofail();\n            EVP_PKEY_free(pkey);\n            op_count = 1;\n            kem_checks = 0;\n            break;\n        }\n        if (kem_checks != 0) {\n            kskey_print_message(kem_name, \"keygen\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_keygen_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R15:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM keygen ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][0] = (double)count / d;\n            op_count = count;\n            kskey_print_message(kem_name, \"encaps\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_encaps_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R16:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM encaps ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][1] = (double)count / d;\n            op_count = count;\n            kskey_print_message(kem_name, \"decaps\", seconds.kem);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, KEM_decaps_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R17:%ld:%s:%.2f\\n\" :\n                       \"%ld %s KEM decaps ops in %.2fs\\n\", count,\n                       kem_name, d);\n            kems_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1) {\n            /* if longer than 10s, don't do any more */\n            stop_it(kems_doit, testnum);\n        }\n    }\n\n    for (testnum = 0; testnum < sigs_algs_len; testnum++) {\n        int sig_checks = 1;\n        const char *sig_name = sigs_algname[testnum];\n\n        if (!sigs_doit[testnum] || !do_sigs)\n            continue;\n\n        for (i = 0; i < loopargs_len; i++) {\n            EVP_PKEY *pkey = NULL;\n            EVP_PKEY_CTX *ctx_params = NULL;\n            EVP_PKEY* pkey_params = NULL;\n            EVP_PKEY_CTX *sig_gen_ctx = NULL;\n            EVP_PKEY_CTX *sig_sign_ctx = NULL;\n            EVP_PKEY_CTX *sig_verify_ctx = NULL;\n            unsigned char md[SHA256_DIGEST_LENGTH];\n            unsigned char *sig;\n            char sfx[MAX_ALGNAME_SUFFIX];\n            size_t md_len = SHA256_DIGEST_LENGTH;\n            size_t max_sig_len, sig_len;\n            unsigned int bits;\n            OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };\n            int use_params = 0;\n\n            /* only sign little data to avoid measuring digest performance */\n            memset(md, 0, SHA256_DIGEST_LENGTH);\n\n            if (ERR_peek_error()) {\n                BIO_printf(bio_err,\n                           \"WARNING: the error queue contains previous unhandled errors.\\n\");\n                dofail();\n            }\n\n            /* no string after rsa<bitcnt> permitted: */\n            if (strlen(sig_name) < MAX_ALGNAME_SUFFIX + 4 /* rsa+digit */\n                && sscanf(sig_name, \"rsa%u%s\", &bits, sfx) == 1) {\n                params[0] = OSSL_PARAM_construct_uint(OSSL_PKEY_PARAM_RSA_BITS,\n                                                      &bits);\n                use_params = 1;\n            }\n\n            if (strncmp(sig_name, \"dsa\", 3) == 0) {\n                ctx_params = EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, NULL);\n                if (ctx_params == NULL\n                    || EVP_PKEY_paramgen_init(ctx_params) <= 0\n                    || EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx_params,\n                                                        atoi(sig_name + 3)) <= 0\n                    || EVP_PKEY_paramgen(ctx_params, &pkey_params) <= 0\n                    || (sig_gen_ctx = EVP_PKEY_CTX_new(pkey_params, NULL)) == NULL\n                    || EVP_PKEY_keygen_init(sig_gen_ctx) <= 0) {\n                    BIO_printf(bio_err,\n                               \"Error initializing classic keygen ctx for %s.\\n\",\n                               sig_name);\n                    goto sig_err_break;\n                }\n            }\n\n            if (sig_gen_ctx == NULL)\n                sig_gen_ctx = EVP_PKEY_CTX_new_from_name(app_get0_libctx(),\n                                      use_params == 1 ? \"RSA\" : sig_name,\n                                      app_get0_propq());\n\n            if (!sig_gen_ctx || EVP_PKEY_keygen_init(sig_gen_ctx) <= 0\n                || (use_params &&\n                    EVP_PKEY_CTX_set_params(sig_gen_ctx, params) <= 0)) {\n                BIO_printf(bio_err, \"Error initializing keygen ctx for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_keygen(sig_gen_ctx, &pkey) <= 0) {\n                BIO_printf(bio_err,\n                           \"Error while generating signature EVP_PKEY for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            /* Now prepare signature data structs */\n            sig_sign_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                      pkey,\n                                                      app_get0_propq());\n            if (sig_sign_ctx == NULL\n                || EVP_PKEY_sign_init(sig_sign_ctx) <= 0\n                || (use_params == 1\n                    && (EVP_PKEY_CTX_set_rsa_padding(sig_sign_ctx,\n                                                     RSA_PKCS1_PADDING) <= 0))\n                || EVP_PKEY_sign(sig_sign_ctx, NULL, &max_sig_len,\n                                 md, md_len) <= 0) {\n                    BIO_printf(bio_err,\n                               \"Error while initializing signing data structs for %s.\\n\",\n                               sig_name);\n                    goto sig_err_break;\n            }\n            sig = app_malloc(sig_len = max_sig_len, \"signature buffer\");\n            if (sig == NULL) {\n                BIO_printf(bio_err, \"MemAlloc error in sign for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_sign(sig_sign_ctx, sig, &sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Signing error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            /* Now prepare verify data structs */\n            memset(md, 0, SHA256_DIGEST_LENGTH);\n            sig_verify_ctx = EVP_PKEY_CTX_new_from_pkey(app_get0_libctx(),\n                                                        pkey,\n                                                        app_get0_propq());\n            if (sig_verify_ctx == NULL\n                || EVP_PKEY_verify_init(sig_verify_ctx) <= 0\n                || (use_params == 1\n                  && (EVP_PKEY_CTX_set_rsa_padding(sig_verify_ctx,\n                                                   RSA_PKCS1_PADDING) <= 0))) {\n                BIO_printf(bio_err,\n                           \"Error while initializing verify data structs for %s.\\n\",\n                           sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_verify(sig_verify_ctx, sig, sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Verify error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            if (EVP_PKEY_verify(sig_verify_ctx, sig, sig_len, md, md_len) <= 0) {\n                BIO_printf(bio_err, \"Verify 2 error for %s.\\n\", sig_name);\n                goto sig_err_break;\n            }\n            loopargs[i].sig_gen_ctx[testnum] = sig_gen_ctx;\n            loopargs[i].sig_sign_ctx[testnum] = sig_sign_ctx;\n            loopargs[i].sig_verify_ctx[testnum] = sig_verify_ctx;\n            loopargs[i].sig_max_sig_len[testnum] = max_sig_len;\n            loopargs[i].sig_act_sig_len[testnum] = sig_len;\n            loopargs[i].sig_sig[testnum] = sig;\n            EVP_PKEY_free(pkey);\n            pkey = NULL;\n            continue;\n\n        sig_err_break:\n            dofail();\n            EVP_PKEY_free(pkey);\n            op_count = 1;\n            sig_checks = 0;\n            break;\n        }\n\n        if (sig_checks != 0) {\n            kskey_print_message(sig_name, \"keygen\", seconds.sig);\n            Time_F(START);\n            count = run_benchmark(async_jobs, SIG_keygen_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R18:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature keygen ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][0] = (double)count / d;\n            op_count = count;\n            kskey_print_message(sig_name, \"signs\", seconds.sig);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, SIG_sign_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R19:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature sign ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][1] = (double)count / d;\n            op_count = count;\n\n            kskey_print_message(sig_name, \"verify\", seconds.sig);\n            Time_F(START);\n            count =\n                run_benchmark(async_jobs, SIG_verify_loop, loopargs);\n            d = Time_F(STOP);\n            BIO_printf(bio_err,\n                       mr ? \"+R20:%ld:%s:%.2f\\n\" :\n                       \"%ld %s signature verify ops in %.2fs\\n\", count,\n                       sig_name, d);\n            sigs_results[testnum][2] = (double)count / d;\n            op_count = count;\n        }\n        if (op_count <= 1)\n            stop_it(sigs_doit, testnum);\n    }\n\n#ifndef NO_FORK\n show_res:\n#endif\n    if (!mr) {\n        printf(\"version: %s\\n\", OpenSSL_version(OPENSSL_FULL_VERSION_STRING));\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_BUILT_ON));\n        printf(\"options: %s\\n\", BN_options());\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_CFLAGS));\n        printf(\"%s\\n\", OpenSSL_version(OPENSSL_CPU_INFO));\n    }\n\n    if (pr_header) {\n        if (mr) {\n            printf(\"+H\");\n        } else {\n            printf(\"The 'numbers' are in 1000s of bytes per second processed.\\n\");\n            printf(\"type        \");\n        }\n        for (testnum = 0; testnum < size_num; testnum++)\n            printf(mr ? \":%d\" : \"%7d bytes\", lengths[testnum]);\n        printf(\"\\n\");\n    }\n\n    for (k = 0; k < ALGOR_NUM; k++) {\n        const char *alg_name = names[k];\n\n        if (!doit[k])\n            continue;\n\n        if (k == D_EVP) {\n            if (evp_cipher == NULL)\n                alg_name = evp_md_name;\n            else if ((alg_name = EVP_CIPHER_get0_name(evp_cipher)) == NULL)\n                app_bail_out(\"failed to get name of cipher '%s'\\n\", evp_cipher);\n        }\n\n        if (mr)\n            printf(\"+F:%u:%s\", k, alg_name);\n        else\n            printf(\"%-13s\", alg_name);\n        for (testnum = 0; testnum < size_num; testnum++) {\n            if (results[k][testnum] > 10000 && !mr)\n                printf(\" %11.2fk\", results[k][testnum] / 1e3);\n            else\n                printf(mr ? \":%.2f\" : \" %11.2f \", results[k][testnum]);\n        }\n        printf(\"\\n\");\n    }\n    testnum = 1;\n    for (k = 0; k < RSA_NUM; k++) {\n        if (!rsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%19ssign    verify    encrypt   decrypt   sign/s verify/s  encr./s  decr./s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F2:%u:%u:%f:%f:%f:%f\\n\",\n                   k, rsa_keys[k].bits, rsa_results[k][0], rsa_results[k][1],\n                   rsa_results[k][2], rsa_results[k][3]);\n        else\n            printf(\"rsa %5u bits %8.6fs %8.6fs %8.6fs %8.6fs %8.1f %8.1f %8.1f %8.1f\\n\",\n                   rsa_keys[k].bits, 1.0 / rsa_results[k][0],\n                   1.0 / rsa_results[k][1], 1.0 / rsa_results[k][2],\n                   1.0 / rsa_results[k][3],\n                   rsa_results[k][0], rsa_results[k][1],\n                   rsa_results[k][2], rsa_results[k][3]);\n    }\n    testnum = 1;\n#ifndef OPENSSL_NO_DSA\n    for (k = 0; k < DSA_NUM; k++) {\n        if (!dsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%18ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F3:%u:%u:%f:%f\\n\",\n                   k, dsa_bits[k], dsa_results[k][0], dsa_results[k][1]);\n        else\n            printf(\"dsa %4u bits %8.6fs %8.6fs %8.1f %8.1f\\n\",\n                   dsa_bits[k], 1.0 / dsa_results[k][0], 1.0 / dsa_results[k][1],\n                   dsa_results[k][0], dsa_results[k][1]);\n    }\n#endif /* OPENSSL_NO_DSA */\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(ecdsa_doit); k++) {\n        if (!ecdsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F4:%u:%u:%f:%f\\n\",\n                   k, ec_curves[k].bits,\n                   ecdsa_results[k][0], ecdsa_results[k][1]);\n        else\n            printf(\"%4u bits ecdsa (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   ec_curves[k].bits, ec_curves[k].name,\n                   1.0 / ecdsa_results[k][0], 1.0 / ecdsa_results[k][1],\n                   ecdsa_results[k][0], ecdsa_results[k][1]);\n    }\n\n    testnum = 1;\n    for (k = 0; k < EC_NUM; k++) {\n        if (!ecdh_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30sop      op/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F5:%u:%u:%f:%f\\n\",\n                   k, ec_curves[k].bits,\n                   ecdh_results[k][0], 1.0 / ecdh_results[k][0]);\n\n        else\n            printf(\"%4u bits ecdh (%s) %8.4fs %8.1f\\n\",\n                   ec_curves[k].bits, ec_curves[k].name,\n                   1.0 / ecdh_results[k][0], ecdh_results[k][0]);\n    }\n\n#ifndef OPENSSL_NO_ECX\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(eddsa_doit); k++) {\n        if (!eddsa_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F6:%u:%u:%s:%f:%f\\n\",\n                   k, ed_curves[k].bits, ed_curves[k].name,\n                   eddsa_results[k][0], eddsa_results[k][1]);\n        else\n            printf(\"%4u bits EdDSA (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   ed_curves[k].bits, ed_curves[k].name,\n                   1.0 / eddsa_results[k][0], 1.0 / eddsa_results[k][1],\n                   eddsa_results[k][0], eddsa_results[k][1]);\n    }\n#endif /* OPENSSL_NO_ECX */\n\n#ifndef OPENSSL_NO_SM2\n    testnum = 1;\n    for (k = 0; k < OSSL_NELEM(sm2_doit); k++) {\n        if (!sm2_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%30ssign    verify    sign/s verify/s\\n\", \" \");\n            testnum = 0;\n        }\n\n        if (mr)\n            printf(\"+F7:%u:%u:%s:%f:%f\\n\",\n                   k, sm2_curves[k].bits, sm2_curves[k].name,\n                   sm2_results[k][0], sm2_results[k][1]);\n        else\n            printf(\"%4u bits SM2 (%s) %8.4fs %8.4fs %8.1f %8.1f\\n\",\n                   sm2_curves[k].bits, sm2_curves[k].name,\n                   1.0 / sm2_results[k][0], 1.0 / sm2_results[k][1],\n                   sm2_results[k][0], sm2_results[k][1]);\n    }\n#endif\n#ifndef OPENSSL_NO_DH\n    testnum = 1;\n    for (k = 0; k < FFDH_NUM; k++) {\n        if (!ffdh_doit[k])\n            continue;\n        if (testnum && !mr) {\n            printf(\"%23sop     op/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F8:%u:%u:%f:%f\\n\",\n                   k, ffdh_params[k].bits,\n                   ffdh_results[k][0], 1.0 / ffdh_results[k][0]);\n\n        else\n            printf(\"%4u bits ffdh %8.4fs %8.1f\\n\",\n                   ffdh_params[k].bits,\n                   1.0 / ffdh_results[k][0], ffdh_results[k][0]);\n    }\n#endif /* OPENSSL_NO_DH */\n\n    testnum = 1;\n    for (k = 0; k < kems_algs_len; k++) {\n        const char *kem_name = kems_algname[k];\n\n        if (!kems_doit[k] || !do_kems)\n            continue;\n        if (testnum && !mr) {\n            printf(\"%31skeygen    encaps    decaps keygens/s  encaps/s  decaps/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F9:%u:%f:%f:%f\\n\",\n                   k, kems_results[k][0], kems_results[k][1],\n                   kems_results[k][2]);\n        else\n            printf(\"%27s %8.6fs %8.6fs %8.6fs %9.1f %9.1f %9.1f\\n\", kem_name,\n                   1.0 / kems_results[k][0],\n                   1.0 / kems_results[k][1], 1.0 / kems_results[k][2],\n                   kems_results[k][0], kems_results[k][1], kems_results[k][2]);\n    }\n    ret = 0;\n\n    testnum = 1;\n    for (k = 0; k < sigs_algs_len; k++) {\n        const char *sig_name = sigs_algname[k];\n\n        if (!sigs_doit[k] || !do_sigs)\n            continue;\n        if (testnum && !mr) {\n            printf(\"%31skeygen     signs    verify keygens/s    sign/s  verify/s\\n\", \" \");\n            testnum = 0;\n        }\n        if (mr)\n            printf(\"+F10:%u:%f:%f:%f\\n\",\n                   k, sigs_results[k][0], sigs_results[k][1],\n                   sigs_results[k][2]);\n        else\n            printf(\"%27s %8.6fs %8.6fs %8.6fs %9.1f %9.1f %9.1f\\n\", sig_name,\n                   1.0 / sigs_results[k][0], 1.0 / sigs_results[k][1],\n                   1.0 / sigs_results[k][2], sigs_results[k][0],\n                   sigs_results[k][1], sigs_results[k][2]);\n    }\n    ret = 0;\n\n end:\n    if (ret == 0 && testmode)\n        ret = testmoderesult;\n    ERR_print_errors(bio_err);\n    for (i = 0; i < loopargs_len; i++) {\n        OPENSSL_free(loopargs[i].buf_malloc);\n        OPENSSL_free(loopargs[i].buf2_malloc);\n\n        BN_free(bn);\n        EVP_PKEY_CTX_free(genctx);\n        for (k = 0; k < RSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].rsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_verify_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_encrypt_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].rsa_decrypt_ctx[k]);\n        }\n#ifndef OPENSSL_NO_DH\n        OPENSSL_free(loopargs[i].secret_ff_a);\n        OPENSSL_free(loopargs[i].secret_ff_b);\n        for (k = 0; k < FFDH_NUM; k++)\n            EVP_PKEY_CTX_free(loopargs[i].ffdh_ctx[k]);\n#endif\n#ifndef OPENSSL_NO_DSA\n        for (k = 0; k < DSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].dsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].dsa_verify_ctx[k]);\n        }\n#endif\n        for (k = 0; k < ECDSA_NUM; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].ecdsa_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].ecdsa_verify_ctx[k]);\n        }\n        for (k = 0; k < EC_NUM; k++)\n            EVP_PKEY_CTX_free(loopargs[i].ecdh_ctx[k]);\n#ifndef OPENSSL_NO_ECX\n        for (k = 0; k < EdDSA_NUM; k++) {\n            EVP_MD_CTX_free(loopargs[i].eddsa_ctx[k]);\n            EVP_MD_CTX_free(loopargs[i].eddsa_ctx2[k]);\n        }\n#endif /* OPENSSL_NO_ECX */\n#ifndef OPENSSL_NO_SM2\n        for (k = 0; k < SM2_NUM; k++) {\n            EVP_PKEY_CTX *pctx = NULL;\n\n            /* free signing ctx */\n            if (loopargs[i].sm2_ctx[k] != NULL\n                && (pctx = EVP_MD_CTX_get_pkey_ctx(loopargs[i].sm2_ctx[k])) != NULL)\n                EVP_PKEY_CTX_free(pctx);\n            EVP_MD_CTX_free(loopargs[i].sm2_ctx[k]);\n            /* free verification ctx */\n            if (loopargs[i].sm2_vfy_ctx[k] != NULL\n                && (pctx = EVP_MD_CTX_get_pkey_ctx(loopargs[i].sm2_vfy_ctx[k])) != NULL)\n                EVP_PKEY_CTX_free(pctx);\n            EVP_MD_CTX_free(loopargs[i].sm2_vfy_ctx[k]);\n            /* free pkey */\n            EVP_PKEY_free(loopargs[i].sm2_pkey[k]);\n        }\n#endif\n        for (k = 0; k < kems_algs_len; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].kem_gen_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].kem_encaps_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].kem_decaps_ctx[k]);\n            OPENSSL_free(loopargs[i].kem_out[k]);\n            OPENSSL_free(loopargs[i].kem_send_secret[k]);\n            OPENSSL_free(loopargs[i].kem_rcv_secret[k]);\n        }\n        for (k = 0; k < sigs_algs_len; k++) {\n            EVP_PKEY_CTX_free(loopargs[i].sig_gen_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].sig_sign_ctx[k]);\n            EVP_PKEY_CTX_free(loopargs[i].sig_verify_ctx[k]);\n            OPENSSL_free(loopargs[i].sig_sig[k]);\n        }\n        OPENSSL_free(loopargs[i].secret_a);\n        OPENSSL_free(loopargs[i].secret_b);\n    }\n    OPENSSL_free(evp_hmac_name);\n    OPENSSL_free(evp_cmac_name);\n    for (k = 0; k < kems_algs_len; k++)\n        OPENSSL_free(kems_algname[k]);\n    if (kem_stack != NULL)\n        sk_EVP_KEM_pop_free(kem_stack, EVP_KEM_free);\n    for (k = 0; k < sigs_algs_len; k++)\n        OPENSSL_free(sigs_algname[k]);\n    if (sig_stack != NULL)\n        sk_EVP_SIGNATURE_pop_free(sig_stack, EVP_SIGNATURE_free);\n\n    if (async_jobs > 0) {\n        for (i = 0; i < loopargs_len; i++)\n            ASYNC_WAIT_CTX_free(loopargs[i].wait_ctx);\n    }\n\n    if (async_init) {\n        ASYNC_cleanup_thread();\n    }\n    OPENSSL_free(loopargs);\n    release_engine(e);\n    EVP_CIPHER_free(evp_cipher);\n    EVP_MAC_free(mac);\n    NCONF_free(conf);\n    return ret;\n}"
        ],
        "sink": "ASYNC_WAIT_CTX_free(loopargs[i].wait_ctx);",
        "final_sink": "ASYNC_WAIT_CTX_free(loopargs[i].wait_ctx);",
        "source": [
            "        cnf = sk_CONF_VALUE_value(sktmp, i);"
        ],
        "index": 49
    }
]