[
    {
        "prt": "qmul",
        "function_call": [
            "static av_always_inline void\ndecode_cabac_residual_internal(const H264Context *h, H264SliceContext *sl,\n                               int16_t *block,\n                               int cat, int n, const uint8_t *scantable,\n                               const uint32_t *qmul, int max_coeff,\n                               int is_dc, int chroma422)\n{\n    static const int significant_coeff_flag_offset[2][14] = {\n      { 105+0, 105+15, 105+29, 105+44, 105+47, 402, 484+0, 484+15, 484+29, 660, 528+0, 528+15, 528+29, 718 },\n      { 277+0, 277+15, 277+29, 277+44, 277+47, 436, 776+0, 776+15, 776+29, 675, 820+0, 820+15, 820+29, 733 }\n    };\n    static const int last_coeff_flag_offset[2][14] = {\n      { 166+0, 166+15, 166+29, 166+44, 166+47, 417, 572+0, 572+15, 572+29, 690, 616+0, 616+15, 616+29, 748 },\n      { 338+0, 338+15, 338+29, 338+44, 338+47, 451, 864+0, 864+15, 864+29, 699, 908+0, 908+15, 908+29, 757 }\n    };\n    static const int coeff_abs_level_m1_offset[14] = {\n        227+0, 227+10, 227+20, 227+30, 227+39, 426, 952+0, 952+10, 952+20, 708, 982+0, 982+10, 982+20, 766\n    };\n    static const uint8_t significant_coeff_flag_offset_8x8[2][63] = {\n      { 0, 1, 2, 3, 4, 5, 5, 4, 4, 3, 3, 4, 4, 4, 5, 5,\n        4, 4, 4, 4, 3, 3, 6, 7, 7, 7, 8, 9,10, 9, 8, 7,\n        7, 6,11,12,13,11, 6, 7, 8, 9,14,10, 9, 8, 6,11,\n       12,13,11, 6, 9,14,10, 9,11,12,13,11,14,10,12 },\n      { 0, 1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 7, 7, 8, 4, 5,\n        6, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,11,12,11,\n        9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,13,13, 9,\n        9,10,10, 8,13,13, 9, 9,10,10,14,14,14,14,14 }\n    };\n    static const uint8_t sig_coeff_offset_dc[7] = { 0, 0, 1, 1, 2, 2, 2 };\n    /* node ctx: 0..3: abslevel1 (with abslevelgt1 == 0).\n     * 4..7: abslevelgt1 + 3 (and abslevel1 doesn't matter).\n     * map node ctx => cabac ctx for level=1 */\n    static const uint8_t coeff_abs_level1_ctx[8] = { 1, 2, 3, 4, 0, 0, 0, 0 };\n    /* map node ctx => cabac ctx for level>1 */\n    static const uint8_t coeff_abs_levelgt1_ctx[2][8] = {\n        { 5, 5, 5, 5, 6, 7, 8, 9 },\n        { 5, 5, 5, 5, 6, 7, 8, 8 }, // 422/dc case\n    };\n    static const uint8_t coeff_abs_level_transition[2][8] = {\n    /* update node ctx after decoding a level=1 */\n        { 1, 2, 3, 3, 4, 5, 6, 7 },\n    /* update node ctx after decoding a level>1 */\n        { 4, 4, 4, 4, 5, 6, 7, 7 }\n    };\n\n    int index[64];\n\n    int last;\n    int coeff_count = 0;\n    int node_ctx = 0;\n\n    uint8_t *significant_coeff_ctx_base;\n    uint8_t *last_coeff_ctx_base;\n    uint8_t *abs_level_m1_ctx_base;\n\n#if !ARCH_X86\n#define CABAC_ON_STACK\n#endif\n#ifdef CABAC_ON_STACK\n#define CC &cc\n    CABACContext cc;\n    cc.range     = sl->cabac.range;\n    cc.low       = sl->cabac.low;\n    cc.bytestream= sl->cabac.bytestream;\n    cc.bytestream_end = sl->cabac.bytestream_end;\n#else\n#define CC &sl->cabac\n#endif\n\n    significant_coeff_ctx_base = sl->cabac_state\n        + significant_coeff_flag_offset[MB_FIELD(sl)][cat];\n    last_coeff_ctx_base = sl->cabac_state\n        + last_coeff_flag_offset[MB_FIELD(sl)][cat];\n    abs_level_m1_ctx_base = sl->cabac_state\n        + coeff_abs_level_m1_offset[cat];\n\n    if( !is_dc && max_coeff == 64 ) {\n#define DECODE_SIGNIFICANCE( coefs, sig_off, last_off ) \\\n        for(last= 0; last < coefs; last++) { \\\n            uint8_t *sig_ctx = significant_coeff_ctx_base + sig_off; \\\n            if( get_cabac( CC, sig_ctx )) { \\\n                uint8_t *last_ctx = last_coeff_ctx_base + last_off; \\\n                index[coeff_count++] = last; \\\n                if( get_cabac( CC, last_ctx ) ) { \\\n                    last= max_coeff; \\\n                    break; \\\n                } \\\n            } \\\n        }\\\n        if( last == max_coeff -1 ) {\\\n            index[coeff_count++] = last;\\\n        }\n        const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD(sl)];\n#ifdef decode_significance\n        coeff_count = decode_significance_8x8(CC, significant_coeff_ctx_base, index,\n                                                 last_coeff_ctx_base, sig_off);\n    } else {\n        if (is_dc && chroma422) { // dc 422\n            DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]);\n        } else {\n            coeff_count = decode_significance(CC, max_coeff, significant_coeff_ctx_base, index,\n                                                 last_coeff_ctx_base-significant_coeff_ctx_base);\n        }\n#else\n        DECODE_SIGNIFICANCE( 63, sig_off[last], ff_h264_last_coeff_flag_offset_8x8[last] );\n    } else {\n        if (is_dc && chroma422) { // dc 422\n            DECODE_SIGNIFICANCE(7, sig_coeff_offset_dc[last], sig_coeff_offset_dc[last]);\n        } else {\n            DECODE_SIGNIFICANCE(max_coeff - 1, last, last);\n        }\n#endif\n    }\n    assert(coeff_count > 0);\n\n    if( is_dc ) {\n        if( cat == 3 )\n            h->cbp_table[sl->mb_xy] |= 0x40 << (n - CHROMA_DC_BLOCK_INDEX);\n        else\n            h->cbp_table[sl->mb_xy] |= 0x100 << (n - LUMA_DC_BLOCK_INDEX);\n        sl->non_zero_count_cache[scan8[n]] = coeff_count;\n    } else {\n        if( max_coeff == 64 )\n            fill_rectangle(&sl->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);\n        else {\n            assert( cat == 1 || cat ==  2 || cat ==  4 || cat == 7 || cat == 8 || cat == 11 || cat == 12 );\n            sl->non_zero_count_cache[scan8[n]] = coeff_count;\n        }\n    }\n\n#define STORE_BLOCK(type) \\\n    do { \\\n        uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base; \\\n \\\n        int j= scantable[index[--coeff_count]]; \\\n \\\n        if( get_cabac( CC, ctx ) == 0 ) { \\\n            node_ctx = coeff_abs_level_transition[0][node_ctx]; \\\n            if( is_dc ) { \\\n                ((type*)block)[j] = get_cabac_bypass_sign( CC, -1); \\\n            }else{ \\\n                ((type*)block)[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6; \\\n            } \\\n        } else { \\\n            int coeff_abs = 2; \\\n            ctx = coeff_abs_levelgt1_ctx[is_dc && chroma422][node_ctx] + abs_level_m1_ctx_base; \\\n            node_ctx = coeff_abs_level_transition[1][node_ctx]; \\\n\\\n            while( coeff_abs < 15 && get_cabac( CC, ctx ) ) { \\\n                coeff_abs++; \\\n            } \\\n\\\n            if( coeff_abs >= 15 ) { \\\n                int j = 0; \\\n                while (get_cabac_bypass(CC) && j < 30) { \\\n                    j++; \\\n                } \\\n\\\n                coeff_abs=1; \\\n                while( j-- ) { \\\n                    coeff_abs += coeff_abs + get_cabac_bypass( CC ); \\\n                } \\\n                coeff_abs+= 14; \\\n            } \\\n\\\n            if( is_dc ) { \\\n                ((type*)block)[j] = get_cabac_bypass_sign( CC, -coeff_abs ); \\\n            }else{ \\\n                ((type*)block)[j] = ((int)(get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32)) >> 6; \\\n            } \\\n        } \\\n    } while ( coeff_count );\n\n    if (h->pixel_shift) {\n        STORE_BLOCK(int32_t)\n    } else {\n        STORE_BLOCK(int16_t)\n    }\n#ifdef CABAC_ON_STACK\n            sl->cabac.range     = cc.range     ;\n            sl->cabac.low       = cc.low       ;\n            sl->cabac.bytestream= cc.bytestream;\n#endif\n\n}"
        ],
        "sink": "STORE_BLOCK(int32_t)",
        "final_sink": "STORE_BLOCK(int32_t)",
        "source": [
            "    InputStream *ist = get_input_stream(ost);"
        ]
    },
    {
        "prt": "qmul",
        "function_call": [
            "static int decode_residual(const H264Context *h, H264SliceContext *sl,\n                           GetBitContext *gb, int16_t *block, int n,\n                           const uint8_t *scantable, const uint32_t *qmul,\n                           int max_coeff)\n{\n    static const int coeff_token_table_index[17]= {0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3};\n    int level[16];\n    int zeros_left, coeff_token, total_coeff, i, trailing_ones, run_before;\n\n    //FIXME put trailing_onex into the context\n\n    if(max_coeff <= 8){\n        if (max_coeff == 4)\n            coeff_token = get_vlc2(gb, chroma_dc_coeff_token_vlc.table, CHROMA_DC_COEFF_TOKEN_VLC_BITS, 1);\n        else\n            coeff_token = get_vlc2(gb, chroma422_dc_coeff_token_vlc.table, CHROMA422_DC_COEFF_TOKEN_VLC_BITS, 1);\n        total_coeff= coeff_token>>2;\n    }else{\n        if(n >= LUMA_DC_BLOCK_INDEX){\n            total_coeff= pred_non_zero_count(h, sl, (n - LUMA_DC_BLOCK_INDEX)*16);\n            coeff_token= get_vlc2(gb, coeff_token_vlc[ coeff_token_table_index[total_coeff] ].table, COEFF_TOKEN_VLC_BITS, 2);\n            total_coeff= coeff_token>>2;\n        }else{\n            total_coeff= pred_non_zero_count(h, sl, n);\n            coeff_token= get_vlc2(gb, coeff_token_vlc[ coeff_token_table_index[total_coeff] ].table, COEFF_TOKEN_VLC_BITS, 2);\n            total_coeff= coeff_token>>2;\n        }\n    }\n    sl->non_zero_count_cache[scan8[n]] = total_coeff;\n\n    //FIXME set last_non_zero?\n\n    if(total_coeff==0)\n        return 0;\n    if(total_coeff > (unsigned)max_coeff) {\n        av_log(h->avctx, AV_LOG_ERROR, \"corrupted macroblock %d %d (total_coeff=%d)\\n\", sl->mb_x, sl->mb_y, total_coeff);\n        return -1;\n    }\n\n    trailing_ones= coeff_token&3;\n    ff_tlog(h->avctx, \"trailing:%d, total:%d\\n\", trailing_ones, total_coeff);\n    assert(total_coeff<=16);\n\n    i = show_bits(gb, 3);\n    skip_bits(gb, trailing_ones);\n    level[0] = 1-((i&4)>>1);\n    level[1] = 1-((i&2)   );\n    level[2] = 1-((i&1)<<1);\n\n    if(trailing_ones<total_coeff) {\n        int mask, prefix;\n        int suffix_length = total_coeff > 10 & trailing_ones < 3;\n        int bitsi= show_bits(gb, LEVEL_TAB_BITS);\n        int level_code= cavlc_level_tab[suffix_length][bitsi][0];\n\n        skip_bits(gb, cavlc_level_tab[suffix_length][bitsi][1]);\n        if(level_code >= 100){\n            prefix= level_code - 100;\n            if(prefix == LEVEL_TAB_BITS)\n                prefix += get_level_prefix(gb);\n\n            //first coefficient has suffix_length equal to 0 or 1\n            if(prefix<14){ //FIXME try to build a large unified VLC table for all this\n                if(suffix_length)\n                    level_code= (prefix<<1) + get_bits1(gb); //part\n                else\n                    level_code= prefix; //part\n            }else if(prefix==14){\n                if(suffix_length)\n                    level_code= (prefix<<1) + get_bits1(gb); //part\n                else\n                    level_code= prefix + get_bits(gb, 4); //part\n            }else{\n                level_code= 30 + get_bits(gb, prefix-3); //part\n                if(prefix>=16){\n                    if(prefix > 25+3){\n                        av_log(h->avctx, AV_LOG_ERROR, \"Invalid level prefix\\n\");\n                        return -1;\n                    }\n                    level_code += (1<<(prefix-3))-4096;\n                }\n            }\n\n            if(trailing_ones < 3) level_code += 2;\n\n            suffix_length = 2;\n            mask= -(level_code&1);\n            level[trailing_ones]= (((2+level_code)>>1) ^ mask) - mask;\n        }else{\n            level_code += ((level_code>>31)|1) & -(trailing_ones < 3);\n\n            suffix_length = 1 + (level_code + 3U > 6U);\n            level[trailing_ones]= level_code;\n        }\n\n        //remaining coefficients have suffix_length > 0\n        for(i=trailing_ones+1;i<total_coeff;i++) {\n            static const unsigned int suffix_limit[7] = {0,3,6,12,24,48,INT_MAX };\n            int bitsi= show_bits(gb, LEVEL_TAB_BITS);\n            level_code= cavlc_level_tab[suffix_length][bitsi][0];\n\n            skip_bits(gb, cavlc_level_tab[suffix_length][bitsi][1]);\n            if(level_code >= 100){\n                prefix= level_code - 100;\n                if(prefix == LEVEL_TAB_BITS){\n                    prefix += get_level_prefix(gb);\n                }\n                if(prefix<15){\n                    level_code = (prefix<<suffix_length) + get_bits(gb, suffix_length);\n                }else{\n                    level_code = (15<<suffix_length) + get_bits(gb, prefix-3);\n                    if(prefix>=16)\n                        level_code += (1<<(prefix-3))-4096;\n                }\n                mask= -(level_code&1);\n                level_code= (((2+level_code)>>1) ^ mask) - mask;\n            }\n            level[i]= level_code;\n            suffix_length+= suffix_limit[suffix_length] + level_code > 2U*suffix_limit[suffix_length];\n        }\n    }\n\n    if(total_coeff == max_coeff)\n        zeros_left=0;\n    else{\n        if (max_coeff <= 8) {\n            if (max_coeff == 4)\n                zeros_left = get_vlc2(gb, chroma_dc_total_zeros_vlc[total_coeff - 1].table,\n                                      CHROMA_DC_TOTAL_ZEROS_VLC_BITS, 1);\n            else\n                zeros_left = get_vlc2(gb, chroma422_dc_total_zeros_vlc[total_coeff - 1].table,\n                                      CHROMA422_DC_TOTAL_ZEROS_VLC_BITS, 1);\n        } else {\n            zeros_left= get_vlc2(gb, total_zeros_vlc[total_coeff - 1].table, TOTAL_ZEROS_VLC_BITS, 1);\n        }\n    }\n\n#define STORE_BLOCK(type) \\\n    scantable += zeros_left + total_coeff - 1; \\\n    if(n >= LUMA_DC_BLOCK_INDEX){ \\\n        ((type*)block)[*scantable] = level[0]; \\\n        for(i=1;i<total_coeff && zeros_left > 0;i++) { \\\n            if(zeros_left < 7) \\\n                run_before= get_vlc2(gb, run_vlc[zeros_left - 1].table, RUN_VLC_BITS, 1); \\\n            else {\\\n                run_before= get_vlc2(gb, run7_vlc.table, RUN7_VLC_BITS, 2); \\\n                run_before = FFMIN(zeros_left, run_before);\\\n            }\\\n            zeros_left -= run_before; \\\n            scantable -= 1 + run_before; \\\n            ((type*)block)[*scantable]= level[i]; \\\n        } \\\n        for(;i<total_coeff;i++) { \\\n            scantable--; \\\n            ((type*)block)[*scantable]= level[i]; \\\n        } \\\n    }else{ \\\n        ((type*)block)[*scantable] = ((int)(level[0] * qmul[*scantable] + 32))>>6; \\\n        for(i=1;i<total_coeff && zeros_left > 0;i++) { \\\n            if(zeros_left < 7) \\\n                run_before= get_vlc2(gb, run_vlc[zeros_left - 1].table, RUN_VLC_BITS, 1); \\\n            else {\\\n                run_before= get_vlc2(gb, run7_vlc.table, RUN7_VLC_BITS, 2); \\\n                run_before = FFMIN(zeros_left, run_before);\\\n            }\\\n            zeros_left -= run_before; \\\n            scantable -= 1 + run_before; \\\n            ((type*)block)[*scantable]= ((int)(level[i] * qmul[*scantable] + 32))>>6; \\\n        } \\\n        for(;i<total_coeff;i++) { \\\n            scantable--; \\\n            ((type*)block)[*scantable]= ((int)(level[i] * qmul[*scantable] + 32))>>6; \\\n        } \\\n    }\n\n    if (zeros_left < 0) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"negative number of zero coeffs at %d %d\\n\", sl->mb_x, sl->mb_y);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (h->pixel_shift) {\n        STORE_BLOCK(int32_t)\n    } else {\n        STORE_BLOCK(int16_t)\n    }\n\n    return 0;\n}"
        ],
        "sink": "STORE_BLOCK(int32_t)",
        "final_sink": "STORE_BLOCK(int32_t)",
        "source": []
    },
    {
        "prt": "info",
        "function_call": [
            "static void frame_list_remove_samples(FrameList *frame_list, int nb_samples)\n{\n    if (nb_samples >= frame_list->nb_samples) {\n        frame_list_clear(frame_list);\n    } else {\n        int samples = nb_samples;\n        while (samples > 0) {\n            FrameInfo *info = frame_list->list;\n            av_assert0(info != NULL);\n            if (info->nb_samples <= samples) {\n                samples -= info->nb_samples;\n                frame_list->list = info->next;\n                if (!frame_list->list)\n                    frame_list->end = NULL;\n                frame_list->nb_frames--;\n                frame_list->nb_samples -= info->nb_samples;\n                av_free(info);\n            } else {\n                info->nb_samples       -= samples;\n                info->pts              += samples;\n                frame_list->nb_samples -= samples;\n                samples = 0;\n            }\n        }\n    }\n}"
        ],
        "sink": "if (info->nb_samples <= samples) {",
        "final_sink": "if (info->nb_samples <= samples) {",
        "source": [
            "    const char *type_name = av_hwdevice_get_type_name(type);"
        ]
    },
    {
        "prt": "*oldref",
        "function_call": [
            "void ff_channel_layouts_changeref(AVFilterChannelLayouts **oldref,\n                                  AVFilterChannelLayouts **newref)\n{\n    FORMATS_CHANGEREF(oldref, newref);\n}"
        ],
        "sink": "FORMATS_CHANGEREF(oldref, newref);",
        "final_sink": "FORMATS_CHANGEREF(oldref, newref);",
        "source": [
            "        char *buf = NULL, *arg = NULL, *preset = NULL;"
        ]
    },
    {
        "prt": "*oldref",
        "function_call": [
            "void ff_formats_changeref(AVFilterFormats **oldref, AVFilterFormats **newref)\n{\n    FORMATS_CHANGEREF(oldref, newref);\n}"
        ],
        "sink": "FORMATS_CHANGEREF(oldref, newref);",
        "final_sink": "FORMATS_CHANGEREF(oldref, newref);",
        "source": [
            "    AVDictionary **meta_in = NULL;"
        ]
    },
    {
        "prt": "minvar",
        "function_call": [
            "static int hls_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    HLSContext *c = s->priv_data;\n    int ret, i, minvariant = -1;\n\n    if (c->first_packet) {\n        recheck_discard_flags(s, 1);\n        c->first_packet = 0;\n    }\n\nstart:\n    c->end_of_segment = 0;\n    for (i = 0; i < c->n_variants; i++) {\n        struct variant *var = c->variants[i];\n        /* Make sure we've got one buffered packet from each open variant\n         * stream */\n        if (var->needed && !var->pkt.data) {\n            while (1) {\n                int64_t ts_diff;\n                AVStream *st;\n                ret = av_read_frame(var->ctx, &var->pkt);\n                if (ret < 0) {\n                    if (!var->pb.eof_reached)\n                        return ret;\n                    reset_packet(&var->pkt);\n                    break;\n                } else {\n                    if (c->first_timestamp == AV_NOPTS_VALUE &&\n                        var->pkt.dts       != AV_NOPTS_VALUE)\n                        c->first_timestamp = av_rescale_q(var->pkt.dts,\n                            var->ctx->streams[var->pkt.stream_index]->time_base,\n                            AV_TIME_BASE_Q);\n                }\n\n                if (c->seek_timestamp == AV_NOPTS_VALUE)\n                    break;\n\n                if (var->pkt.dts == AV_NOPTS_VALUE) {\n                    c->seek_timestamp = AV_NOPTS_VALUE;\n                    break;\n                }\n\n                st = var->ctx->streams[var->pkt.stream_index];\n                ts_diff = av_rescale_rnd(var->pkt.dts, AV_TIME_BASE,\n                                         st->time_base.den, AV_ROUND_DOWN) -\n                          c->seek_timestamp;\n                if (ts_diff >= 0 && (c->seek_flags  & AVSEEK_FLAG_ANY ||\n                                     var->pkt.flags & AV_PKT_FLAG_KEY)) {\n                    c->seek_timestamp = AV_NOPTS_VALUE;\n                    break;\n                }\n                av_packet_unref(&var->pkt);\n                reset_packet(&var->pkt);\n            }\n        }\n        /* Check if this stream still is on an earlier segment number, or\n         * has the packet with the lowest dts */\n        if (var->pkt.data) {\n            struct variant *minvar = minvariant < 0 ?\n                                     NULL : c->variants[minvariant];\n            if (minvariant < 0 || var->cur_seq_no < minvar->cur_seq_no) {\n                minvariant = i;\n            } else if (var->cur_seq_no == minvar->cur_seq_no) {\n                int64_t dts     =    var->pkt.dts;\n                int64_t mindts  = minvar->pkt.dts;\n                AVStream *st    =    var->ctx->streams[var->pkt.stream_index];\n                AVStream *minst = minvar->ctx->streams[minvar->pkt.stream_index];\n\n                if (dts == AV_NOPTS_VALUE) {\n                    minvariant = i;\n                } else if (mindts != AV_NOPTS_VALUE) {\n                    if (st->start_time    != AV_NOPTS_VALUE)\n                        dts    -= st->start_time;\n                    if (minst->start_time != AV_NOPTS_VALUE)\n                        mindts -= minst->start_time;\n\n                    if (av_compare_ts(dts, st->time_base,\n                                      mindts, minst->time_base) < 0)\n                        minvariant = i;\n                }\n            }\n        }\n    }\n    if (c->end_of_segment) {\n        if (recheck_discard_flags(s, 0))\n            goto start;\n    }\n    /* If we got a packet, return it */\n    if (minvariant >= 0) {\n        *pkt = c->variants[minvariant]->pkt;\n        pkt->stream_index += c->variants[minvariant]->stream_offset;\n        reset_packet(&c->variants[minvariant]->pkt);\n        return 0;\n    }\n    return AVERROR_EOF;\n}"
        ],
        "sink": "} else if (var->cur_seq_no == minvar->cur_seq_no) {",
        "final_sink": "} else if (var->cur_seq_no == minvar->cur_seq_no) {",
        "source": [
            "    AVDictionary **meta_in = NULL;"
        ]
    },
    {
        "prt": "p",
        "function_call": [
            "const char *avio_enum_protocols(void **opaque, int output)\n{\n    const URLProtocol **p = *opaque;\n\n    p = p ? p + 1 : url_protocols;\n    *opaque = p;\n    if (!*p) {\n        *opaque = NULL;\n        return NULL;\n    }\n    if ((output && (*p)->url_write) || (!output && (*p)->url_read))\n        return (*p)->name;\n    return avio_enum_protocols(opaque, output);\n}"
        ],
        "sink": "if (!*p) {",
        "final_sink": "if (!*p) {",
        "source": []
    },
    {
        "prt": "bufptr",
        "function_call": [
            "static int rtp_parse_one_packet(RTPDemuxContext *s, AVPacket *pkt,\n                                uint8_t **bufptr, int len)\n{\n    uint8_t *buf = bufptr ? *bufptr : NULL;\n    int flags = 0;\n    uint32_t timestamp;\n    int rv = 0;\n\n    if (!buf) {\n        /* If parsing of the previous packet actually returned 0 or an error,\n         * there's nothing more to be parsed from that packet, but we may have\n         * indicated that we can return the next enqueued packet. */\n        if (s->prev_ret <= 0)\n            return rtp_parse_queued_packet(s, pkt);\n        /* return the next packets, if any */\n        if (s->handler && s->handler->parse_packet) {\n            /* timestamp should be overwritten by parse_packet, if not,\n             * the packet is left with pts == AV_NOPTS_VALUE */\n            timestamp = RTP_NOTS_VALUE;\n            rv        = s->handler->parse_packet(s->ic, s->dynamic_protocol_context,\n                                                 s->st, pkt, &timestamp, NULL, 0, 0,\n                                                 flags);\n            finalize_packet(s, pkt, timestamp);\n            return rv;\n        }\n    }\n\n    if (len < 12)\n        return -1;\n\n    if ((buf[0] & 0xc0) != (RTP_VERSION << 6))\n        return -1;\n    if (RTP_PT_IS_RTCP(buf[1])) {\n        return rtcp_parse_packet(s, buf, len);\n    }\n\n    if (s->st) {\n        int64_t received = av_gettime_relative();\n        uint32_t arrival_ts = av_rescale_q(received, AV_TIME_BASE_Q,\n                                           s->st->time_base);\n        timestamp = AV_RB32(buf + 4);\n        // Calculate the jitter immediately, before queueing the packet\n        // into the reordering queue.\n        rtcp_update_jitter(&s->statistics, timestamp, arrival_ts);\n    }\n\n    if ((s->seq == 0 && !s->queue) || s->queue_size <= 1) {\n        /* First packet, or no reordering */\n        return rtp_parse_packet_internal(s, pkt, buf, len);\n    } else {\n        uint16_t seq = AV_RB16(buf + 2);\n        int16_t diff = seq - s->seq;\n        if (diff < 0) {\n            /* Packet older than the previously emitted one, drop */\n            av_log(s->ic, AV_LOG_WARNING,\n                   \"RTP: dropping old packet received too late\\n\");\n            return -1;\n        } else if (diff <= 1) {\n            /* Correct packet */\n            rv = rtp_parse_packet_internal(s, pkt, buf, len);\n            return rv;\n        } else {\n            /* Still missing some packet, enqueue this one. */\n            rv = enqueue_packet(s, buf, len);\n            if (rv < 0)\n                return rv;\n            *bufptr = NULL;\n            /* Return the first enqueued packet if the queue is full,\n             * even if we're missing something */\n            if (s->queue_len >= s->queue_size) {\n                av_log(s->ic, AV_LOG_WARNING, \"jitter buffer full\\n\");\n                return rtp_parse_queued_packet(s, pkt);\n            }\n            return -1;\n        }\n    }\n}"
        ],
        "sink": "*bufptr = NULL;",
        "final_sink": "*bufptr = NULL;",
        "source": [
            "            arg = \"0\";"
        ]
    },
    {
        "prt": "cur_ai",
        "function_call": [
            "static int tcp_open(URLContext *h, const char *uri, int flags)\n{\n    struct addrinfo hints = { 0 }, *ai, *cur_ai;\n    int port, fd = -1;\n    TCPContext *s = h->priv_data;\n    const char *p;\n    char buf[256];\n    int ret;\n    char hostname[1024],proto[1024],path[1024];\n    char portstr[10];\n\n    av_url_split(proto, sizeof(proto), NULL, 0, hostname, sizeof(hostname),\n        &port, path, sizeof(path), uri);\n    if (strcmp(proto, \"tcp\"))\n        return AVERROR(EINVAL);\n    if (port <= 0 || port >= 65536) {\n        av_log(h, AV_LOG_ERROR, \"Port missing in uri\\n\");\n        return AVERROR(EINVAL);\n    }\n    p = strchr(uri, '?');\n    if (p) {\n        if (av_find_info_tag(buf, sizeof(buf), \"listen\", p))\n            s->listen = 1;\n        if (av_find_info_tag(buf, sizeof(buf), \"timeout\", p)) {\n            s->timeout = strtol(buf, NULL, 10) * 100;\n        }\n        if (av_find_info_tag(buf, sizeof(buf), \"listen_timeout\", p)) {\n            s->listen_timeout = strtol(buf, NULL, 10);\n        }\n    }\n    if (!s->timeout)\n        s->timeout = h->rw_timeout ? h->rw_timeout / 1000 : 10000;\n    if (h->rw_timeout && s->listen_timeout < 0)\n        s->listen_timeout = h->rw_timeout / 1000;\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    snprintf(portstr, sizeof(portstr), \"%d\", port);\n    if (s->listen)\n        hints.ai_flags |= AI_PASSIVE;\n    if (!hostname[0])\n        ret = getaddrinfo(NULL, portstr, &hints, &ai);\n    else\n        ret = getaddrinfo(hostname, portstr, &hints, &ai);\n    if (ret) {\n        av_log(h, AV_LOG_ERROR,\n               \"Failed to resolve hostname %s: %s\\n\",\n               hostname, gai_strerror(ret));\n        return AVERROR(EIO);\n    }\n\n    cur_ai = ai;\n\n    if (s->listen) {\n        while (cur_ai && fd < 0) {\n            fd = ff_socket(cur_ai->ai_family,\n                           cur_ai->ai_socktype,\n                           cur_ai->ai_protocol);\n            if (fd < 0) {\n                ret = ff_neterrno();\n                cur_ai = cur_ai->ai_next;\n            }\n        }\n        if (fd < 0)\n            goto fail1;\n\n        if ((ret = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,\n                                  s->listen_timeout, h)) < 0) {\n            goto fail1;\n        }\n        fd = ret;\n    } else {\n        ret = ff_connect_parallel(ai, s->timeout, 3, h, &fd, NULL, NULL);\n        if (ret < 0)\n            goto fail1;\n    }\n\n    h->is_streamed = 1;\n    s->fd = fd;\n    freeaddrinfo(ai);\n    return 0;\n\n fail1:\n    if (fd >= 0)\n        closesocket(fd);\n    freeaddrinfo(ai);\n    return ret;\n}"
        ],
        "sink": "if ((ret = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,",
        "final_sink": "if ((ret = ff_listen_bind(fd, cur_ai->ai_addr, cur_ai->ai_addrlen,",
        "source": [
            "    ChannelElement *che = NULL, *che_prev = NULL;",
            "            if (!(che=get_che(ac, elem_type, elem_id))) {"
        ]
    },
    {
        "prt": "pkt",
        "function_call": [
            "static int probe_codec(AVFormatContext *s, AVStream *st, const AVPacket *pkt)\n{\n    if (st->codecpar->codec_id == AV_CODEC_ID_PROBE) {\n        AVProbeData *pd = &st->probe_data;\n        av_log(s, AV_LOG_DEBUG, \"probing stream %d\\n\", st->index);\n        --st->probe_packets;\n\n        if (pkt) {\n            int err;\n            if ((err = av_reallocp(&pd->buf, pd->buf_size + pkt->size +\n                                   AVPROBE_PADDING_SIZE)) < 0)\n                return err;\n            memcpy(pd->buf + pd->buf_size, pkt->data, pkt->size);\n            pd->buf_size += pkt->size;\n            memset(pd->buf + pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n        } else {\n            st->probe_packets = 0;\n            if (!pd->buf_size) {\n                av_log(s, AV_LOG_ERROR,\n                       \"nothing to probe for stream %d\\n\", st->index);\n                return 0;\n            }\n        }\n\n        if (!st->probe_packets ||\n            av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)) {\n            set_codec_from_probe_data(s, st, pd, st->probe_packets > 0\n                                                 ? AVPROBE_SCORE_MAX / 4 : 0);\n            if (st->codecpar->codec_id != AV_CODEC_ID_PROBE) {\n                pd->buf_size = 0;\n                av_freep(&pd->buf);\n                av_log(s, AV_LOG_DEBUG, \"probed stream %d\\n\", st->index);\n            }\n        }\n    }\n    return 0;\n}"
        ],
        "sink": "av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)) {",
        "final_sink": "av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)) {",
        "source": [
            "    ChannelElement *che = NULL, *che_prev = NULL;",
            "            if (!(che=get_che(ac, elem_type, elem_id))) {"
        ]
    }
]