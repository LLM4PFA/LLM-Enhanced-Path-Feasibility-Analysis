[
    {
        "prt": "desc",
        "function_call": [
            "static int xwd_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n                            const AVFrame *p, int *got_packet)\n{\n    enum AVPixelFormat pix_fmt = avctx->pix_fmt;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);\n    uint32_t pixdepth, bpp, bpad, ncolors = 0, lsize, vclass, be = 0;\n    uint32_t rgb[3] = { 0 }, bitorder = 0;\n    uint32_t header_size;\n    int i, out_size, ret;\n    uint8_t *ptr, *buf;\n\n    pixdepth = av_get_bits_per_pixel(desc);\n    if (desc->flags & AV_PIX_FMT_FLAG_BE)\n        be = 1;\n    switch (pix_fmt) {\n    case AV_PIX_FMT_ARGB:\n    case AV_PIX_FMT_BGRA:\n    case AV_PIX_FMT_RGBA:\n    case AV_PIX_FMT_ABGR:\n        if (pix_fmt == AV_PIX_FMT_ARGB ||\n            pix_fmt == AV_PIX_FMT_ABGR)\n            be = 1;\n        if (pix_fmt == AV_PIX_FMT_ABGR ||\n            pix_fmt == AV_PIX_FMT_RGBA) {\n            rgb[0] = 0xFF;\n            rgb[1] = 0xFF00;\n            rgb[2] = 0xFF0000;\n        } else {\n            rgb[0] = 0xFF0000;\n            rgb[1] = 0xFF00;\n            rgb[2] = 0xFF;\n        }\n        bpp      = 32;\n        pixdepth = 24;\n        vclass   = XWD_TRUE_COLOR;\n        bpad     = 32;\n        break;\n    case AV_PIX_FMT_BGR24:\n    case AV_PIX_FMT_RGB24:\n        if (pix_fmt == AV_PIX_FMT_RGB24)\n            be = 1;\n        bpp      = 24;\n        vclass   = XWD_TRUE_COLOR;\n        bpad     = 32;\n        rgb[0]   = 0xFF0000;\n        rgb[1]   = 0xFF00;\n        rgb[2]   = 0xFF;\n        break;\n    case AV_PIX_FMT_RGB565LE:\n    case AV_PIX_FMT_RGB565BE:\n    case AV_PIX_FMT_BGR565LE:\n    case AV_PIX_FMT_BGR565BE:\n        if (pix_fmt == AV_PIX_FMT_BGR565LE ||\n            pix_fmt == AV_PIX_FMT_BGR565BE) {\n            rgb[0] = 0x1F;\n            rgb[1] = 0x7E0;\n            rgb[2] = 0xF800;\n        } else {\n            rgb[0] = 0xF800;\n            rgb[1] = 0x7E0;\n            rgb[2] = 0x1F;\n        }\n        bpp      = 16;\n        vclass   = XWD_TRUE_COLOR;\n        bpad     = 16;\n        break;\n    case AV_PIX_FMT_RGB555LE:\n    case AV_PIX_FMT_RGB555BE:\n    case AV_PIX_FMT_BGR555LE:\n    case AV_PIX_FMT_BGR555BE:\n        if (pix_fmt == AV_PIX_FMT_BGR555LE ||\n            pix_fmt == AV_PIX_FMT_BGR555BE) {\n            rgb[0] = 0x1F;\n            rgb[1] = 0x3E0;\n            rgb[2] = 0x7C00;\n        } else {\n            rgb[0] = 0x7C00;\n            rgb[1] = 0x3E0;\n            rgb[2] = 0x1F;\n        }\n        bpp      = 16;\n        vclass   = XWD_TRUE_COLOR;\n        bpad     = 16;\n        break;\n    case AV_PIX_FMT_RGB8:\n    case AV_PIX_FMT_BGR8:\n    case AV_PIX_FMT_RGB4_BYTE:\n    case AV_PIX_FMT_BGR4_BYTE:\n    case AV_PIX_FMT_PAL8:\n        bpp      = 8;\n        vclass   = XWD_PSEUDO_COLOR;\n        bpad     = 8;\n        ncolors  = 256;\n        break;\n    case AV_PIX_FMT_MONOWHITE:\n        be       = 1;\n        bitorder = 1;\n        bpp      = 1;\n        bpad     = 8;\n        vclass   = XWD_STATIC_GRAY;\n        break;\n    default:\n        av_log(avctx, AV_LOG_INFO, \"unsupported pixel format\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    lsize       = FFALIGN(bpp * avctx->width, bpad) / 8;\n    header_size = XWD_HEADER_SIZE + WINDOW_NAME_SIZE;\n    out_size    = header_size + ncolors * XWD_CMAP_SIZE + avctx->height * lsize;\n\n    if ((ret = ff_alloc_packet(pkt, out_size)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"output buffer too small\\n\");\n        return ret;\n    }\n    buf = pkt->data;\n\n#if FF_API_CODED_FRAME\nFF_DISABLE_DEPRECATION_WARNINGS\n    avctx->coded_frame->key_frame = 1;\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    bytestream_put_be32(&buf, header_size);\n    bytestream_put_be32(&buf, XWD_VERSION);   // file version\n    bytestream_put_be32(&buf, XWD_Z_PIXMAP);  // pixmap format\n    bytestream_put_be32(&buf, pixdepth);      // pixmap depth in pixels\n    bytestream_put_be32(&buf, avctx->width);  // pixmap width in pixels\n    bytestream_put_be32(&buf, avctx->height); // pixmap height in pixels\n    bytestream_put_be32(&buf, 0);             // bitmap x offset\n    bytestream_put_be32(&buf, be);            // byte order\n    bytestream_put_be32(&buf, 32);            // bitmap unit\n    bytestream_put_be32(&buf, bitorder);      // bit-order of image data\n    bytestream_put_be32(&buf, bpad);          // bitmap scan-line pad in bits\n    bytestream_put_be32(&buf, bpp);           // bits per pixel\n    bytestream_put_be32(&buf, lsize);         // bytes per scan-line\n    bytestream_put_be32(&buf, vclass);        // visual class\n    bytestream_put_be32(&buf, rgb[0]);        // red mask\n    bytestream_put_be32(&buf, rgb[1]);        // green mask\n    bytestream_put_be32(&buf, rgb[2]);        // blue mask\n    bytestream_put_be32(&buf, 8);             // size of each bitmask in bits\n    bytestream_put_be32(&buf, ncolors);       // number of colors\n    bytestream_put_be32(&buf, ncolors);       // number of entries in color map\n    bytestream_put_be32(&buf, avctx->width);  // window width\n    bytestream_put_be32(&buf, avctx->height); // window height\n    bytestream_put_be32(&buf, 0);             // window upper left X coordinate\n    bytestream_put_be32(&buf, 0);             // window upper left Y coordinate\n    bytestream_put_be32(&buf, 0);             // window border width\n    bytestream_put_buffer(&buf, WINDOW_NAME, WINDOW_NAME_SIZE);\n\n    for (i = 0; i < ncolors; i++) {\n        uint32_t val;\n        uint8_t red, green, blue;\n\n        val   = AV_RN32A(p->data[1] + i * 4);\n        red   = (val >> 16) & 0xFF;\n        green = (val >>  8) & 0xFF;\n        blue  =  val        & 0xFF;\n\n        bytestream_put_be32(&buf, i);         // colormap entry number\n        bytestream_put_be16(&buf, red   << 8);\n        bytestream_put_be16(&buf, green << 8);\n        bytestream_put_be16(&buf, blue  << 8);\n        bytestream_put_byte(&buf, 0x7);       // bitmask flag\n        bytestream_put_byte(&buf, 0);         // padding\n    }\n\n    ptr = p->data[0];\n    for (i = 0; i < avctx->height; i++) {\n        bytestream_put_buffer(&buf, ptr, lsize);\n        ptr += p->linesize[0];\n    }\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n    *got_packet = 1;\n    return 0;\n}"
        ],
        "sink": "if (desc->flags & AV_PIX_FMT_FLAG_BE)",
        "final_sink": "if (desc->flags & AV_PIX_FMT_FLAG_BE)",
        "source": [
            "    InputStream *ist = get_input_stream(ost);"
        ],
        "index": 0
    },
    {
        "prt": "movie->format_ctx",
        "function_call": [
            "static av_cold int movie_init(AVFilterContext *ctx)\n{\n    MovieContext *movie = ctx->priv;\n    AVInputFormat *iformat = NULL;\n    AVStream *st;\n    AVCodec *codec;\n    int ret;\n    int64_t timestamp;\n\n    av_register_all();\n\n    // Try to find the movie format (container)\n    iformat = movie->format_name ? av_find_input_format(movie->format_name) : NULL;\n\n    movie->format_ctx = NULL;\n    if ((ret = avformat_open_input(&movie->format_ctx, movie->file_name, iformat, NULL)) < 0) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"Failed to avformat_open_input '%s'\\n\", movie->file_name);\n        return ret;\n    }\n    if ((ret = avformat_find_stream_info(movie->format_ctx, NULL)) < 0)\n        av_log(ctx, AV_LOG_WARNING, \"Failed to find stream info\\n\");\n\n    // if seeking requested, we execute it\n    if (movie->seek_point > 0) {\n        timestamp = movie->seek_point;\n        // add the stream start time, should it exist\n        if (movie->format_ctx->start_time != AV_NOPTS_VALUE) {\n            if (timestamp > INT64_MAX - movie->format_ctx->start_time) {\n                av_log(ctx, AV_LOG_ERROR,\n                       \"%s: seek value overflow with start_time:%\"PRId64\" seek_point:%\"PRId64\"\\n\",\n                       movie->file_name, movie->format_ctx->start_time, movie->seek_point);\n                return AVERROR(EINVAL);\n            }\n            timestamp += movie->format_ctx->start_time;\n        }\n        if ((ret = av_seek_frame(movie->format_ctx, -1, timestamp, AVSEEK_FLAG_BACKWARD)) < 0) {\n            av_log(ctx, AV_LOG_ERROR, \"%s: could not seek to position %\"PRId64\"\\n\",\n                   movie->file_name, timestamp);\n            return ret;\n        }\n    }\n\n    /* select the video stream */\n    if ((ret = av_find_best_stream(movie->format_ctx, AVMEDIA_TYPE_VIDEO,\n                                   movie->stream_index, -1, NULL, 0)) < 0) {\n        av_log(ctx, AV_LOG_ERROR, \"No video stream with index '%d' found\\n\",\n               movie->stream_index);\n        return ret;\n    }\n    movie->stream_index = ret;\n    st = movie->format_ctx->streams[movie->stream_index];\n\n    /*\n     * So now we've got a pointer to the so-called codec context for our video\n     * stream, but we still have to find the actual codec and open it.\n     */\n    codec = avcodec_find_decoder(st->codecpar->codec_id);\n    if (!codec) {\n        av_log(ctx, AV_LOG_ERROR, \"Failed to find any codec\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    movie->codec_ctx = avcodec_alloc_context3(codec);\n    if (!movie->codec_ctx)\n        return AVERROR(ENOMEM);\n\n    ret = avcodec_parameters_to_context(movie->codec_ctx, st->codecpar);\n    if (ret < 0)\n        return ret;\n\n    movie->codec_ctx->refcounted_frames = 1;\n\n    if ((ret = avcodec_open2(movie->codec_ctx, codec, NULL)) < 0) {\n        av_log(ctx, AV_LOG_ERROR, \"Failed to open codec\\n\");\n        return ret;\n    }\n\n    movie->w = movie->codec_ctx->width;\n    movie->h = movie->codec_ctx->height;\n\n    av_log(ctx, AV_LOG_VERBOSE, \"seek_point:%\"PRIi64\" format_name:%s file_name:%s stream_index:%d\\n\",\n           movie->seek_point, movie->format_name, movie->file_name,\n           movie->stream_index);\n\n    return 0;\n}"
        ],
        "sink": "if (movie->format_ctx->start_time != AV_NOPTS_VALUE) {",
        "final_sink": "if (movie->format_ctx->start_time != AV_NOPTS_VALUE) {",
        "source": [],
        "index": 1
    },
    {
        "prt": "movie->format_ctx",
        "function_call": [
            "static av_cold int movie_init(AVFilterContext *ctx)\n{\n    MovieContext *movie = ctx->priv;\n    AVInputFormat *iformat = NULL;\n    AVStream *st;\n    AVCodec *codec;\n    int ret;\n    int64_t timestamp;\n\n    av_register_all();\n\n    // Try to find the movie format (container)\n    iformat = movie->format_name ? av_find_input_format(movie->format_name) : NULL;\n\n    movie->format_ctx = NULL;\n    if ((ret = avformat_open_input(&movie->format_ctx, movie->file_name, iformat, NULL)) < 0) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"Failed to avformat_open_input '%s'\\n\", movie->file_name);\n        return ret;\n    }\n    if ((ret = avformat_find_stream_info(movie->format_ctx, NULL)) < 0)\n        av_log(ctx, AV_LOG_WARNING, \"Failed to find stream info\\n\");\n\n    // if seeking requested, we execute it\n    if (movie->seek_point > 0) {\n        timestamp = movie->seek_point;\n        // add the stream start time, should it exist\n        if (movie->format_ctx->start_time != AV_NOPTS_VALUE) {\n            if (timestamp > INT64_MAX - movie->format_ctx->start_time) {\n                av_log(ctx, AV_LOG_ERROR,\n                       \"%s: seek value overflow with start_time:%\"PRId64\" seek_point:%\"PRId64\"\\n\",\n                       movie->file_name, movie->format_ctx->start_time, movie->seek_point);\n                return AVERROR(EINVAL);\n            }\n            timestamp += movie->format_ctx->start_time;\n        }\n        if ((ret = av_seek_frame(movie->format_ctx, -1, timestamp, AVSEEK_FLAG_BACKWARD)) < 0) {\n            av_log(ctx, AV_LOG_ERROR, \"%s: could not seek to position %\"PRId64\"\\n\",\n                   movie->file_name, timestamp);\n            return ret;\n        }\n    }\n\n    /* select the video stream */\n    if ((ret = av_find_best_stream(movie->format_ctx, AVMEDIA_TYPE_VIDEO,\n                                   movie->stream_index, -1, NULL, 0)) < 0) {\n        av_log(ctx, AV_LOG_ERROR, \"No video stream with index '%d' found\\n\",\n               movie->stream_index);\n        return ret;\n    }\n    movie->stream_index = ret;\n    st = movie->format_ctx->streams[movie->stream_index];\n\n    /*\n     * So now we've got a pointer to the so-called codec context for our video\n     * stream, but we still have to find the actual codec and open it.\n     */\n    codec = avcodec_find_decoder(st->codecpar->codec_id);\n    if (!codec) {\n        av_log(ctx, AV_LOG_ERROR, \"Failed to find any codec\\n\");\n        return AVERROR(EINVAL);\n    }\n\n    movie->codec_ctx = avcodec_alloc_context3(codec);\n    if (!movie->codec_ctx)\n        return AVERROR(ENOMEM);\n\n    ret = avcodec_parameters_to_context(movie->codec_ctx, st->codecpar);\n    if (ret < 0)\n        return ret;\n\n    movie->codec_ctx->refcounted_frames = 1;\n\n    if ((ret = avcodec_open2(movie->codec_ctx, codec, NULL)) < 0) {\n        av_log(ctx, AV_LOG_ERROR, \"Failed to open codec\\n\");\n        return ret;\n    }\n\n    movie->w = movie->codec_ctx->width;\n    movie->h = movie->codec_ctx->height;\n\n    av_log(ctx, AV_LOG_VERBOSE, \"seek_point:%\"PRIi64\" format_name:%s file_name:%s stream_index:%d\\n\",\n           movie->seek_point, movie->format_name, movie->file_name,\n           movie->stream_index);\n\n    return 0;\n}"
        ],
        "sink": "st = movie->format_ctx->streams[movie->stream_index];",
        "final_sink": "st = movie->format_ctx->streams[movie->stream_index];",
        "source": [
            "    const char *type_name = av_hwdevice_get_type_name(type);"
        ],
        "index": 2
    },
    {
        "prt": "formats",
        "function_call": [
            "static int query_formats(AVFilterContext *ctx)\n{\n    AVFilterFormats *formats;\n    enum AVPixelFormat pix_fmt;\n    int ret;\n\n    if (ctx->inputs[0]) {\n        const AVPixFmtDescriptor *desc = NULL;\n        formats = NULL;\n        while ((desc = av_pix_fmt_desc_next(desc))) {\n            pix_fmt = av_pix_fmt_desc_get_id(desc);\n            if ((sws_isSupportedInput(pix_fmt) ||\n                 sws_isSupportedEndiannessConversion(pix_fmt))\n                && (ret = ff_add_format(&formats, pix_fmt)) < 0) {\n                ff_formats_unref(&formats);\n                return ret;\n            }\n        }\n        ff_formats_ref(formats, &ctx->inputs[0]->out_formats);\n    }\n    if (ctx->outputs[0]) {\n        const AVPixFmtDescriptor *desc = NULL;\n        formats = NULL;\n        while ((desc = av_pix_fmt_desc_next(desc))) {\n            pix_fmt = av_pix_fmt_desc_get_id(desc);\n            if ((sws_isSupportedOutput(pix_fmt) ||\n                 sws_isSupportedEndiannessConversion(pix_fmt))\n                && (ret = ff_add_format(&formats, pix_fmt)) < 0) {\n                ff_formats_unref(&formats);\n                return ret;\n            }\n        }\n        ff_formats_ref(formats, &ctx->outputs[0]->in_formats);\n    }\n\n    return 0;\n}",
            "void ff_formats_ref(AVFilterFormats *f, AVFilterFormats **ref)\n{\n    FORMATS_REF(f, ref);\n}"
        ],
        "sink": "ff_formats_ref(formats, &ctx->inputs[0]->out_formats);",
        "final_sink": "    FORMATS_REF(f, ref);",
        "source": [
            "        char *buf = NULL, *arg = NULL, *preset = NULL;"
        ],
        "index": 3
    },
    {
        "prt": "config",
        "function_call": [
            "static HWDevice *hw_device_match_by_codec(const AVCodec *codec)\n{\n    const AVCodecHWConfig *config;\n    HWDevice *dev;\n    int i;\n    for (i = 0;; i++) {\n        config = avcodec_get_hw_config(codec, i);\n        if (!config)\n            return NULL;\n        if (!(config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX))\n            continue;\n        dev = hw_device_get_by_type(config->device_type);\n        if (dev)\n            return dev;\n    }\n}"
        ],
        "sink": "if (!(config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX))",
        "final_sink": "if (!(config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX))",
        "source": [
            "    AVDictionary **meta_in = NULL;"
        ],
        "index": 4
    },
    {
        "prt": "sub->rects",
        "function_call": [
            "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n                                      int buf_size, AVSubtitle *sub)\n{\n    DVBSubContext *ctx = avctx->priv_data;\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n    DVBSubRegion *region;\n    DVBSubRegionDisplay *display;\n    AVSubtitleRect *rect;\n    DVBSubCLUT *clut;\n    uint32_t *clut_table;\n    int i;\n    int offset_x=0, offset_y=0;\n\n    sub->rects = NULL;\n    sub->start_display_time = 0;\n    sub->end_display_time = ctx->time_out * 1000;\n    sub->format = 0;\n\n    if (display_def) {\n        offset_x = display_def->x;\n        offset_y = display_def->y;\n    }\n\n    sub->num_rects = ctx->display_list_size;\n\n    if (sub->num_rects > 0) {\n        sub->rects = av_mallocz(sizeof(*sub->rects) * sub->num_rects);\n        if (!sub->rects)\n            return AVERROR(ENOMEM);\n        for (i = 0; i < sub->num_rects; i++) {\n            sub->rects[i] = av_mallocz(sizeof(*sub->rects[i]));\n            if (!sub->rects[i]) {\n                int j;\n                for (j = 0; j < i; j ++)\n                    av_free(sub->rects[j]);\n                av_free(sub->rects);\n                return AVERROR(ENOMEM);\n            }\n        }\n    }\n\n    i = 0;\n\n    for (display = ctx->display_list; display; display = display->next) {\n        region = get_region(ctx, display->region_id);\n        rect = sub->rects[i];\n\n        if (!region)\n            continue;\n\n        rect->x = display->x_pos + offset_x;\n        rect->y = display->y_pos + offset_y;\n        rect->w = region->width;\n        rect->h = region->height;\n        rect->nb_colors = 16;\n        rect->type      = SUBTITLE_BITMAP;\n        rect->linesize[0] = region->width;\n\n        clut = get_clut(ctx, region->clut);\n\n        if (!clut)\n            clut = &default_clut;\n\n        switch (region->depth) {\n        case 2:\n            clut_table = clut->clut4;\n            break;\n        case 8:\n            clut_table = clut->clut256;\n            break;\n        case 4:\n        default:\n            clut_table = clut->clut16;\n            break;\n        }\n\n        rect->data[1] = av_mallocz(AVPALETTE_SIZE);\n        if (!rect->data[1]) {\n            for (i = 0; i < sub->num_rects; i++)\n                av_free(sub->rects[i]);\n            av_free(sub->rects);\n            return AVERROR(ENOMEM);\n        }\n        memcpy(rect->data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n        rect->data[0] = av_malloc(region->buf_size);\n        if (!rect->data[0]) {\n            av_free(rect->data[1]);\n            for (i = 0; i < sub->num_rects; i++)\n                av_free(sub->rects[i]);\n            av_free(sub->rects);\n            return AVERROR(ENOMEM);\n        }\n        memcpy(rect->data[0], region->pbuf, region->buf_size);\n\n#if FF_API_AVPICTURE\nFF_DISABLE_DEPRECATION_WARNINGS\n{\n        int j;\n        for (j = 0; j < 4; j++) {\n            rect->pict.data[j] = rect->data[j];\n            rect->pict.linesize[j] = rect->linesize[j];\n        }\n}\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n        i++;\n    }\n\n    sub->num_rects = i;\n\n#ifdef DEBUG\n    save_display_set(ctx);\n#endif\n\n    return 1;\n}"
        ],
        "sink": "rect = sub->rects[i];",
        "final_sink": "rect = sub->rects[i];",
        "source": [
            "    AVDictionary **meta_in = NULL;"
        ],
        "index": 5
    }
]