[
    {
        "prt": "ctx",
        "function_call": [
            "static EVP_PKEY *pkey_type2param(int ptype, const void *pval,\n                                 OSSL_LIB_CTX *libctx, const char *propq)\n{\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *pctx = NULL;\n    OSSL_DECODER_CTX *ctx = NULL;\n\n    if (ptype == V_ASN1_SEQUENCE) {\n        const ASN1_STRING *pstr = pval;\n        const unsigned char *pm = pstr->data;\n        size_t pmlen = (size_t)pstr->length;\n        int selection = OSSL_KEYMGMT_SELECT_ALL_PARAMETERS;\n\n        ctx = OSSL_DECODER_CTX_new_for_pkey(&pkey, \"DER\", NULL, \"EC\",\n                                            selection, libctx, propq);\n        if (ctx == NULL)\n            goto err;\n\n        if (!OSSL_DECODER_from_data(ctx, &pm, &pmlen)) {\n            ERR_raise(ERR_LIB_CMS, CMS_R_DECODE_ERROR);\n            goto err;\n        }\n        OSSL_DECODER_CTX_free(ctx);\n        return pkey;\n    } else if (ptype == V_ASN1_OBJECT) {\n        const ASN1_OBJECT *poid = pval;\n        char groupname[OSSL_MAX_NAME_SIZE];\n\n        /* type == V_ASN1_OBJECT => the parameters are given by an asn1 OID */\n        pctx = EVP_PKEY_CTX_new_from_name(libctx, \"EC\", propq);\n        if (pctx == NULL || EVP_PKEY_paramgen_init(pctx) <= 0)\n            goto err;\n        if (OBJ_obj2txt(groupname, sizeof(groupname), poid, 0) <= 0\n                || EVP_PKEY_CTX_set_group_name(pctx, groupname) <= 0) {\n            ERR_raise(ERR_LIB_CMS, CMS_R_DECODE_ERROR);\n            goto err;\n        }\n        if (EVP_PKEY_paramgen(pctx, &pkey) <= 0)\n            goto err;\n        EVP_PKEY_CTX_free(pctx);\n        return pkey;\n    }\n\n    ERR_raise(ERR_LIB_CMS, CMS_R_DECODE_ERROR);\n    return NULL;\n\n err:\n    EVP_PKEY_free(pkey);\n    EVP_PKEY_CTX_free(pctx);\n    OSSL_DECODER_CTX_free(ctx);\n    return NULL;\n}"
        ],
        "sink": "OSSL_DECODER_CTX_free(ctx);",
        "final_sink": "OSSL_DECODER_CTX_free(ctx);",
        "source": [
            "    str = app_malloc(i, \"revocation reason\");"
        ],
        "index": 0
    },
    {
        "prt": "new",
        "function_call": [
            "static void rwwriter_fn(int id, int *iterations)\n{\n    int count;\n    int *old, *new;\n    OSSL_TIME t1, t2;\n    t1 = ossl_time_now();\n\n    for (count = 0; ; count++) {\n        new = CRYPTO_zalloc(sizeof (int), NULL, 0);\n        if (contention == 0)\n            OSSL_sleep(1000);\n        if (!CRYPTO_THREAD_write_lock(rwtorturelock))\n            abort();\n        if (rwwriter_ptr != NULL) {\n            *new = *rwwriter_ptr + 1;\n        } else {\n            *new = 0;\n        }\n        old = rwwriter_ptr;\n        rwwriter_ptr = new;\n        if (!CRYPTO_THREAD_unlock(rwtorturelock))\n            abort();\n        if (old != NULL)\n            CRYPTO_free(old, __FILE__, __LINE__);\n        t2 = ossl_time_now();\n        if ((ossl_time2seconds(t2) - ossl_time2seconds(t1)) >= 4)\n            break;\n    }\n    *iterations = count;\n    return;\n}"
        ],
        "sink": "*new = 0;",
        "final_sink": "*new = 0;",
        "source": [
            "        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");"
        ],
        "index": 2
    },
    {
        "prt": "ptmp",
        "function_call": [
            "int X509_PURPOSE_add(int id, int trust, int flags,\n                     int (*ck) (const X509_PURPOSE *, const X509 *, int),\n                     const char *name, const char *sname, void *arg)\n{\n    int idx;\n    X509_PURPOSE *ptmp;\n\n    /* This is set according to what we change: application can't set it */\n    flags &= ~X509_PURPOSE_DYNAMIC;\n    /* This will always be set for application modified trust entries */\n    flags |= X509_PURPOSE_DYNAMIC_NAME;\n    /* Get existing entry if any */\n    idx = X509_PURPOSE_get_by_id(id);\n    /* Need a new entry */\n    if (idx == -1) {\n        if ((ptmp = OPENSSL_malloc(sizeof(*ptmp))) == NULL)\n            return 0;\n        ptmp->flags = X509_PURPOSE_DYNAMIC;\n    } else {\n        ptmp = X509_PURPOSE_get0(idx);\n    }\n\n    /* OPENSSL_free existing name if dynamic */\n    if ((ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) != 0) {\n        OPENSSL_free(ptmp->name);\n        OPENSSL_free(ptmp->sname);\n    }\n    /* Dup supplied name */\n    ptmp->name = OPENSSL_strdup(name);\n    ptmp->sname = OPENSSL_strdup(sname);\n    if (ptmp->name == NULL || ptmp->sname == NULL)\n        goto err;\n    /* Keep the dynamic flag of existing entry */\n    ptmp->flags &= X509_PURPOSE_DYNAMIC;\n    /* Set all other flags */\n    ptmp->flags |= flags;\n\n    ptmp->purpose = id;\n    ptmp->trust = trust;\n    ptmp->check_purpose = ck;\n    ptmp->usr_data = arg;\n\n    /* If its a new entry manage the dynamic table */\n    if (idx == -1) {\n        if (xptable == NULL\n            && (xptable = sk_X509_PURPOSE_new(xp_cmp)) == NULL) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_CRYPTO_LIB);\n            goto err;\n        }\n        if (!sk_X509_PURPOSE_push(xptable, ptmp)) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_CRYPTO_LIB);\n            goto err;\n        }\n    }\n    return 1;\n err:\n    if (idx == -1) {\n        OPENSSL_free(ptmp->name);\n        OPENSSL_free(ptmp->sname);\n        OPENSSL_free(ptmp);\n    }\n    return 0;\n}"
        ],
        "sink": "if ((ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) != 0) {",
        "final_sink": "if ((ptmp->flags & X509_PURPOSE_DYNAMIC_NAME) != 0) {",
        "source": [
            "        irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row ptr\");"
        ],
        "index": 3
    },
    {
        "prt": "sc",
        "function_call": [
            "static long ssl_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    SSL **sslp, *ssl;\n    BIO_SSL *bs, *dbs;\n    BIO *dbio, *bio;\n    long ret = 1;\n    BIO *next;\n    SSL_CONNECTION *sc = NULL;\n\n    bs = BIO_get_data(b);\n    next = BIO_next(b);\n    ssl = bs->ssl;\n    if (ssl == NULL && cmd != BIO_C_SET_SSL)\n        return 0;\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        /* TODO(QUIC FUTURE): Add support when SSL_clear() is supported */\n        if ((sc = SSL_CONNECTION_FROM_SSL_ONLY(ssl)) == NULL)\n            return 0;\n\n        SSL_shutdown(ssl);\n\n        if (sc->handshake_func == ssl->method->ssl_connect)\n            SSL_set_connect_state(ssl);\n        else if (sc->handshake_func == ssl->method->ssl_accept)\n            SSL_set_accept_state(ssl);\n\n        if (!SSL_clear(ssl)) {\n            ret = 0;\n            break;\n        }\n\n        if (next != NULL)\n            ret = BIO_ctrl(next, cmd, num, ptr);\n        else if (sc->rbio != NULL)\n            ret = BIO_ctrl(sc->rbio, cmd, num, ptr);\n        else\n            ret = 1;\n        break;\n    case BIO_CTRL_INFO:\n        ret = 0;\n        break;\n    case BIO_C_SSL_MODE:\n        if (num)                /* client mode */\n            SSL_set_connect_state(ssl);\n        else\n            SSL_set_accept_state(ssl);\n        break;\n    case BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT:\n        ret = bs->renegotiate_timeout;\n        if (num < 60)\n            num = 5;\n        bs->renegotiate_timeout = (unsigned long)num;\n        bs->last_time = (unsigned long)time(NULL);\n        break;\n    case BIO_C_SET_SSL_RENEGOTIATE_BYTES:\n        ret = bs->renegotiate_count;\n        if ((long)num >= 512)\n            bs->renegotiate_count = (unsigned long)num;\n        break;\n    case BIO_C_GET_SSL_NUM_RENEGOTIATES:\n        ret = bs->num_renegotiates;\n        break;\n    case BIO_C_SET_SSL:\n        if (ssl != NULL) {\n            ssl_free(b);\n            if (!ssl_new(b))\n                return 0;\n            bs = BIO_get_data(b);\n        }\n        BIO_set_shutdown(b, num);\n        ssl = (SSL *)ptr;\n        bs->ssl = ssl;\n        bio = SSL_get_rbio(ssl);\n        if (bio != NULL) {\n            if (next != NULL)\n                BIO_push(bio, next);\n            BIO_set_next(b, bio);\n            BIO_up_ref(bio);\n        }\n        BIO_set_init(b, 1);\n        break;\n    case BIO_C_GET_SSL:\n        if (ptr != NULL) {\n            sslp = (SSL **)ptr;\n            *sslp = ssl;\n        } else\n            ret = 0;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n        ret = BIO_get_shutdown(b);\n        break;\n    case BIO_CTRL_SET_CLOSE:\n        BIO_set_shutdown(b, (int)num);\n        break;\n    case BIO_CTRL_WPENDING:\n        ret = BIO_ctrl(SSL_get_wbio(ssl), cmd, num, ptr);\n        break;\n    case BIO_CTRL_PENDING:\n        ret = SSL_pending(ssl);\n        if (ret == 0)\n            ret = BIO_pending(SSL_get_rbio(ssl));\n        break;\n    case BIO_CTRL_FLUSH:\n        BIO_clear_retry_flags(b);\n        ret = BIO_ctrl(SSL_get_wbio(ssl), cmd, num, ptr);\n        BIO_copy_next_retry(b);\n        break;\n    case BIO_CTRL_PUSH:\n        if ((next != NULL) && (next != SSL_get_rbio(ssl))) {\n            /*\n             * We are going to pass ownership of next to the SSL object...but\n             * we don't own a reference to pass yet - so up ref\n             */\n            BIO_up_ref(next);\n            SSL_set_bio(ssl, next, next);\n        }\n        break;\n    case BIO_CTRL_POP:\n        /* Only detach if we are the BIO explicitly being popped */\n        if (b == ptr) {\n            /* This will clear the reference we obtained during push */\n            SSL_set_bio(ssl, NULL, NULL);\n        }\n        break;\n    case BIO_C_DO_STATE_MACHINE:\n        BIO_clear_retry_flags(b);\n\n        BIO_set_retry_reason(b, 0);\n        ret = (int)SSL_do_handshake(ssl);\n\n        switch (SSL_get_error(ssl, (int)ret)) {\n        case SSL_ERROR_WANT_READ:\n            BIO_set_flags(b, BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY);\n            break;\n        case SSL_ERROR_WANT_WRITE:\n            BIO_set_flags(b, BIO_FLAGS_WRITE | BIO_FLAGS_SHOULD_RETRY);\n            break;\n        case SSL_ERROR_WANT_CONNECT:\n            BIO_set_flags(b, BIO_FLAGS_IO_SPECIAL | BIO_FLAGS_SHOULD_RETRY);\n            BIO_set_retry_reason(b, BIO_get_retry_reason(next));\n            break;\n        case SSL_ERROR_WANT_X509_LOOKUP:\n            BIO_set_retry_special(b);\n            BIO_set_retry_reason(b, BIO_RR_SSL_X509_LOOKUP);\n            break;\n        default:\n            break;\n        }\n        break;\n    case BIO_CTRL_DUP:\n        dbio = (BIO *)ptr;\n        dbs = BIO_get_data(dbio);\n        SSL_free(dbs->ssl);\n        dbs->ssl = SSL_dup(ssl);\n        dbs->num_renegotiates = bs->num_renegotiates;\n        dbs->renegotiate_count = bs->renegotiate_count;\n        dbs->byte_count = bs->byte_count;\n        dbs->renegotiate_timeout = bs->renegotiate_timeout;\n        dbs->last_time = bs->last_time;\n        ret = (dbs->ssl != NULL);\n        break;\n    case BIO_C_GET_FD:\n        ret = BIO_ctrl(SSL_get_rbio(ssl), cmd, num, ptr);\n        break;\n    case BIO_CTRL_SET_CALLBACK:\n        ret = 0; /* use callback ctrl */\n        break;\n    case BIO_CTRL_GET_RPOLL_DESCRIPTOR:\n        if (!SSL_get_rpoll_descriptor(ssl, (BIO_POLL_DESCRIPTOR *)ptr))\n            ret = 0;\n        break;\n    case BIO_CTRL_GET_WPOLL_DESCRIPTOR:\n        if (!SSL_get_wpoll_descriptor(ssl, (BIO_POLL_DESCRIPTOR *)ptr))\n            ret = 0;\n        break;\n    default:\n        ret = BIO_ctrl(SSL_get_rbio(ssl), cmd, num, ptr);\n        break;\n    }\n    return ret;\n}"
        ],
        "sink": "if (sc->handshake_func == ssl->method->ssl_connect)",
        "final_sink": "if (sc->handshake_func == ssl->method->ssl_connect)",
        "source": [
            "        cv = sk_CONF_VALUE_value(sk, i);"
        ],
        "index": 4
    },
    {
        "prt": "s",
        "function_call": [
            "static int test_handshake_secrets(void)\n{\n    SSL_CTX *ctx = NULL;\n    SSL *ssl = NULL;\n    SSL_CONNECTION *s;\n    int ret = 0;\n    size_t hashsize;\n    unsigned char out_master_secret[EVP_MAX_MD_SIZE];\n    size_t master_secret_length;\n\n    ctx = SSL_CTX_new(TLS_method());\n    if (!TEST_ptr(ctx))\n        goto err;\n\n    ssl = SSL_new(ctx);\n    if (!TEST_ptr(ssl) || !TEST_ptr(s = SSL_CONNECTION_FROM_SSL_ONLY(ssl)))\n        goto err;\n\n    s->session = SSL_SESSION_new();\n    if (!TEST_ptr(s->session))\n        goto err;\n\n    if (!TEST_true(tls13_generate_secret(s, ssl_handshake_md(s), NULL, NULL, 0,\n                                         (unsigned char *)&s->early_secret))) {\n        TEST_info(\"Early secret generation failed\");\n        goto err;\n    }\n\n    if (!TEST_mem_eq(s->early_secret, sizeof(early_secret),\n                     early_secret, sizeof(early_secret))) {\n        TEST_info(\"Early secret does not match\");\n        goto err;\n    }\n\n    if (!TEST_true(tls13_generate_handshake_secret(s, ecdhe_secret,\n                                                   sizeof(ecdhe_secret)))) {\n        TEST_info(\"Handshake secret generation failed\");\n        goto err;\n    }\n\n    if (!TEST_mem_eq(s->handshake_secret, sizeof(handshake_secret),\n                     handshake_secret, sizeof(handshake_secret)))\n        goto err;\n\n    hashsize = EVP_MD_get_size(ssl_handshake_md(s));\n    if (!TEST_size_t_eq(sizeof(client_hts), hashsize))\n        goto err;\n    if (!TEST_size_t_eq(sizeof(client_hts_key), KEYLEN))\n        goto err;\n    if (!TEST_size_t_eq(sizeof(client_hts_iv), IVLEN))\n        goto err;\n\n    if (!TEST_true(test_secret(s, s->handshake_secret,\n                               (unsigned char *)client_hts_label,\n                               strlen(client_hts_label), client_hts,\n                               client_hts_key, client_hts_iv))) {\n        TEST_info(\"Client handshake secret test failed\");\n        goto err;\n    }\n\n    if (!TEST_size_t_eq(sizeof(server_hts), hashsize))\n        goto err;\n    if (!TEST_size_t_eq(sizeof(server_hts_key), KEYLEN))\n        goto err;\n    if (!TEST_size_t_eq(sizeof(server_hts_iv), IVLEN))\n        goto err;\n\n    if (!TEST_true(test_secret(s, s->handshake_secret,\n                               (unsigned char *)server_hts_label,\n                               strlen(server_hts_label), server_hts,\n                               server_hts_key, server_hts_iv))) {\n        TEST_info(\"Server handshake secret test failed\");\n        goto err;\n    }\n\n    /*\n     * Ensure the mocked out ssl_handshake_hash() returns the full handshake\n     * hash.\n     */\n    full_hash = 1;\n\n    if (!TEST_true(tls13_generate_master_secret(s, out_master_secret,\n                                                s->handshake_secret, hashsize,\n                                                &master_secret_length))) {\n        TEST_info(\"Master secret generation failed\");\n        goto err;\n    }\n\n    if (!TEST_mem_eq(out_master_secret, master_secret_length,\n                     master_secret, sizeof(master_secret))) {\n        TEST_info(\"Master secret does not match\");\n        goto err;\n    }\n\n    if (!TEST_size_t_eq(sizeof(client_ats), hashsize))\n        goto err;\n    if (!TEST_size_t_eq(sizeof(client_ats_key), KEYLEN))\n        goto err;\n    if (!TEST_size_t_eq(sizeof(client_ats_iv), IVLEN))\n        goto err;\n\n    if (!TEST_true(test_secret(s, out_master_secret,\n                               (unsigned char *)client_ats_label,\n                               strlen(client_ats_label), client_ats,\n                               client_ats_key, client_ats_iv))) {\n        TEST_info(\"Client application data secret test failed\");\n        goto err;\n    }\n\n    if (!TEST_size_t_eq(sizeof(server_ats), hashsize))\n        goto err;\n    if (!TEST_size_t_eq(sizeof(server_ats_key), KEYLEN))\n        goto err;\n    if (!TEST_size_t_eq(sizeof(server_ats_iv), IVLEN))\n        goto err;\n\n    if (!TEST_true(test_secret(s, out_master_secret,\n                               (unsigned char *)server_ats_label,\n                               strlen(server_ats_label), server_ats,\n                               server_ats_key, server_ats_iv))) {\n        TEST_info(\"Server application data secret test failed\");\n        goto err;\n    }\n\n    ret = 1;\n err:\n    SSL_free(ssl);\n    SSL_CTX_free(ctx);\n    return ret;\n}"
        ],
        "sink": "s->session = SSL_SESSION_new();",
        "final_sink": "s->session = SSL_SESSION_new();",
        "source": [
            "        str = X509_NAME_ENTRY_get_data(ne);"
        ],
        "index": 6
    },
    {
        "prt": "rh_item",
        "function_call": [
            "static int srtm_remove_from_rev(QUIC_SRTM *srtm, SRTM_ITEM *item)\n{\n    SRTM_ITEM *rh_item;\n\n    rh_item = lh_SRTM_ITEM_retrieve(srtm->items_rev, item);\n    assert(rh_item != NULL);\n    if (rh_item == item) {\n        /*\n         * Change lhash to point to item after this one, or remove the entry if\n         * this is the last one.\n         */\n        if (item->next_by_srt_blinded != NULL) {\n            lh_SRTM_ITEM_insert(srtm->items_rev, item->next_by_srt_blinded);\n            if (!srtm_check_lh(srtm, srtm->items_rev))\n                return 0;\n        } else {\n            lh_SRTM_ITEM_delete(srtm->items_rev, item);\n        }\n    } else {\n        /* Find our entry in the SRT list */\n        for (; rh_item->next_by_srt_blinded != item;\n               rh_item = rh_item->next_by_srt_blinded);\n        rh_item->next_by_srt_blinded = item->next_by_srt_blinded;\n    }\n\n    return 1;\n}"
        ],
        "sink": "for (; rh_item->next_by_srt_blinded != item;",
        "final_sink": "for (; rh_item->next_by_srt_blinded != item;",
        "source": [
            "        cv = sk_CONF_VALUE_value(policy, i); /* get the object id */"
        ],
        "index": 8
    },
    {
        "prt": "sc",
        "function_call": [
            "int ossl_quic_tls_is_cert_request(QUIC_TLS *qtls)\n{\n    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(qtls->args.s);\n\n    return sc->s3.tmp.message_type == SSL3_MT_CERTIFICATE_REQUEST;\n}"
        ],
        "sink": "return sc->s3.tmp.message_type == SSL3_MT_CERTIFICATE_REQUEST;",
        "final_sink": "return sc->s3.tmp.message_type == SSL3_MT_CERTIFICATE_REQUEST;",
        "source": [
            "    irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row space\");"
        ],
        "index": 11
    },
    {
        "prt": "path",
        "function_call": [
            "static int opt_provider_path(const char *path)\n{\n    if (path != NULL && *path == '\\0')\n        path = NULL;\n    return OSSL_PROVIDER_set_default_search_path(app_get0_libctx(), path);\n}"
        ],
        "sink": "return OSSL_PROVIDER_set_default_search_path(app_get0_libctx(), path);",
        "final_sink": "return OSSL_PROVIDER_set_default_search_path(app_get0_libctx(), path);",
        "source": [
            "        rrow = sk_OPENSSL_PSTRING_value(db->db->data, i);"
        ],
        "index": 1
    },
    {
        "prt": "key",
        "function_call": [
            "static int test_rsa_simple(int idx, int en_pad_type, int de_pad_type,\n                           int success, unsigned char *ctext_ex, int *clen,\n                           RSA **retkey)\n{\n    int ret = 0;\n    RSA *key;\n    unsigned char ptext[256];\n    unsigned char ctext[256];\n    static unsigned char ptext_ex[] = \"\\x54\\x85\\x9b\\x34\\x2c\\x49\\xea\\x2a\";\n    int plen;\n    int clentmp = 0;\n    int num;\n\n    plen = sizeof(ptext_ex) - 1;\n    clentmp = rsa_setkey(&key, ctext_ex, idx);\n    if (clen != NULL)\n        *clen = clentmp;\n\n    num = RSA_public_encrypt(plen, ptext_ex, ctext, key, en_pad_type);\n    if (!TEST_int_eq(num, clentmp))\n        goto err;\n\n    num = RSA_private_decrypt(num, ctext, ptext, key, de_pad_type);\n    if (success) {\n        if (!TEST_int_gt(num, 0) || !TEST_mem_eq(ptext, num, ptext_ex, plen))\n            goto err;\n    } else {\n        if (!TEST_int_lt(num, 0))\n            goto err;\n    }\n\n    ret = 1;\n    if (retkey != NULL) {\n        *retkey = key;\n        key = NULL;\n    }\nerr:\n    RSA_free(key);\n    return ret;\n}",
            "int RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to,\n                       RSA *rsa, int padding)\n{\n    return rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding);\n}"
        ],
        "sink": "num = RSA_public_encrypt(plen, ptext_ex, ctext, key, en_pad_type);",
        "final_sink": "    return rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding);",
        "source": [
            "        str = X509_NAME_ENTRY_get_data(ne);"
        ],
        "index": 5
    },
    {
        "prt": "signer",
        "function_call": [
            "static int int_ts_RESP_verify_token(TS_VERIFY_CTX *ctx,\n                                    PKCS7 *token, TS_TST_INFO *tst_info)\n{\n    X509 *signer = NULL;\n    GENERAL_NAME *tsa_name = tst_info->tsa;\n    X509_ALGOR *md_alg = NULL;\n    unsigned char *imprint = NULL;\n    unsigned imprint_len = 0;\n    int ret = 0;\n    int flags = ctx->flags;\n\n    /* Some options require us to also check the signature */\n    if (((flags & TS_VFY_SIGNER) && tsa_name != NULL)\n            || (flags & TS_VFY_TSA_NAME)) {\n        flags |= TS_VFY_SIGNATURE;\n    }\n\n    if ((flags & TS_VFY_SIGNATURE)\n        && !TS_RESP_verify_signature(token, ctx->certs, ctx->store, &signer))\n        goto err;\n    if ((flags & TS_VFY_VERSION)\n        && TS_TST_INFO_get_version(tst_info) != 1) {\n        ERR_raise(ERR_LIB_TS, TS_R_UNSUPPORTED_VERSION);\n        goto err;\n    }\n    if ((flags & TS_VFY_POLICY)\n        && !ts_check_policy(ctx->policy, tst_info))\n        goto err;\n    if ((flags & TS_VFY_IMPRINT)\n        && !ts_check_imprints(ctx->md_alg, ctx->imprint, ctx->imprint_len,\n                              tst_info))\n        goto err;\n    if ((flags & TS_VFY_DATA)\n        && (!ts_compute_imprint(ctx->data, tst_info,\n                                &md_alg, &imprint, &imprint_len)\n            || !ts_check_imprints(md_alg, imprint, imprint_len, tst_info)))\n        goto err;\n    if ((flags & TS_VFY_NONCE)\n        && !ts_check_nonces(ctx->nonce, tst_info))\n        goto err;\n    if ((flags & TS_VFY_SIGNER)\n        && tsa_name && !ts_check_signer_name(tsa_name, signer)) {\n        ERR_raise(ERR_LIB_TS, TS_R_TSA_NAME_MISMATCH);\n        goto err;\n    }\n    if ((flags & TS_VFY_TSA_NAME)\n        && !ts_check_signer_name(ctx->tsa_name, signer)) {\n        ERR_raise(ERR_LIB_TS, TS_R_TSA_UNTRUSTED);\n        goto err;\n    }\n    ret = 1;\n\n err:\n    X509_free(signer);\n    X509_ALGOR_free(md_alg);\n    OPENSSL_free(imprint);\n    return ret;\n}"
        ],
        "sink": "&& tsa_name && !ts_check_signer_name(tsa_name, signer)) {",
        "final_sink": "&& tsa_name && !ts_check_signer_name(tsa_name, signer)) {",
        "source": [
            "        str = X509_NAME_ENTRY_get_data(ne);"
        ],
        "index": 7
    },
    {
        "prt": "b",
        "function_call": [
            "static int test_bn_output(int n)\n{\n    BIGNUM *b = NULL;\n\n    if (bn_output_tests[n] != NULL\n            && !TEST_true(BN_hex2bn(&b, bn_output_tests[n])))\n        return 0;\n    test_output_bignum(bn_output_tests[n], b);\n    BN_free(b);\n    return 1;\n}"
        ],
        "sink": "test_output_bignum(bn_output_tests[n], b);",
        "final_sink": "test_output_bignum(bn_output_tests[n], b);",
        "source": [
            "    pktmp = X509_get0_pubkey(ret);"
        ],
        "index": 9
    },
    {
        "prt": "xptmp",
        "function_call": [
            "int opt_verify(int opt, X509_VERIFY_PARAM *vpm)\n{\n    int i;\n    ossl_intmax_t t = 0;\n    ASN1_OBJECT *otmp;\n    X509_PURPOSE *xptmp;\n    const X509_VERIFY_PARAM *vtmp;\n\n    OPENSSL_assert(vpm != NULL);\n    OPENSSL_assert(opt > OPT_V__FIRST);\n    OPENSSL_assert(opt < OPT_V__LAST);\n\n    switch ((enum range)opt) {\n    case OPT_V__FIRST:\n    case OPT_V__LAST:\n        return 0;\n    case OPT_V_POLICY:\n        otmp = OBJ_txt2obj(opt_arg(), 0);\n        if (otmp == NULL) {\n            opt_printf_stderr(\"%s: Invalid Policy %s\\n\", prog, opt_arg());\n            return 0;\n        }\n        if (!X509_VERIFY_PARAM_add0_policy(vpm, otmp)) {\n            ASN1_OBJECT_free(otmp);\n            opt_printf_stderr(\"%s: Internal error adding Policy %s\\n\",\n                              prog, opt_arg());\n            return 0;\n        }\n        break;\n    case OPT_V_PURPOSE:\n        /* purpose name -> purpose index */\n        i = X509_PURPOSE_get_by_sname(opt_arg());\n        if (i < 0) {\n            opt_printf_stderr(\"%s: Invalid purpose %s\\n\", prog, opt_arg());\n            return 0;\n        }\n\n        /* purpose index -> purpose object */\n        xptmp = X509_PURPOSE_get0(i);\n\n        /* purpose object -> purpose value */\n        i = X509_PURPOSE_get_id(xptmp);\n\n        if (!X509_VERIFY_PARAM_set_purpose(vpm, i)) {\n            opt_printf_stderr(\"%s: Internal error setting purpose %s\\n\",\n                              prog, opt_arg());\n            return 0;\n        }\n        break;\n    case OPT_V_VERIFY_NAME:\n        vtmp = X509_VERIFY_PARAM_lookup(opt_arg());\n        if (vtmp == NULL) {\n            opt_printf_stderr(\"%s: Invalid verify name %s\\n\",\n                              prog, opt_arg());\n            return 0;\n        }\n        X509_VERIFY_PARAM_set1(vpm, vtmp);\n        break;\n    case OPT_V_VERIFY_DEPTH:\n        i = atoi(opt_arg());\n        if (i >= 0)\n            X509_VERIFY_PARAM_set_depth(vpm, i);\n        break;\n    case OPT_V_VERIFY_AUTH_LEVEL:\n        i = atoi(opt_arg());\n        if (i >= 0)\n            X509_VERIFY_PARAM_set_auth_level(vpm, i);\n        break;\n    case OPT_V_ATTIME:\n        if (!opt_intmax(opt_arg(), &t))\n            return 0;\n        if (t != (time_t)t) {\n            opt_printf_stderr(\"%s: epoch time out of range %s\\n\",\n                              prog, opt_arg());\n            return 0;\n        }\n        X509_VERIFY_PARAM_set_time(vpm, (time_t)t);\n        break;\n    case OPT_V_VERIFY_HOSTNAME:\n        if (!X509_VERIFY_PARAM_set1_host(vpm, opt_arg(), 0))\n            return 0;\n        break;\n    case OPT_V_VERIFY_EMAIL:\n        if (!X509_VERIFY_PARAM_set1_email(vpm, opt_arg(), 0))\n            return 0;\n        break;\n    case OPT_V_VERIFY_IP:\n        if (!X509_VERIFY_PARAM_set1_ip_asc(vpm, opt_arg()))\n            return 0;\n        break;\n    case OPT_V_IGNORE_CRITICAL:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_IGNORE_CRITICAL);\n        break;\n    case OPT_V_ISSUER_CHECKS:\n        /* NOP, deprecated */\n        break;\n    case OPT_V_CRL_CHECK:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_CRL_CHECK);\n        break;\n    case OPT_V_CRL_CHECK_ALL:\n        X509_VERIFY_PARAM_set_flags(vpm,\n                                    X509_V_FLAG_CRL_CHECK |\n                                    X509_V_FLAG_CRL_CHECK_ALL);\n        break;\n    case OPT_V_POLICY_CHECK:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_POLICY_CHECK);\n        break;\n    case OPT_V_EXPLICIT_POLICY:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_EXPLICIT_POLICY);\n        break;\n    case OPT_V_INHIBIT_ANY:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_INHIBIT_ANY);\n        break;\n    case OPT_V_INHIBIT_MAP:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_INHIBIT_MAP);\n        break;\n    case OPT_V_X509_STRICT:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_X509_STRICT);\n        break;\n    case OPT_V_EXTENDED_CRL:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_EXTENDED_CRL_SUPPORT);\n        break;\n    case OPT_V_USE_DELTAS:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_USE_DELTAS);\n        break;\n    case OPT_V_POLICY_PRINT:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_NOTIFY_POLICY);\n        break;\n    case OPT_V_CHECK_SS_SIG:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_CHECK_SS_SIGNATURE);\n        break;\n    case OPT_V_TRUSTED_FIRST:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_TRUSTED_FIRST);\n        break;\n    case OPT_V_SUITEB_128_ONLY:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_SUITEB_128_LOS_ONLY);\n        break;\n    case OPT_V_SUITEB_128:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_SUITEB_128_LOS);\n        break;\n    case OPT_V_SUITEB_192:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_SUITEB_192_LOS);\n        break;\n    case OPT_V_PARTIAL_CHAIN:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_PARTIAL_CHAIN);\n        break;\n    case OPT_V_NO_ALT_CHAINS:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_NO_ALT_CHAINS);\n        break;\n    case OPT_V_NO_CHECK_TIME:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_NO_CHECK_TIME);\n        break;\n    case OPT_V_ALLOW_PROXY_CERTS:\n        X509_VERIFY_PARAM_set_flags(vpm, X509_V_FLAG_ALLOW_PROXY_CERTS);\n        break;\n    }\n    return 1;\n\n}"
        ],
        "sink": "i = X509_PURPOSE_get_id(xptmp);",
        "final_sink": "i = X509_PURPOSE_get_id(xptmp);",
        "source": [
            "    irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row space\");"
        ],
        "index": 10
    },
    {
        "prt": "result",
        "function_call": [
            "static OSSL_STORE_INFO *file_load_try_decode(OSSL_STORE_LOADER_CTX *ctx,\n                                             const char *pem_name,\n                                             const char *pem_header,\n                                             unsigned char *data, size_t len,\n                                             const UI_METHOD *ui_method,\n                                             void *ui_data, int *matchcount)\n{\n    OSSL_STORE_INFO *result = NULL;\n    BUF_MEM *new_mem = NULL;\n    char *new_pem_name = NULL;\n    int t = 0;\n\n again:\n    {\n        size_t i = 0;\n        void *handler_ctx = NULL;\n        const FILE_HANDLER **matching_handlers =\n            OPENSSL_zalloc(sizeof(*matching_handlers)\n                           * OSSL_NELEM(file_handlers));\n\n        if (matching_handlers == NULL)\n            goto err;\n\n        *matchcount = 0;\n        for (i = 0; i < OSSL_NELEM(file_handlers); i++) {\n            const FILE_HANDLER *handler = file_handlers[i];\n            int try_matchcount = 0;\n            void *tmp_handler_ctx = NULL;\n            OSSL_STORE_INFO *tmp_result;\n            unsigned long err;\n\n            ERR_set_mark();\n            tmp_result =\n                handler->try_decode(pem_name, pem_header, data, len,\n                                    &tmp_handler_ctx, &try_matchcount,\n                                    ui_method, ui_data, ctx->uri,\n                                    ctx->libctx, ctx->propq);\n            /* avoid flooding error queue with low-level ASN.1 parse errors */\n            err = ERR_peek_last_error();\n            if (ERR_GET_LIB(err) == ERR_LIB_ASN1\n                    && ERR_GET_REASON(err) == ERR_R_NESTED_ASN1_ERROR)\n                ERR_pop_to_mark();\n            else\n                ERR_clear_last_mark();\n\n            if (try_matchcount > 0) {\n\n                matching_handlers[*matchcount] = handler;\n\n                if (handler_ctx)\n                    handler->destroy_ctx(&handler_ctx);\n                handler_ctx = tmp_handler_ctx;\n\n                if ((*matchcount += try_matchcount) > 1) {\n                    /* more than one match => ambiguous, kill any result */\n                    store_info_free(result);\n                    store_info_free(tmp_result);\n                    if (handler->destroy_ctx != NULL)\n                        handler->destroy_ctx(&handler_ctx);\n                    handler_ctx = NULL;\n                    tmp_result = NULL;\n                    result = NULL;\n                }\n                if (result == NULL)\n                    result = tmp_result;\n                if (result == NULL) /* e.g., PKCS#12 file decryption error */\n                    break;\n            }\n        }\n\n        if (result != NULL\n                && *matchcount == 1 && matching_handlers[0]->repeatable) {\n            ctx->_.file.last_handler = matching_handlers[0];\n            ctx->_.file.last_handler_ctx = handler_ctx;\n        }\n\n        OPENSSL_free(matching_handlers);\n    }\n\n err:\n    OPENSSL_free(new_pem_name);\n    BUF_MEM_free(new_mem);\n\n    if (result != NULL\n        && (t = OSSL_STORE_INFO_get_type(result)) == STORE_INFO_EMBEDDED) {\n        struct embedded_st *embedded = get0_EMBEDDED(result);\n\n        /* \"steal\" the embedded data */\n        pem_name = new_pem_name = embedded->pem_name;\n        new_mem = embedded->blob;\n        data = (unsigned char *)new_mem->data;\n        len = new_mem->length;\n        embedded->pem_name = NULL;\n        embedded->blob = NULL;\n\n        store_info_free(result);\n        result = NULL;\n        goto again;\n    }\n\n    return result;\n}"
        ],
        "sink": "store_info_free(result);",
        "final_sink": "store_info_free(result);",
        "source": [
            "        pp = sk_OPENSSL_PSTRING_value(db->db->data, i);"
        ],
        "index": 12
    },
    {
        "prt": "str",
        "function_call": [
            "static int do_body(X509 **xret, EVP_PKEY *pkey, X509 *x509,\n                   const char *dgst, STACK_OF(OPENSSL_STRING) *sigopts,\n                   STACK_OF(CONF_VALUE) *policy, CA_DB *db, BIGNUM *serial,\n                   const char *subj, unsigned long chtype, int multirdn,\n                   int email_dn, const char *startdate, const char *enddate, long days,\n                   int batch, int verbose, X509_REQ *req, const char *ext_sect,\n                   CONF *lconf, unsigned long certopt, unsigned long nameopt,\n                   int default_op, int ext_copy, int selfsign, unsigned long dateopt)\n{\n    const X509_NAME *name = NULL;\n    X509_NAME *CAname = NULL, *subject = NULL;\n    const ASN1_TIME *tm;\n    ASN1_STRING *str, *str2;\n    ASN1_OBJECT *obj;\n    X509 *ret = NULL;\n    X509_NAME_ENTRY *ne, *tne;\n    EVP_PKEY *pktmp;\n    int ok = -1, i, j, last, nid;\n    const char *p;\n    CONF_VALUE *cv;\n    OPENSSL_STRING row[DB_NUMBER];\n    OPENSSL_STRING *irow = NULL;\n    OPENSSL_STRING *rrow = NULL;\n    char buf[25];\n    X509V3_CTX ext_ctx;\n\n    for (i = 0; i < DB_NUMBER; i++)\n        row[i] = NULL;\n\n    if (subj) {\n        X509_NAME *n = parse_name(subj, chtype, multirdn, \"subject\");\n\n        if (!n)\n            goto end;\n        X509_REQ_set_subject_name(req, n);\n        X509_NAME_free(n);\n    }\n\n    if (default_op)\n        BIO_printf(bio_err, \"The Subject's Distinguished Name is as follows\\n\");\n\n    name = X509_REQ_get_subject_name(req);\n    for (i = 0; i < X509_NAME_entry_count(name); i++) {\n        ne = X509_NAME_get_entry(name, i);\n        str = X509_NAME_ENTRY_get_data(ne);\n        obj = X509_NAME_ENTRY_get_object(ne);\n        nid = OBJ_obj2nid(obj);\n\n        if (msie_hack) {\n            /* assume all type should be strings */\n\n            if (str->type == V_ASN1_UNIVERSALSTRING)\n                ASN1_UNIVERSALSTRING_to_string(str);\n\n            if (str->type == V_ASN1_IA5STRING && nid != NID_pkcs9_emailAddress)\n                str->type = V_ASN1_T61STRING;\n\n            if (nid == NID_pkcs9_emailAddress\n                && str->type == V_ASN1_PRINTABLESTRING)\n                str->type = V_ASN1_IA5STRING;\n        }\n\n        /* If no EMAIL is wanted in the subject */\n        if (nid == NID_pkcs9_emailAddress && !email_dn)\n            continue;\n\n        /* check some things */\n        if (nid == NID_pkcs9_emailAddress && str->type != V_ASN1_IA5STRING) {\n            BIO_printf(bio_err,\n                       \"\\nemailAddress type needs to be of type IA5STRING\\n\");\n            goto end;\n        }\n        if (str->type != V_ASN1_BMPSTRING && str->type != V_ASN1_UTF8STRING) {\n            j = ASN1_PRINTABLE_type(str->data, str->length);\n            if ((j == V_ASN1_T61STRING && str->type != V_ASN1_T61STRING) ||\n                (j == V_ASN1_IA5STRING && str->type == V_ASN1_PRINTABLESTRING))\n            {\n                BIO_printf(bio_err,\n                           \"\\nThe string contains characters that are illegal for the ASN.1 type\\n\");\n                goto end;\n            }\n        }\n\n        if (default_op)\n            old_entry_print(obj, str);\n    }\n\n    /* Ok, now we check the 'policy' stuff. */\n    if ((subject = X509_NAME_new()) == NULL) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n\n    /* take a copy of the issuer name before we mess with it. */\n    if (selfsign)\n        CAname = X509_NAME_dup(name);\n    else\n        CAname = X509_NAME_dup(X509_get_subject_name(x509));\n    if (CAname == NULL)\n        goto end;\n    str = str2 = NULL;\n\n    for (i = 0; i < sk_CONF_VALUE_num(policy); i++) {\n        cv = sk_CONF_VALUE_value(policy, i); /* get the object id */\n        if ((j = OBJ_txt2nid(cv->name)) == NID_undef) {\n            BIO_printf(bio_err,\n                       \"%s:unknown object type in 'policy' configuration\\n\",\n                       cv->name);\n            goto end;\n        }\n        obj = OBJ_nid2obj(j);\n\n        last = -1;\n        for (;;) {\n            X509_NAME_ENTRY *push = NULL;\n\n            /* lookup the object in the supplied name list */\n            j = X509_NAME_get_index_by_OBJ(name, obj, last);\n            if (j < 0) {\n                if (last != -1)\n                    break;\n                tne = NULL;\n            } else {\n                tne = X509_NAME_get_entry(name, j);\n            }\n            last = j;\n\n            /* depending on the 'policy', decide what to do. */\n            if (strcmp(cv->value, \"optional\") == 0) {\n                if (tne != NULL)\n                    push = tne;\n            } else if (strcmp(cv->value, \"supplied\") == 0) {\n                if (tne == NULL) {\n                    BIO_printf(bio_err,\n                               \"The %s field needed to be supplied and was missing\\n\",\n                               cv->name);\n                    goto end;\n                } else {\n                    push = tne;\n                }\n            } else if (strcmp(cv->value, \"match\") == 0) {\n                int last2;\n\n                if (tne == NULL) {\n                    BIO_printf(bio_err,\n                               \"The mandatory %s field was missing\\n\",\n                               cv->name);\n                    goto end;\n                }\n\n                last2 = -1;\n\n again2:\n                j = X509_NAME_get_index_by_OBJ(CAname, obj, last2);\n                if ((j < 0) && (last2 == -1)) {\n                    BIO_printf(bio_err,\n                               \"The %s field does not exist in the CA certificate,\\n\"\n                               \"the 'policy' is misconfigured\\n\", cv->name);\n                    goto end;\n                }\n                if (j >= 0) {\n                    push = X509_NAME_get_entry(CAname, j);\n                    str = X509_NAME_ENTRY_get_data(tne);\n                    str2 = X509_NAME_ENTRY_get_data(push);\n                    last2 = j;\n                    if (ASN1_STRING_cmp(str, str2) != 0)\n                        goto again2;\n                }\n                if (j < 0) {\n                    BIO_printf(bio_err,\n                               \"The %s field is different between\\n\"\n                               \"CA certificate (%s) and the request (%s)\\n\",\n                               cv->name,\n                               ((str2 == NULL) ? \"NULL\" : (char *)str2->data),\n                               ((str == NULL) ? \"NULL\" : (char *)str->data));\n                    goto end;\n                }\n            } else {\n                BIO_printf(bio_err,\n                           \"%s:invalid type in 'policy' configuration\\n\",\n                           cv->value);\n                goto end;\n            }\n\n            if (push != NULL) {\n                if (!X509_NAME_add_entry(subject, push, -1, 0)) {\n                    BIO_printf(bio_err, \"Memory allocation failure\\n\");\n                    goto end;\n                }\n            }\n            if (j < 0)\n                break;\n        }\n    }\n\n    if (preserve) {\n        X509_NAME_free(subject);\n        /* subject=X509_NAME_dup(X509_REQ_get_subject_name(req)); */\n        subject = X509_NAME_dup(name);\n        if (subject == NULL)\n            goto end;\n    }\n\n    /* We are now totally happy, lets make and sign the certificate */\n    if (verbose)\n        BIO_printf(bio_err,\n                   \"Everything appears to be ok, creating and signing the certificate\\n\");\n\n    if ((ret = X509_new_ex(app_get0_libctx(), app_get0_propq())) == NULL)\n        goto end;\n\n    if (BN_to_ASN1_INTEGER(serial, X509_get_serialNumber(ret)) == NULL)\n        goto end;\n    if (selfsign) {\n        if (!X509_set_issuer_name(ret, subject))\n            goto end;\n    } else {\n        if (!X509_set_issuer_name(ret, X509_get_subject_name(x509)))\n            goto end;\n    }\n\n    if (!set_cert_times(ret, startdate, enddate, days, 0))\n        goto end;\n\n    if (enddate != NULL) {\n        int tdays;\n\n        if (!ASN1_TIME_diff(&tdays, NULL, NULL, X509_get0_notAfter(ret)))\n            goto end;\n        days = tdays;\n    }\n\n    if (!X509_set_subject_name(ret, subject))\n        goto end;\n\n    pktmp = X509_REQ_get0_pubkey(req);\n    i = X509_set_pubkey(ret, pktmp);\n    if (!i)\n        goto end;\n\n    /* Initialize the context structure */\n    X509V3_set_ctx(&ext_ctx, selfsign ? ret : x509,\n                   ret, NULL /* no need to give req, needed info is in ret */,\n                   NULL, X509V3_CTX_REPLACE);\n    /* prepare fallback for AKID, but only if issuer cert equals subject cert */\n    if (selfsign) {\n        if (!X509V3_set_issuer_pkey(&ext_ctx, pkey))\n            goto end;\n        if (!cert_matches_key(ret, pkey))\n            BIO_printf(bio_err,\n                       \"Warning: Signature key and public key of cert do not match\\n\");\n    }\n\n    /* Lets add the extensions, if there are any */\n    if (ext_sect) {\n        if (extfile_conf != NULL) {\n            if (verbose)\n                BIO_printf(bio_err, \"Extra configuration file found\\n\");\n\n            /* Use the extfile_conf configuration db LHASH */\n            X509V3_set_nconf(&ext_ctx, extfile_conf);\n\n            /* Adds exts contained in the configuration file */\n            if (!X509V3_EXT_add_nconf(extfile_conf, &ext_ctx, ext_sect, ret)) {\n                BIO_printf(bio_err,\n                           \"Error adding certificate extensions from extfile section %s\\n\",\n                           ext_sect);\n                goto end;\n            }\n            if (verbose)\n                BIO_printf(bio_err,\n                           \"Successfully added extensions from file.\\n\");\n        } else if (ext_sect) {\n            /* We found extensions to be set from config file */\n            X509V3_set_nconf(&ext_ctx, lconf);\n\n            if (!X509V3_EXT_add_nconf(lconf, &ext_ctx, ext_sect, ret)) {\n                BIO_printf(bio_err,\n                           \"Error adding certificate extensions from config section %s\\n\",\n                           ext_sect);\n                goto end;\n            }\n\n            if (verbose)\n                BIO_printf(bio_err,\n                           \"Successfully added extensions from config\\n\");\n        }\n    }\n\n    /* Copy extensions from request (if any) */\n\n    if (!copy_extensions(ret, req, ext_copy)) {\n        BIO_printf(bio_err, \"ERROR: adding extensions from request\\n\");\n        goto end;\n    }\n\n    if (verbose)\n        BIO_printf(bio_err,\n                   \"The subject name appears to be ok, checking database for clashes\\n\");\n\n    /* Build the correct Subject if no e-mail is wanted in the subject. */\n    if (!email_dn) {\n        X509_NAME_ENTRY *tmpne;\n        X509_NAME *dn_subject;\n\n        /*\n         * Its best to dup the subject DN and then delete any email addresses\n         * because this retains its structure.\n         */\n        if ((dn_subject = X509_NAME_dup(subject)) == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n        i = -1;\n        while ((i = X509_NAME_get_index_by_NID(dn_subject,\n                                               NID_pkcs9_emailAddress,\n                                               i)) >= 0) {\n            tmpne = X509_NAME_delete_entry(dn_subject, i--);\n            X509_NAME_ENTRY_free(tmpne);\n        }\n\n        if (!X509_set_subject_name(ret, dn_subject)) {\n            X509_NAME_free(dn_subject);\n            goto end;\n        }\n        X509_NAME_free(dn_subject);\n    }\n\n    row[DB_name] = X509_NAME_oneline(X509_get_subject_name(ret), NULL, 0);\n    if (row[DB_name] == NULL) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n\n    if (BN_is_zero(serial))\n        row[DB_serial] = OPENSSL_strdup(\"00\");\n    else\n        row[DB_serial] = BN_bn2hex(serial);\n    if (row[DB_serial] == NULL) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n\n    if (row[DB_name][0] == '\\0') {\n        /*\n         * An empty subject! We'll use the serial number instead. If\n         * unique_subject is in use then we don't want different entries with\n         * empty subjects matching each other.\n         */\n        OPENSSL_free(row[DB_name]);\n        row[DB_name] = OPENSSL_strdup(row[DB_serial]);\n        if (row[DB_name] == NULL) {\n            BIO_printf(bio_err, \"Memory allocation failure\\n\");\n            goto end;\n        }\n    }\n\n    if (db->attributes.unique_subject) {\n        OPENSSL_STRING *crow = row;\n\n        rrow = TXT_DB_get_by_index(db->db, DB_name, crow);\n        if (rrow != NULL) {\n            BIO_printf(bio_err,\n                       \"ERROR:There is already a certificate for %s\\n\",\n                       row[DB_name]);\n        }\n    }\n    if (rrow == NULL) {\n        rrow = TXT_DB_get_by_index(db->db, DB_serial, row);\n        if (rrow != NULL) {\n            BIO_printf(bio_err,\n                       \"ERROR:Serial number %s has already been issued,\\n\",\n                       row[DB_serial]);\n            BIO_printf(bio_err,\n                       \"      check the database/serial_file for corruption\\n\");\n        }\n    }\n\n    if (rrow != NULL) {\n        BIO_printf(bio_err, \"The matching entry has the following details\\n\");\n        if (rrow[DB_type][0] == DB_TYPE_EXP)\n            p = \"Expired\";\n        else if (rrow[DB_type][0] == DB_TYPE_REV)\n            p = \"Revoked\";\n        else if (rrow[DB_type][0] == DB_TYPE_VAL)\n            p = \"Valid\";\n        else\n            p = \"\\ninvalid type, Database error\\n\";\n        BIO_printf(bio_err, \"Type          :%s\\n\", p);\n        if (rrow[DB_type][0] == DB_TYPE_REV) {\n            p = rrow[DB_exp_date];\n            if (p == NULL)\n                p = \"undef\";\n            BIO_printf(bio_err, \"Was revoked on:%s\\n\", p);\n        }\n        p = rrow[DB_exp_date];\n        if (p == NULL)\n            p = \"undef\";\n        BIO_printf(bio_err, \"Expires on    :%s\\n\", p);\n        p = rrow[DB_serial];\n        if (p == NULL)\n            p = \"undef\";\n        BIO_printf(bio_err, \"Serial Number :%s\\n\", p);\n        p = rrow[DB_file];\n        if (p == NULL)\n            p = \"undef\";\n        BIO_printf(bio_err, \"File name     :%s\\n\", p);\n        p = rrow[DB_name];\n        if (p == NULL)\n            p = \"undef\";\n        BIO_printf(bio_err, \"Subject Name  :%s\\n\", p);\n        ok = -1;                /* This is now a 'bad' error. */\n        goto end;\n    }\n\n    if (!default_op) {\n        BIO_printf(bio_err, \"Certificate Details:\\n\");\n        /*\n         * Never print signature details because signature not present\n         */\n        certopt |= X509_FLAG_NO_SIGDUMP | X509_FLAG_NO_SIGNAME;\n        X509_print_ex(bio_err, ret, nameopt, certopt);\n    }\n\n    BIO_printf(bio_err, \"Certificate is to be certified until \");\n    ASN1_TIME_print_ex(bio_err, X509_get0_notAfter(ret), dateopt);\n    if (days)\n        BIO_printf(bio_err, \" (%ld days)\", days);\n    BIO_printf(bio_err, \"\\n\");\n\n    if (!batch) {\n\n        BIO_printf(bio_err, \"Sign the certificate? [y/n]:\");\n        (void)BIO_flush(bio_err);\n        buf[0] = '\\0';\n        if (fgets(buf, sizeof(buf), stdin) == NULL) {\n            BIO_printf(bio_err,\n                       \"CERTIFICATE WILL NOT BE CERTIFIED: I/O error\\n\");\n            ok = 0;\n            goto end;\n        }\n        if (!(buf[0] == 'y' || buf[0] == 'Y')) {\n            BIO_printf(bio_err, \"CERTIFICATE WILL NOT BE CERTIFIED\\n\");\n            ok = 0;\n            goto end;\n        }\n    }\n\n    pktmp = X509_get0_pubkey(ret);\n    if (EVP_PKEY_missing_parameters(pktmp) &&\n        !EVP_PKEY_missing_parameters(pkey))\n        EVP_PKEY_copy_parameters(pktmp, pkey);\n\n    if (!do_X509_sign(ret, 0, pkey, dgst, sigopts, &ext_ctx))\n        goto end;\n\n    /* We now just add it to the database as DB_TYPE_VAL('V') */\n    row[DB_type] = OPENSSL_strdup(\"V\");\n    tm = X509_get0_notAfter(ret);\n    row[DB_exp_date] = app_malloc(tm->length + 1, \"row expdate\");\n    memcpy(row[DB_exp_date], tm->data, tm->length);\n    row[DB_exp_date][tm->length] = '\\0';\n    row[DB_rev_date] = NULL;\n    row[DB_file] = OPENSSL_strdup(\"unknown\");\n    if ((row[DB_type] == NULL) || (row[DB_file] == NULL)\n        || (row[DB_name] == NULL)) {\n        BIO_printf(bio_err, \"Memory allocation failure\\n\");\n        goto end;\n    }\n\n    irow = app_malloc(sizeof(*irow) * (DB_NUMBER + 1), \"row space\");\n    for (i = 0; i < DB_NUMBER; i++)\n        irow[i] = row[i];\n    irow[DB_NUMBER] = NULL;\n\n    if (!TXT_DB_insert(db->db, irow)) {\n        BIO_printf(bio_err, \"failed to update database\\n\");\n        BIO_printf(bio_err, \"TXT_DB error number %ld\\n\", db->db->error);\n        goto end;\n    }\n    irow = NULL;\n    ok = 1;\n end:\n    if (ok != 1) {\n        for (i = 0; i < DB_NUMBER; i++)\n            OPENSSL_free(row[i]);\n    }\n    OPENSSL_free(irow);\n\n    X509_NAME_free(CAname);\n    X509_NAME_free(subject);\n    if (ok <= 0)\n        X509_free(ret);\n    else\n        *xret = ret;\n    return ok;\n}"
        ],
        "sink": "if (str->type == V_ASN1_UNIVERSALSTRING)",
        "final_sink": "if (str->type == V_ASN1_UNIVERSALSTRING)",
        "source": [
            "    char *outdir = NULL, *outfile = NULL, *rev_arg = NULL, *ser_status = NULL;",
            "        outdir = NCONF_get_string(conf, section, ENV_NEW_CERTS_DIR);"
        ],
        "index": 13
    },
    {
        "prt": "sc",
        "function_call": [
            "int SSL_check_private_key(const SSL *ssl)\n{\n    const SSL_CONNECTION *sc;\n\n    if ((sc = SSL_CONNECTION_FROM_CONST_SSL(ssl)) == NULL) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_PASSED_NULL_PARAMETER);\n        return 0;\n    }\n    if (sc->cert->key->x509 == NULL) {\n        ERR_raise(ERR_LIB_SSL, SSL_R_NO_CERTIFICATE_ASSIGNED);\n        return 0;\n    }\n    if (sc->cert->key->privatekey == NULL) {\n        ERR_raise(ERR_LIB_SSL, SSL_R_NO_PRIVATE_KEY_ASSIGNED);\n        return 0;\n    }\n    return X509_check_private_key(sc->cert->key->x509,\n                                   sc->cert->key->privatekey);\n}"
        ],
        "sink": "if (sc->cert->key->x509 == NULL) {",
        "final_sink": "if (sc->cert->key->x509 == NULL) {",
        "source": [
            "            X509 *xi = sk_X509_value(cert_sk, i);"
        ],
        "index": 14
    },
    {
        "prt": "ptmp",
        "function_call": [
            "int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,\n                                   int purpose, int trust)\n{\n    int idx;\n\n    /* If purpose not set use default */\n    if (purpose == 0)\n        purpose = def_purpose;\n    /*\n     * If purpose is set but we don't have a default then set the default to\n     * the current purpose\n     */\n    else if (def_purpose == 0)\n        def_purpose = purpose;\n    /* If we have a purpose then check it is valid */\n    if (purpose != 0) {\n        X509_PURPOSE *ptmp;\n\n        idx = X509_PURPOSE_get_by_id(purpose);\n        if (idx == -1) {\n            ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_PURPOSE_ID);\n            return 0;\n        }\n        ptmp = X509_PURPOSE_get0(idx);\n        if (ptmp->trust == X509_TRUST_DEFAULT) {\n            idx = X509_PURPOSE_get_by_id(def_purpose);\n            if (idx == -1) {\n                ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_PURPOSE_ID);\n                return 0;\n            }\n            ptmp = X509_PURPOSE_get0(idx);\n        }\n        /* If trust not set then get from purpose default */\n        if (trust == 0)\n            trust = ptmp->trust;\n    }\n    if (trust != 0) {\n        idx = X509_TRUST_get_by_id(trust);\n        if (idx == -1) {\n            ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_TRUST_ID);\n            return 0;\n        }\n    }\n\n    if (ctx->param->purpose == 0 && purpose != 0)\n        ctx->param->purpose = purpose;\n    if (ctx->param->trust == 0 && trust != 0)\n        ctx->param->trust = trust;\n    return 1;\n}"
        ],
        "sink": "if (ptmp->trust == X509_TRUST_DEFAULT) {",
        "final_sink": "if (ptmp->trust == X509_TRUST_DEFAULT) {",
        "source": [
            "            pp = sk_OPENSSL_PSTRING_value(db->db->data, i);"
        ],
        "index": 15
    }
]